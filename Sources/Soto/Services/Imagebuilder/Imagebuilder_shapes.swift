//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Imagebuilder {
    // MARK: Enums

    public enum BuildType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `import` = "IMPORT"
        case scheduled = "SCHEDULED"
        case userInitiated = "USER_INITIATED"
        public var description: String { return self.rawValue }
    }

    public enum ComponentFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case shell = "SHELL"
        public var description: String { return self.rawValue }
    }

    public enum ComponentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum ComponentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case build = "BUILD"
        case test = "TEST"
        public var description: String { return self.rawValue }
    }

    public enum ContainerRepositoryService: String, CustomStringConvertible, Codable, _SotoSendable {
        case ecr = "ECR"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable, _SotoSendable {
        case docker = "DOCKER"
        public var description: String { return self.rawValue }
    }

    public enum DiskImageFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case raw = "RAW"
        case vhd = "VHD"
        case vmdk = "VMDK"
        public var description: String { return self.rawValue }
    }

    public enum EbsVolumeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        public var description: String { return self.rawValue }
    }

    public enum ImageStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "AVAILABLE"
        case building = "BUILDING"
        case cancelled = "CANCELLED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deprecated = "DEPRECATED"
        case distributing = "DISTRIBUTING"
        case failed = "FAILED"
        case integrating = "INTEGRATING"
        case pending = "PENDING"
        case testing = "TESTING"
        public var description: String { return self.rawValue }
    }

    public enum ImageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ami = "AMI"
        case docker = "DOCKER"
        public var description: String { return self.rawValue }
    }

    public enum Ownership: String, CustomStringConvertible, Codable, _SotoSendable {
        case amazon = "Amazon"
        case _self = "Self"
        case shared = "Shared"
        public var description: String { return self.rawValue }
    }

    public enum PipelineExecutionStartCondition: String, CustomStringConvertible, Codable, _SotoSendable {
        case expressionMatchAndDependencyUpdatesAvailable = "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
        case expressionMatchOnly = "EXPRESSION_MATCH_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum PipelineStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Platform: String, CustomStringConvertible, Codable, _SotoSendable {
        case linux = "Linux"
        case windows = "Windows"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AdditionalInstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains settings for the Systems Manager agent on your build instance.
        public let systemsManagerAgent: SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch
        /// 			your build instance.
        /// 		       The userDataOverride property replaces any commands that Image Builder might have added to ensure
        /// 			that Systems Manager is installed on your Linux build instance. If you override the user data,
        /// 			make sure that you add commands to install Systems Manager, if it is not pre-installed on your
        /// 			base image.
        ///
        /// 			         The user data is always base 64 encoded. For example, the
        /// 				following commands are encoded as IyEvYmluL2Jhc2gKbWtkaXIgLXAgL3Zhci9iYi8KdG91Y2ggL3Zhci$:
        ///
        /// 			          #!/bin/bash
        /// 			         mkdir -p /var/bb/
        /// 			         touch /var
        ///
        public let userDataOverride: String?

        public init(systemsManagerAgent: SystemsManagerAgent? = nil, userDataOverride: String? = nil) {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, max: 21847)
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, min: 1)
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case systemsManagerAgent
            case userDataOverride
        }
    }

    public struct Ami: AWSDecodableShape {
        /// The account ID of the owner of the AMI.
        public let accountId: String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public let description: String?
        /// The AMI ID of the Amazon EC2 AMI.
        public let image: String?
        /// The name of the Amazon EC2 AMI.
        public let name: String?
        /// The Amazon Web Services Region of the Amazon EC2 AMI.
        public let region: String?
        public let state: ImageState?

        public init(accountId: String? = nil, description: String? = nil, image: String? = nil, name: String? = nil, region: String? = nil, state: ImageState? = nil) {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case description
            case image
            case name
            case region
            case state
        }
    }

    public struct AmiDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The tags to apply to AMIs distributed to this Region.
        public let amiTags: [String: String]?
        /// The description of the AMI distribution configuration. Minimum and maximum length are in characters.
        public let description: String?
        /// The KMS key identifier used to encrypt the distributed image.
        public let kmsKeyId: String?
        ///  Launch permissions can be used to configure which Amazon Web Services accounts can use the AMI to launch
        /// 			instances.
        public let launchPermission: LaunchPermissionConfiguration?
        /// The name of the output AMI.
        public let name: String?
        /// The ID of an account to which you want to distribute an image.
        public let targetAccountIds: [String]?

        public init(amiTags: [String: String]? = nil, description: String? = nil, kmsKeyId: String? = nil, launchPermission: LaunchPermissionConfiguration? = nil, name: String? = nil, targetAccountIds: [String]? = nil) {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }

        public func validate(name: String) throws {
            try self.amiTags?.forEach {
                try validate($0.key, name: "amiTags.key", parent: name, max: 128)
                try validate($0.key, name: "amiTags.key", parent: name, min: 1)
                try validate($0.key, name: "amiTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "amiTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.amiTags, name: "amiTags", parent: name, max: 50)
            try self.validate(self.amiTags, name: "amiTags", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.launchPermission?.validate(name: "\(name).launchPermission")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z0-9{][-_A-Za-z0-9\\s:{}\\.]+[-_A-Za-z0-9}]$")
            try self.targetAccountIds?.forEach {
                try validate($0, name: "targetAccountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.targetAccountIds, name: "targetAccountIds", parent: name, max: 1536)
            try self.validate(self.targetAccountIds, name: "targetAccountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amiTags
            case description
            case kmsKeyId
            case launchPermission
            case name
            case targetAccountIds
        }
    }

    public struct CancelImageCreationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image whose creation you want to cancel.
        public let imageBuildVersionArn: String

        public init(clientToken: String = CancelImageCreationRequest.idempotencyToken(), imageBuildVersionArn: String) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
        }
    }

    public struct CancelImageCreationResponse: AWSDecodableShape {
        /// The idempotency token that was used for this request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image whose creation has been cancelled.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct Component: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description of the component.
        public let changeDescription: String?
        /// Component data contains the YAML document content for the component.
        public let data: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The encryption status of the component.
        public let encrypted: Bool?
        /// The KMS key identifier used to encrypt the component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// Contains parameter details for each of the parameters that are defined for the component.
        public let parameters: [ComponentParameterDetail]?
        /// The platform of the component.
        public let platform: Platform?
        /// Describes the current status of the component. This is used for
        /// 			components that are no longer active.
        public let state: ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public let supportedOsVersions: [String]?
        /// The tags associated with the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only
        /// 			to test it.
        public let type: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, data: String? = nil, dateCreated: String? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, parameters: [ComponentParameterDetail]? = nil, platform: Platform? = nil, state: ComponentState? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case changeDescription
            case data
            case dateCreated
            case description
            case encrypted
            case kmsKeyId
            case name
            case owner
            case parameters
            case platform
            case state
            case supportedOsVersions
            case tags
            case type
            case version
        }
    }

    public struct ComponentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let componentArn: String
        /// A group of parameter settings that are used to configure the component for a specific recipe.
        public let parameters: [ComponentParameter]?

        public init(componentArn: String, parameters: [ComponentParameter]? = nil) {
            self.componentArn = componentArn
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
            try self.parameters?.forEach {
                try $0.validate(name: "\(name).parameters[]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn
            case parameters
        }
    }

    public struct ComponentParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component parameter to set.
        public let name: String
        /// Sets the value for the named component parameter.
        public let value: [String]

        public init(name: String, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\x00]+$")
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^[^\\x00]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct ComponentParameterDetail: AWSDecodableShape {
        /// The default value of this parameter if no input is provided.
        public let defaultValue: [String]?
        /// Describes this parameter.
        public let description: String?
        /// The name of this input parameter.
        public let name: String
        /// The type of input this parameter provides. The currently supported value is "string".
        public let type: String

        public init(defaultValue: [String]? = nil, description: String? = nil, name: String, type: String) {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue
            case description
            case name
            case type
        }
    }

    public struct ComponentState: AWSDecodableShape {
        /// Describes how or why the component changed state.
        public let reason: String?
        /// The current state of the component.
        public let status: ComponentStatus?

        public init(reason: String? = nil, status: ComponentStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason
            case status
        }
    }

    public struct ComponentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description of the component.
        public let changeDescription: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// Describes the current status of the component.
        public let state: ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public let supportedOsVersions: [String]?
        /// The tags associated with the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only
        /// 			to test it.
        public let type: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, state: ComponentState? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case changeDescription
            case dateCreated
            case description
            case name
            case owner
            case platform
            case state
            case supportedOsVersions
            case tags
            case type
            case version
        }
    }

    public struct ComponentVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        ///
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// 			               Version ARNs have only the first three nodes: ..
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        ///
        ///
        public let arn: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// he operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public let supportedOsVersions: [String]?
        /// The type of the component denotes whether the component is used to build the image or only
        /// 			to test it.
        public let type: ComponentType?
        /// The semantic version of the component.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			          Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        ///
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case description
            case name
            case owner
            case platform
            case supportedOsVersions
            case type
            case version
        }
    }

    public struct Container: AWSDecodableShape {
        /// A list of URIs for containers created in the context Region.
        public let imageUris: [String]?
        /// Containers and container images are Region-specific. This is the Region context for the container.
        public let region: String?

        public init(imageUris: [String]? = nil, region: String? = nil) {
            self.imageUris = imageUris
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case imageUris
            case region
        }
    }

    public struct ContainerDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Tags that are attached to the container distribution configuration.
        public let containerTags: [String]?
        /// The description of the container distribution configuration.
        public let description: String?
        /// The destination repository for the container distribution configuration.
        public let targetRepository: TargetContainerRepository

        public init(containerTags: [String]? = nil, description: String? = nil, targetRepository: TargetContainerRepository) {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }

        public func validate(name: String) throws {
            try self.containerTags?.forEach {
                try validate($0, name: "containerTags[]", parent: name, max: 1024)
                try validate($0, name: "containerTags[]", parent: name, min: 1)
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.targetRepository.validate(name: "\(name).targetRepository")
        }

        private enum CodingKeys: String, CodingKey {
            case containerTags
            case description
            case targetRepository
        }
    }

    public struct ContainerRecipe: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe.
        ///
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// 			               Version ARNs have only the first three nodes: ..
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        ///
        ///
        public let arn: String?
        /// Components for build and test that are included in the container recipe.
        public let components: [ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public let containerType: ContainerType?
        /// The date when this container recipe was created.
        public let dateCreated: String?
        /// The description of the container recipe.
        public let description: String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
        public let dockerfileTemplateData: String?
        /// A flag that indicates if the target container is encrypted.
        public let encrypted: Bool?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public let instanceConfiguration: InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to the target Region.
        public let kmsKeyId: String?
        /// The name of the container recipe.
        public let name: String?
        /// The owner of the container recipe.
        public let owner: String?
        /// The base image for the container recipe.
        public let parentImage: String?
        /// The system platform for the container, such as Windows or Linux.
        public let platform: Platform?
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?
        /// The destination repository for the container image.
        public let targetRepository: TargetContainerRepository?
        /// The semantic version of the container recipe.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			          Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        ///
        public let version: String?
        /// The working directory for use during build and test workflows.
        public let workingDirectory: String?

        public init(arn: String? = nil, components: [ComponentConfiguration]? = nil, containerType: ContainerType? = nil, dateCreated: String? = nil, description: String? = nil, dockerfileTemplateData: String? = nil, encrypted: Bool? = nil, instanceConfiguration: InstanceConfiguration? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, targetRepository: TargetContainerRepository? = nil, version: String? = nil, workingDirectory: String? = nil) {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case components
            case containerType
            case dateCreated
            case description
            case dockerfileTemplateData
            case encrypted
            case instanceConfiguration
            case kmsKeyId
            case name
            case owner
            case parentImage
            case platform
            case tags
            case targetRepository
            case version
            case workingDirectory
        }
    }

    public struct ContainerRecipeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public let arn: String?
        /// Specifies the type of container, such as "Docker".
        public let containerType: ContainerType?
        /// The date when this container recipe was created.
        public let dateCreated: String?
        /// The name of the container recipe.
        public let name: String?
        /// The owner of the container recipe.
        public let owner: String?
        /// The base image for the container recipe.
        public let parentImage: String?
        /// The system platform for the container, such as Windows or Linux.
        public let platform: Platform?
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, containerType: ContainerType? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case containerType
            case dateCreated
            case name
            case owner
            case parentImage
            case platform
            case tags
        }
    }

    public struct CreateComponentRequest: AWSEncodableShape {
        /// The change description of the component. Describes what change has been made in this
        /// 			version, or what makes this version different from other versions of this component.
        public let changeDescription: String?
        /// The idempotency token of the component.
        public let clientToken: String
        /// Component data contains inline YAML document content for the component.
        /// 			Alternatively, you can specify the uri of a YAML document file stored in
        /// 			Amazon S3. However, you cannot specify both properties.
        public let data: String?
        /// The description of the component. Describes the contents of the component.
        public let description: String?
        /// The ID of the KMS key that should be used to encrypt this component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String
        /// The platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version syntax.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        ///
        public let semanticVersion: String
        ///  The operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public let supportedOsVersions: [String]?
        /// The tags of the component.
        public let tags: [String: String]?
        /// The uri of a YAML component document file. This must be an S3 URL
        /// 			(s3://bucket/key), and the requester must have permission to access
        /// 			the S3 bucket it points to. If you use Amazon S3, you can specify component content
        /// 			up to your service quota.
        /// 		       Alternatively, you can specify the YAML document inline, using the component
        /// 			data property. You cannot specify both properties.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = CreateComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 16000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, pattern: "^[^\\x00]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.supportedOsVersions?.forEach {
                try validate($0, name: "supportedOsVersions[]", parent: name, min: 1)
            }
            try self.validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, max: 25)
            try self.validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription
            case clientToken
            case data
            case description
            case kmsKeyId
            case name
            case platform
            case semanticVersion
            case supportedOsVersions
            case tags
            case uri
        }
    }

    public struct CreateComponentResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the component that was created by this request.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case componentBuildVersionArn
            case requestId
        }
    }

    public struct CreateContainerRecipeRequest: AWSEncodableShape {
        /// The client token used to make this request idempotent.
        public let clientToken: String
        /// Components for build and test that are included in the container recipe.
        public let components: [ComponentConfiguration]
        /// The type of container to create.
        public let containerType: ContainerType
        /// The description of the container recipe.
        public let description: String?
        /// The Dockerfile template used to build your image as an inline data blob.
        public let dockerfileTemplateData: String?
        /// The Amazon S3 URI for the Dockerfile that will be used to build your container image.
        public let dockerfileTemplateUri: String?
        /// Specifies the operating system version for the base image.
        public let imageOsVersionOverride: String?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public let instanceConfiguration: InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image.
        public let kmsKeyId: String?
        /// The name of the container recipe.
        public let name: String
        /// The base image for the container recipe.
        public let parentImage: String
        /// Specifies the operating system platform when you use a custom base image.
        public let platformOverride: Platform?
        /// The semantic version of the container recipe. This version follows the semantic version syntax.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        ///
        public let semanticVersion: String
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?
        /// The destination repository for the container image.
        public let targetRepository: TargetContainerRepository
        /// The working directory for use during build and test workflows.
        public let workingDirectory: String?

        public init(clientToken: String = CreateContainerRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], containerType: ContainerType, description: String? = nil, dockerfileTemplateData: String? = nil, dockerfileTemplateUri: String? = nil, imageOsVersionOverride: String? = nil, instanceConfiguration: InstanceConfiguration? = nil, kmsKeyId: String? = nil, name: String, parentImage: String, platformOverride: Platform? = nil, semanticVersion: String, tags: [String: String]? = nil, targetRepository: TargetContainerRepository, workingDirectory: String? = nil) {
            self.clientToken = clientToken
            self.components = components
            self.containerType = containerType
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.dockerfileTemplateUri = dockerfileTemplateUri
            self.imageOsVersionOverride = imageOsVersionOverride
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.parentImage = parentImage
            self.platformOverride = platformOverride
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.targetRepository = targetRepository
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try self.validate(self.components, name: "components", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, max: 16000)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, min: 1)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, pattern: "^[^\\x00]+$")
            try self.validate(self.imageOsVersionOverride, name: "imageOsVersionOverride", parent: name, max: 1024)
            try self.validate(self.imageOsVersionOverride, name: "imageOsVersionOverride", parent: name, min: 1)
            try self.instanceConfiguration?.validate(name: "\(name).instanceConfiguration")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try self.validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.targetRepository.validate(name: "\(name).targetRepository")
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1024)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case components
            case containerType
            case description
            case dockerfileTemplateData
            case dockerfileTemplateUri
            case imageOsVersionOverride
            case instanceConfiguration
            case kmsKeyId
            case name
            case parentImage
            case platformOverride
            case semanticVersion
            case tags
            case targetRepository
            case workingDirectory
        }
    }

    public struct CreateContainerRecipeResponse: AWSDecodableShape {
        /// The client token used to make this request idempotent.
        public let clientToken: String?
        /// Returns the Amazon Resource Name (ARN) of the container recipe that the request created.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case requestId
        }
    }

    public struct CreateDistributionConfigurationRequest: AWSEncodableShape {
        ///  The idempotency token of the distribution configuration.
        public let clientToken: String
        ///  The description of the distribution configuration.
        public let description: String?
        ///  The distributions of the distribution configuration.
        public let distributions: [Distribution]
        ///  The name of the distribution configuration.
        public let name: String
        ///  The tags of the distribution configuration.
        public let tags: [String: String]?

        public init(clientToken: String = CreateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributions: [Distribution], name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case distributions
            case name
            case tags
        }
    }

    public struct CreateDistributionConfigurationResponse: AWSDecodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that was created by this
        /// 			request.
        public let distributionConfigurationArn: String?
        ///  The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case distributionConfigurationArn
            case requestId
        }
    }

    public struct CreateImagePipelineRequest: AWSEncodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.
        public let containerRecipeArn: String?
        ///  The description of the image pipeline.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that will be used to
        /// 			configure and distribute images created by this image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        ///  The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
        /// 			created by this image pipeline.
        public let imageRecipeArn: String?
        ///  The image test configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        ///  The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
        /// 			build images created by this image pipeline.
        public let infrastructureConfigurationArn: String
        ///  The name of the image pipeline.
        public let name: String
        ///  The schedule of the image pipeline.
        public let schedule: Schedule?
        ///  The status of the image pipeline.
        public let status: PipelineStatus?
        ///  The tags of the image pipeline.
        public let tags: [String: String]?

        public init(clientToken: String = CreateImagePipelineRequest.idempotencyToken(), containerRecipeArn: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, name: String, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.schedule?.validate(name: "\(name).schedule")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case description
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case name
            case schedule
            case status
            case tags
        }
    }

    public struct CreateImagePipelineResponse: AWSDecodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the image pipeline that was created by this request.
        public let imagePipelineArn: String?
        ///  The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imagePipelineArn
            case requestId
        }
    }

    public struct CreateImageRecipeRequest: AWSEncodableShape {
        /// Specify additional settings and launch scripts for your build instances.
        public let additionalInstanceConfiguration: AdditionalInstanceConfiguration?
        /// The block device mappings of the image recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The components of the image recipe.
        public let components: [ComponentConfiguration]
        ///  The description of the image recipe.
        public let description: String?
        ///  The name of the image recipe.
        public let name: String
        /// The base image of the image recipe. The value of the string can be the ARN of the base
        /// 			image or an AMI ID. The format for the ARN follows this example:
        /// 			arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x.
        /// 			You can provide the specific version that you want to use, or you can use a wildcard in
        /// 			all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI,
        /// 			and the AMI must be in the same Region in which you are using Image Builder.
        public let parentImage: String
        /// The semantic version of the image recipe. This version follows the semantic version syntax.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        ///
        public let semanticVersion: String
        ///  The tags of the image recipe.
        public let tags: [String: String]?
        /// The working directory used during build and test workflows.
        public let workingDirectory: String?

        public init(additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, clientToken: String = CreateImageRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], description: String? = nil, name: String, parentImage: String, semanticVersion: String, tags: [String: String]? = nil, workingDirectory: String? = nil) {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.blockDeviceMappings = blockDeviceMappings
            self.clientToken = clientToken
            self.components = components
            self.description = description
            self.name = name
            self.parentImage = parentImage
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.additionalInstanceConfiguration?.validate(name: "\(name).additionalInstanceConfiguration")
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try self.validate(self.components, name: "components", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try self.validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1024)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInstanceConfiguration
            case blockDeviceMappings
            case clientToken
            case components
            case description
            case name
            case parentImage
            case semanticVersion
            case tags
            case workingDirectory
        }
    }

    public struct CreateImageRecipeResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image recipe that was created by this request.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageRecipeArn
            case requestId
        }
    }

    public struct CreateImageRequest: AWSEncodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.
        public let containerRecipeArn: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that defines and
        /// 			configures the outputs of your pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        ///  The Amazon Resource Name (ARN) of the image recipe that defines how images are
        /// 			configured, tested, and assessed.
        public let imageRecipeArn: String?
        ///  The image tests configuration of the image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        ///  The Amazon Resource Name (ARN) of the infrastructure configuration that defines the
        /// 			environment in which your image will be built and tested.
        public let infrastructureConfigurationArn: String
        ///  The tags of the image.
        public let tags: [String: String]?

        public init(clientToken: String = CreateImageRequest.idempotencyToken(), containerRecipeArn: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case tags
        }
    }

    public struct CreateImageResponse: AWSDecodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the image that was created by this request.
        public let imageBuildVersionArn: String?
        ///  The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct CreateInfrastructureConfigurationRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance metadata options that you can set for the HTTP requests that
        /// 			pipeline builds use to launch EC2 build and test instances.
        public let instanceMetadataOptions: InstanceMetadataOptions?
        /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more
        /// 			instance types to use for this build. The service will pick one of these instance types based
        /// 			on availability.
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. You can use this to log on to and debug
        /// 			the instance used to create your image.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications.
        ///
        /// 			         EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys
        /// 				from other accounts. The key that is used to encrypt the SNS topic must reside in the
        /// 				account that the Image Builder service runs under.
        ///
        public let snsTopicArn: String?
        /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to
        /// 			false if you want Image Builder to retain the instance used to configure your AMI if the build
        /// 			or test phase of your workflow fails.
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = CreateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, instanceMetadataOptions: InstanceMetadataOptions? = nil, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.instanceMetadataOptions?.validate(name: "\(name).instanceMetadataOptions")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 256)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try self.validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 30)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:[0-9]{12}:[a-zA-Z0-9-_]{1,256}$")
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case instanceMetadataOptions
            case instanceProfileName
            case instanceTypes
            case keyPair
            case logging
            case name
            case resourceTags
            case securityGroupIds
            case snsTopicArn
            case subnetId
            case tags
            case terminateInstanceOnFailure
        }
    }

    public struct CreateInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by
        /// 			this request.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case infrastructureConfigurationArn
            case requestId
        }
    }

    public struct DeleteComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentBuildVersionArn", location: .querystring("componentBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component build version to delete.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component build version that was deleted.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentBuildVersionArn
            case requestId
        }
    }

    public struct DeleteContainerRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "containerRecipeArn", location: .querystring("containerRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the container recipe to delete.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContainerRecipeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn
            case requestId
        }
    }

    public struct DeleteDistributionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "distributionConfigurationArn", location: .querystring("distributionConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDistributionConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationArn
            case requestId
        }
    }

    public struct DeleteImagePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imagePipelineArn", location: .querystring("imagePipelineArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image pipeline to delete.
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImagePipelineResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineArn
            case requestId
        }
    }

    public struct DeleteImageRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring("imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe to delete.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageRecipeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn
            case requestId
        }
    }

    public struct DeleteImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageBuildVersionArn", location: .querystring("imageBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Image Builder image resource that was deleted.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct DeleteInfrastructureConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "infrastructureConfigurationArn", location: .querystring("infrastructureConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationArn
            case requestId
        }
    }

    public struct Distribution: AWSEncodableShape & AWSDecodableShape {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public let amiDistributionConfiguration: AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing
        /// 			in a specific Region.
        public let containerDistributionConfiguration: ContainerDistributionConfiguration?
        /// The Windows faster-launching configurations to use for AMI distribution.
        public let fastLaunchConfigurations: [FastLaunchConfiguration]?
        /// A group of launchTemplateConfiguration settings that apply to image distribution
        /// 			for specified accounts.
        public let launchTemplateConfigurations: [LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified
        /// 			Region.
        public let licenseConfigurationArns: [String]?
        /// The target Region.
        public let region: String
        /// Configure export settings to deliver disk images created from your image build,
        /// 			using a file format that is compatible with your VMs in that Region.
        public let s3ExportConfiguration: S3ExportConfiguration?

        public init(amiDistributionConfiguration: AmiDistributionConfiguration? = nil, containerDistributionConfiguration: ContainerDistributionConfiguration? = nil, fastLaunchConfigurations: [FastLaunchConfiguration]? = nil, launchTemplateConfigurations: [LaunchTemplateConfiguration]? = nil, licenseConfigurationArns: [String]? = nil, region: String, s3ExportConfiguration: S3ExportConfiguration? = nil) {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.fastLaunchConfigurations = fastLaunchConfigurations
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
            self.s3ExportConfiguration = s3ExportConfiguration
        }

        public func validate(name: String) throws {
            try self.amiDistributionConfiguration?.validate(name: "\(name).amiDistributionConfiguration")
            try self.containerDistributionConfiguration?.validate(name: "\(name).containerDistributionConfiguration")
            try self.fastLaunchConfigurations?.forEach {
                try $0.validate(name: "\(name).fastLaunchConfigurations[]")
            }
            try self.validate(self.fastLaunchConfigurations, name: "fastLaunchConfigurations", parent: name, max: 1000)
            try self.validate(self.fastLaunchConfigurations, name: "fastLaunchConfigurations", parent: name, min: 1)
            try self.launchTemplateConfigurations?.forEach {
                try $0.validate(name: "\(name).launchTemplateConfigurations[]")
            }
            try self.validate(self.launchTemplateConfigurations, name: "launchTemplateConfigurations", parent: name, max: 100)
            try self.validate(self.launchTemplateConfigurations, name: "launchTemplateConfigurations", parent: name, min: 1)
            try self.licenseConfigurationArns?.forEach {
                try validate($0, name: "licenseConfigurationArns[]", parent: name, pattern: "^arn:aws[^:]*:license-manager:[^:]+:[0-9]{12}:license-configuration:lic-[a-z0-9-_]{32}$")
            }
            try self.validate(self.licenseConfigurationArns, name: "licenseConfigurationArns", parent: name, max: 50)
            try self.validate(self.licenseConfigurationArns, name: "licenseConfigurationArns", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, max: 1024)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.s3ExportConfiguration?.validate(name: "\(name).s3ExportConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case amiDistributionConfiguration
            case containerDistributionConfiguration
            case fastLaunchConfigurations
            case launchTemplateConfigurations
            case licenseConfigurationArns
            case region
            case s3ExportConfiguration
        }
    }

    public struct DistributionConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which this distribution configuration was created.
        public let dateCreated: String?
        /// The date on which this distribution configuration was last updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The distribution objects that apply Region-specific
        /// 			settings for the deployment of the image to targeted Regions.
        public let distributions: [Distribution]?
        /// The name of the distribution configuration.
        public let name: String?
        /// The tags of the distribution configuration.
        public let tags: [String: String]?
        /// The maximum duration in minutes for this distribution configuration.
        public let timeoutMinutes: Int

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributions: [Distribution]? = nil, name: String? = nil, tags: [String: String]? = nil, timeoutMinutes: Int) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case distributions
            case name
            case tags
            case timeoutMinutes
        }
    }

    public struct DistributionConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which the distribution configuration was created.
        public let dateCreated: String?
        /// The date on which the distribution configuration was updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The name of the distribution configuration.
        public let name: String?
        /// A list of Regions where the container image is distributed to.
        public let regions: [String]?
        /// The tags associated with the distribution configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, name: String? = nil, regions: [String]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case name
            case regions
            case tags
        }
    }

    public struct EbsInstanceBlockDeviceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Use to configure delete on termination of the associated device.
        public let deleteOnTermination: Bool?
        /// Use to configure device encryption.
        public let encrypted: Bool?
        /// Use to configure device IOPS.
        public let iops: Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public let kmsKeyId: String?
        /// The snapshot that defines the device contents.
        public let snapshotId: String?
        ///  For GP3 volumes only 
        /// 			The throughput in MiB/s that the volume supports.
        public let throughput: Int?
        /// Use to override the device's volume size.
        public let volumeSize: Int?
        /// Use to override the device's volume type.
        public let volumeType: EbsVolumeType?

        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, snapshotId: String? = nil, throughput: Int? = nil, volumeSize: Int? = nil, volumeType: EbsVolumeType? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 64000)
            try self.validate(self.iops, name: "iops", parent: name, min: 100)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 1024)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 1)
            try self.validate(self.throughput, name: "throughput", parent: name, max: 1000)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 125)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, max: 16000)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination
            case encrypted
            case iops
            case kmsKeyId
            case snapshotId
            case throughput
            case volumeSize
            case volumeType
        }
    }

    public struct FastLaunchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The owner account ID for the fast-launch enabled Windows AMI.
        public let accountId: String?
        /// A Boolean that represents the current state of faster launching for the
        /// 			Windows AMI. Set to true to start using Windows faster launching, or
        /// 			false to stop using it.
        public let enabled: Bool
        /// The launch template that the fast-launch enabled Windows AMI uses when it
        /// 			launches Windows instances to create pre-provisioned snapshots.
        public let launchTemplate: FastLaunchLaunchTemplateSpecification?
        /// The maximum number of parallel instances that are launched for creating
        /// 			resources.
        public let maxParallelLaunches: Int?
        /// Configuration settings for managing the number of snapshots that are
        /// 			created from pre-provisioned instances for the Windows AMI when faster
        /// 			launching is enabled.
        public let snapshotConfiguration: FastLaunchSnapshotConfiguration?

        public init(accountId: String? = nil, enabled: Bool, launchTemplate: FastLaunchLaunchTemplateSpecification? = nil, maxParallelLaunches: Int? = nil, snapshotConfiguration: FastLaunchSnapshotConfiguration? = nil) {
            self.accountId = accountId
            self.enabled = enabled
            self.launchTemplate = launchTemplate
            self.maxParallelLaunches = maxParallelLaunches
            self.snapshotConfiguration = snapshotConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.launchTemplate?.validate(name: "\(name).launchTemplate")
            try self.validate(self.maxParallelLaunches, name: "maxParallelLaunches", parent: name, max: 10000)
            try self.validate(self.maxParallelLaunches, name: "maxParallelLaunches", parent: name, min: 1)
            try self.snapshotConfiguration?.validate(name: "\(name).snapshotConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case enabled
            case launchTemplate
            case maxParallelLaunches
            case snapshotConfiguration
        }
    }

    public struct FastLaunchLaunchTemplateSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the launch template to use for faster launching for a Windows AMI.
        public let launchTemplateId: String?
        /// The name of the launch template to use for faster launching for a Windows AMI.
        public let launchTemplateName: String?
        /// The version of the launch template to use for faster launching for a Windows AMI.
        public let launchTemplateVersion: String?

        public init(launchTemplateId: String? = nil, launchTemplateName: String? = nil, launchTemplateVersion: String? = nil) {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.launchTemplateVersion = launchTemplateVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "^lt-[a-z0-9-_]{17}$")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, max: 1024)
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, min: 1)
            try self.validate(self.launchTemplateVersion, name: "launchTemplateVersion", parent: name, max: 1024)
            try self.validate(self.launchTemplateVersion, name: "launchTemplateVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateId
            case launchTemplateName
            case launchTemplateVersion
        }
    }

    public struct FastLaunchSnapshotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled
        /// 			Windows AMI.
        public let targetResourceCount: Int?

        public init(targetResourceCount: Int? = nil) {
            self.targetResourceCount = targetResourceCount
        }

        public func validate(name: String) throws {
            try self.validate(self.targetResourceCount, name: "targetResourceCount", parent: name, max: 10000)
            try self.validate(self.targetResourceCount, name: "targetResourceCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetResourceCount
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter. Filter names are case-sensitive.
        public let name: String?
        /// The filter values. Filter values are case-sensitive.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]{1,1024}$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z./_ :-]{1,1024}$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case values
        }
    }

    public struct GetComponentPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentArn", location: .querystring("componentArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.
        public let componentArn: String

        public init(componentArn: String) {
            self.componentArn = componentArn
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentPolicyResponse: AWSDecodableShape {
        /// The component policy.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentBuildVersionArn", location: .querystring("componentBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires
        /// 			"/\d+$" suffix.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentResponse: AWSDecodableShape {
        /// The component object associated with the specified ARN.
        public let component: Component?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(component: Component? = nil, requestId: String? = nil) {
            self.component = component
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case component
            case requestId
        }
    }

    public struct GetContainerRecipePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "containerRecipeArn", location: .querystring("containerRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the container recipe for the policy being requested.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContainerRecipePolicyResponse: AWSDecodableShape {
        /// The container recipe policy object that is returned.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetContainerRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "containerRecipeArn", location: .querystring("containerRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContainerRecipeResponse: AWSDecodableShape {
        /// The container recipe object that is returned.
        public let containerRecipe: ContainerRecipe?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipe: ContainerRecipe? = nil, requestId: String? = nil) {
            self.containerRecipe = containerRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipe
            case requestId
        }
    }

    public struct GetDistributionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "distributionConfigurationArn", location: .querystring("distributionConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to
        /// 			retrieve.
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDistributionConfigurationResponse: AWSDecodableShape {
        /// The distribution configuration object.
        public let distributionConfiguration: DistributionConfiguration?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfiguration: DistributionConfiguration? = nil, requestId: String? = nil) {
            self.distributionConfiguration = distributionConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfiguration
            case requestId
        }
    }

    public struct GetImagePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imagePipelineArn", location: .querystring("imagePipelineArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePipelineResponse: AWSDecodableShape {
        /// The image pipeline object.
        public let imagePipeline: ImagePipeline?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipeline: ImagePipeline? = nil, requestId: String? = nil) {
            self.imagePipeline = imagePipeline
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipeline
            case requestId
        }
    }

    public struct GetImagePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageArn", location: .querystring("imageArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
        public let imageArn: String

        public init(imageArn: String) {
            self.imageArn = imageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePolicyResponse: AWSDecodableShape {
        /// The image policy object.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetImageRecipePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring("imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipePolicyResponse: AWSDecodableShape {
        /// The image recipe policy object.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetImageRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring("imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipeResponse: AWSDecodableShape {
        /// The image recipe object.
        public let imageRecipe: ImageRecipe?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipe: ImageRecipe? = nil, requestId: String? = nil) {
            self.imageRecipe = imageRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipe
            case requestId
        }
    }

    public struct GetImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageBuildVersionArn", location: .querystring("imageBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image that you want to retrieve.
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageResponse: AWSDecodableShape {
        /// The image object.
        public let image: Image?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(image: Image? = nil, requestId: String? = nil) {
            self.image = image
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case image
            case requestId
        }
    }

    public struct GetInfrastructureConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "infrastructureConfigurationArn", location: .querystring("infrastructureConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
        /// 			retrieve.
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The infrastructure configuration object.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfiguration: InfrastructureConfiguration? = nil, requestId: String? = nil) {
            self.infrastructureConfiguration = infrastructureConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfiguration
            case requestId
        }
    }

    public struct Image: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image.
        ///
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// 			               Version ARNs have only the first three nodes: ..
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        ///
        ///
        public let arn: String?
        /// Indicates the type of build that created this image. The build can be initiated
        /// 			in the following ways:
        ///
        /// 				            USER_INITIATED  A manual
        /// 					pipeline build request.
        ///
        /// 				            SCHEDULED  A pipeline build
        /// 					initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// 				            IMPORT  A VM import created
        /// 					the image to use as the base image for the recipe.
        ///
        public let buildType: BuildType?
        /// The recipe that is used to create an Image Builder container image.
        public let containerRecipe: ContainerRecipe?
        /// The date on which this image was created.
        public let dateCreated: String?
        /// The distribution configuration used when creating this image.
        public let distributionConfiguration: DistributionConfiguration?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The image recipe used when creating the image.
        public let imageRecipe: ImageRecipe?
        /// The image tests configuration used when creating this image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The infrastructure used when creating this image.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
        /// 			Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The output resources produced when creating this image.
        public let outputResources: OutputResources?
        /// The platform of the image.
        public let platform: Platform?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public let sourcePipelineArn: String?
        /// The name of the image pipeline that created this image.
        public let sourcePipelineName: String?
        /// The state of the image.
        public let state: ImageState?
        /// The tags of the image.
        public let tags: [String: String]?
        /// Specifies whether this is an AMI or container image.
        public let type: ImageType?
        /// The semantic version of the image.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			          Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        ///
        public let version: String?

        public init(arn: String? = nil, buildType: BuildType? = nil, containerRecipe: ContainerRecipe? = nil, dateCreated: String? = nil, distributionConfiguration: DistributionConfiguration? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipe: ImageRecipe? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfiguration: InfrastructureConfiguration? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, platform: Platform? = nil, sourcePipelineArn: String? = nil, sourcePipelineName: String? = nil, state: ImageState? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.buildType = buildType
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipe = imageRecipe
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case buildType
            case containerRecipe
            case dateCreated
            case distributionConfiguration
            case enhancedImageMetadataEnabled
            case imageRecipe
            case imageTestsConfiguration
            case infrastructureConfiguration
            case name
            case osVersion
            case outputResources
            case platform
            case sourcePipelineArn
            case sourcePipelineName
            case state
            case tags
            case type
            case version
        }
    }

    public struct ImagePackage: AWSDecodableShape {
        /// The name of the package as reported to the operating system package manager.
        public let packageName: String?
        /// The version of the package as reported to the operating system package manager.
        public let packageVersion: String?

        public init(packageName: String? = nil, packageVersion: String? = nil) {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageName
            case packageVersion
        }
    }

    public struct ImagePipeline: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public let arn: String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.
        public let containerRecipeArn: String?
        /// The date on which this image pipeline was created.
        public let dateCreated: String?
        /// The date on which this image pipeline was last run.
        public let dateLastRun: String?
        /// The date on which this image pipeline will next be run.
        public let dateNextRun: String?
        /// The date on which this image pipeline was last updated.
        public let dateUpdated: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this
        /// 			image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image
        /// 			pipeline.
        public let imageRecipeArn: String?
        /// The image tests configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this
        /// 			image pipeline.
        public let infrastructureConfigurationArn: String?
        /// The name of the image pipeline.
        public let name: String?
        /// The platform of the image pipeline.
        public let platform: Platform?
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?
        /// The tags of this image pipeline.
        public let tags: [String: String]?

        public init(arn: String? = nil, containerRecipeArn: String? = nil, dateCreated: String? = nil, dateLastRun: String? = nil, dateNextRun: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String? = nil, name: String? = nil, platform: Platform? = nil, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case containerRecipeArn
            case dateCreated
            case dateLastRun
            case dateNextRun
            case dateUpdated
            case description
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case name
            case platform
            case schedule
            case status
            case tags
        }
    }

    public struct ImageRecipe: AWSDecodableShape {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to
        /// 			build and test your image configuration. Instance configuration adds a layer
        /// 			of control over those instances. You can define settings and add scripts to
        /// 			run when an instance is launched from your AMI.
        public let additionalInstanceConfiguration: AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The block device mappings to apply when creating images from this recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The components of the image recipe.
        public let components: [ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The description of the image recipe.
        public let description: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The base image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?
        /// Specifies which type of image is created by the recipe - an AMI or a
        /// 			container image.
        public let type: ImageType?
        /// The version of the image recipe.
        public let version: String?
        /// The working directory to be used during build and test workflows.
        public let workingDirectory: String?

        public init(additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil, arn: String? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, components: [ComponentConfiguration]? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil, workingDirectory: String? = nil) {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInstanceConfiguration
            case arn
            case blockDeviceMappings
            case components
            case dateCreated
            case description
            case name
            case owner
            case parentImage
            case platform
            case tags
            case type
            case version
            case workingDirectory
        }
    }

    public struct ImageRecipeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The base image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case name
            case owner
            case parentImage
            case platform
            case tags
        }
    }

    public struct ImageState: AWSDecodableShape {
        /// The reason for the image's status.
        public let reason: String?
        /// The status of the image.
        public let status: ImageStatus?

        public init(reason: String? = nil, status: ImageStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason
            case status
        }
    }

    public struct ImageSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image.
        public let arn: String?
        /// Indicates the type of build that created this image. The build can be initiated
        /// 			in the following ways:
        ///
        /// 				            USER_INITIATED  A manual
        /// 					pipeline build request.
        ///
        /// 				            SCHEDULED  A pipeline build
        /// 					initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// 				            IMPORT  A VM import created
        /// 					the image to use as the base image for the recipe.
        ///
        public let buildType: BuildType?
        /// The date on which this image was created.
        public let dateCreated: String?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
        /// 			Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The output resources produced when creating this image.
        public let outputResources: OutputResources?
        /// The owner of the image.
        public let owner: String?
        /// The platform of the image.
        public let platform: Platform?
        /// The state of the image.
        public let state: ImageState?
        /// The tags of the image.
        public let tags: [String: String]?
        /// Specifies whether this is an AMI or container image.
        public let type: ImageType?
        /// The version of the image.
        public let version: String?

        public init(arn: String? = nil, buildType: BuildType? = nil, dateCreated: String? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, owner: String? = nil, platform: Platform? = nil, state: ImageState? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case buildType
            case dateCreated
            case name
            case osVersion
            case outputResources
            case owner
            case platform
            case state
            case tags
            case type
            case version
        }
    }

    public struct ImageTestsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines if tests should run after building the image. Image Builder defaults
        /// 			to enable tests to run following the image build, before image distribution.
        public let imageTestsEnabled: Bool?
        /// The maximum time in minutes that tests are permitted to run.
        public let timeoutMinutes: Int?

        public init(imageTestsEnabled: Bool? = nil, timeoutMinutes: Int? = nil) {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, max: 1440)
            try self.validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case imageTestsEnabled
            case timeoutMinutes
        }
    }

    public struct ImageVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a specific version of an Image Builder image.
        ///
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// 			               Version ARNs have only the first three nodes: ..
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        ///
        ///
        public let arn: String?
        /// Indicates the type of build that created this image. The build can be initiated
        /// 			in the following ways:
        ///
        /// 				            USER_INITIATED  A manual
        /// 					pipeline build request.
        ///
        /// 				            SCHEDULED  A pipeline build
        /// 					initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// 				            IMPORT  A VM import created
        /// 					the image to use as the base image for the recipe.
        ///
        public let buildType: BuildType?
        /// The date on which this specific version of the Image Builder image was created.
        public let dateCreated: String?
        /// The name of this specific version of an Image Builder image.
        public let name: String?
        /// The operating system version of the Amazon EC2 build instance. For example, Amazon Linux 2, Ubuntu 18, or
        /// 			Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The owner of the image version.
        public let owner: String?
        /// The platform of the image version, for example "Windows" or "Linux".
        public let platform: Platform?
        /// Specifies whether this image is an AMI or a container image.
        public let type: ImageType?
        /// Details for a specific version of an Image Builder image. This version follows the semantic version syntax.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			          Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        ///
        public let version: String?

        public init(arn: String? = nil, buildType: BuildType? = nil, dateCreated: String? = nil, name: String? = nil, osVersion: String? = nil, owner: String? = nil, platform: Platform? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case buildType
            case dateCreated
            case name
            case osVersion
            case owner
            case platform
            case type
            case version
        }
    }

    public struct ImportComponentRequest: AWSEncodableShape {
        /// The change description of the component. Describes what change has been made in this
        /// 			version, or what makes this version different from other versions of this component.
        public let changeDescription: String?
        /// The idempotency token of the component.
        public let clientToken: String
        /// The data of the component. Used to specify the data inline. Either data or
        /// 			uri can be used to specify the data within the component.
        public let data: String?
        /// The description of the component. Describes the contents of the component.
        public let description: String?
        /// The format of the resource that you want to import as a component.
        public let format: ComponentFormat
        /// The ID of the KMS key that should be used to encrypt this component.
        public let kmsKeyId: String?
        ///  The name of the component.
        public let name: String
        /// The platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version syntax.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        ///
        public let semanticVersion: String
        /// The tags of the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image, or only
        /// 			to test it.
        public let type: ComponentType
        /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to
        /// 			access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service
        /// 			quota. Either data or uri can be used to specify the data within the
        /// 			component.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = ImportComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, format: ComponentFormat, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, tags: [String: String]? = nil, type: ComponentType, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.format = format
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 1024)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription
            case clientToken
            case data
            case description
            case format
            case kmsKeyId
            case name
            case platform
            case semanticVersion
            case tags
            case type
            case uri
        }
    }

    public struct ImportComponentResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the imported component.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case componentBuildVersionArn
            case requestId
        }
    }

    public struct ImportVmImageRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The description for the base image that is created by the import process.
        public let description: String?
        /// The name of the base image that is created by the import process.
        public let name: String
        /// The operating system version for the imported VM.
        public let osVersion: String?
        /// The operating system platform for the imported VM.
        public let platform: Platform
        /// The semantic version to attach to the base image that was created during the
        /// 			import process. This version follows the semantic version syntax.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			          Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        ///
        public let semanticVersion: String
        /// Tags that are attached to the import resources.
        public let tags: [String: String]?
        /// The importTaskId (API) or ImportTaskId (CLI) from the
        /// 			Amazon EC2 VM import process. Image Builder retrieves information from the import process to pull
        /// 			in the AMI that is created from the VM source as the base image for your recipe.
        public let vmImportTaskId: String

        public init(clientToken: String = ImportVmImageRequest.idempotencyToken(), description: String? = nil, name: String, osVersion: String? = nil, platform: Platform, semanticVersion: String, tags: [String: String]? = nil, vmImportTaskId: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.osVersion = osVersion
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.vmImportTaskId = vmImportTaskId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.osVersion, name: "osVersion", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.vmImportTaskId, name: "vmImportTaskId", parent: name, max: 1024)
            try self.validate(self.vmImportTaskId, name: "vmImportTaskId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case name
            case osVersion
            case platform
            case semanticVersion
            case tags
            case vmImportTaskId
        }
    }

    public struct ImportVmImageResponse: AWSDecodableShape {
        /// The idempotency token that was used for this request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the AMI that was created during the VM
        /// 			import process. This AMI is used as the base image for the recipe that
        /// 			imported the VM.
        public let imageArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageArn = imageArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageArn
            case requestId
        }
    }

    public struct InfrastructureConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance metadata option settings for the infrastructure configuration.
        public let instanceMetadataOptions: InstanceMetadataOptions?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs of the infrastructure configuration.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications.
        ///
        /// 			         EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys
        /// 				from other accounts. The key that is used to encrypt the SNS topic must reside in the
        /// 				account that the Image Builder service runs under.
        ///
        public let snsTopicArn: String?
        /// The subnet ID of the infrastructure configuration.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure configuration of the infrastructure
        /// 			configuration.
        public let terminateInstanceOnFailure: Bool?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceMetadataOptions: InstanceMetadataOptions? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String? = nil, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case instanceMetadataOptions
            case instanceProfileName
            case instanceTypes
            case keyPair
            case logging
            case name
            case resourceTags
            case securityGroupIds
            case snsTopicArn
            case subnetId
            case tags
            case terminateInstanceOnFailure
        }
    }

    public struct InfrastructureConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags attached to the image created by Image Builder.
        public let resourceTags: [String: String]?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, name: String? = nil, resourceTags: [String: String]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.resourceTags = resourceTags
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case instanceProfileName
            case instanceTypes
            case name
            case resourceTags
            case tags
        }
    }

    public struct InstanceBlockDeviceMapping: AWSEncodableShape & AWSDecodableShape {
        /// The device to which these mappings apply.
        public let deviceName: String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public let ebs: EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the base image.
        public let noDevice: String?
        /// Use to manage instance ephemeral devices.
        public let virtualName: String?

        public init(deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 1024)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 1)
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.noDevice, name: "noDevice", parent: name, max: 0)
            try self.validate(self.virtualName, name: "virtualName", parent: name, max: 1024)
            try self.validate(self.virtualName, name: "virtualName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName
            case ebs
            case noDevice
            case virtualName
        }
    }

    public struct InstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the block devices to attach for building an instance from this Image Builder AMI.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not specified,
        /// 			Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public let image: String?

        public init(blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, image: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.image, name: "image", parent: name, max: 1024)
            try self.validate(self.image, name: "image", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappings
            case image
        }
    }

    public struct InstanceMetadataOptions: AWSEncodableShape & AWSDecodableShape {
        /// Limit the number of hops that an instance metadata request can traverse to reach its
        /// 			destination.
        public let httpPutResponseHopLimit: Int?
        /// Indicates whether a signed token header is required for instance metadata retrieval requests.
        /// 			The values affect the response as follows:
        ///
        /// 				            required  When you retrieve the
        /// 					IAM role credentials, version 2.0 credentials are returned in all cases.
        ///
        /// 				            optional  You can include a signed token header
        /// 					in your request to retrieve instance metadata, or you can leave it out. If you
        /// 					include it, version 2.0 credentials are returned for the IAM role. Otherwise,
        /// 					version 1.0 credentials are returned.
        ///
        /// 		       The default setting is optional.
        public let httpTokens: String?

        public init(httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil) {
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.httpPutResponseHopLimit, name: "httpPutResponseHopLimit", parent: name, max: 64)
            try self.validate(self.httpPutResponseHopLimit, name: "httpPutResponseHopLimit", parent: name, min: 1)
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "^optional|required$")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPutResponseHopLimit
            case httpTokens
        }
    }

    public struct LaunchPermissionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for an Organizations organizational unit (OU) that you want to share your AMI with. For more
        /// 			information about key concepts for Organizations, see Organizations terminology and concepts.
        public let organizationalUnitArns: [String]?
        /// The ARN for an Amazon Web Services Organization that you want to share your AMI with. For more information, see
        /// 			What is Organizations?.
        public let organizationArns: [String]?
        /// The name of the group.
        public let userGroups: [String]?
        /// The Amazon Web Services account ID.
        public let userIds: [String]?

        public init(organizationalUnitArns: [String]? = nil, organizationArns: [String]? = nil, userGroups: [String]? = nil, userIds: [String]? = nil) {
            self.organizationalUnitArns = organizationalUnitArns
            self.organizationArns = organizationArns
            self.userGroups = userGroups
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.organizationalUnitArns?.forEach {
                try validate($0, name: "organizationalUnitArns[]", parent: name, pattern: "^arn:aws[^:]*:organizations::[0-9]{12}:ou/o-[a-z0-9]{10,32}/ou-[0-9a-z]{4,32}-[0-9a-z]{8,32}$")
            }
            try self.validate(self.organizationalUnitArns, name: "organizationalUnitArns", parent: name, max: 25)
            try self.validate(self.organizationalUnitArns, name: "organizationalUnitArns", parent: name, min: 1)
            try self.organizationArns?.forEach {
                try validate($0, name: "organizationArns[]", parent: name, pattern: "^arn:aws[^:]*:organizations::[0-9]{12}:organization/o-[a-z0-9]{10,32}$")
            }
            try self.validate(self.organizationArns, name: "organizationArns", parent: name, max: 25)
            try self.validate(self.organizationArns, name: "organizationArns", parent: name, min: 1)
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 1024)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.userIds, name: "userIds", parent: name, max: 1536)
            try self.validate(self.userIds, name: "userIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case organizationalUnitArns
            case organizationArns
            case userGroups
            case userIds
        }
    }

    public struct LaunchTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The account ID that this configuration applies to.
        public let accountId: String?
        /// Identifies the Amazon EC2 launch template to use.
        public let launchTemplateId: String
        /// Set the specified Amazon EC2 launch template as the default launch template for the specified account.
        public let setDefaultVersion: Bool?

        public init(accountId: String? = nil, launchTemplateId: String, setDefaultVersion: Bool? = nil) {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "^lt-[a-z0-9-_]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case launchTemplateId
            case setDefaultVersion
        }
    }

    public struct ListComponentBuildVersionsRequest: AWSEncodableShape {
        /// The component version Amazon Resource Name (ARN) whose versions you want to list.
        public let componentVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?

        public init(componentVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.componentVersionArn = componentVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.componentVersionArn, name: "componentVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionArn
            case maxResults
            case nextToken
        }
    }

    public struct ListComponentBuildVersionsResponse: AWSDecodableShape {
        /// The list of component summaries for the specified semantic version.
        public let componentSummaryList: [ComponentSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentSummaryList: [ComponentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentSummaryList = componentSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {
        /// Returns the list of component build versions for the specified name.
        public let byName: Bool?
        /// Use the following filters to streamline results:
        /// 		          description     name     platform     supportedOsVersion     type     version
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?
        /// The owner defines which components you want to list. By default, this request will only
        /// 			show components owned by your account. You can use this field to specify if you want to view
        /// 			components owned by yourself, by Amazon, or those components that have been shared with you by
        /// 			other customers.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName
            case filters
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListComponentsResponse: AWSDecodableShape {
        /// The list of component semantic versions.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        ///
        public let componentVersionList: [ComponentVersion]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentVersionList: [ComponentVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentVersionList = componentVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionList
            case nextToken
            case requestId
        }
    }

    public struct ListContainerRecipesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:
        /// 		          containerType     name     parentImage     platform
        public let filters: [Filter]?
        /// The maximum number of results to return in the list.
        public let maxResults: Int?
        /// Provides a token for pagination, which determines where to begin the next set of results when the current set reaches the maximum for one request.
        public let nextToken: String?
        /// Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListContainerRecipesResponse: AWSDecodableShape {
        /// The list of container recipes returned for the request.
        public let containerRecipeSummaryList: [ContainerRecipeSummary]?
        /// The next token field is used for paginated responses. When this is not empty, there are additional container recipes that the service has not included in this response. Use this token with the next request to retrieve additional list items.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeSummaryList: [ContainerRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.containerRecipeSummaryList = containerRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListDistributionConfigurationsRequest: AWSEncodableShape {
        /// You can filter on name to streamline results.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListDistributionConfigurationsResponse: AWSDecodableShape {
        /// The list of distributions.
        public let distributionConfigurationSummaryList: [DistributionConfigurationSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfigurationSummaryList: [DistributionConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImageBuildVersionsRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:
        /// 		          name     osVersion     platform     type     version
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.
        public let imageVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imageVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imageVersionArn = imageVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.imageVersionArn, name: "imageVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case imageVersionArn
            case maxResults
            case nextToken
        }
    }

    public struct ListImageBuildVersionsResponse: AWSDecodableShape {
        /// The list of image build versions.
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImagePackagesRequest: AWSEncodableShape {
        /// Filter results for the ListImagePackages request by the Image Build Version ARN
        public let imageBuildVersionArn: String
        /// The maxiumum number of results to return from the ListImagePackages request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(imageBuildVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn
            case maxResults
            case nextToken
        }
    }

    public struct ListImagePackagesResponse: AWSDecodableShape {
        /// The list of Image Packages returned in the response.
        public let imagePackageList: [ImagePackage]?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePackageList: [ImagePackage]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePackageList = imagePackageList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePackageList
            case nextToken
            case requestId
        }
    }

    public struct ListImagePipelineImagesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:
        /// 		          name     version
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.
        public let imagePipelineArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imagePipelineArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imagePipelineArn = imagePipelineArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case imagePipelineArn
            case maxResults
            case nextToken
        }
    }

    public struct ListImagePipelineImagesResponse: AWSDecodableShape {
        /// The list of images built by this pipeline.
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImagePipelinesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:
        /// 		          description     distributionConfigurationArn     imageRecipeArn     infrastructureConfigurationArn     name     status
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListImagePipelinesResponse: AWSDecodableShape {
        /// The list of image pipelines.
        public let imagePipelineList: [ImagePipeline]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipelineList: [ImagePipeline]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePipelineList = imagePipelineList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineList
            case nextToken
            case requestId
        }
    }

    public struct ListImageRecipesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:
        /// 		          name     parentImage     platform
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?
        /// The owner defines which image recipes you want to list. By default, this request will only
        /// 			show image recipes owned by your account. You can use this field to specify if you want to
        /// 			view image recipes owned by yourself, by Amazon, or those image recipes that have been shared
        /// 			with you by other customers.
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListImageRecipesResponse: AWSDecodableShape {
        /// The list of image pipelines.
        public let imageRecipeSummaryList: [ImageRecipeSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeSummaryList: [ImageRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageRecipeSummaryList = imageRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {
        /// Requests a list of images with a specific recipe name.
        public let byName: Bool?
        /// Use the following filters to streamline results:
        /// 		          name     osVersion     platform     type     version
        public let filters: [Filter]?
        /// Includes deprecated images in the response list.
        public let includeDeprecated: Bool?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?
        /// The owner defines which images you want to list. By default, this request will only show
        /// 			images owned by your account. You can use this field to specify if you want to view images
        /// 			owned by yourself, by Amazon, or those images that have been shared with you by other
        /// 			customers.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, includeDeprecated: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.includeDeprecated = includeDeprecated
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName
            case filters
            case includeDeprecated
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {
        /// The list of image semantic versions.
        ///
        /// 			         The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			          Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        ///
        public let imageVersionList: [ImageVersion]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageVersionList: [ImageVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageVersionList = imageVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersionList
            case nextToken
            case requestId
        }
    }

    public struct ListInfrastructureConfigurationsRequest: AWSEncodableShape {
        /// You can filter on name to streamline results.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously
        /// 			truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListInfrastructureConfigurationsResponse: AWSDecodableShape {
        /// The list of infrastructure configurations.
        public let infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional
        /// 			elements that the service has not included in this request. Use this token with the next
        /// 			request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 logging configuration.
        public let s3Logs: S3Logs?

        public init(s3Logs: S3Logs? = nil) {
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Logs
        }
    }

    public struct OutputResources: AWSDecodableShape {
        /// The Amazon EC2 AMIs created by this image.
        public let amis: [Ami]?
        /// Container images that the pipeline has generated and stored in the output repository.
        public let containers: [Container]?

        public init(amis: [Ami]? = nil, containers: [Container]? = nil) {
            self.amis = amis
            self.containers = containers
        }

        private enum CodingKeys: String, CodingKey {
            case amis
            case containers
        }
    }

    public struct PutComponentPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the component that this policy should be applied to.
        public let componentArn: String
        /// The policy to apply.
        public let policy: String

        public init(componentArn: String, policy: String) {
            self.componentArn = componentArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn
            case policy
        }
    }

    public struct PutComponentPolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component that this policy was applied to.
        public let componentArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentArn: String? = nil, requestId: String? = nil) {
            self.componentArn = componentArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn
            case requestId
        }
    }

    public struct PutContainerRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.
        public let containerRecipeArn: String
        /// The policy to apply to the container recipe.
        public let policy: String

        public init(containerRecipeArn: String, policy: String) {
            self.containerRecipeArn = containerRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn
            case policy
        }
    }

    public struct PutContainerRecipePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn
            case requestId
        }
    }

    public struct PutImagePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image that this policy should be applied to.
        public let imageArn: String
        /// The policy to apply.
        public let policy: String

        public init(imageArn: String, policy: String) {
            self.imageArn = imageArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn
            case policy
        }
    }

    public struct PutImagePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
        public let imageArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageArn: String? = nil, requestId: String? = nil) {
            self.imageArn = imageArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn
            case requestId
        }
    }

    public struct PutImageRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.
        public let imageRecipeArn: String
        /// The policy to apply.
        public let policy: String

        public init(imageRecipeArn: String, policy: String) {
            self.imageRecipeArn = imageRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn
            case policy
        }
    }

    public struct PutImageRecipePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn
            case requestId
        }
    }

    public struct S3ExportConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Export the updated image to one of the following supported disk
        /// 			image formats:
        ///
        /// 				            Virtual Hard Disk (VHD) 
        /// 					Compatible with Citrix Xen and Microsoft Hyper-V virtualization products.
        ///
        /// 				            Stream-optimized ESX Virtual Machine Disk
        /// 					(VMDK)  Compatible with VMware ESX and
        /// 					VMware vSphere versions 4, 5, and 6.
        ///
        /// 				            Raw  Raw format.
        ///
        public let diskImageFormat: DiskImageFormat
        /// The name of the role that grants VM Import/Export permission to
        /// 			export images to your S3 bucket.
        public let roleName: String
        /// The S3 bucket in which to store the output disk images for your VM.
        public let s3Bucket: String
        /// The Amazon S3 path for the bucket where the output disk images for your VM are stored.
        public let s3Prefix: String?

        public init(diskImageFormat: DiskImageFormat, roleName: String, s3Bucket: String, s3Prefix: String? = nil) {
            self.diskImageFormat = diskImageFormat
            self.roleName = roleName
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.roleName, name: "roleName", parent: name, max: 1024)
            try self.validate(self.roleName, name: "roleName", parent: name, min: 1)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 1024)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 1)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, max: 1024)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case diskImageFormat
            case roleName
            case s3Bucket
            case s3Prefix
        }
    }

    public struct S3Logs: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket in which to store the logs.
        public let s3BucketName: String?
        /// The Amazon S3 path to the bucket where the logs are stored.
        public let s3KeyPrefix: String?

        public init(s3BucketName: String? = nil, s3KeyPrefix: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 1024)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 1024)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName
            case s3KeyPrefix
        }
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {
        /// The condition configures when the pipeline should trigger a new image build. When the
        /// 			pipelineExecutionStartCondition is set to
        /// 			EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic version
        /// 			filters on the base image or components in your image recipe, EC2 Image Builder will build a
        /// 			new image only when there are new versions of the image or components in your recipe that
        /// 			match the semantic version filter. When it is set to EXPRESSION_MATCH_ONLY, it
        /// 			will build a new image every time the CRON expression matches the current time. For semantic
        /// 			version syntax, see CreateComponent in the  EC2 Image Builder API
        /// 					Reference.
        public let pipelineExecutionStartCondition: PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your
        /// 			pipelineExecutionStartCondition.
        /// 		       For information on how to format a cron expression in Image Builder, see Use cron
        /// 			expressions in EC2 Image Builder.
        public let scheduleExpression: String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC",
        /// 			"America/Los_Angeles" in the IANA
        /// 				timezone format. If not specified this defaults to UTC.
        public let timezone: String?

        public init(pipelineExecutionStartCondition: PipelineExecutionStartCondition? = nil, scheduleExpression: String? = nil, timezone: String? = nil) {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 1024)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 100)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 3)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "^[a-zA-Z0-9]{2,}(?:\\/[a-zA-z0-9-_+]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionStartCondition
            case scheduleExpression
            case timezone
        }
    }

    public struct StartImagePipelineExecutionRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.
        public let imagePipelineArn: String

        public init(clientToken: String = StartImagePipelineExecutionRequest.idempotencyToken(), imagePipelineArn: String) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imagePipelineArn
        }
    }

    public struct StartImagePipelineExecutionResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image that was created by this request.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct SystemsManagerAgent: AWSEncodableShape & AWSDecodableShape {
        /// Controls whether the Systems Manager agent is removed from your final build image, prior to creating
        /// 			the new AMI. If this is set to true, then the agent is removed from the final image. If it's
        /// 			set to false, then the agent is left in, so that it is included in the new AMI. The default
        /// 			value is false.
        public let uninstallAfterBuild: Bool?

        public init(uninstallAfterBuild: Bool? = nil) {
            self.uninstallAfterBuild = uninstallAfterBuild
        }

        private enum CodingKeys: String, CodingKey {
            case uninstallAfterBuild
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// The tags to apply to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetContainerRepository: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        public let repositoryName: String
        /// Specifies the service in which this image was registered.
        public let service: ContainerRepositoryService

        public init(repositoryName: String, service: ContainerRepositoryService) {
            self.repositoryName = repositoryName
            self.service = service
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 1024)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName
            case service
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDistributionConfigurationRequest: AWSEncodableShape {
        /// The idempotency token of the distribution configuration.
        public let clientToken: String
        /// The description of the distribution configuration.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update.
        public let distributionConfigurationArn: String
        /// The distributions of the distribution configuration.
        public let distributions: [Distribution]

        public init(clientToken: String = UpdateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributionConfigurationArn: String, distributions: [Distribution]) {
            self.clientToken = clientToken
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case distributionConfigurationArn
            case distributions
        }
    }

    public struct UpdateDistributionConfigurationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this
        /// 			request.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case distributionConfigurationArn
            case requestId
        }
    }

    public struct UpdateImagePipelineRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container pipeline to update.
        public let containerRecipeArn: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to
        /// 			configure and distribute images updated by this image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
        public let imagePipelineArn: String
        /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
        /// 			updated by this image pipeline.
        public let imageRecipeArn: String?
        /// The image test configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
        /// 			build images updated by this image pipeline.
        public let infrastructureConfigurationArn: String
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?

        public init(clientToken: String = UpdateImagePipelineRequest.idempotencyToken(), containerRecipeArn: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imagePipelineArn: String, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, schedule: Schedule? = nil, status: PipelineStatus? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imagePipelineArn = imagePipelineArn
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.schedule = schedule
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.schedule?.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case description
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imagePipelineArn
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case schedule
            case status
        }
    }

    public struct UpdateImagePipelineResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imagePipelineArn
            case requestId
        }
    }

    public struct UpdateInfrastructureConfigurationRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
        /// 			update.
        public let infrastructureConfigurationArn: String
        /// The instance metadata options that you can set for the HTTP requests that pipeline builds
        /// 			use to launch EC2 build and test instances. For more information about instance metadata
        /// 			options, see one of the following links:
        ///
        /// 				            Configure
        /// 					the instance metadata options in the  Amazon EC2 User Guide
        /// 					for Linux instances.
        ///
        /// 				            Configure
        /// 					the instance metadata options in the  Amazon EC2 Windows Guide
        /// 					for Windows instances.
        ///
        public let instanceMetadataOptions: InstanceMetadataOptions?
        /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more
        /// 			instance types to use for this build. The service will pick one of these instance types based
        /// 			on availability.
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. You can use this to log on to and debug
        /// 			the instance used to create your image.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications.
        ///
        /// 			         EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys
        /// 				from other accounts. The key that is used to encrypt the SNS topic must reside in the
        /// 				account that the Image Builder service runs under.
        ///
        public let snsTopicArn: String?
        /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
        public let subnetId: String?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to
        /// 			false if you want Image Builder to retain the instance used to configure your AMI if the build
        /// 			or test phase of your workflow fails.
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = UpdateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, infrastructureConfigurationArn: String, instanceMetadataOptions: InstanceMetadataOptions? = nil, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.instanceMetadataOptions?.validate(name: "\(name).instanceMetadataOptions")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 256)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try self.validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 30)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:[0-9]{12}:[a-zA-Z0-9-_]{1,256}$")
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case infrastructureConfigurationArn
            case instanceMetadataOptions
            case instanceProfileName
            case instanceTypes
            case keyPair
            case logging
            case resourceTags
            case securityGroupIds
            case snsTopicArn
            case subnetId
            case terminateInstanceOnFailure
        }
    }

    public struct UpdateInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by
        /// 			this request.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case infrastructureConfigurationArn
            case requestId
        }
    }
}

// MARK: - Errors

/// Error enum for Imagebuilder
public struct ImagebuilderErrorType: AWSErrorType {
    enum Code: String {
        case callRateLimitExceededException = "CallRateLimitExceededException"
        case clientException = "ClientException"
        case forbiddenException = "ForbiddenException"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case invalidPaginationTokenException = "InvalidPaginationTokenException"
        case invalidParameterCombinationException = "InvalidParameterCombinationException"
        case invalidParameterException = "InvalidParameterException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestException = "InvalidRequestException"
        case invalidVersionNumberException = "InvalidVersionNumberException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceDependencyException = "ResourceDependencyException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Imagebuilder
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You have exceeded the permitted request rate for the specific operation.
    public static var callRateLimitExceededException: Self { .init(.callRateLimitExceededException) }
    /// These errors are usually caused by a client action, such as using an action or resource on
    /// 			behalf of a user that doesn&#39;t have permissions to use the action or resource, or specifying an
    /// 			invalid resource identifier.
    public static var clientException: Self { .init(.clientException) }
    /// You are not authorized to perform the requested operation.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// You have specified a client token for an operation using parameter values that differ from
    /// 			a previous request that used the same client token.
    public static var idempotentParameterMismatchException: Self { .init(.idempotentParameterMismatchException) }
    /// You have provided an invalid pagination token in your request.
    public static var invalidPaginationTokenException: Self { .init(.invalidPaginationTokenException) }
    /// You have specified two or more mutually exclusive parameters. Review the error message for
    /// 			details.
    public static var invalidParameterCombinationException: Self { .init(.invalidParameterCombinationException) }
    /// The specified parameter is invalid. Review the available parameters for the API
    /// 			request.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The value that you provided for the specified parameter is invalid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// You have made a request for an action that is not supported by the service.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// Your version number is out of bounds or does not follow the required syntax.
    public static var invalidVersionNumberException: Self { .init(.invalidVersionNumberException) }
    /// The resource that you are trying to create already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// You have attempted to mutate or delete a resource with a dependency that prohibits this
    /// 			action. See the error message for more details.
    public static var resourceDependencyException: Self { .init(.resourceDependencyException) }
    /// The resource that you are trying to operate on is currently in use. Review the message
    /// 			details and retry later.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// At least one of the resources referenced by your request does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This exception is thrown when the service encounters an unrecoverable exception.
    public static var serviceException: Self { .init(.serviceException) }
    /// You have exceeded the number of permitted resources or operations for this service. For service quotas, see EC2 Image Builder endpoints and quotas.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The service is unable to process your request at this time.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
}

extension ImagebuilderErrorType: Equatable {
    public static func == (lhs: ImagebuilderErrorType, rhs: ImagebuilderErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ImagebuilderErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
