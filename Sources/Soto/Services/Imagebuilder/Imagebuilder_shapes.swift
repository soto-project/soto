//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Imagebuilder {
    // MARK: Enums

    public enum BuildType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `import` = "IMPORT"
        case scheduled = "SCHEDULED"
        case userInitiated = "USER_INITIATED"
        public var description: String { return self.rawValue }
    }

    public enum ComponentFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case shell = "SHELL"
        public var description: String { return self.rawValue }
    }

    public enum ComponentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum ComponentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case build = "BUILD"
        case test = "TEST"
        public var description: String { return self.rawValue }
    }

    public enum ContainerRepositoryService: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ecr = "ECR"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case docker = "DOCKER"
        public var description: String { return self.rawValue }
    }

    public enum DiskImageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case raw = "RAW"
        case vhd = "VHD"
        case vmdk = "VMDK"
        public var description: String { return self.rawValue }
    }

    public enum EbsVolumeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gp2 = "gp2"
        case gp3 = "gp3"
        case io1 = "io1"
        case io2 = "io2"
        case sc1 = "sc1"
        case st1 = "st1"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public enum ImageScanStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case abandoned = "ABANDONED"
        case collecting = "COLLECTING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case scanning = "SCANNING"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum ImageSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonManaged = "AMAZON_MANAGED"
        case awsMarketplace = "AWS_MARKETPLACE"
        case custom = "CUSTOM"
        case imported = "IMPORTED"
        public var description: String { return self.rawValue }
    }

    public enum ImageStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case building = "BUILDING"
        case cancelled = "CANCELLED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deprecated = "DEPRECATED"
        case disabled = "DISABLED"
        case distributing = "DISTRIBUTING"
        case failed = "FAILED"
        case integrating = "INTEGRATING"
        case pending = "PENDING"
        case testing = "TESTING"
        public var description: String { return self.rawValue }
    }

    public enum ImageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ami = "AMI"
        case docker = "DOCKER"
        public var description: String { return self.rawValue }
    }

    public enum LifecycleExecutionResourceActionName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case delete = "DELETE"
        case deprecate = "DEPRECATE"
        case disable = "DISABLE"
        public var description: String { return self.rawValue }
    }

    public enum LifecycleExecutionResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case skipped = "SKIPPED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LifecycleExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyDetailActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case deprecate = "DEPRECATE"
        case disable = "DISABLE"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyDetailFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case age = "AGE"
        case count = "COUNT"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amiImage = "AMI_IMAGE"
        case containerImage = "CONTAINER_IMAGE"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyTimeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        case months = "MONTHS"
        case weeks = "WEEKS"
        case years = "YEARS"
        public var description: String { return self.rawValue }
    }

    public enum OnWorkflowFailure: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `continue` = "CONTINUE"
        case abort = "ABORT"
        public var description: String { return self.rawValue }
    }

    public enum Ownership: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case _self = "Self"
        case amazon = "Amazon"
        case shared = "Shared"
        case thirdparty = "ThirdParty"
        public var description: String { return self.rawValue }
    }

    public enum PipelineExecutionStartCondition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case expressionMatchAndDependencyUpdatesAvailable = "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
        case expressionMatchOnly = "EXPRESSION_MATCH_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum PipelineStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Platform: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "Linux"
        case windows = "Windows"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deprecated = "DEPRECATED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case rollbackCompleted = "ROLLBACK_COMPLETED"
        case rollbackInProgress = "ROLLBACK_IN_PROGRESS"
        case running = "RUNNING"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStepActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case resume = "RESUME"
        case stop = "STOP"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStepExecutionRollbackStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStepExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case build = "BUILD"
        case distribution = "DISTRIBUTION"
        case test = "TEST"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAggregation: AWSDecodableShape {
        /// Identifies the account that owns the aggregated resource findings.
        public let accountId: String?
        /// Counts by severity level for medium severity and higher level findings, plus a total
        /// 			for all of the findings.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case severityCounts = "severityCounts"
        }
    }

    public struct AdditionalInstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains settings for the Systems Manager agent on your build instance.
        public let systemsManagerAgent: SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch your
        /// 			build instance. The userDataOverride property replaces any commands that Image Builder might have added to
        /// 			ensure that Systems Manager is installed on your Linux build instance. If you override the user
        /// 			data, make sure that you add commands to install Systems Manager, if it is not pre-installed on
        /// 			your base image.  The user data is always base 64 encoded. For example, the following commands are
        /// 				encoded as
        /// 				IyEvYmluL2Jhc2gKbWtkaXIgLXAgL3Zhci9iYi8KdG91Y2ggL3Zhci$:  #!/bin/bash  mkdir -p /var/bb/ touch /var
        public let userDataOverride: String?

        public init(systemsManagerAgent: SystemsManagerAgent? = nil, userDataOverride: String? = nil) {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, max: 21847)
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, min: 1)
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case systemsManagerAgent = "systemsManagerAgent"
            case userDataOverride = "userDataOverride"
        }
    }

    public struct Ami: AWSDecodableShape {
        /// The account ID of the owner of the AMI.
        public let accountId: String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public let description: String?
        /// The AMI ID of the Amazon EC2 AMI.
        public let image: String?
        /// The name of the Amazon EC2 AMI.
        public let name: String?
        /// The Amazon Web Services Region of the Amazon EC2 AMI.
        public let region: String?
        public let state: ImageState?

        public init(accountId: String? = nil, description: String? = nil, image: String? = nil, name: String? = nil, region: String? = nil, state: ImageState? = nil) {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case description = "description"
            case image = "image"
            case name = "name"
            case region = "region"
            case state = "state"
        }
    }

    public struct AmiDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The tags to apply to AMIs distributed to this Region.
        public let amiTags: [String: String]?
        /// The description of the AMI distribution configuration. Minimum and maximum length are
        /// 			in characters.
        public let description: String?
        /// The KMS key identifier used to encrypt the distributed image.
        public let kmsKeyId: String?
        /// Launch permissions can be used to configure which Amazon Web Services accounts can use the AMI to
        /// 			launch instances.
        public let launchPermission: LaunchPermissionConfiguration?
        /// The name of the output AMI.
        public let name: String?
        /// The ID of an account to which you want to distribute an image.
        public let targetAccountIds: [String]?

        public init(amiTags: [String: String]? = nil, description: String? = nil, kmsKeyId: String? = nil, launchPermission: LaunchPermissionConfiguration? = nil, name: String? = nil, targetAccountIds: [String]? = nil) {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }

        public func validate(name: String) throws {
            try self.amiTags?.forEach {
                try validate($0.key, name: "amiTags.key", parent: name, max: 128)
                try validate($0.key, name: "amiTags.key", parent: name, min: 1)
                try validate($0.key, name: "amiTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "amiTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.amiTags, name: "amiTags", parent: name, max: 50)
            try self.validate(self.amiTags, name: "amiTags", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.launchPermission?.validate(name: "\(name).launchPermission")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z0-9{][-_A-Za-z0-9\\s:{}\\.]+[-_A-Za-z0-9}]$")
            try self.targetAccountIds?.forEach {
                try validate($0, name: "targetAccountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.targetAccountIds, name: "targetAccountIds", parent: name, max: 1536)
            try self.validate(self.targetAccountIds, name: "targetAccountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amiTags = "amiTags"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case launchPermission = "launchPermission"
            case name = "name"
            case targetAccountIds = "targetAccountIds"
        }
    }

    public struct CancelImageCreationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image that you want to cancel creation
        /// 			for.
        public let imageBuildVersionArn: String

        public init(clientToken: String = CancelImageCreationRequest.idempotencyToken(), imageBuildVersionArn: String) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
        }
    }

    public struct CancelImageCreationResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The ARN of the image whose creation this request canceled.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct CancelLifecycleExecutionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Identifies the specific runtime instance of the image lifecycle to cancel.
        public let lifecycleExecutionId: String

        public init(clientToken: String = CancelLifecycleExecutionRequest.idempotencyToken(), lifecycleExecutionId: String) {
            self.clientToken = clientToken
            self.lifecycleExecutionId = lifecycleExecutionId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.lifecycleExecutionId, name: "lifecycleExecutionId", parent: name, pattern: "^lce-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case lifecycleExecutionId = "lifecycleExecutionId"
        }
    }

    public struct CancelLifecycleExecutionResponse: AWSDecodableShape {
        /// The unique identifier for the image lifecycle runtime instance that was canceled.
        public let lifecycleExecutionId: String?

        public init(lifecycleExecutionId: String? = nil) {
            self.lifecycleExecutionId = lifecycleExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleExecutionId = "lifecycleExecutionId"
        }
    }

    public struct Component: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// Describes what change has been made in this version of the component,
        /// 			or what makes this version different from other versions of the component.
        public let changeDescription: String?
        /// Component data contains the YAML document content for the component.
        public let data: String?
        /// The date that Image Builder created the component.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The encryption status of the component.
        public let encrypted: Bool?
        /// The KMS key identifier used to encrypt the component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String?
        /// Indicates whether component source is hidden from view in the console, and from
        /// 			component detail results for API, CLI, or SDK operations.
        public let obfuscate: Bool?
        /// The owner of the component.
        public let owner: String?
        /// Contains parameter details for each of the parameters that the component document
        /// 			defined for the component.
        public let parameters: [ComponentParameterDetail]?
        /// The operating system platform of the component.
        public let platform: Platform?
        /// Contains the name of the publisher if this is a third-party component. Otherwise,
        /// 			this property is empty.
        public let publisher: String?
        /// Describes the current status of the component. This is used for components that are no
        /// 			longer active.
        public let state: ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is
        /// 			available, Image Builder performs a prefix match against the base image OS version during image
        /// 			recipe creation.
        public let supportedOsVersions: [String]?
        /// The tags that apply to the component.
        public let tags: [String: String]?
        /// The component type specifies whether Image Builder uses the component to build the image or
        /// 			only to test it.
        public let type: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, data: String? = nil, dateCreated: String? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, name: String? = nil, obfuscate: Bool? = nil, owner: String? = nil, parameters: [ComponentParameterDetail]? = nil, platform: Platform? = nil, publisher: String? = nil, state: ComponentState? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.obfuscate = obfuscate
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.publisher = publisher
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case changeDescription = "changeDescription"
            case data = "data"
            case dateCreated = "dateCreated"
            case description = "description"
            case encrypted = "encrypted"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case obfuscate = "obfuscate"
            case owner = "owner"
            case parameters = "parameters"
            case platform = "platform"
            case publisher = "publisher"
            case state = "state"
            case supportedOsVersions = "supportedOsVersions"
            case tags = "tags"
            case type = "type"
            case version = "version"
        }
    }

    public struct ComponentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let componentArn: String
        /// A group of parameter settings that Image Builder uses to configure the component for a specific
        /// 			recipe.
        public let parameters: [ComponentParameter]?

        public init(componentArn: String, parameters: [ComponentParameter]? = nil) {
            self.componentArn = componentArn
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
            try self.parameters?.forEach {
                try $0.validate(name: "\(name).parameters[]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case parameters = "parameters"
        }
    }

    public struct ComponentParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component parameter to set.
        public let name: String
        /// Sets the value for the named component parameter.
        public let value: [String]

        public init(name: String, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\x00]+$")
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^[^\\x00]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct ComponentParameterDetail: AWSDecodableShape {
        /// The default value of this parameter if no input is provided.
        public let defaultValue: [String]?
        /// Describes this parameter.
        public let description: String?
        /// The name of this input parameter.
        public let name: String
        /// The type of input this parameter provides. The currently supported value is
        /// 			"string".
        public let type: String

        public init(defaultValue: [String]? = nil, description: String? = nil, name: String, type: String) {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case description = "description"
            case name = "name"
            case type = "type"
        }
    }

    public struct ComponentState: AWSDecodableShape {
        /// Describes how or why the component changed state.
        public let reason: String?
        /// The current state of the component.
        public let status: ComponentStatus?

        public init(reason: String? = nil, status: ComponentStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct ComponentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description for the current version of the component.
        public let changeDescription: String?
        /// The original creation date of the component.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// Indicates whether component source is hidden from view in the console,
        /// 			and from component detail results for API, CLI, or SDK operations.
        public let obfuscate: Bool?
        /// The owner of the component.
        public let owner: String?
        /// The operating system platform of the component.
        public let platform: Platform?
        /// Contains the name of the publisher if this is a third-party component. Otherwise,
        /// 			this property is empty.
        public let publisher: String?
        /// Describes the current status of the component.
        public let state: ComponentState?
        /// The operating system (OS) version that the component supports. If the OS information
        /// 			is available, Image Builder performs a prefix match against the base image OS version during
        /// 			image recipe creation.
        public let supportedOsVersions: [String]?
        /// The tags that apply to the component.
        public let tags: [String: String]?
        /// The component type specifies whether Image Builder uses the component to build the image or
        /// 			only to test it.
        public let type: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, obfuscate: Bool? = nil, owner: String? = nil, platform: Platform? = nil, publisher: String? = nil, state: ComponentState? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.obfuscate = obfuscate
            self.owner = owner
            self.platform = platform
            self.publisher = publisher
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case changeDescription = "changeDescription"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case obfuscate = "obfuscate"
            case owner = "owner"
            case platform = "platform"
            case publisher = "publisher"
            case state = "state"
            case supportedOsVersions = "supportedOsVersions"
            case tags = "tags"
            case type = "type"
            case version = "version"
        }
    }

    public struct ComponentVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.  Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:   Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.   Version ARNs have only the first three nodes: ..   Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public let arn: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// he operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image
        /// 			recipe creation.
        public let supportedOsVersions: [String]?
        /// The type of the component denotes whether the component is used to build the image or
        /// 			only to test it.
        public let type: ComponentType?
        /// The semantic version of the component.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case platform = "platform"
            case supportedOsVersions = "supportedOsVersions"
            case type = "type"
            case version = "version"
        }
    }

    public struct Container: AWSDecodableShape {
        /// A list of URIs for containers created in the context Region.
        public let imageUris: [String]?
        /// Containers and container images are Region-specific. This is the Region context for
        /// 			the container.
        public let region: String?

        public init(imageUris: [String]? = nil, region: String? = nil) {
            self.imageUris = imageUris
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case imageUris = "imageUris"
            case region = "region"
        }
    }

    public struct ContainerDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Tags that are attached to the container distribution configuration.
        public let containerTags: [String]?
        /// The description of the container distribution configuration.
        public let description: String?
        /// The destination repository for the container distribution configuration.
        public let targetRepository: TargetContainerRepository

        public init(containerTags: [String]? = nil, description: String? = nil, targetRepository: TargetContainerRepository) {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }

        public func validate(name: String) throws {
            try self.containerTags?.forEach {
                try validate($0, name: "containerTags[]", parent: name, max: 1024)
                try validate($0, name: "containerTags[]", parent: name, min: 1)
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.targetRepository.validate(name: "\(name).targetRepository")
        }

        private enum CodingKeys: String, CodingKey {
            case containerTags = "containerTags"
            case description = "description"
            case targetRepository = "targetRepository"
        }
    }

    public struct ContainerRecipe: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe.  Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:   Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.   Version ARNs have only the first three nodes: ..   Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public let arn: String?
        /// Build and test components that are included in the container recipe.
        /// 			Recipes require a minimum of one build component, and can
        /// 			have a maximum of 20 build and test components in any combination.
        public let components: [ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public let containerType: ContainerType?
        /// The date when this container recipe was created.
        public let dateCreated: String?
        /// The description of the container recipe.
        public let description: String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure
        /// 			that they contain all of the elements required by the application running inside. The
        /// 			template data consists of contextual variables where Image Builder places build information or
        /// 			scripts, based on your container image recipe.
        public let dockerfileTemplateData: String?
        /// A flag that indicates if the target container is encrypted.
        public let encrypted: Bool?
        /// A group of options that can be used to configure an instance for building and testing
        /// 			container images.
        public let instanceConfiguration: InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to
        /// 			the target Region.
        public let kmsKeyId: String?
        /// The name of the container recipe.
        public let name: String?
        /// The owner of the container recipe.
        public let owner: String?
        /// The base image for the container recipe.
        public let parentImage: String?
        /// The system platform for the container, such as Windows or Linux.
        public let platform: Platform?
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?
        /// The destination repository for the container image.
        public let targetRepository: TargetContainerRepository?
        /// The semantic version of the container recipe.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        public let version: String?
        /// The working directory for use during build and test workflows.
        public let workingDirectory: String?

        public init(arn: String? = nil, components: [ComponentConfiguration]? = nil, containerType: ContainerType? = nil, dateCreated: String? = nil, description: String? = nil, dockerfileTemplateData: String? = nil, encrypted: Bool? = nil, instanceConfiguration: InstanceConfiguration? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, targetRepository: TargetContainerRepository? = nil, version: String? = nil, workingDirectory: String? = nil) {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case components = "components"
            case containerType = "containerType"
            case dateCreated = "dateCreated"
            case description = "description"
            case dockerfileTemplateData = "dockerfileTemplateData"
            case encrypted = "encrypted"
            case instanceConfiguration = "instanceConfiguration"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case owner = "owner"
            case parentImage = "parentImage"
            case platform = "platform"
            case tags = "tags"
            case targetRepository = "targetRepository"
            case version = "version"
            case workingDirectory = "workingDirectory"
        }
    }

    public struct ContainerRecipeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public let arn: String?
        /// Specifies the type of container, such as "Docker".
        public let containerType: ContainerType?
        /// The date when this container recipe was created.
        public let dateCreated: String?
        /// The name of the container recipe.
        public let name: String?
        /// The owner of the container recipe.
        public let owner: String?
        /// The base image for the container recipe.
        public let parentImage: String?
        /// The system platform for the container, such as Windows or Linux.
        public let platform: Platform?
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, containerType: ContainerType? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case containerType = "containerType"
            case dateCreated = "dateCreated"
            case name = "name"
            case owner = "owner"
            case parentImage = "parentImage"
            case platform = "platform"
            case tags = "tags"
        }
    }

    public struct CreateComponentRequest: AWSEncodableShape {
        /// The change description of the component. Describes what change has been made in this
        /// 			version, or what makes this version different from other versions of the
        /// 			component.
        public let changeDescription: String?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Component data contains inline YAML document content for the component.
        /// 			Alternatively, you can specify the uri of a YAML document file stored in
        /// 			Amazon S3. However, you cannot specify both properties.
        public let data: String?
        /// Describes the contents of the component.
        public let description: String?
        /// The ID of the KMS key that is used to encrypt this component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String
        /// The operating system platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version
        /// 			syntax.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        public let semanticVersion: String
        /// The operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image
        /// 			recipe creation.
        public let supportedOsVersions: [String]?
        /// The tags that apply to the component.
        public let tags: [String: String]?
        /// The uri of a YAML component document file. This must be an S3 URL
        /// 				(s3://bucket/key), and the requester must have permission to access the
        /// 			S3 bucket it points to. If you use Amazon S3, you can specify component content up to your
        /// 			service quota. Alternatively, you can specify the YAML document inline, using the component
        /// 				data property. You cannot specify both properties.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = CreateComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 16000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, pattern: "^[^\\x00]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.supportedOsVersions?.forEach {
                try validate($0, name: "supportedOsVersions[]", parent: name, min: 1)
            }
            try self.validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, max: 25)
            try self.validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription = "changeDescription"
            case clientToken = "clientToken"
            case data = "data"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case platform = "platform"
            case semanticVersion = "semanticVersion"
            case supportedOsVersions = "supportedOsVersions"
            case tags = "tags"
            case uri = "uri"
        }
    }

    public struct CreateComponentResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the component that the request created.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case componentBuildVersionArn = "componentBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct CreateContainerRecipeRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Components for build and test that are included in the container recipe.
        /// 			Recipes require a minimum of one build component, and can
        /// 			have a maximum of 20 build and test components in any combination.
        public let components: [ComponentConfiguration]
        /// The type of container to create.
        public let containerType: ContainerType
        /// The description of the container recipe.
        public let description: String?
        /// The Dockerfile template used to build your image as an inline data blob.
        public let dockerfileTemplateData: String?
        /// The Amazon S3 URI for the Dockerfile that will be used to build your container
        /// 			image.
        public let dockerfileTemplateUri: String?
        /// Specifies the operating system version for the base image.
        public let imageOsVersionOverride: String?
        /// A group of options that can be used to configure an instance for building and testing
        /// 			container images.
        public let instanceConfiguration: InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image.
        public let kmsKeyId: String?
        /// The name of the container recipe.
        public let name: String
        /// The base image for the container recipe.
        public let parentImage: String
        /// Specifies the operating system platform when you use a custom base image.
        public let platformOverride: Platform?
        /// The semantic version of the container recipe. This version follows the semantic
        /// 			version syntax.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        public let semanticVersion: String
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?
        /// The destination repository for the container image.
        public let targetRepository: TargetContainerRepository
        /// The working directory for use during build and test workflows.
        public let workingDirectory: String?

        public init(clientToken: String = CreateContainerRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], containerType: ContainerType, description: String? = nil, dockerfileTemplateData: String? = nil, dockerfileTemplateUri: String? = nil, imageOsVersionOverride: String? = nil, instanceConfiguration: InstanceConfiguration? = nil, kmsKeyId: String? = nil, name: String, parentImage: String, platformOverride: Platform? = nil, semanticVersion: String, tags: [String: String]? = nil, targetRepository: TargetContainerRepository, workingDirectory: String? = nil) {
            self.clientToken = clientToken
            self.components = components
            self.containerType = containerType
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.dockerfileTemplateUri = dockerfileTemplateUri
            self.imageOsVersionOverride = imageOsVersionOverride
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.parentImage = parentImage
            self.platformOverride = platformOverride
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.targetRepository = targetRepository
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try self.validate(self.components, name: "components", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, max: 16000)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, min: 1)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, pattern: "^[^\\x00]+$")
            try self.validate(self.imageOsVersionOverride, name: "imageOsVersionOverride", parent: name, max: 1024)
            try self.validate(self.imageOsVersionOverride, name: "imageOsVersionOverride", parent: name, min: 1)
            try self.instanceConfiguration?.validate(name: "\(name).instanceConfiguration")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try self.validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.targetRepository.validate(name: "\(name).targetRepository")
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1024)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case components = "components"
            case containerType = "containerType"
            case description = "description"
            case dockerfileTemplateData = "dockerfileTemplateData"
            case dockerfileTemplateUri = "dockerfileTemplateUri"
            case imageOsVersionOverride = "imageOsVersionOverride"
            case instanceConfiguration = "instanceConfiguration"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case parentImage = "parentImage"
            case platformOverride = "platformOverride"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
            case targetRepository = "targetRepository"
            case workingDirectory = "workingDirectory"
        }
    }

    public struct CreateContainerRecipeResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// Returns the Amazon Resource Name (ARN) of the container recipe that the request
        /// 			created.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case containerRecipeArn = "containerRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct CreateDistributionConfigurationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The description of the distribution configuration.
        public let description: String?
        /// The distributions of the distribution configuration.
        public let distributions: [Distribution]
        /// The name of the distribution configuration.
        public let name: String
        /// The tags of the distribution configuration.
        public let tags: [String: String]?

        public init(clientToken: String = CreateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributions: [Distribution], name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case distributions = "distributions"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateDistributionConfigurationResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that was created by
        /// 			this request.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct CreateImagePipelineRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container recipe that is used to configure
        /// 			images created by this container pipeline.
        public let containerRecipeArn: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to
        /// 			configure and distribute images created by this image pipeline.
        public let distributionConfigurationArn: String?
        /// Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants
        /// 			Image Builder access to perform workflow actions.
        public let executionRole: String?
        /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure
        /// 			images created by this image pipeline.
        public let imageRecipeArn: String?
        /// Contains settings for vulnerability scans.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The image test configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used
        /// 			to build images created by this image pipeline.
        public let infrastructureConfigurationArn: String
        /// The name of the image pipeline.
        public let name: String
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?
        /// The tags of the image pipeline.
        public let tags: [String: String]?
        /// Contains an array of workflow configuration objects.
        public let workflows: [WorkflowConfiguration]?

        public init(clientToken: String = CreateImagePipelineRequest.idempotencyToken(), containerRecipeArn: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, executionRole: String? = nil, imageRecipeArn: String? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, name: String, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil, workflows: [WorkflowConfiguration]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imageRecipeArn = imageRecipeArn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.schedule = schedule
            self.status = status
            self.tags = tags
            self.workflows = workflows
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^(?:arn:aws(?:-[a-z]+)*:iam::[0-9]{12}:role/)?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageScanningConfiguration?.validate(name: "\(name).imageScanningConfiguration")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.schedule?.validate(name: "\(name).schedule")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.workflows?.forEach {
                try $0.validate(name: "\(name).workflows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case containerRecipeArn = "containerRecipeArn"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case executionRole = "executionRole"
            case imageRecipeArn = "imageRecipeArn"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case name = "name"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
            case workflows = "workflows"
        }
    }

    public struct CreateImagePipelineResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that was created by this
        /// 			request.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imagePipelineArn = "imagePipelineArn"
            case requestId = "requestId"
        }
    }

    public struct CreateImageRecipeRequest: AWSEncodableShape {
        /// Specify additional settings and launch scripts for your build instances.
        public let additionalInstanceConfiguration: AdditionalInstanceConfiguration?
        /// The block device mappings of the image recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The components included in the image recipe.
        public let components: [ComponentConfiguration]
        /// The description of the image recipe.
        public let description: String?
        /// The name of the image recipe.
        public let name: String
        /// The base image of the image recipe. The value of the string can be the ARN of the base
        /// 			image or an AMI ID. The format for the ARN follows this example:
        /// 				arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x.
        /// 			You can provide the specific version that you want to use, or you can use a wildcard in
        /// 			all of the fields. If you enter an AMI ID for the string value, you must have access to
        /// 			the AMI, and the AMI must be in the same Region in which you are using Image Builder.
        public let parentImage: String
        /// The semantic version of the image recipe. This version follows the semantic version
        /// 			syntax.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        public let semanticVersion: String
        /// The tags of the image recipe.
        public let tags: [String: String]?
        /// The working directory used during build and test workflows.
        public let workingDirectory: String?

        public init(additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, clientToken: String = CreateImageRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], description: String? = nil, name: String, parentImage: String, semanticVersion: String, tags: [String: String]? = nil, workingDirectory: String? = nil) {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.blockDeviceMappings = blockDeviceMappings
            self.clientToken = clientToken
            self.components = components
            self.description = description
            self.name = name
            self.parentImage = parentImage
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.additionalInstanceConfiguration?.validate(name: "\(name).additionalInstanceConfiguration")
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try self.validate(self.components, name: "components", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try self.validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1024)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInstanceConfiguration = "additionalInstanceConfiguration"
            case blockDeviceMappings = "blockDeviceMappings"
            case clientToken = "clientToken"
            case components = "components"
            case description = "description"
            case name = "name"
            case parentImage = "parentImage"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
            case workingDirectory = "workingDirectory"
        }
    }

    public struct CreateImageRecipeResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image recipe that was created by this
        /// 			request.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageRecipeArn = "imageRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct CreateImageRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container recipe that defines how images are
        /// 			configured and tested.
        public let containerRecipeArn: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that defines and
        /// 			configures the outputs of your pipeline.
        public let distributionConfigurationArn: String?
        /// Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants
        /// 			Image Builder access to perform workflow actions.
        public let executionRole: String?
        /// The Amazon Resource Name (ARN) of the image recipe that defines how images are
        /// 			configured, tested, and assessed.
        public let imageRecipeArn: String?
        /// Contains settings for vulnerability scans.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The image tests configuration of the image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that defines the
        /// 			environment in which your image will be built and tested.
        public let infrastructureConfigurationArn: String
        /// The tags of the image.
        public let tags: [String: String]?
        /// Contains an array of workflow configuration objects.
        public let workflows: [WorkflowConfiguration]?

        public init(clientToken: String = CreateImageRequest.idempotencyToken(), containerRecipeArn: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, executionRole: String? = nil, imageRecipeArn: String? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, tags: [String: String]? = nil, workflows: [WorkflowConfiguration]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imageRecipeArn = imageRecipeArn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.tags = tags
            self.workflows = workflows
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^(?:arn:aws(?:-[a-z]+)*:iam::[0-9]{12}:role/)?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageScanningConfiguration?.validate(name: "\(name).imageScanningConfiguration")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.workflows?.forEach {
                try $0.validate(name: "\(name).workflows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case containerRecipeArn = "containerRecipeArn"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case executionRole = "executionRole"
            case imageRecipeArn = "imageRecipeArn"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case tags = "tags"
            case workflows = "workflows"
        }
    }

    public struct CreateImageResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image that the request created.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct CreateInfrastructureConfigurationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance metadata options that you can set for the HTTP requests that pipeline
        /// 			builds use to launch EC2 build and test instances.
        public let instanceMetadataOptions: InstanceMetadataOptions?
        /// The instance profile to associate with the instance used to customize your Amazon EC2
        /// 			AMI.
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more
        /// 			instance types to use for this build. The service will pick one of these instance types
        /// 			based on availability.
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. You can use this to log on to and
        /// 			debug the instance used to create your image.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs to associate with the instance used to customize your Amazon EC2
        /// 			AMI.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event
        /// 			notifications.  EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys
        /// 				from other accounts. The key that is used to encrypt the SNS topic must reside in the
        /// 				account that the Image Builder service runs under.
        public let snsTopicArn: String?
        /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to
        /// 			false if you want Image Builder to retain the instance used to configure your AMI if the build or
        /// 			test phase of your workflow fails.
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = CreateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, instanceMetadataOptions: InstanceMetadataOptions? = nil, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.instanceMetadataOptions?.validate(name: "\(name).instanceMetadataOptions")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 256)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try self.validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 30)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:[0-9]{12}:[a-zA-Z0-9-_]{1,256}$")
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case instanceMetadataOptions = "instanceMetadataOptions"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case keyPair = "keyPair"
            case logging = "logging"
            case name = "name"
            case resourceTags = "resourceTags"
            case securityGroupIds = "securityGroupIds"
            case snsTopicArn = "snsTopicArn"
            case subnetId = "subnetId"
            case tags = "tags"
            case terminateInstanceOnFailure = "terminateInstanceOnFailure"
        }
    }

    public struct CreateInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by
        /// 			this request.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct CreateLifecyclePolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Optional description for the lifecycle policy.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants
        /// 			Image Builder access to run lifecycle actions.
        public let executionRole: String
        /// The name of the  lifecycle policy to create.
        public let name: String
        /// Configuration details for the lifecycle policy rules.
        public let policyDetails: [LifecyclePolicyDetail]
        /// Selection criteria for the resources that the lifecycle policy applies to.
        public let resourceSelection: LifecyclePolicyResourceSelection
        /// The type of Image Builder resource that the lifecycle policy applies to.
        public let resourceType: LifecyclePolicyResourceType
        /// Indicates whether the lifecycle policy resource is enabled.
        public let status: LifecyclePolicyStatus?
        /// Tags to apply to the lifecycle policy resource.
        public let tags: [String: String]?

        public init(clientToken: String = CreateLifecyclePolicyRequest.idempotencyToken(), description: String? = nil, executionRole: String, name: String, policyDetails: [LifecyclePolicyDetail], resourceSelection: LifecyclePolicyResourceSelection, resourceType: LifecyclePolicyResourceType, status: LifecyclePolicyStatus? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.policyDetails = policyDetails
            self.resourceSelection = resourceSelection
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^(?:arn:aws(?:-[a-z]+)*:iam::[0-9]{12}:role/)?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.policyDetails.forEach {
                try $0.validate(name: "\(name).policyDetails[]")
            }
            try self.validate(self.policyDetails, name: "policyDetails", parent: name, max: 3)
            try self.validate(self.policyDetails, name: "policyDetails", parent: name, min: 1)
            try self.resourceSelection.validate(name: "\(name).resourceSelection")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRole = "executionRole"
            case name = "name"
            case policyDetails = "policyDetails"
            case resourceSelection = "resourceSelection"
            case resourceType = "resourceType"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateLifecyclePolicyResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the lifecycle policy that the request created.
        public let lifecyclePolicyArn: String?

        public init(clientToken: String? = nil, lifecyclePolicyArn: String? = nil) {
            self.clientToken = clientToken
            self.lifecyclePolicyArn = lifecyclePolicyArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case lifecyclePolicyArn = "lifecyclePolicyArn"
        }
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        /// Describes what change has been made in this version of the workflow, or
        /// 			what makes this version different from other versions of the workflow.
        public let changeDescription: String?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Contains the UTF-8 encoded YAML document content for the workflow.
        /// 			Alternatively, you can specify the uri of a YAML document file stored in
        /// 			Amazon S3. However, you cannot specify both properties.
        public let data: String?
        /// Describes the workflow.
        public let description: String?
        /// The ID of the KMS key that is used to encrypt this workflow resource.
        public let kmsKeyId: String?
        /// The name of the workflow to create.
        public let name: String
        /// The semantic version of this workflow resource. The semantic version syntax
        /// 			adheres to the following rules.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        public let semanticVersion: String
        /// Tags that apply to the workflow resource.
        public let tags: [String: String]?
        /// The phase in the image build process for which the workflow resource
        /// 			is responsible.
        public let type: WorkflowType
        /// The uri of a YAML component document file. This must be an S3 URL
        /// 			(s3://bucket/key), and the requester must have permission to access the
        /// 			S3 bucket it points to. If you use Amazon S3, you can specify component content up to your
        /// 			service quota. Alternatively, you can specify the YAML document inline, using the component
        /// 			data property. You cannot specify both properties.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = CreateWorkflowRequest.idempotencyToken(), data: String? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String, semanticVersion: String, tags: [String: String]? = nil, type: WorkflowType, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 16000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, pattern: "^[^\\x00]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription = "changeDescription"
            case clientToken = "clientToken"
            case data = "data"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
            case type = "type"
            case uri = "uri"
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the workflow resource that the request created.
        public let workflowBuildVersionArn: String?

        public init(clientToken: String? = nil, workflowBuildVersionArn: String? = nil) {
            self.clientToken = clientToken
            self.workflowBuildVersionArn = workflowBuildVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case workflowBuildVersionArn = "workflowBuildVersionArn"
        }
    }

    public struct CvssScore: AWSDecodableShape {
        /// The CVSS base score.
        public let baseScore: Double?
        /// The vector string of the CVSS score.
        public let scoringVector: String?
        /// The source of the CVSS score.
        public let source: String?
        /// The CVSS version that generated the score.
        public let version: String?

        public init(baseScore: Double? = nil, scoringVector: String? = nil, source: String? = nil, version: String? = nil) {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case baseScore = "baseScore"
            case scoringVector = "scoringVector"
            case source = "source"
            case version = "version"
        }
    }

    public struct CvssScoreAdjustment: AWSDecodableShape {
        /// The metric that Amazon Inspector used to adjust the CVSS score.
        public let metric: String?
        /// The reason for the CVSS score adjustment.
        public let reason: String?

        public init(metric: String? = nil, reason: String? = nil) {
            self.metric = metric
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "metric"
            case reason = "reason"
        }
    }

    public struct CvssScoreDetails: AWSDecodableShape {
        /// An object that contains details about an adjustment that Amazon Inspector made to the CVSS score
        /// 			for the finding.
        public let adjustments: [CvssScoreAdjustment]?
        /// The source of the finding.
        public let cvssSource: String?
        /// The CVSS score.
        public let score: Double?
        /// The source for the CVSS score.
        public let scoreSource: String?
        /// A vector that measures the severity of the vulnerability.
        public let scoringVector: String?
        /// The CVSS version that generated the score.
        public let version: String?

        public init(adjustments: [CvssScoreAdjustment]? = nil, cvssSource: String? = nil, score: Double? = nil, scoreSource: String? = nil, scoringVector: String? = nil, version: String? = nil) {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case adjustments = "adjustments"
            case cvssSource = "cvssSource"
            case score = "score"
            case scoreSource = "scoreSource"
            case scoringVector = "scoringVector"
            case version = "version"
        }
    }

    public struct DeleteComponentRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the component build version to delete.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.componentBuildVersionArn, key: "componentBuildVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentResponse: AWSDecodableShape {
        /// The ARN of the component build version that this request deleted.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentBuildVersionArn = "componentBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteContainerRecipeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe to delete.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.containerRecipeArn, key: "containerRecipeArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContainerRecipeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn = "containerRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteDistributionConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.distributionConfigurationArn, key: "distributionConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDistributionConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration that was
        /// 			deleted.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationArn = "distributionConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteImagePipelineRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline to delete.
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imagePipelineArn, key: "imagePipelineArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImagePipelineResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineArn = "imagePipelineArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteImageRecipeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe to delete.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imageRecipeArn, key: "imageRecipeArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageRecipeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn = "imageRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteImageRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imageBuildVersionArn, key: "imageBuildVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageResponse: AWSDecodableShape {
        /// The ARN of the Image Builder image resource that this request deleted.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteInfrastructureConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.infrastructureConfigurationArn, key: "infrastructureConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was
        /// 			deleted.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the lifecycle policy resource to delete.
        public let lifecyclePolicyArn: String

        public init(lifecyclePolicyArn: String) {
            self.lifecyclePolicyArn = lifecyclePolicyArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.lifecyclePolicyArn, key: "lifecyclePolicyArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyArn, name: "lifecyclePolicyArn", parent: name, max: 1024)
            try self.validate(self.lifecyclePolicyArn, name: "lifecyclePolicyArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):lifecycle-policy/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLifecyclePolicyResponse: AWSDecodableShape {
        /// The ARN of the lifecycle policy that was deleted.
        public let lifecyclePolicyArn: String?

        public init(lifecyclePolicyArn: String? = nil) {
            self.lifecyclePolicyArn = lifecyclePolicyArn
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyArn = "lifecyclePolicyArn"
        }
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the workflow resource to delete.
        public let workflowBuildVersionArn: String

        public init(workflowBuildVersionArn: String) {
            self.workflowBuildVersionArn = workflowBuildVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.workflowBuildVersionArn, key: "workflowBuildVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowBuildVersionArn, name: "workflowBuildVersionArn", parent: name, max: 1024)
            try self.validate(self.workflowBuildVersionArn, name: "workflowBuildVersionArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):workflow/(build|test|distribution)/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkflowResponse: AWSDecodableShape {
        /// The ARN of the workflow resource that this request deleted.
        public let workflowBuildVersionArn: String?

        public init(workflowBuildVersionArn: String? = nil) {
            self.workflowBuildVersionArn = workflowBuildVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case workflowBuildVersionArn = "workflowBuildVersionArn"
        }
    }

    public struct Distribution: AWSEncodableShape & AWSDecodableShape {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public let amiDistributionConfiguration: AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing in a specific
        /// 			Region.
        public let containerDistributionConfiguration: ContainerDistributionConfiguration?
        /// The Windows faster-launching configurations to use for AMI distribution.
        public let fastLaunchConfigurations: [FastLaunchConfiguration]?
        /// A group of launchTemplateConfiguration settings that apply to image distribution for
        /// 			specified accounts.
        public let launchTemplateConfigurations: [LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified
        /// 			Region.
        public let licenseConfigurationArns: [String]?
        /// The target Region.
        public let region: String
        /// Configure export settings to deliver disk images created from your image build, using
        /// 			a file format that is compatible with your VMs in that Region.
        public let s3ExportConfiguration: S3ExportConfiguration?

        public init(amiDistributionConfiguration: AmiDistributionConfiguration? = nil, containerDistributionConfiguration: ContainerDistributionConfiguration? = nil, fastLaunchConfigurations: [FastLaunchConfiguration]? = nil, launchTemplateConfigurations: [LaunchTemplateConfiguration]? = nil, licenseConfigurationArns: [String]? = nil, region: String, s3ExportConfiguration: S3ExportConfiguration? = nil) {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.fastLaunchConfigurations = fastLaunchConfigurations
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
            self.s3ExportConfiguration = s3ExportConfiguration
        }

        public func validate(name: String) throws {
            try self.amiDistributionConfiguration?.validate(name: "\(name).amiDistributionConfiguration")
            try self.containerDistributionConfiguration?.validate(name: "\(name).containerDistributionConfiguration")
            try self.fastLaunchConfigurations?.forEach {
                try $0.validate(name: "\(name).fastLaunchConfigurations[]")
            }
            try self.validate(self.fastLaunchConfigurations, name: "fastLaunchConfigurations", parent: name, max: 1000)
            try self.validate(self.fastLaunchConfigurations, name: "fastLaunchConfigurations", parent: name, min: 1)
            try self.launchTemplateConfigurations?.forEach {
                try $0.validate(name: "\(name).launchTemplateConfigurations[]")
            }
            try self.validate(self.launchTemplateConfigurations, name: "launchTemplateConfigurations", parent: name, max: 100)
            try self.validate(self.launchTemplateConfigurations, name: "launchTemplateConfigurations", parent: name, min: 1)
            try self.licenseConfigurationArns?.forEach {
                try validate($0, name: "licenseConfigurationArns[]", parent: name, pattern: "^arn:aws[^:]*:license-manager:[^:]+:[0-9]{12}:license-configuration:lic-[a-z0-9-_]{32}$")
            }
            try self.validate(self.licenseConfigurationArns, name: "licenseConfigurationArns", parent: name, max: 50)
            try self.validate(self.licenseConfigurationArns, name: "licenseConfigurationArns", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, max: 1024)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.s3ExportConfiguration?.validate(name: "\(name).s3ExportConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case amiDistributionConfiguration = "amiDistributionConfiguration"
            case containerDistributionConfiguration = "containerDistributionConfiguration"
            case fastLaunchConfigurations = "fastLaunchConfigurations"
            case launchTemplateConfigurations = "launchTemplateConfigurations"
            case licenseConfigurationArns = "licenseConfigurationArns"
            case region = "region"
            case s3ExportConfiguration = "s3ExportConfiguration"
        }
    }

    public struct DistributionConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which this distribution configuration was created.
        public let dateCreated: String?
        /// The date on which this distribution configuration was last updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The distribution objects that apply Region-specific settings for the deployment of the
        /// 			image to targeted Regions.
        public let distributions: [Distribution]?
        /// The name of the distribution configuration.
        public let name: String?
        /// The tags of the distribution configuration.
        public let tags: [String: String]?
        /// The maximum duration in minutes for this distribution configuration.
        public let timeoutMinutes: Int

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributions: [Distribution]? = nil, name: String? = nil, tags: [String: String]? = nil, timeoutMinutes: Int) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case distributions = "distributions"
            case name = "name"
            case tags = "tags"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct DistributionConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which the distribution configuration was created.
        public let dateCreated: String?
        /// The date on which the distribution configuration was updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The name of the distribution configuration.
        public let name: String?
        /// A list of Regions where the container image is distributed to.
        public let regions: [String]?
        /// The tags associated with the distribution configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, name: String? = nil, regions: [String]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case name = "name"
            case regions = "regions"
            case tags = "tags"
        }
    }

    public struct EbsInstanceBlockDeviceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Use to configure delete on termination of the associated device.
        public let deleteOnTermination: Bool?
        /// Use to configure device encryption.
        public let encrypted: Bool?
        /// Use to configure device IOPS.
        public let iops: Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public let kmsKeyId: String?
        /// The snapshot that defines the device contents.
        public let snapshotId: String?
        ///  For GP3 volumes only – The throughput in MiB/s
        /// 			that the volume supports.
        public let throughput: Int?
        /// Use to override the device's volume size.
        public let volumeSize: Int?
        /// Use to override the device's volume type.
        public let volumeType: EbsVolumeType?

        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, snapshotId: String? = nil, throughput: Int? = nil, volumeSize: Int? = nil, volumeType: EbsVolumeType? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 64000)
            try self.validate(self.iops, name: "iops", parent: name, min: 100)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 1024)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 1)
            try self.validate(self.throughput, name: "throughput", parent: name, max: 1000)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 125)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, max: 16000)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination = "deleteOnTermination"
            case encrypted = "encrypted"
            case iops = "iops"
            case kmsKeyId = "kmsKeyId"
            case snapshotId = "snapshotId"
            case throughput = "throughput"
            case volumeSize = "volumeSize"
            case volumeType = "volumeType"
        }
    }

    public struct EcrConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Tags for Image Builder to apply to the output container image that &INS; scans. Tags can
        /// 			help you identify and manage your scanned images.
        public let containerTags: [String]?
        /// The name of the container repository that Amazon Inspector scans to identify findings for your
        /// 			container images. The name includes the path for the repository location. If you don’t
        /// 			provide this information, Image Builder creates a repository in your account named
        /// 				image-builder-image-scanning-repository for vulnerability scans of your
        /// 			output container images.
        public let repositoryName: String?

        public init(containerTags: [String]? = nil, repositoryName: String? = nil) {
            self.containerTags = containerTags
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.containerTags?.forEach {
                try validate($0, name: "containerTags[]", parent: name, max: 1024)
                try validate($0, name: "containerTags[]", parent: name, min: 1)
            }
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 1024)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containerTags = "containerTags"
            case repositoryName = "repositoryName"
        }
    }

    public struct FastLaunchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The owner account ID for the fast-launch enabled Windows AMI.
        public let accountId: String?
        /// A Boolean that represents the current state of faster launching for the Windows AMI.
        /// 			Set to true to start using Windows faster launching, or false
        /// 			to stop using it.
        public let enabled: Bool
        /// The launch template that the fast-launch enabled Windows AMI uses when it launches
        /// 			Windows instances to create pre-provisioned snapshots.
        public let launchTemplate: FastLaunchLaunchTemplateSpecification?
        /// The maximum number of parallel instances that are launched for creating
        /// 			resources.
        public let maxParallelLaunches: Int?
        /// Configuration settings for managing the number of snapshots that are created from
        /// 			pre-provisioned instances for the Windows AMI when faster launching is enabled.
        public let snapshotConfiguration: FastLaunchSnapshotConfiguration?

        public init(accountId: String? = nil, enabled: Bool, launchTemplate: FastLaunchLaunchTemplateSpecification? = nil, maxParallelLaunches: Int? = nil, snapshotConfiguration: FastLaunchSnapshotConfiguration? = nil) {
            self.accountId = accountId
            self.enabled = enabled
            self.launchTemplate = launchTemplate
            self.maxParallelLaunches = maxParallelLaunches
            self.snapshotConfiguration = snapshotConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.launchTemplate?.validate(name: "\(name).launchTemplate")
            try self.validate(self.maxParallelLaunches, name: "maxParallelLaunches", parent: name, min: 1)
            try self.snapshotConfiguration?.validate(name: "\(name).snapshotConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case enabled = "enabled"
            case launchTemplate = "launchTemplate"
            case maxParallelLaunches = "maxParallelLaunches"
            case snapshotConfiguration = "snapshotConfiguration"
        }
    }

    public struct FastLaunchLaunchTemplateSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the launch template to use for faster launching for a Windows AMI.
        public let launchTemplateId: String?
        /// The name of the launch template to use for faster launching for a Windows AMI.
        public let launchTemplateName: String?
        /// The version of the launch template to use for faster launching for a Windows
        /// 			AMI.
        public let launchTemplateVersion: String?

        public init(launchTemplateId: String? = nil, launchTemplateName: String? = nil, launchTemplateVersion: String? = nil) {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.launchTemplateVersion = launchTemplateVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "^lt-[a-z0-9-_]{17}$")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, max: 1024)
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, min: 1)
            try self.validate(self.launchTemplateVersion, name: "launchTemplateVersion", parent: name, max: 1024)
            try self.validate(self.launchTemplateVersion, name: "launchTemplateVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateId = "launchTemplateId"
            case launchTemplateName = "launchTemplateName"
            case launchTemplateVersion = "launchTemplateVersion"
        }
    }

    public struct FastLaunchSnapshotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled
        /// 			Windows AMI.
        public let targetResourceCount: Int?

        public init(targetResourceCount: Int? = nil) {
            self.targetResourceCount = targetResourceCount
        }

        public func validate(name: String) throws {
            try self.validate(self.targetResourceCount, name: "targetResourceCount", parent: name, max: 10000)
            try self.validate(self.targetResourceCount, name: "targetResourceCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetResourceCount = "targetResourceCount"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter. Filter names are case-sensitive.
        public let name: String?
        /// The filter values. Filter values are case-sensitive.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]{1,1024}$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z./_ :-]{1,1024}$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct GetComponentPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the component whose policy you want to
        /// 			retrieve.
        public let componentArn: String

        public init(componentArn: String) {
            self.componentArn = componentArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.componentArn, key: "componentArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentPolicyResponse: AWSDecodableShape {
        /// The component policy.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetComponentRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the component that you want to get. Regex requires
        /// 			the suffix /\d+$.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.componentBuildVersionArn, key: "componentBuildVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentResponse: AWSDecodableShape {
        /// The component object specified in the request.
        public let component: Component?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(component: Component? = nil, requestId: String? = nil) {
            self.component = component
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
            case requestId = "requestId"
        }
    }

    public struct GetContainerRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe for the policy being
        /// 			requested.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.containerRecipeArn, key: "containerRecipeArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContainerRecipePolicyResponse: AWSDecodableShape {
        /// The container recipe policy object that is returned.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetContainerRecipeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.containerRecipeArn, key: "containerRecipeArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContainerRecipeResponse: AWSDecodableShape {
        /// The container recipe object that is returned.
        public let containerRecipe: ContainerRecipe?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipe: ContainerRecipe? = nil, requestId: String? = nil) {
            self.containerRecipe = containerRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipe = "containerRecipe"
            case requestId = "requestId"
        }
    }

    public struct GetDistributionConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to
        /// 			retrieve.
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.distributionConfigurationArn, key: "distributionConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDistributionConfigurationResponse: AWSDecodableShape {
        /// The distribution configuration object.
        public let distributionConfiguration: DistributionConfiguration?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfiguration: DistributionConfiguration? = nil, requestId: String? = nil) {
            self.distributionConfiguration = distributionConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfiguration = "distributionConfiguration"
            case requestId = "requestId"
        }
    }

    public struct GetImagePipelineRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imagePipelineArn, key: "imagePipelineArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePipelineResponse: AWSDecodableShape {
        /// The image pipeline object.
        public let imagePipeline: ImagePipeline?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipeline: ImagePipeline? = nil, requestId: String? = nil) {
            self.imagePipeline = imagePipeline
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipeline = "imagePipeline"
            case requestId = "requestId"
        }
    }

    public struct GetImagePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
        public let imageArn: String

        public init(imageArn: String) {
            self.imageArn = imageArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imageArn, key: "imageArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePolicyResponse: AWSDecodableShape {
        /// The image policy object.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetImageRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to
        /// 			retrieve.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imageRecipeArn, key: "imageRecipeArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipePolicyResponse: AWSDecodableShape {
        /// The image recipe policy object.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetImageRecipeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imageRecipeArn, key: "imageRecipeArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipeResponse: AWSDecodableShape {
        /// The image recipe object.
        public let imageRecipe: ImageRecipe?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipe: ImageRecipe? = nil, requestId: String? = nil) {
            self.imageRecipe = imageRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipe = "imageRecipe"
            case requestId = "requestId"
        }
    }

    public struct GetImageRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image that you want to get.
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.imageBuildVersionArn, key: "imageBuildVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageResponse: AWSDecodableShape {
        /// The image object.
        public let image: Image?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(image: Image? = nil, requestId: String? = nil) {
            self.image = image
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
            case requestId = "requestId"
        }
    }

    public struct GetInfrastructureConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
        /// 			retrieve.
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.infrastructureConfigurationArn, key: "infrastructureConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The infrastructure configuration object.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfiguration: InfrastructureConfiguration? = nil, requestId: String? = nil) {
            self.infrastructureConfiguration = infrastructureConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfiguration = "infrastructureConfiguration"
            case requestId = "requestId"
        }
    }

    public struct GetLifecycleExecutionRequest: AWSEncodableShape {
        /// Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
        public let lifecycleExecutionId: String

        public init(lifecycleExecutionId: String) {
            self.lifecycleExecutionId = lifecycleExecutionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.lifecycleExecutionId, key: "lifecycleExecutionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecycleExecutionId, name: "lifecycleExecutionId", parent: name, pattern: "^lce-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLifecycleExecutionResponse: AWSDecodableShape {
        /// Runtime details for the specified runtime instance of the lifecycle policy.
        public let lifecycleExecution: LifecycleExecution?

        public init(lifecycleExecution: LifecycleExecution? = nil) {
            self.lifecycleExecution = lifecycleExecution
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleExecution = "lifecycleExecution"
        }
    }

    public struct GetLifecyclePolicyRequest: AWSEncodableShape {
        /// Specifies the Amazon Resource Name (ARN) of the image lifecycle policy resource to get.
        public let lifecyclePolicyArn: String

        public init(lifecyclePolicyArn: String) {
            self.lifecyclePolicyArn = lifecyclePolicyArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.lifecyclePolicyArn, key: "lifecyclePolicyArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyArn, name: "lifecyclePolicyArn", parent: name, max: 1024)
            try self.validate(self.lifecyclePolicyArn, name: "lifecyclePolicyArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):lifecycle-policy/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLifecyclePolicyResponse: AWSDecodableShape {
        /// The ARN of the image lifecycle policy resource that was returned.
        public let lifecyclePolicy: LifecyclePolicy?

        public init(lifecyclePolicy: LifecyclePolicy? = nil) {
            self.lifecyclePolicy = lifecyclePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicy = "lifecyclePolicy"
        }
    }

    public struct GetWorkflowExecutionRequest: AWSEncodableShape {
        /// Use the unique identifier for a runtime instance of the workflow to get
        /// 			runtime details.
        public let workflowExecutionId: String

        public init(workflowExecutionId: String) {
            self.workflowExecutionId = workflowExecutionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.workflowExecutionId, key: "workflowExecutionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowExecutionId, name: "workflowExecutionId", parent: name, pattern: "^wf-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowExecutionResponse: AWSDecodableShape {
        /// The timestamp when the specified runtime instance of the workflow finished.
        public let endTime: String?
        /// The Amazon Resource Name (ARN) of the image resource build version that the specified
        /// 			runtime instance of the workflow created.
        public let imageBuildVersionArn: String?
        /// The output message from the specified runtime instance of the workflow, if applicable.
        public let message: String?
        /// Test workflows are defined within named runtime groups. The parallel group
        /// 			is a named group that contains one or more test workflows.
        public let parallelGroup: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?
        /// The timestamp when the specified runtime instance of the workflow started.
        public let startTime: String?
        /// The current runtime status for the specified runtime instance of the workflow.
        public let status: WorkflowExecutionStatus?
        /// The total number of steps in the specified runtime instance of the workflow that ran.
        /// 			This number should equal the sum of the step counts for steps that succeeded, were skipped,
        /// 			and failed.
        public let totalStepCount: Int?
        /// A runtime count for the number of steps that failed in the specified runtime instance
        /// 			of the workflow.
        public let totalStepsFailed: Int?
        /// A runtime count for the number of steps that were skipped in the specified runtime
        /// 			instance of the workflow.
        public let totalStepsSkipped: Int?
        /// A runtime count for the number of steps that ran successfully in the specified runtime
        /// 			instance of the workflow.
        public let totalStepsSucceeded: Int?
        /// The type of workflow that Image Builder ran for the specified runtime instance of the workflow.
        public let type: WorkflowType?
        /// The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource
        /// 			that defines the specified runtime instance of the workflow.
        public let workflowBuildVersionArn: String?
        /// The unique identifier that Image Builder assigned to keep track of runtime details
        /// 			when it ran the workflow.
        public let workflowExecutionId: String?

        public init(endTime: String? = nil, imageBuildVersionArn: String? = nil, message: String? = nil, parallelGroup: String? = nil, requestId: String? = nil, startTime: String? = nil, status: WorkflowExecutionStatus? = nil, totalStepCount: Int? = nil, totalStepsFailed: Int? = nil, totalStepsSkipped: Int? = nil, totalStepsSucceeded: Int? = nil, type: WorkflowType? = nil, workflowBuildVersionArn: String? = nil, workflowExecutionId: String? = nil) {
            self.endTime = endTime
            self.imageBuildVersionArn = imageBuildVersionArn
            self.message = message
            self.parallelGroup = parallelGroup
            self.requestId = requestId
            self.startTime = startTime
            self.status = status
            self.totalStepCount = totalStepCount
            self.totalStepsFailed = totalStepsFailed
            self.totalStepsSkipped = totalStepsSkipped
            self.totalStepsSucceeded = totalStepsSucceeded
            self.type = type
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case message = "message"
            case parallelGroup = "parallelGroup"
            case requestId = "requestId"
            case startTime = "startTime"
            case status = "status"
            case totalStepCount = "totalStepCount"
            case totalStepsFailed = "totalStepsFailed"
            case totalStepsSkipped = "totalStepsSkipped"
            case totalStepsSucceeded = "totalStepsSucceeded"
            case type = "type"
            case workflowBuildVersionArn = "workflowBuildVersionArn"
            case workflowExecutionId = "workflowExecutionId"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the workflow resource that you want to get.
        public let workflowBuildVersionArn: String

        public init(workflowBuildVersionArn: String) {
            self.workflowBuildVersionArn = workflowBuildVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.workflowBuildVersionArn, key: "workflowBuildVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowBuildVersionArn, name: "workflowBuildVersionArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):workflow/(build|test|distribution)/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// The workflow resource specified in the request.
        public let workflow: Workflow?

        public init(workflow: Workflow? = nil) {
            self.workflow = workflow
        }

        private enum CodingKeys: String, CodingKey {
            case workflow = "workflow"
        }
    }

    public struct GetWorkflowStepExecutionRequest: AWSEncodableShape {
        /// Use the unique identifier for a specific runtime instance of the workflow step to
        /// 			get runtime details for that step.
        public let stepExecutionId: String

        public init(stepExecutionId: String) {
            self.stepExecutionId = stepExecutionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.stepExecutionId, key: "stepExecutionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.stepExecutionId, name: "stepExecutionId", parent: name, pattern: "^step-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowStepExecutionResponse: AWSDecodableShape {
        /// The name of the action that the specified step performs.
        public let action: String?
        /// Describes the specified workflow step.
        public let description: String?
        /// The timestamp when the specified runtime instance of the workflow step finished.
        public let endTime: String?
        /// The Amazon Resource Name (ARN) of the image resource build version that the specified
        /// 			runtime instance of the workflow step creates.
        public let imageBuildVersionArn: String?
        /// Input parameters that Image Builder provided for the specified runtime instance of
        /// 			the workflow step.
        public let inputs: String?
        /// The output message from the specified runtime instance of the workflow step, if applicable.
        public let message: String?
        /// The name of the specified runtime instance of the workflow step.
        public let name: String?
        /// The action to perform if the workflow step fails.
        public let onFailure: String?
        /// The file names that the specified runtime version of the workflow step created as output.
        public let outputs: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?
        /// Reports on the rollback status of the specified runtime version of the workflow step,
        /// 			if applicable.
        public let rollbackStatus: WorkflowStepExecutionRollbackStatus?
        /// The timestamp when the specified runtime version of the workflow step started.
        public let startTime: String?
        /// The current status for the specified runtime version of the workflow step.
        public let status: WorkflowStepExecutionStatus?
        /// The unique identifier for the runtime version of the workflow step that you specified
        /// 			in the request.
        public let stepExecutionId: String?
        /// The maximum duration in seconds for this step to complete its action.
        public let timeoutSeconds: Int?
        /// The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource
        /// 			that defines this workflow step.
        public let workflowBuildVersionArn: String?
        /// The unique identifier that Image Builder assigned to keep track of runtime details
        /// 			when it ran the workflow.
        public let workflowExecutionId: String?

        public init(action: String? = nil, description: String? = nil, endTime: String? = nil, imageBuildVersionArn: String? = nil, inputs: String? = nil, message: String? = nil, name: String? = nil, onFailure: String? = nil, outputs: String? = nil, requestId: String? = nil, rollbackStatus: WorkflowStepExecutionRollbackStatus? = nil, startTime: String? = nil, status: WorkflowStepExecutionStatus? = nil, stepExecutionId: String? = nil, timeoutSeconds: Int? = nil, workflowBuildVersionArn: String? = nil, workflowExecutionId: String? = nil) {
            self.action = action
            self.description = description
            self.endTime = endTime
            self.imageBuildVersionArn = imageBuildVersionArn
            self.inputs = inputs
            self.message = message
            self.name = name
            self.onFailure = onFailure
            self.outputs = outputs
            self.requestId = requestId
            self.rollbackStatus = rollbackStatus
            self.startTime = startTime
            self.status = status
            self.stepExecutionId = stepExecutionId
            self.timeoutSeconds = timeoutSeconds
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case endTime = "endTime"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case inputs = "inputs"
            case message = "message"
            case name = "name"
            case onFailure = "onFailure"
            case outputs = "outputs"
            case requestId = "requestId"
            case rollbackStatus = "rollbackStatus"
            case startTime = "startTime"
            case status = "status"
            case stepExecutionId = "stepExecutionId"
            case timeoutSeconds = "timeoutSeconds"
            case workflowBuildVersionArn = "workflowBuildVersionArn"
            case workflowExecutionId = "workflowExecutionId"
        }
    }

    public struct Image: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image.  Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:   Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.   Version ARNs have only the first three nodes: ..   Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public let arn: String?
        /// Indicates the type of build that created this image. The build can be initiated in the
        /// 			following ways:    USER_INITIATED – A manual
        /// 					pipeline build request.    SCHEDULED – A pipeline build
        /// 					initiated by a cron expression in the Image Builder pipeline, or from EventBridge.    IMPORT – A VM import created
        /// 					the image to use as the base image for the recipe.
        public let buildType: BuildType?
        /// For container images, this is the container recipe that Image Builder used to create the
        /// 			image. For images that distribute an AMI, this is empty.
        public let containerRecipe: ContainerRecipe?
        /// The date on which Image Builder created this image.
        public let dateCreated: String?
        /// The time when deprecation occurs for an image resource. This can be a past or future date.
        public let deprecationTime: Date?
        /// The distribution configuration that Image Builder used to create this image.
        public let distributionConfiguration: DistributionConfiguration?
        /// Indicates whether Image Builder collects additional information about the image, such as
        /// 			the operating system (OS) version and package list.
        public let enhancedImageMetadataEnabled: Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants
        /// 			Image Builder access to perform workflow actions.
        public let executionRole: String?
        /// For images that distribute an AMI, this is the image recipe that Image Builder used to
        /// 			create the image. For container images, this is empty.
        public let imageRecipe: ImageRecipe?
        /// Contains settings for vulnerability scans.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The origin of the base image that Image Builder used to build this image.
        public let imageSource: ImageSource?
        /// The image tests that ran when that Image Builder created this image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The infrastructure that Image Builder used to create this image.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// Identifies the last runtime instance of the lifecycle policy to take action on the image.
        public let lifecycleExecutionId: String?
        /// The name of the image.
        public let name: String?
        /// The operating system version for instances that launch from this image. For example,
        /// 			Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The output resources that Image Builder produces for this image.
        public let outputResources: OutputResources?
        /// The image operating system platform, such as Linux or Windows.
        public let platform: Platform?
        /// Contains information about the current state of scans for this image.
        public let scanState: ImageScanState?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public let sourcePipelineArn: String?
        /// The name of the image pipeline that created this image.
        public let sourcePipelineName: String?
        /// The state of the image.
        public let state: ImageState?
        /// The tags that apply to this image.
        public let tags: [String: String]?
        /// Specifies whether this image produces an AMI or a container image.
        public let type: ImageType?
        /// The semantic version of the image.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        public let version: String?
        /// Contains the build and test workflows that are associated with the image.
        public let workflows: [WorkflowConfiguration]?

        public init(arn: String? = nil, buildType: BuildType? = nil, containerRecipe: ContainerRecipe? = nil, dateCreated: String? = nil, deprecationTime: Date? = nil, distributionConfiguration: DistributionConfiguration? = nil, enhancedImageMetadataEnabled: Bool? = nil, executionRole: String? = nil, imageRecipe: ImageRecipe? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageSource: ImageSource? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfiguration: InfrastructureConfiguration? = nil, lifecycleExecutionId: String? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, platform: Platform? = nil, scanState: ImageScanState? = nil, sourcePipelineArn: String? = nil, sourcePipelineName: String? = nil, state: ImageState? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil, workflows: [WorkflowConfiguration]? = nil) {
            self.arn = arn
            self.buildType = buildType
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.deprecationTime = deprecationTime
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imageRecipe = imageRecipe
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageSource = imageSource
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.lifecycleExecutionId = lifecycleExecutionId
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.scanState = scanState
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildType = "buildType"
            case containerRecipe = "containerRecipe"
            case dateCreated = "dateCreated"
            case deprecationTime = "deprecationTime"
            case distributionConfiguration = "distributionConfiguration"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case executionRole = "executionRole"
            case imageRecipe = "imageRecipe"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageSource = "imageSource"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfiguration = "infrastructureConfiguration"
            case lifecycleExecutionId = "lifecycleExecutionId"
            case name = "name"
            case osVersion = "osVersion"
            case outputResources = "outputResources"
            case platform = "platform"
            case scanState = "scanState"
            case sourcePipelineArn = "sourcePipelineArn"
            case sourcePipelineName = "sourcePipelineName"
            case state = "state"
            case tags = "tags"
            case type = "type"
            case version = "version"
            case workflows = "workflows"
        }
    }

    public struct ImageAggregation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the image for this aggregation.
        public let imageBuildVersionArn: String?
        /// Counts by severity level for medium severity and higher level findings, plus a total
        /// 			for all of the findings for the specified image.
        public let severityCounts: SeverityCounts?

        public init(imageBuildVersionArn: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case severityCounts = "severityCounts"
        }
    }

    public struct ImagePackage: AWSDecodableShape {
        /// The name of the package as reported to the operating system package manager.
        public let packageName: String?
        /// The version of the package as reported to the operating system package manager.
        public let packageVersion: String?

        public init(packageName: String? = nil, packageVersion: String? = nil) {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageName = "packageName"
            case packageVersion = "packageVersion"
        }
    }

    public struct ImagePipeline: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public let arn: String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this
        /// 			pipeline.
        public let containerRecipeArn: String?
        /// The date on which this image pipeline was created.
        public let dateCreated: String?
        /// This is no longer supported, and does not return a value.
        public let dateLastRun: String?
        /// The next date when the pipeline is scheduled to run.
        public let dateNextRun: String?
        /// The date on which this image pipeline was last updated.
        public let dateUpdated: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this
        /// 			image pipeline.
        public let distributionConfigurationArn: String?
        /// Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants
        /// 			Image Builder access to perform workflow actions.
        public let executionRole: String?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image
        /// 			pipeline.
        public let imageRecipeArn: String?
        /// Contains settings for vulnerability scans.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The image tests configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with
        /// 			this image pipeline.
        public let infrastructureConfigurationArn: String?
        /// The name of the image pipeline.
        public let name: String?
        /// The platform of the image pipeline.
        public let platform: Platform?
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?
        /// The tags of this image pipeline.
        public let tags: [String: String]?
        /// Contains the workflows that run for the image pipeline.
        public let workflows: [WorkflowConfiguration]?

        public init(arn: String? = nil, containerRecipeArn: String? = nil, dateCreated: String? = nil, dateLastRun: String? = nil, dateNextRun: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, executionRole: String? = nil, imageRecipeArn: String? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String? = nil, name: String? = nil, platform: Platform? = nil, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil, workflows: [WorkflowConfiguration]? = nil) {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imageRecipeArn = imageRecipeArn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case containerRecipeArn = "containerRecipeArn"
            case dateCreated = "dateCreated"
            case dateLastRun = "dateLastRun"
            case dateNextRun = "dateNextRun"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case executionRole = "executionRole"
            case imageRecipeArn = "imageRecipeArn"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case name = "name"
            case platform = "platform"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
            case workflows = "workflows"
        }
    }

    public struct ImagePipelineAggregation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the image pipeline for this
        /// 			aggregation.
        public let imagePipelineArn: String?
        /// Counts by severity level for medium severity and higher level findings, plus a total
        /// 			for all of the findings for the specified image pipeline.
        public let severityCounts: SeverityCounts?

        public init(imagePipelineArn: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.imagePipelineArn = imagePipelineArn
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineArn = "imagePipelineArn"
            case severityCounts = "severityCounts"
        }
    }

    public struct ImageRecipe: AWSDecodableShape {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test
        /// 			your image configuration. Instance configuration adds a layer of control over those
        /// 			instances. You can define settings and add scripts to run when an instance is launched
        /// 			from your AMI.
        public let additionalInstanceConfiguration: AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The block device mappings to apply when creating images from this recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The components that are included in the image recipe. Recipes require a minimum of one build component, and can
        /// 			have a maximum of 20 build and test components in any combination.
        public let components: [ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The description of the image recipe.
        public let description: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The base image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?
        /// Specifies which type of image is created by the recipe - an AMI or a container
        /// 			image.
        public let type: ImageType?
        /// The version of the image recipe.
        public let version: String?
        /// The working directory to be used during build and test workflows.
        public let workingDirectory: String?

        public init(additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil, arn: String? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, components: [ComponentConfiguration]? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil, workingDirectory: String? = nil) {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInstanceConfiguration = "additionalInstanceConfiguration"
            case arn = "arn"
            case blockDeviceMappings = "blockDeviceMappings"
            case components = "components"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case parentImage = "parentImage"
            case platform = "platform"
            case tags = "tags"
            case type = "type"
            case version = "version"
            case workingDirectory = "workingDirectory"
        }
    }

    public struct ImageRecipeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The base image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case name = "name"
            case owner = "owner"
            case parentImage = "parentImage"
            case platform = "platform"
            case tags = "tags"
        }
    }

    public struct ImageScanFinding: AWSDecodableShape {
        /// The Amazon Web Services account ID that's associated with the finding.
        public let awsAccountId: String?
        /// The description of the finding.
        public let description: String?
        /// The date and time when the finding was first observed.
        public let firstObservedAt: Date?
        /// Details about whether a fix is available for any of the packages that are identified
        /// 			in the finding through a version update.
        public let fixAvailable: String?
        /// The Amazon Resource Name (ARN) of the image build version that's associated with the
        /// 			finding.
        public let imageBuildVersionArn: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that's associated with the
        /// 			finding.
        public let imagePipelineArn: String?
        /// The score that Amazon Inspector assigned for the finding.
        public let inspectorScore: Double?
        /// An object that contains details of the Amazon Inspector score.
        public let inspectorScoreDetails: InspectorScoreDetails?
        /// An object that contains the details of a package vulnerability finding.
        public let packageVulnerabilityDetails: PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate the finding.
        public let remediation: Remediation?
        /// The severity of the finding.
        public let severity: String?
        /// The title of the finding.
        public let title: String?
        /// The type of the finding. Image Builder looks for findings of the type
        /// 				PACKAGE_VULNERABILITY that apply to output images, and excludes other
        /// 			types.
        public let type: String?
        /// The timestamp when the finding was last updated.
        public let updatedAt: Date?

        public init(awsAccountId: String? = nil, description: String? = nil, firstObservedAt: Date? = nil, fixAvailable: String? = nil, imageBuildVersionArn: String? = nil, imagePipelineArn: String? = nil, inspectorScore: Double? = nil, inspectorScoreDetails: InspectorScoreDetails? = nil, packageVulnerabilityDetails: PackageVulnerabilityDetails? = nil, remediation: Remediation? = nil, severity: String? = nil, title: String? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.imageBuildVersionArn = imageBuildVersionArn
            self.imagePipelineArn = imagePipelineArn
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case description = "description"
            case firstObservedAt = "firstObservedAt"
            case fixAvailable = "fixAvailable"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case imagePipelineArn = "imagePipelineArn"
            case inspectorScore = "inspectorScore"
            case inspectorScoreDetails = "inspectorScoreDetails"
            case packageVulnerabilityDetails = "packageVulnerabilityDetails"
            case remediation = "remediation"
            case severity = "severity"
            case title = "title"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct ImageScanFindingAggregation: AWSDecodableShape {
        /// Returns an object that contains severity counts based on an account ID.
        public let accountAggregation: AccountAggregation?
        /// Returns an object that contains severity counts based on the Amazon Resource Name
        /// 			(ARN) for a specific image.
        public let imageAggregation: ImageAggregation?
        /// Returns an object that contains severity counts based on an image pipeline ARN.
        public let imagePipelineAggregation: ImagePipelineAggregation?
        /// Returns an object that contains severity counts based on vulnerability ID.
        public let vulnerabilityIdAggregation: VulnerabilityIdAggregation?

        public init(accountAggregation: AccountAggregation? = nil, imageAggregation: ImageAggregation? = nil, imagePipelineAggregation: ImagePipelineAggregation? = nil, vulnerabilityIdAggregation: VulnerabilityIdAggregation? = nil) {
            self.accountAggregation = accountAggregation
            self.imageAggregation = imageAggregation
            self.imagePipelineAggregation = imagePipelineAggregation
            self.vulnerabilityIdAggregation = vulnerabilityIdAggregation
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregation = "accountAggregation"
            case imageAggregation = "imageAggregation"
            case imagePipelineAggregation = "imagePipelineAggregation"
            case vulnerabilityIdAggregation = "vulnerabilityIdAggregation"
        }
    }

    public struct ImageScanFindingsFilter: AWSEncodableShape {
        /// The name of the image scan finding filter. Filter names are case-sensitive.
        public let name: String?
        /// The filter values. Filter values are case-sensitive.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]{1,1024}$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z./_ :-]{1,1024}$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct ImageScanState: AWSDecodableShape {
        /// The reason for the scan status for the image.
        public let reason: String?
        /// The current state of vulnerability scans for the image.
        public let status: ImageScanStatus?

        public init(reason: String? = nil, status: ImageScanStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct ImageScanningConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains Amazon ECR settings for vulnerability scans.
        public let ecrConfiguration: EcrConfiguration?
        /// A setting that indicates whether Image Builder keeps a snapshot of the vulnerability scans that
        /// 			Amazon Inspector runs against the build instance when you create a new image.
        public let imageScanningEnabled: Bool?

        public init(ecrConfiguration: EcrConfiguration? = nil, imageScanningEnabled: Bool? = nil) {
            self.ecrConfiguration = ecrConfiguration
            self.imageScanningEnabled = imageScanningEnabled
        }

        public func validate(name: String) throws {
            try self.ecrConfiguration?.validate(name: "\(name).ecrConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case ecrConfiguration = "ecrConfiguration"
            case imageScanningEnabled = "imageScanningEnabled"
        }
    }

    public struct ImageState: AWSDecodableShape {
        /// The reason for the status of the image.
        public let reason: String?
        /// The status of the image.
        public let status: ImageStatus?

        public init(reason: String? = nil, status: ImageStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct ImageSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image.
        public let arn: String?
        /// Indicates the type of build that created this image. The build can be initiated in the
        /// 			following ways:    USER_INITIATED – A manual
        /// 					pipeline build request.    SCHEDULED – A pipeline build
        /// 					initiated by a cron expression in the Image Builder pipeline, or from EventBridge.    IMPORT – A VM import created
        /// 					the image to use as the base image for the recipe.
        public let buildType: BuildType?
        /// The date on which Image Builder created this image.
        public let dateCreated: String?
        /// The time when deprecation occurs for an image resource. This can be a past or future date.
        public let deprecationTime: Date?
        /// The origin of the base image that Image Builder used to build this image.
        public let imageSource: ImageSource?
        /// Identifies the last runtime instance of the lifecycle policy to take action on the image.
        public let lifecycleExecutionId: String?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instances that launch from this image. For
        /// 			example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The output resources that Image Builder produced when it created this image.
        public let outputResources: OutputResources?
        /// The owner of the image.
        public let owner: String?
        /// The image operating system platform, such as Linux or Windows.
        public let platform: Platform?
        /// The state of the image.
        public let state: ImageState?
        /// The tags that apply to this image.
        public let tags: [String: String]?
        /// Specifies whether this image produces an AMI or a container image.
        public let type: ImageType?
        /// The version of the image.
        public let version: String?

        public init(arn: String? = nil, buildType: BuildType? = nil, dateCreated: String? = nil, deprecationTime: Date? = nil, imageSource: ImageSource? = nil, lifecycleExecutionId: String? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, owner: String? = nil, platform: Platform? = nil, state: ImageState? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.deprecationTime = deprecationTime
            self.imageSource = imageSource
            self.lifecycleExecutionId = lifecycleExecutionId
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildType = "buildType"
            case dateCreated = "dateCreated"
            case deprecationTime = "deprecationTime"
            case imageSource = "imageSource"
            case lifecycleExecutionId = "lifecycleExecutionId"
            case name = "name"
            case osVersion = "osVersion"
            case outputResources = "outputResources"
            case owner = "owner"
            case platform = "platform"
            case state = "state"
            case tags = "tags"
            case type = "type"
            case version = "version"
        }
    }

    public struct ImageTestsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines if tests should run after building the image. Image Builder defaults to enable tests
        /// 			to run following the image build, before image distribution.
        public let imageTestsEnabled: Bool?
        /// The maximum time in minutes that tests are permitted to run.  The timeoutMinutes attribute is not currently active. This value is
        /// 				ignored.
        public let timeoutMinutes: Int?

        public init(imageTestsEnabled: Bool? = nil, timeoutMinutes: Int? = nil) {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, max: 1440)
            try self.validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case imageTestsEnabled = "imageTestsEnabled"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct ImageVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a specific version of an Image Builder image.  Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:   Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.   Version ARNs have only the first three nodes: ..   Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public let arn: String?
        /// Indicates the type of build that created this image. The build can be initiated in the
        /// 			following ways:    USER_INITIATED – A manual
        /// 					pipeline build request.    SCHEDULED – A pipeline build
        /// 					initiated by a cron expression in the Image Builder pipeline, or from EventBridge.    IMPORT – A VM import created
        /// 					the image to use as the base image for the recipe.
        public let buildType: BuildType?
        /// The date on which this specific version of the Image Builder image was created.
        public let dateCreated: String?
        /// The origin of the base image that Image Builder used to build this image.
        public let imageSource: ImageSource?
        /// The name of this specific version of an Image Builder image.
        public let name: String?
        /// The operating system version of the Amazon EC2 build instance. For example, Amazon Linux 2,
        /// 			Ubuntu 18, or Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The owner of the image version.
        public let owner: String?
        /// The operating system platform of the image version, for example "Windows" or
        /// 			"Linux".
        public let platform: Platform?
        /// Specifies whether this image produces an AMI or a container image.
        public let type: ImageType?
        /// Details for a specific version of an Image Builder image. This version follows the semantic
        /// 			version syntax.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        public let version: String?

        public init(arn: String? = nil, buildType: BuildType? = nil, dateCreated: String? = nil, imageSource: ImageSource? = nil, name: String? = nil, osVersion: String? = nil, owner: String? = nil, platform: Platform? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.imageSource = imageSource
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case buildType = "buildType"
            case dateCreated = "dateCreated"
            case imageSource = "imageSource"
            case name = "name"
            case osVersion = "osVersion"
            case owner = "owner"
            case platform = "platform"
            case type = "type"
            case version = "version"
        }
    }

    public struct ImportComponentRequest: AWSEncodableShape {
        /// The change description of the component. This description indicates the change that
        /// 			has been made in this version, or what makes this version different from other versions
        /// 			of the component.
        public let changeDescription: String?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The data of the component. Used to specify the data inline. Either data
        /// 			or uri can be used to specify the data within the component.
        public let data: String?
        /// The description of the component. Describes the contents of the component.
        public let description: String?
        /// The format of the resource that you want to import as a component.
        public let format: ComponentFormat
        /// The ID of the KMS key that should be used to encrypt this component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String
        /// The platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version
        /// 			syntax.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        public let semanticVersion: String
        /// The tags of the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image, or
        /// 			only to test it.
        public let type: ComponentType
        /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission
        /// 			to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your
        /// 			service quota. Either data or uri can be used to specify the
        /// 			data within the component.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = ImportComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, format: ComponentFormat, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, tags: [String: String]? = nil, type: ComponentType, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.format = format
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 1024)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription = "changeDescription"
            case clientToken = "clientToken"
            case data = "data"
            case description = "description"
            case format = "format"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case platform = "platform"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
            case type = "type"
            case uri = "uri"
        }
    }

    public struct ImportComponentResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the imported component.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case componentBuildVersionArn = "componentBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct ImportVmImageRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The description for the base image that is created by the import process.
        public let description: String?
        /// The name of the base image that is created by the import process.
        public let name: String
        /// The operating system version for the imported VM.
        public let osVersion: String?
        /// The operating system platform for the imported VM.
        public let platform: Platform
        /// The semantic version to attach to the base image that was created during the import
        /// 			process. This version follows the semantic version syntax.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.  Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        public let semanticVersion: String
        /// Tags that are attached to the import resources.
        public let tags: [String: String]?
        /// The importTaskId (API) or ImportTaskId (CLI) from the
        /// 			Amazon EC2 VM import process. Image Builder retrieves information from the import process to pull in
        /// 			the AMI that is created from the VM source as the base image for your recipe.
        public let vmImportTaskId: String

        public init(clientToken: String = ImportVmImageRequest.idempotencyToken(), description: String? = nil, name: String, osVersion: String? = nil, platform: Platform, semanticVersion: String, tags: [String: String]? = nil, vmImportTaskId: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.osVersion = osVersion
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.vmImportTaskId = vmImportTaskId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.osVersion, name: "osVersion", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.vmImportTaskId, name: "vmImportTaskId", parent: name, max: 1024)
            try self.validate(self.vmImportTaskId, name: "vmImportTaskId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case osVersion = "osVersion"
            case platform = "platform"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
            case vmImportTaskId = "vmImportTaskId"
        }
    }

    public struct ImportVmImageResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the AMI that was created during the VM import
        /// 			process. This AMI is used as the base image for the recipe that imported the VM.
        public let imageArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageArn = imageArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageArn = "imageArn"
            case requestId = "requestId"
        }
    }

    public struct InfrastructureConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance metadata option settings for the infrastructure configuration.
        public let instanceMetadataOptions: InstanceMetadataOptions?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs of the infrastructure configuration.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event
        /// 			notifications.  EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys
        /// 				from other accounts. The key that is used to encrypt the SNS topic must reside in the
        /// 				account that the Image Builder service runs under.
        public let snsTopicArn: String?
        /// The subnet ID of the infrastructure configuration.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure configuration of the infrastructure
        /// 			configuration.
        public let terminateInstanceOnFailure: Bool?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceMetadataOptions: InstanceMetadataOptions? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String? = nil, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case instanceMetadataOptions = "instanceMetadataOptions"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case keyPair = "keyPair"
            case logging = "logging"
            case name = "name"
            case resourceTags = "resourceTags"
            case securityGroupIds = "securityGroupIds"
            case snsTopicArn = "snsTopicArn"
            case subnetId = "subnetId"
            case tags = "tags"
            case terminateInstanceOnFailure = "terminateInstanceOnFailure"
        }
    }

    public struct InfrastructureConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags attached to the image created by Image Builder.
        public let resourceTags: [String: String]?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, name: String? = nil, resourceTags: [String: String]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.resourceTags = resourceTags
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case name = "name"
            case resourceTags = "resourceTags"
            case tags = "tags"
        }
    }

    public struct InspectorScoreDetails: AWSDecodableShape {
        /// An object that contains details about an adjustment that Amazon Inspector made to the CVSS score
        /// 			for the finding.
        public let adjustedCvss: CvssScoreDetails?

        public init(adjustedCvss: CvssScoreDetails? = nil) {
            self.adjustedCvss = adjustedCvss
        }

        private enum CodingKeys: String, CodingKey {
            case adjustedCvss = "adjustedCvss"
        }
    }

    public struct InstanceBlockDeviceMapping: AWSEncodableShape & AWSDecodableShape {
        /// The device to which these mappings apply.
        public let deviceName: String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public let ebs: EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the base image.
        public let noDevice: String?
        /// Use to manage instance ephemeral devices.
        public let virtualName: String?

        public init(deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 1024)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 1)
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.noDevice, name: "noDevice", parent: name, max: 0)
            try self.validate(self.virtualName, name: "virtualName", parent: name, max: 1024)
            try self.validate(self.virtualName, name: "virtualName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "deviceName"
            case ebs = "ebs"
            case noDevice = "noDevice"
            case virtualName = "virtualName"
        }
    }

    public struct InstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the block devices to attach for building an instance from this Image Builder
        /// 			AMI.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not
        /// 			specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public let image: String?

        public init(blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, image: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.image, name: "image", parent: name, max: 1024)
            try self.validate(self.image, name: "image", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappings = "blockDeviceMappings"
            case image = "image"
        }
    }

    public struct InstanceMetadataOptions: AWSEncodableShape & AWSDecodableShape {
        /// Limit the number of hops that an instance metadata request can traverse to reach its
        /// 			destination. The default is one hop. However, if HTTP tokens are required, container
        /// 			image builds need a minimum of two hops.
        public let httpPutResponseHopLimit: Int?
        /// Indicates whether a signed token header is required for instance metadata retrieval
        /// 			requests. The values affect the response as follows:    required – When you retrieve the IAM
        /// 					role credentials, version 2.0 credentials are returned in all cases.    optional – You can include a signed
        /// 					token header in your request to retrieve instance metadata, or you can leave it
        /// 					out. If you include it, version 2.0 credentials are returned for the IAM role.
        /// 					Otherwise, version 1.0 credentials are returned.   The default setting is optional.
        public let httpTokens: String?

        public init(httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil) {
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.httpPutResponseHopLimit, name: "httpPutResponseHopLimit", parent: name, max: 64)
            try self.validate(self.httpPutResponseHopLimit, name: "httpPutResponseHopLimit", parent: name, min: 1)
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "^optional|required$")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPutResponseHopLimit = "httpPutResponseHopLimit"
            case httpTokens = "httpTokens"
        }
    }

    public struct LaunchPermissionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
        /// 			For more information about key concepts for Organizations, see Organizations
        /// 				terminology and concepts.
        public let organizationalUnitArns: [String]?
        /// The ARN for an Amazon Web Services Organization that you want to share your AMI with. For more
        /// 			information, see What is
        /// 				Organizations?.
        public let organizationArns: [String]?
        /// The name of the group.
        public let userGroups: [String]?
        /// The Amazon Web Services account ID.
        public let userIds: [String]?

        public init(organizationalUnitArns: [String]? = nil, organizationArns: [String]? = nil, userGroups: [String]? = nil, userIds: [String]? = nil) {
            self.organizationalUnitArns = organizationalUnitArns
            self.organizationArns = organizationArns
            self.userGroups = userGroups
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.organizationalUnitArns?.forEach {
                try validate($0, name: "organizationalUnitArns[]", parent: name, pattern: "^arn:aws[^:]*:organizations::[0-9]{12}:ou/o-[a-z0-9]{10,32}/ou-[0-9a-z]{4,32}-[0-9a-z]{8,32}$")
            }
            try self.validate(self.organizationalUnitArns, name: "organizationalUnitArns", parent: name, max: 25)
            try self.validate(self.organizationalUnitArns, name: "organizationalUnitArns", parent: name, min: 1)
            try self.organizationArns?.forEach {
                try validate($0, name: "organizationArns[]", parent: name, pattern: "^arn:aws[^:]*:organizations::[0-9]{12}:organization/o-[a-z0-9]{10,32}$")
            }
            try self.validate(self.organizationArns, name: "organizationArns", parent: name, max: 25)
            try self.validate(self.organizationArns, name: "organizationArns", parent: name, min: 1)
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 1024)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.userIds, name: "userIds", parent: name, max: 1536)
            try self.validate(self.userIds, name: "userIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case organizationalUnitArns = "organizationalUnitArns"
            case organizationArns = "organizationArns"
            case userGroups = "userGroups"
            case userIds = "userIds"
        }
    }

    public struct LaunchTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The account ID that this configuration applies to.
        public let accountId: String?
        /// Identifies the Amazon EC2 launch template to use.
        public let launchTemplateId: String
        /// Set the specified Amazon EC2 launch template as the default launch template for the
        /// 			specified account.
        public let setDefaultVersion: Bool?

        public init(accountId: String? = nil, launchTemplateId: String, setDefaultVersion: Bool? = nil) {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "^lt-[a-z0-9-_]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case launchTemplateId = "launchTemplateId"
            case setDefaultVersion = "setDefaultVersion"
        }
    }

    public struct LifecycleExecution: AWSDecodableShape {
        /// The timestamp when the lifecycle runtime instance completed.
        public let endTime: Date?
        /// Identifies the lifecycle policy runtime instance.
        public let lifecycleExecutionId: String?
        /// The Amazon Resource Name (ARN) of the lifecycle policy that ran.
        public let lifecyclePolicyArn: String?
        /// Contains information about associated resources that are identified for action by
        /// 			the runtime instance of the lifecycle policy.
        public let resourcesImpactedSummary: LifecycleExecutionResourcesImpactedSummary?
        /// The timestamp when the lifecycle runtime instance started.
        public let startTime: Date?
        /// Runtime state that reports if the policy action ran successfully,
        /// 			failed, or was skipped.
        public let state: LifecycleExecutionState?

        public init(endTime: Date? = nil, lifecycleExecutionId: String? = nil, lifecyclePolicyArn: String? = nil, resourcesImpactedSummary: LifecycleExecutionResourcesImpactedSummary? = nil, startTime: Date? = nil, state: LifecycleExecutionState? = nil) {
            self.endTime = endTime
            self.lifecycleExecutionId = lifecycleExecutionId
            self.lifecyclePolicyArn = lifecyclePolicyArn
            self.resourcesImpactedSummary = resourcesImpactedSummary
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case lifecycleExecutionId = "lifecycleExecutionId"
            case lifecyclePolicyArn = "lifecyclePolicyArn"
            case resourcesImpactedSummary = "resourcesImpactedSummary"
            case startTime = "startTime"
            case state = "state"
        }
    }

    public struct LifecycleExecutionResource: AWSDecodableShape {
        /// The account that owns the impacted resource.
        public let accountId: String?
        /// The action to take for the identified resource.
        public let action: LifecycleExecutionResourceAction?
        /// The ending timestamp from the lifecycle action that was applied to the resource.
        public let endTime: Date?
        /// For an impacted container image, this identifies a list of URIs for associated
        /// 			container images distributed to ECR repositories.
        public let imageUris: [String]?
        /// The Amazon Web Services Region where the lifecycle execution resource is stored.
        public let region: String?
        /// Identifies the impacted resource. The resource ID depends on the type of
        /// 			resource, as follows.   Image Builder image resources: Amazon Resource Name (ARN)   Distributed AMIs: AMI ID   Container images distributed to an ECR repository: image URI or SHA Digest
        public let resourceId: String?
        /// A list of associated resource snapshots for the impacted resource if
        /// 			it’s an AMI.
        public let snapshots: [LifecycleExecutionSnapshotResource]?
        /// The starting timestamp from the lifecycle action that was applied to the resource.
        public let startTime: Date?
        /// The runtime state for the lifecycle execution.
        public let state: LifecycleExecutionResourceState?

        public init(accountId: String? = nil, action: LifecycleExecutionResourceAction? = nil, endTime: Date? = nil, imageUris: [String]? = nil, region: String? = nil, resourceId: String? = nil, snapshots: [LifecycleExecutionSnapshotResource]? = nil, startTime: Date? = nil, state: LifecycleExecutionResourceState? = nil) {
            self.accountId = accountId
            self.action = action
            self.endTime = endTime
            self.imageUris = imageUris
            self.region = region
            self.resourceId = resourceId
            self.snapshots = snapshots
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case action = "action"
            case endTime = "endTime"
            case imageUris = "imageUris"
            case region = "region"
            case resourceId = "resourceId"
            case snapshots = "snapshots"
            case startTime = "startTime"
            case state = "state"
        }
    }

    public struct LifecycleExecutionResourceAction: AWSDecodableShape {
        /// The name of the resource that was identified for a lifecycle policy action.
        public let name: LifecycleExecutionResourceActionName?
        /// The reason why the lifecycle policy action is taken.
        public let reason: String?

        public init(name: LifecycleExecutionResourceActionName? = nil, reason: String? = nil) {
            self.name = name
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case reason = "reason"
        }
    }

    public struct LifecycleExecutionResourceState: AWSDecodableShape {
        /// Messaging that clarifies the reason for the assigned status.
        public let reason: String?
        /// The runtime status of the lifecycle action taken for the
        /// 			impacted resource.
        public let status: LifecycleExecutionResourceStatus?

        public init(reason: String? = nil, status: LifecycleExecutionResourceStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct LifecycleExecutionResourcesImpactedSummary: AWSDecodableShape {
        /// Indicates whether an image resource that was identified for a lifecycle action has
        /// 			associated resources that are also impacted.
        public let hasImpactedResources: Bool?

        public init(hasImpactedResources: Bool? = nil) {
            self.hasImpactedResources = hasImpactedResources
        }

        private enum CodingKeys: String, CodingKey {
            case hasImpactedResources = "hasImpactedResources"
        }
    }

    public struct LifecycleExecutionSnapshotResource: AWSDecodableShape {
        /// Identifies the impacted snapshot resource.
        public let snapshotId: String?
        /// The runtime status of the lifecycle action taken for the snapshot.
        public let state: LifecycleExecutionResourceState?

        public init(snapshotId: String? = nil, state: LifecycleExecutionResourceState? = nil) {
            self.snapshotId = snapshotId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotId = "snapshotId"
            case state = "state"
        }
    }

    public struct LifecycleExecutionState: AWSDecodableShape {
        /// The reason for the current status.
        public let reason: String?
        /// The runtime status of the lifecycle execution.
        public let status: LifecycleExecutionStatus?

        public init(reason: String? = nil, status: LifecycleExecutionStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct LifecyclePolicy: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the lifecycle policy resource.
        public let arn: String?
        /// The timestamp when Image Builder created the lifecycle policy resource.
        public let dateCreated: Date?
        /// The timestamp for the last time Image Builder ran the lifecycle policy.
        public let dateLastRun: Date?
        /// The timestamp when Image Builder updated the lifecycle policy resource.
        public let dateUpdated: Date?
        /// Optional description for the lifecycle policy.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to run the lifecycle policy.
        /// 			This is a custom role that you create.
        public let executionRole: String?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The configuration details for a lifecycle policy resource.
        public let policyDetails: [LifecyclePolicyDetail]?
        /// Resource selection criteria used to run the lifecycle policy.
        public let resourceSelection: LifecyclePolicyResourceSelection?
        /// The type of resources the lifecycle policy targets.
        public let resourceType: LifecyclePolicyResourceType?
        /// Indicates whether the lifecycle policy resource is enabled.
        public let status: LifecyclePolicyStatus?
        /// To help manage your lifecycle policy resources, you can assign your own
        /// 			metadata to each resource in the form of tags. Each tag consists of a key and
        /// 			an optional value, both of which you define.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: Date? = nil, dateLastRun: Date? = nil, dateUpdated: Date? = nil, description: String? = nil, executionRole: String? = nil, name: String? = nil, policyDetails: [LifecyclePolicyDetail]? = nil, resourceSelection: LifecyclePolicyResourceSelection? = nil, resourceType: LifecyclePolicyResourceType? = nil, status: LifecyclePolicyStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.policyDetails = policyDetails
            self.resourceSelection = resourceSelection
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateLastRun = "dateLastRun"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case executionRole = "executionRole"
            case name = "name"
            case policyDetails = "policyDetails"
            case resourceSelection = "resourceSelection"
            case resourceType = "resourceType"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct LifecyclePolicyDetail: AWSEncodableShape & AWSDecodableShape {
        /// Configuration details for the policy action.
        public let action: LifecyclePolicyDetailAction
        /// Additional rules to specify resources that should be exempt from policy actions.
        public let exclusionRules: LifecyclePolicyDetailExclusionRules?
        /// Specifies the resources that the lifecycle policy applies to.
        public let filter: LifecyclePolicyDetailFilter

        public init(action: LifecyclePolicyDetailAction, exclusionRules: LifecyclePolicyDetailExclusionRules? = nil, filter: LifecyclePolicyDetailFilter) {
            self.action = action
            self.exclusionRules = exclusionRules
            self.filter = filter
        }

        public func validate(name: String) throws {
            try self.exclusionRules?.validate(name: "\(name).exclusionRules")
            try self.filter.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case exclusionRules = "exclusionRules"
            case filter = "filter"
        }
    }

    public struct LifecyclePolicyDetailAction: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the resources that the lifecycle policy applies to.
        public let includeResources: LifecyclePolicyDetailActionIncludeResources?
        /// Specifies the lifecycle action to take.
        public let type: LifecyclePolicyDetailActionType

        public init(includeResources: LifecyclePolicyDetailActionIncludeResources? = nil, type: LifecyclePolicyDetailActionType) {
            self.includeResources = includeResources
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case includeResources = "includeResources"
            case type = "type"
        }
    }

    public struct LifecyclePolicyDetailActionIncludeResources: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the lifecycle action should apply to distributed AMIs.
        public let amis: Bool?
        /// Specifies whether the lifecycle action should apply to distributed containers.
        public let containers: Bool?
        /// Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.
        public let snapshots: Bool?

        public init(amis: Bool? = nil, containers: Bool? = nil, snapshots: Bool? = nil) {
            self.amis = amis
            self.containers = containers
            self.snapshots = snapshots
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
            case containers = "containers"
            case snapshots = "snapshots"
        }
    }

    public struct LifecyclePolicyDetailExclusionRules: AWSEncodableShape & AWSDecodableShape {
        /// Lists configuration values that apply to AMIs that Image Builder should exclude
        /// 			from the lifecycle action.
        public let amis: LifecyclePolicyDetailExclusionRulesAmis?
        /// Contains a list of tags that Image Builder uses to skip lifecycle actions for Image Builder image
        /// 			resources that have them.
        public let tagMap: [String: String]?

        public init(amis: LifecyclePolicyDetailExclusionRulesAmis? = nil, tagMap: [String: String]? = nil) {
            self.amis = amis
            self.tagMap = tagMap
        }

        public func validate(name: String) throws {
            try self.amis?.validate(name: "\(name).amis")
            try self.tagMap?.forEach {
                try validate($0.key, name: "tagMap.key", parent: name, max: 128)
                try validate($0.key, name: "tagMap.key", parent: name, min: 1)
                try validate($0.key, name: "tagMap.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tagMap[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tagMap, name: "tagMap", parent: name, max: 50)
            try self.validate(self.tagMap, name: "tagMap", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
            case tagMap = "tagMap"
        }
    }

    public struct LifecyclePolicyDetailExclusionRulesAmis: AWSEncodableShape & AWSDecodableShape {
        /// Configures whether public AMIs are excluded from the lifecycle action.
        public let isPublic: Bool?
        /// Specifies configuration details for Image Builder to exclude the most recent resources
        /// 			from lifecycle actions.
        public let lastLaunched: LifecyclePolicyDetailExclusionRulesAmisLastLaunched?
        /// Configures Amazon Web Services Regions that are excluded from the lifecycle action.
        public let regions: [String]?
        /// Specifies Amazon Web Services accounts whose resources are excluded from the lifecycle action.
        public let sharedAccounts: [String]?
        /// Lists tags that should be excluded from lifecycle actions for the AMIs that have them.
        public let tagMap: [String: String]?

        public init(isPublic: Bool? = nil, lastLaunched: LifecyclePolicyDetailExclusionRulesAmisLastLaunched? = nil, regions: [String]? = nil, sharedAccounts: [String]? = nil, tagMap: [String: String]? = nil) {
            self.isPublic = isPublic
            self.lastLaunched = lastLaunched
            self.regions = regions
            self.sharedAccounts = sharedAccounts
            self.tagMap = tagMap
        }

        public func validate(name: String) throws {
            try self.lastLaunched?.validate(name: "\(name).lastLaunched")
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 1024)
                try validate($0, name: "regions[]", parent: name, min: 1)
            }
            try self.sharedAccounts?.forEach {
                try validate($0, name: "sharedAccounts[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.sharedAccounts, name: "sharedAccounts", parent: name, max: 1536)
            try self.validate(self.sharedAccounts, name: "sharedAccounts", parent: name, min: 1)
            try self.tagMap?.forEach {
                try validate($0.key, name: "tagMap.key", parent: name, max: 128)
                try validate($0.key, name: "tagMap.key", parent: name, min: 1)
                try validate($0.key, name: "tagMap.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tagMap[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tagMap, name: "tagMap", parent: name, max: 50)
            try self.validate(self.tagMap, name: "tagMap", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case isPublic = "isPublic"
            case lastLaunched = "lastLaunched"
            case regions = "regions"
            case sharedAccounts = "sharedAccounts"
            case tagMap = "tagMap"
        }
    }

    public struct LifecyclePolicyDetailExclusionRulesAmisLastLaunched: AWSEncodableShape & AWSDecodableShape {
        /// Defines the unit of time that the lifecycle policy uses to calculate elapsed time
        /// 			since the last instance launched from the AMI. For example: days, weeks, months, or years.
        public let unit: LifecyclePolicyTimeUnit
        /// The integer number of units for the time period. For example 6 (months).
        public let value: Int

        public init(unit: LifecyclePolicyTimeUnit, value: Int) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 365)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct LifecyclePolicyDetailFilter: AWSEncodableShape & AWSDecodableShape {
        /// For age-based filters, this is the number of resources to keep on hand after the lifecycle
        /// 			DELETE action is applied. Impacted resources are only deleted if you have more than
        /// 			this number of resources. If you have fewer resources than this number, the impacted resource
        /// 			is not deleted.
        public let retainAtLeast: Int?
        /// Filter resources based on either age or count.
        public let type: LifecyclePolicyDetailFilterType
        /// Defines the unit of time that the lifecycle policy uses to determine impacted
        /// 			resources. This is required for age-based rules.
        public let unit: LifecyclePolicyTimeUnit?
        /// The number of units for the time period or for the count. For example, a value of
        /// 			6 might refer to six months or six AMIs.  For count-based filters, this value represents the minimum number of resources
        /// 				to keep on hand. If you have fewer resources than this number, the resource is
        /// 				excluded from lifecycle actions.
        public let value: Int

        public init(retainAtLeast: Int? = nil, type: LifecyclePolicyDetailFilterType, unit: LifecyclePolicyTimeUnit? = nil, value: Int) {
            self.retainAtLeast = retainAtLeast
            self.type = type
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.retainAtLeast, name: "retainAtLeast", parent: name, max: 10)
            try self.validate(self.retainAtLeast, name: "retainAtLeast", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case retainAtLeast = "retainAtLeast"
            case type = "type"
            case unit = "unit"
            case value = "value"
        }
    }

    public struct LifecyclePolicyResourceSelection: AWSEncodableShape & AWSDecodableShape {
        /// A list of recipes that are used as selection criteria for the output
        /// 			images that the lifecycle policy applies to.
        public let recipes: [LifecyclePolicyResourceSelectionRecipe]?
        /// A list of tags that are used as selection criteria for the Image Builder image
        /// 			resources that the lifecycle policy applies to.
        public let tagMap: [String: String]?

        public init(recipes: [LifecyclePolicyResourceSelectionRecipe]? = nil, tagMap: [String: String]? = nil) {
            self.recipes = recipes
            self.tagMap = tagMap
        }

        public func validate(name: String) throws {
            try self.recipes?.forEach {
                try $0.validate(name: "\(name).recipes[]")
            }
            try self.validate(self.recipes, name: "recipes", parent: name, max: 50)
            try self.validate(self.recipes, name: "recipes", parent: name, min: 1)
            try self.tagMap?.forEach {
                try validate($0.key, name: "tagMap.key", parent: name, max: 128)
                try validate($0.key, name: "tagMap.key", parent: name, min: 1)
                try validate($0.key, name: "tagMap.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tagMap[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tagMap, name: "tagMap", parent: name, max: 50)
            try self.validate(self.tagMap, name: "tagMap", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recipes = "recipes"
            case tagMap = "tagMap"
        }
    }

    public struct LifecyclePolicyResourceSelectionRecipe: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Image Builder recipe that the lifecycle policy uses for resource selection.
        public let name: String
        /// The version of the Image Builder recipe specified by the name field.
        public let semanticVersion: String

        public init(name: String, semanticVersion: String) {
            self.name = name
            self.semanticVersion = semanticVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case semanticVersion = "semanticVersion"
        }
    }

    public struct LifecyclePolicySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the lifecycle policy summary resource.
        public let arn: String?
        /// The timestamp when Image Builder created the lifecycle policy resource.
        public let dateCreated: Date?
        /// The timestamp for the last time Image Builder ran the lifecycle policy.
        public let dateLastRun: Date?
        /// The timestamp when Image Builder updated the lifecycle policy resource.
        public let dateUpdated: Date?
        /// Optional description for the lifecycle policy.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to run the lifecycle policy.
        public let executionRole: String?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The type of resources the lifecycle policy targets.
        public let resourceType: LifecyclePolicyResourceType?
        /// The lifecycle policy resource status.
        public let status: LifecyclePolicyStatus?
        /// To help manage your lifecycle policy resources, you can assign your own
        /// 			metadata to each resource in the form of tags. Each tag consists of a key and
        /// 			an optional value, both of which you define.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: Date? = nil, dateLastRun: Date? = nil, dateUpdated: Date? = nil, description: String? = nil, executionRole: String? = nil, name: String? = nil, resourceType: LifecyclePolicyResourceType? = nil, status: LifecyclePolicyStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateLastRun = "dateLastRun"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case executionRole = "executionRole"
            case name = "name"
            case resourceType = "resourceType"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ListComponentBuildVersionsRequest: AWSEncodableShape {
        /// The component version Amazon Resource Name (ARN) whose versions you want to
        /// 			list.
        public let componentVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(componentVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.componentVersionArn = componentVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.componentVersionArn, name: "componentVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionArn = "componentVersionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentBuildVersionsResponse: AWSDecodableShape {
        /// The list of component summaries for the specified semantic version.
        public let componentSummaryList: [ComponentSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentSummaryList: [ComponentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentSummaryList = componentSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentSummaryList = "componentSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {
        /// Returns the list of components for the specified name.
        public let byName: Bool?
        /// Use the following filters to streamline results:    description     name     platform     supportedOsVersion     type     version
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// Filters results based on the type of owner for the component. By default, this request
        /// 			returns a list of components that your account owns. To see results for other types of
        /// 			owners, you can specify components that Amazon manages, third party components, or
        /// 			components that other accounts have shared with you.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName = "byName"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListComponentsResponse: AWSDecodableShape {
        /// The list of component semantic versions.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.
        public let componentVersionList: [ComponentVersion]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentVersionList: [ComponentVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentVersionList = componentVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionList = "componentVersionList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListContainerRecipesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:    containerType     name     parentImage     platform
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// Returns container recipes belonging to the specified owner, that have been shared with
        /// 			you. You can omit this field to return container recipes belonging to your
        /// 			account.
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListContainerRecipesResponse: AWSDecodableShape {
        /// The list of container recipes returned for the request.
        public let containerRecipeSummaryList: [ContainerRecipeSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeSummaryList: [ContainerRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.containerRecipeSummaryList = containerRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeSummaryList = "containerRecipeSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListDistributionConfigurationsRequest: AWSEncodableShape {
        /// You can filter on name to streamline results.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDistributionConfigurationsResponse: AWSDecodableShape {
        /// The list of distributions.
        public let distributionConfigurationSummaryList: [DistributionConfigurationSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfigurationSummaryList: [DistributionConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationSummaryList = "distributionConfigurationSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImageBuildVersionsRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:    name     osVersion     platform     type     version
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image whose build versions you want to
        /// 			retrieve.
        public let imageVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imageVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imageVersionArn = imageVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.imageVersionArn, name: "imageVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case imageVersionArn = "imageVersionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImageBuildVersionsResponse: AWSDecodableShape {
        /// The list of image build versions.
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList = "imageSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagePackagesRequest: AWSEncodableShape {
        /// Filter results for the ListImagePackages request by the Image Build Version ARN
        public let imageBuildVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(imageBuildVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImagePackagesResponse: AWSDecodableShape {
        /// The list of Image Packages returned in the response.
        public let imagePackageList: [ImagePackage]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePackageList: [ImagePackage]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePackageList = imagePackageList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePackageList = "imagePackageList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagePipelineImagesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:    name     version
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to
        /// 			view.
        public let imagePipelineArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imagePipelineArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imagePipelineArn = imagePipelineArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case imagePipelineArn = "imagePipelineArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImagePipelineImagesResponse: AWSDecodableShape {
        /// The list of images built by this pipeline.
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList = "imageSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagePipelinesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:    description     distributionConfigurationArn     imageRecipeArn     infrastructureConfigurationArn     name     status
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImagePipelinesResponse: AWSDecodableShape {
        /// The list of image pipelines.
        public let imagePipelineList: [ImagePipeline]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipelineList: [ImagePipeline]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePipelineList = imagePipelineList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineList = "imagePipelineList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImageRecipesRequest: AWSEncodableShape {
        /// Use the following filters to streamline results:    name     parentImage     platform
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// The owner defines which image recipes you want to list. By default, this request will
        /// 			only show image recipes owned by your account. You can use this field to specify if you
        /// 			want to view image recipes owned by yourself, by Amazon, or those image recipes that
        /// 			have been shared with you by other customers.
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListImageRecipesResponse: AWSDecodableShape {
        /// The list of image pipelines.
        public let imageRecipeSummaryList: [ImageRecipeSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeSummaryList: [ImageRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageRecipeSummaryList = imageRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeSummaryList = "imageRecipeSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImageScanFindingAggregationsRequest: AWSEncodableShape {
        public let filter: Filter?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filter: Filter? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case nextToken = "nextToken"
        }
    }

    public struct ListImageScanFindingAggregationsResponse: AWSDecodableShape {
        /// The aggregation type specifies what type of key is used to group the image scan
        /// 			findings. Image Builder returns results based on the request filter. If you didn't specify a
        /// 			filter in the request, the type defaults to accountId.  Aggregation types    accountId   imageBuildVersionArn   imagePipelineArn   vulnerabilityId   Each aggregation includes counts by severity level for medium severity and higher
        /// 			level findings, plus a total for all of the findings for each key value.
        public let aggregationType: String?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?
        /// An array of image scan finding aggregations that match the filter criteria.
        public let responses: [ImageScanFindingAggregation]?

        public init(aggregationType: String? = nil, nextToken: String? = nil, requestId: String? = nil, responses: [ImageScanFindingAggregation]? = nil) {
            self.aggregationType = aggregationType
            self.nextToken = nextToken
            self.requestId = requestId
            self.responses = responses
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationType = "aggregationType"
            case nextToken = "nextToken"
            case requestId = "requestId"
            case responses = "responses"
        }
    }

    public struct ListImageScanFindingsRequest: AWSEncodableShape {
        /// An array of name value pairs that you can use to filter your results. You can use the
        /// 			following filters to streamline results:    imageBuildVersionArn     imagePipelineArn     vulnerabilityId     severity    If you don't request a filter, then all findings in your account are listed.
        public let filters: [ImageScanFindingsFilter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [ImageScanFindingsFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImageScanFindingsResponse: AWSDecodableShape {
        /// The image scan findings for your account that meet your request filter
        /// 			criteria.
        public let findings: [ImageScanFinding]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(findings: [ImageScanFinding]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {
        /// Requests a list of images with a specific recipe name.
        public let byName: Bool?
        /// Use the following filters to streamline results:    name     osVersion     platform     type     version
        public let filters: [Filter]?
        /// Includes deprecated images in the response list.
        public let includeDeprecated: Bool?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// The owner defines which images you want to list. By default, this request will only
        /// 			show images owned by your account. You can use this field to specify if you want to view
        /// 			images owned by yourself, by Amazon, or those images that have been shared with you by
        /// 			other customers.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, includeDeprecated: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.includeDeprecated = includeDeprecated
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName = "byName"
            case filters = "filters"
            case includeDeprecated = "includeDeprecated"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {
        /// The list of image semantic versions.  The semantic version has four nodes: ../.
        /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        public let imageVersionList: [ImageVersion]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageVersionList: [ImageVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageVersionList = imageVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersionList = "imageVersionList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListInfrastructureConfigurationsRequest: AWSEncodableShape {
        /// You can filter on name to streamline results.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListInfrastructureConfigurationsResponse: AWSDecodableShape {
        /// The list of infrastructure configurations.
        public let infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationSummaryList = "infrastructureConfigurationSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListLifecycleExecutionResourcesRequest: AWSEncodableShape {
        /// Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
        public let lifecycleExecutionId: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// You can  leave this empty to get a list of Image Builder resources that were identified for lifecycle actions. To get a list of associated resources that are impacted for an individual resource (the parent), specify
        /// 			its Amazon Resource Name (ARN). Associated resources are produced from your image and distributed when you run a build, such as
        /// 			AMIs or container images stored in ECR repositories.
        public let parentResourceId: String?

        public init(lifecycleExecutionId: String, maxResults: Int? = nil, nextToken: String? = nil, parentResourceId: String? = nil) {
            self.lifecycleExecutionId = lifecycleExecutionId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.parentResourceId = parentResourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecycleExecutionId, name: "lifecycleExecutionId", parent: name, pattern: "^lce-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.parentResourceId, name: "parentResourceId", parent: name, max: 1024)
            try self.validate(self.parentResourceId, name: "parentResourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleExecutionId = "lifecycleExecutionId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case parentResourceId = "parentResourceId"
        }
    }

    public struct ListLifecycleExecutionResourcesResponse: AWSDecodableShape {
        /// Runtime details for the specified runtime instance of the lifecycle policy.
        public let lifecycleExecutionId: String?
        /// The current state of the lifecycle runtime instance.
        public let lifecycleExecutionState: LifecycleExecutionState?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// A list of resources that were identified for lifecycle actions.
        public let resources: [LifecycleExecutionResource]?

        public init(lifecycleExecutionId: String? = nil, lifecycleExecutionState: LifecycleExecutionState? = nil, nextToken: String? = nil, resources: [LifecycleExecutionResource]? = nil) {
            self.lifecycleExecutionId = lifecycleExecutionId
            self.lifecycleExecutionState = lifecycleExecutionState
            self.nextToken = nextToken
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleExecutionId = "lifecycleExecutionId"
            case lifecycleExecutionState = "lifecycleExecutionState"
            case nextToken = "nextToken"
            case resources = "resources"
        }
    }

    public struct ListLifecycleExecutionsRequest: AWSEncodableShape {
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource for which to get a list of lifecycle runtime instances.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline|lifecycle-policy|workflow\\/(?:build|test|distribution))/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceArn = "resourceArn"
        }
    }

    public struct ListLifecycleExecutionsResponse: AWSDecodableShape {
        /// A list of lifecycle runtime instances for the specified resource.
        public let lifecycleExecutions: [LifecycleExecution]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?

        public init(lifecycleExecutions: [LifecycleExecution]? = nil, nextToken: String? = nil) {
            self.lifecycleExecutions = lifecycleExecutions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleExecutions = "lifecycleExecutions"
            case nextToken = "nextToken"
        }
    }

    public struct ListLifecyclePoliciesRequest: AWSEncodableShape {
        /// Streamline results based on one of the following values: Name,
        /// 			Status.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListLifecyclePoliciesResponse: AWSDecodableShape {
        /// A list of lifecycle policies in your Amazon Web Services account that meet the criteria
        /// 			specified in the request.
        public let lifecyclePolicySummaryList: [LifecyclePolicySummary]?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?

        public init(lifecyclePolicySummaryList: [LifecyclePolicySummary]? = nil, nextToken: String? = nil) {
            self.lifecyclePolicySummaryList = lifecyclePolicySummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicySummaryList = "lifecyclePolicySummaryList"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline|lifecycle-policy|workflow\\/(?:build|test|distribution))/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWaitingWorkflowStepsRequest: AWSEncodableShape {
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWaitingWorkflowStepsResponse: AWSDecodableShape {
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// An array of the workflow steps that are waiting for action in your
        /// 			Amazon Web Services account.
        public let steps: [WorkflowStepExecution]?

        public init(nextToken: String? = nil, steps: [WorkflowStepExecution]? = nil) {
            self.nextToken = nextToken
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case steps = "steps"
        }
    }

    public struct ListWorkflowBuildVersionsRequest: AWSEncodableShape {
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the workflow resource for which to get a list of build versions.
        public let workflowVersionArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowVersionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowVersionArn = workflowVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.workflowVersionArn, name: "workflowVersionArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):workflow/(build|test|distribution)/[a-z0-9-_]+/(?:[0-9]+|x)\\.(?:[0-9]+|x)\\.(?:[0-9]+|x)$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case workflowVersionArn = "workflowVersionArn"
        }
    }

    public struct ListWorkflowBuildVersionsResponse: AWSDecodableShape {
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// A list that contains metadata for the workflow builds that have run for
        /// 			the workflow resource specified in the request.
        public let workflowSummaryList: [WorkflowSummary]?

        public init(nextToken: String? = nil, workflowSummaryList: [WorkflowSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowSummaryList = workflowSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowSummaryList = "workflowSummaryList"
        }
    }

    public struct ListWorkflowExecutionsRequest: AWSEncodableShape {
        /// List all workflow runtime instances for the specified image build version
        /// 			resource ARN.
        public let imageBuildVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?

        public init(imageBuildVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkflowExecutionsResponse: AWSDecodableShape {
        /// The resource ARN of the image build version for which you requested a list of
        /// 			workflow runtime details.
        public let imageBuildVersionArn: String?
        /// The output message from the list action, if applicable.
        public let message: String?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?
        /// Contains an array of runtime details that represents each time a workflow ran for
        /// 			the requested image build version.
        public let workflowExecutions: [WorkflowExecutionMetadata]?

        public init(imageBuildVersionArn: String? = nil, message: String? = nil, nextToken: String? = nil, requestId: String? = nil, workflowExecutions: [WorkflowExecutionMetadata]? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.message = message
            self.nextToken = nextToken
            self.requestId = requestId
            self.workflowExecutions = workflowExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case message = "message"
            case nextToken = "nextToken"
            case requestId = "requestId"
            case workflowExecutions = "workflowExecutions"
        }
    }

    public struct ListWorkflowStepExecutionsRequest: AWSEncodableShape {
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// The unique identifier that Image Builder assigned to keep track of runtime details
        /// 			when it ran the workflow.
        public let workflowExecutionId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowExecutionId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowExecutionId = workflowExecutionId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.workflowExecutionId, name: "workflowExecutionId", parent: name, pattern: "^wf-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case workflowExecutionId = "workflowExecutionId"
        }
    }

    public struct ListWorkflowStepExecutionsResponse: AWSDecodableShape {
        /// The image build version resource ARN that's associated with the specified runtime
        /// 			instance of the workflow.
        public let imageBuildVersionArn: String?
        /// The output message from the list action, if applicable.
        public let message: String?
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?
        /// Contains an array of runtime details that represents each step in this runtime
        /// 			instance of the workflow.
        public let steps: [WorkflowStepMetadata]?
        /// The build version ARN for the Image Builder workflow resource that defines the steps for
        /// 			this runtime instance of the workflow.
        public let workflowBuildVersionArn: String?
        /// The unique identifier that Image Builder assigned to keep track of runtime details
        /// 			when it ran the workflow.
        public let workflowExecutionId: String?

        public init(imageBuildVersionArn: String? = nil, message: String? = nil, nextToken: String? = nil, requestId: String? = nil, steps: [WorkflowStepMetadata]? = nil, workflowBuildVersionArn: String? = nil, workflowExecutionId: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.message = message
            self.nextToken = nextToken
            self.requestId = requestId
            self.steps = steps
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case message = "message"
            case nextToken = "nextToken"
            case requestId = "requestId"
            case steps = "steps"
            case workflowBuildVersionArn = "workflowBuildVersionArn"
            case workflowExecutionId = "workflowExecutionId"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// Specify all or part of the workflow name to streamline results.
        public let byName: Bool?
        /// Used to streamline search results.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the nextToken
        /// 	from a previously truncated response.
        public let nextToken: String?
        /// Used to get a list of workflow build version filtered by the identity of the creator.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName = "byName"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// The next token used for paginated responses. When this field isn't empty,
        /// 	there are additional elements that the service hasn't included in this request. Use this token
        /// 		with the next request to retrieve additional objects.
        public let nextToken: String?
        /// A list of workflow build versions that match the request criteria.
        public let workflowVersionList: [WorkflowVersion]?

        public init(nextToken: String? = nil, workflowVersionList: [WorkflowVersion]? = nil) {
            self.nextToken = nextToken
            self.workflowVersionList = workflowVersionList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowVersionList = "workflowVersionList"
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 logging configuration.
        public let s3Logs: S3Logs?

        public init(s3Logs: S3Logs? = nil) {
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Logs = "s3Logs"
        }
    }

    public struct OutputResources: AWSDecodableShape {
        /// The Amazon EC2 AMIs created by this image.
        public let amis: [Ami]?
        /// Container images that the pipeline has generated and stored in the output
        /// 			repository.
        public let containers: [Container]?

        public init(amis: [Ami]? = nil, containers: [Container]? = nil) {
            self.amis = amis
            self.containers = containers
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
            case containers = "containers"
        }
    }

    public struct PackageVulnerabilityDetails: AWSDecodableShape {
        /// CVSS scores for one or more vulnerabilities that Amazon Inspector identified for a
        /// 			package.
        public let cvss: [CvssScore]?
        /// Links to web pages that contain details about the vulnerabilities that Amazon Inspector
        /// 			identified for the package.
        public let referenceUrls: [String]?
        /// Vulnerabilities that are often related to the findings for the package.
        public let relatedVulnerabilities: [String]?
        /// The source of the vulnerability information.
        public let source: String?
        /// A link to the source of the vulnerability information.
        public let sourceUrl: String?
        /// The date and time when this vulnerability was first added to the vendor's
        /// 			database.
        public let vendorCreatedAt: Date?
        /// The severity that the vendor assigned to this vulnerability type.
        public let vendorSeverity: String?
        /// The date and time when the vendor last updated this vulnerability in their
        /// 			database.
        public let vendorUpdatedAt: Date?
        /// A unique identifier for this vulnerability.
        public let vulnerabilityId: String
        /// The packages that this vulnerability impacts.
        public let vulnerablePackages: [VulnerablePackage]?

        public init(cvss: [CvssScore]? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, source: String? = nil, sourceUrl: String? = nil, vendorCreatedAt: Date? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: Date? = nil, vulnerabilityId: String, vulnerablePackages: [VulnerablePackage]? = nil) {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }

        private enum CodingKeys: String, CodingKey {
            case cvss = "cvss"
            case referenceUrls = "referenceUrls"
            case relatedVulnerabilities = "relatedVulnerabilities"
            case source = "source"
            case sourceUrl = "sourceUrl"
            case vendorCreatedAt = "vendorCreatedAt"
            case vendorSeverity = "vendorSeverity"
            case vendorUpdatedAt = "vendorUpdatedAt"
            case vulnerabilityId = "vulnerabilityId"
            case vulnerablePackages = "vulnerablePackages"
        }
    }

    public struct PutComponentPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the component that this policy should be applied
        /// 			to.
        public let componentArn: String
        /// The policy to apply.
        public let policy: String

        public init(componentArn: String, policy: String) {
            self.componentArn = componentArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case policy = "policy"
        }
    }

    public struct PutComponentPolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component that this policy was applied
        /// 			to.
        public let componentArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentArn: String? = nil, requestId: String? = nil) {
            self.componentArn = componentArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case requestId = "requestId"
        }
    }

    public struct PutContainerRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that this policy should be
        /// 			applied to.
        public let containerRecipeArn: String
        /// The policy to apply to the container recipe.
        public let policy: String

        public init(containerRecipeArn: String, policy: String) {
            self.containerRecipeArn = containerRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn = "containerRecipeArn"
            case policy = "policy"
        }
    }

    public struct PutContainerRecipePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied
        /// 			to.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn = "containerRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct PutImagePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image that this policy should be applied
        /// 			to.
        public let imageArn: String
        /// The policy to apply.
        public let policy: String

        public init(imageArn: String, policy: String) {
            self.imageArn = imageArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn = "imageArn"
            case policy = "policy"
        }
    }

    public struct PutImagePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
        public let imageArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageArn: String? = nil, requestId: String? = nil) {
            self.imageArn = imageArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn = "imageArn"
            case requestId = "requestId"
        }
    }

    public struct PutImageRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied
        /// 			to.
        public let imageRecipeArn: String
        /// The policy to apply.
        public let policy: String

        public init(imageRecipeArn: String, policy: String) {
            self.imageRecipeArn = imageRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn = "imageRecipeArn"
            case policy = "policy"
        }
    }

    public struct PutImageRecipePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied
        /// 			to.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn = "imageRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct Remediation: AWSDecodableShape {
        /// An object that contains information about the recommended course of action to
        /// 			remediate the finding.
        public let recommendation: RemediationRecommendation?

        public init(recommendation: RemediationRecommendation? = nil) {
            self.recommendation = recommendation
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "recommendation"
        }
    }

    public struct RemediationRecommendation: AWSDecodableShape {
        /// The recommended course of action to remediate the finding.
        public let text: String?
        /// A link to more information about the recommended remediation for this
        /// 			vulnerability.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case url = "url"
        }
    }

    public struct ResourceState: AWSEncodableShape {
        /// Shows the current lifecycle policy action that was applied to an impacted resource.
        public let status: ResourceStatus?

        public init(status: ResourceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ResourceStateUpdateExclusionRules: AWSEncodableShape {
        public let amis: LifecyclePolicyDetailExclusionRulesAmis?

        public init(amis: LifecyclePolicyDetailExclusionRulesAmis? = nil) {
            self.amis = amis
        }

        public func validate(name: String) throws {
            try self.amis?.validate(name: "\(name).amis")
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
        }
    }

    public struct ResourceStateUpdateIncludeResources: AWSEncodableShape {
        /// Specifies whether the lifecycle action should apply to distributed AMIs
        public let amis: Bool?
        /// Specifies whether the lifecycle action should apply to distributed containers.
        public let containers: Bool?
        /// Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.
        public let snapshots: Bool?

        public init(amis: Bool? = nil, containers: Bool? = nil, snapshots: Bool? = nil) {
            self.amis = amis
            self.containers = containers
            self.snapshots = snapshots
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
            case containers = "containers"
            case snapshots = "snapshots"
        }
    }

    public struct S3ExportConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Export the updated image to one of the following supported disk image formats:    Virtual Hard Disk (VHD) – Compatible
        /// 					with Citrix Xen and Microsoft Hyper-V virtualization products.    Stream-optimized ESX Virtual Machine Disk
        /// 						(VMDK) – Compatible with VMware ESX and VMware vSphere
        /// 					versions 4, 5, and 6.    Raw – Raw format.
        public let diskImageFormat: DiskImageFormat
        /// The name of the role that grants VM Import/Export permission to export images to your
        /// 			S3 bucket.
        public let roleName: String
        /// The S3 bucket in which to store the output disk images for your VM.
        public let s3Bucket: String
        /// The Amazon S3 path for the bucket where the output disk images for your VM are
        /// 			stored.
        public let s3Prefix: String?

        public init(diskImageFormat: DiskImageFormat, roleName: String, s3Bucket: String, s3Prefix: String? = nil) {
            self.diskImageFormat = diskImageFormat
            self.roleName = roleName
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.roleName, name: "roleName", parent: name, max: 1024)
            try self.validate(self.roleName, name: "roleName", parent: name, min: 1)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 1024)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 1)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, max: 1024)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case diskImageFormat = "diskImageFormat"
            case roleName = "roleName"
            case s3Bucket = "s3Bucket"
            case s3Prefix = "s3Prefix"
        }
    }

    public struct S3Logs: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket in which to store the logs.
        public let s3BucketName: String?
        /// The Amazon S3 path to the bucket where the logs are stored.
        public let s3KeyPrefix: String?

        public init(s3BucketName: String? = nil, s3KeyPrefix: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 1024)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 1024)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3KeyPrefix = "s3KeyPrefix"
        }
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {
        /// The condition configures when the pipeline should trigger a new image build. When the
        /// 				pipelineExecutionStartCondition is set to
        /// 				EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic
        /// 			version filters on the base image or components in your image recipe, EC2 Image Builder will
        /// 			build a new image only when there are new versions of the image or components in your
        /// 			recipe that match the semantic version filter. When it is set to
        /// 				EXPRESSION_MATCH_ONLY, it will build a new image every time the CRON
        /// 			expression matches the current time. For semantic version syntax, see CreateComponent in the  EC2 Image Builder API Reference.
        public let pipelineExecutionStartCondition: PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your
        /// 				pipelineExecutionStartCondition. For information on how to format a cron expression in Image Builder, see Use
        /// 				cron expressions in EC2 Image Builder.
        public let scheduleExpression: String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC",
        /// 			"America/Los_Angeles" in the IANA timezone format. If not specified this defaults to UTC.
        public let timezone: String?

        public init(pipelineExecutionStartCondition: PipelineExecutionStartCondition? = nil, scheduleExpression: String? = nil, timezone: String? = nil) {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 1024)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 100)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 3)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "^[a-zA-Z0-9]{2,}(?:\\/[a-zA-z0-9-_+]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionStartCondition = "pipelineExecutionStartCondition"
            case scheduleExpression = "scheduleExpression"
            case timezone = "timezone"
        }
    }

    public struct SendWorkflowStepActionRequest: AWSEncodableShape {
        /// The action for the image creation process to take while a workflow
        /// 			WaitForAction step waits for an asynchronous action to complete.
        public let action: WorkflowStepActionType
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image build version to send action for.
        public let imageBuildVersionArn: String
        /// The reason why this action is sent.
        public let reason: String?
        /// Uniquely identifies the workflow step that sent the step action.
        public let stepExecutionId: String

        public init(action: WorkflowStepActionType, clientToken: String = SendWorkflowStepActionRequest.idempotencyToken(), imageBuildVersionArn: String, reason: String? = nil, stepExecutionId: String) {
            self.action = action
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.reason = reason
            self.stepExecutionId = stepExecutionId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.reason, name: "reason", parent: name, max: 1024)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
            try self.validate(self.stepExecutionId, name: "stepExecutionId", parent: name, pattern: "^step-[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case reason = "reason"
            case stepExecutionId = "stepExecutionId"
        }
    }

    public struct SendWorkflowStepActionResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image build version that received the action
        /// 			request.
        public let imageBuildVersionArn: String?
        /// The workflow step that sent the step action.
        public let stepExecutionId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, stepExecutionId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.stepExecutionId = stepExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case stepExecutionId = "stepExecutionId"
        }
    }

    public struct SeverityCounts: AWSDecodableShape {
        /// The total number of findings across all severity levels for the specified filter.
        public let all: Int64?
        /// The number of critical severity findings for the specified filter.
        public let critical: Int64?
        /// The number of high severity findings for the specified filter.
        public let high: Int64?
        /// The number of medium severity findings for the specified filter.
        public let medium: Int64?

        public init(all: Int64? = nil, critical: Int64? = nil, high: Int64? = nil, medium: Int64? = nil) {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }

        private enum CodingKeys: String, CodingKey {
            case all = "all"
            case critical = "critical"
            case high = "high"
            case medium = "medium"
        }
    }

    public struct StartImagePipelineExecutionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually
        /// 			invoke.
        public let imagePipelineArn: String

        public init(clientToken: String = StartImagePipelineExecutionRequest.idempotencyToken(), imagePipelineArn: String) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imagePipelineArn = "imagePipelineArn"
        }
    }

    public struct StartImagePipelineExecutionResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image that the request created.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct StartResourceStateUpdateRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Skip action on the image resource and associated resources if specified
        /// 			exclusion rules are met.
        public let exclusionRules: ResourceStateUpdateExclusionRules?
        /// The name or Amazon Resource Name (ARN) of the IAM role that’s used to update image state.
        public let executionRole: String?
        /// A list of image resources to update state for.
        public let includeResources: ResourceStateUpdateIncludeResources?
        /// The ARN of the Image Builder resource that is updated. The state update might also
        /// 			impact associated resources.
        public let resourceArn: String
        /// Indicates the lifecycle action to take for this request.
        public let state: ResourceState
        /// The timestamp that indicates when resources are updated by a lifecycle action.
        public let updateAt: Date?

        public init(clientToken: String = StartResourceStateUpdateRequest.idempotencyToken(), exclusionRules: ResourceStateUpdateExclusionRules? = nil, executionRole: String? = nil, includeResources: ResourceStateUpdateIncludeResources? = nil, resourceArn: String, state: ResourceState, updateAt: Date? = nil) {
            self.clientToken = clientToken
            self.exclusionRules = exclusionRules
            self.executionRole = executionRole
            self.includeResources = includeResources
            self.resourceArn = resourceArn
            self.state = state
            self.updateAt = updateAt
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.exclusionRules?.validate(name: "\(name).exclusionRules")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^(?:arn:aws(?:-[a-z]+)*:iam::[0-9]{12}:role/)?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case exclusionRules = "exclusionRules"
            case executionRole = "executionRole"
            case includeResources = "includeResources"
            case resourceArn = "resourceArn"
            case state = "state"
            case updateAt = "updateAt"
        }
    }

    public struct StartResourceStateUpdateResponse: AWSDecodableShape {
        /// Identifies the lifecycle runtime instance that started the resource
        /// 			state update.
        public let lifecycleExecutionId: String?
        /// The requested ARN of the Image Builder resource for the asynchronous update.
        public let resourceArn: String?

        public init(lifecycleExecutionId: String? = nil, resourceArn: String? = nil) {
            self.lifecycleExecutionId = lifecycleExecutionId
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleExecutionId = "lifecycleExecutionId"
            case resourceArn = "resourceArn"
        }
    }

    public struct SystemsManagerAgent: AWSEncodableShape & AWSDecodableShape {
        /// Controls whether the Systems Manager agent is removed from your final build image, prior to
        /// 			creating the new AMI. If this is set to true, then the agent is removed from the final
        /// 			image. If it's set to false, then the agent is left in, so that it is included in the
        /// 			new AMI. The default value is false.
        public let uninstallAfterBuild: Bool?

        public init(uninstallAfterBuild: Bool? = nil) {
            self.uninstallAfterBuild = uninstallAfterBuild
        }

        private enum CodingKeys: String, CodingKey {
            case uninstallAfterBuild = "uninstallAfterBuild"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// The tags to apply to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline|lifecycle-policy|workflow\\/(?:build|test|distribution))/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetContainerRepository: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container repository where the output container image is stored. This
        /// 			name is prefixed by the repository location.
        public let repositoryName: String
        /// Specifies the service in which this image was registered.
        public let service: ContainerRepositoryService

        public init(repositoryName: String, service: ContainerRepositoryService) {
            self.repositoryName = repositoryName
            self.service = service
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 1024)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
            case service = "service"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline|lifecycle-policy|workflow\\/(?:build|test|distribution))/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDistributionConfigurationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The description of the distribution configuration.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to
        /// 			update.
        public let distributionConfigurationArn: String
        /// The distributions of the distribution configuration.
        public let distributions: [Distribution]

        public init(clientToken: String = UpdateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributionConfigurationArn: String, distributions: [Distribution]) {
            self.clientToken = clientToken
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case distributions = "distributions"
        }
    }

    public struct UpdateDistributionConfigurationResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by
        /// 			this request.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct UpdateImagePipelineRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container pipeline to update.
        public let containerRecipeArn: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that Image Builder uses to
        /// 			configure and distribute images that this image pipeline has updated.
        public let distributionConfigurationArn: String?
        /// Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The name or Amazon Resource Name (ARN) for the IAM role you create that grants
        /// 			Image Builder access to perform workflow actions.
        public let executionRole: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
        public let imagePipelineArn: String
        /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure
        /// 			images updated by this image pipeline.
        public let imageRecipeArn: String?
        /// Contains settings for vulnerability scans.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The image test configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that Image Builder uses to
        /// 			build images that this image pipeline has updated.
        public let infrastructureConfigurationArn: String
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?
        /// Contains the workflows to run for the pipeline.
        public let workflows: [WorkflowConfiguration]?

        public init(clientToken: String = UpdateImagePipelineRequest.idempotencyToken(), containerRecipeArn: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, executionRole: String? = nil, imagePipelineArn: String, imageRecipeArn: String? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, schedule: Schedule? = nil, status: PipelineStatus? = nil, workflows: [WorkflowConfiguration]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.executionRole = executionRole
            self.imagePipelineArn = imagePipelineArn
            self.imageRecipeArn = imageRecipeArn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.schedule = schedule
            self.status = status
            self.workflows = workflows
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^(?:arn:aws(?:-[a-z]+)*:iam::[0-9]{12}:role/)?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageScanningConfiguration?.validate(name: "\(name).imageScanningConfiguration")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.schedule?.validate(name: "\(name).schedule")
            try self.workflows?.forEach {
                try $0.validate(name: "\(name).workflows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case containerRecipeArn = "containerRecipeArn"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case executionRole = "executionRole"
            case imagePipelineArn = "imagePipelineArn"
            case imageRecipeArn = "imageRecipeArn"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case schedule = "schedule"
            case status = "status"
            case workflows = "workflows"
        }
    }

    public struct UpdateImagePipelineResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this
        /// 			request.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imagePipelineArn = "imagePipelineArn"
            case requestId = "requestId"
        }
    }

    public struct UpdateInfrastructureConfigurationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
        /// 			update.
        public let infrastructureConfigurationArn: String
        /// The instance metadata options that you can set for the HTTP requests that pipeline
        /// 			builds use to launch EC2 build and test instances. For more information about instance
        /// 			metadata options, see one of the following links:    Configure the instance metadata options in the
        /// 						 Amazon EC2 User Guide for Linux instances.    Configure the instance metadata options in the
        /// 						 Amazon EC2 Windows Guide for Windows instances.
        public let instanceMetadataOptions: InstanceMetadataOptions?
        /// The instance profile to associate with the instance used to customize your Amazon EC2
        /// 			AMI.
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more
        /// 			instance types to use for this build. The service will pick one of these instance types
        /// 			based on availability.
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. You can use this to log on to and
        /// 			debug the instance used to create your image.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs to associate with the instance used to customize your Amazon EC2
        /// 			AMI.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event
        /// 			notifications.  EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys
        /// 				from other accounts. The key that is used to encrypt the SNS topic must reside in the
        /// 				account that the Image Builder service runs under.
        public let snsTopicArn: String?
        /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
        public let subnetId: String?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to
        /// 			false if you want Image Builder to retain the instance used to configure your AMI if the build or
        /// 			test phase of your workflow fails.
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = UpdateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, infrastructureConfigurationArn: String, instanceMetadataOptions: InstanceMetadataOptions? = nil, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.instanceMetadataOptions?.validate(name: "\(name).instanceMetadataOptions")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 256)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try self.validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 30)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:[0-9]{12}:[a-zA-Z0-9-_]{1,256}$")
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case instanceMetadataOptions = "instanceMetadataOptions"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case keyPair = "keyPair"
            case logging = "logging"
            case resourceTags = "resourceTags"
            case securityGroupIds = "securityGroupIds"
            case snsTopicArn = "snsTopicArn"
            case subnetId = "subnetId"
            case terminateInstanceOnFailure = "terminateInstanceOnFailure"
        }
    }

    public struct UpdateInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The client token that uniquely identifies the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by
        /// 			this request.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct UpdateLifecyclePolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
        public let clientToken: String
        /// Optional description for the lifecycle policy.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to update the
        /// 			lifecycle policy.
        public let executionRole: String
        /// The Amazon Resource Name (ARN) of the lifecycle policy resource.
        public let lifecyclePolicyArn: String
        /// The configuration details for a lifecycle policy resource.
        public let policyDetails: [LifecyclePolicyDetail]
        /// Selection criteria for resources that the lifecycle policy applies to.
        public let resourceSelection: LifecyclePolicyResourceSelection
        /// The type of image resource that the lifecycle policy applies to.
        public let resourceType: LifecyclePolicyResourceType
        /// Indicates whether the lifecycle policy resource is enabled.
        public let status: LifecyclePolicyStatus?

        public init(clientToken: String = UpdateLifecyclePolicyRequest.idempotencyToken(), description: String? = nil, executionRole: String, lifecyclePolicyArn: String, policyDetails: [LifecyclePolicyDetail], resourceSelection: LifecyclePolicyResourceSelection, resourceType: LifecyclePolicyResourceType, status: LifecyclePolicyStatus? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.executionRole = executionRole
            self.lifecyclePolicyArn = lifecyclePolicyArn
            self.policyDetails = policyDetails
            self.resourceSelection = resourceSelection
            self.resourceType = resourceType
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^(?:arn:aws(?:-[a-z]+)*:iam::[0-9]{12}:role/)?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.lifecyclePolicyArn, name: "lifecyclePolicyArn", parent: name, max: 1024)
            try self.validate(self.lifecyclePolicyArn, name: "lifecyclePolicyArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):lifecycle-policy/[a-z0-9-_]+$")
            try self.policyDetails.forEach {
                try $0.validate(name: "\(name).policyDetails[]")
            }
            try self.validate(self.policyDetails, name: "policyDetails", parent: name, max: 3)
            try self.validate(self.policyDetails, name: "policyDetails", parent: name, min: 1)
            try self.resourceSelection.validate(name: "\(name).resourceSelection")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRole = "executionRole"
            case lifecyclePolicyArn = "lifecyclePolicyArn"
            case policyDetails = "policyDetails"
            case resourceSelection = "resourceSelection"
            case resourceType = "resourceType"
            case status = "status"
        }
    }

    public struct UpdateLifecyclePolicyResponse: AWSDecodableShape {
        /// The ARN of the image lifecycle policy resource that was updated.
        public let lifecyclePolicyArn: String?

        public init(lifecyclePolicyArn: String? = nil) {
            self.lifecyclePolicyArn = lifecyclePolicyArn
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyArn = "lifecyclePolicyArn"
        }
    }

    public struct VulnerabilityIdAggregation: AWSDecodableShape {
        /// Counts by severity level for medium severity and higher level findings, plus a total
        /// 			for all of the findings for the specified vulnerability.
        public let severityCounts: SeverityCounts?
        /// The vulnerability Id for this set of counts.
        public let vulnerabilityId: String?

        public init(severityCounts: SeverityCounts? = nil, vulnerabilityId: String? = nil) {
            self.severityCounts = severityCounts
            self.vulnerabilityId = vulnerabilityId
        }

        private enum CodingKeys: String, CodingKey {
            case severityCounts = "severityCounts"
            case vulnerabilityId = "vulnerabilityId"
        }
    }

    public struct VulnerablePackage: AWSDecodableShape {
        /// The architecture of the vulnerable package.
        public let arch: String?
        /// The epoch of the vulnerable package.
        public let epoch: Int?
        /// The file path of the vulnerable package.
        public let filePath: String?
        /// The version of the package that contains the vulnerability fix.
        public let fixedInVersion: String?
        /// The name of the vulnerable package.
        public let name: String?
        /// The package manager of the vulnerable package.
        public let packageManager: String?
        /// The release of the vulnerable package.
        public let release: String?
        /// The code to run in your environment to update packages with a fix available.
        public let remediation: String?
        /// The source layer hash of the vulnerable package.
        public let sourceLayerHash: String?
        /// The version of the vulnerable package.
        public let version: String?

        public init(arch: String? = nil, epoch: Int? = nil, filePath: String? = nil, fixedInVersion: String? = nil, name: String? = nil, packageManager: String? = nil, release: String? = nil, remediation: String? = nil, sourceLayerHash: String? = nil, version: String? = nil) {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arch = "arch"
            case epoch = "epoch"
            case filePath = "filePath"
            case fixedInVersion = "fixedInVersion"
            case name = "name"
            case packageManager = "packageManager"
            case release = "release"
            case remediation = "remediation"
            case sourceLayerHash = "sourceLayerHash"
            case version = "version"
        }
    }

    public struct Workflow: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public let arn: String?
        /// Describes what change has been made in this version of the workflow, or
        /// 			what makes this version different from other versions of the workflow.
        public let changeDescription: String?
        /// Contains the YAML document content for the workflow.
        public let data: String?
        /// The timestamp when Image Builder created the workflow resource.
        public let dateCreated: String?
        /// The description of the workflow.
        public let description: String?
        /// The KMS key identifier used to encrypt the workflow resource.
        public let kmsKeyId: String?
        /// The name of the workflow resource.
        public let name: String?
        /// The owner of the workflow resource.
        public let owner: String?
        /// An array of input parameters that that the image workflow uses
        /// 			to control actions or configure settings.
        public let parameters: [WorkflowParameterDetail]?
        /// Describes the current status of the workflow and the reason for
        /// 			that status.
        public let state: WorkflowState?
        /// The tags that apply to the workflow resource
        public let tags: [String: String]?
        /// Specifies the image creation stage that the workflow applies to. Image Builder
        /// 			currently supports build and test workflows.
        public let type: WorkflowType?
        /// The workflow resource version. Workflow resources are immutable.
        /// 			To make a change, you can clone a workflow or create a new version.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, data: String? = nil, dateCreated: String? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, parameters: [WorkflowParameterDetail]? = nil, state: WorkflowState? = nil, tags: [String: String]? = nil, type: WorkflowType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case changeDescription = "changeDescription"
            case data = "data"
            case dateCreated = "dateCreated"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case owner = "owner"
            case parameters = "parameters"
            case state = "state"
            case tags = "tags"
            case type = "type"
            case version = "version"
        }
    }

    public struct WorkflowConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The action to take if the workflow fails.
        public let onFailure: OnWorkflowFailure?
        /// Test workflows are defined within named runtime groups called parallel groups.
        /// 			The parallel group is the named group that contains this test workflow. Test
        /// 			workflows within a parallel group can run at the same time. Image Builder starts up to five
        /// 			test workflows in the group at the same time, and starts additional workflows as
        /// 			others complete, until all workflows in the group have completed. This field only
        /// 			applies for test workflows.
        public let parallelGroup: String?
        /// Contains parameter values for each of the parameters that the workflow
        /// 			document defined for the workflow resource.
        public let parameters: [WorkflowParameter]?
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public let workflowArn: String

        public init(onFailure: OnWorkflowFailure? = nil, parallelGroup: String? = nil, parameters: [WorkflowParameter]? = nil, workflowArn: String) {
            self.onFailure = onFailure
            self.parallelGroup = parallelGroup
            self.parameters = parameters
            self.workflowArn = workflowArn
        }

        public func validate(name: String) throws {
            try self.validate(self.parallelGroup, name: "parallelGroup", parent: name, max: 100)
            try self.validate(self.parallelGroup, name: "parallelGroup", parent: name, min: 1)
            try self.validate(self.parallelGroup, name: "parallelGroup", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9-_+#]{0,99}$")
            try self.parameters?.forEach {
                try $0.validate(name: "\(name).parameters[]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-[a-z]+)*:imagebuilder:[a-z]{2,}(?:-[a-z]+)+-[0-9]+:(?:[0-9]{12}|aws):workflow/(build|test|distribution)/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case onFailure = "onFailure"
            case parallelGroup = "parallelGroup"
            case parameters = "parameters"
            case workflowArn = "workflowArn"
        }
    }

    public struct WorkflowExecutionMetadata: AWSDecodableShape {
        /// The timestamp when this runtime instance of the workflow finished.
        public let endTime: String?
        /// The runtime output message from the workflow, if applicable.
        public let message: String?
        /// The name of the test group that included the test workflow resource at runtime.
        public let parallelGroup: String?
        /// The timestamp when the runtime instance of this workflow started.
        public let startTime: String?
        /// The current runtime status for this workflow.
        public let status: WorkflowExecutionStatus?
        /// The total number of steps in the workflow. This should equal the sum of the step
        /// 			counts for steps that succeeded, were skipped, and failed.
        public let totalStepCount: Int?
        /// A runtime count for the number of steps in the workflow that failed.
        public let totalStepsFailed: Int?
        /// A runtime count for the number of steps in the workflow that were skipped.
        public let totalStepsSkipped: Int?
        /// A runtime count for the number of steps in the workflow that ran successfully.
        public let totalStepsSucceeded: Int?
        /// Indicates what type of workflow that Image Builder ran for this runtime instance of the workflow.
        public let type: WorkflowType?
        /// The Amazon Resource Name (ARN) of the workflow resource build version that ran.
        public let workflowBuildVersionArn: String?
        /// Unique identifier that Image Builder assigns to keep track of runtime resources each time it runs a
        /// 			workflow.
        public let workflowExecutionId: String?

        public init(endTime: String? = nil, message: String? = nil, parallelGroup: String? = nil, startTime: String? = nil, status: WorkflowExecutionStatus? = nil, totalStepCount: Int? = nil, totalStepsFailed: Int? = nil, totalStepsSkipped: Int? = nil, totalStepsSucceeded: Int? = nil, type: WorkflowType? = nil, workflowBuildVersionArn: String? = nil, workflowExecutionId: String? = nil) {
            self.endTime = endTime
            self.message = message
            self.parallelGroup = parallelGroup
            self.startTime = startTime
            self.status = status
            self.totalStepCount = totalStepCount
            self.totalStepsFailed = totalStepsFailed
            self.totalStepsSkipped = totalStepsSkipped
            self.totalStepsSucceeded = totalStepsSucceeded
            self.type = type
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case message = "message"
            case parallelGroup = "parallelGroup"
            case startTime = "startTime"
            case status = "status"
            case totalStepCount = "totalStepCount"
            case totalStepsFailed = "totalStepsFailed"
            case totalStepsSkipped = "totalStepsSkipped"
            case totalStepsSucceeded = "totalStepsSucceeded"
            case type = "type"
            case workflowBuildVersionArn = "workflowBuildVersionArn"
            case workflowExecutionId = "workflowExecutionId"
        }
    }

    public struct WorkflowParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the workflow parameter to set.
        public let name: String
        /// Sets the value for the named workflow parameter.
        public let value: [String]

        public init(name: String, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\x00]+$")
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^[^\\x00]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct WorkflowParameterDetail: AWSDecodableShape {
        /// The default value of this parameter if no input is provided.
        public let defaultValue: [String]?
        /// Describes this parameter.
        public let description: String?
        /// The name of this input parameter.
        public let name: String
        /// The type of input this parameter provides. The currently supported value is
        /// 			"string".
        public let type: String

        public init(defaultValue: [String]? = nil, description: String? = nil, name: String, type: String) {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case description = "description"
            case name = "name"
            case type = "type"
        }
    }

    public struct WorkflowState: AWSDecodableShape {
        /// Describes how or why the workflow changed state.
        public let reason: String?
        /// The current state of the workflow.
        public let status: WorkflowStatus?

        public init(reason: String? = nil, status: WorkflowStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct WorkflowStepExecution: AWSDecodableShape {
        /// The name of the step action.
        public let action: String?
        /// The Amazon Resource Name (ARN) of the image build version that ran the workflow.
        public let imageBuildVersionArn: String?
        /// The name of the workflow step.
        public let name: String?
        /// The timestamp when the workflow step started.
        public let startTime: String?
        /// Uniquely identifies the workflow step that ran for the associated
        /// 			image build version.
        public let stepExecutionId: String?
        /// The ARN of the workflow resource that ran.
        public let workflowBuildVersionArn: String?
        /// Uniquely identifies the runtime instance of the workflow that contains
        /// 			the workflow step that ran for the associated image build version.
        public let workflowExecutionId: String?

        public init(action: String? = nil, imageBuildVersionArn: String? = nil, name: String? = nil, startTime: String? = nil, stepExecutionId: String? = nil, workflowBuildVersionArn: String? = nil, workflowExecutionId: String? = nil) {
            self.action = action
            self.imageBuildVersionArn = imageBuildVersionArn
            self.name = name
            self.startTime = startTime
            self.stepExecutionId = stepExecutionId
            self.workflowBuildVersionArn = workflowBuildVersionArn
            self.workflowExecutionId = workflowExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case name = "name"
            case startTime = "startTime"
            case stepExecutionId = "stepExecutionId"
            case workflowBuildVersionArn = "workflowBuildVersionArn"
            case workflowExecutionId = "workflowExecutionId"
        }
    }

    public struct WorkflowStepMetadata: AWSDecodableShape {
        /// The step action name.
        public let action: String?
        /// Description of the workflow step.
        public let description: String?
        /// The timestamp when the workflow step finished.
        public let endTime: String?
        /// Input parameters that Image Builder provides for the workflow step.
        public let inputs: String?
        /// Detailed output message that the workflow step provides at runtime.
        public let message: String?
        /// The name of the workflow step.
        public let name: String?
        /// The file names that the workflow step created as output for this runtime instance of the workflow.
        public let outputs: String?
        /// Reports on the rollback status of the step, if applicable.
        public let rollbackStatus: WorkflowStepExecutionRollbackStatus?
        /// The timestamp when the workflow step started.
        public let startTime: String?
        /// Runtime status for the workflow step.
        public let status: WorkflowStepExecutionStatus?
        /// A unique identifier for the workflow step, assigned at runtime.
        public let stepExecutionId: String?

        public init(action: String? = nil, description: String? = nil, endTime: String? = nil, inputs: String? = nil, message: String? = nil, name: String? = nil, outputs: String? = nil, rollbackStatus: WorkflowStepExecutionRollbackStatus? = nil, startTime: String? = nil, status: WorkflowStepExecutionStatus? = nil, stepExecutionId: String? = nil) {
            self.action = action
            self.description = description
            self.endTime = endTime
            self.inputs = inputs
            self.message = message
            self.name = name
            self.outputs = outputs
            self.rollbackStatus = rollbackStatus
            self.startTime = startTime
            self.status = status
            self.stepExecutionId = stepExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case endTime = "endTime"
            case inputs = "inputs"
            case message = "message"
            case name = "name"
            case outputs = "outputs"
            case rollbackStatus = "rollbackStatus"
            case startTime = "startTime"
            case status = "status"
            case stepExecutionId = "stepExecutionId"
        }
    }

    public struct WorkflowSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public let arn: String?
        /// The change description for the current version of the workflow resource.
        public let changeDescription: String?
        /// The original creation date of the workflow resource.
        public let dateCreated: String?
        /// Describes the workflow.
        public let description: String?
        /// The name of the workflow.
        public let name: String?
        /// The owner of the workflow resource.
        public let owner: String?
        /// Describes the current state of the workflow resource.
        public let state: WorkflowState?
        /// Contains a list of tags that are defined for the workflow.
        public let tags: [String: String]?
        /// The image creation stage that this workflow applies to. Image Builder currently
        /// 			supports build and test stage workflows.
        public let type: WorkflowType?
        /// The version of the workflow.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, state: WorkflowState? = nil, tags: [String: String]? = nil, type: WorkflowType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case changeDescription = "changeDescription"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case state = "state"
            case tags = "tags"
            case type = "type"
            case version = "version"
        }
    }

    public struct WorkflowVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the workflow resource.
        public let arn: String?
        /// The timestamp when Image Builder created the workflow version.
        public let dateCreated: String?
        /// Describes the workflow.
        public let description: String?
        /// The name of the workflow.
        public let name: String?
        /// The owner of the workflow resource.
        public let owner: String?
        /// The image creation stage that this workflow applies to. Image Builder currently
        /// 			supports build and test stage workflows.
        public let type: WorkflowType?
        /// The semantic version of the workflow resource. The format includes three nodes: ...
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, type: WorkflowType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case type = "type"
            case version = "version"
        }
    }
}

// MARK: - Errors

/// Error enum for Imagebuilder
public struct ImagebuilderErrorType: AWSErrorType {
    enum Code: String {
        case callRateLimitExceededException = "CallRateLimitExceededException"
        case clientException = "ClientException"
        case forbiddenException = "ForbiddenException"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case invalidPaginationTokenException = "InvalidPaginationTokenException"
        case invalidParameterCombinationException = "InvalidParameterCombinationException"
        case invalidParameterException = "InvalidParameterException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestException = "InvalidRequestException"
        case invalidVersionNumberException = "InvalidVersionNumberException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceDependencyException = "ResourceDependencyException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Imagebuilder
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You have exceeded the permitted request rate for the specific operation.
    public static var callRateLimitExceededException: Self { .init(.callRateLimitExceededException) }
    /// These errors are usually caused by a client action, such as using an action or
    /// 			resource on behalf of a user that doesn't have permissions to use the action or
    /// 			resource, or specifying an invalid resource identifier.
    public static var clientException: Self { .init(.clientException) }
    /// You are not authorized to perform the requested operation.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// You have specified a client token for an operation using parameter values that differ
    /// 			from a previous request that used the same client token.
    public static var idempotentParameterMismatchException: Self { .init(.idempotentParameterMismatchException) }
    /// You have provided an invalid pagination token in your request.
    public static var invalidPaginationTokenException: Self { .init(.invalidPaginationTokenException) }
    /// You have specified two or more mutually exclusive parameters. Review the error message
    /// 			for details.
    public static var invalidParameterCombinationException: Self { .init(.invalidParameterCombinationException) }
    /// The specified parameter is invalid. Review the available parameters for the API
    /// 			request.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The value that you provided for the specified parameter is invalid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// You have requested an action that that the service doesn't support.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// Your version number is out of bounds or does not follow the required syntax.
    public static var invalidVersionNumberException: Self { .init(.invalidVersionNumberException) }
    /// The resource that you are trying to create already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// You have attempted to mutate or delete a resource with a dependency that prohibits
    /// 			this action. See the error message for more details.
    public static var resourceDependencyException: Self { .init(.resourceDependencyException) }
    /// The resource that you are trying to operate on is currently in use. Review the message
    /// 			details and retry later.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// At least one of the resources referenced by your request does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This exception is thrown when the service encounters an unrecoverable
    /// 			exception.
    public static var serviceException: Self { .init(.serviceException) }
    /// You have exceeded the number of permitted resources or operations for this service.
    /// 			For service quotas, see EC2 Image Builder endpoints and
    /// 				quotas.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The service is unable to process your request at this time.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
}

extension ImagebuilderErrorType: Equatable {
    public static func == (lhs: ImagebuilderErrorType, rhs: ImagebuilderErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ImagebuilderErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
