//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Lambda {
    // MARK: Enums

    public enum CodeSigningPolicy: String, CustomStringConvertible, Codable {
        case enforce = "Enforce"
        case warn = "Warn"
        public var description: String { return self.rawValue }
    }

    public enum EndPointType: String, CustomStringConvertible, Codable {
        case kafkaBootstrapServers = "KAFKA_BOOTSTRAP_SERVERS"
        public var description: String { return self.rawValue }
    }

    public enum EventSourcePosition: String, CustomStringConvertible, Codable {
        case atTimestamp = "AT_TIMESTAMP"
        case latest = "LATEST"
        case trimHorizon = "TRIM_HORIZON"
        public var description: String { return self.rawValue }
    }

    public enum FunctionResponseType: String, CustomStringConvertible, Codable {
        case reportbatchitemfailures = "ReportBatchItemFailures"
        public var description: String { return self.rawValue }
    }

    public enum FunctionVersion: String, CustomStringConvertible, Codable {
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable {
        case dryrun = "DryRun"
        case event = "Event"
        case requestresponse = "RequestResponse"
        public var description: String { return self.rawValue }
    }

    public enum LastUpdateStatus: String, CustomStringConvertible, Codable {
        case failed = "Failed"
        case inprogress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum LastUpdateStatusReasonCode: String, CustomStringConvertible, Codable {
        case enilimitexceeded = "EniLimitExceeded"
        case imageaccessdenied = "ImageAccessDenied"
        case imagedeleted = "ImageDeleted"
        case insufficientrolepermissions = "InsufficientRolePermissions"
        case internalerror = "InternalError"
        case invalidconfiguration = "InvalidConfiguration"
        case invalidimage = "InvalidImage"
        case invalidsecuritygroup = "InvalidSecurityGroup"
        case invalidsubnet = "InvalidSubnet"
        case subnetoutofipaddresses = "SubnetOutOfIPAddresses"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable {
        case none = "None"
        case tail = "Tail"
        public var description: String { return self.rawValue }
    }

    public enum PackageType: String, CustomStringConvertible, Codable {
        case image = "Image"
        case zip = "Zip"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedConcurrencyStatusEnum: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum Runtime: String, CustomStringConvertible, Codable {
        case dotnetcore10 = "dotnetcore1.0"
        case dotnetcore20 = "dotnetcore2.0"
        case dotnetcore21 = "dotnetcore2.1"
        case dotnetcore31 = "dotnetcore3.1"
        case go1X = "go1.x"
        case java11
        case java8
        case java8Al2 = "java8.al2"
        case nodejs
        case nodejs10X = "nodejs10.x"
        case nodejs12X = "nodejs12.x"
        case nodejs14X = "nodejs14.x"
        case nodejs43 = "nodejs4.3"
        case nodejs43Edge = "nodejs4.3-edge"
        case nodejs610 = "nodejs6.10"
        case nodejs810 = "nodejs8.10"
        case provided
        case providedAl2 = "provided.al2"
        case python27 = "python2.7"
        case python36 = "python3.6"
        case python37 = "python3.7"
        case python38 = "python3.8"
        case ruby25 = "ruby2.5"
        case ruby27 = "ruby2.7"
        public var description: String { return self.rawValue }
    }

    public enum SourceAccessType: String, CustomStringConvertible, Codable {
        case basicAuth = "BASIC_AUTH"
        case saslScram256Auth = "SASL_SCRAM_256_AUTH"
        case saslScram512Auth = "SASL_SCRAM_512_AUTH"
        case virtualHost = "VIRTUAL_HOST"
        case vpcSecurityGroup = "VPC_SECURITY_GROUP"
        case vpcSubnet = "VPC_SUBNET"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable {
        case active = "Active"
        case failed = "Failed"
        case inactive = "Inactive"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum StateReasonCode: String, CustomStringConvertible, Codable {
        case creating = "Creating"
        case enilimitexceeded = "EniLimitExceeded"
        case idle = "Idle"
        case imageaccessdenied = "ImageAccessDenied"
        case imagedeleted = "ImageDeleted"
        case insufficientrolepermissions = "InsufficientRolePermissions"
        case internalerror = "InternalError"
        case invalidconfiguration = "InvalidConfiguration"
        case invalidimage = "InvalidImage"
        case invalidsecuritygroup = "InvalidSecurityGroup"
        case invalidsubnet = "InvalidSubnet"
        case restoring = "Restoring"
        case subnetoutofipaddresses = "SubnetOutOfIPAddresses"
        public var description: String { return self.rawValue }
    }

    public enum TracingMode: String, CustomStringConvertible, Codable {
        case active = "Active"
        case passthrough = "PassThrough"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountLimit: AWSDecodableShape {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public let codeSizeUnzipped: Int64?
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.
        public let codeSizeZipped: Int64?
        /// The maximum number of simultaneous function executions.
        public let concurrentExecutions: Int?
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public let totalCodeSize: Int64?
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with PutFunctionConcurrency.
        public let unreservedConcurrentExecutions: Int?

        public init(codeSizeUnzipped: Int64? = nil, codeSizeZipped: Int64? = nil, concurrentExecutions: Int? = nil, totalCodeSize: Int64? = nil, unreservedConcurrentExecutions: Int? = nil) {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case codeSizeUnzipped = "CodeSizeUnzipped"
            case codeSizeZipped = "CodeSizeZipped"
            case concurrentExecutions = "ConcurrentExecutions"
            case totalCodeSize = "TotalCodeSize"
            case unreservedConcurrentExecutions = "UnreservedConcurrentExecutions"
        }
    }

    public struct AccountUsage: AWSDecodableShape {
        /// The number of Lambda functions.
        public let functionCount: Int64?
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public let totalCodeSize: Int64?

        public init(functionCount: Int64? = nil, totalCodeSize: Int64? = nil) {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }

        private enum CodingKeys: String, CodingKey {
            case functionCount = "FunctionCount"
            case totalCodeSize = "TotalCodeSize"
        }
    }

    public struct AddLayerVersionPermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName")),
            AWSMemberEncoding(label: "revisionId", location: .querystring(locationName: "RevisionId")),
            AWSMemberEncoding(label: "versionNumber", location: .uri(locationName: "VersionNumber"))
        ]

        /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
        public let action: String
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// With the principal set to *, grant permission to all accounts in the specified organization.
        public let organizationId: String?
        /// An account ID, or * to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
        public let principal: String
        /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// An identifier that distinguishes the policy from others on the same layer version.
        public let statementId: String
        /// The version number.
        public let versionNumber: Int64

        public init(action: String, layerName: String, organizationId: String? = nil, principal: String, revisionId: String? = nil, statementId: String, versionNumber: Int64) {
            self.action = action
            self.layerName = layerName
            self.organizationId = organizationId
            self.principal = principal
            self.revisionId = revisionId
            self.statementId = statementId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, max: 22)
            try self.validate(self.action, name: "action", parent: name, pattern: "lambda:GetLayerVersion")
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "o-[a-z0-9]{10,32}")
            try self.validate(self.principal, name: "principal", parent: name, pattern: "\\d{12}|\\*|arn:(aws[a-zA-Z-]*):iam::\\d{12}:root")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "([a-zA-Z0-9-_]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case organizationId = "OrganizationId"
            case principal = "Principal"
            case statementId = "StatementId"
        }
    }

    public struct AddLayerVersionPermissionResponse: AWSDecodableShape {
        /// A unique identifier for the current revision of the policy.
        public let revisionId: String?
        /// The permission statement.
        public let statement: String?

        public init(revisionId: String? = nil, statement: String? = nil) {
            self.revisionId = revisionId
            self.statement = statement
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId = "RevisionId"
            case statement = "Statement"
        }
    }

    public struct AddPermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
        public let action: String
        /// For Alexa Smart Home functions, a token that must be supplied by the invoker.
        public let eventSourceToken: String?
        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The Amazon Web Services service or account that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
        public let principal: String
        /// Specify a version or alias to add permissions to a published version of the function.
        public let qualifier: String?
        /// Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// For Amazon S3, the ID of the account that owns the resource. Use this together with SourceArn to ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
        public let sourceAccount: String?
        /// For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic.
        public let sourceArn: String?
        /// A statement identifier that differentiates the statement from others in the same policy.
        public let statementId: String

        public init(action: String, eventSourceToken: String? = nil, functionName: String, principal: String, qualifier: String? = nil, revisionId: String? = nil, sourceAccount: String? = nil, sourceArn: String? = nil, statementId: String) {
            self.action = action
            self.eventSourceToken = eventSourceToken
            self.functionName = functionName
            self.principal = principal
            self.qualifier = qualifier
            self.revisionId = revisionId
            self.sourceAccount = sourceAccount
            self.sourceArn = sourceArn
            self.statementId = statementId
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, pattern: "(lambda:[*]|lambda:[a-zA-Z]+|[*])")
            try self.validate(self.eventSourceToken, name: "eventSourceToken", parent: name, max: 256)
            try self.validate(self.eventSourceToken, name: "eventSourceToken", parent: name, min: 0)
            try self.validate(self.eventSourceToken, name: "eventSourceToken", parent: name, pattern: "[a-zA-Z0-9._\\-]+")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.principal, name: "principal", parent: name, pattern: "[^\\s]+")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
            try self.validate(self.sourceAccount, name: "sourceAccount", parent: name, max: 12)
            try self.validate(self.sourceAccount, name: "sourceAccount", parent: name, pattern: "\\d{12}")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "([a-zA-Z0-9-_]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case eventSourceToken = "EventSourceToken"
            case principal = "Principal"
            case revisionId = "RevisionId"
            case sourceAccount = "SourceAccount"
            case sourceArn = "SourceArn"
            case statementId = "StatementId"
        }
    }

    public struct AddPermissionResponse: AWSDecodableShape {
        /// The permission statement that's added to the function policy.
        public let statement: String?

        public init(statement: String? = nil) {
            self.statement = statement
        }

        private enum CodingKeys: String, CodingKey {
            case statement = "Statement"
        }
    }

    public struct AliasConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias.
        public let aliasArn: String?
        /// A description of the alias.
        public let description: String?
        /// The function version that the alias invokes.
        public let functionVersion: String?
        /// The name of the alias.
        public let name: String?
        /// A unique identifier that changes when you update the alias.
        public let revisionId: String?
        /// The routing configuration of the alias.
        public let routingConfig: AliasRoutingConfiguration?

        public init(aliasArn: String? = nil, description: String? = nil, functionVersion: String? = nil, name: String? = nil, revisionId: String? = nil, routingConfig: AliasRoutingConfiguration? = nil) {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aliasArn = "AliasArn"
            case description = "Description"
            case functionVersion = "FunctionVersion"
            case name = "Name"
            case revisionId = "RevisionId"
            case routingConfig = "RoutingConfig"
        }
    }

    public struct AliasRoutingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The second version, and the percentage of traffic that's routed to it.
        public let additionalVersionWeights: [String: Double]?

        public init(additionalVersionWeights: [String: Double]? = nil) {
            self.additionalVersionWeights = additionalVersionWeights
        }

        public func validate(name: String) throws {
            try self.additionalVersionWeights?.forEach {
                try validate($0.key, name: "additionalVersionWeights.key", parent: name, max: 1024)
                try validate($0.key, name: "additionalVersionWeights.key", parent: name, min: 1)
                try validate($0.key, name: "additionalVersionWeights.key", parent: name, pattern: "[0-9]+")
                try validate($0.value, name: "additionalVersionWeights[\"\($0.key)\"]", parent: name, max: 1)
                try validate($0.value, name: "additionalVersionWeights[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalVersionWeights = "AdditionalVersionWeights"
        }
    }

    public struct AllowedPublishers: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        public let signingProfileVersionArns: [String]

        public init(signingProfileVersionArns: [String]) {
            self.signingProfileVersionArns = signingProfileVersionArns
        }

        public func validate(name: String) throws {
            try self.signingProfileVersionArns.forEach {
                try validate($0, name: "signingProfileVersionArns[]", parent: name, pattern: "arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)")
            }
            try self.validate(self.signingProfileVersionArns, name: "signingProfileVersionArns", parent: name, max: 20)
            try self.validate(self.signingProfileVersionArns, name: "signingProfileVersionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case signingProfileVersionArns = "SigningProfileVersionArns"
        }
    }

    public struct CodeSigningConfig: AWSDecodableShape {
        /// List of allowed publishers.
        public let allowedPublishers: AllowedPublishers
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        public let codeSigningConfigArn: String
        /// Unique identifer for the Code signing configuration.
        public let codeSigningConfigId: String
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        public let codeSigningPolicies: CodeSigningPolicies
        /// Code signing configuration description.
        public let description: String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModified: String

        public init(allowedPublishers: AllowedPublishers, codeSigningConfigArn: String, codeSigningConfigId: String, codeSigningPolicies: CodeSigningPolicies, description: String? = nil, lastModified: String) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPublishers = "AllowedPublishers"
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case codeSigningConfigId = "CodeSigningConfigId"
            case codeSigningPolicies = "CodeSigningPolicies"
            case description = "Description"
            case lastModified = "LastModified"
        }
    }

    public struct CodeSigningPolicies: AWSEncodableShape & AWSDecodableShape {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log.  Default value: Warn
        public let untrustedArtifactOnDeployment: CodeSigningPolicy?

        public init(untrustedArtifactOnDeployment: CodeSigningPolicy? = nil) {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case untrustedArtifactOnDeployment = "UntrustedArtifactOnDeployment"
        }
    }

    public struct Concurrency: AWSDecodableShape {
        /// The number of concurrent executions that are reserved for this function. For more information, see Managing Concurrency.
        public let reservedConcurrentExecutions: Int?

        public init(reservedConcurrentExecutions: Int? = nil) {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
        }
    }

    public struct CreateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// A description of the alias.
        public let description: String?
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The function version that the alias invokes.
        public let functionVersion: String
        /// The name of the alias.
        public let name: String
        /// The routing configuration of the alias.
        public let routingConfig: AliasRoutingConfiguration?

        public init(description: String? = nil, functionName: String, functionVersion: String, name: String, routingConfig: AliasRoutingConfiguration? = nil) {
            self.description = description
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.name = name
            self.routingConfig = routingConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, max: 1024)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, min: 1)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, pattern: "(\\$LATEST|[0-9]+)")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "(?!^[0-9]+$)([a-zA-Z0-9-_]+)")
            try self.routingConfig?.validate(name: "\(name).routingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case functionVersion = "FunctionVersion"
            case name = "Name"
            case routingConfig = "RoutingConfig"
        }
    }

    public struct CreateCodeSigningConfigRequest: AWSEncodableShape {
        /// Signing profiles for this code signing configuration.
        public let allowedPublishers: AllowedPublishers
        /// The code signing policies define the actions to take if the validation checks fail.
        public let codeSigningPolicies: CodeSigningPolicies?
        /// Descriptive name for this code signing configuration.
        public let description: String?

        public init(allowedPublishers: AllowedPublishers, codeSigningPolicies: CodeSigningPolicies? = nil, description: String? = nil) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
        }

        public func validate(name: String) throws {
            try self.allowedPublishers.validate(name: "\(name).allowedPublishers")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPublishers = "AllowedPublishers"
            case codeSigningPolicies = "CodeSigningPolicies"
            case description = "Description"
        }
    }

    public struct CreateCodeSigningConfigResponse: AWSDecodableShape {
        /// The code signing configuration.
        public let codeSigningConfig: CodeSigningConfig

        public init(codeSigningConfig: CodeSigningConfig) {
            self.codeSigningConfig = codeSigningConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfig = "CodeSigningConfig"
        }
    }

    public struct CreateEventSourceMappingRequest: AWSEncodableShape {
        /// The maximum number of items to retrieve in a single batch.    Amazon Kinesis - Default 100. Max 10,000.    Amazon DynamoDB Streams - Default 100. Max 1,000.    Amazon Simple Queue Service - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.    Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.    Self-Managed Apache Kafka - Default 100. Max 10,000.
        public let batchSize: Int?
        /// (Streams only) If the function returns an error, split the batch in two and retry.
        public let bisectBatchOnFunctionError: Bool?
        /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        public let destinationConfig: DestinationConfig?
        /// If true, the event source mapping is active. Set to false to pause polling and invocation.
        public let enabled: Bool?
        /// The Amazon Resource Name (ARN) of the event source.    Amazon Kinesis - The ARN of the data stream or a stream consumer.    Amazon DynamoDB Streams - The ARN of the stream.    Amazon Simple Queue Service - The ARN of the queue.    Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
        public let eventSourceArn: String?
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
        public let functionName: String
        /// (Streams only) A list of current response type enums applied to the event source mapping.
        public let functionResponseTypes: [FunctionResponseType]?
        /// (Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.
        public let maximumBatchingWindowInSeconds: Int?
        /// (Streams only) Discard records older than the specified age. The default value is infinite (-1).
        public let maximumRecordAgeInSeconds: Int?
        /// (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
        public let maximumRetryAttempts: Int?
        /// (Streams only) The number of batches to process from each shard concurrently.
        public let parallelizationFactor: Int?
        ///  (MQ) The name of the Amazon MQ broker destination queue to consume.
        public let queues: [String]?
        /// The Self-Managed Apache Kafka cluster to send records.
        public let selfManagedEventSource: SelfManagedEventSource?
        /// An array of the authentication protocol, or the VPC components to secure your event source.
        public let sourceAccessConfigurations: [SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams sources. AT_TIMESTAMP is only supported for Amazon Kinesis streams.
        public let startingPosition: EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
        public let startingPositionTimestamp: Date?
        /// The name of the Kafka topic.
        public let topics: [String]?
        /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
        public let tumblingWindowInSeconds: Int?

        public init(batchSize: Int? = nil, bisectBatchOnFunctionError: Bool? = nil, destinationConfig: DestinationConfig? = nil, enabled: Bool? = nil, eventSourceArn: String? = nil, functionName: String, functionResponseTypes: [FunctionResponseType]? = nil, maximumBatchingWindowInSeconds: Int? = nil, maximumRecordAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, parallelizationFactor: Int? = nil, queues: [String]? = nil, selfManagedEventSource: SelfManagedEventSource? = nil, sourceAccessConfigurations: [SourceAccessConfiguration]? = nil, startingPosition: EventSourcePosition? = nil, startingPositionTimestamp: Date? = nil, topics: [String]? = nil, tumblingWindowInSeconds: Int? = nil) {
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.enabled = enabled
            self.eventSourceArn = eventSourceArn
            self.functionName = functionName
            self.functionResponseTypes = functionResponseTypes
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.queues = queues
            self.selfManagedEventSource = selfManagedEventSource
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.batchSize, name: "batchSize", parent: name, max: 10000)
            try self.validate(self.batchSize, name: "batchSize", parent: name, min: 1)
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.validate(self.eventSourceArn, name: "eventSourceArn", parent: name, pattern: "arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.functionResponseTypes, name: "functionResponseTypes", parent: name, max: 1)
            try self.validate(self.functionResponseTypes, name: "functionResponseTypes", parent: name, min: 0)
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, max: 300)
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, min: 0)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, max: 604_800)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, min: -1)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 10000)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: -1)
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, max: 10)
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, min: 1)
            try self.queues?.forEach {
                try validate($0, name: "queues[]", parent: name, max: 1000)
                try validate($0, name: "queues[]", parent: name, min: 1)
                try validate($0, name: "queues[]", parent: name, pattern: "[\\s\\S]*")
            }
            try self.validate(self.queues, name: "queues", parent: name, max: 1)
            try self.validate(self.queues, name: "queues", parent: name, min: 1)
            try self.selfManagedEventSource?.validate(name: "\(name).selfManagedEventSource")
            try self.sourceAccessConfigurations?.forEach {
                try $0.validate(name: "\(name).sourceAccessConfigurations[]")
            }
            try self.validate(self.sourceAccessConfigurations, name: "sourceAccessConfigurations", parent: name, max: 22)
            try self.validate(self.sourceAccessConfigurations, name: "sourceAccessConfigurations", parent: name, min: 0)
            try self.topics?.forEach {
                try validate($0, name: "topics[]", parent: name, max: 249)
                try validate($0, name: "topics[]", parent: name, min: 1)
                try validate($0, name: "topics[]", parent: name, pattern: "^[^.]([a-zA-Z0-9\\-_.]+)")
            }
            try self.validate(self.topics, name: "topics", parent: name, max: 1)
            try self.validate(self.topics, name: "topics", parent: name, min: 1)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, max: 900)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
            case destinationConfig = "DestinationConfig"
            case enabled = "Enabled"
            case eventSourceArn = "EventSourceArn"
            case functionName = "FunctionName"
            case functionResponseTypes = "FunctionResponseTypes"
            case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
            case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
            case parallelizationFactor = "ParallelizationFactor"
            case queues = "Queues"
            case selfManagedEventSource = "SelfManagedEventSource"
            case sourceAccessConfigurations = "SourceAccessConfigurations"
            case startingPosition = "StartingPosition"
            case startingPositionTimestamp = "StartingPositionTimestamp"
            case topics = "Topics"
            case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        }
    }

    public struct CreateFunctionRequest: AWSEncodableShape {
        /// The code for the function.
        public let code: FunctionCode
        /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
        public let codeSigningConfigArn: String?
        /// A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues.
        public let deadLetterConfig: DeadLetterConfig?
        /// A description of the function.
        public let description: String?
        /// Environment variables that are accessible from function code during execution.
        public let environment: Environment?
        /// Connection settings for an Amazon EFS file system.
        public let fileSystemConfigs: [FileSystemConfig]?
        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Programming Model.
        public let handler: String?
        /// Container image configuration values that override the values in the container image Dockerfile.
        public let imageConfig: ImageConfig?
        /// The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment variables. If it's not provided, Lambda uses a default service key.
        public let kMSKeyArn: String?
        /// A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.
        public let layers: [String]?
        /// The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
        public let memorySize: Int?
        /// The type of deployment package. Set to Image for container image and set Zip for ZIP archive.
        public let packageType: PackageType?
        /// Set to true to publish the first version of the function during creation.
        public let publish: Bool?
        /// The Amazon Resource Name (ARN) of the function's execution role.
        public let role: String
        /// The identifier of the function's runtime.
        public let runtime: Runtime?
        /// A list of tags to apply to the function.
        public let tags: [String: String]?
        /// The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For additional information, see Lambda execution environment.
        public let timeout: Int?
        /// Set Mode to Active to sample and trace a subset of incoming requests with X-Ray.
        public let tracingConfig: TracingConfig?
        /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings.
        public let vpcConfig: VpcConfig?

        public init(code: FunctionCode, codeSigningConfigArn: String? = nil, deadLetterConfig: DeadLetterConfig? = nil, description: String? = nil, environment: Environment? = nil, fileSystemConfigs: [FileSystemConfig]? = nil, functionName: String, handler: String? = nil, imageConfig: ImageConfig? = nil, kMSKeyArn: String? = nil, layers: [String]? = nil, memorySize: Int? = nil, packageType: PackageType? = nil, publish: Bool? = nil, role: String, runtime: Runtime? = nil, tags: [String: String]? = nil, timeout: Int? = nil, tracingConfig: TracingConfig? = nil, vpcConfig: VpcConfig? = nil) {
            self.code = code
            self.codeSigningConfigArn = codeSigningConfigArn
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.fileSystemConfigs = fileSystemConfigs
            self.functionName = functionName
            self.handler = handler
            self.imageConfig = imageConfig
            self.kMSKeyArn = kMSKeyArn
            self.layers = layers
            self.memorySize = memorySize
            self.packageType = packageType
            self.publish = publish
            self.role = role
            self.runtime = runtime
            self.tags = tags
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.code.validate(name: "\(name).code")
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}")
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.environment?.validate(name: "\(name).environment")
            try self.fileSystemConfigs?.forEach {
                try $0.validate(name: "\(name).fileSystemConfigs[]")
            }
            try self.validate(self.fileSystemConfigs, name: "fileSystemConfigs", parent: name, max: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.handler, name: "handler", parent: name, max: 128)
            try self.validate(self.handler, name: "handler", parent: name, pattern: "[^\\s]+")
            try self.imageConfig?.validate(name: "\(name).imageConfig")
            try self.validate(self.kMSKeyArn, name: "kMSKeyArn", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()")
            try self.layers?.forEach {
                try validate($0, name: "layers[]", parent: name, max: 140)
                try validate($0, name: "layers[]", parent: name, min: 1)
                try validate($0, name: "layers[]", parent: name, pattern: "arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+")
            }
            try self.validate(self.memorySize, name: "memorySize", parent: name, max: 10240)
            try self.validate(self.memorySize, name: "memorySize", parent: name, min: 128)
            try self.validate(self.role, name: "role", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case deadLetterConfig = "DeadLetterConfig"
            case description = "Description"
            case environment = "Environment"
            case fileSystemConfigs = "FileSystemConfigs"
            case functionName = "FunctionName"
            case handler = "Handler"
            case imageConfig = "ImageConfig"
            case kMSKeyArn = "KMSKeyArn"
            case layers = "Layers"
            case memorySize = "MemorySize"
            case packageType = "PackageType"
            case publish = "Publish"
            case role = "Role"
            case runtime = "Runtime"
            case tags = "Tags"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct DeadLetterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public let targetArn: String?

        public init(targetArn: String? = nil) {
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.targetArn, name: "targetArn", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()")
        }

        private enum CodingKeys: String, CodingKey {
            case targetArn = "TargetArn"
        }
    }

    public struct DeleteAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "Name"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the alias.
        public let name: String

        public init(functionName: String, name: String) {
            self.functionName = functionName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "(?!^[0-9]+$)([a-zA-Z0-9-_]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "codeSigningConfigArn", location: .uri(locationName: "CodeSigningConfigArn"))
        ]

        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String

        public init(codeSigningConfigArn: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeSigningConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventSourceMappingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "uuid", location: .uri(locationName: "UUID"))
        ]

        /// The identifier of the event source mapping.
        public let uuid: String

        public init(uuid: String) {
            self.uuid = uuid
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(functionName: String) {
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionConcurrencyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(functionName: String) {
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionEventInvokeConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// A version number or alias name.
        public let qualifier: String?

        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function or version.  Name formats     Function name - my-function (name-only), my-function:1 (with version).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version to delete. You can't delete a version that's referenced by an alias.
        public let qualifier: String?

        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLayerVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName")),
            AWSMemberEncoding(label: "versionNumber", location: .uri(locationName: "VersionNumber"))
        ]

        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The version number.
        public let versionNumber: Int64

        public init(layerName: String, versionNumber: Int64) {
            self.layerName = layerName
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProvisionedConcurrencyConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The version number or alias name.
        public let qualifier: String

        public init(functionName: String, qualifier: String) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DestinationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The destination configuration for failed invocations.
        public let onFailure: OnFailure?
        /// The destination configuration for successful invocations.
        public let onSuccess: OnSuccess?

        public init(onFailure: OnFailure? = nil, onSuccess: OnSuccess? = nil) {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }

        public func validate(name: String) throws {
            try self.onFailure?.validate(name: "\(name).onFailure")
            try self.onSuccess?.validate(name: "\(name).onSuccess")
        }

        private enum CodingKeys: String, CodingKey {
            case onFailure = "OnFailure"
            case onSuccess = "OnSuccess"
        }
    }

    public struct Environment: AWSEncodableShape {
        /// Environment variable key-value pairs. For more information, see Using Lambda environment variables.
        public let variables: [String: String]?

        public init(variables: [String: String]? = nil) {
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "[a-zA-Z]([a-zA-Z0-9_])+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case variables = "Variables"
        }
    }

    public struct EnvironmentError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct EnvironmentResponse: AWSDecodableShape {
        /// Error messages for environment variables that couldn't be applied.
        public let error: EnvironmentError?
        /// Environment variable key-value pairs.
        public let variables: [String: String]?

        public init(error: EnvironmentError? = nil, variables: [String: String]? = nil) {
            self.error = error
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case variables = "Variables"
        }
    }

    public struct EventSourceMappingConfiguration: AWSDecodableShape {
        /// The maximum number of items to retrieve in a single batch.
        public let batchSize: Int?
        /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
        public let bisectBatchOnFunctionError: Bool?
        /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        public let destinationConfig: DestinationConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public let eventSourceArn: String?
        /// The ARN of the Lambda function.
        public let functionArn: String?
        /// (Streams only) A list of current response type enums applied to the event source mapping.
        public let functionResponseTypes: [FunctionResponseType]?
        /// The date that the event source mapping was last updated, or its state changed.
        public let lastModified: Date?
        /// The result of the last Lambda invocation of your Lambda function.
        public let lastProcessingResult: String?
        /// (Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.
        public let maximumBatchingWindowInSeconds: Int?
        /// (Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
        public let maximumRecordAgeInSeconds: Int?
        /// (Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public let maximumRetryAttempts: Int?
        /// (Streams only) The number of batches to process from each shard concurrently. The default value is 1.
        public let parallelizationFactor: Int?
        ///  (MQ) The name of the Amazon MQ broker destination queue to consume.
        public let queues: [String]?
        /// The Self-Managed Apache Kafka cluster for your event source.
        public let selfManagedEventSource: SelfManagedEventSource?
        /// An array of the authentication protocol, or the VPC components to secure your event source.
        public let sourceAccessConfigurations: [SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams sources. AT_TIMESTAMP is only supported for Amazon Kinesis streams.
        public let startingPosition: EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
        public let startingPositionTimestamp: Date?
        /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
        public let state: String?
        /// Indicates whether the last change to the event source mapping was made by a user, or by the Lambda service.
        public let stateTransitionReason: String?
        /// The name of the Kafka topic.
        public let topics: [String]?
        /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
        public let tumblingWindowInSeconds: Int?
        /// The identifier of the event source mapping.
        public let uuid: String?

        public init(batchSize: Int? = nil, bisectBatchOnFunctionError: Bool? = nil, destinationConfig: DestinationConfig? = nil, eventSourceArn: String? = nil, functionArn: String? = nil, functionResponseTypes: [FunctionResponseType]? = nil, lastModified: Date? = nil, lastProcessingResult: String? = nil, maximumBatchingWindowInSeconds: Int? = nil, maximumRecordAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, parallelizationFactor: Int? = nil, queues: [String]? = nil, selfManagedEventSource: SelfManagedEventSource? = nil, sourceAccessConfigurations: [SourceAccessConfiguration]? = nil, startingPosition: EventSourcePosition? = nil, startingPositionTimestamp: Date? = nil, state: String? = nil, stateTransitionReason: String? = nil, topics: [String]? = nil, tumblingWindowInSeconds: Int? = nil, uuid: String? = nil) {
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.eventSourceArn = eventSourceArn
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.queues = queues
            self.selfManagedEventSource = selfManagedEventSource
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
            case destinationConfig = "DestinationConfig"
            case eventSourceArn = "EventSourceArn"
            case functionArn = "FunctionArn"
            case functionResponseTypes = "FunctionResponseTypes"
            case lastModified = "LastModified"
            case lastProcessingResult = "LastProcessingResult"
            case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
            case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
            case parallelizationFactor = "ParallelizationFactor"
            case queues = "Queues"
            case selfManagedEventSource = "SelfManagedEventSource"
            case sourceAccessConfigurations = "SourceAccessConfigurations"
            case startingPosition = "StartingPosition"
            case startingPositionTimestamp = "StartingPositionTimestamp"
            case state = "State"
            case stateTransitionReason = "StateTransitionReason"
            case topics = "Topics"
            case tumblingWindowInSeconds = "TumblingWindowInSeconds"
            case uuid = "UUID"
        }
    }

    public struct FileSystemConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        public let arn: String
        /// The path where the function can access the file system, starting with /mnt/.
        public let localMountPath: String

        public init(arn: String, localMountPath: String) {
            self.arn = arn
            self.localMountPath = localMountPath
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 200)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:access-point/fsap-[a-f0-9]{17}")
            try self.validate(self.localMountPath, name: "localMountPath", parent: name, max: 160)
            try self.validate(self.localMountPath, name: "localMountPath", parent: name, pattern: "^/mnt/[a-zA-Z0-9-_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case localMountPath = "LocalMountPath"
        }
    }

    public struct FunctionCode: AWSEncodableShape {
        /// URI of a container image in the Amazon ECR registry.
        public let imageUri: String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public let zipFile: Data?

        public init(imageUri: String? = nil, s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: Data? = nil) {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*(?<!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1024)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageUri = "ImageUri"
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct FunctionCodeLocation: AWSDecodableShape {
        /// URI of a container image in the Amazon ECR registry.
        public let imageUri: String?
        /// A presigned URL that you can use to download the deployment package.
        public let location: String?
        /// The service that's hosting the file.
        public let repositoryType: String?
        /// The resolved URI for the image.
        public let resolvedImageUri: String?

        public init(imageUri: String? = nil, location: String? = nil, repositoryType: String? = nil, resolvedImageUri: String? = nil) {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
        }

        private enum CodingKeys: String, CodingKey {
            case imageUri = "ImageUri"
            case location = "Location"
            case repositoryType = "RepositoryType"
            case resolvedImageUri = "ResolvedImageUri"
        }
    }

    public struct FunctionConfiguration: AWSDecodableShape {
        /// The SHA256 hash of the function's deployment package.
        public let codeSha256: String?
        /// The size of the function's deployment package, in bytes.
        public let codeSize: Int64?
        /// The function's dead letter queue.
        public let deadLetterConfig: DeadLetterConfig?
        /// The function's description.
        public let description: String?
        /// The function's environment variables.
        public let environment: EnvironmentResponse?
        /// Connection settings for an Amazon EFS file system.
        public let fileSystemConfigs: [FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public let functionArn: String?
        /// The name of the function.
        public let functionName: String?
        /// The function that Lambda calls to begin executing your function.
        public let handler: String?
        /// The function's image configuration values.
        public let imageConfigResponse: ImageConfigResponse?
        /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed CMK.
        public let kMSKeyArn: String?
        /// The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModified: String?
        /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
        public let lastUpdateStatus: LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public let lastUpdateStatusReason: String?
        /// The reason code for the last update that was performed on the function.
        public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
        /// The function's  layers.
        public let layers: [Layer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public let masterArn: String?
        /// The amount of memory available to the function at runtime.
        public let memorySize: Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public let packageType: PackageType?
        /// The latest updated revision of the function or alias.
        public let revisionId: String?
        /// The function's execution role.
        public let role: String?
        /// The runtime environment for the Lambda function.
        public let runtime: Runtime?
        /// The ARN of the signing job.
        public let signingJobArn: String?
        /// The ARN of the signing profile version.
        public let signingProfileVersionArn: String?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
        public let state: State?
        /// The reason for the function's current state.
        public let stateReason: String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
        public let stateReasonCode: StateReasonCode?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public let timeout: Int?
        /// The function's X-Ray tracing configuration.
        public let tracingConfig: TracingConfigResponse?
        /// The version of the Lambda function.
        public let version: String?
        /// The function's networking configuration.
        public let vpcConfig: VpcConfigResponse?

        public init(codeSha256: String? = nil, codeSize: Int64? = nil, deadLetterConfig: DeadLetterConfig? = nil, description: String? = nil, environment: EnvironmentResponse? = nil, fileSystemConfigs: [FileSystemConfig]? = nil, functionArn: String? = nil, functionName: String? = nil, handler: String? = nil, imageConfigResponse: ImageConfigResponse? = nil, kMSKeyArn: String? = nil, lastModified: String? = nil, lastUpdateStatus: LastUpdateStatus? = nil, lastUpdateStatusReason: String? = nil, lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil, layers: [Layer]? = nil, masterArn: String? = nil, memorySize: Int? = nil, packageType: PackageType? = nil, revisionId: String? = nil, role: String? = nil, runtime: Runtime? = nil, signingJobArn: String? = nil, signingProfileVersionArn: String? = nil, state: State? = nil, stateReason: String? = nil, stateReasonCode: StateReasonCode? = nil, timeout: Int? = nil, tracingConfig: TracingConfigResponse? = nil, version: String? = nil, vpcConfig: VpcConfigResponse? = nil) {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kMSKeyArn = kMSKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSha256 = "CodeSha256"
            case codeSize = "CodeSize"
            case deadLetterConfig = "DeadLetterConfig"
            case description = "Description"
            case environment = "Environment"
            case fileSystemConfigs = "FileSystemConfigs"
            case functionArn = "FunctionArn"
            case functionName = "FunctionName"
            case handler = "Handler"
            case imageConfigResponse = "ImageConfigResponse"
            case kMSKeyArn = "KMSKeyArn"
            case lastModified = "LastModified"
            case lastUpdateStatus = "LastUpdateStatus"
            case lastUpdateStatusReason = "LastUpdateStatusReason"
            case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
            case layers = "Layers"
            case masterArn = "MasterArn"
            case memorySize = "MemorySize"
            case packageType = "PackageType"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case signingJobArn = "SigningJobArn"
            case signingProfileVersionArn = "SigningProfileVersionArn"
            case state = "State"
            case stateReason = "StateReason"
            case stateReasonCode = "StateReasonCode"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case version = "Version"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct FunctionEventInvokeConfig: AWSDecodableShape {
        /// A destination for events after they have been sent to a function for processing.  Destinations     Function - The Amazon Resource Name (ARN) of a Lambda function.    Queue - The ARN of an SQS queue.    Topic - The ARN of an SNS topic.    Event Bus - The ARN of an Amazon EventBridge event bus.
        public let destinationConfig: DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public let functionArn: String?
        /// The date and time that the configuration was last updated.
        public let lastModified: Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of times to retry when the function returns an error.
        public let maximumRetryAttempts: Int?

        public init(destinationConfig: DestinationConfig? = nil, functionArn: String? = nil, lastModified: Date? = nil, maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil) {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfig = "DestinationConfig"
            case functionArn = "FunctionArn"
            case lastModified = "LastModified"
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResponse: AWSDecodableShape {
        /// Limits that are related to concurrency and code storage.
        public let accountLimit: AccountLimit?
        /// The number of functions and amount of storage in use.
        public let accountUsage: AccountUsage?

        public init(accountLimit: AccountLimit? = nil, accountUsage: AccountUsage? = nil) {
            self.accountLimit = accountLimit
            self.accountUsage = accountUsage
        }

        private enum CodingKeys: String, CodingKey {
            case accountLimit = "AccountLimit"
            case accountUsage = "AccountUsage"
        }
    }

    public struct GetAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "Name"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the alias.
        public let name: String

        public init(functionName: String, name: String) {
            self.functionName = functionName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "(?!^[0-9]+$)([a-zA-Z0-9-_]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "codeSigningConfigArn", location: .uri(locationName: "CodeSigningConfigArn"))
        ]

        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String

        public init(codeSigningConfigArn: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeSigningConfigResponse: AWSDecodableShape {
        /// The code signing configuration
        public let codeSigningConfig: CodeSigningConfig

        public init(codeSigningConfig: CodeSigningConfig) {
            self.codeSigningConfig = codeSigningConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfig = "CodeSigningConfig"
        }
    }

    public struct GetEventSourceMappingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "uuid", location: .uri(locationName: "UUID"))
        ]

        /// The identifier of the event source mapping.
        public let uuid: String

        public init(uuid: String) {
            self.uuid = uuid
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(functionName: String) {
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionCodeSigningConfigResponse: AWSDecodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(codeSigningConfigArn: String, functionName: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.functionName = functionName
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case functionName = "FunctionName"
        }
    }

    public struct GetFunctionConcurrencyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(functionName: String) {
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionConcurrencyResponse: AWSDecodableShape {
        /// The number of simultaneous executions that are reserved for the function.
        public let reservedConcurrentExecutions: Int?

        public init(reservedConcurrentExecutions: Int? = nil) {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
        }
    }

    public struct GetFunctionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to get details about a published version of the function.
        public let qualifier: String?

        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionEventInvokeConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// A version number or alias name.
        public let qualifier: String?

        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to get details about a published version of the function.
        public let qualifier: String?

        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionResponse: AWSDecodableShape {
        /// The deployment package of the function or version.
        public let code: FunctionCodeLocation?
        /// The function's reserved concurrency.
        public let concurrency: Concurrency?
        /// The configuration of the function or version.
        public let configuration: FunctionConfiguration?
        /// The function's tags.
        public let tags: [String: String]?

        public init(code: FunctionCodeLocation? = nil, concurrency: Concurrency? = nil, configuration: FunctionConfiguration? = nil, tags: [String: String]? = nil) {
            self.code = code
            self.concurrency = concurrency
            self.configuration = configuration
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case concurrency = "Concurrency"
            case configuration = "Configuration"
            case tags = "Tags"
        }
    }

    public struct GetLayerVersionByArnRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring(locationName: "Arn"))
        ]

        /// The ARN of the layer version.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 140)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayerVersionPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName")),
            AWSMemberEncoding(label: "versionNumber", location: .uri(locationName: "VersionNumber"))
        ]

        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The version number.
        public let versionNumber: Int64

        public init(layerName: String, versionNumber: Int64) {
            self.layerName = layerName
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayerVersionPolicyResponse: AWSDecodableShape {
        /// The policy document.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let revisionId: String?

        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct GetLayerVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName")),
            AWSMemberEncoding(label: "versionNumber", location: .uri(locationName: "VersionNumber"))
        ]

        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The version number.
        public let versionNumber: Int64

        public init(layerName: String, versionNumber: Int64) {
            self.layerName = layerName
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayerVersionResponse: AWSDecodableShape {
        /// The layer's compatible runtimes.
        public let compatibleRuntimes: [Runtime]?
        /// Details about the layer version.
        public let content: LayerVersionContentOutput?
        /// The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let createdDate: String?
        /// The description of the version.
        public let description: String?
        /// The ARN of the layer.
        public let layerArn: String?
        /// The ARN of the layer version.
        public let layerVersionArn: String?
        /// The layer's software license.
        public let licenseInfo: String?
        /// The version number.
        public let version: Int64?

        public init(compatibleRuntimes: [Runtime]? = nil, content: LayerVersionContentOutput? = nil, createdDate: String? = nil, description: String? = nil, layerArn: String? = nil, layerVersionArn: String? = nil, licenseInfo: String? = nil, version: Int64? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.content = content
            self.createdDate = createdDate
            self.description = description
            self.layerArn = layerArn
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case content = "Content"
            case createdDate = "CreatedDate"
            case description = "Description"
            case layerArn = "LayerArn"
            case layerVersionArn = "LayerVersionArn"
            case licenseInfo = "LicenseInfo"
            case version = "Version"
        }
    }

    public struct GetPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to get the policy for that resource.
        public let qualifier: String?

        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyResponse: AWSDecodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let revisionId: String?

        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct GetProvisionedConcurrencyConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The version number or alias name.
        public let qualifier: String

        public init(functionName: String, qualifier: String) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProvisionedConcurrencyConfigResponse: AWSDecodableShape {
        /// The amount of provisioned concurrency allocated.
        public let allocatedProvisionedConcurrentExecutions: Int?
        /// The amount of provisioned concurrency available.
        public let availableProvisionedConcurrentExecutions: Int?
        /// The date and time that a user last updated the configuration, in ISO 8601 format.
        public let lastModified: String?
        /// The amount of provisioned concurrency requested.
        public let requestedProvisionedConcurrentExecutions: Int?
        /// The status of the allocation process.
        public let status: ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public let statusReason: String?

        public init(allocatedProvisionedConcurrentExecutions: Int? = nil, availableProvisionedConcurrentExecutions: Int? = nil, lastModified: String? = nil, requestedProvisionedConcurrentExecutions: Int? = nil, status: ProvisionedConcurrencyStatusEnum? = nil, statusReason: String? = nil) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
            case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
            case lastModified = "LastModified"
            case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct ImageConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public let command: [String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime executable.
        public let entryPoint: [String]?
        /// Specifies the working directory.
        public let workingDirectory: String?

        public init(command: [String]? = nil, entryPoint: [String]? = nil, workingDirectory: String? = nil) {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.command, name: "command", parent: name, max: 1500)
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, max: 1500)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case entryPoint = "EntryPoint"
            case workingDirectory = "WorkingDirectory"
        }
    }

    public struct ImageConfigError: AWSDecodableShape {
        /// Error code.
        public let errorCode: String?
        /// Error message.
        public let message: String?

        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ImageConfigResponse: AWSDecodableShape {
        /// Error response to GetFunctionConfiguration.
        public let error: ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public let imageConfig: ImageConfig?

        public init(error: ImageConfigError? = nil, imageConfig: ImageConfig? = nil) {
            self.error = error
            self.imageConfig = imageConfig
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case imageConfig = "ImageConfig"
        }
    }

    public struct InvocationRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "payload"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "clientContext", location: .header(locationName: "X-Amz-Client-Context")),
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "invocationType", location: .header(locationName: "X-Amz-Invocation-Type")),
            AWSMemberEncoding(label: "logType", location: .header(locationName: "X-Amz-Log-Type")),
            AWSMemberEncoding(label: "payload", location: .body(locationName: "Payload")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
        public let clientContext: String?
        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Choose from the following options.    RequestResponse (default) - Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API response includes the function response and additional data.    Event - Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if it's configured). The API response only includes a status code.    DryRun - Validate parameter values and verify that the user or role has permission to invoke the function.
        public let invocationType: InvocationType?
        /// Set to Tail to include the execution log in the response.
        public let logType: LogType?
        /// The JSON that you want to provide to your Lambda function as input.
        public let payload: AWSPayload?
        /// Specify a version or alias to invoke a published version of the function.
        public let qualifier: String?

        public init(clientContext: String? = nil, functionName: String, invocationType: InvocationType? = nil, logType: LogType? = nil, payload: AWSPayload? = nil, qualifier: String? = nil) {
            self.clientContext = clientContext
            self.functionName = functionName
            self.invocationType = invocationType
            self.logType = logType
            self.payload = payload
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvocationResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "payload"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "executedVersion", location: .header(locationName: "X-Amz-Executed-Version")),
            AWSMemberEncoding(label: "functionError", location: .header(locationName: "X-Amz-Function-Error")),
            AWSMemberEncoding(label: "logResult", location: .header(locationName: "X-Amz-Log-Result")),
            AWSMemberEncoding(label: "payload", location: .body(locationName: "Payload")),
            AWSMemberEncoding(label: "statusCode", location: .statusCode)
        ]

        /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
        public let executedVersion: String?
        /// If present, indicates that an error occurred during function execution. Details about the error are included in the response payload.
        public let functionError: String?
        /// The last 4 KB of the execution log, which is base64 encoded.
        public let logResult: String?
        /// The response from the function, or an error object.
        public let payload: AWSPayload?
        /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse invocation type, this status code is 200. For the Event invocation type, this status code is 202. For the DryRun invocation type, the status code is 204.
        public let statusCode: Int?

        public init(executedVersion: String? = nil, functionError: String? = nil, logResult: String? = nil, payload: AWSPayload? = nil, statusCode: Int? = nil) {
            self.executedVersion = executedVersion
            self.functionError = functionError
            self.logResult = logResult
            self.payload = payload
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case executedVersion = "X-Amz-Executed-Version"
            case functionError = "X-Amz-Function-Error"
            case logResult = "X-Amz-Log-Result"
            case payload = "Payload"
            case statusCode = "StatusCode"
        }
    }

    public struct InvokeAsyncRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "invokeArgs"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw, .allowStreaming]
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "invokeArgs", location: .body(locationName: "InvokeArgs"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The JSON that you want to provide to your Lambda function as input.
        public let invokeArgs: AWSPayload

        public init(functionName: String, invokeArgs: AWSPayload) {
            self.functionName = functionName
            self.invokeArgs = invokeArgs
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeAsyncResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The status code.
        public let status: Int?

        public init(status: Int? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct Layer: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the function layer.
        public let arn: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int64?
        /// The Amazon Resource Name (ARN) of a signing job.
        public let signingJobArn: String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public let signingProfileVersionArn: String?

        public init(arn: String? = nil, codeSize: Int64? = nil, signingJobArn: String? = nil, signingProfileVersionArn: String? = nil) {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case codeSize = "CodeSize"
            case signingJobArn = "SigningJobArn"
            case signingProfileVersionArn = "SigningProfileVersionArn"
        }
    }

    public struct LayerVersionContentInput: AWSEncodableShape {
        /// The Amazon S3 bucket of the layer archive.
        public let s3Bucket: String?
        /// The Amazon S3 key of the layer archive.
        public let s3Key: String?
        /// For versioned objects, the version of the layer archive object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public let zipFile: Data?

        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: Data? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*(?<!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1024)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct LayerVersionContentOutput: AWSDecodableShape {
        /// The SHA-256 hash of the layer archive.
        public let codeSha256: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int64?
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public let location: String?
        /// The Amazon Resource Name (ARN) of a signing job.
        public let signingJobArn: String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public let signingProfileVersionArn: String?

        public init(codeSha256: String? = nil, codeSize: Int64? = nil, location: String? = nil, signingJobArn: String? = nil, signingProfileVersionArn: String? = nil) {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case codeSha256 = "CodeSha256"
            case codeSize = "CodeSize"
            case location = "Location"
            case signingJobArn = "SigningJobArn"
            case signingProfileVersionArn = "SigningProfileVersionArn"
        }
    }

    public struct LayerVersionsListItem: AWSDecodableShape {
        /// The layer's compatible runtimes.
        public let compatibleRuntimes: [Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public let createdDate: String?
        /// The description of the version.
        public let description: String?
        /// The ARN of the layer version.
        public let layerVersionArn: String?
        /// The layer's open-source license.
        public let licenseInfo: String?
        /// The version number.
        public let version: Int64?

        public init(compatibleRuntimes: [Runtime]? = nil, createdDate: String? = nil, description: String? = nil, layerVersionArn: String? = nil, licenseInfo: String? = nil, version: Int64? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case createdDate = "CreatedDate"
            case description = "Description"
            case layerVersionArn = "LayerVersionArn"
            case licenseInfo = "LicenseInfo"
            case version = "Version"
        }
    }

    public struct LayersListItem: AWSDecodableShape {
        /// The newest version of the layer.
        public let latestMatchingVersion: LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public let layerArn: String?
        /// The name of the layer.
        public let layerName: String?

        public init(latestMatchingVersion: LayerVersionsListItem? = nil, layerArn: String? = nil, layerName: String? = nil) {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }

        private enum CodingKeys: String, CodingKey {
            case latestMatchingVersion = "LatestMatchingVersion"
            case layerArn = "LayerArn"
            case layerName = "LayerName"
        }
    }

    public struct ListAliasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "functionVersion", location: .querystring(locationName: "FunctionVersion")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a function version to only list aliases that invoke that version.
        public let functionVersion: String?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Limit the number of aliases returned.
        public let maxItems: Int?

        public init(functionName: String, functionVersion: String? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, max: 1024)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, min: 1)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, pattern: "(\\$LATEST|[0-9]+)")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAliasesResponse: AWSDecodableShape {
        /// A list of aliases.
        public let aliases: [AliasConfiguration]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        public init(aliases: [AliasConfiguration]? = nil, nextMarker: String? = nil) {
            self.aliases = aliases
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListCodeSigningConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Maximum number of items to return.
        public let maxItems: Int?

        public init(marker: String? = nil, maxItems: Int? = nil) {
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCodeSigningConfigsResponse: AWSDecodableShape {
        /// The code signing configurations
        public let codeSigningConfigs: [CodeSigningConfig]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        public init(codeSigningConfigs: [CodeSigningConfig]? = nil, nextMarker: String? = nil) {
            self.codeSigningConfigs = codeSigningConfigs
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigs = "CodeSigningConfigs"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListEventSourceMappingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eventSourceArn", location: .querystring(locationName: "EventSourceArn")),
            AWSMemberEncoding(label: "functionName", location: .querystring(locationName: "FunctionName")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// The Amazon Resource Name (ARN) of the event source.    Amazon Kinesis - The ARN of the data stream or a stream consumer.    Amazon DynamoDB Streams - The ARN of the stream.    Amazon Simple Queue Service - The ARN of the queue.    Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
        public let eventSourceArn: String?
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
        public let functionName: String?
        /// A pagination token returned by a previous call.
        public let marker: String?
        /// The maximum number of event source mappings to return.
        public let maxItems: Int?

        public init(eventSourceArn: String? = nil, functionName: String? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.eventSourceArn = eventSourceArn
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.eventSourceArn, name: "eventSourceArn", parent: name, pattern: "arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventSourceMappingsResponse: AWSDecodableShape {
        /// A list of event source mappings.
        public let eventSourceMappings: [EventSourceMappingConfiguration]?
        /// A pagination token that's returned when the response doesn't contain all event source mappings.
        public let nextMarker: String?

        public init(eventSourceMappings: [EventSourceMappingConfiguration]? = nil, nextMarker: String? = nil) {
            self.eventSourceMappings = eventSourceMappings
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSourceMappings = "EventSourceMappings"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionEventInvokeConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// The maximum number of configurations to return.
        public let maxItems: Int?

        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionEventInvokeConfigsResponse: AWSDecodableShape {
        /// A list of configurations.
        public let functionEventInvokeConfigs: [FunctionEventInvokeConfig]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        public init(functionEventInvokeConfigs: [FunctionEventInvokeConfig]? = nil, nextMarker: String? = nil) {
            self.functionEventInvokeConfigs = functionEventInvokeConfigs
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functionEventInvokeConfigs = "FunctionEventInvokeConfigs"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionsByCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "codeSigningConfigArn", location: .uri(locationName: "CodeSigningConfigArn")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Maximum number of items to return.
        public let maxItems: Int?

        public init(codeSigningConfigArn: String, marker: String? = nil, maxItems: Int? = nil) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionsByCodeSigningConfigResponse: AWSDecodableShape {
        /// The function ARNs.
        public let functionArns: [String]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        public init(functionArns: [String]? = nil, nextMarker: String? = nil) {
            self.functionArns = functionArns
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functionArns = "FunctionArns"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionVersion", location: .querystring(locationName: "FunctionVersion")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "masterRegion", location: .querystring(locationName: "MasterRegion")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// Set to ALL to include entries for all published versions of each function.
        public let functionVersion: FunctionVersion?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// For Lambda@Edge functions, the Region of the master function. For example, us-east-1 filters the list of functions to only include Lambda@Edge functions replicated from a master function in US East (N. Virginia). If specified, you must set FunctionVersion to ALL.
        public let masterRegion: SotoCore.Region?
        /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response, even if you set the number higher.
        public let maxItems: Int?

        public init(functionVersion: FunctionVersion? = nil, marker: String? = nil, masterRegion: SotoCore.Region? = nil, maxItems: Int? = nil) {
            self.functionVersion = functionVersion
            self.marker = marker
            self.masterRegion = masterRegion
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionsResponse: AWSDecodableShape {
        /// A list of Lambda functions.
        public let functions: [FunctionConfiguration]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        public init(functions: [FunctionConfiguration]? = nil, nextMarker: String? = nil) {
            self.functions = functions
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "Functions"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListLayerVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "compatibleRuntime", location: .querystring(locationName: "CompatibleRuntime")),
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// A runtime identifier. For example, go1.x.
        public let compatibleRuntime: Runtime?
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// A pagination token returned by a previous call.
        public let marker: String?
        /// The maximum number of versions to return.
        public let maxItems: Int?

        public init(compatibleRuntime: Runtime? = nil, layerName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.compatibleRuntime = compatibleRuntime
            self.layerName = layerName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayerVersionsResponse: AWSDecodableShape {
        /// A list of versions.
        public let layerVersions: [LayerVersionsListItem]?
        /// A pagination token returned when the response doesn't contain all versions.
        public let nextMarker: String?

        public init(layerVersions: [LayerVersionsListItem]? = nil, nextMarker: String? = nil) {
            self.layerVersions = layerVersions
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case layerVersions = "LayerVersions"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListLayersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "compatibleRuntime", location: .querystring(locationName: "CompatibleRuntime")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// A runtime identifier. For example, go1.x.
        public let compatibleRuntime: Runtime?
        /// A pagination token returned by a previous call.
        public let marker: String?
        /// The maximum number of layers to return.
        public let maxItems: Int?

        public init(compatibleRuntime: Runtime? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.compatibleRuntime = compatibleRuntime
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayersResponse: AWSDecodableShape {
        /// A list of function layers.
        public let layers: [LayersListItem]?
        /// A pagination token returned when the response doesn't contain all layers.
        public let nextMarker: String?

        public init(layers: [LayersListItem]? = nil, nextMarker: String? = nil) {
            self.layers = layers
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case layers = "Layers"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListProvisionedConcurrencyConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Specify a number to limit the number of configurations returned.
        public let maxItems: Int?

        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisionedConcurrencyConfigsResponse: AWSDecodableShape {
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?
        /// A list of provisioned concurrency configurations.
        public let provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]?

        public init(nextMarker: String? = nil, provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]? = nil) {
            self.nextMarker = nextMarker
            self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextMarker = "NextMarker"
            case provisionedConcurrencyConfigs = "ProvisionedConcurrencyConfigs"
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resource", location: .uri(locationName: "ARN"))
        ]

        /// The function's Amazon Resource Name (ARN).
        public let resource: String

        public init(resource: String) {
            self.resource = resource
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// The function's tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVersionsByFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "marker", location: .querystring(locationName: "Marker")),
            AWSMemberEncoding(label: "maxItems", location: .querystring(locationName: "MaxItems"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response, even if you set the number higher.
        public let maxItems: Int?

        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVersionsByFunctionResponse: AWSDecodableShape {
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?
        /// A list of Lambda function versions.
        public let versions: [FunctionConfiguration]?

        public init(nextMarker: String? = nil, versions: [FunctionConfiguration]? = nil) {
            self.nextMarker = nextMarker
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextMarker = "NextMarker"
            case versions = "Versions"
        }
    }

    public struct OnFailure: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public let destination: String?

        public init(destination: String? = nil) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 350)
            try self.validate(self.destination, name: "destination", parent: name, min: 0)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct OnSuccess: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public let destination: String?

        public init(destination: String? = nil) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 350)
            try self.validate(self.destination, name: "destination", parent: name, min: 0)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct ProvisionedConcurrencyConfigListItem: AWSDecodableShape {
        /// The amount of provisioned concurrency allocated.
        public let allocatedProvisionedConcurrentExecutions: Int?
        /// The amount of provisioned concurrency available.
        public let availableProvisionedConcurrentExecutions: Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public let functionArn: String?
        /// The date and time that a user last updated the configuration, in ISO 8601 format.
        public let lastModified: String?
        /// The amount of provisioned concurrency requested.
        public let requestedProvisionedConcurrentExecutions: Int?
        /// The status of the allocation process.
        public let status: ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public let statusReason: String?

        public init(allocatedProvisionedConcurrentExecutions: Int? = nil, availableProvisionedConcurrentExecutions: Int? = nil, functionArn: String? = nil, lastModified: String? = nil, requestedProvisionedConcurrentExecutions: Int? = nil, status: ProvisionedConcurrencyStatusEnum? = nil, statusReason: String? = nil) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
            case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
            case functionArn = "FunctionArn"
            case lastModified = "LastModified"
            case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct PublishLayerVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName"))
        ]

        /// A list of compatible function runtimes. Used for filtering with ListLayers and ListLayerVersions.
        public let compatibleRuntimes: [Runtime]?
        /// The function layer archive.
        public let content: LayerVersionContentInput
        /// The description of the version.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The layer's software license. It can be any of the following:   An SPDX license identifier. For example, MIT.   The URL of a license hosted on the internet. For example, https://opensource.org/licenses/MIT.   The full text of the license.
        public let licenseInfo: String?

        public init(compatibleRuntimes: [Runtime]? = nil, content: LayerVersionContentInput, description: String? = nil, layerName: String, licenseInfo: String? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.content = content
            self.description = description
            self.layerName = layerName
            self.licenseInfo = licenseInfo
        }

        public func validate(name: String) throws {
            try self.validate(self.compatibleRuntimes, name: "compatibleRuntimes", parent: name, max: 15)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
            try self.validate(self.licenseInfo, name: "licenseInfo", parent: name, max: 512)
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case content = "Content"
            case description = "Description"
            case licenseInfo = "LicenseInfo"
        }
    }

    public struct PublishLayerVersionResponse: AWSDecodableShape {
        /// The layer's compatible runtimes.
        public let compatibleRuntimes: [Runtime]?
        /// Details about the layer version.
        public let content: LayerVersionContentOutput?
        /// The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let createdDate: String?
        /// The description of the version.
        public let description: String?
        /// The ARN of the layer.
        public let layerArn: String?
        /// The ARN of the layer version.
        public let layerVersionArn: String?
        /// The layer's software license.
        public let licenseInfo: String?
        /// The version number.
        public let version: Int64?

        public init(compatibleRuntimes: [Runtime]? = nil, content: LayerVersionContentOutput? = nil, createdDate: String? = nil, description: String? = nil, layerArn: String? = nil, layerVersionArn: String? = nil, licenseInfo: String? = nil, version: Int64? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.content = content
            self.createdDate = createdDate
            self.description = description
            self.layerArn = layerArn
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case content = "Content"
            case createdDate = "CreatedDate"
            case description = "Description"
            case layerArn = "LayerArn"
            case layerVersionArn = "LayerVersionArn"
            case licenseInfo = "LicenseInfo"
            case version = "Version"
        }
    }

    public struct PublishVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of UpdateFunctionCode.
        public let codeSha256: String?
        /// A description for the version to override the description in the function configuration.
        public let description: String?
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.
        public let revisionId: String?

        public init(codeSha256: String? = nil, description: String? = nil, functionName: String, revisionId: String? = nil) {
            self.codeSha256 = codeSha256
            self.description = description
            self.functionName = functionName
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: String, CodingKey {
            case codeSha256 = "CodeSha256"
            case description = "Description"
            case revisionId = "RevisionId"
        }
    }

    public struct PutFunctionCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(codeSigningConfigArn: String, functionName: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigArn = "CodeSigningConfigArn"
        }
    }

    public struct PutFunctionCodeSigningConfigResponse: AWSDecodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        public init(codeSigningConfigArn: String, functionName: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.functionName = functionName
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case functionName = "FunctionName"
        }
    }

    public struct PutFunctionConcurrencyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The number of simultaneous executions to reserve for the function.
        public let reservedConcurrentExecutions: Int

        public init(functionName: String, reservedConcurrentExecutions: Int) {
            self.functionName = functionName
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.reservedConcurrentExecutions, name: "reservedConcurrentExecutions", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
        }
    }

    public struct PutFunctionEventInvokeConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// A destination for events after they have been sent to a function for processing.  Destinations     Function - The Amazon Resource Name (ARN) of a Lambda function.    Queue - The ARN of an SQS queue.    Topic - The ARN of an SNS topic.    Event Bus - The ARN of an Amazon EventBridge event bus.
        public let destinationConfig: DestinationConfig?
        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The maximum age of a request that Lambda sends to a function for processing.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of times to retry when the function returns an error.
        public let maximumRetryAttempts: Int?
        /// A version number or alias name.
        public let qualifier: String?

        public init(destinationConfig: DestinationConfig? = nil, functionName: String, maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, qualifier: String? = nil) {
            self.destinationConfig = destinationConfig
            self.functionName = functionName
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, max: 21600)
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, min: 60)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 2)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: 0)
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfig = "DestinationConfig"
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct PutProvisionedConcurrencyConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The amount of provisioned concurrency to allocate for the version or alias.
        public let provisionedConcurrentExecutions: Int
        /// The version number or alias name.
        public let qualifier: String

        public init(functionName: String, provisionedConcurrentExecutions: Int, qualifier: String) {
            self.functionName = functionName
            self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.provisionedConcurrentExecutions, name: "provisionedConcurrentExecutions", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
        }
    }

    public struct PutProvisionedConcurrencyConfigResponse: AWSDecodableShape {
        /// The amount of provisioned concurrency allocated.
        public let allocatedProvisionedConcurrentExecutions: Int?
        /// The amount of provisioned concurrency available.
        public let availableProvisionedConcurrentExecutions: Int?
        /// The date and time that a user last updated the configuration, in ISO 8601 format.
        public let lastModified: String?
        /// The amount of provisioned concurrency requested.
        public let requestedProvisionedConcurrentExecutions: Int?
        /// The status of the allocation process.
        public let status: ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public let statusReason: String?

        public init(allocatedProvisionedConcurrentExecutions: Int? = nil, availableProvisionedConcurrentExecutions: Int? = nil, lastModified: String? = nil, requestedProvisionedConcurrentExecutions: Int? = nil, status: ProvisionedConcurrencyStatusEnum? = nil, statusReason: String? = nil) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
            case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
            case lastModified = "LastModified"
            case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct RemoveLayerVersionPermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "layerName", location: .uri(locationName: "LayerName")),
            AWSMemberEncoding(label: "revisionId", location: .querystring(locationName: "RevisionId")),
            AWSMemberEncoding(label: "statementId", location: .uri(locationName: "StatementId")),
            AWSMemberEncoding(label: "versionNumber", location: .uri(locationName: "VersionNumber"))
        ]

        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// The identifier that was specified when the statement was added.
        public let statementId: String
        /// The version number.
        public let versionNumber: Int64

        public init(layerName: String, revisionId: String? = nil, statementId: String, versionNumber: Int64) {
            self.layerName = layerName
            self.revisionId = revisionId
            self.statementId = statementId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "([a-zA-Z0-9-_]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemovePermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier")),
            AWSMemberEncoding(label: "revisionId", location: .querystring(locationName: "RevisionId")),
            AWSMemberEncoding(label: "statementId", location: .uri(locationName: "StatementId"))
        ]

        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to remove permissions from a published version of the function.
        public let qualifier: String?
        /// Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// Statement ID of the permission to remove.
        public let statementId: String

        public init(functionName: String, qualifier: String? = nil, revisionId: String? = nil, statementId: String) {
            self.functionName = functionName
            self.qualifier = qualifier
            self.revisionId = revisionId
            self.statementId = statementId
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "([a-zA-Z0-9-_.]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SelfManagedEventSource: AWSEncodableShape & AWSDecodableShape {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public let endpoints: [EndPointType: [String]]?

        public init(endpoints: [EndPointType: [String]]? = nil) {
            self.endpoints = endpoints
        }

        public func validate(name: String) throws {
            try self.endpoints?.forEach {
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, max: 10)
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct SourceAccessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of authentication protocol or the VPC components for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".    BASIC_AUTH - (MQ) The Secrets Manager secret that stores your broker credentials.    VPC_SUBNET - The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your Self-Managed Apache Kafka cluster.    VPC_SECURITY_GROUP - The VPC security group used to manage access to your Self-Managed Apache Kafka brokers.    SASL_SCRAM_256_AUTH - The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your Self-Managed Apache Kafka brokers.    SASL_SCRAM_512_AUTH - The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your Self-Managed Apache Kafka brokers.    VIRTUAL_HOST - The name of the virtual host in your RabbitMQ broker. Lambda will use this host as the event source.
        public let type: SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public let uri: String?

        public init(type: SourceAccessType? = nil, uri: String? = nil) {
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 200)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "[a-zA-Z0-9-\\/*:_+=.@-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case uri = "URI"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resource", location: .uri(locationName: "ARN"))
        ]

        /// The function's Amazon Resource Name (ARN).
        public let resource: String
        /// A list of tags to apply to the function.
        public let tags: [String: String]

        public init(resource: String, tags: [String: String]) {
            self.resource = resource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TracingConfig: AWSEncodableShape {
        /// The tracing mode.
        public let mode: TracingMode?

        public init(mode: TracingMode? = nil) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct TracingConfigResponse: AWSDecodableShape {
        /// The tracing mode.
        public let mode: TracingMode?

        public init(mode: TracingMode? = nil) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resource", location: .uri(locationName: "ARN")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The function's Amazon Resource Name (ARN).
        public let resource: String
        /// A list of tag keys to remove from the function.
        public let tagKeys: [String]

        public init(resource: String, tagKeys: [String]) {
            self.resource = resource
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "Name"))
        ]

        /// A description of the alias.
        public let description: String?
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The function version that the alias invokes.
        public let functionVersion: String?
        /// The name of the alias.
        public let name: String
        /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.
        public let revisionId: String?
        /// The routing configuration of the alias.
        public let routingConfig: AliasRoutingConfiguration?

        public init(description: String? = nil, functionName: String, functionVersion: String? = nil, name: String, revisionId: String? = nil, routingConfig: AliasRoutingConfiguration? = nil) {
            self.description = description
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, max: 1024)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, min: 1)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, pattern: "(\\$LATEST|[0-9]+)")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "(?!^[0-9]+$)([a-zA-Z0-9-_]+)")
            try self.routingConfig?.validate(name: "\(name).routingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case functionVersion = "FunctionVersion"
            case revisionId = "RevisionId"
            case routingConfig = "RoutingConfig"
        }
    }

    public struct UpdateCodeSigningConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "codeSigningConfigArn", location: .uri(locationName: "CodeSigningConfigArn"))
        ]

        /// Signing profiles for this code signing configuration.
        public let allowedPublishers: AllowedPublishers?
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The code signing policy.
        public let codeSigningPolicies: CodeSigningPolicies?
        /// Descriptive name for this code signing configuration.
        public let description: String?

        public init(allowedPublishers: AllowedPublishers? = nil, codeSigningConfigArn: String, codeSigningPolicies: CodeSigningPolicies? = nil, description: String? = nil) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
        }

        public func validate(name: String) throws {
            try self.allowedPublishers?.validate(name: "\(name).allowedPublishers")
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPublishers = "AllowedPublishers"
            case codeSigningPolicies = "CodeSigningPolicies"
            case description = "Description"
        }
    }

    public struct UpdateCodeSigningConfigResponse: AWSDecodableShape {
        /// The code signing configuration
        public let codeSigningConfig: CodeSigningConfig

        public init(codeSigningConfig: CodeSigningConfig) {
            self.codeSigningConfig = codeSigningConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfig = "CodeSigningConfig"
        }
    }

    public struct UpdateEventSourceMappingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "uuid", location: .uri(locationName: "UUID"))
        ]

        /// The maximum number of items to retrieve in a single batch.    Amazon Kinesis - Default 100. Max 10,000.    Amazon DynamoDB Streams - Default 100. Max 1,000.    Amazon Simple Queue Service - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.    Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.    Self-Managed Apache Kafka - Default 100. Max 10,000.
        public let batchSize: Int?
        /// (Streams only) If the function returns an error, split the batch in two and retry.
        public let bisectBatchOnFunctionError: Bool?
        /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        public let destinationConfig: DestinationConfig?
        /// If true, the event source mapping is active. Set to false to pause polling and invocation.
        public let enabled: Bool?
        /// The name of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
        public let functionName: String?
        /// (Streams only) A list of current response type enums applied to the event source mapping.
        public let functionResponseTypes: [FunctionResponseType]?
        /// (Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.
        public let maximumBatchingWindowInSeconds: Int?
        /// (Streams only) Discard records older than the specified age. The default value is infinite (-1).
        public let maximumRecordAgeInSeconds: Int?
        /// (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
        public let maximumRetryAttempts: Int?
        /// (Streams only) The number of batches to process from each shard concurrently.
        public let parallelizationFactor: Int?
        /// An array of the authentication protocol, or the VPC components to secure your event source.
        public let sourceAccessConfigurations: [SourceAccessConfiguration]?
        /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
        public let tumblingWindowInSeconds: Int?
        /// The identifier of the event source mapping.
        public let uuid: String

        public init(batchSize: Int? = nil, bisectBatchOnFunctionError: Bool? = nil, destinationConfig: DestinationConfig? = nil, enabled: Bool? = nil, functionName: String? = nil, functionResponseTypes: [FunctionResponseType]? = nil, maximumBatchingWindowInSeconds: Int? = nil, maximumRecordAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, parallelizationFactor: Int? = nil, sourceAccessConfigurations: [SourceAccessConfiguration]? = nil, tumblingWindowInSeconds: Int? = nil, uuid: String) {
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.enabled = enabled
            self.functionName = functionName
            self.functionResponseTypes = functionResponseTypes
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }

        public func validate(name: String) throws {
            try self.validate(self.batchSize, name: "batchSize", parent: name, max: 10000)
            try self.validate(self.batchSize, name: "batchSize", parent: name, min: 1)
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.functionResponseTypes, name: "functionResponseTypes", parent: name, max: 1)
            try self.validate(self.functionResponseTypes, name: "functionResponseTypes", parent: name, min: 0)
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, max: 300)
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, min: 0)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, max: 604_800)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, min: -1)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 10000)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: -1)
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, max: 10)
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, min: 1)
            try self.sourceAccessConfigurations?.forEach {
                try $0.validate(name: "\(name).sourceAccessConfigurations[]")
            }
            try self.validate(self.sourceAccessConfigurations, name: "sourceAccessConfigurations", parent: name, max: 22)
            try self.validate(self.sourceAccessConfigurations, name: "sourceAccessConfigurations", parent: name, min: 0)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, max: 900)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
            case destinationConfig = "DestinationConfig"
            case enabled = "Enabled"
            case functionName = "FunctionName"
            case functionResponseTypes = "FunctionResponseTypes"
            case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
            case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
            case parallelizationFactor = "ParallelizationFactor"
            case sourceAccessConfigurations = "SourceAccessConfigurations"
            case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        }
    }

    public struct UpdateFunctionCodeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// Set to true to validate the request parameters and access permissions without modifying the function code.
        public let dryRun: Bool?
        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// URI of a container image in the Amazon ECR registry.
        public let imageUri: String?
        /// Set to true to publish a new version of the function after updating the code. This has the same effect as calling PublishVersion separately.
        public let publish: Bool?
        /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
        public let revisionId: String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public let zipFile: Data?

        public init(dryRun: Bool? = nil, functionName: String, imageUri: String? = nil, publish: Bool? = nil, revisionId: String? = nil, s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: Data? = nil) {
            self.dryRun = dryRun
            self.functionName = functionName
            self.imageUri = imageUri
            self.publish = publish
            self.revisionId = revisionId
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*(?<!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1024)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dryRun = "DryRun"
            case imageUri = "ImageUri"
            case publish = "Publish"
            case revisionId = "RevisionId"
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct UpdateFunctionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName"))
        ]

        /// A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues.
        public let deadLetterConfig: DeadLetterConfig?
        /// A description of the function.
        public let description: String?
        /// Environment variables that are accessible from function code during execution.
        public let environment: Environment?
        /// Connection settings for an Amazon EFS file system.
        public let fileSystemConfigs: [FileSystemConfig]?
        /// The name of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Programming Model.
        public let handler: String?
        ///  Container image configuration values that override the values in the container image Dockerfile.
        public let imageConfig: ImageConfig?
        /// The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment variables. If it's not provided, Lambda uses a default service key.
        public let kMSKeyArn: String?
        /// A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.
        public let layers: [String]?
        /// The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
        public let memorySize: Int?
        /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
        public let revisionId: String?
        /// The Amazon Resource Name (ARN) of the function's execution role.
        public let role: String?
        /// The identifier of the function's runtime.
        public let runtime: Runtime?
        /// The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For additional information, see Lambda execution environment.
        public let timeout: Int?
        /// Set Mode to Active to sample and trace a subset of incoming requests with X-Ray.
        public let tracingConfig: TracingConfig?
        /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings.
        public let vpcConfig: VpcConfig?

        public init(deadLetterConfig: DeadLetterConfig? = nil, description: String? = nil, environment: Environment? = nil, fileSystemConfigs: [FileSystemConfig]? = nil, functionName: String, handler: String? = nil, imageConfig: ImageConfig? = nil, kMSKeyArn: String? = nil, layers: [String]? = nil, memorySize: Int? = nil, revisionId: String? = nil, role: String? = nil, runtime: Runtime? = nil, timeout: Int? = nil, tracingConfig: TracingConfig? = nil, vpcConfig: VpcConfig? = nil) {
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.fileSystemConfigs = fileSystemConfigs
            self.functionName = functionName
            self.handler = handler
            self.imageConfig = imageConfig
            self.kMSKeyArn = kMSKeyArn
            self.layers = layers
            self.memorySize = memorySize
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.environment?.validate(name: "\(name).environment")
            try self.fileSystemConfigs?.forEach {
                try $0.validate(name: "\(name).fileSystemConfigs[]")
            }
            try self.validate(self.fileSystemConfigs, name: "fileSystemConfigs", parent: name, max: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.handler, name: "handler", parent: name, max: 128)
            try self.validate(self.handler, name: "handler", parent: name, pattern: "[^\\s]+")
            try self.imageConfig?.validate(name: "\(name).imageConfig")
            try self.validate(self.kMSKeyArn, name: "kMSKeyArn", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()")
            try self.layers?.forEach {
                try validate($0, name: "layers[]", parent: name, max: 140)
                try validate($0, name: "layers[]", parent: name, min: 1)
                try validate($0, name: "layers[]", parent: name, pattern: "arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+")
            }
            try self.validate(self.memorySize, name: "memorySize", parent: name, max: 10240)
            try self.validate(self.memorySize, name: "memorySize", parent: name, min: 128)
            try self.validate(self.role, name: "role", parent: name, pattern: "arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterConfig = "DeadLetterConfig"
            case description = "Description"
            case environment = "Environment"
            case fileSystemConfigs = "FileSystemConfigs"
            case handler = "Handler"
            case imageConfig = "ImageConfig"
            case kMSKeyArn = "KMSKeyArn"
            case layers = "Layers"
            case memorySize = "MemorySize"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct UpdateFunctionEventInvokeConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionName", location: .uri(locationName: "FunctionName")),
            AWSMemberEncoding(label: "qualifier", location: .querystring(locationName: "Qualifier"))
        ]

        /// A destination for events after they have been sent to a function for processing.  Destinations     Function - The Amazon Resource Name (ARN) of a Lambda function.    Queue - The ARN of an SQS queue.    Topic - The ARN of an SNS topic.    Event Bus - The ARN of an Amazon EventBridge event bus.
        public let destinationConfig: DestinationConfig?
        /// The name of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The maximum age of a request that Lambda sends to a function for processing.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of times to retry when the function returns an error.
        public let maximumRetryAttempts: Int?
        /// A version number or alias name.
        public let qualifier: String?

        public init(destinationConfig: DestinationConfig? = nil, functionName: String, maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, qualifier: String? = nil) {
            self.destinationConfig = destinationConfig
            self.functionName = functionName
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.qualifier = qualifier
        }

        public func validate(name: String) throws {
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, max: 21600)
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, min: 60)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 2)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: 0)
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "(|[a-zA-Z0-9$_-]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfig = "DestinationConfig"
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct VpcConfig: AWSEncodableShape {
        /// A list of VPC security groups IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct VpcConfigResponse: AWSDecodableShape {
        /// A list of VPC security groups IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VpcId"
        }
    }
}
