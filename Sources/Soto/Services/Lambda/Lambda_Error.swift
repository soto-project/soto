//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

/// Error enum for Lambda
public struct LambdaErrorType: AWSErrorType {
    enum Code: String {
        case codeSigningConfigNotFoundException = "CodeSigningConfigNotFoundException"
        case codeStorageExceededException = "CodeStorageExceededException"
        case codeVerificationFailedException = "CodeVerificationFailedException"
        case ec2AccessDeniedException = "EC2AccessDeniedException"
        case ec2ThrottledException = "EC2ThrottledException"
        case ec2UnexpectedException = "EC2UnexpectedException"
        case efsMountConnectivityException = "EFSMountConnectivityException"
        case efsMountFailureException = "EFSMountFailureException"
        case efsMountTimeoutException = "EFSMountTimeoutException"
        case efsioException = "EFSIOException"
        case eniLimitReachedException = "ENILimitReachedException"
        case invalidCodeSignatureException = "InvalidCodeSignatureException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestContentException = "InvalidRequestContentException"
        case invalidRuntimeException = "InvalidRuntimeException"
        case invalidSecurityGroupIDException = "InvalidSecurityGroupIDException"
        case invalidSubnetIDException = "InvalidSubnetIDException"
        case invalidZipFileException = "InvalidZipFileException"
        case kmsAccessDeniedException = "KMSAccessDeniedException"
        case kmsDisabledException = "KMSDisabledException"
        case kmsInvalidStateException = "KMSInvalidStateException"
        case kmsNotFoundException = "KMSNotFoundException"
        case policyLengthExceededException = "PolicyLengthExceededException"
        case preconditionFailedException = "PreconditionFailedException"
        case provisionedConcurrencyConfigNotFoundException = "ProvisionedConcurrencyConfigNotFoundException"
        case requestTooLargeException = "RequestTooLargeException"
        case resourceConflictException = "ResourceConflictException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceNotReadyException = "ResourceNotReadyException"
        case serviceException = "ServiceException"
        case subnetIPAddressLimitReachedException = "SubnetIPAddressLimitReachedException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unsupportedMediaTypeException = "UnsupportedMediaTypeException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Lambda
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified code signing configuration does not exist.
    public static var codeSigningConfigNotFoundException: Self { .init(.codeSigningConfigNotFoundException) }
    /// You have exceeded your maximum total code size per account. Learn more
    public static var codeStorageExceededException: Self { .init(.codeStorageExceededException) }
    /// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.
    public static var codeVerificationFailedException: Self { .init(.codeVerificationFailedException) }
    /// Need additional permissions to configure VPC settings.
    public static var ec2AccessDeniedException: Self { .init(.ec2AccessDeniedException) }
    /// Lambda was throttled by Amazon EC2 during Lambda function initialization using the execution role provided for the Lambda function.
    public static var ec2ThrottledException: Self { .init(.ec2ThrottledException) }
    /// Lambda received an unexpected EC2 client exception while setting up for the Lambda function.
    public static var ec2UnexpectedException: Self { .init(.ec2UnexpectedException) }
    /// The function couldn't make a network connection to the configured file system.
    public static var efsMountConnectivityException: Self { .init(.efsMountConnectivityException) }
    /// The function couldn't mount the configured file system due to a permission or configuration issue.
    public static var efsMountFailureException: Self { .init(.efsMountFailureException) }
    /// The function was able to make a network connection to the configured file system, but the mount operation timed out.
    public static var efsMountTimeoutException: Self { .init(.efsMountTimeoutException) }
    /// An error occurred when reading from or writing to a connected file system.
    public static var efsioException: Self { .init(.efsioException) }
    /// Lambda was not able to create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached.
    public static var eniLimitReachedException: Self { .init(.eniLimitReachedException) }
    /// The code signature failed the integrity check. Lambda always blocks deployment if the integrity check fails, even if code signing policy is set to WARN.
    public static var invalidCodeSignatureException: Self { .init(.invalidCodeSignatureException) }
    /// One of the parameters in the request is invalid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// The request body could not be parsed as JSON.
    public static var invalidRequestContentException: Self { .init(.invalidRequestContentException) }
    /// The runtime or runtime version specified is not supported.
    public static var invalidRuntimeException: Self { .init(.invalidRuntimeException) }
    /// The Security Group ID provided in the Lambda function VPC configuration is invalid.
    public static var invalidSecurityGroupIDException: Self { .init(.invalidSecurityGroupIDException) }
    /// The Subnet ID provided in the Lambda function VPC configuration is invalid.
    public static var invalidSubnetIDException: Self { .init(.invalidSubnetIDException) }
    /// Lambda could not unzip the deployment package.
    public static var invalidZipFileException: Self { .init(.invalidZipFileException) }
    /// Lambda was unable to decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.
    public static var kmsAccessDeniedException: Self { .init(.kmsAccessDeniedException) }
    /// Lambda was unable to decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.
    public static var kmsDisabledException: Self { .init(.kmsDisabledException) }
    /// Lambda was unable to decrypt the environment variables because the KMS key used is in an invalid state for Decrypt. Check the function's KMS key settings.
    public static var kmsInvalidStateException: Self { .init(.kmsInvalidStateException) }
    /// Lambda was unable to decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.
    public static var kmsNotFoundException: Self { .init(.kmsNotFoundException) }
    /// The permissions policy for the resource is too large. Learn more
    public static var policyLengthExceededException: Self { .init(.policyLengthExceededException) }
    /// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the GetFunction or the GetAlias API to retrieve the latest RevisionId for your resource.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The specified configuration does not exist.
    public static var provisionedConcurrencyConfigNotFoundException: Self { .init(.provisionedConcurrencyConfigNotFoundException) }
    /// The request payload exceeded the Invoke request body JSON input limit. For more information, see Limits.
    public static var requestTooLargeException: Self { .init(.requestTooLargeException) }
    /// The resource already exists, or another operation is in progress.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    /// The operation conflicts with the resource's availability. For example, you attempted to update an EventSource Mapping in CREATING, or tried to delete a EventSource mapping currently in the UPDATING state.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The resource specified in the request does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.
    public static var resourceNotReadyException: Self { .init(.resourceNotReadyException) }
    /// The Lambda service encountered an internal error.
    public static var serviceException: Self { .init(.serviceException) }
    /// Lambda was not able to set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.
    public static var subnetIPAddressLimitReachedException: Self { .init(.subnetIPAddressLimitReachedException) }
    /// The request throughput limit was exceeded.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The content type of the Invoke request body is not JSON.
    public static var unsupportedMediaTypeException: Self { .init(.unsupportedMediaTypeException) }
}

extension LambdaErrorType: Equatable {
    public static func == (lhs: LambdaErrorType, rhs: LambdaErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LambdaErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
