//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Lambda {
    // MARK: Enums

    public enum ApplicationLogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case error = "ERROR"
        case fatal = "FATAL"
        case info = "INFO"
        case trace = "TRACE"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum Architecture: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arm64 = "arm64"
        case x8664 = "x86_64"
        public var description: String { return self.rawValue }
    }

    public enum CodeSigningPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enforce = "Enforce"
        case warn = "Warn"
        public var description: String { return self.rawValue }
    }

    public enum EndPointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kafkaBootstrapServers = "KAFKA_BOOTSTRAP_SERVERS"
        public var description: String { return self.rawValue }
    }

    public enum EventSourceMappingMetric: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eventCount = "EventCount"
        public var description: String { return self.rawValue }
    }

    public enum EventSourcePosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case atTimestamp = "AT_TIMESTAMP"
        case latest = "LATEST"
        case trimHorizon = "TRIM_HORIZON"
        public var description: String { return self.rawValue }
    }

    public enum FullDocument: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "Default"
        case updateLookup = "UpdateLookup"
        public var description: String { return self.rawValue }
    }

    public enum FunctionResponseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case reportBatchItemFailures = "ReportBatchItemFailures"
        public var description: String { return self.rawValue }
    }

    public enum FunctionUrlAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum FunctionVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dryRun = "DryRun"
        case event = "Event"
        case requestResponse = "RequestResponse"
        public var description: String { return self.rawValue }
    }

    public enum InvokeMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case buffered = "BUFFERED"
        case responseStream = "RESPONSE_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum LastUpdateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum LastUpdateStatusReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "Creating"
        case disabledKMSKey = "DisabledKMSKey"
        case efsMountConnectivityError = "EFSMountConnectivityError"
        case efsMountFailure = "EFSMountFailure"
        case efsMountTimeout = "EFSMountTimeout"
        case efsioError = "EFSIOError"
        case eniLimitExceeded = "EniLimitExceeded"
        case functionError = "FunctionError"
        case imageAccessDenied = "ImageAccessDenied"
        case imageDeleted = "ImageDeleted"
        case insufficientRolePermissions = "InsufficientRolePermissions"
        case internalError = "InternalError"
        case invalidConfiguration = "InvalidConfiguration"
        case invalidImage = "InvalidImage"
        case invalidRuntime = "InvalidRuntime"
        case invalidSecurityGroup = "InvalidSecurityGroup"
        case invalidStateKMSKey = "InvalidStateKMSKey"
        case invalidSubnet = "InvalidSubnet"
        case invalidZipFileException = "InvalidZipFileException"
        case kmsKeyAccessDenied = "KMSKeyAccessDenied"
        case kmsKeyNotFound = "KMSKeyNotFound"
        case subnetOutOfIPAddresses = "SubnetOutOfIPAddresses"
        public var description: String { return self.rawValue }
    }

    public enum LogFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "None"
        case tail = "Tail"
        public var description: String { return self.rawValue }
    }

    public enum PackageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "Image"
        case zip = "Zip"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedConcurrencyStatusEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum RecursiveLoop: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "Allow"
        case terminate = "Terminate"
        public var description: String { return self.rawValue }
    }

    public enum ResponseStreamingInvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dryRun = "DryRun"
        case requestResponse = "RequestResponse"
        public var description: String { return self.rawValue }
    }

    public enum Runtime: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dotnet6 = "dotnet6"
        case dotnet8 = "dotnet8"
        case dotnetcore10 = "dotnetcore1.0"
        case dotnetcore20 = "dotnetcore2.0"
        case dotnetcore21 = "dotnetcore2.1"
        case dotnetcore31 = "dotnetcore3.1"
        case go1x = "go1.x"
        case java11 = "java11"
        case java17 = "java17"
        case java21 = "java21"
        case java8 = "java8"
        case java8al2 = "java8.al2"
        case nodejs = "nodejs"
        case nodejs10x = "nodejs10.x"
        case nodejs12x = "nodejs12.x"
        case nodejs14x = "nodejs14.x"
        case nodejs16x = "nodejs16.x"
        case nodejs18x = "nodejs18.x"
        case nodejs20x = "nodejs20.x"
        case nodejs22x = "nodejs22.x"
        case nodejs43 = "nodejs4.3"
        case nodejs43edge = "nodejs4.3-edge"
        case nodejs610 = "nodejs6.10"
        case nodejs810 = "nodejs8.10"
        case provided = "provided"
        case providedal2 = "provided.al2"
        case providedal2023 = "provided.al2023"
        case python27 = "python2.7"
        case python310 = "python3.10"
        case python311 = "python3.11"
        case python312 = "python3.12"
        case python313 = "python3.13"
        case python36 = "python3.6"
        case python37 = "python3.7"
        case python38 = "python3.8"
        case python39 = "python3.9"
        case ruby25 = "ruby2.5"
        case ruby27 = "ruby2.7"
        case ruby32 = "ruby3.2"
        case ruby33 = "ruby3.3"
        case ruby34 = "ruby3.4"
        public var description: String { return self.rawValue }
    }

    public enum SnapStartApplyOn: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "None"
        case publishedVersions = "PublishedVersions"
        public var description: String { return self.rawValue }
    }

    public enum SnapStartOptimizationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "Off"
        case on = "On"
        public var description: String { return self.rawValue }
    }

    public enum SourceAccessType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basicAuth = "BASIC_AUTH"
        case clientCertificateTlsAuth = "CLIENT_CERTIFICATE_TLS_AUTH"
        case saslScram256Auth = "SASL_SCRAM_256_AUTH"
        case saslScram512Auth = "SASL_SCRAM_512_AUTH"
        case serverRootCaCertificate = "SERVER_ROOT_CA_CERTIFICATE"
        case virtualHost = "VIRTUAL_HOST"
        case vpcSecurityGroup = "VPC_SECURITY_GROUP"
        case vpcSubnet = "VPC_SUBNET"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case failed = "Failed"
        case inactive = "Inactive"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum StateReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "Creating"
        case disabledKMSKey = "DisabledKMSKey"
        case efsMountConnectivityError = "EFSMountConnectivityError"
        case efsMountFailure = "EFSMountFailure"
        case efsMountTimeout = "EFSMountTimeout"
        case efsioError = "EFSIOError"
        case eniLimitExceeded = "EniLimitExceeded"
        case functionError = "FunctionError"
        case idle = "Idle"
        case imageAccessDenied = "ImageAccessDenied"
        case imageDeleted = "ImageDeleted"
        case insufficientRolePermissions = "InsufficientRolePermissions"
        case internalError = "InternalError"
        case invalidConfiguration = "InvalidConfiguration"
        case invalidImage = "InvalidImage"
        case invalidRuntime = "InvalidRuntime"
        case invalidSecurityGroup = "InvalidSecurityGroup"
        case invalidStateKMSKey = "InvalidStateKMSKey"
        case invalidSubnet = "InvalidSubnet"
        case invalidZipFileException = "InvalidZipFileException"
        case kmsKeyAccessDenied = "KMSKeyAccessDenied"
        case kmsKeyNotFound = "KMSKeyNotFound"
        case restoring = "Restoring"
        case subnetOutOfIPAddresses = "SubnetOutOfIPAddresses"
        public var description: String { return self.rawValue }
    }

    public enum SystemLogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum ThrottleReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case callerRateLimitExceeded = "CallerRateLimitExceeded"
        case concurrentInvocationLimitExceeded = "ConcurrentInvocationLimitExceeded"
        case concurrentSnapshotCreateLimitExceeded = "ConcurrentSnapshotCreateLimitExceeded"
        case functionInvocationRateLimitExceeded = "FunctionInvocationRateLimitExceeded"
        case reservedFunctionConcurrentInvocationLimitExceeded = "ReservedFunctionConcurrentInvocationLimitExceeded"
        case reservedFunctionInvocationRateLimitExceeded = "ReservedFunctionInvocationRateLimitExceeded"
        public var description: String { return self.rawValue }
    }

    public enum TracingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case passThrough = "PassThrough"
        public var description: String { return self.rawValue }
    }

    public enum UpdateRuntimeOn: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "Auto"
        case functionUpdate = "FunctionUpdate"
        case manual = "Manual"
        public var description: String { return self.rawValue }
    }

    public enum InvokeWithResponseStreamResponseEvent: AWSDecodableShape, Sendable {
        /// An object that's returned when the stream has ended and all the payload chunks have been returned.
        case invokeComplete(InvokeWithResponseStreamCompleteEvent)
        /// A chunk of the streamed response payload.
        case payloadChunk(InvokeResponseStreamUpdate)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .invokeComplete:
                let value = try container.decode(InvokeWithResponseStreamCompleteEvent.self, forKey: .invokeComplete)
                self = .invokeComplete(value)
            case .payloadChunk:
                let value = try container.decode(InvokeResponseStreamUpdate.self, forKey: .payloadChunk)
                self = .payloadChunk(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invokeComplete = "InvokeComplete"
            case payloadChunk = "PayloadChunk"
        }
    }

    // MARK: Shapes

    public struct AccountLimit: AWSDecodableShape {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public let codeSizeUnzipped: Int64?
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.
        public let codeSizeZipped: Int64?
        /// The maximum number of simultaneous function executions.
        public let concurrentExecutions: Int?
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public let totalCodeSize: Int64?
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with PutFunctionConcurrency.
        public let unreservedConcurrentExecutions: Int?

        @inlinable
        public init(codeSizeUnzipped: Int64? = nil, codeSizeZipped: Int64? = nil, concurrentExecutions: Int? = nil, totalCodeSize: Int64? = nil, unreservedConcurrentExecutions: Int? = nil) {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case codeSizeUnzipped = "CodeSizeUnzipped"
            case codeSizeZipped = "CodeSizeZipped"
            case concurrentExecutions = "ConcurrentExecutions"
            case totalCodeSize = "TotalCodeSize"
            case unreservedConcurrentExecutions = "UnreservedConcurrentExecutions"
        }
    }

    public struct AccountUsage: AWSDecodableShape {
        /// The number of Lambda functions.
        public let functionCount: Int64?
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public let totalCodeSize: Int64?

        @inlinable
        public init(functionCount: Int64? = nil, totalCodeSize: Int64? = nil) {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }

        private enum CodingKeys: String, CodingKey {
            case functionCount = "FunctionCount"
            case totalCodeSize = "TotalCodeSize"
        }
    }

    public struct AddLayerVersionPermissionRequest: AWSEncodableShape {
        /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
        public let action: String
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// With the principal set to *, grant permission to all accounts in the specified organization.
        public let organizationId: String?
        /// An account ID, or * to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
        public let principal: String
        /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// An identifier that distinguishes the policy from others on the same layer version.
        public let statementId: String
        /// The version number.
        public let versionNumber: Int64

        @inlinable
        public init(action: String, layerName: String, organizationId: String? = nil, principal: String, revisionId: String? = nil, statementId: String, versionNumber: Int64) {
            self.action = action
            self.layerName = layerName
            self.organizationId = organizationId
            self.principal = principal
            self.revisionId = revisionId
            self.statementId = statementId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            request.encodePath(self.layerName, key: "LayerName")
            try container.encodeIfPresent(self.organizationId, forKey: .organizationId)
            try container.encode(self.principal, forKey: .principal)
            request.encodeQuery(self.revisionId, key: "RevisionId")
            try container.encode(self.statementId, forKey: .statementId)
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, max: 22)
            try self.validate(self.action, name: "action", parent: name, pattern: "^lambda:GetLayerVersion$")
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^o-[a-z0-9]{10,32}$")
            try self.validate(self.principal, name: "principal", parent: name, pattern: "^\\d{12}|\\*|arn:(aws[a-zA-Z-]*):iam::\\d{12}:root$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case organizationId = "OrganizationId"
            case principal = "Principal"
            case statementId = "StatementId"
        }
    }

    public struct AddLayerVersionPermissionResponse: AWSDecodableShape {
        /// A unique identifier for the current revision of the policy.
        public let revisionId: String?
        /// The permission statement.
        public let statement: String?

        @inlinable
        public init(revisionId: String? = nil, statement: String? = nil) {
            self.revisionId = revisionId
            self.statement = statement
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId = "RevisionId"
            case statement = "Statement"
        }
    }

    public struct AddPermissionRequest: AWSEncodableShape {
        /// The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
        public let action: String
        /// For Alexa Smart Home functions, a token that the invoker must supply.
        public let eventSourceToken: String?
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name – my-function (name-only), my-function:v1 (with alias).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let functionUrlAuthType: FunctionUrlAuthType?
        /// The Amazon Web Services service, Amazon Web Services account, IAM user, or IAM role that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
        public let principal: String
        /// The identifier for your organization in Organizations. Use this to grant permissions to all the Amazon Web Services accounts under this organization.
        public let principalOrgID: String?
        /// Specify a version or alias to add permissions to a published version of the function.
        public let qualifier: String?
        /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// For Amazon Web Services service, the ID of the Amazon Web Services account that owns the resource. Use this together with SourceArn to ensure that the specified account owns the resource. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
        public let sourceAccount: String?
        /// For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic. Note that Lambda configures the comparison using the StringLike operator.
        public let sourceArn: String?
        /// A statement identifier that differentiates the statement from others in the same policy.
        public let statementId: String

        @inlinable
        public init(action: String, eventSourceToken: String? = nil, functionName: String, functionUrlAuthType: FunctionUrlAuthType? = nil, principal: String, principalOrgID: String? = nil, qualifier: String? = nil, revisionId: String? = nil, sourceAccount: String? = nil, sourceArn: String? = nil, statementId: String) {
            self.action = action
            self.eventSourceToken = eventSourceToken
            self.functionName = functionName
            self.functionUrlAuthType = functionUrlAuthType
            self.principal = principal
            self.principalOrgID = principalOrgID
            self.qualifier = qualifier
            self.revisionId = revisionId
            self.sourceAccount = sourceAccount
            self.sourceArn = sourceArn
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.eventSourceToken, forKey: .eventSourceToken)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.functionUrlAuthType, forKey: .functionUrlAuthType)
            try container.encode(self.principal, forKey: .principal)
            try container.encodeIfPresent(self.principalOrgID, forKey: .principalOrgID)
            request.encodeQuery(self.qualifier, key: "Qualifier")
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.sourceAccount, forKey: .sourceAccount)
            try container.encodeIfPresent(self.sourceArn, forKey: .sourceArn)
            try container.encode(self.statementId, forKey: .statementId)
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, pattern: "^(lambda:[*]|lambda:[a-zA-Z]+|[*])$")
            try self.validate(self.eventSourceToken, name: "eventSourceToken", parent: name, max: 256)
            try self.validate(self.eventSourceToken, name: "eventSourceToken", parent: name, pattern: "^[a-zA-Z0-9._\\-]+$")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.principal, name: "principal", parent: name, pattern: "^[^\\s]+$")
            try self.validate(self.principalOrgID, name: "principalOrgID", parent: name, max: 34)
            try self.validate(self.principalOrgID, name: "principalOrgID", parent: name, min: 12)
            try self.validate(self.principalOrgID, name: "principalOrgID", parent: name, pattern: "^o-[a-z0-9]{10,32}$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
            try self.validate(self.sourceAccount, name: "sourceAccount", parent: name, max: 12)
            try self.validate(self.sourceAccount, name: "sourceAccount", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case eventSourceToken = "EventSourceToken"
            case functionUrlAuthType = "FunctionUrlAuthType"
            case principal = "Principal"
            case principalOrgID = "PrincipalOrgID"
            case revisionId = "RevisionId"
            case sourceAccount = "SourceAccount"
            case sourceArn = "SourceArn"
            case statementId = "StatementId"
        }
    }

    public struct AddPermissionResponse: AWSDecodableShape {
        /// The permission statement that's added to the function policy.
        public let statement: String?

        @inlinable
        public init(statement: String? = nil) {
            self.statement = statement
        }

        private enum CodingKeys: String, CodingKey {
            case statement = "Statement"
        }
    }

    public struct AliasConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the alias.
        public let aliasArn: String?
        /// A description of the alias.
        public let description: String?
        /// The function version that the alias invokes.
        public let functionVersion: String?
        /// The name of the alias.
        public let name: String?
        /// A unique identifier that changes when you update the alias.
        public let revisionId: String?
        /// The routing configuration of the alias.
        public let routingConfig: AliasRoutingConfiguration?

        @inlinable
        public init(aliasArn: String? = nil, description: String? = nil, functionVersion: String? = nil, name: String? = nil, revisionId: String? = nil, routingConfig: AliasRoutingConfiguration? = nil) {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aliasArn = "AliasArn"
            case description = "Description"
            case functionVersion = "FunctionVersion"
            case name = "Name"
            case revisionId = "RevisionId"
            case routingConfig = "RoutingConfig"
        }
    }

    public struct AliasRoutingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The second version, and the percentage of traffic that's routed to it.
        public let additionalVersionWeights: [String: Double]?

        @inlinable
        public init(additionalVersionWeights: [String: Double]? = nil) {
            self.additionalVersionWeights = additionalVersionWeights
        }

        public func validate(name: String) throws {
            try self.additionalVersionWeights?.forEach {
                try validate($0.key, name: "additionalVersionWeights.key", parent: name, max: 1024)
                try validate($0.key, name: "additionalVersionWeights.key", parent: name, min: 1)
                try validate($0.key, name: "additionalVersionWeights.key", parent: name, pattern: "^[0-9]+$")
                try validate($0.value, name: "additionalVersionWeights[\"\($0.key)\"]", parent: name, max: 1.0)
                try validate($0.value, name: "additionalVersionWeights[\"\($0.key)\"]", parent: name, min: 0.0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalVersionWeights = "AdditionalVersionWeights"
        }
    }

    public struct AllowedPublishers: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        public let signingProfileVersionArns: [String]

        @inlinable
        public init(signingProfileVersionArns: [String]) {
            self.signingProfileVersionArns = signingProfileVersionArns
        }

        public func validate(name: String) throws {
            try self.signingProfileVersionArns.forEach {
                try validate($0, name: "signingProfileVersionArns[]", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)$")
            }
            try self.validate(self.signingProfileVersionArns, name: "signingProfileVersionArns", parent: name, max: 20)
            try self.validate(self.signingProfileVersionArns, name: "signingProfileVersionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case signingProfileVersionArns = "SigningProfileVersionArns"
        }
    }

    public struct AmazonManagedKafkaEventSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see Customizable consumer group ID.
        public let consumerGroupId: String?

        @inlinable
        public init(consumerGroupId: String? = nil) {
            self.consumerGroupId = consumerGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerGroupId, name: "consumerGroupId", parent: name, max: 200)
            try self.validate(self.consumerGroupId, name: "consumerGroupId", parent: name, min: 1)
            try self.validate(self.consumerGroupId, name: "consumerGroupId", parent: name, pattern: "^[a-zA-Z0-9-\\/*:_+=.@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupId = "ConsumerGroupId"
        }
    }

    public struct CodeSigningConfig: AWSDecodableShape {
        /// List of allowed publishers.
        public let allowedPublishers: AllowedPublishers
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        public let codeSigningConfigArn: String
        /// Unique identifer for the Code signing configuration.
        public let codeSigningConfigId: String
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        public let codeSigningPolicies: CodeSigningPolicies
        /// Code signing configuration description.
        public let description: String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModified: String

        @inlinable
        public init(allowedPublishers: AllowedPublishers, codeSigningConfigArn: String, codeSigningConfigId: String, codeSigningPolicies: CodeSigningPolicies, description: String? = nil, lastModified: String) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPublishers = "AllowedPublishers"
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case codeSigningConfigId = "CodeSigningConfigId"
            case codeSigningPolicies = "CodeSigningPolicies"
            case description = "Description"
            case lastModified = "LastModified"
        }
    }

    public struct CodeSigningConfigNotFoundException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct CodeSigningPolicies: AWSEncodableShape & AWSDecodableShape {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log.  Default value: Warn
        public let untrustedArtifactOnDeployment: CodeSigningPolicy?

        @inlinable
        public init(untrustedArtifactOnDeployment: CodeSigningPolicy? = nil) {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case untrustedArtifactOnDeployment = "UntrustedArtifactOnDeployment"
        }
    }

    public struct CodeStorageExceededException: AWSErrorShape {
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct CodeVerificationFailedException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct Concurrency: AWSDecodableShape {
        /// The number of concurrent executions that are reserved for this function. For more information, see Managing Lambda reserved concurrency.
        public let reservedConcurrentExecutions: Int?

        @inlinable
        public init(reservedConcurrentExecutions: Int? = nil) {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
        }
    }

    public struct Cors: AWSEncodableShape & AWSDecodableShape {
        /// Whether to allow cookies or other credentials in requests to your function URL. The default is false.
        public let allowCredentials: Bool?
        /// The HTTP headers that origins can include in requests to your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public let allowHeaders: [String]?
        /// The HTTP methods that are allowed when calling your function URL. For example: GET, POST, DELETE, or the wildcard character (*).
        public let allowMethods: [String]?
        /// The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: https://www.example.com, http://localhost:60905. Alternatively, you can grant access to all origins using the wildcard character (*).
        public let allowOrigins: [String]?
        /// The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public let exposeHeaders: [String]?
        /// The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to 0, which means that the browser doesn't cache results.
        public let maxAge: Int?

        @inlinable
        public init(allowCredentials: Bool? = nil, allowHeaders: [String]? = nil, allowMethods: [String]? = nil, allowOrigins: [String]? = nil, exposeHeaders: [String]? = nil, maxAge: Int? = nil) {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }

        public func validate(name: String) throws {
            try self.allowHeaders?.forEach {
                try validate($0, name: "allowHeaders[]", parent: name, max: 1024)
                try validate($0, name: "allowHeaders[]", parent: name, pattern: ".*")
            }
            try self.validate(self.allowHeaders, name: "allowHeaders", parent: name, max: 100)
            try self.allowMethods?.forEach {
                try validate($0, name: "allowMethods[]", parent: name, max: 6)
                try validate($0, name: "allowMethods[]", parent: name, pattern: ".*")
            }
            try self.validate(self.allowMethods, name: "allowMethods", parent: name, max: 6)
            try self.allowOrigins?.forEach {
                try validate($0, name: "allowOrigins[]", parent: name, max: 253)
                try validate($0, name: "allowOrigins[]", parent: name, min: 1)
                try validate($0, name: "allowOrigins[]", parent: name, pattern: ".*")
            }
            try self.validate(self.allowOrigins, name: "allowOrigins", parent: name, max: 100)
            try self.exposeHeaders?.forEach {
                try validate($0, name: "exposeHeaders[]", parent: name, max: 1024)
                try validate($0, name: "exposeHeaders[]", parent: name, pattern: ".*")
            }
            try self.validate(self.exposeHeaders, name: "exposeHeaders", parent: name, max: 100)
            try self.validate(self.maxAge, name: "maxAge", parent: name, max: 86400)
            try self.validate(self.maxAge, name: "maxAge", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case allowCredentials = "AllowCredentials"
            case allowHeaders = "AllowHeaders"
            case allowMethods = "AllowMethods"
            case allowOrigins = "AllowOrigins"
            case exposeHeaders = "ExposeHeaders"
            case maxAge = "MaxAge"
        }
    }

    public struct CreateAliasRequest: AWSEncodableShape {
        /// A description of the alias.
        public let description: String?
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The function version that the alias invokes.
        public let functionVersion: String
        /// The name of the alias.
        public let name: String
        /// The routing configuration of the alias.
        public let routingConfig: AliasRoutingConfiguration?

        @inlinable
        public init(description: String? = nil, functionName: String, functionVersion: String, name: String, routingConfig: AliasRoutingConfiguration? = nil) {
            self.description = description
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.name = name
            self.routingConfig = routingConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encode(self.functionVersion, forKey: .functionVersion)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.routingConfig, forKey: .routingConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, max: 1024)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, min: 1)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, pattern: "^(\\$LATEST|[0-9]+)$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_]+)$")
            try self.routingConfig?.validate(name: "\(name).routingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case functionVersion = "FunctionVersion"
            case name = "Name"
            case routingConfig = "RoutingConfig"
        }
    }

    public struct CreateCodeSigningConfigRequest: AWSEncodableShape {
        /// Signing profiles for this code signing configuration.
        public let allowedPublishers: AllowedPublishers
        /// The code signing policies define the actions to take if the validation checks fail.
        public let codeSigningPolicies: CodeSigningPolicies?
        /// Descriptive name for this code signing configuration.
        public let description: String?
        /// A list of tags to add to the code signing configuration.
        public let tags: [String: String]?

        @inlinable
        public init(allowedPublishers: AllowedPublishers, codeSigningPolicies: CodeSigningPolicies? = nil, description: String? = nil, tags: [String: String]? = nil) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedPublishers.validate(name: "\(name).allowedPublishers")
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPublishers = "AllowedPublishers"
            case codeSigningPolicies = "CodeSigningPolicies"
            case description = "Description"
            case tags = "Tags"
        }
    }

    public struct CreateCodeSigningConfigResponse: AWSDecodableShape {
        /// The code signing configuration.
        public let codeSigningConfig: CodeSigningConfig

        @inlinable
        public init(codeSigningConfig: CodeSigningConfig) {
            self.codeSigningConfig = codeSigningConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfig = "CodeSigningConfig"
        }
    }

    public struct CreateEventSourceMappingRequest: AWSEncodableShape {
        /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        public let amazonManagedKafkaEventSourceConfig: AmazonManagedKafkaEventSourceConfig?
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).    Amazon Kinesis – Default 100. Max 10,000.    Amazon DynamoDB Streams – Default 100. Max 10,000.    Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.    Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.    Self-managed Apache Kafka – Default 100. Max 10,000.    Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.    DocumentDB – Default 100. Max 10,000.
        public let batchSize: Int?
        /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.
        public let bisectBatchOnFunctionError: Bool?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Kafka only) A configuration object that specifies the destination of an event after Lambda processes it.
        public let destinationConfig: DestinationConfig?
        /// Specific configuration settings for a DocumentDB event source.
        public let documentDBEventSourceConfig: DocumentDBEventSourceConfig?
        /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
        public let enabled: Bool?
        /// The Amazon Resource Name (ARN) of the event source.    Amazon Kinesis – The ARN of the data stream or a stream consumer.    Amazon DynamoDB Streams – The ARN of the stream.    Amazon Simple Queue Service – The ARN of the queue.    Amazon Managed Streaming for Apache Kafka – The ARN of the cluster or the ARN of the VPC connection (for cross-account event source mappings).    Amazon MQ – The ARN of the broker.    Amazon DocumentDB – The ARN of the DocumentDB change stream.
        public let eventSourceArn: String?
        /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see Lambda event filtering.
        public let filterCriteria: FilterCriteria?
        /// The name or ARN of the Lambda function.  Name formats     Function name – MyFunction.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.    Partial ARN – 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
        public let functionName: String
        /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
        public let functionResponseTypes: [FunctionResponseType]?
        ///  The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's filter criteria. By default, Lambda does not encrypt your filter criteria object. Specify this property to encrypt data using your own customer managed key.
        public let kmsKeyArn: String?
        /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For Kinesis, DynamoDB, and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public let maximumBatchingWindowInSeconds: Int?
        /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).
        public let maximumRecordAgeInSeconds: Int?
        /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
        public let maximumRetryAttempts: Int?
        /// The metrics configuration for your event source. For more information, see Event source mapping metrics.
        public let metricsConfig: EventSourceMappingMetricsConfig?
        /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
        public let parallelizationFactor: Int?
        /// (Amazon MSK and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see provisioned mode.
        public let provisionedPollerConfig: ProvisionedPollerConfig?
        ///  (MQ) The name of the Amazon MQ broker destination queue to consume.
        public let queues: [String]?
        /// (Amazon SQS only) The scaling configuration for the event source. For more information, see Configuring maximum concurrency for Amazon SQS event sources.
        public let scalingConfig: ScalingConfig?
        /// The self-managed Apache Kafka cluster to receive records from.
        public let selfManagedEventSource: SelfManagedEventSource?
        /// Specific configuration settings for a self-managed Apache Kafka event source.
        public let selfManagedKafkaEventSourceConfig: SelfManagedKafkaEventSourceConfig?
        /// An array of authentication protocols or VPC components required to secure your event source.
        public let sourceAccessConfigurations: [SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
        public let startingPosition: EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
        public let startingPositionTimestamp: Date?
        /// A list of tags to apply to the event source mapping.
        public let tags: [String: String]?
        /// The name of the Kafka topic.
        public let topics: [String]?
        /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
        public let tumblingWindowInSeconds: Int?

        @inlinable
        public init(amazonManagedKafkaEventSourceConfig: AmazonManagedKafkaEventSourceConfig? = nil, batchSize: Int? = nil, bisectBatchOnFunctionError: Bool? = nil, destinationConfig: DestinationConfig? = nil, documentDBEventSourceConfig: DocumentDBEventSourceConfig? = nil, enabled: Bool? = nil, eventSourceArn: String? = nil, filterCriteria: FilterCriteria? = nil, functionName: String, functionResponseTypes: [FunctionResponseType]? = nil, kmsKeyArn: String? = nil, maximumBatchingWindowInSeconds: Int? = nil, maximumRecordAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, metricsConfig: EventSourceMappingMetricsConfig? = nil, parallelizationFactor: Int? = nil, provisionedPollerConfig: ProvisionedPollerConfig? = nil, queues: [String]? = nil, scalingConfig: ScalingConfig? = nil, selfManagedEventSource: SelfManagedEventSource? = nil, selfManagedKafkaEventSourceConfig: SelfManagedKafkaEventSourceConfig? = nil, sourceAccessConfigurations: [SourceAccessConfiguration]? = nil, startingPosition: EventSourcePosition? = nil, startingPositionTimestamp: Date? = nil, tags: [String: String]? = nil, topics: [String]? = nil, tumblingWindowInSeconds: Int? = nil) {
            self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.documentDBEventSourceConfig = documentDBEventSourceConfig
            self.enabled = enabled
            self.eventSourceArn = eventSourceArn
            self.filterCriteria = filterCriteria
            self.functionName = functionName
            self.functionResponseTypes = functionResponseTypes
            self.kmsKeyArn = kmsKeyArn
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.metricsConfig = metricsConfig
            self.parallelizationFactor = parallelizationFactor
            self.provisionedPollerConfig = provisionedPollerConfig
            self.queues = queues
            self.scalingConfig = scalingConfig
            self.selfManagedEventSource = selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.tags = tags
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
        }

        public func validate(name: String) throws {
            try self.amazonManagedKafkaEventSourceConfig?.validate(name: "\(name).amazonManagedKafkaEventSourceConfig")
            try self.validate(self.batchSize, name: "batchSize", parent: name, max: 10000)
            try self.validate(self.batchSize, name: "batchSize", parent: name, min: 1)
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.documentDBEventSourceConfig?.validate(name: "\(name).documentDBEventSourceConfig")
            try self.validate(self.eventSourceArn, name: "eventSourceArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)$")
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.functionResponseTypes, name: "functionResponseTypes", parent: name, max: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, max: 300)
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, min: 0)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, max: 604800)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, min: -1)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 10000)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: -1)
            try self.metricsConfig?.validate(name: "\(name).metricsConfig")
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, max: 10)
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, min: 1)
            try self.provisionedPollerConfig?.validate(name: "\(name).provisionedPollerConfig")
            try self.queues?.forEach {
                try validate($0, name: "queues[]", parent: name, max: 1000)
                try validate($0, name: "queues[]", parent: name, min: 1)
                try validate($0, name: "queues[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.queues, name: "queues", parent: name, max: 1)
            try self.validate(self.queues, name: "queues", parent: name, min: 1)
            try self.scalingConfig?.validate(name: "\(name).scalingConfig")
            try self.selfManagedEventSource?.validate(name: "\(name).selfManagedEventSource")
            try self.selfManagedKafkaEventSourceConfig?.validate(name: "\(name).selfManagedKafkaEventSourceConfig")
            try self.sourceAccessConfigurations?.forEach {
                try $0.validate(name: "\(name).sourceAccessConfigurations[]")
            }
            try self.validate(self.sourceAccessConfigurations, name: "sourceAccessConfigurations", parent: name, max: 22)
            try self.topics?.forEach {
                try validate($0, name: "topics[]", parent: name, max: 249)
                try validate($0, name: "topics[]", parent: name, min: 1)
                try validate($0, name: "topics[]", parent: name, pattern: "^[^.]([a-zA-Z0-9\\-_.]+)$")
            }
            try self.validate(self.topics, name: "topics", parent: name, max: 1)
            try self.validate(self.topics, name: "topics", parent: name, min: 1)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, max: 900)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
            case batchSize = "BatchSize"
            case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
            case destinationConfig = "DestinationConfig"
            case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
            case enabled = "Enabled"
            case eventSourceArn = "EventSourceArn"
            case filterCriteria = "FilterCriteria"
            case functionName = "FunctionName"
            case functionResponseTypes = "FunctionResponseTypes"
            case kmsKeyArn = "KMSKeyArn"
            case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
            case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
            case metricsConfig = "MetricsConfig"
            case parallelizationFactor = "ParallelizationFactor"
            case provisionedPollerConfig = "ProvisionedPollerConfig"
            case queues = "Queues"
            case scalingConfig = "ScalingConfig"
            case selfManagedEventSource = "SelfManagedEventSource"
            case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
            case sourceAccessConfigurations = "SourceAccessConfigurations"
            case startingPosition = "StartingPosition"
            case startingPositionTimestamp = "StartingPositionTimestamp"
            case tags = "Tags"
            case topics = "Topics"
            case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        }
    }

    public struct CreateFunctionRequest: AWSEncodableShape {
        /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
        public let architectures: [Architecture]?
        /// The code for the function.
        public let code: FunctionCode
        /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
        /// includes a set of signing profiles, which define the trusted publishers for this function.
        public let codeSigningConfigArn: String?
        /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues.
        public let deadLetterConfig: DeadLetterConfig?
        /// A description of the function.
        public let description: String?
        /// Environment variables that are accessible from function code during execution.
        public let environment: Environment?
        /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
        public let ephemeralStorage: EphemeralStorage?
        /// Connection settings for an Amazon EFS file system.
        public let fileSystemConfigs: [FileSystemConfig]?
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the method within your code that Lambda calls to run your function.
        /// Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model.
        public let handler: String?
        /// Container image configuration values that override the values in the container image Dockerfile.
        public let imageConfig: ImageConfig?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:   The function's environment variables.   The function's Lambda SnapStart snapshots.   When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see
        /// Specifying a customer managed key for Lambda.   The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.   If you don't provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key.
        public let kmsKeyArn: String?
        /// A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.
        public let layers: [String]?
        /// The function's Amazon CloudWatch Logs configuration settings.
        public let loggingConfig: LoggingConfig?
        /// The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
        public let memorySize: Int?
        /// The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
        public let packageType: PackageType?
        /// Set to true to publish the first version of the function during creation.
        public let publish: Bool?
        /// The Amazon Resource Name (ARN) of the function's execution role.
        public let role: String
        /// The identifier of the function's  runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let runtime: Runtime?
        /// The function's SnapStart setting.
        public let snapStart: SnapStart?
        /// A list of tags to apply to the function.
        public let tags: [String: String]?
        /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
        public let timeout: Int?
        /// Set Mode to Active to sample and trace a subset of incoming requests with
        /// X-Ray.
        public let tracingConfig: TracingConfig?
        /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(architectures: [Architecture]? = nil, code: FunctionCode, codeSigningConfigArn: String? = nil, deadLetterConfig: DeadLetterConfig? = nil, description: String? = nil, environment: Environment? = nil, ephemeralStorage: EphemeralStorage? = nil, fileSystemConfigs: [FileSystemConfig]? = nil, functionName: String, handler: String? = nil, imageConfig: ImageConfig? = nil, kmsKeyArn: String? = nil, layers: [String]? = nil, loggingConfig: LoggingConfig? = nil, memorySize: Int? = nil, packageType: PackageType? = nil, publish: Bool? = nil, role: String, runtime: Runtime? = nil, snapStart: SnapStart? = nil, tags: [String: String]? = nil, timeout: Int? = nil, tracingConfig: TracingConfig? = nil, vpcConfig: VpcConfig? = nil) {
            self.architectures = architectures
            self.code = code
            self.codeSigningConfigArn = codeSigningConfigArn
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.ephemeralStorage = ephemeralStorage
            self.fileSystemConfigs = fileSystemConfigs
            self.functionName = functionName
            self.handler = handler
            self.imageConfig = imageConfig
            self.kmsKeyArn = kmsKeyArn
            self.layers = layers
            self.loggingConfig = loggingConfig
            self.memorySize = memorySize
            self.packageType = packageType
            self.publish = publish
            self.role = role
            self.runtime = runtime
            self.snapStart = snapStart
            self.tags = tags
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.architectures, name: "architectures", parent: name, max: 1)
            try self.validate(self.architectures, name: "architectures", parent: name, min: 1)
            try self.code.validate(name: "\(name).code")
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}$")
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.environment?.validate(name: "\(name).environment")
            try self.ephemeralStorage?.validate(name: "\(name).ephemeralStorage")
            try self.fileSystemConfigs?.forEach {
                try $0.validate(name: "\(name).fileSystemConfigs[]")
            }
            try self.validate(self.fileSystemConfigs, name: "fileSystemConfigs", parent: name, max: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.handler, name: "handler", parent: name, max: 128)
            try self.validate(self.handler, name: "handler", parent: name, pattern: "^[^\\s]+$")
            try self.imageConfig?.validate(name: "\(name).imageConfig")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
            try self.layers?.forEach {
                try validate($0, name: "layers[]", parent: name, max: 140)
                try validate($0, name: "layers[]", parent: name, min: 1)
                try validate($0, name: "layers[]", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+$")
            }
            try self.loggingConfig?.validate(name: "\(name).loggingConfig")
            try self.validate(self.memorySize, name: "memorySize", parent: name, max: 10240)
            try self.validate(self.memorySize, name: "memorySize", parent: name, min: 128)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "Architectures"
            case code = "Code"
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case deadLetterConfig = "DeadLetterConfig"
            case description = "Description"
            case environment = "Environment"
            case ephemeralStorage = "EphemeralStorage"
            case fileSystemConfigs = "FileSystemConfigs"
            case functionName = "FunctionName"
            case handler = "Handler"
            case imageConfig = "ImageConfig"
            case kmsKeyArn = "KMSKeyArn"
            case layers = "Layers"
            case loggingConfig = "LoggingConfig"
            case memorySize = "MemorySize"
            case packageType = "PackageType"
            case publish = "Publish"
            case role = "Role"
            case runtime = "Runtime"
            case snapStart = "SnapStart"
            case tags = "Tags"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct CreateFunctionUrlConfigRequest: AWSEncodableShape {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let authType: FunctionUrlAuthType
        /// The cross-origin resource sharing (CORS) settings for your function URL.
        public let cors: Cors?
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Use one of the following options:    BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results  are available when the payload is complete. The maximum payload size is 6 MB.    RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using  the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase.
        public let invokeMode: InvokeMode?
        /// The alias name.
        public let qualifier: String?

        @inlinable
        public init(authType: FunctionUrlAuthType, cors: Cors? = nil, functionName: String, invokeMode: InvokeMode? = nil, qualifier: String? = nil) {
            self.authType = authType
            self.cors = cors
            self.functionName = functionName
            self.invokeMode = invokeMode
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.authType, forKey: .authType)
            try container.encodeIfPresent(self.cors, forKey: .cors)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.invokeMode, forKey: .invokeMode)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.cors?.validate(name: "\(name).cors")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(^\\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case cors = "Cors"
            case invokeMode = "InvokeMode"
        }
    }

    public struct CreateFunctionUrlConfigResponse: AWSDecodableShape {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let authType: FunctionUrlAuthType
        /// The cross-origin resource sharing (CORS) settings for your function URL.
        public let cors: Cors?
        /// When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let creationTime: String
        /// The Amazon Resource Name (ARN) of your function.
        public let functionArn: String
        /// The HTTP URL endpoint for your function.
        public let functionUrl: String
        /// Use one of the following options:    BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results  are available when the payload is complete. The maximum payload size is 6 MB.    RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using  the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase.
        public let invokeMode: InvokeMode?

        @inlinable
        public init(authType: FunctionUrlAuthType, cors: Cors? = nil, creationTime: String, functionArn: String, functionUrl: String, invokeMode: InvokeMode? = nil) {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case cors = "Cors"
            case creationTime = "CreationTime"
            case functionArn = "FunctionArn"
            case functionUrl = "FunctionUrl"
            case invokeMode = "InvokeMode"
        }
    }

    public struct DeadLetterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public let targetArn: String?

        @inlinable
        public init(targetArn: String? = nil) {
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.targetArn, name: "targetArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetArn = "TargetArn"
        }
    }

    public struct DeleteAliasRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the alias.
        public let name: String

        @inlinable
        public init(functionName: String, name: String) {
            self.functionName = functionName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeSigningConfigRequest: AWSEncodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String

        @inlinable
        public init(codeSigningConfigArn: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeSigningConfigArn, key: "CodeSigningConfigArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeSigningConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventSourceMappingRequest: AWSEncodableShape {
        /// The identifier of the event source mapping.
        public let uuid: String

        @inlinable
        public init(uuid: String) {
            self.uuid = uuid
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.uuid, key: "UUID")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionCodeSigningConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(functionName: String) {
            self.functionName = functionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionConcurrencyRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(functionName: String) {
            self.functionName = functionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionEventInvokeConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// A version number or alias name.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function or version.  Name formats     Function name – my-function (name-only), my-function:1 (with version).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version to delete. You can't delete a version that an alias references.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionUrlConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The alias name.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(^\\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLayerVersionRequest: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The version number.
        public let versionNumber: Int64

        @inlinable
        public init(layerName: String, versionNumber: Int64) {
            self.layerName = layerName
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.layerName, key: "LayerName")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProvisionedConcurrencyConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The version number or alias name.
        public let qualifier: String

        @inlinable
        public init(functionName: String, qualifier: String) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DestinationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The destination configuration for failed invocations.
        public let onFailure: OnFailure?
        /// The destination configuration for successful invocations.
        public let onSuccess: OnSuccess?

        @inlinable
        public init(onFailure: OnFailure? = nil, onSuccess: OnSuccess? = nil) {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }

        public func validate(name: String) throws {
            try self.onFailure?.validate(name: "\(name).onFailure")
            try self.onSuccess?.validate(name: "\(name).onSuccess")
        }

        private enum CodingKeys: String, CodingKey {
            case onFailure = "OnFailure"
            case onSuccess = "OnSuccess"
        }
    }

    public struct DocumentDBEventSourceConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        public let collectionName: String?
        ///  The name of the database to consume within the DocumentDB cluster.
        public let databaseName: String?
        ///  Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        public let fullDocument: FullDocument?

        @inlinable
        public init(collectionName: String? = nil, databaseName: String? = nil, fullDocument: FullDocument? = nil) {
            self.collectionName = collectionName
            self.databaseName = databaseName
            self.fullDocument = fullDocument
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 57)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^(^(?!(system\\x2e)))(^[_a-zA-Z0-9])([^$]*)$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[^ /\\.$\\x22]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case databaseName = "DatabaseName"
            case fullDocument = "FullDocument"
        }
    }

    public struct EC2AccessDeniedException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EC2ThrottledException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EC2UnexpectedException: AWSErrorShape {
        public let ec2ErrorCode: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(ec2ErrorCode: String? = nil, message: String? = nil, type: String? = nil) {
            self.ec2ErrorCode = ec2ErrorCode
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case ec2ErrorCode = "EC2ErrorCode"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EFSIOException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EFSMountConnectivityException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EFSMountFailureException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EFSMountTimeoutException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ENILimitReachedException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct Environment: AWSEncodableShape {
        /// Environment variable key-value pairs. For more information, see Using Lambda environment variables.
        public let variables: [String: String]?

        @inlinable
        public init(variables: [String: String]? = nil) {
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "^[a-zA-Z]([a-zA-Z0-9_])+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case variables = "Variables"
        }
    }

    public struct EnvironmentError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct EnvironmentResponse: AWSDecodableShape {
        /// Error messages for environment variables that couldn't be applied.
        public let error: EnvironmentError?
        /// Environment variable key-value pairs. Omitted from CloudTrail logs.
        public let variables: [String: String]?

        @inlinable
        public init(error: EnvironmentError? = nil, variables: [String: String]? = nil) {
            self.error = error
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case variables = "Variables"
        }
    }

    public struct EphemeralStorage: AWSEncodableShape & AWSDecodableShape {
        /// The size of the function's /tmp directory.
        public let size: Int

        @inlinable
        public init(size: Int) {
            self.size = size
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, max: 10240)
            try self.validate(self.size, name: "size", parent: name, min: 512)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
        }
    }

    public struct EventSourceMappingConfiguration: AWSDecodableShape {
        /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        public let amazonManagedKafkaEventSourceConfig: AmazonManagedKafkaEventSourceConfig?
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public let batchSize: Int?
        /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
        public let bisectBatchOnFunctionError: Bool?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka event sources only) A configuration object that specifies the destination of an event after Lambda processes it.
        public let destinationConfig: DestinationConfig?
        /// Specific configuration settings for a DocumentDB event source.
        public let documentDBEventSourceConfig: DocumentDBEventSourceConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public let eventSourceArn: String?
        /// The Amazon Resource Name (ARN) of the event source mapping.
        public let eventSourceMappingArn: String?
        /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see Lambda event filtering. If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
        public let filterCriteria: FilterCriteria?
        /// An object that contains details about an error related to filter criteria encryption.
        public let filterCriteriaError: FilterCriteriaError?
        /// The ARN of the Lambda function.
        public let functionArn: String?
        /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
        public let functionResponseTypes: [FunctionResponseType]?
        ///  The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's filter criteria.
        public let kmsKeyArn: String?
        /// The date that the event source mapping was last updated or that its state changed.
        public let lastModified: Date?
        /// The result of the last Lambda invocation of your function.
        public let lastProcessingResult: String?
        /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public let maximumBatchingWindowInSeconds: Int?
        /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1,
        /// which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.  The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
        public let maximumRecordAgeInSeconds: Int?
        /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1,
        /// which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public let maximumRetryAttempts: Int?
        /// The metrics configuration for your event source. For more information, see Event source mapping metrics.
        public let metricsConfig: EventSourceMappingMetricsConfig?
        /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
        public let parallelizationFactor: Int?
        /// (Amazon MSK and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see provisioned mode.
        public let provisionedPollerConfig: ProvisionedPollerConfig?
        ///  (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
        public let queues: [String]?
        /// (Amazon SQS only) The scaling configuration for the event source. For more information, see Configuring maximum concurrency for Amazon SQS event sources.
        public let scalingConfig: ScalingConfig?
        /// The self-managed Apache Kafka cluster for your event source.
        public let selfManagedEventSource: SelfManagedEventSource?
        /// Specific configuration settings for a self-managed Apache Kafka event source.
        public let selfManagedKafkaEventSourceConfig: SelfManagedKafkaEventSourceConfig?
        /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        public let sourceAccessConfigurations: [SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
        public let startingPosition: EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
        public let startingPositionTimestamp: Date?
        /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
        public let state: String?
        /// Indicates whether a user or Lambda made the last change to the event source mapping.
        public let stateTransitionReason: String?
        /// The name of the Kafka topic.
        public let topics: [String]?
        /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
        public let tumblingWindowInSeconds: Int?
        /// The identifier of the event source mapping.
        public let uuid: String?

        @inlinable
        public init(amazonManagedKafkaEventSourceConfig: AmazonManagedKafkaEventSourceConfig? = nil, batchSize: Int? = nil, bisectBatchOnFunctionError: Bool? = nil, destinationConfig: DestinationConfig? = nil, documentDBEventSourceConfig: DocumentDBEventSourceConfig? = nil, eventSourceArn: String? = nil, eventSourceMappingArn: String? = nil, filterCriteria: FilterCriteria? = nil, filterCriteriaError: FilterCriteriaError? = nil, functionArn: String? = nil, functionResponseTypes: [FunctionResponseType]? = nil, kmsKeyArn: String? = nil, lastModified: Date? = nil, lastProcessingResult: String? = nil, maximumBatchingWindowInSeconds: Int? = nil, maximumRecordAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, metricsConfig: EventSourceMappingMetricsConfig? = nil, parallelizationFactor: Int? = nil, provisionedPollerConfig: ProvisionedPollerConfig? = nil, queues: [String]? = nil, scalingConfig: ScalingConfig? = nil, selfManagedEventSource: SelfManagedEventSource? = nil, selfManagedKafkaEventSourceConfig: SelfManagedKafkaEventSourceConfig? = nil, sourceAccessConfigurations: [SourceAccessConfiguration]? = nil, startingPosition: EventSourcePosition? = nil, startingPositionTimestamp: Date? = nil, state: String? = nil, stateTransitionReason: String? = nil, topics: [String]? = nil, tumblingWindowInSeconds: Int? = nil, uuid: String? = nil) {
            self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.documentDBEventSourceConfig = documentDBEventSourceConfig
            self.eventSourceArn = eventSourceArn
            self.eventSourceMappingArn = eventSourceMappingArn
            self.filterCriteria = filterCriteria
            self.filterCriteriaError = filterCriteriaError
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.metricsConfig = metricsConfig
            self.parallelizationFactor = parallelizationFactor
            self.provisionedPollerConfig = provisionedPollerConfig
            self.queues = queues
            self.scalingConfig = scalingConfig
            self.selfManagedEventSource = selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }

        private enum CodingKeys: String, CodingKey {
            case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
            case batchSize = "BatchSize"
            case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
            case destinationConfig = "DestinationConfig"
            case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
            case eventSourceArn = "EventSourceArn"
            case eventSourceMappingArn = "EventSourceMappingArn"
            case filterCriteria = "FilterCriteria"
            case filterCriteriaError = "FilterCriteriaError"
            case functionArn = "FunctionArn"
            case functionResponseTypes = "FunctionResponseTypes"
            case kmsKeyArn = "KMSKeyArn"
            case lastModified = "LastModified"
            case lastProcessingResult = "LastProcessingResult"
            case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
            case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
            case metricsConfig = "MetricsConfig"
            case parallelizationFactor = "ParallelizationFactor"
            case provisionedPollerConfig = "ProvisionedPollerConfig"
            case queues = "Queues"
            case scalingConfig = "ScalingConfig"
            case selfManagedEventSource = "SelfManagedEventSource"
            case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
            case sourceAccessConfigurations = "SourceAccessConfigurations"
            case startingPosition = "StartingPosition"
            case startingPositionTimestamp = "StartingPositionTimestamp"
            case state = "State"
            case stateTransitionReason = "StateTransitionReason"
            case topics = "Topics"
            case tumblingWindowInSeconds = "TumblingWindowInSeconds"
            case uuid = "UUID"
        }
    }

    public struct EventSourceMappingMetricsConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The metrics you want your event source mapping to produce. Include EventCount to receive event source mapping metrics related to the number of events processed by your event source mapping. For more information about these metrics, see  Event source mapping metrics.
        public let metrics: [EventSourceMappingMetric]?

        @inlinable
        public init(metrics: [EventSourceMappingMetric]? = nil) {
            self.metrics = metrics
        }

        public func validate(name: String) throws {
            try self.validate(self.metrics, name: "metrics", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "Metrics"
        }
    }

    public struct FileSystemConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        public let arn: String
        /// The path where the function can access the file system, starting with /mnt/.
        public let localMountPath: String

        @inlinable
        public init(arn: String, localMountPath: String) {
            self.arn = arn
            self.localMountPath = localMountPath
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 200)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:access-point/fsap-[a-f0-9]{17}$")
            try self.validate(self.localMountPath, name: "localMountPath", parent: name, max: 160)
            try self.validate(self.localMountPath, name: "localMountPath", parent: name, pattern: "^/mnt/[a-zA-Z0-9-_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case localMountPath = "LocalMountPath"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        ///  A filter pattern. For more information on the syntax of a filter pattern, see  Filter rule syntax.
        public let pattern: String?

        @inlinable
        public init(pattern: String? = nil) {
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.pattern, name: "pattern", parent: name, max: 4096)
            try self.validate(self.pattern, name: "pattern", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "Pattern"
        }
    }

    public struct FilterCriteria: AWSEncodableShape & AWSDecodableShape {
        ///  A list of filters.
        public let filters: [Filter]?

        @inlinable
        public init(filters: [Filter]? = nil) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
        }
    }

    public struct FilterCriteriaError: AWSDecodableShape {
        /// The KMS exception that resulted from filter criteria encryption or decryption.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct FunctionCode: AWSEncodableShape {
        /// URI of a container image in the Amazon ECR registry.
        public let imageUri: String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's
        /// .zip deployment package. If you don't provide a customer managed key, Lambda uses an Amazon Web Services owned key.
        public let sourceKMSKeyArn: String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.
        public let zipFile: AWSBase64Data?

        @inlinable
        public init(imageUri: String? = nil, s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, sourceKMSKeyArn: String? = nil, zipFile: AWSBase64Data? = nil) {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.sourceKMSKeyArn = sourceKMSKeyArn
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*(?<!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1024)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
            try self.validate(self.sourceKMSKeyArn, name: "sourceKMSKeyArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageUri = "ImageUri"
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case sourceKMSKeyArn = "SourceKMSKeyArn"
            case zipFile = "ZipFile"
        }
    }

    public struct FunctionCodeLocation: AWSDecodableShape {
        /// URI of a container image in the Amazon ECR registry.
        public let imageUri: String?
        /// A presigned URL that you can use to download the deployment package.
        public let location: String?
        /// The service that's hosting the file.
        public let repositoryType: String?
        /// The resolved URI for the image.
        public let resolvedImageUri: String?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's
        /// .zip deployment package. If you don't provide a customer managed key, Lambda uses an Amazon Web Services owned key.
        public let sourceKMSKeyArn: String?

        @inlinable
        public init(imageUri: String? = nil, location: String? = nil, repositoryType: String? = nil, resolvedImageUri: String? = nil, sourceKMSKeyArn: String? = nil) {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
            self.sourceKMSKeyArn = sourceKMSKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case imageUri = "ImageUri"
            case location = "Location"
            case repositoryType = "RepositoryType"
            case resolvedImageUri = "ResolvedImageUri"
            case sourceKMSKeyArn = "SourceKMSKeyArn"
        }
    }

    public struct FunctionConfiguration: AWSDecodableShape {
        /// The instruction set architecture that the function supports. Architecture is a string array with one of the  valid values. The default architecture value is x86_64.
        public let architectures: [Architecture]?
        /// The SHA256 hash of the function's deployment package.
        public let codeSha256: String?
        /// The size of the function's deployment package, in bytes.
        public let codeSize: Int64?
        /// The function's dead letter queue.
        public let deadLetterConfig: DeadLetterConfig?
        /// The function's description.
        public let description: String?
        /// The function's environment variables. Omitted from CloudTrail logs.
        public let environment: EnvironmentResponse?
        /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
        public let ephemeralStorage: EphemeralStorage?
        /// Connection settings for an Amazon EFS file system.
        public let fileSystemConfigs: [FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public let functionArn: String?
        /// The name of the function.
        public let functionName: String?
        /// The function that Lambda calls to begin running your function.
        public let handler: String?
        /// The function's image configuration values.
        public let imageConfigResponse: ImageConfigResponse?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:   The function's environment variables.   The function's Lambda SnapStart snapshots.   When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see  Specifying a customer managed key for Lambda.   The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.   If you don't provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key.
        public let kmsKeyArn: String?
        /// The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModified: String?
        /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
        public let lastUpdateStatus: LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public let lastUpdateStatusReason: String?
        /// The reason code for the last update that was performed on the function.
        public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
        /// The function's layers.
        public let layers: [Layer]?
        /// The function's Amazon CloudWatch Logs configuration settings.
        public let loggingConfig: LoggingConfig?
        /// For Lambda@Edge functions, the ARN of the main function.
        public let masterArn: String?
        /// The amount of memory available to the function at runtime.
        public let memorySize: Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public let packageType: PackageType?
        /// The latest updated revision of the function or alias.
        public let revisionId: String?
        /// The function's execution role.
        public let role: String?
        /// The identifier of the function's  runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let runtime: Runtime?
        /// The ARN of the runtime and any errors that occured.
        public let runtimeVersionConfig: RuntimeVersionConfig?
        /// The ARN of the signing job.
        public let signingJobArn: String?
        /// The ARN of the signing profile version.
        public let signingProfileVersionArn: String?
        /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
        public let snapStart: SnapStartResponse?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
        public let state: State?
        /// The reason for the function's current state.
        public let stateReason: String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
        public let stateReasonCode: StateReasonCode?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public let timeout: Int?
        /// The function's X-Ray tracing configuration.
        public let tracingConfig: TracingConfigResponse?
        /// The version of the Lambda function.
        public let version: String?
        /// The function's networking configuration.
        public let vpcConfig: VpcConfigResponse?

        @inlinable
        public init(architectures: [Architecture]? = nil, codeSha256: String? = nil, codeSize: Int64? = nil, deadLetterConfig: DeadLetterConfig? = nil, description: String? = nil, environment: EnvironmentResponse? = nil, ephemeralStorage: EphemeralStorage? = nil, fileSystemConfigs: [FileSystemConfig]? = nil, functionArn: String? = nil, functionName: String? = nil, handler: String? = nil, imageConfigResponse: ImageConfigResponse? = nil, kmsKeyArn: String? = nil, lastModified: String? = nil, lastUpdateStatus: LastUpdateStatus? = nil, lastUpdateStatusReason: String? = nil, lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil, layers: [Layer]? = nil, loggingConfig: LoggingConfig? = nil, masterArn: String? = nil, memorySize: Int? = nil, packageType: PackageType? = nil, revisionId: String? = nil, role: String? = nil, runtime: Runtime? = nil, runtimeVersionConfig: RuntimeVersionConfig? = nil, signingJobArn: String? = nil, signingProfileVersionArn: String? = nil, snapStart: SnapStartResponse? = nil, state: State? = nil, stateReason: String? = nil, stateReasonCode: StateReasonCode? = nil, timeout: Int? = nil, tracingConfig: TracingConfigResponse? = nil, version: String? = nil, vpcConfig: VpcConfigResponse? = nil) {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.ephemeralStorage = ephemeralStorage
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.loggingConfig = loggingConfig
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.runtimeVersionConfig = runtimeVersionConfig
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.snapStart = snapStart
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "Architectures"
            case codeSha256 = "CodeSha256"
            case codeSize = "CodeSize"
            case deadLetterConfig = "DeadLetterConfig"
            case description = "Description"
            case environment = "Environment"
            case ephemeralStorage = "EphemeralStorage"
            case fileSystemConfigs = "FileSystemConfigs"
            case functionArn = "FunctionArn"
            case functionName = "FunctionName"
            case handler = "Handler"
            case imageConfigResponse = "ImageConfigResponse"
            case kmsKeyArn = "KMSKeyArn"
            case lastModified = "LastModified"
            case lastUpdateStatus = "LastUpdateStatus"
            case lastUpdateStatusReason = "LastUpdateStatusReason"
            case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
            case layers = "Layers"
            case loggingConfig = "LoggingConfig"
            case masterArn = "MasterArn"
            case memorySize = "MemorySize"
            case packageType = "PackageType"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case runtimeVersionConfig = "RuntimeVersionConfig"
            case signingJobArn = "SigningJobArn"
            case signingProfileVersionArn = "SigningProfileVersionArn"
            case snapStart = "SnapStart"
            case state = "State"
            case stateReason = "StateReason"
            case stateReasonCode = "StateReasonCode"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case version = "Version"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct FunctionEventInvokeConfig: AWSDecodableShape {
        /// A destination for events after they have been sent to a function for processing.  Destinations     Function - The Amazon Resource Name (ARN) of a Lambda function.    Queue - The ARN of a standard SQS queue.    Bucket - The ARN of an Amazon S3 bucket.    Topic - The ARN of a standard SNS topic.    Event Bus - The ARN of an Amazon EventBridge event bus.    S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
        public let destinationConfig: DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public let functionArn: String?
        /// The date and time that the configuration was last updated.
        public let lastModified: Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of times to retry when the function returns an error.
        public let maximumRetryAttempts: Int?

        @inlinable
        public init(destinationConfig: DestinationConfig? = nil, functionArn: String? = nil, lastModified: Date? = nil, maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil) {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfig = "DestinationConfig"
            case functionArn = "FunctionArn"
            case lastModified = "LastModified"
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct FunctionUrlConfig: AWSDecodableShape {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let authType: FunctionUrlAuthType
        /// The cross-origin resource sharing (CORS) settings for your function URL.
        public let cors: Cors?
        /// When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let creationTime: String
        /// The Amazon Resource Name (ARN) of your function.
        public let functionArn: String
        /// The HTTP URL endpoint for your function.
        public let functionUrl: String
        /// Use one of the following options:    BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.    RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase.
        public let invokeMode: InvokeMode?
        /// When the function URL configuration was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModifiedTime: String

        @inlinable
        public init(authType: FunctionUrlAuthType, cors: Cors? = nil, creationTime: String, functionArn: String, functionUrl: String, invokeMode: InvokeMode? = nil, lastModifiedTime: String) {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case cors = "Cors"
            case creationTime = "CreationTime"
            case functionArn = "FunctionArn"
            case functionUrl = "FunctionUrl"
            case invokeMode = "InvokeMode"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResponse: AWSDecodableShape {
        /// Limits that are related to concurrency and code storage.
        public let accountLimit: AccountLimit?
        /// The number of functions and amount of storage in use.
        public let accountUsage: AccountUsage?

        @inlinable
        public init(accountLimit: AccountLimit? = nil, accountUsage: AccountUsage? = nil) {
            self.accountLimit = accountLimit
            self.accountUsage = accountUsage
        }

        private enum CodingKeys: String, CodingKey {
            case accountLimit = "AccountLimit"
            case accountUsage = "AccountUsage"
        }
    }

    public struct GetAliasRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the alias.
        public let name: String

        @inlinable
        public init(functionName: String, name: String) {
            self.functionName = functionName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeSigningConfigRequest: AWSEncodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String

        @inlinable
        public init(codeSigningConfigArn: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeSigningConfigArn, key: "CodeSigningConfigArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeSigningConfigResponse: AWSDecodableShape {
        /// The code signing configuration
        public let codeSigningConfig: CodeSigningConfig

        @inlinable
        public init(codeSigningConfig: CodeSigningConfig) {
            self.codeSigningConfig = codeSigningConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfig = "CodeSigningConfig"
        }
    }

    public struct GetEventSourceMappingRequest: AWSEncodableShape {
        /// The identifier of the event source mapping.
        public let uuid: String

        @inlinable
        public init(uuid: String) {
            self.uuid = uuid
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.uuid, key: "UUID")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionCodeSigningConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(functionName: String) {
            self.functionName = functionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionCodeSigningConfigResponse: AWSDecodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(codeSigningConfigArn: String, functionName: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.functionName = functionName
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case functionName = "FunctionName"
        }
    }

    public struct GetFunctionConcurrencyRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(functionName: String) {
            self.functionName = functionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionConcurrencyResponse: AWSDecodableShape {
        /// The number of simultaneous executions that are reserved for the function.
        public let reservedConcurrentExecutions: Int?

        @inlinable
        public init(reservedConcurrentExecutions: Int? = nil) {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
        }
    }

    public struct GetFunctionConfigurationRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name – my-function (name-only), my-function:v1 (with alias).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to get details about a published version of the function.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionEventInvokeConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// A version number or alias name.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionRecursionConfigRequest: AWSEncodableShape {
        public let functionName: String

        @inlinable
        public init(functionName: String) {
            self.functionName = functionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}((-gov)|(-iso([a-z]?)))?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionRecursionConfigResponse: AWSDecodableShape {
        /// If your function's recursive loop detection configuration is Allow, Lambda doesn't take any action when it  detects your function being invoked as part of a recursive loop. If your function's recursive loop detection configuration is Terminate, Lambda stops your function being  invoked and notifies you when it detects your function being invoked as part of a recursive loop. By default, Lambda sets your function's configuration to Terminate. You can update this  configuration using the PutFunctionRecursionConfig action.
        public let recursiveLoop: RecursiveLoop?

        @inlinable
        public init(recursiveLoop: RecursiveLoop? = nil) {
            self.recursiveLoop = recursiveLoop
        }

        private enum CodingKeys: String, CodingKey {
            case recursiveLoop = "RecursiveLoop"
        }
    }

    public struct GetFunctionRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name – my-function (name-only), my-function:v1 (with alias).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to get details about a published version of the function.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionResponse: AWSDecodableShape {
        /// The deployment package of the function or version.
        public let code: FunctionCodeLocation?
        /// The function's reserved concurrency.
        public let concurrency: Concurrency?
        /// The configuration of the function or version.
        public let configuration: FunctionConfiguration?
        /// The function's tags. Lambda returns tag data only if you have explicit allow permissions for lambda:ListTags.
        public let tags: [String: String]?
        /// An object that contains details about an error related to retrieving tags.
        public let tagsError: TagsError?

        @inlinable
        public init(code: FunctionCodeLocation? = nil, concurrency: Concurrency? = nil, configuration: FunctionConfiguration? = nil, tags: [String: String]? = nil, tagsError: TagsError? = nil) {
            self.code = code
            self.concurrency = concurrency
            self.configuration = configuration
            self.tags = tags
            self.tagsError = tagsError
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case concurrency = "Concurrency"
            case configuration = "Configuration"
            case tags = "Tags"
            case tagsError = "TagsError"
        }
    }

    public struct GetFunctionUrlConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The alias name.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(^\\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionUrlConfigResponse: AWSDecodableShape {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let authType: FunctionUrlAuthType
        /// The cross-origin resource sharing (CORS) settings for your function URL.
        public let cors: Cors?
        /// When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let creationTime: String
        /// The Amazon Resource Name (ARN) of your function.
        public let functionArn: String
        /// The HTTP URL endpoint for your function.
        public let functionUrl: String
        /// Use one of the following options:    BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results  are available when the payload is complete. The maximum payload size is 6 MB.    RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using  the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase.
        public let invokeMode: InvokeMode?
        /// When the function URL configuration was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModifiedTime: String

        @inlinable
        public init(authType: FunctionUrlAuthType, cors: Cors? = nil, creationTime: String, functionArn: String, functionUrl: String, invokeMode: InvokeMode? = nil, lastModifiedTime: String) {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case cors = "Cors"
            case creationTime = "CreationTime"
            case functionArn = "FunctionArn"
            case functionUrl = "FunctionUrl"
            case invokeMode = "InvokeMode"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct GetLayerVersionByArnRequest: AWSEncodableShape {
        /// The ARN of the layer version.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 140)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayerVersionPolicyRequest: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The version number.
        public let versionNumber: Int64

        @inlinable
        public init(layerName: String, versionNumber: Int64) {
            self.layerName = layerName
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.layerName, key: "LayerName")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayerVersionPolicyResponse: AWSDecodableShape {
        /// The policy document.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let revisionId: String?

        @inlinable
        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct GetLayerVersionRequest: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The version number.
        public let versionNumber: Int64

        @inlinable
        public init(layerName: String, versionNumber: Int64) {
            self.layerName = layerName
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.layerName, key: "LayerName")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayerVersionResponse: AWSDecodableShape {
        /// A list of compatible
        /// instruction set architectures.
        public let compatibleArchitectures: [Architecture]?
        /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let compatibleRuntimes: [Runtime]?
        /// Details about the layer version.
        public let content: LayerVersionContentOutput?
        /// The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let createdDate: String?
        /// The description of the version.
        public let description: String?
        /// The ARN of the layer.
        public let layerArn: String?
        /// The ARN of the layer version.
        public let layerVersionArn: String?
        /// The layer's software license.
        public let licenseInfo: String?
        /// The version number.
        public let version: Int64?

        @inlinable
        public init(compatibleArchitectures: [Architecture]? = nil, compatibleRuntimes: [Runtime]? = nil, content: LayerVersionContentOutput? = nil, createdDate: String? = nil, description: String? = nil, layerArn: String? = nil, layerVersionArn: String? = nil, licenseInfo: String? = nil, version: Int64? = nil) {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.content = content
            self.createdDate = createdDate
            self.description = description
            self.layerArn = layerArn
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleArchitectures = "CompatibleArchitectures"
            case compatibleRuntimes = "CompatibleRuntimes"
            case content = "Content"
            case createdDate = "CreatedDate"
            case description = "Description"
            case layerArn = "LayerArn"
            case layerVersionArn = "LayerVersionArn"
            case licenseInfo = "LicenseInfo"
            case version = "Version"
        }
    }

    public struct GetPolicyRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name – my-function (name-only), my-function:v1 (with alias).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to get the policy for that resource.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyResponse: AWSDecodableShape {
        /// The resource-based policy.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let revisionId: String?

        @inlinable
        public init(policy: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case revisionId = "RevisionId"
        }
    }

    public struct GetProvisionedConcurrencyConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The version number or alias name.
        public let qualifier: String

        @inlinable
        public init(functionName: String, qualifier: String) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProvisionedConcurrencyConfigResponse: AWSDecodableShape {
        /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
        public let allocatedProvisionedConcurrentExecutions: Int?
        /// The amount of provisioned concurrency available.
        public let availableProvisionedConcurrentExecutions: Int?
        /// The date and time that a user last updated the configuration, in ISO 8601 format.
        public let lastModified: String?
        /// The amount of provisioned concurrency requested.
        public let requestedProvisionedConcurrentExecutions: Int?
        /// The status of the allocation process.
        public let status: ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public let statusReason: String?

        @inlinable
        public init(allocatedProvisionedConcurrentExecutions: Int? = nil, availableProvisionedConcurrentExecutions: Int? = nil, lastModified: String? = nil, requestedProvisionedConcurrentExecutions: Int? = nil, status: ProvisionedConcurrencyStatusEnum? = nil, statusReason: String? = nil) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
            case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
            case lastModified = "LastModified"
            case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct GetRuntimeManagementConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the  $LATEST version is returned.
        public let qualifier: String?

        @inlinable
        public init(functionName: String, qualifier: String? = nil) {
            self.functionName = functionName
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRuntimeManagementConfigResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of your function.
        public let functionArn: String?
        /// The ARN of the runtime the function is configured to use. If the runtime update mode is Manual, the ARN is returned, otherwise null  is returned.
        public let runtimeVersionArn: String?
        /// The current runtime update mode of the function.
        public let updateRuntimeOn: UpdateRuntimeOn?

        @inlinable
        public init(functionArn: String? = nil, runtimeVersionArn: String? = nil, updateRuntimeOn: UpdateRuntimeOn? = nil) {
            self.functionArn = functionArn
            self.runtimeVersionArn = runtimeVersionArn
            self.updateRuntimeOn = updateRuntimeOn
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
            case runtimeVersionArn = "RuntimeVersionArn"
            case updateRuntimeOn = "UpdateRuntimeOn"
        }
    }

    public struct ImageConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public let command: [String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime executable.
        public let entryPoint: [String]?
        /// Specifies the working directory.
        public let workingDirectory: String?

        @inlinable
        public init(command: [String]? = nil, entryPoint: [String]? = nil, workingDirectory: String? = nil) {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.command, name: "command", parent: name, max: 1500)
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, max: 1500)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case entryPoint = "EntryPoint"
            case workingDirectory = "WorkingDirectory"
        }
    }

    public struct ImageConfigError: AWSDecodableShape {
        /// Error code.
        public let errorCode: String?
        /// Error message.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ImageConfigResponse: AWSDecodableShape {
        /// Error response to GetFunctionConfiguration.
        public let error: ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public let imageConfig: ImageConfig?

        @inlinable
        public init(error: ImageConfigError? = nil, imageConfig: ImageConfig? = nil) {
            self.error = error
            self.imageConfig = imageConfig
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case imageConfig = "ImageConfig"
        }
    }

    public struct InvalidCodeSignatureException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvalidParameterValueException: AWSErrorShape {
        /// The exception message.
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct InvalidRequestContentException: AWSErrorShape {
        /// The exception message.
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct InvalidRuntimeException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvalidSecurityGroupIDException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvalidSubnetIDException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvalidZipFileException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvocationRequest: AWSEncodableShape {
        /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object. Lambda passes the ClientContext object to your function for synchronous invocations only.
        public let clientContext: String?
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name – my-function (name-only), my-function:v1 (with alias).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Choose from the following options.    RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API response includes the function response and additional data.    Event – Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if one is configured). The API response only includes a status code.    DryRun – Validate parameter values and verify that the user or role has permission to invoke the function.
        public let invocationType: InvocationType?
        /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
        public let logType: LogType?
        /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
        public let payload: AWSHTTPBody?
        /// Specify a version or alias to invoke a published version of the function.
        public let qualifier: String?

        @inlinable
        public init(clientContext: String? = nil, functionName: String, invocationType: InvocationType? = nil, logType: LogType? = nil, payload: AWSHTTPBody? = nil, qualifier: String? = nil) {
            self.clientContext = clientContext
            self.functionName = functionName
            self.invocationType = invocationType
            self.logType = logType
            self.payload = payload
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.clientContext, key: "X-Amz-Client-Context")
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeHeader(self.invocationType, key: "X-Amz-Invocation-Type")
            request.encodeHeader(self.logType, key: "X-Amz-Log-Type")
            try container.encode(self.payload)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvocationResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
        public let executedVersion: String?
        /// If present, indicates that an error occurred during function execution. Details about the error are included in the response payload.
        public let functionError: String?
        /// The last 4 KB of the execution log, which is base64-encoded.
        public let logResult: String?
        /// The response from the function, or an error object.
        public let payload: AWSHTTPBody
        /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse invocation type, this status code is 200. For the Event invocation type, this status code is 202. For the DryRun invocation type, the status code is 204.
        public let statusCode: Int?

        @inlinable
        public init(executedVersion: String? = nil, functionError: String? = nil, logResult: String? = nil, payload: AWSHTTPBody, statusCode: Int? = nil) {
            self.executedVersion = executedVersion
            self.functionError = functionError
            self.logResult = logResult
            self.payload = payload
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.executedVersion = try response.decodeHeaderIfPresent(String.self, key: "X-Amz-Executed-Version")
            self.functionError = try response.decodeHeaderIfPresent(String.self, key: "X-Amz-Function-Error")
            self.logResult = try response.decodeHeaderIfPresent(String.self, key: "X-Amz-Log-Result")
            self.payload = try container.decode(AWSHTTPBody.self)
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeAsyncRequest: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The JSON that you want to provide to your Lambda function as input.
        public let invokeArgs: AWSHTTPBody

        @inlinable
        public init(functionName: String, invokeArgs: AWSHTTPBody) {
            self.functionName = functionName
            self.invokeArgs = invokeArgs
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encode(self.invokeArgs)
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeAsyncResponse: AWSDecodableShape {
        /// The status code.
        public let status: Int?

        @inlinable
        public init(status: Int? = nil) {
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeResponseStreamUpdate: AWSDecodableShape {
        /// Data returned by your Lambda function.
        public let payload: AWSEventPayload

        @inlinable
        public init(payload: AWSEventPayload) {
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.payload = try container.decode(AWSEventPayload.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeWithResponseStreamCompleteEvent: AWSDecodableShape {
        /// An error code.
        public let errorCode: String?
        /// The details of any returned error.
        public let errorDetails: String?
        /// The last 4 KB of the execution log, which is base64-encoded.
        public let logResult: String?

        @inlinable
        public init(errorCode: String? = nil, errorDetails: String? = nil, logResult: String? = nil) {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
            self.logResult = logResult
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorDetails = "ErrorDetails"
            case logResult = "LogResult"
        }
    }

    public struct InvokeWithResponseStreamRequest: AWSEncodableShape {
        /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
        public let clientContext: String?
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Use one of the following options:    RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API operation response includes the function response and additional data.    DryRun – Validate parameter values and verify that the IAM user or role has permission to invoke the function.
        public let invocationType: ResponseStreamingInvocationType?
        /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
        public let logType: LogType?
        /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
        public let payload: AWSHTTPBody?
        /// The alias name.
        public let qualifier: String?

        @inlinable
        public init(clientContext: String? = nil, functionName: String, invocationType: ResponseStreamingInvocationType? = nil, logType: LogType? = nil, payload: AWSHTTPBody? = nil, qualifier: String? = nil) {
            self.clientContext = clientContext
            self.functionName = functionName
            self.invocationType = invocationType
            self.logType = logType
            self.payload = payload
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.clientContext, key: "X-Amz-Client-Context")
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeHeader(self.invocationType, key: "X-Amz-Invocation-Type")
            request.encodeHeader(self.logType, key: "X-Amz-Log-Type")
            try container.encode(self.payload)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeWithResponseStreamResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The stream of response payloads.
        public let eventStream: AWSEventStream<InvokeWithResponseStreamResponseEvent>
        /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
        public let executedVersion: String?
        /// The type of data the stream is returning.
        public let responseStreamContentType: String?
        /// For a successful request, the HTTP status code is in the 200 range. For the RequestResponse invocation type, this status code is 200. For the DryRun invocation type, this status code is 204.
        public let statusCode: Int?

        @inlinable
        public init(eventStream: AWSEventStream<InvokeWithResponseStreamResponseEvent>, executedVersion: String? = nil, responseStreamContentType: String? = nil, statusCode: Int? = nil) {
            self.eventStream = eventStream
            self.executedVersion = executedVersion
            self.responseStreamContentType = responseStreamContentType
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.eventStream = try container.decode(AWSEventStream<InvokeWithResponseStreamResponseEvent>.self)
            self.executedVersion = try response.decodeHeaderIfPresent(String.self, key: "X-Amz-Executed-Version")
            self.responseStreamContentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct KMSAccessDeniedException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct KMSDisabledException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct KMSInvalidStateException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct KMSNotFoundException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct Layer: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the function layer.
        public let arn: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int64?
        /// The Amazon Resource Name (ARN)  of a signing job.
        public let signingJobArn: String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public let signingProfileVersionArn: String?

        @inlinable
        public init(arn: String? = nil, codeSize: Int64? = nil, signingJobArn: String? = nil, signingProfileVersionArn: String? = nil) {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case codeSize = "CodeSize"
            case signingJobArn = "SigningJobArn"
            case signingProfileVersionArn = "SigningProfileVersionArn"
        }
    }

    public struct LayerVersionContentInput: AWSEncodableShape {
        /// The Amazon S3 bucket of the layer archive.
        public let s3Bucket: String?
        /// The Amazon S3 key of the layer archive.
        public let s3Key: String?
        /// For versioned objects, the version of the layer archive object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public let zipFile: AWSBase64Data?

        @inlinable
        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: AWSBase64Data? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*(?<!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1024)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct LayerVersionContentOutput: AWSDecodableShape {
        /// The SHA-256 hash of the layer archive.
        public let codeSha256: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int64?
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public let location: String?
        /// The Amazon Resource Name (ARN)  of a signing job.
        public let signingJobArn: String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public let signingProfileVersionArn: String?

        @inlinable
        public init(codeSha256: String? = nil, codeSize: Int64? = nil, location: String? = nil, signingJobArn: String? = nil, signingProfileVersionArn: String? = nil) {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case codeSha256 = "CodeSha256"
            case codeSize = "CodeSize"
            case location = "Location"
            case signingJobArn = "SigningJobArn"
            case signingProfileVersionArn = "SigningProfileVersionArn"
        }
    }

    public struct LayerVersionsListItem: AWSDecodableShape {
        /// A list of compatible   instruction set architectures.
        public let compatibleArchitectures: [Architecture]?
        /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let compatibleRuntimes: [Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public let createdDate: String?
        /// The description of the version.
        public let description: String?
        /// The ARN of the layer version.
        public let layerVersionArn: String?
        /// The layer's open-source license.
        public let licenseInfo: String?
        /// The version number.
        public let version: Int64?

        @inlinable
        public init(compatibleArchitectures: [Architecture]? = nil, compatibleRuntimes: [Runtime]? = nil, createdDate: String? = nil, description: String? = nil, layerVersionArn: String? = nil, licenseInfo: String? = nil, version: Int64? = nil) {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleArchitectures = "CompatibleArchitectures"
            case compatibleRuntimes = "CompatibleRuntimes"
            case createdDate = "CreatedDate"
            case description = "Description"
            case layerVersionArn = "LayerVersionArn"
            case licenseInfo = "LicenseInfo"
            case version = "Version"
        }
    }

    public struct LayersListItem: AWSDecodableShape {
        /// The newest version of the layer.
        public let latestMatchingVersion: LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public let layerArn: String?
        /// The name of the layer.
        public let layerName: String?

        @inlinable
        public init(latestMatchingVersion: LayerVersionsListItem? = nil, layerArn: String? = nil, layerName: String? = nil) {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }

        private enum CodingKeys: String, CodingKey {
            case latestMatchingVersion = "LatestMatchingVersion"
            case layerArn = "LayerArn"
            case layerName = "LayerName"
        }
    }

    public struct ListAliasesRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a function version to only list aliases that invoke that version.
        public let functionVersion: String?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Limit the number of aliases returned.
        public let maxItems: Int?

        @inlinable
        public init(functionName: String, functionVersion: String? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.functionVersion, key: "FunctionVersion")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, max: 1024)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, min: 1)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, pattern: "^(\\$LATEST|[0-9]+)$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAliasesResponse: AWSDecodableShape {
        /// A list of aliases.
        public let aliases: [AliasConfiguration]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        @inlinable
        public init(aliases: [AliasConfiguration]? = nil, nextMarker: String? = nil) {
            self.aliases = aliases
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListCodeSigningConfigsRequest: AWSEncodableShape {
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Maximum number of items to return.
        public let maxItems: Int?

        @inlinable
        public init(marker: String? = nil, maxItems: Int? = nil) {
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCodeSigningConfigsResponse: AWSDecodableShape {
        /// The code signing configurations
        public let codeSigningConfigs: [CodeSigningConfig]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        @inlinable
        public init(codeSigningConfigs: [CodeSigningConfig]? = nil, nextMarker: String? = nil) {
            self.codeSigningConfigs = codeSigningConfigs
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigs = "CodeSigningConfigs"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListEventSourceMappingsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the event source.    Amazon Kinesis – The ARN of the data stream or a stream consumer.    Amazon DynamoDB Streams – The ARN of the stream.    Amazon Simple Queue Service – The ARN of the queue.    Amazon Managed Streaming for Apache Kafka – The ARN of the cluster or the ARN of the VPC connection (for cross-account event source mappings).    Amazon MQ – The ARN of the broker.    Amazon DocumentDB – The ARN of the DocumentDB change stream.
        public let eventSourceArn: String?
        /// The name or ARN of the Lambda function.  Name formats     Function name – MyFunction.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.    Partial ARN – 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
        public let functionName: String?
        /// A pagination token returned by a previous call.
        public let marker: String?
        /// The maximum number of event source mappings to return. Note that ListEventSourceMappings returns a maximum of 100 items in each response, even if you set the number higher.
        public let maxItems: Int?

        @inlinable
        public init(eventSourceArn: String? = nil, functionName: String? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.eventSourceArn = eventSourceArn
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.eventSourceArn, key: "EventSourceArn")
            request.encodeQuery(self.functionName, key: "FunctionName")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.eventSourceArn, name: "eventSourceArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)$")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventSourceMappingsResponse: AWSDecodableShape {
        /// A list of event source mappings.
        public let eventSourceMappings: [EventSourceMappingConfiguration]?
        /// A pagination token that's returned when the response doesn't contain all event source mappings.
        public let nextMarker: String?

        @inlinable
        public init(eventSourceMappings: [EventSourceMappingConfiguration]? = nil, nextMarker: String? = nil) {
            self.eventSourceMappings = eventSourceMappings
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSourceMappings = "EventSourceMappings"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionEventInvokeConfigsRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - my-function.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// The maximum number of configurations to return.
        public let maxItems: Int?

        @inlinable
        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionEventInvokeConfigsResponse: AWSDecodableShape {
        /// A list of configurations.
        public let functionEventInvokeConfigs: [FunctionEventInvokeConfig]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        @inlinable
        public init(functionEventInvokeConfigs: [FunctionEventInvokeConfig]? = nil, nextMarker: String? = nil) {
            self.functionEventInvokeConfigs = functionEventInvokeConfigs
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functionEventInvokeConfigs = "FunctionEventInvokeConfigs"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionUrlConfigsRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// The maximum number of function URLs to return in the response. Note that ListFunctionUrlConfigs returns a maximum of 50 items in each response, even if you set the number higher.
        public let maxItems: Int?

        @inlinable
        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionUrlConfigsResponse: AWSDecodableShape {
        /// A list of function URL configurations.
        public let functionUrlConfigs: [FunctionUrlConfig]
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        @inlinable
        public init(functionUrlConfigs: [FunctionUrlConfig], nextMarker: String? = nil) {
            self.functionUrlConfigs = functionUrlConfigs
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functionUrlConfigs = "FunctionUrlConfigs"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionsByCodeSigningConfigRequest: AWSEncodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Maximum number of items to return.
        public let maxItems: Int?

        @inlinable
        public init(codeSigningConfigArn: String, marker: String? = nil, maxItems: Int? = nil) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeSigningConfigArn, key: "CodeSigningConfigArn")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionsByCodeSigningConfigResponse: AWSDecodableShape {
        /// The function ARNs.
        public let functionArns: [String]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        @inlinable
        public init(functionArns: [String]? = nil, nextMarker: String? = nil) {
            self.functionArns = functionArns
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functionArns = "FunctionArns"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFunctionsRequest: AWSEncodableShape {
        /// Set to ALL to include entries for all published versions of each function.
        public let functionVersion: FunctionVersion?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// For Lambda@Edge functions, the Amazon Web Services Region of the master function. For example, us-east-1 filters the list of functions to include only Lambda@Edge functions replicated from a master function in US East (N. Virginia). If specified, you must set FunctionVersion to ALL.
        public let masterRegion: SotoCore.Region?
        /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response, even if you set the number higher.
        public let maxItems: Int?

        @inlinable
        public init(functionVersion: FunctionVersion? = nil, marker: String? = nil, masterRegion: SotoCore.Region? = nil, maxItems: Int? = nil) {
            self.functionVersion = functionVersion
            self.marker = marker
            self.masterRegion = masterRegion
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.functionVersion, key: "FunctionVersion")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.masterRegion, key: "MasterRegion")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionsResponse: AWSDecodableShape {
        /// A list of Lambda functions.
        public let functions: [FunctionConfiguration]?
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?

        @inlinable
        public init(functions: [FunctionConfiguration]? = nil, nextMarker: String? = nil) {
            self.functions = functions
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "Functions"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListLayerVersionsRequest: AWSEncodableShape {
        /// The compatible
        /// instruction set architecture.
        public let compatibleArchitecture: Architecture?
        /// A runtime identifier. The following list includes deprecated runtimes. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let compatibleRuntime: Runtime?
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// A pagination token returned by a previous call.
        public let marker: String?
        /// The maximum number of versions to return.
        public let maxItems: Int?

        @inlinable
        public init(compatibleArchitecture: Architecture? = nil, compatibleRuntime: Runtime? = nil, layerName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.compatibleArchitecture = compatibleArchitecture
            self.compatibleRuntime = compatibleRuntime
            self.layerName = layerName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.compatibleArchitecture, key: "CompatibleArchitecture")
            request.encodeQuery(self.compatibleRuntime, key: "CompatibleRuntime")
            request.encodePath(self.layerName, key: "LayerName")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayerVersionsResponse: AWSDecodableShape {
        /// A list of versions.
        public let layerVersions: [LayerVersionsListItem]?
        /// A pagination token returned when the response doesn't contain all versions.
        public let nextMarker: String?

        @inlinable
        public init(layerVersions: [LayerVersionsListItem]? = nil, nextMarker: String? = nil) {
            self.layerVersions = layerVersions
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case layerVersions = "LayerVersions"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListLayersRequest: AWSEncodableShape {
        /// The compatible
        /// instruction set architecture.
        public let compatibleArchitecture: Architecture?
        /// A runtime identifier. The following list includes deprecated runtimes. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let compatibleRuntime: Runtime?
        /// A pagination token returned by a previous call.
        public let marker: String?
        /// The maximum number of layers to return.
        public let maxItems: Int?

        @inlinable
        public init(compatibleArchitecture: Architecture? = nil, compatibleRuntime: Runtime? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.compatibleArchitecture = compatibleArchitecture
            self.compatibleRuntime = compatibleRuntime
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.compatibleArchitecture, key: "CompatibleArchitecture")
            request.encodeQuery(self.compatibleRuntime, key: "CompatibleRuntime")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayersResponse: AWSDecodableShape {
        /// A list of function layers.
        public let layers: [LayersListItem]?
        /// A pagination token returned when the response doesn't contain all layers.
        public let nextMarker: String?

        @inlinable
        public init(layers: [LayersListItem]? = nil, nextMarker: String? = nil) {
            self.layers = layers
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case layers = "Layers"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListProvisionedConcurrencyConfigsRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// Specify a number to limit the number of configurations returned.
        public let maxItems: Int?

        @inlinable
        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 50)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisionedConcurrencyConfigsResponse: AWSDecodableShape {
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?
        /// A list of provisioned concurrency configurations.
        public let provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]?

        @inlinable
        public init(nextMarker: String? = nil, provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]? = nil) {
            self.nextMarker = nextMarker
            self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextMarker = "NextMarker"
            case provisionedConcurrencyConfigs = "ProvisionedConcurrencyConfigs"
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).  Note: Lambda does not support adding tags to function aliases or versions.
        public let resource: String

        @inlinable
        public init(resource: String) {
            self.resource = resource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resource, key: "Resource")
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, max: 256)
            try self.validate(self.resource, name: "resource", parent: name, min: 1)
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso([a-z]?)))?-[a-z]+-\\d{1}:\\d{12}:(function:[a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?|code-signing-config:csc-[a-z0-9]{17}|event-source-mapping:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// The function's tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVersionsByFunctionRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let marker: String?
        /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response,  even if you set the number higher.
        public let maxItems: Int?

        @inlinable
        public init(functionName: String, marker: String? = nil, maxItems: Int? = nil) {
            self.functionName = functionName
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 170)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 10000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVersionsByFunctionResponse: AWSDecodableShape {
        /// The pagination token that's included if more results are available.
        public let nextMarker: String?
        /// A list of Lambda function versions.
        public let versions: [FunctionConfiguration]?

        @inlinable
        public init(nextMarker: String? = nil, versions: [FunctionConfiguration]? = nil) {
            self.nextMarker = nextMarker
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextMarker = "NextMarker"
            case versions = "Versions"
        }
    }

    public struct LoggingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the  selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
        public let applicationLogLevel: ApplicationLogLevel?
        /// The format in which Lambda sends your function's application and system logs to CloudWatch. Select between  plain text and structured JSON.
        public let logFormat: LogFormat?
        /// The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default  log group named /aws/lambda/. To use a different log group, enter an existing log group or enter a new log group name.
        public let logGroup: String?
        /// Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the  selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
        public let systemLogLevel: SystemLogLevel?

        @inlinable
        public init(applicationLogLevel: ApplicationLogLevel? = nil, logFormat: LogFormat? = nil, logGroup: String? = nil, systemLogLevel: SystemLogLevel? = nil) {
            self.applicationLogLevel = applicationLogLevel
            self.logFormat = logFormat
            self.logGroup = logGroup
            self.systemLogLevel = systemLogLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroup, name: "logGroup", parent: name, max: 512)
            try self.validate(self.logGroup, name: "logGroup", parent: name, min: 1)
            try self.validate(self.logGroup, name: "logGroup", parent: name, pattern: "^[\\.\\-_/#A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogLevel = "ApplicationLogLevel"
            case logFormat = "LogFormat"
            case logGroup = "LogGroup"
            case systemLogLevel = "SystemLogLevel"
        }
    }

    public struct OnFailure: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination resource. To retain records of unsuccessful asynchronous invocations, you can configure an Amazon SNS topic, Amazon SQS queue, Amazon S3 bucket, Lambda function, or Amazon EventBridge event bus as the destination. To retain records of failed invocations from Kinesis,  DynamoDB, self-managed Kafka or Amazon MSK, you can configure an Amazon SNS topic, Amazon SQS queue, or Amazon S3 bucket as the destination.
        public let destination: String?

        @inlinable
        public init(destination: String? = nil) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 350)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct OnSuccess: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public let destination: String?

        @inlinable
        public init(destination: String? = nil) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 350)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct PolicyLengthExceededException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct PreconditionFailedException: AWSErrorShape {
        /// The exception message.
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct ProvisionedConcurrencyConfigListItem: AWSDecodableShape {
        /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
        public let allocatedProvisionedConcurrentExecutions: Int?
        /// The amount of provisioned concurrency available.
        public let availableProvisionedConcurrentExecutions: Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public let functionArn: String?
        /// The date and time that a user last updated the configuration, in ISO 8601 format.
        public let lastModified: String?
        /// The amount of provisioned concurrency requested.
        public let requestedProvisionedConcurrentExecutions: Int?
        /// The status of the allocation process.
        public let status: ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public let statusReason: String?

        @inlinable
        public init(allocatedProvisionedConcurrentExecutions: Int? = nil, availableProvisionedConcurrentExecutions: Int? = nil, functionArn: String? = nil, lastModified: String? = nil, requestedProvisionedConcurrentExecutions: Int? = nil, status: ProvisionedConcurrencyStatusEnum? = nil, statusReason: String? = nil) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
            case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
            case functionArn = "FunctionArn"
            case lastModified = "LastModified"
            case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct ProvisionedConcurrencyConfigNotFoundException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct ProvisionedPollerConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of event pollers this event source can scale up to.
        public let maximumPollers: Int?
        /// The minimum number of event pollers this event source can scale down to.
        public let minimumPollers: Int?

        @inlinable
        public init(maximumPollers: Int? = nil, minimumPollers: Int? = nil) {
            self.maximumPollers = maximumPollers
            self.minimumPollers = minimumPollers
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumPollers, name: "maximumPollers", parent: name, max: 2000)
            try self.validate(self.maximumPollers, name: "maximumPollers", parent: name, min: 1)
            try self.validate(self.minimumPollers, name: "minimumPollers", parent: name, max: 200)
            try self.validate(self.minimumPollers, name: "minimumPollers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumPollers = "MaximumPollers"
            case minimumPollers = "MinimumPollers"
        }
    }

    public struct PublishLayerVersionRequest: AWSEncodableShape {
        /// A list of compatible
        /// instruction set architectures.
        public let compatibleArchitectures: [Architecture]?
        /// A list of compatible function runtimes. Used for filtering with ListLayers and ListLayerVersions. The following list includes deprecated runtimes. For more information, see Runtime deprecation policy.
        public let compatibleRuntimes: [Runtime]?
        /// The function layer archive.
        public let content: LayerVersionContentInput
        /// The description of the version.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// The layer's software license. It can be any of the following:   An SPDX license identifier. For example, MIT.   The URL of a license hosted on the internet. For example, https://opensource.org/licenses/MIT.   The full text of the license.
        public let licenseInfo: String?

        @inlinable
        public init(compatibleArchitectures: [Architecture]? = nil, compatibleRuntimes: [Runtime]? = nil, content: LayerVersionContentInput, description: String? = nil, layerName: String, licenseInfo: String? = nil) {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.content = content
            self.description = description
            self.layerName = layerName
            self.licenseInfo = licenseInfo
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.compatibleArchitectures, forKey: .compatibleArchitectures)
            try container.encodeIfPresent(self.compatibleRuntimes, forKey: .compatibleRuntimes)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.layerName, key: "LayerName")
            try container.encodeIfPresent(self.licenseInfo, forKey: .licenseInfo)
        }

        public func validate(name: String) throws {
            try self.validate(self.compatibleArchitectures, name: "compatibleArchitectures", parent: name, max: 2)
            try self.validate(self.compatibleRuntimes, name: "compatibleRuntimes", parent: name, max: 15)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
            try self.validate(self.licenseInfo, name: "licenseInfo", parent: name, max: 512)
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleArchitectures = "CompatibleArchitectures"
            case compatibleRuntimes = "CompatibleRuntimes"
            case content = "Content"
            case description = "Description"
            case licenseInfo = "LicenseInfo"
        }
    }

    public struct PublishLayerVersionResponse: AWSDecodableShape {
        /// A list of compatible
        /// instruction set architectures.
        public let compatibleArchitectures: [Architecture]?
        /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let compatibleRuntimes: [Runtime]?
        /// Details about the layer version.
        public let content: LayerVersionContentOutput?
        /// The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let createdDate: String?
        /// The description of the version.
        public let description: String?
        /// The ARN of the layer.
        public let layerArn: String?
        /// The ARN of the layer version.
        public let layerVersionArn: String?
        /// The layer's software license.
        public let licenseInfo: String?
        /// The version number.
        public let version: Int64?

        @inlinable
        public init(compatibleArchitectures: [Architecture]? = nil, compatibleRuntimes: [Runtime]? = nil, content: LayerVersionContentOutput? = nil, createdDate: String? = nil, description: String? = nil, layerArn: String? = nil, layerVersionArn: String? = nil, licenseInfo: String? = nil, version: Int64? = nil) {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.content = content
            self.createdDate = createdDate
            self.description = description
            self.layerArn = layerArn
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleArchitectures = "CompatibleArchitectures"
            case compatibleRuntimes = "CompatibleRuntimes"
            case content = "Content"
            case createdDate = "CreatedDate"
            case description = "Description"
            case layerArn = "LayerArn"
            case layerVersionArn = "LayerVersionArn"
            case licenseInfo = "LicenseInfo"
            case version = "Version"
        }
    }

    public struct PublishVersionRequest: AWSEncodableShape {
        /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of UpdateFunctionCode.
        public let codeSha256: String?
        /// A description for the version to override the description in the function configuration.
        public let description: String?
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.
        public let revisionId: String?

        @inlinable
        public init(codeSha256: String? = nil, description: String? = nil, functionName: String, revisionId: String? = nil) {
            self.codeSha256 = codeSha256
            self.description = description
            self.functionName = functionName
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.codeSha256, forKey: .codeSha256)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeSha256 = "CodeSha256"
            case description = "Description"
            case revisionId = "RevisionId"
        }
    }

    public struct PutFunctionCodeSigningConfigRequest: AWSEncodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(codeSigningConfigArn: String, functionName: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.functionName = functionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.codeSigningConfigArn, forKey: .codeSigningConfigArn)
            request.encodePath(self.functionName, key: "FunctionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}$")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigArn = "CodeSigningConfigArn"
        }
    }

    public struct PutFunctionCodeSigningConfigResponse: AWSDecodableShape {
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String

        @inlinable
        public init(codeSigningConfigArn: String, functionName: String) {
            self.codeSigningConfigArn = codeSigningConfigArn
            self.functionName = functionName
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfigArn = "CodeSigningConfigArn"
            case functionName = "FunctionName"
        }
    }

    public struct PutFunctionConcurrencyRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The number of simultaneous executions to reserve for the function.
        public let reservedConcurrentExecutions: Int

        @inlinable
        public init(functionName: String, reservedConcurrentExecutions: Int) {
            self.functionName = functionName
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encode(self.reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.reservedConcurrentExecutions, name: "reservedConcurrentExecutions", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
        }
    }

    public struct PutFunctionEventInvokeConfigRequest: AWSEncodableShape {
        /// A destination for events after they have been sent to a function for processing.  Destinations     Function - The Amazon Resource Name (ARN) of a Lambda function.    Queue - The ARN of a standard SQS queue.    Bucket - The ARN of an Amazon S3 bucket.    Topic - The ARN of a standard SNS topic.    Event Bus - The ARN of an Amazon EventBridge event bus.    S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
        public let destinationConfig: DestinationConfig?
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The maximum age of a request that Lambda sends to a function for processing.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of times to retry when the function returns an error.
        public let maximumRetryAttempts: Int?
        /// A version number or alias name.
        public let qualifier: String?

        @inlinable
        public init(destinationConfig: DestinationConfig? = nil, functionName: String, maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, qualifier: String? = nil) {
            self.destinationConfig = destinationConfig
            self.functionName = functionName
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.destinationConfig, forKey: .destinationConfig)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
            try container.encodeIfPresent(self.maximumRetryAttempts, forKey: .maximumRetryAttempts)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, max: 21600)
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, min: 60)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 2)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: 0)
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfig = "DestinationConfig"
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct PutFunctionRecursionConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// If you set your function's recursive loop detection configuration to Allow, Lambda doesn't take any action when it  detects your function being invoked as part of a recursive loop. We recommend that you only use this setting if your design intentionally uses a  Lambda function to write data back to the same Amazon Web Services resource that invokes it. If you set your function's recursive loop detection configuration to Terminate, Lambda stops your function being  invoked and notifies you when it detects your function being invoked as part of a recursive loop. By default, Lambda sets your function's configuration to Terminate.  If your design intentionally uses a Lambda function to write data back to the same Amazon Web Services resource that invokes the function, then use caution and implement suitable guard rails to prevent unexpected charges being billed to your Amazon Web Services account. To learn more about best practices for using recursive invocation patterns, see Recursive patterns that cause run-away Lambda functions in Serverless Land.
        public let recursiveLoop: RecursiveLoop

        @inlinable
        public init(functionName: String, recursiveLoop: RecursiveLoop) {
            self.functionName = functionName
            self.recursiveLoop = recursiveLoop
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encode(self.recursiveLoop, forKey: .recursiveLoop)
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}((-gov)|(-iso([a-z]?)))?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case recursiveLoop = "RecursiveLoop"
        }
    }

    public struct PutFunctionRecursionConfigResponse: AWSDecodableShape {
        /// The status of your function's recursive loop detection configuration. When this value is set to Allowand Lambda detects your function being invoked as part of a recursive  loop, it doesn't take any action. When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive  loop, it stops your function being invoked and notifies you.
        public let recursiveLoop: RecursiveLoop?

        @inlinable
        public init(recursiveLoop: RecursiveLoop? = nil) {
            self.recursiveLoop = recursiveLoop
        }

        private enum CodingKeys: String, CodingKey {
            case recursiveLoop = "RecursiveLoop"
        }
    }

    public struct PutProvisionedConcurrencyConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The amount of provisioned concurrency to allocate for the version or alias.
        public let provisionedConcurrentExecutions: Int
        /// The version number or alias name.
        public let qualifier: String

        @inlinable
        public init(functionName: String, provisionedConcurrentExecutions: Int, qualifier: String) {
            self.functionName = functionName
            self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encode(self.provisionedConcurrentExecutions, forKey: .provisionedConcurrentExecutions)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.provisionedConcurrentExecutions, name: "provisionedConcurrentExecutions", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
        }
    }

    public struct PutProvisionedConcurrencyConfigResponse: AWSDecodableShape {
        /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
        public let allocatedProvisionedConcurrentExecutions: Int?
        /// The amount of provisioned concurrency available.
        public let availableProvisionedConcurrentExecutions: Int?
        /// The date and time that a user last updated the configuration, in ISO 8601 format.
        public let lastModified: String?
        /// The amount of provisioned concurrency requested.
        public let requestedProvisionedConcurrentExecutions: Int?
        /// The status of the allocation process.
        public let status: ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public let statusReason: String?

        @inlinable
        public init(allocatedProvisionedConcurrentExecutions: Int? = nil, availableProvisionedConcurrentExecutions: Int? = nil, lastModified: String? = nil, requestedProvisionedConcurrentExecutions: Int? = nil, status: ProvisionedConcurrencyStatusEnum? = nil, statusReason: String? = nil) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
            case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
            case lastModified = "LastModified"
            case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct PutRuntimeManagementConfigRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the  $LATEST version is returned.
        public let qualifier: String?
        /// The ARN of the runtime version you want the function to use.  This is only required if you're using the Manual runtime update mode.
        public let runtimeVersionArn: String?
        /// Specify the runtime update mode.    Auto (default) - Automatically update to the most recent and secure runtime version using a Two-phase runtime version rollout. This is the best  choice for most customers to ensure they always benefit from runtime updates.    Function update - Lambda updates the runtime of your function  to the most recent and secure runtime version when you update your  function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and  mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.    Manual - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely.  In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information,  see Roll back a runtime version.
        public let updateRuntimeOn: UpdateRuntimeOn

        @inlinable
        public init(functionName: String, qualifier: String? = nil, runtimeVersionArn: String? = nil, updateRuntimeOn: UpdateRuntimeOn) {
            self.functionName = functionName
            self.qualifier = qualifier
            self.runtimeVersionArn = runtimeVersionArn
            self.updateRuntimeOn = updateRuntimeOn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
            try container.encodeIfPresent(self.runtimeVersionArn, forKey: .runtimeVersionArn)
            try container.encode(self.updateRuntimeOn, forKey: .updateRuntimeOn)
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
            try self.validate(self.runtimeVersionArn, name: "runtimeVersionArn", parent: name, max: 2048)
            try self.validate(self.runtimeVersionArn, name: "runtimeVersionArn", parent: name, min: 26)
            try self.validate(self.runtimeVersionArn, name: "runtimeVersionArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}::runtime:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeVersionArn = "RuntimeVersionArn"
            case updateRuntimeOn = "UpdateRuntimeOn"
        }
    }

    public struct PutRuntimeManagementConfigResponse: AWSDecodableShape {
        /// The ARN of the function
        public let functionArn: String
        /// The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null  is returned.
        public let runtimeVersionArn: String?
        /// The runtime update mode.
        public let updateRuntimeOn: UpdateRuntimeOn

        @inlinable
        public init(functionArn: String, runtimeVersionArn: String? = nil, updateRuntimeOn: UpdateRuntimeOn) {
            self.functionArn = functionArn
            self.runtimeVersionArn = runtimeVersionArn
            self.updateRuntimeOn = updateRuntimeOn
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
            case runtimeVersionArn = "RuntimeVersionArn"
            case updateRuntimeOn = "UpdateRuntimeOn"
        }
    }

    public struct RecursiveInvocationException: AWSErrorShape {
        /// The exception message.
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct RemoveLayerVersionPermissionRequest: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the layer.
        public let layerName: String
        /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// The identifier that was specified when the statement was added.
        public let statementId: String
        /// The version number.
        public let versionNumber: Int64

        @inlinable
        public init(layerName: String, revisionId: String? = nil, statementId: String, versionNumber: Int64) {
            self.layerName = layerName
            self.revisionId = revisionId
            self.statementId = statementId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.layerName, key: "LayerName")
            request.encodeQuery(self.revisionId, key: "RevisionId")
            request.encodePath(self.statementId, key: "StatementId")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.layerName, name: "layerName", parent: name, max: 140)
            try self.validate(self.layerName, name: "layerName", parent: name, min: 1)
            try self.validate(self.layerName, name: "layerName", parent: name, pattern: "^(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^([a-zA-Z0-9-_]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemovePermissionRequest: AWSEncodableShape {
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name – my-function (name-only), my-function:v1 (with alias).    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Specify a version or alias to remove permissions from a published version of the function.
        public let qualifier: String?
        /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
        public let revisionId: String?
        /// Statement ID of the permission to remove.
        public let statementId: String

        @inlinable
        public init(functionName: String, qualifier: String? = nil, revisionId: String? = nil, statementId: String) {
            self.functionName = functionName
            self.qualifier = qualifier
            self.revisionId = revisionId
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionName, key: "FunctionName")
            request.encodeQuery(self.qualifier, key: "Qualifier")
            request.encodeQuery(self.revisionId, key: "RevisionId")
            request.encodePath(self.statementId, key: "StatementId")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^([a-zA-Z0-9-_.]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RequestTooLargeException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct ResourceConflictException: AWSErrorShape {
        /// The exception message.
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct ResourceInUseException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ResourceNotReadyException: AWSErrorShape {
        /// The exception message.
        public let message: String?
        /// The exception type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct RuntimeVersionConfig: AWSDecodableShape {
        /// Error response when Lambda is unable to retrieve the runtime version for a function.
        public let error: RuntimeVersionError?
        /// The ARN of the runtime version you want the function to use.
        public let runtimeVersionArn: String?

        @inlinable
        public init(error: RuntimeVersionError? = nil, runtimeVersionArn: String? = nil) {
            self.error = error
            self.runtimeVersionArn = runtimeVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case runtimeVersionArn = "RuntimeVersionArn"
        }
    }

    public struct RuntimeVersionError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ScalingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Limits the number of concurrent instances that the Amazon SQS event source can invoke.
        public let maximumConcurrency: Int?

        @inlinable
        public init(maximumConcurrency: Int? = nil) {
            self.maximumConcurrency = maximumConcurrency
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumConcurrency, name: "maximumConcurrency", parent: name, max: 1000)
            try self.validate(self.maximumConcurrency, name: "maximumConcurrency", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumConcurrency = "MaximumConcurrency"
        }
    }

    public struct SelfManagedEventSource: AWSEncodableShape & AWSDecodableShape {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public let endpoints: [EndPointType: [String]]?

        @inlinable
        public init(endpoints: [EndPointType: [String]]? = nil) {
            self.endpoints = endpoints
        }

        public func validate(name: String) throws {
            try self.endpoints?.forEach {
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, max: 10)
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 2)
            try self.validate(self.endpoints, name: "endpoints", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct SelfManagedKafkaEventSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see Customizable consumer group ID.
        public let consumerGroupId: String?

        @inlinable
        public init(consumerGroupId: String? = nil) {
            self.consumerGroupId = consumerGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerGroupId, name: "consumerGroupId", parent: name, max: 200)
            try self.validate(self.consumerGroupId, name: "consumerGroupId", parent: name, min: 1)
            try self.validate(self.consumerGroupId, name: "consumerGroupId", parent: name, pattern: "^[a-zA-Z0-9-\\/*:_+=.@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupId = "ConsumerGroupId"
        }
    }

    public struct ServiceException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct SnapStart: AWSEncodableShape {
        /// Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
        public let applyOn: SnapStartApplyOn?

        @inlinable
        public init(applyOn: SnapStartApplyOn? = nil) {
            self.applyOn = applyOn
        }

        private enum CodingKeys: String, CodingKey {
            case applyOn = "ApplyOn"
        }
    }

    public struct SnapStartException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct SnapStartNotReadyException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct SnapStartResponse: AWSDecodableShape {
        /// When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        public let applyOn: SnapStartApplyOn?
        /// When you provide a qualified Amazon Resource Name (ARN), this response element indicates whether SnapStart is activated for the specified function version.
        public let optimizationStatus: SnapStartOptimizationStatus?

        @inlinable
        public init(applyOn: SnapStartApplyOn? = nil, optimizationStatus: SnapStartOptimizationStatus? = nil) {
            self.applyOn = applyOn
            self.optimizationStatus = optimizationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case applyOn = "ApplyOn"
            case optimizationStatus = "OptimizationStatus"
        }
    }

    public struct SnapStartTimeoutException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct SourceAccessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".    BASIC_AUTH – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.    BASIC_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.    VPC_SUBNET – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.    VPC_SECURITY_GROUP – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.    SASL_SCRAM_256_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.    SASL_SCRAM_512_AUTH – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.    VIRTUAL_HOST –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source.  This property cannot be specified in an UpdateEventSourceMapping API call.    CLIENT_CERTIFICATE_TLS_AUTH – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM),  private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.    SERVER_ROOT_CA_CERTIFICATE – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        public let type: SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public let uri: String?

        @inlinable
        public init(type: SourceAccessType? = nil, uri: String? = nil) {
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 200)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^[a-zA-Z0-9-\\/*:_+=.@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case uri = "URI"
        }
    }

    public struct SubnetIPAddressLimitReachedException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resource: String
        /// A list of tags to apply to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resource: String, tags: [String: String]) {
            self.resource = resource
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resource, key: "Resource")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, max: 256)
            try self.validate(self.resource, name: "resource", parent: name, min: 1)
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso([a-z]?)))?-[a-z]+-\\d{1}:\\d{12}:(function:[a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?|code-signing-config:csc-[a-z0-9]{17}|event-source-mapping:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagsError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String
        /// The error message.
        public let message: String

        @inlinable
        public init(errorCode: String, message: String) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct TooManyRequestsException: AWSErrorShape {
        public let message: String?
        public let reason: ThrottleReason?
        /// The number of seconds the caller should wait before retrying.
        public let retryAfterSeconds: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, reason: ThrottleReason? = nil, retryAfterSeconds: String? = nil, type: String? = nil) {
            self.message = message
            self.reason = reason
            self.retryAfterSeconds = retryAfterSeconds
            self.type = type
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.reason = try container.decodeIfPresent(ThrottleReason.self, forKey: .reason)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(String.self, key: "Retry-After")
            self.type = try container.decodeIfPresent(String.self, forKey: .type)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "Reason"
            case type = "Type"
        }
    }

    public struct TracingConfig: AWSEncodableShape {
        /// The tracing mode.
        public let mode: TracingMode?

        @inlinable
        public init(mode: TracingMode? = nil) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct TracingConfigResponse: AWSDecodableShape {
        /// The tracing mode.
        public let mode: TracingMode?

        @inlinable
        public init(mode: TracingMode? = nil) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct UnsupportedMediaTypeException: AWSErrorShape {
        public let message: String?
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "Type"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resource: String
        /// A list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resource: String, tagKeys: [String]) {
            self.resource = resource
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resource, key: "Resource")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, max: 256)
            try self.validate(self.resource, name: "resource", parent: name, min: 1)
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso([a-z]?)))?-[a-z]+-\\d{1}:\\d{12}:(function:[a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?|code-signing-config:csc-[a-z0-9]{17}|event-source-mapping:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateAliasRequest: AWSEncodableShape {
        /// A description of the alias.
        public let description: String?
        /// The name or ARN of the Lambda function.  Name formats     Function name - MyFunction.    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Partial ARN - 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The function version that the alias invokes.
        public let functionVersion: String?
        /// The name of the alias.
        public let name: String
        /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.
        public let revisionId: String?
        /// The routing configuration of the alias.
        public let routingConfig: AliasRoutingConfiguration?

        @inlinable
        public init(description: String? = nil, functionName: String, functionVersion: String? = nil, name: String, revisionId: String? = nil, routingConfig: AliasRoutingConfiguration? = nil) {
            self.description = description
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.functionVersion, forKey: .functionVersion)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.routingConfig, forKey: .routingConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, max: 1024)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, min: 1)
            try self.validate(self.functionVersion, name: "functionVersion", parent: name, pattern: "^(\\$LATEST|[0-9]+)$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_]+)$")
            try self.routingConfig?.validate(name: "\(name).routingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case functionVersion = "FunctionVersion"
            case revisionId = "RevisionId"
            case routingConfig = "RoutingConfig"
        }
    }

    public struct UpdateCodeSigningConfigRequest: AWSEncodableShape {
        /// Signing profiles for this code signing configuration.
        public let allowedPublishers: AllowedPublishers?
        /// The The Amazon Resource Name (ARN) of the code signing configuration.
        public let codeSigningConfigArn: String
        /// The code signing policy.
        public let codeSigningPolicies: CodeSigningPolicies?
        /// Descriptive name for this code signing configuration.
        public let description: String?

        @inlinable
        public init(allowedPublishers: AllowedPublishers? = nil, codeSigningConfigArn: String, codeSigningPolicies: CodeSigningPolicies? = nil, description: String? = nil) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedPublishers, forKey: .allowedPublishers)
            request.encodePath(self.codeSigningConfigArn, key: "CodeSigningConfigArn")
            try container.encodeIfPresent(self.codeSigningPolicies, forKey: .codeSigningPolicies)
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.allowedPublishers?.validate(name: "\(name).allowedPublishers")
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, max: 200)
            try self.validate(self.codeSigningConfigArn, name: "codeSigningConfigArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPublishers = "AllowedPublishers"
            case codeSigningPolicies = "CodeSigningPolicies"
            case description = "Description"
        }
    }

    public struct UpdateCodeSigningConfigResponse: AWSDecodableShape {
        /// The code signing configuration
        public let codeSigningConfig: CodeSigningConfig

        @inlinable
        public init(codeSigningConfig: CodeSigningConfig) {
            self.codeSigningConfig = codeSigningConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeSigningConfig = "CodeSigningConfig"
        }
    }

    public struct UpdateEventSourceMappingRequest: AWSEncodableShape {
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).    Amazon Kinesis – Default 100. Max 10,000.    Amazon DynamoDB Streams – Default 100. Max 10,000.    Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.    Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.    Self-managed Apache Kafka – Default 100. Max 10,000.    Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.    DocumentDB – Default 100. Max 10,000.
        public let batchSize: Int?
        /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.
        public let bisectBatchOnFunctionError: Bool?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Kafka only) A configuration object that specifies the destination of an event after Lambda processes it.
        public let destinationConfig: DestinationConfig?
        /// Specific configuration settings for a DocumentDB event source.
        public let documentDBEventSourceConfig: DocumentDBEventSourceConfig?
        /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
        public let enabled: Bool?
        /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see Lambda event filtering.
        public let filterCriteria: FilterCriteria?
        /// The name or ARN of the Lambda function.  Name formats     Function name – MyFunction.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.    Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.    Partial ARN – 123456789012:function:MyFunction.   The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
        public let functionName: String?
        /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
        public let functionResponseTypes: [FunctionResponseType]?
        ///  The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's filter criteria. By default, Lambda does not encrypt your filter criteria object. Specify this property to encrypt data using your own customer managed key.
        public let kmsKeyArn: String?
        /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For Kinesis, DynamoDB, and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public let maximumBatchingWindowInSeconds: Int?
        /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).
        public let maximumRecordAgeInSeconds: Int?
        /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
        public let maximumRetryAttempts: Int?
        /// The metrics configuration for your event source. For more information, see Event source mapping metrics.
        public let metricsConfig: EventSourceMappingMetricsConfig?
        /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
        public let parallelizationFactor: Int?
        /// (Amazon MSK and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see provisioned mode.
        public let provisionedPollerConfig: ProvisionedPollerConfig?
        /// (Amazon SQS only) The scaling configuration for the event source. For more information, see Configuring maximum concurrency for Amazon SQS event sources.
        public let scalingConfig: ScalingConfig?
        /// An array of authentication protocols or VPC components required to secure your event source.
        public let sourceAccessConfigurations: [SourceAccessConfiguration]?
        /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
        public let tumblingWindowInSeconds: Int?
        /// The identifier of the event source mapping.
        public let uuid: String

        @inlinable
        public init(batchSize: Int? = nil, bisectBatchOnFunctionError: Bool? = nil, destinationConfig: DestinationConfig? = nil, documentDBEventSourceConfig: DocumentDBEventSourceConfig? = nil, enabled: Bool? = nil, filterCriteria: FilterCriteria? = nil, functionName: String? = nil, functionResponseTypes: [FunctionResponseType]? = nil, kmsKeyArn: String? = nil, maximumBatchingWindowInSeconds: Int? = nil, maximumRecordAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, metricsConfig: EventSourceMappingMetricsConfig? = nil, parallelizationFactor: Int? = nil, provisionedPollerConfig: ProvisionedPollerConfig? = nil, scalingConfig: ScalingConfig? = nil, sourceAccessConfigurations: [SourceAccessConfiguration]? = nil, tumblingWindowInSeconds: Int? = nil, uuid: String) {
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.documentDBEventSourceConfig = documentDBEventSourceConfig
            self.enabled = enabled
            self.filterCriteria = filterCriteria
            self.functionName = functionName
            self.functionResponseTypes = functionResponseTypes
            self.kmsKeyArn = kmsKeyArn
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.metricsConfig = metricsConfig
            self.parallelizationFactor = parallelizationFactor
            self.provisionedPollerConfig = provisionedPollerConfig
            self.scalingConfig = scalingConfig
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.batchSize, forKey: .batchSize)
            try container.encodeIfPresent(self.bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
            try container.encodeIfPresent(self.destinationConfig, forKey: .destinationConfig)
            try container.encodeIfPresent(self.documentDBEventSourceConfig, forKey: .documentDBEventSourceConfig)
            try container.encodeIfPresent(self.enabled, forKey: .enabled)
            try container.encodeIfPresent(self.filterCriteria, forKey: .filterCriteria)
            try container.encodeIfPresent(self.functionName, forKey: .functionName)
            try container.encodeIfPresent(self.functionResponseTypes, forKey: .functionResponseTypes)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            try container.encodeIfPresent(self.maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
            try container.encodeIfPresent(self.maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
            try container.encodeIfPresent(self.maximumRetryAttempts, forKey: .maximumRetryAttempts)
            try container.encodeIfPresent(self.metricsConfig, forKey: .metricsConfig)
            try container.encodeIfPresent(self.parallelizationFactor, forKey: .parallelizationFactor)
            try container.encodeIfPresent(self.provisionedPollerConfig, forKey: .provisionedPollerConfig)
            try container.encodeIfPresent(self.scalingConfig, forKey: .scalingConfig)
            try container.encodeIfPresent(self.sourceAccessConfigurations, forKey: .sourceAccessConfigurations)
            try container.encodeIfPresent(self.tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
            request.encodePath(self.uuid, key: "UUID")
        }

        public func validate(name: String) throws {
            try self.validate(self.batchSize, name: "batchSize", parent: name, max: 10000)
            try self.validate(self.batchSize, name: "batchSize", parent: name, min: 1)
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.documentDBEventSourceConfig?.validate(name: "\(name).documentDBEventSourceConfig")
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.functionResponseTypes, name: "functionResponseTypes", parent: name, max: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, max: 300)
            try self.validate(self.maximumBatchingWindowInSeconds, name: "maximumBatchingWindowInSeconds", parent: name, min: 0)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, max: 604800)
            try self.validate(self.maximumRecordAgeInSeconds, name: "maximumRecordAgeInSeconds", parent: name, min: -1)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 10000)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: -1)
            try self.metricsConfig?.validate(name: "\(name).metricsConfig")
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, max: 10)
            try self.validate(self.parallelizationFactor, name: "parallelizationFactor", parent: name, min: 1)
            try self.provisionedPollerConfig?.validate(name: "\(name).provisionedPollerConfig")
            try self.scalingConfig?.validate(name: "\(name).scalingConfig")
            try self.sourceAccessConfigurations?.forEach {
                try $0.validate(name: "\(name).sourceAccessConfigurations[]")
            }
            try self.validate(self.sourceAccessConfigurations, name: "sourceAccessConfigurations", parent: name, max: 22)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, max: 900)
            try self.validate(self.tumblingWindowInSeconds, name: "tumblingWindowInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
            case destinationConfig = "DestinationConfig"
            case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
            case enabled = "Enabled"
            case filterCriteria = "FilterCriteria"
            case functionName = "FunctionName"
            case functionResponseTypes = "FunctionResponseTypes"
            case kmsKeyArn = "KMSKeyArn"
            case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
            case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
            case metricsConfig = "MetricsConfig"
            case parallelizationFactor = "ParallelizationFactor"
            case provisionedPollerConfig = "ProvisionedPollerConfig"
            case scalingConfig = "ScalingConfig"
            case sourceAccessConfigurations = "SourceAccessConfigurations"
            case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        }
    }

    public struct UpdateFunctionCodeRequest: AWSEncodableShape {
        /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
        public let architectures: [Architecture]?
        /// Set to true to validate the request parameters and access permissions without modifying the function code.
        public let dryRun: Bool?
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// URI of a container image in the Amazon ECR registry. Do not use for a function defined with a .zip file archive.
        public let imageUri: String?
        /// Set to true to publish a new version of the function after updating the code. This has the same effect as calling PublishVersion separately.
        public let publish: Bool?
        /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
        public let revisionId: String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different
        /// Amazon Web Services account. Use only with a function defined with a .zip file archive deployment package.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package. Use only with a function defined with a .zip file archive deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's  .zip deployment package. If you don't provide a customer managed key, Lambda uses an Amazon Web Services managed key.
        public let sourceKMSKeyArn: String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients
        /// handle the encoding for you. Use only with a function defined with a .zip file archive deployment package.
        public let zipFile: AWSBase64Data?

        @inlinable
        public init(architectures: [Architecture]? = nil, dryRun: Bool? = nil, functionName: String, imageUri: String? = nil, publish: Bool? = nil, revisionId: String? = nil, s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, sourceKMSKeyArn: String? = nil, zipFile: AWSBase64Data? = nil) {
            self.architectures = architectures
            self.dryRun = dryRun
            self.functionName = functionName
            self.imageUri = imageUri
            self.publish = publish
            self.revisionId = revisionId
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.sourceKMSKeyArn = sourceKMSKeyArn
            self.zipFile = zipFile
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.architectures, forKey: .architectures)
            try container.encodeIfPresent(self.dryRun, forKey: .dryRun)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.imageUri, forKey: .imageUri)
            try container.encodeIfPresent(self.publish, forKey: .publish)
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.s3Bucket, forKey: .s3Bucket)
            try container.encodeIfPresent(self.s3Key, forKey: .s3Key)
            try container.encodeIfPresent(self.s3ObjectVersion, forKey: .s3ObjectVersion)
            try container.encodeIfPresent(self.sourceKMSKeyArn, forKey: .sourceKMSKeyArn)
            try container.encodeIfPresent(self.zipFile, forKey: .zipFile)
        }

        public func validate(name: String) throws {
            try self.validate(self.architectures, name: "architectures", parent: name, max: 1)
            try self.validate(self.architectures, name: "architectures", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*(?<!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1024)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
            try self.validate(self.sourceKMSKeyArn, name: "sourceKMSKeyArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "Architectures"
            case dryRun = "DryRun"
            case imageUri = "ImageUri"
            case publish = "Publish"
            case revisionId = "RevisionId"
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case sourceKMSKeyArn = "SourceKMSKeyArn"
            case zipFile = "ZipFile"
        }
    }

    public struct UpdateFunctionConfigurationRequest: AWSEncodableShape {
        /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues.
        public let deadLetterConfig: DeadLetterConfig?
        /// A description of the function.
        public let description: String?
        /// Environment variables that are accessible from function code during execution.
        public let environment: Environment?
        /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
        public let ephemeralStorage: EphemeralStorage?
        /// Connection settings for an Amazon EFS file system.
        public let fileSystemConfigs: [FileSystemConfig]?
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The name of the method within your code that Lambda calls to run your function.
        /// Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model.
        public let handler: String?
        ///  Container image configuration values that override the values in the container image Docker file.
        public let imageConfig: ImageConfig?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:   The function's environment variables.   The function's Lambda SnapStart snapshots.   When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see
        /// Specifying a customer managed key for Lambda.   The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.   If you don't provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key.
        public let kmsKeyArn: String?
        /// A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.
        public let layers: [String]?
        /// The function's Amazon CloudWatch Logs configuration settings.
        public let loggingConfig: LoggingConfig?
        /// The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
        public let memorySize: Int?
        /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
        public let revisionId: String?
        /// The Amazon Resource Name (ARN) of the function's execution role.
        public let role: String?
        /// The identifier of the function's  runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation. For a list of all currently supported runtimes, see Supported runtimes.
        public let runtime: Runtime?
        /// The function's SnapStart setting.
        public let snapStart: SnapStart?
        /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
        public let timeout: Int?
        /// Set Mode to Active to sample and trace a subset of incoming requests with
        /// X-Ray.
        public let tracingConfig: TracingConfig?
        /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(deadLetterConfig: DeadLetterConfig? = nil, description: String? = nil, environment: Environment? = nil, ephemeralStorage: EphemeralStorage? = nil, fileSystemConfigs: [FileSystemConfig]? = nil, functionName: String, handler: String? = nil, imageConfig: ImageConfig? = nil, kmsKeyArn: String? = nil, layers: [String]? = nil, loggingConfig: LoggingConfig? = nil, memorySize: Int? = nil, revisionId: String? = nil, role: String? = nil, runtime: Runtime? = nil, snapStart: SnapStart? = nil, timeout: Int? = nil, tracingConfig: TracingConfig? = nil, vpcConfig: VpcConfig? = nil) {
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.ephemeralStorage = ephemeralStorage
            self.fileSystemConfigs = fileSystemConfigs
            self.functionName = functionName
            self.handler = handler
            self.imageConfig = imageConfig
            self.kmsKeyArn = kmsKeyArn
            self.layers = layers
            self.loggingConfig = loggingConfig
            self.memorySize = memorySize
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.snapStart = snapStart
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.vpcConfig = vpcConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deadLetterConfig, forKey: .deadLetterConfig)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.environment, forKey: .environment)
            try container.encodeIfPresent(self.ephemeralStorage, forKey: .ephemeralStorage)
            try container.encodeIfPresent(self.fileSystemConfigs, forKey: .fileSystemConfigs)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.handler, forKey: .handler)
            try container.encodeIfPresent(self.imageConfig, forKey: .imageConfig)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            try container.encodeIfPresent(self.layers, forKey: .layers)
            try container.encodeIfPresent(self.loggingConfig, forKey: .loggingConfig)
            try container.encodeIfPresent(self.memorySize, forKey: .memorySize)
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.role, forKey: .role)
            try container.encodeIfPresent(self.runtime, forKey: .runtime)
            try container.encodeIfPresent(self.snapStart, forKey: .snapStart)
            try container.encodeIfPresent(self.timeout, forKey: .timeout)
            try container.encodeIfPresent(self.tracingConfig, forKey: .tracingConfig)
            try container.encodeIfPresent(self.vpcConfig, forKey: .vpcConfig)
        }

        public func validate(name: String) throws {
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.environment?.validate(name: "\(name).environment")
            try self.ephemeralStorage?.validate(name: "\(name).ephemeralStorage")
            try self.fileSystemConfigs?.forEach {
                try $0.validate(name: "\(name).fileSystemConfigs[]")
            }
            try self.validate(self.fileSystemConfigs, name: "fileSystemConfigs", parent: name, max: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.handler, name: "handler", parent: name, max: 128)
            try self.validate(self.handler, name: "handler", parent: name, pattern: "^[^\\s]+$")
            try self.imageConfig?.validate(name: "\(name).imageConfig")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$")
            try self.layers?.forEach {
                try validate($0, name: "layers[]", parent: name, max: 140)
                try validate($0, name: "layers[]", parent: name, min: 1)
                try validate($0, name: "layers[]", parent: name, pattern: "^arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+$")
            }
            try self.loggingConfig?.validate(name: "\(name).loggingConfig")
            try self.validate(self.memorySize, name: "memorySize", parent: name, max: 10240)
            try self.validate(self.memorySize, name: "memorySize", parent: name, min: 128)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterConfig = "DeadLetterConfig"
            case description = "Description"
            case environment = "Environment"
            case ephemeralStorage = "EphemeralStorage"
            case fileSystemConfigs = "FileSystemConfigs"
            case handler = "Handler"
            case imageConfig = "ImageConfig"
            case kmsKeyArn = "KMSKeyArn"
            case layers = "Layers"
            case loggingConfig = "LoggingConfig"
            case memorySize = "MemorySize"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case snapStart = "SnapStart"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct UpdateFunctionEventInvokeConfigRequest: AWSEncodableShape {
        /// A destination for events after they have been sent to a function for processing.  Destinations     Function - The Amazon Resource Name (ARN) of a Lambda function.    Queue - The ARN of a standard SQS queue.    Bucket - The ARN of an Amazon S3 bucket.    Topic - The ARN of a standard SNS topic.    Event Bus - The ARN of an Amazon EventBridge event bus.    S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
        public let destinationConfig: DestinationConfig?
        /// The name or ARN of the Lambda function, version, or alias.  Name formats     Function name - my-function (name-only), my-function:v1 (with alias).    Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN - 123456789012:function:my-function.   You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// The maximum age of a request that Lambda sends to a function for processing.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of times to retry when the function returns an error.
        public let maximumRetryAttempts: Int?
        /// A version number or alias name.
        public let qualifier: String?

        @inlinable
        public init(destinationConfig: DestinationConfig? = nil, functionName: String, maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil, qualifier: String? = nil) {
            self.destinationConfig = destinationConfig
            self.functionName = functionName
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.destinationConfig, forKey: .destinationConfig)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
            try container.encodeIfPresent(self.maximumRetryAttempts, forKey: .maximumRetryAttempts)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.destinationConfig?.validate(name: "\(name).destinationConfig")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, max: 21600)
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, min: 60)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 2)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: 0)
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(|[a-zA-Z0-9$_-]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfig = "DestinationConfig"
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct UpdateFunctionUrlConfigRequest: AWSEncodableShape {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let authType: FunctionUrlAuthType?
        /// The cross-origin resource sharing (CORS) settings for your function URL.
        public let cors: Cors?
        /// The name or ARN of the Lambda function.  Name formats     Function name – my-function.    Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.    Partial ARN – 123456789012:function:my-function.   The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
        public let functionName: String
        /// Use one of the following options:    BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results  are available when the payload is complete. The maximum payload size is 6 MB.    RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using  the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase.
        public let invokeMode: InvokeMode?
        /// The alias name.
        public let qualifier: String?

        @inlinable
        public init(authType: FunctionUrlAuthType? = nil, cors: Cors? = nil, functionName: String, invokeMode: InvokeMode? = nil, qualifier: String? = nil) {
            self.authType = authType
            self.cors = cors
            self.functionName = functionName
            self.invokeMode = invokeMode
            self.qualifier = qualifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authType, forKey: .authType)
            try container.encodeIfPresent(self.cors, forKey: .cors)
            request.encodePath(self.functionName, key: "FunctionName")
            try container.encodeIfPresent(self.invokeMode, forKey: .invokeMode)
            request.encodeQuery(self.qualifier, key: "Qualifier")
        }

        public func validate(name: String) throws {
            try self.cors?.validate(name: "\(name).cors")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 140)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.validate(self.qualifier, name: "qualifier", parent: name, max: 128)
            try self.validate(self.qualifier, name: "qualifier", parent: name, min: 1)
            try self.validate(self.qualifier, name: "qualifier", parent: name, pattern: "^(^\\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case cors = "Cors"
            case invokeMode = "InvokeMode"
        }
    }

    public struct UpdateFunctionUrlConfigResponse: AWSDecodableShape {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see Security and auth model for Lambda function URLs.
        public let authType: FunctionUrlAuthType
        /// The cross-origin resource sharing (CORS) settings for your function URL.
        public let cors: Cors?
        /// When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let creationTime: String
        /// The Amazon Resource Name (ARN) of your function.
        public let functionArn: String
        /// The HTTP URL endpoint for your function.
        public let functionUrl: String
        /// Use one of the following options:    BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results  are available when the payload is complete. The maximum payload size is 6 MB.    RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using  the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can request a quota increase.
        public let invokeMode: InvokeMode?
        /// When the function URL configuration was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModifiedTime: String

        @inlinable
        public init(authType: FunctionUrlAuthType, cors: Cors? = nil, creationTime: String, functionArn: String, functionUrl: String, invokeMode: InvokeMode? = nil, lastModifiedTime: String) {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case cors = "Cors"
            case creationTime = "CreationTime"
            case functionArn = "FunctionArn"
            case functionUrl = "FunctionUrl"
            case invokeMode = "InvokeMode"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct VpcConfig: AWSEncodableShape {
        /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        public let ipv6AllowedForDualStack: Bool?
        /// A list of VPC security group IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?

        @inlinable
        public init(ipv6AllowedForDualStack: Bool? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.ipv6AllowedForDualStack = ipv6AllowedForDualStack
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6AllowedForDualStack = "Ipv6AllowedForDualStack"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct VpcConfigResponse: AWSDecodableShape {
        /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        public let ipv6AllowedForDualStack: Bool?
        /// A list of VPC security group IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(ipv6AllowedForDualStack: Bool? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.ipv6AllowedForDualStack = ipv6AllowedForDualStack
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6AllowedForDualStack = "Ipv6AllowedForDualStack"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VpcId"
        }
    }
}

// MARK: - Errors

/// Error enum for Lambda
public struct LambdaErrorType: AWSErrorType {
    enum Code: String {
        case codeSigningConfigNotFoundException = "CodeSigningConfigNotFoundException"
        case codeStorageExceededException = "CodeStorageExceededException"
        case codeVerificationFailedException = "CodeVerificationFailedException"
        case ec2AccessDeniedException = "EC2AccessDeniedException"
        case ec2ThrottledException = "EC2ThrottledException"
        case ec2UnexpectedException = "EC2UnexpectedException"
        case efsMountConnectivityException = "EFSMountConnectivityException"
        case efsMountFailureException = "EFSMountFailureException"
        case efsMountTimeoutException = "EFSMountTimeoutException"
        case efsioException = "EFSIOException"
        case eniLimitReachedException = "ENILimitReachedException"
        case invalidCodeSignatureException = "InvalidCodeSignatureException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestContentException = "InvalidRequestContentException"
        case invalidRuntimeException = "InvalidRuntimeException"
        case invalidSecurityGroupIDException = "InvalidSecurityGroupIDException"
        case invalidSubnetIDException = "InvalidSubnetIDException"
        case invalidZipFileException = "InvalidZipFileException"
        case kmsAccessDeniedException = "KMSAccessDeniedException"
        case kmsDisabledException = "KMSDisabledException"
        case kmsInvalidStateException = "KMSInvalidStateException"
        case kmsNotFoundException = "KMSNotFoundException"
        case policyLengthExceededException = "PolicyLengthExceededException"
        case preconditionFailedException = "PreconditionFailedException"
        case provisionedConcurrencyConfigNotFoundException = "ProvisionedConcurrencyConfigNotFoundException"
        case recursiveInvocationException = "RecursiveInvocationException"
        case requestTooLargeException = "RequestTooLargeException"
        case resourceConflictException = "ResourceConflictException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceNotReadyException = "ResourceNotReadyException"
        case serviceException = "ServiceException"
        case snapStartException = "SnapStartException"
        case snapStartNotReadyException = "SnapStartNotReadyException"
        case snapStartTimeoutException = "SnapStartTimeoutException"
        case subnetIPAddressLimitReachedException = "SubnetIPAddressLimitReachedException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unsupportedMediaTypeException = "UnsupportedMediaTypeException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Lambda
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified code signing configuration does not exist.
    public static var codeSigningConfigNotFoundException: Self { .init(.codeSigningConfigNotFoundException) }
    /// Your Amazon Web Services account has exceeded its maximum total code size. For more information, see Lambda quotas.
    public static var codeStorageExceededException: Self { .init(.codeStorageExceededException) }
    /// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.
    public static var codeVerificationFailedException: Self { .init(.codeVerificationFailedException) }
    /// Need additional permissions to configure VPC settings.
    public static var ec2AccessDeniedException: Self { .init(.ec2AccessDeniedException) }
    /// Amazon EC2 throttled Lambda during Lambda function initialization using the execution role provided for the function.
    public static var ec2ThrottledException: Self { .init(.ec2ThrottledException) }
    /// Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda function.
    public static var ec2UnexpectedException: Self { .init(.ec2UnexpectedException) }
    /// The Lambda function couldn't make a network connection to the configured file system.
    public static var efsMountConnectivityException: Self { .init(.efsMountConnectivityException) }
    /// The Lambda function couldn't mount the configured file system due to a permission or configuration issue.
    public static var efsMountFailureException: Self { .init(.efsMountFailureException) }
    /// The Lambda function made a network connection to the configured file system, but the mount operation timed out.
    public static var efsMountTimeoutException: Self { .init(.efsMountTimeoutException) }
    /// An error occurred when reading from or writing to a connected file system.
    public static var efsioException: Self { .init(.efsioException) }
    /// Lambda couldn't create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached. For more information, see Lambda quotas.
    public static var eniLimitReachedException: Self { .init(.eniLimitReachedException) }
    /// The code signature failed the integrity check. If the integrity check fails, then Lambda blocks deployment, even if the code signing policy is set to WARN.
    public static var invalidCodeSignatureException: Self { .init(.invalidCodeSignatureException) }
    /// One of the parameters in the request is not valid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// The request body could not be parsed as JSON, or a request header is invalid. For example, the 'x-amzn-RequestId' header is not a valid UUID string.
    public static var invalidRequestContentException: Self { .init(.invalidRequestContentException) }
    /// The runtime or runtime version specified is not supported.
    public static var invalidRuntimeException: Self { .init(.invalidRuntimeException) }
    /// The security group ID provided in the Lambda function VPC configuration is not valid.
    public static var invalidSecurityGroupIDException: Self { .init(.invalidSecurityGroupIDException) }
    /// The subnet ID provided in the Lambda function VPC configuration is not valid.
    public static var invalidSubnetIDException: Self { .init(.invalidSubnetIDException) }
    /// Lambda could not unzip the deployment package.
    public static var invalidZipFileException: Self { .init(.invalidZipFileException) }
    /// Lambda couldn't decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.
    public static var kmsAccessDeniedException: Self { .init(.kmsAccessDeniedException) }
    /// Lambda couldn't decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.
    public static var kmsDisabledException: Self { .init(.kmsDisabledException) }
    /// Lambda couldn't decrypt the environment variables because the state of the KMS key used is not valid for Decrypt. Check the function's KMS key settings.
    public static var kmsInvalidStateException: Self { .init(.kmsInvalidStateException) }
    /// Lambda couldn't decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.
    public static var kmsNotFoundException: Self { .init(.kmsNotFoundException) }
    /// The permissions policy for the resource is too large. For more information, see Lambda quotas.
    public static var policyLengthExceededException: Self { .init(.policyLengthExceededException) }
    /// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias.    For AddPermission and RemovePermission API operations: Call GetPolicy to retrieve the latest RevisionId for your resource.    For all other API operations: Call GetFunction or GetAlias to retrieve the latest RevisionId for your resource.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The specified configuration does not exist.
    public static var provisionedConcurrencyConfigNotFoundException: Self { .init(.provisionedConcurrencyConfigNotFoundException) }
    /// Lambda has detected your function being invoked in a recursive loop with other Amazon Web Services resources and stopped your function's invocation.
    public static var recursiveInvocationException: Self { .init(.recursiveInvocationException) }
    /// The request payload exceeded the Invoke request body JSON input quota. For more information, see Lambda quotas.
    public static var requestTooLargeException: Self { .init(.requestTooLargeException) }
    /// The resource already exists, or another operation is in progress.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    /// The operation conflicts with the resource's availability. For example, you tried to update an event source mapping in the CREATING state, or you tried to delete an event source mapping currently UPDATING.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The resource specified in the request does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.
    public static var resourceNotReadyException: Self { .init(.resourceNotReadyException) }
    /// The Lambda service encountered an internal error.
    public static var serviceException: Self { .init(.serviceException) }
    /// The afterRestore() runtime hook encountered an error. For more information, check the Amazon CloudWatch logs.
    public static var snapStartException: Self { .init(.snapStartException) }
    /// Lambda is initializing your function. You can invoke the function when the function state becomes Active.
    public static var snapStartNotReadyException: Self { .init(.snapStartNotReadyException) }
    /// Lambda couldn't restore the snapshot within the timeout limit.
    public static var snapStartTimeoutException: Self { .init(.snapStartTimeoutException) }
    /// Lambda couldn't set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.
    public static var subnetIPAddressLimitReachedException: Self { .init(.subnetIPAddressLimitReachedException) }
    /// The request throughput limit was exceeded. For more information, see Lambda quotas.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The content type of the Invoke request body is not JSON.
    public static var unsupportedMediaTypeException: Self { .init(.unsupportedMediaTypeException) }
}

extension LambdaErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "CodeSigningConfigNotFoundException": Lambda.CodeSigningConfigNotFoundException.self,
        "CodeStorageExceededException": Lambda.CodeStorageExceededException.self,
        "CodeVerificationFailedException": Lambda.CodeVerificationFailedException.self,
        "EC2AccessDeniedException": Lambda.EC2AccessDeniedException.self,
        "EC2ThrottledException": Lambda.EC2ThrottledException.self,
        "EC2UnexpectedException": Lambda.EC2UnexpectedException.self,
        "EFSIOException": Lambda.EFSIOException.self,
        "EFSMountConnectivityException": Lambda.EFSMountConnectivityException.self,
        "EFSMountFailureException": Lambda.EFSMountFailureException.self,
        "EFSMountTimeoutException": Lambda.EFSMountTimeoutException.self,
        "ENILimitReachedException": Lambda.ENILimitReachedException.self,
        "InvalidCodeSignatureException": Lambda.InvalidCodeSignatureException.self,
        "InvalidParameterValueException": Lambda.InvalidParameterValueException.self,
        "InvalidRequestContentException": Lambda.InvalidRequestContentException.self,
        "InvalidRuntimeException": Lambda.InvalidRuntimeException.self,
        "InvalidSecurityGroupIDException": Lambda.InvalidSecurityGroupIDException.self,
        "InvalidSubnetIDException": Lambda.InvalidSubnetIDException.self,
        "InvalidZipFileException": Lambda.InvalidZipFileException.self,
        "KMSAccessDeniedException": Lambda.KMSAccessDeniedException.self,
        "KMSDisabledException": Lambda.KMSDisabledException.self,
        "KMSInvalidStateException": Lambda.KMSInvalidStateException.self,
        "KMSNotFoundException": Lambda.KMSNotFoundException.self,
        "PolicyLengthExceededException": Lambda.PolicyLengthExceededException.self,
        "PreconditionFailedException": Lambda.PreconditionFailedException.self,
        "ProvisionedConcurrencyConfigNotFoundException": Lambda.ProvisionedConcurrencyConfigNotFoundException.self,
        "RecursiveInvocationException": Lambda.RecursiveInvocationException.self,
        "RequestTooLargeException": Lambda.RequestTooLargeException.self,
        "ResourceConflictException": Lambda.ResourceConflictException.self,
        "ResourceInUseException": Lambda.ResourceInUseException.self,
        "ResourceNotFoundException": Lambda.ResourceNotFoundException.self,
        "ResourceNotReadyException": Lambda.ResourceNotReadyException.self,
        "ServiceException": Lambda.ServiceException.self,
        "SnapStartException": Lambda.SnapStartException.self,
        "SnapStartNotReadyException": Lambda.SnapStartNotReadyException.self,
        "SnapStartTimeoutException": Lambda.SnapStartTimeoutException.self,
        "SubnetIPAddressLimitReachedException": Lambda.SubnetIPAddressLimitReachedException.self,
        "TooManyRequestsException": Lambda.TooManyRequestsException.self,
        "UnsupportedMediaTypeException": Lambda.UnsupportedMediaTypeException.self
    ]
}

extension LambdaErrorType: Equatable {
    public static func == (lhs: LambdaErrorType, rhs: LambdaErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LambdaErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
