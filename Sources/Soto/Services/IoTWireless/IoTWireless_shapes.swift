//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTWireless {
    // MARK: Enums

    public enum AggregationPeriod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneDay = "OneDay"
        case oneHour = "OneHour"
        case oneWeek = "OneWeek"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationConfigType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case semtechGeoLocation = "SemtechGeolocation"
        public var description: String { return self.rawValue }
    }

    public enum BatteryLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "critical"
        case low = "low"
        case normal = "normal"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "Connected"
        case disconnected = "Disconnected"
        public var description: String { return self.rawValue }
    }

    public enum DeviceProfileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        public var description: String { return self.rawValue }
    }

    public enum DeviceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case provisioned = "Provisioned"
        case registerednotseen = "RegisteredNotSeen"
        case registeredreachable = "RegisteredReachable"
        case registeredunreachable = "RegisteredUnreachable"
        public var description: String { return self.rawValue }
    }

    public enum DimensionName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deviceId = "DeviceId"
        case gatewayId = "GatewayId"
        public var description: String { return self.rawValue }
    }

    public enum DlClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case classB = "ClassB"
        case classC = "ClassC"
        public var description: String { return self.rawValue }
    }

    public enum DownlinkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concurrent = "CONCURRENT"
        case sequential = "SEQUENTIAL"
        case usingUplinkGateway = "USING_UPLINK_GATEWAY"
        public var description: String { return self.rawValue }
    }

    public enum Event: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ack = "ack"
        case discovered = "discovered"
        case lost = "lost"
        case nack = "nack"
        case passthrough = "passthrough"
        public var description: String { return self.rawValue }
    }

    public enum EventNotificationPartnerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sidewalk = "Sidewalk"
        public var description: String { return self.rawValue }
    }

    public enum EventNotificationResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fuotaTask = "FuotaTask"
        case sidewalkAccount = "SidewalkAccount"
        case wirelessDevice = "WirelessDevice"
        case wirelessGateway = "WirelessGateway"
        public var description: String { return self.rawValue }
    }

    public enum EventNotificationTopicStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum ExpressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mqttTopic = "MqttTopic"
        case ruleName = "RuleName"
        public var description: String { return self.rawValue }
    }

    public enum FuotaDeviceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deviceExistInConflictFuotaTask = "Device_exist_in_conflict_fuota_task"
        case fragAlgoUnsupported = "FragAlgo_unsupported"
        case fragIndexUnsupported = "FragIndex_unsupported"
        case initial = "Initial"
        case memoryError = "MemoryError"
        case micError = "MICError"
        case missingFrag = "MissingFrag"
        case notEnoughMemory = "Not_enough_memory"
        case packageNotSupported = "Package_Not_Supported"
        case sessionCntReplay = "SessionCnt_replay"
        case successful = "Successful"
        case wrongDescriptor = "Wrong_descriptor"
        public var description: String { return self.rawValue }
    }

    public enum FuotaTaskEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fuota = "Fuota"
        public var description: String { return self.rawValue }
    }

    public enum FuotaTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteWaiting = "Delete_Waiting"
        case fuotaDone = "FuotaDone"
        case fuotaSessionWaiting = "FuotaSession_Waiting"
        case inFuotasession = "In_FuotaSession"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum FuotaTaskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case loRaWAN = "LoRaWAN"
        public var description: String { return self.rawValue }
    }

    public enum IdentifierType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case devEui = "DevEui"
        case fuotaTaskId = "FuotaTaskId"
        case gatewayEui = "GatewayEui"
        case partnerAccountId = "PartnerAccountId"
        case wirelessDeviceId = "WirelessDeviceId"
        case wirelessGatewayId = "WirelessGatewayId"
        public var description: String { return self.rawValue }
    }

    public enum ImportTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case deleting = "DELETING"
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case initializing = "INITIALIZING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case error = "ERROR"
        case info = "INFO"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customCommandIdGet = "CUSTOM_COMMAND_ID_GET"
        case customCommandIdNotify = "CUSTOM_COMMAND_ID_NOTIFY"
        case customCommandIdResp = "CUSTOM_COMMAND_ID_RESP"
        case customCommandIdSet = "CUSTOM_COMMAND_ID_SET"
        public var description: String { return self.rawValue }
    }

    public enum MetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAccountActiveDeviceCount = "AwsAccountActiveDeviceCount"
        case awsAccountActiveGatewayCount = "AwsAccountActiveGatewayCount"
        case awsAccountDeviceCount = "AwsAccountDeviceCount"
        case awsAccountDownlinkCount = "AwsAccountDownlinkCount"
        case awsAccountGatewayCount = "AwsAccountGatewayCount"
        case awsAccountJoinAcceptCount = "AwsAccountJoinAcceptCount"
        case awsAccountJoinRequestCount = "AwsAccountJoinRequestCount"
        case awsAccountRoamingDownlinkCount = "AwsAccountRoamingDownlinkCount"
        case awsAccountRoamingUplinkCount = "AwsAccountRoamingUplinkCount"
        case awsAccountUplinkCount = "AwsAccountUplinkCount"
        case awsAccountUplinkLostCount = "AwsAccountUplinkLostCount"
        case awsAccountUplinkLostRate = "AwsAccountUplinkLostRate"
        case deviceDownlinkCount = "DeviceDownlinkCount"
        case deviceJoinAcceptCount = "DeviceJoinAcceptCount"
        case deviceJoinRequestCount = "DeviceJoinRequestCount"
        case deviceRSSI = "DeviceRSSI"
        case deviceRoamingDownlinkCount = "DeviceRoamingDownlinkCount"
        case deviceRoamingRSSI = "DeviceRoamingRSSI"
        case deviceRoamingSNR = "DeviceRoamingSNR"
        case deviceRoamingUplinkCount = "DeviceRoamingUplinkCount"
        case deviceSNR = "DeviceSNR"
        case deviceUplinkCount = "DeviceUplinkCount"
        case deviceUplinkLostCount = "DeviceUplinkLostCount"
        case deviceUplinkLostRate = "DeviceUplinkLostRate"
        case gatewayDownTime = "GatewayDownTime"
        case gatewayDownlinkCount = "GatewayDownlinkCount"
        case gatewayJoinAcceptCount = "GatewayJoinAcceptCount"
        case gatewayJoinRequestCount = "GatewayJoinRequestCount"
        case gatewayRSSI = "GatewayRSSI"
        case gatewaySNR = "GatewaySNR"
        case gatewayUpTime = "GatewayUpTime"
        case gatewayUplinkCount = "GatewayUplinkCount"
        public var description: String { return self.rawValue }
    }

    public enum MetricQueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum MulticastFrameInfo: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum OnboardStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case onboarded = "ONBOARDED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum PartnerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sidewalk = "Sidewalk"
        public var description: String { return self.rawValue }
    }

    public enum PositionConfigurationFec: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case rose = "ROSE"
        public var description: String { return self.rawValue }
    }

    public enum PositionConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum PositionResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case wirelessDevice = "WirelessDevice"
        case wirelessGateway = "WirelessGateway"
        public var description: String { return self.rawValue }
    }

    public enum PositionSolverProvider: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case semtech = "Semtech"
        public var description: String { return self.rawValue }
    }

    public enum PositionSolverType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gnss = "GNSS"
        public var description: String { return self.rawValue }
    }

    public enum PositioningConfigStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum SigningAlg: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ed25519 = "Ed25519"
        case p256r1 = "P256r1"
        public var description: String { return self.rawValue }
    }

    public enum SummaryMetricConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum SupportedRfRegion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case as9231 = "AS923-1"
        case as9232 = "AS923-2"
        case as9233 = "AS923-3"
        case as9234 = "AS923-4"
        case au915 = "AU915"
        case cn470 = "CN470"
        case cn779 = "CN779"
        case eu433 = "EU433"
        case eu868 = "EU868"
        case in865 = "IN865"
        case kr920 = "KR920"
        case ru864 = "RU864"
        case us915 = "US915"
        public var description: String { return self.rawValue }
    }

    public enum WirelessDeviceEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case downlinkData = "Downlink_Data"
        case join = "Join"
        case registration = "Registration"
        case rejoin = "Rejoin"
        case uplinkData = "Uplink_Data"
        public var description: String { return self.rawValue }
    }

    public enum WirelessDeviceFrameInfo: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum WirelessDeviceIdType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case devEui = "DevEui"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
        case thingName = "ThingName"
        case wirelessDeviceId = "WirelessDeviceId"
        public var description: String { return self.rawValue }
    }

    public enum WirelessDeviceSidewalkStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case provisioned = "PROVISIONED"
        case registered = "REGISTERED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum WirelessDeviceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        public var description: String { return self.rawValue }
    }

    public enum WirelessGatewayEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case certificate = "Certificate"
        case cupsRequest = "CUPS_Request"
        public var description: String { return self.rawValue }
    }

    public enum WirelessGatewayIdType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gatewayEui = "GatewayEui"
        case thingName = "ThingName"
        case wirelessGatewayId = "WirelessGatewayId"
        public var description: String { return self.rawValue }
    }

    public enum WirelessGatewayServiceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cups = "CUPS"
        case lns = "LNS"
        public var description: String { return self.rawValue }
    }

    public enum WirelessGatewayTaskDefinitionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum WirelessGatewayTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case firstRetry = "FIRST_RETRY"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case secondRetry = "SECOND_RETRY"
        public var description: String { return self.rawValue }
    }

    public enum WirelessGatewayType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case loRaWAN = "LoRaWAN"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AbpV10X: AWSEncodableShape & AWSDecodableShape {
        /// The DevAddr value.
        public let devAddr: String?
        /// The FCnt init value.
        public let fCntStart: Int?
        /// Session keys for ABP v1.0.x
        public let sessionKeys: SessionKeysAbpV10X?

        @inlinable
        public init(devAddr: String? = nil, fCntStart: Int? = nil, sessionKeys: SessionKeysAbpV10X? = nil) {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.devAddr, name: "devAddr", parent: name, pattern: "^[a-fA-F0-9]{8}$")
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, max: 65535)
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, min: 0)
            try self.sessionKeys?.validate(name: "\(name).sessionKeys")
        }

        private enum CodingKeys: String, CodingKey {
            case devAddr = "DevAddr"
            case fCntStart = "FCntStart"
            case sessionKeys = "SessionKeys"
        }
    }

    public struct AbpV11: AWSEncodableShape & AWSDecodableShape {
        /// The DevAddr value.
        public let devAddr: String?
        /// The FCnt init value.
        public let fCntStart: Int?
        /// Session keys for ABP v1.1
        public let sessionKeys: SessionKeysAbpV11?

        @inlinable
        public init(devAddr: String? = nil, fCntStart: Int? = nil, sessionKeys: SessionKeysAbpV11? = nil) {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.devAddr, name: "devAddr", parent: name, pattern: "^[a-fA-F0-9]{8}$")
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, max: 65535)
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, min: 0)
            try self.sessionKeys?.validate(name: "\(name).sessionKeys")
        }

        private enum CodingKeys: String, CodingKey {
            case devAddr = "DevAddr"
            case fCntStart = "FCntStart"
            case sessionKeys = "SessionKeys"
        }
    }

    public struct Accuracy: AWSDecodableShape {
        /// The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.
        public let horizontalAccuracy: Float?
        /// The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.
        public let verticalAccuracy: Float?

        @inlinable
        public init(horizontalAccuracy: Float? = nil, verticalAccuracy: Float? = nil) {
            self.horizontalAccuracy = horizontalAccuracy
            self.verticalAccuracy = verticalAccuracy
        }

        private enum CodingKeys: String, CodingKey {
            case horizontalAccuracy = "HorizontalAccuracy"
            case verticalAccuracy = "VerticalAccuracy"
        }
    }

    public struct ApplicationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public let destinationName: String?
        public let fPort: Int?
        /// Application type, which can be specified to obtain real-time position information of your LoRaWAN device.
        public let type: ApplicationConfigType?

        @inlinable
        public init(destinationName: String? = nil, fPort: Int? = nil, type: ApplicationConfigType? = nil) {
            self.destinationName = destinationName
            self.fPort = fPort
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.fPort, name: "fPort", parent: name, max: 223)
            try self.validate(self.fPort, name: "fPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName = "DestinationName"
            case fPort = "FPort"
            case type = "Type"
        }
    }

    public struct AssociateAwsAccountWithPartnerAccountRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The Sidewalk account credentials.
        public let sidewalk: SidewalkAccountInfo
        /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = AssociateAwsAccountWithPartnerAccountRequest.idempotencyToken(), sidewalk: SidewalkAccountInfo, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.sidewalk = sidewalk
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.sidewalk.validate(name: "\(name).sidewalk")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sidewalk = "Sidewalk"
            case tags = "Tags"
        }
    }

    public struct AssociateAwsAccountWithPartnerAccountResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The Sidewalk account credentials.
        public let sidewalk: SidewalkAccountInfo?

        @inlinable
        public init(arn: String? = nil, sidewalk: SidewalkAccountInfo? = nil) {
            self.arn = arn
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case sidewalk = "Sidewalk"
        }
    }

    public struct AssociateMulticastGroupWithFuotaTaskRequest: AWSEncodableShape {
        public let id: String
        public let multicastGroupId: String

        @inlinable
        public init(id: String, multicastGroupId: String) {
            self.id = id
            self.multicastGroupId = multicastGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.multicastGroupId, forKey: .multicastGroupId)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.multicastGroupId, name: "multicastGroupId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case multicastGroupId = "MulticastGroupId"
        }
    }

    public struct AssociateMulticastGroupWithFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateWirelessDeviceWithFuotaTaskRequest: AWSEncodableShape {
        public let id: String
        public let wirelessDeviceId: String

        @inlinable
        public init(id: String, wirelessDeviceId: String) {
            self.id = id
            self.wirelessDeviceId = wirelessDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.wirelessDeviceId, forKey: .wirelessDeviceId)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.wirelessDeviceId, name: "wirelessDeviceId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessDeviceId = "WirelessDeviceId"
        }
    }

    public struct AssociateWirelessDeviceWithFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateWirelessDeviceWithMulticastGroupRequest: AWSEncodableShape {
        public let id: String
        public let wirelessDeviceId: String

        @inlinable
        public init(id: String, wirelessDeviceId: String) {
            self.id = id
            self.wirelessDeviceId = wirelessDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.wirelessDeviceId, forKey: .wirelessDeviceId)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.wirelessDeviceId, name: "wirelessDeviceId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessDeviceId = "WirelessDeviceId"
        }
    }

    public struct AssociateWirelessDeviceWithMulticastGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateWirelessDeviceWithThingRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String
        /// The ARN of the thing to associate with the wireless device.
        public let thingArn: String

        @inlinable
        public init(id: String, thingArn: String) {
            self.id = id
            self.thingArn = thingArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.thingArn, forKey: .thingArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case thingArn = "ThingArn"
        }
    }

    public struct AssociateWirelessDeviceWithThingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateWirelessGatewayWithCertificateRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String
        /// The ID of the certificate to associate with the wireless gateway.
        public let iotCertificateId: String

        @inlinable
        public init(id: String, iotCertificateId: String) {
            self.id = id
            self.iotCertificateId = iotCertificateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.iotCertificateId, forKey: .iotCertificateId)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.iotCertificateId, name: "iotCertificateId", parent: name, max: 4096)
            try self.validate(self.iotCertificateId, name: "iotCertificateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case iotCertificateId = "IotCertificateId"
        }
    }

    public struct AssociateWirelessGatewayWithCertificateResponse: AWSDecodableShape {
        /// The ID of the certificate associated with the wireless gateway.
        public let iotCertificateId: String?

        @inlinable
        public init(iotCertificateId: String? = nil) {
            self.iotCertificateId = iotCertificateId
        }

        private enum CodingKeys: String, CodingKey {
            case iotCertificateId = "IotCertificateId"
        }
    }

    public struct AssociateWirelessGatewayWithThingRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String
        /// The ARN of the thing to associate with the wireless gateway.
        public let thingArn: String

        @inlinable
        public init(id: String, thingArn: String) {
            self.id = id
            self.thingArn = thingArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.thingArn, forKey: .thingArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case thingArn = "ThingArn"
        }
    }

    public struct AssociateWirelessGatewayWithThingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Beaconing: AWSEncodableShape & AWSDecodableShape {
        /// The data rate for gateways that are sending the beacons.
        public let dataRate: Int?
        /// The frequency list for the gateways to send the beacons.
        public let frequencies: [Int]?

        @inlinable
        public init(dataRate: Int? = nil, frequencies: [Int]? = nil) {
            self.dataRate = dataRate
            self.frequencies = frequencies
        }

        public func validate(name: String) throws {
            try self.validate(self.dataRate, name: "dataRate", parent: name, max: 15)
            try self.validate(self.dataRate, name: "dataRate", parent: name, min: 0)
            try self.frequencies?.forEach {
                try validate($0, name: "frequencies[]", parent: name, max: 1000000000)
                try validate($0, name: "frequencies[]", parent: name, min: 100000000)
            }
            try self.validate(self.frequencies, name: "frequencies", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case dataRate = "DataRate"
            case frequencies = "Frequencies"
        }
    }

    public struct CancelMulticastGroupSessionRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelMulticastGroupSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CdmaLocalId: AWSEncodableShape {
        /// CDMA channel information.
        public let cdmaChannel: Int
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        public let pnOffset: Int

        @inlinable
        public init(cdmaChannel: Int, pnOffset: Int) {
            self.cdmaChannel = cdmaChannel
            self.pnOffset = pnOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.cdmaChannel, name: "cdmaChannel", parent: name, max: 4095)
            try self.validate(self.cdmaChannel, name: "cdmaChannel", parent: name, min: 0)
            try self.validate(self.pnOffset, name: "pnOffset", parent: name, max: 511)
            try self.validate(self.pnOffset, name: "pnOffset", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case cdmaChannel = "CdmaChannel"
            case pnOffset = "PnOffset"
        }
    }

    public struct CdmaNmrObj: AWSEncodableShape {
        /// CDMA base station ID (BSID).
        public let baseStationId: Int?
        /// CDMA channel information.
        public let cdmaChannel: Int
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public let pilotPower: Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        public let pnOffset: Int

        @inlinable
        public init(baseStationId: Int? = nil, cdmaChannel: Int, pilotPower: Int? = nil, pnOffset: Int) {
            self.baseStationId = baseStationId
            self.cdmaChannel = cdmaChannel
            self.pilotPower = pilotPower
            self.pnOffset = pnOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.baseStationId, name: "baseStationId", parent: name, max: 65535)
            try self.validate(self.baseStationId, name: "baseStationId", parent: name, min: 0)
            try self.validate(self.cdmaChannel, name: "cdmaChannel", parent: name, max: 4095)
            try self.validate(self.cdmaChannel, name: "cdmaChannel", parent: name, min: 0)
            try self.validate(self.pilotPower, name: "pilotPower", parent: name, max: -49)
            try self.validate(self.pilotPower, name: "pilotPower", parent: name, min: -142)
            try self.validate(self.pnOffset, name: "pnOffset", parent: name, max: 511)
            try self.validate(self.pnOffset, name: "pnOffset", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case baseStationId = "BaseStationId"
            case cdmaChannel = "CdmaChannel"
            case pilotPower = "PilotPower"
            case pnOffset = "PnOffset"
        }
    }

    public struct CdmaObj: AWSEncodableShape {
        /// CDMA base station latitude in degrees.
        public let baseLat: Float?
        /// CDMA base station longitude in degrees.
        public let baseLng: Float?
        /// CDMA base station ID (BSID).
        public let baseStationId: Int
        /// CDMA local identification (local ID) parameters.
        public let cdmaLocalId: CdmaLocalId?
        /// CDMA network measurement reports.
        public let cdmaNmr: [CdmaNmrObj]?
        /// CDMA network ID (NID).
        public let networkId: Int
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public let pilotPower: Int?
        /// CDMA registration zone (RZ).
        public let registrationZone: Int?
        /// CDMA system ID (SID).
        public let systemId: Int

        @inlinable
        public init(baseLat: Float? = nil, baseLng: Float? = nil, baseStationId: Int, cdmaLocalId: CdmaLocalId? = nil, cdmaNmr: [CdmaNmrObj]? = nil, networkId: Int, pilotPower: Int? = nil, registrationZone: Int? = nil, systemId: Int) {
            self.baseLat = baseLat
            self.baseLng = baseLng
            self.baseStationId = baseStationId
            self.cdmaLocalId = cdmaLocalId
            self.cdmaNmr = cdmaNmr
            self.networkId = networkId
            self.pilotPower = pilotPower
            self.registrationZone = registrationZone
            self.systemId = systemId
        }

        public func validate(name: String) throws {
            try self.validate(self.baseLat, name: "baseLat", parent: name, max: 90.0)
            try self.validate(self.baseLat, name: "baseLat", parent: name, min: -90.0)
            try self.validate(self.baseLng, name: "baseLng", parent: name, max: 180.0)
            try self.validate(self.baseLng, name: "baseLng", parent: name, min: -180.0)
            try self.validate(self.baseStationId, name: "baseStationId", parent: name, max: 65535)
            try self.validate(self.baseStationId, name: "baseStationId", parent: name, min: 0)
            try self.cdmaLocalId?.validate(name: "\(name).cdmaLocalId")
            try self.cdmaNmr?.forEach {
                try $0.validate(name: "\(name).cdmaNmr[]")
            }
            try self.validate(self.cdmaNmr, name: "cdmaNmr", parent: name, max: 32)
            try self.validate(self.cdmaNmr, name: "cdmaNmr", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 65535)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 0)
            try self.validate(self.pilotPower, name: "pilotPower", parent: name, max: -49)
            try self.validate(self.pilotPower, name: "pilotPower", parent: name, min: -142)
            try self.validate(self.registrationZone, name: "registrationZone", parent: name, max: 4095)
            try self.validate(self.registrationZone, name: "registrationZone", parent: name, min: 0)
            try self.validate(self.systemId, name: "systemId", parent: name, max: 32767)
            try self.validate(self.systemId, name: "systemId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseLat = "BaseLat"
            case baseLng = "BaseLng"
            case baseStationId = "BaseStationId"
            case cdmaLocalId = "CdmaLocalId"
            case cdmaNmr = "CdmaNmr"
            case networkId = "NetworkId"
            case pilotPower = "PilotPower"
            case registrationZone = "RegistrationZone"
            case systemId = "SystemId"
        }
    }

    public struct CellTowers: AWSEncodableShape {
        /// CDMA object information.
        public let cdma: [CdmaObj]?
        /// GSM object information.
        public let gsm: [GsmObj]?
        /// LTE object information.
        public let lte: [LteObj]?
        /// TD-SCDMA object information.
        public let tdscdma: [TdscdmaObj]?
        /// WCDMA object information.
        public let wcdma: [WcdmaObj]?

        @inlinable
        public init(cdma: [CdmaObj]? = nil, gsm: [GsmObj]? = nil, lte: [LteObj]? = nil, tdscdma: [TdscdmaObj]? = nil, wcdma: [WcdmaObj]? = nil) {
            self.cdma = cdma
            self.gsm = gsm
            self.lte = lte
            self.tdscdma = tdscdma
            self.wcdma = wcdma
        }

        public func validate(name: String) throws {
            try self.cdma?.forEach {
                try $0.validate(name: "\(name).cdma[]")
            }
            try self.validate(self.cdma, name: "cdma", parent: name, max: 16)
            try self.validate(self.cdma, name: "cdma", parent: name, min: 1)
            try self.gsm?.forEach {
                try $0.validate(name: "\(name).gsm[]")
            }
            try self.validate(self.gsm, name: "gsm", parent: name, max: 16)
            try self.validate(self.gsm, name: "gsm", parent: name, min: 1)
            try self.lte?.forEach {
                try $0.validate(name: "\(name).lte[]")
            }
            try self.validate(self.lte, name: "lte", parent: name, max: 16)
            try self.validate(self.lte, name: "lte", parent: name, min: 1)
            try self.tdscdma?.forEach {
                try $0.validate(name: "\(name).tdscdma[]")
            }
            try self.validate(self.tdscdma, name: "tdscdma", parent: name, max: 16)
            try self.validate(self.tdscdma, name: "tdscdma", parent: name, min: 1)
            try self.wcdma?.forEach {
                try $0.validate(name: "\(name).wcdma[]")
            }
            try self.validate(self.wcdma, name: "wcdma", parent: name, max: 16)
            try self.validate(self.wcdma, name: "wcdma", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cdma = "Cdma"
            case gsm = "Gsm"
            case lte = "Lte"
            case tdscdma = "Tdscdma"
            case wcdma = "Wcdma"
        }
    }

    public struct CertificateList: AWSDecodableShape {
        /// The certificate chain algorithm provided by sidewalk.
        public let signingAlg: SigningAlg
        /// The value of the chosen sidewalk certificate.
        public let value: String

        @inlinable
        public init(signingAlg: SigningAlg, value: String) {
            self.signingAlg = signingAlg
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case signingAlg = "SigningAlg"
            case value = "Value"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String?
        /// Id of the resource in the conflicting operation.
        public let resourceId: String?
        /// Type of the resource in the conflicting operation.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ConnectionStatusEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Connection status event configuration object for enabling or disabling LoRaWAN related event topics.
        public let loRaWAN: LoRaWANConnectionStatusEventNotificationConfigurations?
        /// Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.
        public let wirelessGatewayIdEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(loRaWAN: LoRaWANConnectionStatusEventNotificationConfigurations? = nil, wirelessGatewayIdEventTopic: EventNotificationTopicStatus? = nil) {
            self.loRaWAN = loRaWAN
            self.wirelessGatewayIdEventTopic = wirelessGatewayIdEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
            case wirelessGatewayIdEventTopic = "WirelessGatewayIdEventTopic"
        }
    }

    public struct ConnectionStatusResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public let loRaWAN: LoRaWANConnectionStatusResourceTypeEventConfiguration?

        @inlinable
        public init(loRaWAN: LoRaWANConnectionStatusResourceTypeEventConfiguration? = nil) {
            self.loRaWAN = loRaWAN
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct CreateDestinationRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The description of the new resource.
        public let description: String?
        /// The rule name or topic rule to send messages to.
        public let expression: String
        /// The type of value in Expression.
        public let expressionType: ExpressionType
        /// The name of the new resource.
        public let name: String
        /// The ARN of the IAM Role that authorizes the destination.
        public let roleArn: String
        /// The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateDestinationRequest.idempotencyToken(), description: String? = nil, expression: String, expressionType: ExpressionType, name: String, roleArn: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case expression = "Expression"
            case expressionType = "ExpressionType"
            case name = "Name"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateDestinationResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        /// The name of the new resource.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct CreateDeviceProfileRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The device profile information to use to create the device profile.
        public let loRaWAN: LoRaWANDeviceProfile?
        /// The name of the new resource.
        public let name: String?
        /// The Sidewalk-related information for creating the Sidewalk device profile.
        public let sidewalk: SidewalkCreateDeviceProfile?
        /// The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateDeviceProfileRequest.idempotencyToken(), loRaWAN: LoRaWANDeviceProfile? = nil, name: String? = nil, sidewalk: SidewalkCreateDeviceProfile? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.loRaWAN = loRaWAN
            self.name = name
            self.sidewalk = sidewalk
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case sidewalk = "Sidewalk"
            case tags = "Tags"
        }
    }

    public struct CreateDeviceProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        /// The ID of the new device profile.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateFuotaTaskRequest: AWSEncodableShape {
        public let clientRequestToken: String?
        public let description: String?
        public let descriptor: String?
        public let firmwareUpdateImage: String
        public let firmwareUpdateRole: String
        public let fragmentIntervalMS: Int?
        public let fragmentSizeBytes: Int?
        public let loRaWAN: LoRaWANFuotaTask?
        public let name: String?
        public let redundancyPercent: Int?
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateFuotaTaskRequest.idempotencyToken(), description: String? = nil, descriptor: String? = nil, firmwareUpdateImage: String, firmwareUpdateRole: String, fragmentIntervalMS: Int? = nil, fragmentSizeBytes: Int? = nil, loRaWAN: LoRaWANFuotaTask? = nil, name: String? = nil, redundancyPercent: Int? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.descriptor = descriptor
            self.firmwareUpdateImage = firmwareUpdateImage
            self.firmwareUpdateRole = firmwareUpdateRole
            self.fragmentIntervalMS = fragmentIntervalMS
            self.fragmentSizeBytes = fragmentSizeBytes
            self.loRaWAN = loRaWAN
            self.name = name
            self.redundancyPercent = redundancyPercent
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.descriptor, name: "descriptor", parent: name, max: 332)
            try self.validate(self.descriptor, name: "descriptor", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
            try self.validate(self.firmwareUpdateImage, name: "firmwareUpdateImage", parent: name, max: 4096)
            try self.validate(self.firmwareUpdateImage, name: "firmwareUpdateImage", parent: name, min: 1)
            try self.validate(self.firmwareUpdateRole, name: "firmwareUpdateRole", parent: name, max: 2048)
            try self.validate(self.firmwareUpdateRole, name: "firmwareUpdateRole", parent: name, min: 1)
            try self.validate(self.fragmentIntervalMS, name: "fragmentIntervalMS", parent: name, min: 1)
            try self.validate(self.fragmentSizeBytes, name: "fragmentSizeBytes", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.redundancyPercent, name: "redundancyPercent", parent: name, max: 100)
            try self.validate(self.redundancyPercent, name: "redundancyPercent", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case descriptor = "Descriptor"
            case firmwareUpdateImage = "FirmwareUpdateImage"
            case firmwareUpdateRole = "FirmwareUpdateRole"
            case fragmentIntervalMS = "FragmentIntervalMS"
            case fragmentSizeBytes = "FragmentSizeBytes"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case redundancyPercent = "RedundancyPercent"
            case tags = "Tags"
        }
    }

    public struct CreateFuotaTaskResponse: AWSDecodableShape {
        public let arn: String?
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateMulticastGroupRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The description of the multicast group.
        public let description: String?
        public let loRaWAN: LoRaWANMulticast
        public let name: String?
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateMulticastGroupRequest.idempotencyToken(), description: String? = nil, loRaWAN: LoRaWANMulticast, name: String? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.loRaWAN = loRaWAN
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.loRaWAN.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateMulticastGroupResponse: AWSDecodableShape {
        public let arn: String?
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateNetworkAnalyzerConfigurationRequest: AWSEncodableShape {
        public let clientRequestToken: String?
        public let description: String?
        /// Multicast Group resources to add to the network analyzer configruation. Provide the MulticastGroupId of the resource to add in the input array.
        public let multicastGroups: [String]?
        public let name: String
        public let tags: [Tag]?
        public let traceContent: TraceContent?
        /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
        public let wirelessDevices: [String]?
        /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
        public let wirelessGateways: [String]?

        @inlinable
        public init(clientRequestToken: String? = CreateNetworkAnalyzerConfigurationRequest.idempotencyToken(), description: String? = nil, multicastGroups: [String]? = nil, name: String, tags: [Tag]? = nil, traceContent: TraceContent? = nil, wirelessDevices: [String]? = nil, wirelessGateways: [String]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.multicastGroups = multicastGroups
            self.name = name
            self.tags = tags
            self.traceContent = traceContent
            self.wirelessDevices = wirelessDevices
            self.wirelessGateways = wirelessGateways
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.multicastGroups?.forEach {
                try validate($0, name: "multicastGroups[]", parent: name, max: 256)
            }
            try self.validate(self.multicastGroups, name: "multicastGroups", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.wirelessDevices?.forEach {
                try validate($0, name: "wirelessDevices[]", parent: name, max: 256)
            }
            try self.validate(self.wirelessDevices, name: "wirelessDevices", parent: name, max: 250)
            try self.wirelessGateways?.forEach {
                try validate($0, name: "wirelessGateways[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case multicastGroups = "MulticastGroups"
            case name = "Name"
            case tags = "Tags"
            case traceContent = "TraceContent"
            case wirelessDevices = "WirelessDevices"
            case wirelessGateways = "WirelessGateways"
        }
    }

    public struct CreateNetworkAnalyzerConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct CreateServiceProfileRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The service profile information to use to create the service profile.
        public let loRaWAN: LoRaWANServiceProfile?
        /// The name of the new resource.
        public let name: String?
        /// The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateServiceProfileRequest.idempotencyToken(), loRaWAN: LoRaWANServiceProfile? = nil, name: String? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.loRaWAN = loRaWAN
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateServiceProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        /// The ID of the new service profile.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateWirelessDeviceRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The description of the new resource.
        public let description: String?
        /// The name of the destination to assign to the new wireless device.
        public let destinationName: String
        /// The device configuration information to use to create the wireless device.
        public let loRaWAN: LoRaWANDevice?
        /// The name of the new resource.
        public let name: String?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public let positioning: PositioningConfigStatus?
        /// The device configuration information to use to create the Sidewalk device.
        public let sidewalk: SidewalkCreateWirelessDevice?
        /// The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?
        /// The wireless device type.
        public let type: WirelessDeviceType

        @inlinable
        public init(clientRequestToken: String? = CreateWirelessDeviceRequest.idempotencyToken(), description: String? = nil, destinationName: String, loRaWAN: LoRaWANDevice? = nil, name: String? = nil, positioning: PositioningConfigStatus? = nil, sidewalk: SidewalkCreateWirelessDevice? = nil, tags: [Tag]? = nil, type: WirelessDeviceType) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.destinationName = destinationName
            self.loRaWAN = loRaWAN
            self.name = name
            self.positioning = positioning
            self.sidewalk = sidewalk
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.sidewalk?.validate(name: "\(name).sidewalk")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case destinationName = "DestinationName"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case positioning = "Positioning"
            case sidewalk = "Sidewalk"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct CreateWirelessDeviceResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        /// The ID of the new wireless device.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateWirelessGatewayRequest: AWSEncodableShape {
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The description of the new resource.
        public let description: String?
        /// The gateway configuration information to use to create the wireless gateway.
        public let loRaWAN: LoRaWANGateway
        /// The name of the new resource.
        public let name: String?
        /// The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateWirelessGatewayRequest.idempotencyToken(), description: String? = nil, loRaWAN: LoRaWANGateway, name: String? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.loRaWAN = loRaWAN
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.loRaWAN.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateWirelessGatewayResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        /// The ID of the new wireless gateway.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateWirelessGatewayTaskDefinitionRequest: AWSEncodableShape {
        /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
        public let autoCreateTasks: Bool
        /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see Ensuring idempotency in Amazon EC2 API requests.
        public let clientRequestToken: String?
        /// The name of the new resource.
        public let name: String?
        /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?
        /// Information about the gateways to update.
        public let update: UpdateWirelessGatewayTaskCreate?

        @inlinable
        public init(autoCreateTasks: Bool = false, clientRequestToken: String? = CreateWirelessGatewayTaskDefinitionRequest.idempotencyToken(), name: String? = nil, tags: [Tag]? = nil, update: UpdateWirelessGatewayTaskCreate? = nil) {
            self.autoCreateTasks = autoCreateTasks
            self.clientRequestToken = clientRequestToken
            self.name = name
            self.tags = tags
            self.update = update
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.update?.validate(name: "\(name).update")
        }

        private enum CodingKeys: String, CodingKey {
            case autoCreateTasks = "AutoCreateTasks"
            case clientRequestToken = "ClientRequestToken"
            case name = "Name"
            case tags = "Tags"
            case update = "Update"
        }
    }

    public struct CreateWirelessGatewayTaskDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The ID of the new wireless gateway task definition.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateWirelessGatewayTaskRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String
        /// The ID of the WirelessGatewayTaskDefinition.
        public let wirelessGatewayTaskDefinitionId: String

        @inlinable
        public init(id: String, wirelessGatewayTaskDefinitionId: String) {
            self.id = id
            self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.wirelessGatewayTaskDefinitionId, forKey: .wirelessGatewayTaskDefinitionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.wirelessGatewayTaskDefinitionId, name: "wirelessGatewayTaskDefinitionId", parent: name, max: 36)
            try self.validate(self.wirelessGatewayTaskDefinitionId, name: "wirelessGatewayTaskDefinitionId", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
        }
    }

    public struct CreateWirelessGatewayTaskResponse: AWSDecodableShape {
        /// The status of the request.
        public let status: WirelessGatewayTaskStatus?
        /// The ID of the WirelessGatewayTaskDefinition.
        public let wirelessGatewayTaskDefinitionId: String?

        @inlinable
        public init(status: WirelessGatewayTaskStatus? = nil, wirelessGatewayTaskDefinitionId: String? = nil) {
            self.status = status
            self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
        }
    }

    public struct DakCertificateMetadata: AWSDecodableShape {
        /// The advertised product ID (APID) that's used for pre-production and production applications.
        public let apId: String?
        /// The certificate ID for the DAK.
        public let certificateId: String
        /// The device type ID that's used for prototyping applications.
        public let deviceTypeId: String?
        /// Whether factory support has been enabled.
        public let factorySupport: Bool?
        /// The maximum number of signatures that the DAK can sign. A value of -1 indicates that there's no device limit.
        public let maxAllowedSignature: Int?

        @inlinable
        public init(apId: String? = nil, certificateId: String, deviceTypeId: String? = nil, factorySupport: Bool? = nil, maxAllowedSignature: Int? = nil) {
            self.apId = apId
            self.certificateId = certificateId
            self.deviceTypeId = deviceTypeId
            self.factorySupport = factorySupport
            self.maxAllowedSignature = maxAllowedSignature
        }

        private enum CodingKeys: String, CodingKey {
            case apId = "ApId"
            case certificateId = "CertificateId"
            case deviceTypeId = "DeviceTypeId"
            case factorySupport = "FactorySupport"
            case maxAllowedSignature = "MaxAllowedSignature"
        }
    }

    public struct DeleteDestinationRequest: AWSEncodableShape {
        /// The name of the resource to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDeviceProfileRequest: AWSEncodableShape {
        /// The ID of the resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeviceProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFuotaTaskRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMulticastGroupRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMulticastGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNetworkAnalyzerConfigurationRequest: AWSEncodableShape {
        public let configurationName: String

        @inlinable
        public init(configurationName: String) {
            self.configurationName = configurationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationName, key: "ConfigurationName")
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationName, name: "configurationName", parent: name, max: 1024)
            try self.validate(self.configurationName, name: "configurationName", parent: name, min: 1)
            try self.validate(self.configurationName, name: "configurationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNetworkAnalyzerConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueuedMessagesRequest: AWSEncodableShape {
        /// The ID of a given wireless device for which downlink messages will be deleted.
        public let id: String
        /// If message ID is "*", it cleares the entire downlink queue for a given device, specified by the wireless device ID. Otherwise, the downlink message with the specified message ID will be deleted.
        public let messageId: String
        /// The wireless device type, which can be either Sidewalk or LoRaWAN.
        public let wirelessDeviceType: WirelessDeviceType?

        @inlinable
        public init(id: String, messageId: String, wirelessDeviceType: WirelessDeviceType? = nil) {
            self.id = id
            self.messageId = messageId
            self.wirelessDeviceType = wirelessDeviceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodeQuery(self.messageId, key: "messageId")
            request.encodeQuery(self.wirelessDeviceType, key: "WirelessDeviceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQueuedMessagesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServiceProfileRequest: AWSEncodableShape {
        /// The ID of the resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWirelessDeviceImportTaskRequest: AWSEncodableShape {
        /// The unique identifier of the import task to be deleted.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWirelessDeviceImportTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWirelessDeviceRequest: AWSEncodableShape {
        /// The ID of the resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWirelessDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWirelessGatewayRequest: AWSEncodableShape {
        /// The ID of the resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWirelessGatewayResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWirelessGatewayTaskDefinitionRequest: AWSEncodableShape {
        /// The ID of the resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWirelessGatewayTaskDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWirelessGatewayTaskRequest: AWSEncodableShape {
        /// The ID of the resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWirelessGatewayTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterWirelessDeviceRequest: AWSEncodableShape {
        /// The identifier of the wireless device to deregister from AWS IoT Wireless.
        public let identifier: String
        /// The type of wireless device to deregister from AWS IoT Wireless, which can be LoRaWAN or Sidewalk.
        public let wirelessDeviceType: WirelessDeviceType?

        @inlinable
        public init(identifier: String, wirelessDeviceType: WirelessDeviceType? = nil) {
            self.identifier = identifier
            self.wirelessDeviceType = wirelessDeviceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.wirelessDeviceType, key: "WirelessDeviceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterWirelessDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Destinations: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The description of the resource.
        public let description: String?
        /// The rule name or topic rule to send messages to.
        public let expression: String?
        /// The type of value in Expression.
        public let expressionType: ExpressionType?
        /// The name of the resource.
        public let name: String?
        /// The ARN of the IAM Role that authorizes the destination.
        public let roleArn: String?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, expression: String? = nil, expressionType: ExpressionType? = nil, name: String? = nil, roleArn: String? = nil) {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case expression = "Expression"
            case expressionType = "ExpressionType"
            case name = "Name"
            case roleArn = "RoleArn"
        }
    }

    public struct DeviceProfile: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The ID of the device profile.
        public let id: String?
        /// The name of the resource.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DeviceRegistrationStateEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Device registration state event configuration object for enabling or disabling Sidewalk related event topics.
        public let sidewalk: SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID device registration state event topic is enabled or disabled.
        public let wirelessDeviceIdEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(sidewalk: SidewalkEventNotificationConfigurations? = nil, wirelessDeviceIdEventTopic: EventNotificationTopicStatus? = nil) {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
            case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
        }
    }

    public struct DeviceRegistrationStateResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.
        public let sidewalk: SidewalkResourceTypeEventConfiguration?

        @inlinable
        public init(sidewalk: SidewalkResourceTypeEventConfiguration? = nil) {
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
        }
    }

    public struct Dimension: AWSEncodableShape & AWSDecodableShape {
        /// The name of the dimension.
        public let name: DimensionName?
        /// The dimension's value.
        public let value: String?

        @inlinable
        public init(name: DimensionName? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct DisassociateAwsAccountFromPartnerAccountRequest: AWSEncodableShape {
        /// The partner account ID to disassociate from the AWS account.
        public let partnerAccountId: String
        /// The partner type.
        public let partnerType: PartnerType

        @inlinable
        public init(partnerAccountId: String, partnerType: PartnerType) {
            self.partnerAccountId = partnerAccountId
            self.partnerType = partnerType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnerAccountId, key: "PartnerAccountId")
            request.encodeQuery(self.partnerType, key: "partnerType")
        }

        public func validate(name: String) throws {
            try self.validate(self.partnerAccountId, name: "partnerAccountId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateAwsAccountFromPartnerAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMulticastGroupFromFuotaTaskRequest: AWSEncodableShape {
        public let id: String
        public let multicastGroupId: String

        @inlinable
        public init(id: String, multicastGroupId: String) {
            self.id = id
            self.multicastGroupId = multicastGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodePath(self.multicastGroupId, key: "MulticastGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.multicastGroupId, name: "multicastGroupId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMulticastGroupFromFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateWirelessDeviceFromFuotaTaskRequest: AWSEncodableShape {
        public let id: String
        public let wirelessDeviceId: String

        @inlinable
        public init(id: String, wirelessDeviceId: String) {
            self.id = id
            self.wirelessDeviceId = wirelessDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodePath(self.wirelessDeviceId, key: "WirelessDeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.wirelessDeviceId, name: "wirelessDeviceId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateWirelessDeviceFromFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateWirelessDeviceFromMulticastGroupRequest: AWSEncodableShape {
        public let id: String
        public let wirelessDeviceId: String

        @inlinable
        public init(id: String, wirelessDeviceId: String) {
            self.id = id
            self.wirelessDeviceId = wirelessDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodePath(self.wirelessDeviceId, key: "WirelessDeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.wirelessDeviceId, name: "wirelessDeviceId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateWirelessDeviceFromMulticastGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateWirelessDeviceFromThingRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateWirelessDeviceFromThingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateWirelessGatewayFromCertificateRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateWirelessGatewayFromCertificateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateWirelessGatewayFromThingRequest: AWSEncodableShape {
        /// The ID of the resource to update.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateWirelessGatewayFromThingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DownlinkQueueMessage: AWSDecodableShape {
        public let loRaWAN: LoRaWANSendDataToDevice?
        ///  The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.
        public let messageId: String?
        /// The time at which Iot Wireless received the downlink message.
        public let receivedAt: String?
        /// The transmit mode to use for sending data to the wireless device. This can be 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
        public let transmitMode: Int?

        @inlinable
        public init(loRaWAN: LoRaWANSendDataToDevice? = nil, messageId: String? = nil, receivedAt: String? = nil, transmitMode: Int? = nil) {
            self.loRaWAN = loRaWAN
            self.messageId = messageId
            self.receivedAt = receivedAt
            self.transmitMode = transmitMode
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
            case messageId = "MessageId"
            case receivedAt = "ReceivedAt"
            case transmitMode = "TransmitMode"
        }
    }

    public struct EventConfigurationItem: AWSDecodableShape {
        public let events: EventNotificationItemConfigurations?
        /// Resource identifier opted in for event messaging.
        public let identifier: String?
        /// Identifier type of the particular resource identifier for event configuration.
        public let identifierType: IdentifierType?
        /// Partner type of the resource if the identifier type is PartnerAccountId.
        public let partnerType: EventNotificationPartnerType?

        @inlinable
        public init(events: EventNotificationItemConfigurations? = nil, identifier: String? = nil, identifierType: IdentifierType? = nil, partnerType: EventNotificationPartnerType? = nil) {
            self.events = events
            self.identifier = identifier
            self.identifierType = identifierType
            self.partnerType = partnerType
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case identifier = "Identifier"
            case identifierType = "IdentifierType"
            case partnerType = "PartnerType"
        }
    }

    public struct EventNotificationItemConfigurations: AWSDecodableShape {
        /// Connection status event configuration for an event configuration item.
        public let connectionStatus: ConnectionStatusEventConfiguration?
        /// Device registration state event configuration for an event configuration item.
        public let deviceRegistrationState: DeviceRegistrationStateEventConfiguration?
        /// Join event configuration for an event configuration item.
        public let join: JoinEventConfiguration?
        /// Message delivery status event configuration for an event configuration item.
        public let messageDeliveryStatus: MessageDeliveryStatusEventConfiguration?
        /// Proximity event configuration for an event configuration item.
        public let proximity: ProximityEventConfiguration?

        @inlinable
        public init(connectionStatus: ConnectionStatusEventConfiguration? = nil, deviceRegistrationState: DeviceRegistrationStateEventConfiguration? = nil, join: JoinEventConfiguration? = nil, messageDeliveryStatus: MessageDeliveryStatusEventConfiguration? = nil, proximity: ProximityEventConfiguration? = nil) {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case deviceRegistrationState = "DeviceRegistrationState"
            case join = "Join"
            case messageDeliveryStatus = "MessageDeliveryStatus"
            case proximity = "Proximity"
        }
    }

    public struct FPorts: AWSEncodableShape & AWSDecodableShape {
        /// Optional LoRaWAN application information, which can be used for geolocation.
        public let applications: [ApplicationConfig]?
        public let clockSync: Int?
        public let fuota: Int?
        public let multicast: Int?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public let positioning: Positioning?

        @inlinable
        public init(applications: [ApplicationConfig]? = nil, clockSync: Int? = nil, fuota: Int? = nil, multicast: Int? = nil, positioning: Positioning? = nil) {
            self.applications = applications
            self.clockSync = clockSync
            self.fuota = fuota
            self.multicast = multicast
            self.positioning = positioning
        }

        public func validate(name: String) throws {
            try self.applications?.forEach {
                try $0.validate(name: "\(name).applications[]")
            }
            try self.validate(self.clockSync, name: "clockSync", parent: name, max: 223)
            try self.validate(self.clockSync, name: "clockSync", parent: name, min: 1)
            try self.validate(self.fuota, name: "fuota", parent: name, max: 223)
            try self.validate(self.fuota, name: "fuota", parent: name, min: 1)
            try self.validate(self.multicast, name: "multicast", parent: name, max: 223)
            try self.validate(self.multicast, name: "multicast", parent: name, min: 1)
            try self.positioning?.validate(name: "\(name).positioning")
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "Applications"
            case clockSync = "ClockSync"
            case fuota = "Fuota"
            case multicast = "Multicast"
            case positioning = "Positioning"
        }
    }

    public struct FuotaTask: AWSDecodableShape {
        public let arn: String?
        public let id: String?
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct FuotaTaskEventLogOption: AWSEncodableShape & AWSDecodableShape {
        public let event: FuotaTaskEvent
        public let logLevel: LogLevel

        @inlinable
        public init(event: FuotaTaskEvent, logLevel: LogLevel) {
            self.event = event
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case event = "Event"
            case logLevel = "LogLevel"
        }
    }

    public struct FuotaTaskLogOption: AWSEncodableShape & AWSDecodableShape {
        public let events: [FuotaTaskEventLogOption]?
        public let logLevel: LogLevel
        /// The FUOTA task type.
        public let type: FuotaTaskType

        @inlinable
        public init(events: [FuotaTaskEventLogOption]? = nil, logLevel: LogLevel, type: FuotaTaskType) {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case logLevel = "LogLevel"
            case type = "Type"
        }
    }

    public struct GatewayListItem: AWSEncodableShape & AWSDecodableShape {
        /// The frequency to use for the gateways when sending a downlink message to the wireless device.
        public let downlinkFrequency: Int
        /// The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.
        public let gatewayId: String

        @inlinable
        public init(downlinkFrequency: Int, gatewayId: String) {
            self.downlinkFrequency = downlinkFrequency
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.downlinkFrequency, name: "downlinkFrequency", parent: name, max: 1000000000)
            try self.validate(self.downlinkFrequency, name: "downlinkFrequency", parent: name, min: 100000000)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case downlinkFrequency = "DownlinkFrequency"
            case gatewayId = "GatewayId"
        }
    }

    public struct GetDestinationRequest: AWSEncodableShape {
        /// The name of the resource to get.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDestinationResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The description of the resource.
        public let description: String?
        /// The rule name or topic rule to send messages to.
        public let expression: String?
        /// The type of value in Expression.
        public let expressionType: ExpressionType?
        /// The name of the resource.
        public let name: String?
        /// The ARN of the IAM Role that authorizes the destination.
        public let roleArn: String?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, expression: String? = nil, expressionType: ExpressionType? = nil, name: String? = nil, roleArn: String? = nil) {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case expression = "Expression"
            case expressionType = "ExpressionType"
            case name = "Name"
            case roleArn = "RoleArn"
        }
    }

    public struct GetDeviceProfileRequest: AWSEncodableShape {
        /// The ID of the resource to get.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The ID of the device profile.
        public let id: String?
        /// Information about the device profile.
        public let loRaWAN: LoRaWANDeviceProfile?
        /// The name of the resource.
        public let name: String?
        /// Information about the Sidewalk parameters in the device profile.
        public let sidewalk: SidewalkGetDeviceProfile?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, loRaWAN: LoRaWANDeviceProfile? = nil, name: String? = nil, sidewalk: SidewalkGetDeviceProfile? = nil) {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case sidewalk = "Sidewalk"
        }
    }

    public struct GetEventConfigurationByResourceTypesRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEventConfigurationByResourceTypesResponse: AWSDecodableShape {
        /// Resource type event configuration for the connection status event.
        public let connectionStatus: ConnectionStatusResourceTypeEventConfiguration?
        /// Resource type event configuration for the device registration state event.
        public let deviceRegistrationState: DeviceRegistrationStateResourceTypeEventConfiguration?
        /// Resource type event configuration for the join event.
        public let join: JoinResourceTypeEventConfiguration?
        /// Resource type event configuration object for the message delivery status event.
        public let messageDeliveryStatus: MessageDeliveryStatusResourceTypeEventConfiguration?
        /// Resource type event configuration for the proximity event.
        public let proximity: ProximityResourceTypeEventConfiguration?

        @inlinable
        public init(connectionStatus: ConnectionStatusResourceTypeEventConfiguration? = nil, deviceRegistrationState: DeviceRegistrationStateResourceTypeEventConfiguration? = nil, join: JoinResourceTypeEventConfiguration? = nil, messageDeliveryStatus: MessageDeliveryStatusResourceTypeEventConfiguration? = nil, proximity: ProximityResourceTypeEventConfiguration? = nil) {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case deviceRegistrationState = "DeviceRegistrationState"
            case join = "Join"
            case messageDeliveryStatus = "MessageDeliveryStatus"
            case proximity = "Proximity"
        }
    }

    public struct GetFuotaTaskRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFuotaTaskResponse: AWSDecodableShape {
        public let arn: String?
        public let createdAt: Date?
        public let description: String?
        public let descriptor: String?
        public let firmwareUpdateImage: String?
        public let firmwareUpdateRole: String?
        public let fragmentIntervalMS: Int?
        public let fragmentSizeBytes: Int?
        public let id: String?
        public let loRaWAN: LoRaWANFuotaTaskGetInfo?
        public let name: String?
        public let redundancyPercent: Int?
        public let status: FuotaTaskStatus?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, description: String? = nil, descriptor: String? = nil, firmwareUpdateImage: String? = nil, firmwareUpdateRole: String? = nil, fragmentIntervalMS: Int? = nil, fragmentSizeBytes: Int? = nil, id: String? = nil, loRaWAN: LoRaWANFuotaTaskGetInfo? = nil, name: String? = nil, redundancyPercent: Int? = nil, status: FuotaTaskStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.descriptor = descriptor
            self.firmwareUpdateImage = firmwareUpdateImage
            self.firmwareUpdateRole = firmwareUpdateRole
            self.fragmentIntervalMS = fragmentIntervalMS
            self.fragmentSizeBytes = fragmentSizeBytes
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.redundancyPercent = redundancyPercent
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case description = "Description"
            case descriptor = "Descriptor"
            case firmwareUpdateImage = "FirmwareUpdateImage"
            case firmwareUpdateRole = "FirmwareUpdateRole"
            case fragmentIntervalMS = "FragmentIntervalMS"
            case fragmentSizeBytes = "FragmentSizeBytes"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case redundancyPercent = "RedundancyPercent"
            case status = "Status"
        }
    }

    public struct GetLogLevelsByResourceTypesRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetLogLevelsByResourceTypesResponse: AWSDecodableShape {
        public let defaultLogLevel: LogLevel?
        public let fuotaTaskLogOptions: [FuotaTaskLogOption]?
        public let wirelessDeviceLogOptions: [WirelessDeviceLogOption]?
        public let wirelessGatewayLogOptions: [WirelessGatewayLogOption]?

        @inlinable
        public init(defaultLogLevel: LogLevel? = nil, fuotaTaskLogOptions: [FuotaTaskLogOption]? = nil, wirelessDeviceLogOptions: [WirelessDeviceLogOption]? = nil, wirelessGatewayLogOptions: [WirelessGatewayLogOption]? = nil) {
            self.defaultLogLevel = defaultLogLevel
            self.fuotaTaskLogOptions = fuotaTaskLogOptions
            self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
        }

        private enum CodingKeys: String, CodingKey {
            case defaultLogLevel = "DefaultLogLevel"
            case fuotaTaskLogOptions = "FuotaTaskLogOptions"
            case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
            case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
        }
    }

    public struct GetMetricConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMetricConfigurationResponse: AWSDecodableShape {
        /// The configuration status of the AWS account for summary metric aggregation.
        public let summaryMetric: SummaryMetricConfiguration?

        @inlinable
        public init(summaryMetric: SummaryMetricConfiguration? = nil) {
            self.summaryMetric = summaryMetric
        }

        private enum CodingKeys: String, CodingKey {
            case summaryMetric = "SummaryMetric"
        }
    }

    public struct GetMetricsRequest: AWSEncodableShape {
        /// The list of queries to retrieve the summary metrics.
        public let summaryMetricQueries: [SummaryMetricQuery]?

        @inlinable
        public init(summaryMetricQueries: [SummaryMetricQuery]? = nil) {
            self.summaryMetricQueries = summaryMetricQueries
        }

        public func validate(name: String) throws {
            try self.summaryMetricQueries?.forEach {
                try $0.validate(name: "\(name).summaryMetricQueries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case summaryMetricQueries = "SummaryMetricQueries"
        }
    }

    public struct GetMetricsResponse: AWSDecodableShape {
        /// The list of summary metrics that were retrieved.
        public let summaryMetricQueryResults: [SummaryMetricQueryResult]?

        @inlinable
        public init(summaryMetricQueryResults: [SummaryMetricQueryResult]? = nil) {
            self.summaryMetricQueryResults = summaryMetricQueryResults
        }

        private enum CodingKeys: String, CodingKey {
            case summaryMetricQueryResults = "SummaryMetricQueryResults"
        }
    }

    public struct GetMulticastGroupRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMulticastGroupResponse: AWSDecodableShape {
        public let arn: String?
        public let createdAt: Date?
        public let description: String?
        public let id: String?
        public let loRaWAN: LoRaWANMulticastGet?
        public let name: String?
        public let status: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, loRaWAN: LoRaWANMulticastGet? = nil, name: String? = nil, status: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct GetMulticastGroupSessionRequest: AWSEncodableShape {
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMulticastGroupSessionResponse: AWSDecodableShape {
        public let loRaWAN: LoRaWANMulticastSession?

        @inlinable
        public init(loRaWAN: LoRaWANMulticastSession? = nil) {
            self.loRaWAN = loRaWAN
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct GetNetworkAnalyzerConfigurationRequest: AWSEncodableShape {
        public let configurationName: String

        @inlinable
        public init(configurationName: String) {
            self.configurationName = configurationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationName, key: "ConfigurationName")
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationName, name: "configurationName", parent: name, max: 1024)
            try self.validate(self.configurationName, name: "configurationName", parent: name, min: 1)
            try self.validate(self.configurationName, name: "configurationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkAnalyzerConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        public let description: String?
        /// List of multicast group resources that have been added to the network analyzer configuration.
        public let multicastGroups: [String]?
        public let name: String?
        public let traceContent: TraceContent?
        /// List of wireless device resources that have been added to the network analyzer configuration.
        public let wirelessDevices: [String]?
        /// List of wireless gateway resources that have been added to the network analyzer configuration.
        public let wirelessGateways: [String]?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, multicastGroups: [String]? = nil, name: String? = nil, traceContent: TraceContent? = nil, wirelessDevices: [String]? = nil, wirelessGateways: [String]? = nil) {
            self.arn = arn
            self.description = description
            self.multicastGroups = multicastGroups
            self.name = name
            self.traceContent = traceContent
            self.wirelessDevices = wirelessDevices
            self.wirelessGateways = wirelessGateways
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case multicastGroups = "MulticastGroups"
            case name = "Name"
            case traceContent = "TraceContent"
            case wirelessDevices = "WirelessDevices"
            case wirelessGateways = "WirelessGateways"
        }
    }

    public struct GetPartnerAccountRequest: AWSEncodableShape {
        /// The partner account ID to disassociate from the AWS account.
        public let partnerAccountId: String
        /// The partner type.
        public let partnerType: PartnerType

        @inlinable
        public init(partnerAccountId: String, partnerType: PartnerType) {
            self.partnerAccountId = partnerAccountId
            self.partnerType = partnerType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnerAccountId, key: "PartnerAccountId")
            request.encodeQuery(self.partnerType, key: "partnerType")
        }

        public func validate(name: String) throws {
            try self.validate(self.partnerAccountId, name: "partnerAccountId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPartnerAccountResponse: AWSDecodableShape {
        /// Whether the partner account is linked to the AWS account.
        public let accountLinked: Bool?
        /// The Sidewalk account credentials.
        public let sidewalk: SidewalkAccountInfoWithFingerprint?

        @inlinable
        public init(accountLinked: Bool? = nil, sidewalk: SidewalkAccountInfoWithFingerprint? = nil) {
            self.accountLinked = accountLinked
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case accountLinked = "AccountLinked"
            case sidewalk = "Sidewalk"
        }
    }

    public struct GetPositionConfigurationRequest: AWSEncodableShape {
        /// Resource identifier used in a position configuration.
        public let resourceIdentifier: String
        /// Resource type of the resource for which position configuration is retrieved.
        public let resourceType: PositionResourceType

        @inlinable
        public init(resourceIdentifier: String, resourceType: PositionResourceType) {
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPositionConfigurationResponse: AWSDecodableShape {
        /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public let destination: String?
        /// The wrapper for the solver configuration details object.
        public let solvers: PositionSolverDetails?

        @inlinable
        public init(destination: String? = nil, solvers: PositionSolverDetails? = nil) {
            self.destination = destination
            self.solvers = solvers
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case solvers = "Solvers"
        }
    }

    public struct GetPositionEstimateRequest: AWSEncodableShape {
        /// Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.
        public let cellTowers: CellTowers?
        /// Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.
        public let gnss: Gnss?
        /// Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.
        public let ip: Ip?
        /// Optional information that specifies the time when the position information will be resolved. It uses the Unix timestamp format. If not specified, the time at which the request was received will be used.
        public let timestamp: Date?
        /// Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.
        public let wiFiAccessPoints: [WiFiAccessPoint]?

        @inlinable
        public init(cellTowers: CellTowers? = nil, gnss: Gnss? = nil, ip: Ip? = nil, timestamp: Date? = nil, wiFiAccessPoints: [WiFiAccessPoint]? = nil) {
            self.cellTowers = cellTowers
            self.gnss = gnss
            self.ip = ip
            self.timestamp = timestamp
            self.wiFiAccessPoints = wiFiAccessPoints
        }

        public func validate(name: String) throws {
            try self.cellTowers?.validate(name: "\(name).cellTowers")
            try self.gnss?.validate(name: "\(name).gnss")
            try self.wiFiAccessPoints?.forEach {
                try $0.validate(name: "\(name).wiFiAccessPoints[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cellTowers = "CellTowers"
            case gnss = "Gnss"
            case ip = "Ip"
            case timestamp = "Timestamp"
            case wiFiAccessPoints = "WiFiAccessPoints"
        }
    }

    public struct GetPositionEstimateResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The position information of the resource, displayed as a JSON payload. The payload is of type blob and uses the GeoJSON format, which a format that's used to encode geographic data structures. A sample payload contains the timestamp information, the WGS84 coordinates of the location, and the accuracy and confidence level. For more information and examples, see Resolve device location (console).
        public let geoJsonPayload: AWSHTTPBody

        @inlinable
        public init(geoJsonPayload: AWSHTTPBody) {
            self.geoJsonPayload = geoJsonPayload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.geoJsonPayload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPositionRequest: AWSEncodableShape {
        /// Resource identifier used to retrieve the position information.
        public let resourceIdentifier: String
        /// Resource type of the resource for which position information is retrieved.
        public let resourceType: PositionResourceType

        @inlinable
        public init(resourceIdentifier: String, resourceType: PositionResourceType) {
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPositionResponse: AWSDecodableShape {
        /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of 0.0 value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
        public let accuracy: Accuracy?
        /// The position information of the resource.
        public let position: [Float]?
        /// The vendor of the positioning solver.
        public let solverProvider: PositionSolverProvider?
        /// The type of solver used to identify the position of the resource.
        public let solverType: PositionSolverType?
        /// The version of the positioning solver.
        public let solverVersion: String?
        /// The timestamp at which the device's position was determined.
        public let timestamp: String?

        @inlinable
        public init(accuracy: Accuracy? = nil, position: [Float]? = nil, solverProvider: PositionSolverProvider? = nil, solverType: PositionSolverType? = nil, solverVersion: String? = nil, timestamp: String? = nil) {
            self.accuracy = accuracy
            self.position = position
            self.solverProvider = solverProvider
            self.solverType = solverType
            self.solverVersion = solverVersion
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case position = "Position"
            case solverProvider = "SolverProvider"
            case solverType = "SolverType"
            case solverVersion = "SolverVersion"
            case timestamp = "Timestamp"
        }
    }

    public struct GetResourceEventConfigurationRequest: AWSEncodableShape {
        /// Resource identifier to opt in for event messaging.
        public let identifier: String
        /// Identifier type of the particular resource identifier for event configuration.
        public let identifierType: IdentifierType
        /// Partner type of the resource if the identifier type is PartnerAccountId.
        public let partnerType: EventNotificationPartnerType?

        @inlinable
        public init(identifier: String, identifierType: IdentifierType, partnerType: EventNotificationPartnerType? = nil) {
            self.identifier = identifier
            self.identifierType = identifierType
            self.partnerType = partnerType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.identifierType, key: "identifierType")
            request.encodeQuery(self.partnerType, key: "partnerType")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceEventConfigurationResponse: AWSDecodableShape {
        /// Event configuration for the connection status event.
        public let connectionStatus: ConnectionStatusEventConfiguration?
        /// Event configuration for the device registration state event.
        public let deviceRegistrationState: DeviceRegistrationStateEventConfiguration?
        /// Event configuration for the join event.
        public let join: JoinEventConfiguration?
        /// Event configuration for the message delivery status event.
        public let messageDeliveryStatus: MessageDeliveryStatusEventConfiguration?
        /// Event configuration for the proximity event.
        public let proximity: ProximityEventConfiguration?

        @inlinable
        public init(connectionStatus: ConnectionStatusEventConfiguration? = nil, deviceRegistrationState: DeviceRegistrationStateEventConfiguration? = nil, join: JoinEventConfiguration? = nil, messageDeliveryStatus: MessageDeliveryStatusEventConfiguration? = nil, proximity: ProximityEventConfiguration? = nil) {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case deviceRegistrationState = "DeviceRegistrationState"
            case join = "Join"
            case messageDeliveryStatus = "MessageDeliveryStatus"
            case proximity = "Proximity"
        }
    }

    public struct GetResourceLogLevelRequest: AWSEncodableShape {
        public let resourceIdentifier: String
        /// The type of resource, which can be WirelessDevice, WirelessGateway, or FuotaTask.
        public let resourceType: String

        @inlinable
        public init(resourceIdentifier: String, resourceType: String) {
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceLogLevelResponse: AWSDecodableShape {
        public let logLevel: LogLevel?

        @inlinable
        public init(logLevel: LogLevel? = nil) {
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
        }
    }

    public struct GetResourcePositionRequest: AWSEncodableShape {
        /// The identifier of the resource for which position information is retrieved. It can be the wireless device ID or the wireless gateway ID, depending on the resource type.
        public let resourceIdentifier: String
        /// The type of resource for which position information is retrieved, which can be a wireless device or a wireless gateway.
        public let resourceType: PositionResourceType

        @inlinable
        public init(resourceIdentifier: String, resourceType: PositionResourceType) {
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePositionResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see GeoJSON.
        public let geoJsonPayload: AWSHTTPBody

        @inlinable
        public init(geoJsonPayload: AWSHTTPBody) {
            self.geoJsonPayload = geoJsonPayload
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.geoJsonPayload = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceEndpointRequest: AWSEncodableShape {
        /// The service type for which to get endpoint information about. Can be CUPS for the Configuration and Update Server endpoint, or LNS for the LoRaWAN Network Server endpoint.
        public let serviceType: WirelessGatewayServiceType?

        @inlinable
        public init(serviceType: WirelessGatewayServiceType? = nil) {
            self.serviceType = serviceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.serviceType, key: "serviceType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceEndpointResponse: AWSDecodableShape {
        /// The Root CA of the server trust certificate.
        public let serverTrust: String?
        /// The service endpoint value.
        public let serviceEndpoint: String?
        /// The endpoint's service type.
        public let serviceType: WirelessGatewayServiceType?

        @inlinable
        public init(serverTrust: String? = nil, serviceEndpoint: String? = nil, serviceType: WirelessGatewayServiceType? = nil) {
            self.serverTrust = serverTrust
            self.serviceEndpoint = serviceEndpoint
            self.serviceType = serviceType
        }

        private enum CodingKeys: String, CodingKey {
            case serverTrust = "ServerTrust"
            case serviceEndpoint = "ServiceEndpoint"
            case serviceType = "ServiceType"
        }
    }

    public struct GetServiceProfileRequest: AWSEncodableShape {
        /// The ID of the resource to get.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The ID of the service profile.
        public let id: String?
        /// Information about the service profile.
        public let loRaWAN: LoRaWANGetServiceProfileInfo?
        /// The name of the resource.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, loRaWAN: LoRaWANGetServiceProfileInfo? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
        }
    }

    public struct GetWirelessDeviceImportTaskRequest: AWSEncodableShape {
        /// The identifier of the import task for which information is requested.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessDeviceImportTaskResponse: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the import task.
        public let arn: String?
        /// The time at which the import task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The name of the destination that's assigned to the wireless devices in the import task.
        public let destinationName: String?
        /// The number of devices in the import task that failed to onboard to the import task.
        public let failedImportedDeviceCount: Int64?
        /// The identifier of the import task for which information is retrieved.
        public let id: String?
        /// The number of devices in the import task that are waiting for the control log to start processing.
        public let initializedImportedDeviceCount: Int64?
        /// The number of devices in the import task that have been onboarded to the import task.
        public let onboardedImportedDeviceCount: Int64?
        /// The number of devices in the import task that are waiting in the import task queue to be onboarded.
        public let pendingImportedDeviceCount: Int64?
        /// The Sidewalk-related information about an import task.
        public let sidewalk: SidewalkGetStartImportInfo?
        /// The import task status.
        public let status: ImportTaskStatus?
        /// The reason for the provided status information, such as a validation error that causes the import task to fail.
        public let statusReason: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, destinationName: String? = nil, failedImportedDeviceCount: Int64? = nil, id: String? = nil, initializedImportedDeviceCount: Int64? = nil, onboardedImportedDeviceCount: Int64? = nil, pendingImportedDeviceCount: Int64? = nil, sidewalk: SidewalkGetStartImportInfo? = nil, status: ImportTaskStatus? = nil, statusReason: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.failedImportedDeviceCount = failedImportedDeviceCount
            self.id = id
            self.initializedImportedDeviceCount = initializedImportedDeviceCount
            self.onboardedImportedDeviceCount = onboardedImportedDeviceCount
            self.pendingImportedDeviceCount = pendingImportedDeviceCount
            self.sidewalk = sidewalk
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case destinationName = "DestinationName"
            case failedImportedDeviceCount = "FailedImportedDeviceCount"
            case id = "Id"
            case initializedImportedDeviceCount = "InitializedImportedDeviceCount"
            case onboardedImportedDeviceCount = "OnboardedImportedDeviceCount"
            case pendingImportedDeviceCount = "PendingImportedDeviceCount"
            case sidewalk = "Sidewalk"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct GetWirelessDeviceRequest: AWSEncodableShape {
        /// The identifier of the wireless device to get.
        public let identifier: String
        /// The type of identifier used in identifier.
        public let identifierType: WirelessDeviceIdType

        @inlinable
        public init(identifier: String, identifierType: WirelessDeviceIdType) {
            self.identifier = identifier
            self.identifierType = identifierType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.identifierType, key: "identifierType")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessDeviceResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The description of the resource.
        public let description: String?
        /// The name of the destination to which the device is assigned.
        public let destinationName: String?
        /// The ID of the wireless device.
        public let id: String?
        /// Information about the wireless device.
        public let loRaWAN: LoRaWANDevice?
        /// The name of the resource.
        public let name: String?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public let positioning: PositioningConfigStatus?
        /// Sidewalk device object.
        public let sidewalk: SidewalkDevice?
        /// The ARN of the thing associated with the wireless device.
        public let thingArn: String?
        /// The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.
        public let thingName: String?
        /// The wireless device type.
        public let type: WirelessDeviceType?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, destinationName: String? = nil, id: String? = nil, loRaWAN: LoRaWANDevice? = nil, name: String? = nil, positioning: PositioningConfigStatus? = nil, sidewalk: SidewalkDevice? = nil, thingArn: String? = nil, thingName: String? = nil, type: WirelessDeviceType? = nil) {
            self.arn = arn
            self.description = description
            self.destinationName = destinationName
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.positioning = positioning
            self.sidewalk = sidewalk
            self.thingArn = thingArn
            self.thingName = thingName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case destinationName = "DestinationName"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case positioning = "Positioning"
            case sidewalk = "Sidewalk"
            case thingArn = "ThingArn"
            case thingName = "ThingName"
            case type = "Type"
        }
    }

    public struct GetWirelessDeviceStatisticsRequest: AWSEncodableShape {
        /// The ID of the wireless device for which to get the data.
        public let wirelessDeviceId: String

        @inlinable
        public init(wirelessDeviceId: String) {
            self.wirelessDeviceId = wirelessDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.wirelessDeviceId, key: "WirelessDeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.wirelessDeviceId, name: "wirelessDeviceId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessDeviceStatisticsResponse: AWSDecodableShape {
        /// The date and time when the most recent uplink was received.  This value is only valid for 3 months.
        public let lastUplinkReceivedAt: String?
        /// Information about the wireless device's operations.
        public let loRaWAN: LoRaWANDeviceMetadata?
        /// MetaData for Sidewalk device.
        public let sidewalk: SidewalkDeviceMetadata?
        /// The ID of the wireless device.
        public let wirelessDeviceId: String?

        @inlinable
        public init(lastUplinkReceivedAt: String? = nil, loRaWAN: LoRaWANDeviceMetadata? = nil, sidewalk: SidewalkDeviceMetadata? = nil, wirelessDeviceId: String? = nil) {
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
            self.wirelessDeviceId = wirelessDeviceId
        }

        private enum CodingKeys: String, CodingKey {
            case lastUplinkReceivedAt = "LastUplinkReceivedAt"
            case loRaWAN = "LoRaWAN"
            case sidewalk = "Sidewalk"
            case wirelessDeviceId = "WirelessDeviceId"
        }
    }

    public struct GetWirelessGatewayCertificateRequest: AWSEncodableShape {
        /// The ID of the resource to get.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessGatewayCertificateResponse: AWSDecodableShape {
        /// The ID of the certificate associated with the wireless gateway.
        public let iotCertificateId: String?
        /// The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.
        public let loRaWANNetworkServerCertificateId: String?

        @inlinable
        public init(iotCertificateId: String? = nil, loRaWANNetworkServerCertificateId: String? = nil) {
            self.iotCertificateId = iotCertificateId
            self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
        }

        private enum CodingKeys: String, CodingKey {
            case iotCertificateId = "IotCertificateId"
            case loRaWANNetworkServerCertificateId = "LoRaWANNetworkServerCertificateId"
        }
    }

    public struct GetWirelessGatewayFirmwareInformationRequest: AWSEncodableShape {
        /// The ID of the resource to get.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessGatewayFirmwareInformationResponse: AWSDecodableShape {
        /// Information about the wireless gateway's firmware.
        public let loRaWAN: LoRaWANGatewayCurrentVersion?

        @inlinable
        public init(loRaWAN: LoRaWANGatewayCurrentVersion? = nil) {
            self.loRaWAN = loRaWAN
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct GetWirelessGatewayRequest: AWSEncodableShape {
        /// The identifier of the wireless gateway to get.
        public let identifier: String
        /// The type of identifier used in identifier.
        public let identifierType: WirelessGatewayIdType

        @inlinable
        public init(identifier: String, identifierType: WirelessGatewayIdType) {
            self.identifier = identifier
            self.identifierType = identifierType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.identifierType, key: "identifierType")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessGatewayResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The description of the resource.
        public let description: String?
        /// The ID of the wireless gateway.
        public let id: String?
        /// Information about the wireless gateway.
        public let loRaWAN: LoRaWANGateway?
        /// The name of the resource.
        public let name: String?
        /// The ARN of the thing associated with the wireless gateway.
        public let thingArn: String?
        /// The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.
        public let thingName: String?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, loRaWAN: LoRaWANGateway? = nil, name: String? = nil, thingArn: String? = nil, thingName: String? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.thingArn = thingArn
            self.thingName = thingName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case thingArn = "ThingArn"
            case thingName = "ThingName"
        }
    }

    public struct GetWirelessGatewayStatisticsRequest: AWSEncodableShape {
        /// The ID of the wireless gateway for which to get the data.
        public let wirelessGatewayId: String

        @inlinable
        public init(wirelessGatewayId: String) {
            self.wirelessGatewayId = wirelessGatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.wirelessGatewayId, key: "WirelessGatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.wirelessGatewayId, name: "wirelessGatewayId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessGatewayStatisticsResponse: AWSDecodableShape {
        /// The connection status of the wireless gateway.
        public let connectionStatus: ConnectionStatus?
        /// The date and time when the most recent uplink was received.  This value is only valid for 3 months.
        public let lastUplinkReceivedAt: String?
        /// The ID of the wireless gateway.
        public let wirelessGatewayId: String?

        @inlinable
        public init(connectionStatus: ConnectionStatus? = nil, lastUplinkReceivedAt: String? = nil, wirelessGatewayId: String? = nil) {
            self.connectionStatus = connectionStatus
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.wirelessGatewayId = wirelessGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case lastUplinkReceivedAt = "LastUplinkReceivedAt"
            case wirelessGatewayId = "WirelessGatewayId"
        }
    }

    public struct GetWirelessGatewayTaskDefinitionRequest: AWSEncodableShape {
        /// The ID of the resource to get.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessGatewayTaskDefinitionResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
        public let autoCreateTasks: Bool?
        /// The name of the resource.
        public let name: String?
        /// Information about the gateways to update.
        public let update: UpdateWirelessGatewayTaskCreate?

        @inlinable
        public init(arn: String? = nil, autoCreateTasks: Bool? = nil, name: String? = nil, update: UpdateWirelessGatewayTaskCreate? = nil) {
            self.arn = arn
            self.autoCreateTasks = autoCreateTasks
            self.name = name
            self.update = update
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case autoCreateTasks = "AutoCreateTasks"
            case name = "Name"
            case update = "Update"
        }
    }

    public struct GetWirelessGatewayTaskRequest: AWSEncodableShape {
        /// The ID of the resource to get.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWirelessGatewayTaskResponse: AWSDecodableShape {
        /// The date and time when the most recent uplink was received.  This value is only valid for 3 months.
        public let lastUplinkReceivedAt: String?
        /// The status of the request.
        public let status: WirelessGatewayTaskStatus?
        /// The date and time when the task was created.
        public let taskCreatedAt: String?
        /// The ID of the wireless gateway.
        public let wirelessGatewayId: String?
        /// The ID of the WirelessGatewayTask.
        public let wirelessGatewayTaskDefinitionId: String?

        @inlinable
        public init(lastUplinkReceivedAt: String? = nil, status: WirelessGatewayTaskStatus? = nil, taskCreatedAt: String? = nil, wirelessGatewayId: String? = nil, wirelessGatewayTaskDefinitionId: String? = nil) {
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.status = status
            self.taskCreatedAt = taskCreatedAt
            self.wirelessGatewayId = wirelessGatewayId
            self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
        }

        private enum CodingKeys: String, CodingKey {
            case lastUplinkReceivedAt = "LastUplinkReceivedAt"
            case status = "Status"
            case taskCreatedAt = "TaskCreatedAt"
            case wirelessGatewayId = "WirelessGatewayId"
            case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
        }
    }

    public struct GlobalIdentity: AWSEncodableShape {
        /// GERAN (GSM EDGE Radio Access Network) cell global identifier.
        public let geranCid: Int
        /// Location area code of the global identity.
        public let lac: Int

        @inlinable
        public init(geranCid: Int, lac: Int) {
            self.geranCid = geranCid
            self.lac = lac
        }

        public func validate(name: String) throws {
            try self.validate(self.geranCid, name: "geranCid", parent: name, max: 65535)
            try self.validate(self.geranCid, name: "geranCid", parent: name, min: 0)
            try self.validate(self.lac, name: "lac", parent: name, max: 65535)
            try self.validate(self.lac, name: "lac", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case geranCid = "GeranCid"
            case lac = "Lac"
        }
    }

    public struct Gnss: AWSEncodableShape {
        /// Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.
        public let assistAltitude: Float?
        /// Optional assistance position information, specified using latitude and longitude values in degrees. The coordinates are inside the WGS84 reference frame.
        public let assistPosition: [Float]?
        /// Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.
        public let captureTime: Float?
        /// Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.
        public let captureTimeAccuracy: Float?
        /// Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.
        public let payload: String
        /// Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.
        public let use2DSolver: Bool?

        @inlinable
        public init(assistAltitude: Float? = nil, assistPosition: [Float]? = nil, captureTime: Float? = nil, captureTimeAccuracy: Float? = nil, payload: String, use2DSolver: Bool? = nil) {
            self.assistAltitude = assistAltitude
            self.assistPosition = assistPosition
            self.captureTime = captureTime
            self.captureTimeAccuracy = captureTimeAccuracy
            self.payload = payload
            self.use2DSolver = use2DSolver
        }

        public func validate(name: String) throws {
            try self.validate(self.assistPosition, name: "assistPosition", parent: name, max: 2)
            try self.validate(self.assistPosition, name: "assistPosition", parent: name, min: 2)
            try self.validate(self.payload, name: "payload", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case assistAltitude = "AssistAltitude"
            case assistPosition = "AssistPosition"
            case captureTime = "CaptureTime"
            case captureTimeAccuracy = "CaptureTimeAccuracy"
            case payload = "Payload"
            case use2DSolver = "Use2DSolver"
        }
    }

    public struct GsmLocalId: AWSEncodableShape {
        /// GSM broadcast control channel.
        public let bcch: Int
        /// GSM base station identity code (BSIC).
        public let bsic: Int

        @inlinable
        public init(bcch: Int, bsic: Int) {
            self.bcch = bcch
            self.bsic = bsic
        }

        public func validate(name: String) throws {
            try self.validate(self.bcch, name: "bcch", parent: name, max: 1023)
            try self.validate(self.bcch, name: "bcch", parent: name, min: 0)
            try self.validate(self.bsic, name: "bsic", parent: name, max: 63)
            try self.validate(self.bsic, name: "bsic", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case bcch = "Bcch"
            case bsic = "Bsic"
        }
    }

    public struct GsmNmrObj: AWSEncodableShape {
        /// GSM broadcast control channel.
        public let bcch: Int
        /// GSM base station identity code (BSIC).
        public let bsic: Int
        /// Global identity information of the GSM object.
        public let globalIdentity: GlobalIdentity?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public let rxLevel: Int?

        @inlinable
        public init(bcch: Int, bsic: Int, globalIdentity: GlobalIdentity? = nil, rxLevel: Int? = nil) {
            self.bcch = bcch
            self.bsic = bsic
            self.globalIdentity = globalIdentity
            self.rxLevel = rxLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.bcch, name: "bcch", parent: name, max: 1023)
            try self.validate(self.bcch, name: "bcch", parent: name, min: 0)
            try self.validate(self.bsic, name: "bsic", parent: name, max: 63)
            try self.validate(self.bsic, name: "bsic", parent: name, min: 0)
            try self.globalIdentity?.validate(name: "\(name).globalIdentity")
            try self.validate(self.rxLevel, name: "rxLevel", parent: name, max: -25)
            try self.validate(self.rxLevel, name: "rxLevel", parent: name, min: -110)
        }

        private enum CodingKeys: String, CodingKey {
            case bcch = "Bcch"
            case bsic = "Bsic"
            case globalIdentity = "GlobalIdentity"
            case rxLevel = "RxLevel"
        }
    }

    public struct GsmObj: AWSEncodableShape {
        /// GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.
        public let geranCid: Int
        /// GSM local identification (local ID) information.
        public let gsmLocalId: GsmLocalId?
        /// GSM object for network measurement reports.
        public let gsmNmr: [GsmNmrObj]?
        /// Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.
        public let gsmTimingAdvance: Int?
        /// Location area code.
        public let lac: Int
        /// Mobile Country Code.
        public let mcc: Int
        /// Mobile Network Code.
        public let mnc: Int
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public let rxLevel: Int?

        @inlinable
        public init(geranCid: Int, gsmLocalId: GsmLocalId? = nil, gsmNmr: [GsmNmrObj]? = nil, gsmTimingAdvance: Int? = nil, lac: Int, mcc: Int, mnc: Int, rxLevel: Int? = nil) {
            self.geranCid = geranCid
            self.gsmLocalId = gsmLocalId
            self.gsmNmr = gsmNmr
            self.gsmTimingAdvance = gsmTimingAdvance
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.rxLevel = rxLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.geranCid, name: "geranCid", parent: name, max: 65535)
            try self.validate(self.geranCid, name: "geranCid", parent: name, min: 0)
            try self.gsmLocalId?.validate(name: "\(name).gsmLocalId")
            try self.gsmNmr?.forEach {
                try $0.validate(name: "\(name).gsmNmr[]")
            }
            try self.validate(self.gsmNmr, name: "gsmNmr", parent: name, max: 32)
            try self.validate(self.gsmNmr, name: "gsmNmr", parent: name, min: 1)
            try self.validate(self.gsmTimingAdvance, name: "gsmTimingAdvance", parent: name, max: 63)
            try self.validate(self.gsmTimingAdvance, name: "gsmTimingAdvance", parent: name, min: 0)
            try self.validate(self.lac, name: "lac", parent: name, max: 65535)
            try self.validate(self.lac, name: "lac", parent: name, min: 1)
            try self.validate(self.mcc, name: "mcc", parent: name, max: 999)
            try self.validate(self.mcc, name: "mcc", parent: name, min: 200)
            try self.validate(self.mnc, name: "mnc", parent: name, max: 999)
            try self.validate(self.mnc, name: "mnc", parent: name, min: 0)
            try self.validate(self.rxLevel, name: "rxLevel", parent: name, max: -25)
            try self.validate(self.rxLevel, name: "rxLevel", parent: name, min: -110)
        }

        private enum CodingKeys: String, CodingKey {
            case geranCid = "GeranCid"
            case gsmLocalId = "GsmLocalId"
            case gsmNmr = "GsmNmr"
            case gsmTimingAdvance = "GsmTimingAdvance"
            case lac = "Lac"
            case mcc = "Mcc"
            case mnc = "Mnc"
            case rxLevel = "RxLevel"
        }
    }

    public struct ImportedSidewalkDevice: AWSDecodableShape {
        /// The time at which the status information was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdateTime: Date?
        /// The onboarding status of the Sidewalk device in the import task.
        public let onboardingStatus: OnboardStatus?
        /// The reason for the onboarding status information for the Sidewalk device.
        public let onboardingStatusReason: String?
        /// The Sidewalk manufacturing serial number (SMSN) of the Sidewalk device.
        public let sidewalkManufacturingSn: String?

        @inlinable
        public init(lastUpdateTime: Date? = nil, onboardingStatus: OnboardStatus? = nil, onboardingStatusReason: String? = nil, sidewalkManufacturingSn: String? = nil) {
            self.lastUpdateTime = lastUpdateTime
            self.onboardingStatus = onboardingStatus
            self.onboardingStatusReason = onboardingStatusReason
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdateTime = "LastUpdateTime"
            case onboardingStatus = "OnboardingStatus"
            case onboardingStatusReason = "OnboardingStatusReason"
            case sidewalkManufacturingSn = "SidewalkManufacturingSn"
        }
    }

    public struct ImportedWirelessDevice: AWSDecodableShape {
        /// The Sidewalk-related information about a device that has been added to an import task.
        public let sidewalk: ImportedSidewalkDevice?

        @inlinable
        public init(sidewalk: ImportedSidewalkDevice? = nil) {
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
        }
    }

    public struct Ip: AWSEncodableShape {
        /// IP address information.
        public let ipAddress: String

        @inlinable
        public init(ipAddress: String) {
            self.ipAddress = ipAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
        }
    }

    public struct JoinEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Join event configuration object for enabling or disabling LoRaWAN related event topics.
        public let loRaWAN: LoRaWANJoinEventNotificationConfigurations?
        /// Denotes whether the wireless device ID join event topic is enabled or disabled.
        public let wirelessDeviceIdEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(loRaWAN: LoRaWANJoinEventNotificationConfigurations? = nil, wirelessDeviceIdEventTopic: EventNotificationTopicStatus? = nil) {
            self.loRaWAN = loRaWAN
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
            case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
        }
    }

    public struct JoinResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public let loRaWAN: LoRaWANJoinResourceTypeEventConfiguration?

        @inlinable
        public init(loRaWAN: LoRaWANJoinResourceTypeEventConfiguration? = nil) {
            self.loRaWAN = loRaWAN
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct ListDestinationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDestinationsResponse: AWSDecodableShape {
        /// The list of destinations.
        public let destinationList: [Destinations]?
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(destinationList: [Destinations]? = nil, nextToken: String? = nil) {
            self.destinationList = destinationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinationList = "DestinationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeviceProfilesRequest: AWSEncodableShape {
        /// A filter to list only device profiles that use this type, which can be LoRaWAN or Sidewalk.
        public let deviceProfileType: DeviceProfileType?
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(deviceProfileType: DeviceProfileType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deviceProfileType = deviceProfileType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceProfileType, key: "deviceProfileType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeviceProfilesResponse: AWSDecodableShape {
        /// The list of device profiles.
        public let deviceProfileList: [DeviceProfile]?
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(deviceProfileList: [DeviceProfile]? = nil, nextToken: String? = nil) {
            self.deviceProfileList = deviceProfileList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceProfileList = "DeviceProfileList"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicesForWirelessDeviceImportTaskRequest: AWSEncodableShape {
        /// The identifier of the import task for which wireless devices are listed.
        public let id: String
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?
        /// The status of the devices in the import task.
        public let status: OnboardStatus?

        @inlinable
        public init(id: String, maxResults: Int? = nil, nextToken: String? = nil, status: OnboardStatus? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.id, key: "id")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDevicesForWirelessDeviceImportTaskResponse: AWSDecodableShape {
        /// The name of the Sidewalk destination that describes the IoT rule to route messages received from devices in an import task that are onboarded to AWS IoT Wireless.
        public let destinationName: String?
        /// List of wireless devices in an import task and their onboarding status.
        public let importedWirelessDeviceList: [ImportedWirelessDevice]?
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(destinationName: String? = nil, importedWirelessDeviceList: [ImportedWirelessDevice]? = nil, nextToken: String? = nil) {
            self.destinationName = destinationName
            self.importedWirelessDeviceList = importedWirelessDeviceList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName = "DestinationName"
            case importedWirelessDeviceList = "ImportedWirelessDeviceList"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventConfigurationsRequest: AWSEncodableShape {
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?
        /// Resource type to filter event configurations.
        public let resourceType: EventNotificationResourceType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceType: EventNotificationResourceType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventConfigurationsResponse: AWSDecodableShape {
        /// Event configurations of all events for a single resource.
        public let eventConfigurationsList: [EventConfigurationItem]?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(eventConfigurationsList: [EventConfigurationItem]? = nil, nextToken: String? = nil) {
            self.eventConfigurationsList = eventConfigurationsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventConfigurationsList = "EventConfigurationsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListFuotaTasksRequest: AWSEncodableShape {
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFuotaTasksResponse: AWSDecodableShape {
        public let fuotaTaskList: [FuotaTask]?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(fuotaTaskList: [FuotaTask]? = nil, nextToken: String? = nil) {
            self.fuotaTaskList = fuotaTaskList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fuotaTaskList = "FuotaTaskList"
            case nextToken = "NextToken"
        }
    }

    public struct ListMulticastGroupsByFuotaTaskRequest: AWSEncodableShape {
        public let id: String
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(id: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMulticastGroupsByFuotaTaskResponse: AWSDecodableShape {
        public let multicastGroupList: [MulticastGroupByFuotaTask]?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(multicastGroupList: [MulticastGroupByFuotaTask]? = nil, nextToken: String? = nil) {
            self.multicastGroupList = multicastGroupList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case multicastGroupList = "MulticastGroupList"
            case nextToken = "NextToken"
        }
    }

    public struct ListMulticastGroupsRequest: AWSEncodableShape {
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMulticastGroupsResponse: AWSDecodableShape {
        public let multicastGroupList: [MulticastGroup]?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(multicastGroupList: [MulticastGroup]? = nil, nextToken: String? = nil) {
            self.multicastGroupList = multicastGroupList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case multicastGroupList = "MulticastGroupList"
            case nextToken = "NextToken"
        }
    }

    public struct ListNetworkAnalyzerConfigurationsRequest: AWSEncodableShape {
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNetworkAnalyzerConfigurationsResponse: AWSDecodableShape {
        /// The list of network analyzer configurations.
        public let networkAnalyzerConfigurationList: [NetworkAnalyzerConfigurations]?
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(networkAnalyzerConfigurationList: [NetworkAnalyzerConfigurations]? = nil, nextToken: String? = nil) {
            self.networkAnalyzerConfigurationList = networkAnalyzerConfigurationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkAnalyzerConfigurationList = "NetworkAnalyzerConfigurationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListPartnerAccountsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPartnerAccountsResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The Sidewalk account credentials.
        public let sidewalk: [SidewalkAccountInfoWithFingerprint]?

        @inlinable
        public init(nextToken: String? = nil, sidewalk: [SidewalkAccountInfoWithFingerprint]? = nil) {
            self.nextToken = nextToken
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sidewalk = "Sidewalk"
        }
    }

    public struct ListPositionConfigurationsRequest: AWSEncodableShape {
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?
        /// Resource type for which position configurations are listed.
        public let resourceType: PositionResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceType: PositionResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPositionConfigurationsResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of position configurations.
        public let positionConfigurationList: [PositionConfigurationItem]?

        @inlinable
        public init(nextToken: String? = nil, positionConfigurationList: [PositionConfigurationItem]? = nil) {
            self.nextToken = nextToken
            self.positionConfigurationList = positionConfigurationList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case positionConfigurationList = "PositionConfigurationList"
        }
    }

    public struct ListQueuedMessagesRequest: AWSEncodableShape {
        /// The ID of a given wireless device which the downlink message packets are being sent.
        public let id: String
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?
        /// The wireless device type, whic can be either Sidewalk or LoRaWAN.
        public let wirelessDeviceType: WirelessDeviceType?

        @inlinable
        public init(id: String, maxResults: Int? = nil, nextToken: String? = nil, wirelessDeviceType: WirelessDeviceType? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.wirelessDeviceType = wirelessDeviceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.wirelessDeviceType, key: "WirelessDeviceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueuedMessagesResponse: AWSDecodableShape {
        /// The messages in the downlink queue.
        public let downlinkQueueMessagesList: [DownlinkQueueMessage]?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(downlinkQueueMessagesList: [DownlinkQueueMessage]? = nil, nextToken: String? = nil) {
            self.downlinkQueueMessagesList = downlinkQueueMessagesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case downlinkQueueMessagesList = "DownlinkQueueMessagesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListServiceProfilesRequest: AWSEncodableShape {
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceProfilesResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The list of service profiles.
        public let serviceProfileList: [ServiceProfile]?

        @inlinable
        public init(nextToken: String? = nil, serviceProfileList: [ServiceProfile]? = nil) {
            self.nextToken = nextToken
            self.serviceProfileList = serviceProfileList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case serviceProfileList = "ServiceProfileList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource for which you want to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListWirelessDeviceImportTasksRequest: AWSEncodableShape {
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWirelessDeviceImportTasksResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// List of import tasks and summary information of onboarding status of devices in each import task.
        public let wirelessDeviceImportTaskList: [WirelessDeviceImportTask]?

        @inlinable
        public init(nextToken: String? = nil, wirelessDeviceImportTaskList: [WirelessDeviceImportTask]? = nil) {
            self.nextToken = nextToken
            self.wirelessDeviceImportTaskList = wirelessDeviceImportTaskList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case wirelessDeviceImportTaskList = "WirelessDeviceImportTaskList"
        }
    }

    public struct ListWirelessDevicesRequest: AWSEncodableShape {
        /// A filter to list only the wireless devices that use this destination.
        public let destinationName: String?
        /// A filter to list only the wireless devices that use this device profile.
        public let deviceProfileId: String?
        public let fuotaTaskId: String?
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        public let multicastGroupId: String?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?
        /// A filter to list only the wireless devices that use this service profile.
        public let serviceProfileId: String?
        /// A filter to list only the wireless devices that use this wireless device type.
        public let wirelessDeviceType: WirelessDeviceType?

        @inlinable
        public init(destinationName: String? = nil, deviceProfileId: String? = nil, fuotaTaskId: String? = nil, maxResults: Int? = nil, multicastGroupId: String? = nil, nextToken: String? = nil, serviceProfileId: String? = nil, wirelessDeviceType: WirelessDeviceType? = nil) {
            self.destinationName = destinationName
            self.deviceProfileId = deviceProfileId
            self.fuotaTaskId = fuotaTaskId
            self.maxResults = maxResults
            self.multicastGroupId = multicastGroupId
            self.nextToken = nextToken
            self.serviceProfileId = serviceProfileId
            self.wirelessDeviceType = wirelessDeviceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.destinationName, key: "destinationName")
            request.encodeQuery(self.deviceProfileId, key: "deviceProfileId")
            request.encodeQuery(self.fuotaTaskId, key: "fuotaTaskId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.multicastGroupId, key: "multicastGroupId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.serviceProfileId, key: "serviceProfileId")
            request.encodeQuery(self.wirelessDeviceType, key: "wirelessDeviceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.deviceProfileId, name: "deviceProfileId", parent: name, max: 256)
            try self.validate(self.fuotaTaskId, name: "fuotaTaskId", parent: name, max: 256)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.multicastGroupId, name: "multicastGroupId", parent: name, max: 256)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.serviceProfileId, name: "serviceProfileId", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWirelessDevicesResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The ID of the wireless device.
        public let wirelessDeviceList: [WirelessDeviceStatistics]?

        @inlinable
        public init(nextToken: String? = nil, wirelessDeviceList: [WirelessDeviceStatistics]? = nil) {
            self.nextToken = nextToken
            self.wirelessDeviceList = wirelessDeviceList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case wirelessDeviceList = "WirelessDeviceList"
        }
    }

    public struct ListWirelessGatewayTaskDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?
        /// A filter to list only the wireless gateway task definitions that use this task definition type.
        public let taskDefinitionType: WirelessGatewayTaskDefinitionType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, taskDefinitionType: WirelessGatewayTaskDefinitionType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.taskDefinitionType = taskDefinitionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.taskDefinitionType, key: "taskDefinitionType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWirelessGatewayTaskDefinitionsResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The list of task definitions.
        public let taskDefinitions: [UpdateWirelessGatewayTaskEntry]?

        @inlinable
        public init(nextToken: String? = nil, taskDefinitions: [UpdateWirelessGatewayTaskEntry]? = nil) {
            self.nextToken = nextToken
            self.taskDefinitions = taskDefinitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case taskDefinitions = "TaskDefinitions"
        }
    }

    public struct ListWirelessGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results to return in this operation.
        public let maxResults: Int?
        /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWirelessGatewaysResponse: AWSDecodableShape {
        /// The token to use to get the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The ID of the wireless gateway.
        public let wirelessGatewayList: [WirelessGatewayStatistics]?

        @inlinable
        public init(nextToken: String? = nil, wirelessGatewayList: [WirelessGatewayStatistics]? = nil) {
            self.nextToken = nextToken
            self.wirelessGatewayList = wirelessGatewayList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case wirelessGatewayList = "WirelessGatewayList"
        }
    }

    public struct LoRaWANConnectionStatusEventNotificationConfigurations: AWSEncodableShape & AWSDecodableShape {
        /// Denotes whether the gateway EUI connection status event topic is enabled or disabled.
        public let gatewayEuiEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(gatewayEuiEventTopic: EventNotificationTopicStatus? = nil) {
            self.gatewayEuiEventTopic = gatewayEuiEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayEuiEventTopic = "GatewayEuiEventTopic"
        }
    }

    public struct LoRaWANConnectionStatusResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Denotes whether the wireless gateway connection status event topic is enabled or disabled.
        public let wirelessGatewayEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(wirelessGatewayEventTopic: EventNotificationTopicStatus? = nil) {
            self.wirelessGatewayEventTopic = wirelessGatewayEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessGatewayEventTopic = "WirelessGatewayEventTopic"
        }
    }

    public struct LoRaWANDevice: AWSEncodableShape & AWSDecodableShape {
        /// LoRaWAN object for create APIs
        public let abpV10X: AbpV10X?
        /// ABP device object for create APIs for v1.1
        public let abpV11: AbpV11?
        /// The DevEUI value.
        public let devEui: String?
        /// The ID of the device profile for the new wireless device.
        public let deviceProfileId: String?
        public let fPorts: FPorts?
        /// OTAA device object for create APIs for v1.0.x
        public let otaaV10X: OtaaV10X?
        /// OTAA device object for v1.1 for create APIs
        public let otaaV11: OtaaV11?
        /// The ID of the service profile.
        public let serviceProfileId: String?

        @inlinable
        public init(abpV10X: AbpV10X? = nil, abpV11: AbpV11? = nil, devEui: String? = nil, deviceProfileId: String? = nil, fPorts: FPorts? = nil, otaaV10X: OtaaV10X? = nil, otaaV11: OtaaV11? = nil, serviceProfileId: String? = nil) {
            self.abpV10X = abpV10X
            self.abpV11 = abpV11
            self.devEui = devEui
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.otaaV10X = otaaV10X
            self.otaaV11 = otaaV11
            self.serviceProfileId = serviceProfileId
        }

        public func validate(name: String) throws {
            try self.abpV10X?.validate(name: "\(name).abpV10X")
            try self.abpV11?.validate(name: "\(name).abpV11")
            try self.validate(self.devEui, name: "devEui", parent: name, pattern: "^[a-fA-F0-9]{16}$")
            try self.validate(self.deviceProfileId, name: "deviceProfileId", parent: name, max: 256)
            try self.fPorts?.validate(name: "\(name).fPorts")
            try self.otaaV10X?.validate(name: "\(name).otaaV10X")
            try self.otaaV11?.validate(name: "\(name).otaaV11")
            try self.validate(self.serviceProfileId, name: "serviceProfileId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case abpV10X = "AbpV1_0_x"
            case abpV11 = "AbpV1_1"
            case devEui = "DevEui"
            case deviceProfileId = "DeviceProfileId"
            case fPorts = "FPorts"
            case otaaV10X = "OtaaV1_0_x"
            case otaaV11 = "OtaaV1_1"
            case serviceProfileId = "ServiceProfileId"
        }
    }

    public struct LoRaWANDeviceMetadata: AWSDecodableShape {
        /// The DataRate value.
        public let dataRate: Int?
        /// The DevEUI value.
        public let devEui: String?
        /// The FPort value.
        public let fPort: Int?
        /// The device's channel frequency in Hz.
        public let frequency: Int?
        /// Information about the gateways accessed by the device.
        public let gateways: [LoRaWANGatewayMetadata]?
        /// Information about the LoRaWAN public network accessed by the device.
        public let publicGateways: [LoRaWANPublicGatewayMetadata]?
        /// The date and time of the metadata.
        public let timestamp: String?

        @inlinable
        public init(dataRate: Int? = nil, devEui: String? = nil, fPort: Int? = nil, frequency: Int? = nil, gateways: [LoRaWANGatewayMetadata]? = nil, publicGateways: [LoRaWANPublicGatewayMetadata]? = nil, timestamp: String? = nil) {
            self.dataRate = dataRate
            self.devEui = devEui
            self.fPort = fPort
            self.frequency = frequency
            self.gateways = gateways
            self.publicGateways = publicGateways
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case dataRate = "DataRate"
            case devEui = "DevEui"
            case fPort = "FPort"
            case frequency = "Frequency"
            case gateways = "Gateways"
            case publicGateways = "PublicGateways"
            case timestamp = "Timestamp"
        }
    }

    public struct LoRaWANDeviceProfile: AWSEncodableShape & AWSDecodableShape {
        /// The ClassBTimeout value.
        public let classBTimeout: Int?
        /// The ClassCTimeout value.
        public let classCTimeout: Int?
        /// The list of values that make up the FactoryPresetFreqs value.
        public let factoryPresetFreqsList: [Int]?
        /// The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.
        public let macVersion: String?
        /// The MaxDutyCycle value. It ranges from 0 to 15.
        public let maxDutyCycle: Int?
        /// The MaxEIRP value.
        public let maxEirp: Int?
        /// The PingSlotDR value.
        public let pingSlotDr: Int?
        /// The PingSlotFreq value.
        public let pingSlotFreq: Int?
        /// The PingSlotPeriod value.
        public let pingSlotPeriod: Int?
        /// The version of regional parameters.
        public let regParamsRevision: String?
        /// The frequency band (RFRegion) value.
        public let rfRegion: String?
        /// The RXDataRate2 value.
        public let rxDataRate2: Int?
        /// The RXDelay1 value.
        public let rxDelay1: Int?
        /// The RXDROffset1 value.
        public let rxDrOffset1: Int?
        /// The RXFreq2 value.
        public let rxFreq2: Int?
        /// The Supports32BitFCnt value.
        public let supports32BitFCnt: Bool?
        /// The SupportsClassB value.
        public let supportsClassB: Bool?
        /// The SupportsClassC value.
        public let supportsClassC: Bool?
        /// The SupportsJoin value.
        public let supportsJoin: Bool?

        @inlinable
        public init(classBTimeout: Int? = nil, classCTimeout: Int? = nil, factoryPresetFreqsList: [Int]? = nil, macVersion: String? = nil, maxDutyCycle: Int? = nil, maxEirp: Int? = nil, pingSlotDr: Int? = nil, pingSlotFreq: Int? = nil, pingSlotPeriod: Int? = nil, regParamsRevision: String? = nil, rfRegion: String? = nil, rxDataRate2: Int? = nil, rxDelay1: Int? = nil, rxDrOffset1: Int? = nil, rxFreq2: Int? = nil, supports32BitFCnt: Bool? = nil, supportsClassB: Bool? = nil, supportsClassC: Bool? = nil, supportsJoin: Bool? = nil) {
            self.classBTimeout = classBTimeout
            self.classCTimeout = classCTimeout
            self.factoryPresetFreqsList = factoryPresetFreqsList
            self.macVersion = macVersion
            self.maxDutyCycle = maxDutyCycle
            self.maxEirp = maxEirp
            self.pingSlotDr = pingSlotDr
            self.pingSlotFreq = pingSlotFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.regParamsRevision = regParamsRevision
            self.rfRegion = rfRegion
            self.rxDataRate2 = rxDataRate2
            self.rxDelay1 = rxDelay1
            self.rxDrOffset1 = rxDrOffset1
            self.rxFreq2 = rxFreq2
            self.supports32BitFCnt = supports32BitFCnt
            self.supportsClassB = supportsClassB
            self.supportsClassC = supportsClassC
            self.supportsJoin = supportsJoin
        }

        public func validate(name: String) throws {
            try self.validate(self.classBTimeout, name: "classBTimeout", parent: name, max: 1000)
            try self.validate(self.classBTimeout, name: "classBTimeout", parent: name, min: 0)
            try self.validate(self.classCTimeout, name: "classCTimeout", parent: name, max: 1000)
            try self.validate(self.classCTimeout, name: "classCTimeout", parent: name, min: 0)
            try self.factoryPresetFreqsList?.forEach {
                try validate($0, name: "factoryPresetFreqsList[]", parent: name, max: 16700000)
                try validate($0, name: "factoryPresetFreqsList[]", parent: name, min: 1000000)
            }
            try self.validate(self.factoryPresetFreqsList, name: "factoryPresetFreqsList", parent: name, max: 20)
            try self.validate(self.macVersion, name: "macVersion", parent: name, max: 64)
            try self.validate(self.maxDutyCycle, name: "maxDutyCycle", parent: name, max: 100)
            try self.validate(self.maxDutyCycle, name: "maxDutyCycle", parent: name, min: 0)
            try self.validate(self.maxEirp, name: "maxEirp", parent: name, max: 15)
            try self.validate(self.maxEirp, name: "maxEirp", parent: name, min: 0)
            try self.validate(self.pingSlotDr, name: "pingSlotDr", parent: name, max: 15)
            try self.validate(self.pingSlotDr, name: "pingSlotDr", parent: name, min: 0)
            try self.validate(self.pingSlotFreq, name: "pingSlotFreq", parent: name, max: 16700000)
            try self.validate(self.pingSlotFreq, name: "pingSlotFreq", parent: name, min: 1000000)
            try self.validate(self.pingSlotPeriod, name: "pingSlotPeriod", parent: name, max: 4096)
            try self.validate(self.pingSlotPeriod, name: "pingSlotPeriod", parent: name, min: 32)
            try self.validate(self.regParamsRevision, name: "regParamsRevision", parent: name, max: 64)
            try self.validate(self.rfRegion, name: "rfRegion", parent: name, max: 64)
            try self.validate(self.rxDataRate2, name: "rxDataRate2", parent: name, max: 15)
            try self.validate(self.rxDataRate2, name: "rxDataRate2", parent: name, min: 0)
            try self.validate(self.rxDelay1, name: "rxDelay1", parent: name, max: 15)
            try self.validate(self.rxDelay1, name: "rxDelay1", parent: name, min: 0)
            try self.validate(self.rxDrOffset1, name: "rxDrOffset1", parent: name, max: 7)
            try self.validate(self.rxDrOffset1, name: "rxDrOffset1", parent: name, min: 0)
            try self.validate(self.rxFreq2, name: "rxFreq2", parent: name, max: 16700000)
            try self.validate(self.rxFreq2, name: "rxFreq2", parent: name, min: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case classBTimeout = "ClassBTimeout"
            case classCTimeout = "ClassCTimeout"
            case factoryPresetFreqsList = "FactoryPresetFreqsList"
            case macVersion = "MacVersion"
            case maxDutyCycle = "MaxDutyCycle"
            case maxEirp = "MaxEirp"
            case pingSlotDr = "PingSlotDr"
            case pingSlotFreq = "PingSlotFreq"
            case pingSlotPeriod = "PingSlotPeriod"
            case regParamsRevision = "RegParamsRevision"
            case rfRegion = "RfRegion"
            case rxDataRate2 = "RxDataRate2"
            case rxDelay1 = "RxDelay1"
            case rxDrOffset1 = "RxDrOffset1"
            case rxFreq2 = "RxFreq2"
            case supports32BitFCnt = "Supports32BitFCnt"
            case supportsClassB = "SupportsClassB"
            case supportsClassC = "SupportsClassC"
            case supportsJoin = "SupportsJoin"
        }
    }

    public struct LoRaWANFuotaTask: AWSEncodableShape {
        public let rfRegion: SupportedRfRegion?

        @inlinable
        public init(rfRegion: SupportedRfRegion? = nil) {
            self.rfRegion = rfRegion
        }

        private enum CodingKeys: String, CodingKey {
            case rfRegion = "RfRegion"
        }
    }

    public struct LoRaWANFuotaTaskGetInfo: AWSDecodableShape {
        public let rfRegion: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        @inlinable
        public init(rfRegion: String? = nil, startTime: Date? = nil) {
            self.rfRegion = rfRegion
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case rfRegion = "RfRegion"
            case startTime = "StartTime"
        }
    }

    public struct LoRaWANGateway: AWSEncodableShape & AWSDecodableShape {
        /// Beaconing object information, which consists of the data rate and frequency parameters.
        public let beaconing: Beaconing?
        /// The gateway's EUI value.
        public let gatewayEui: String?
        public let joinEuiFilters: [[String]]?
        /// The MaxEIRP value.
        public let maxEirp: Float?
        public let netIdFilters: [String]?
        /// The frequency band (RFRegion) value.
        public let rfRegion: String?
        public let subBands: [Int]?

        @inlinable
        public init(beaconing: Beaconing? = nil, gatewayEui: String? = nil, joinEuiFilters: [[String]]? = nil, maxEirp: Float? = nil, netIdFilters: [String]? = nil, rfRegion: String? = nil, subBands: [Int]? = nil) {
            self.beaconing = beaconing
            self.gatewayEui = gatewayEui
            self.joinEuiFilters = joinEuiFilters
            self.maxEirp = maxEirp
            self.netIdFilters = netIdFilters
            self.rfRegion = rfRegion
            self.subBands = subBands
        }

        public func validate(name: String) throws {
            try self.beaconing?.validate(name: "\(name).beaconing")
            try self.validate(self.gatewayEui, name: "gatewayEui", parent: name, pattern: "^(([0-9A-Fa-f]{2}-){7}|([0-9A-Fa-f]{2}:){7}|([0-9A-Fa-f]{2}\\s){7}|([0-9A-Fa-f]{2}){7})([0-9A-Fa-f]{2})$")
            try self.joinEuiFilters?.forEach {
                try validate($0, name: "joinEuiFilters[]", parent: name, max: 2)
                try validate($0, name: "joinEuiFilters[]", parent: name, min: 2)
            }
            try self.validate(self.joinEuiFilters, name: "joinEuiFilters", parent: name, max: 3)
            try self.validate(self.maxEirp, name: "maxEirp", parent: name, max: 30.0)
            try self.validate(self.maxEirp, name: "maxEirp", parent: name, min: 0.0)
            try self.netIdFilters?.forEach {
                try validate($0, name: "netIdFilters[]", parent: name, pattern: "^[a-fA-F0-9]{6}$")
            }
            try self.validate(self.netIdFilters, name: "netIdFilters", parent: name, max: 10)
            try self.validate(self.rfRegion, name: "rfRegion", parent: name, max: 64)
            try self.subBands?.forEach {
                try validate($0, name: "subBands[]", parent: name, max: 8)
                try validate($0, name: "subBands[]", parent: name, min: 1)
            }
            try self.validate(self.subBands, name: "subBands", parent: name, max: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case beaconing = "Beaconing"
            case gatewayEui = "GatewayEui"
            case joinEuiFilters = "JoinEuiFilters"
            case maxEirp = "MaxEirp"
            case netIdFilters = "NetIdFilters"
            case rfRegion = "RfRegion"
            case subBands = "SubBands"
        }
    }

    public struct LoRaWANGatewayCurrentVersion: AWSDecodableShape {
        /// The version of the gateways that should receive the update.
        public let currentVersion: LoRaWANGatewayVersion?

        @inlinable
        public init(currentVersion: LoRaWANGatewayVersion? = nil) {
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "CurrentVersion"
        }
    }

    public struct LoRaWANGatewayMetadata: AWSDecodableShape {
        /// The gateway's EUI value.
        public let gatewayEui: String?
        /// The RSSI value.
        public let rssi: Double?
        /// The SNR value.
        public let snr: Double?

        @inlinable
        public init(gatewayEui: String? = nil, rssi: Double? = nil, snr: Double? = nil) {
            self.gatewayEui = gatewayEui
            self.rssi = rssi
            self.snr = snr
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayEui = "GatewayEui"
            case rssi = "Rssi"
            case snr = "Snr"
        }
    }

    public struct LoRaWANGatewayVersion: AWSEncodableShape & AWSDecodableShape {
        /// The model number of the wireless gateway.
        public let model: String?
        /// The version of the wireless gateway firmware.
        public let packageVersion: String?
        /// The basic station version of the wireless gateway.
        public let station: String?

        @inlinable
        public init(model: String? = nil, packageVersion: String? = nil, station: String? = nil) {
            self.model = model
            self.packageVersion = packageVersion
            self.station = station
        }

        public func validate(name: String) throws {
            try self.validate(self.model, name: "model", parent: name, max: 4096)
            try self.validate(self.model, name: "model", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 32)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.station, name: "station", parent: name, max: 4096)
            try self.validate(self.station, name: "station", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case model = "Model"
            case packageVersion = "PackageVersion"
            case station = "Station"
        }
    }

    public struct LoRaWANGetServiceProfileInfo: AWSDecodableShape {
        /// The AddGWMetaData value.
        public let addGwMetadata: Bool?
        /// The ChannelMask value.
        public let channelMask: String?
        /// The DevStatusReqFreq value.
        public let devStatusReqFreq: Int?
        /// The DLBucketSize value.
        public let dlBucketSize: Int?
        /// The DLRate value.
        public let dlRate: Int?
        /// The DLRatePolicy value.
        public let dlRatePolicy: String?
        /// The DRMax value.
        public let drMax: Int?
        /// The DRMin value.
        public let drMin: Int?
        /// The HRAllowed value that describes whether handover roaming is allowed.
        public let hrAllowed: Bool?
        /// The MinGwDiversity value.
        public let minGwDiversity: Int?
        /// The NwkGeoLoc value.
        public let nwkGeoLoc: Bool?
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public let prAllowed: Bool?
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public let raAllowed: Bool?
        /// The ReportDevStatusBattery value.
        public let reportDevStatusBattery: Bool?
        /// The ReportDevStatusMargin value.
        public let reportDevStatusMargin: Bool?
        /// The TargetPER value.
        public let targetPer: Int?
        /// The ULBucketSize value.
        public let ulBucketSize: Int?
        /// The ULRate value.
        public let ulRate: Int?
        /// The ULRatePolicy value.
        public let ulRatePolicy: String?

        @inlinable
        public init(addGwMetadata: Bool? = nil, channelMask: String? = nil, devStatusReqFreq: Int? = nil, dlBucketSize: Int? = nil, dlRate: Int? = nil, dlRatePolicy: String? = nil, drMax: Int? = nil, drMin: Int? = nil, hrAllowed: Bool? = nil, minGwDiversity: Int? = nil, nwkGeoLoc: Bool? = nil, prAllowed: Bool? = nil, raAllowed: Bool? = nil, reportDevStatusBattery: Bool? = nil, reportDevStatusMargin: Bool? = nil, targetPer: Int? = nil, ulBucketSize: Int? = nil, ulRate: Int? = nil, ulRatePolicy: String? = nil) {
            self.addGwMetadata = addGwMetadata
            self.channelMask = channelMask
            self.devStatusReqFreq = devStatusReqFreq
            self.dlBucketSize = dlBucketSize
            self.dlRate = dlRate
            self.dlRatePolicy = dlRatePolicy
            self.drMax = drMax
            self.drMin = drMin
            self.hrAllowed = hrAllowed
            self.minGwDiversity = minGwDiversity
            self.nwkGeoLoc = nwkGeoLoc
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
            self.reportDevStatusBattery = reportDevStatusBattery
            self.reportDevStatusMargin = reportDevStatusMargin
            self.targetPer = targetPer
            self.ulBucketSize = ulBucketSize
            self.ulRate = ulRate
            self.ulRatePolicy = ulRatePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case addGwMetadata = "AddGwMetadata"
            case channelMask = "ChannelMask"
            case devStatusReqFreq = "DevStatusReqFreq"
            case dlBucketSize = "DlBucketSize"
            case dlRate = "DlRate"
            case dlRatePolicy = "DlRatePolicy"
            case drMax = "DrMax"
            case drMin = "DrMin"
            case hrAllowed = "HrAllowed"
            case minGwDiversity = "MinGwDiversity"
            case nwkGeoLoc = "NwkGeoLoc"
            case prAllowed = "PrAllowed"
            case raAllowed = "RaAllowed"
            case reportDevStatusBattery = "ReportDevStatusBattery"
            case reportDevStatusMargin = "ReportDevStatusMargin"
            case targetPer = "TargetPer"
            case ulBucketSize = "UlBucketSize"
            case ulRate = "UlRate"
            case ulRatePolicy = "UlRatePolicy"
        }
    }

    public struct LoRaWANJoinEventNotificationConfigurations: AWSEncodableShape & AWSDecodableShape {
        /// Denotes whether the Dev EUI join event topic is enabled or disabled.
        public let devEuiEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(devEuiEventTopic: EventNotificationTopicStatus? = nil) {
            self.devEuiEventTopic = devEuiEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case devEuiEventTopic = "DevEuiEventTopic"
        }
    }

    public struct LoRaWANJoinResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public let wirelessDeviceEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(wirelessDeviceEventTopic: EventNotificationTopicStatus? = nil) {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessDeviceEventTopic = "WirelessDeviceEventTopic"
        }
    }

    public struct LoRaWANListDevice: AWSDecodableShape {
        /// The DevEUI value.
        public let devEui: String?

        @inlinable
        public init(devEui: String? = nil) {
            self.devEui = devEui
        }

        private enum CodingKeys: String, CodingKey {
            case devEui = "DevEui"
        }
    }

    public struct LoRaWANMulticast: AWSEncodableShape {
        public let dlClass: DlClass?
        public let participatingGateways: ParticipatingGatewaysMulticast?
        public let rfRegion: SupportedRfRegion?

        @inlinable
        public init(dlClass: DlClass? = nil, participatingGateways: ParticipatingGatewaysMulticast? = nil, rfRegion: SupportedRfRegion? = nil) {
            self.dlClass = dlClass
            self.participatingGateways = participatingGateways
            self.rfRegion = rfRegion
        }

        public func validate(name: String) throws {
            try self.participatingGateways?.validate(name: "\(name).participatingGateways")
        }

        private enum CodingKeys: String, CodingKey {
            case dlClass = "DlClass"
            case participatingGateways = "ParticipatingGateways"
            case rfRegion = "RfRegion"
        }
    }

    public struct LoRaWANMulticastGet: AWSDecodableShape {
        public let dlClass: DlClass?
        public let numberOfDevicesInGroup: Int?
        public let numberOfDevicesRequested: Int?
        public let participatingGateways: ParticipatingGatewaysMulticast?
        public let rfRegion: SupportedRfRegion?

        @inlinable
        public init(dlClass: DlClass? = nil, numberOfDevicesInGroup: Int? = nil, numberOfDevicesRequested: Int? = nil, participatingGateways: ParticipatingGatewaysMulticast? = nil, rfRegion: SupportedRfRegion? = nil) {
            self.dlClass = dlClass
            self.numberOfDevicesInGroup = numberOfDevicesInGroup
            self.numberOfDevicesRequested = numberOfDevicesRequested
            self.participatingGateways = participatingGateways
            self.rfRegion = rfRegion
        }

        private enum CodingKeys: String, CodingKey {
            case dlClass = "DlClass"
            case numberOfDevicesInGroup = "NumberOfDevicesInGroup"
            case numberOfDevicesRequested = "NumberOfDevicesRequested"
            case participatingGateways = "ParticipatingGateways"
            case rfRegion = "RfRegion"
        }
    }

    public struct LoRaWANMulticastMetadata: AWSEncodableShape {
        public let fPort: Int?

        @inlinable
        public init(fPort: Int? = nil) {
            self.fPort = fPort
        }

        public func validate(name: String) throws {
            try self.validate(self.fPort, name: "fPort", parent: name, max: 223)
            try self.validate(self.fPort, name: "fPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fPort = "FPort"
        }
    }

    public struct LoRaWANMulticastSession: AWSEncodableShape & AWSDecodableShape {
        public let dlDr: Int?
        public let dlFreq: Int?
        /// The PingSlotPeriod value.
        public let pingSlotPeriod: Int?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var sessionStartTime: Date?
        public let sessionTimeout: Int?

        @inlinable
        public init(dlDr: Int? = nil, dlFreq: Int? = nil, pingSlotPeriod: Int? = nil, sessionStartTime: Date? = nil, sessionTimeout: Int? = nil) {
            self.dlDr = dlDr
            self.dlFreq = dlFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.sessionStartTime = sessionStartTime
            self.sessionTimeout = sessionTimeout
        }

        public func validate(name: String) throws {
            try self.validate(self.dlDr, name: "dlDr", parent: name, max: 15)
            try self.validate(self.dlDr, name: "dlDr", parent: name, min: 0)
            try self.validate(self.dlFreq, name: "dlFreq", parent: name, max: 1000000000)
            try self.validate(self.dlFreq, name: "dlFreq", parent: name, min: 100000000)
            try self.validate(self.pingSlotPeriod, name: "pingSlotPeriod", parent: name, max: 4096)
            try self.validate(self.pingSlotPeriod, name: "pingSlotPeriod", parent: name, min: 32)
            try self.validate(self.sessionTimeout, name: "sessionTimeout", parent: name, max: 172800)
            try self.validate(self.sessionTimeout, name: "sessionTimeout", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case dlDr = "DlDr"
            case dlFreq = "DlFreq"
            case pingSlotPeriod = "PingSlotPeriod"
            case sessionStartTime = "SessionStartTime"
            case sessionTimeout = "SessionTimeout"
        }
    }

    public struct LoRaWANPublicGatewayMetadata: AWSDecodableShape {
        /// Boolean that indicates whether downlink is allowed using the network.
        public let dlAllowed: Bool?
        /// The ID of the gateways that are operated by the network provider.
        public let id: String?
        /// The ID of the LoRaWAN public network provider.
        public let providerNetId: String?
        public let rfRegion: String?
        /// The RSSI (received signal strength indicator) value.
        public let rssi: Double?
        /// The SNR (signal to noise ratio) value.
        public let snr: Double?

        @inlinable
        public init(dlAllowed: Bool? = nil, id: String? = nil, providerNetId: String? = nil, rfRegion: String? = nil, rssi: Double? = nil, snr: Double? = nil) {
            self.dlAllowed = dlAllowed
            self.id = id
            self.providerNetId = providerNetId
            self.rfRegion = rfRegion
            self.rssi = rssi
            self.snr = snr
        }

        private enum CodingKeys: String, CodingKey {
            case dlAllowed = "DlAllowed"
            case id = "Id"
            case providerNetId = "ProviderNetId"
            case rfRegion = "RfRegion"
            case rssi = "Rssi"
            case snr = "Snr"
        }
    }

    public struct LoRaWANSendDataToDevice: AWSEncodableShape & AWSDecodableShape {
        public let fPort: Int?
        /// Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.
        public let participatingGateways: ParticipatingGateways?

        @inlinable
        public init(fPort: Int? = nil, participatingGateways: ParticipatingGateways? = nil) {
            self.fPort = fPort
            self.participatingGateways = participatingGateways
        }

        public func validate(name: String) throws {
            try self.validate(self.fPort, name: "fPort", parent: name, max: 223)
            try self.validate(self.fPort, name: "fPort", parent: name, min: 1)
            try self.participatingGateways?.validate(name: "\(name).participatingGateways")
        }

        private enum CodingKeys: String, CodingKey {
            case fPort = "FPort"
            case participatingGateways = "ParticipatingGateways"
        }
    }

    public struct LoRaWANServiceProfile: AWSEncodableShape {
        /// The AddGWMetaData value.
        public let addGwMetadata: Bool?
        /// The DrMax value.
        public let drMax: Int?
        /// The DrMin value.
        public let drMin: Int?
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public let prAllowed: Bool?
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public let raAllowed: Bool?

        @inlinable
        public init(addGwMetadata: Bool? = nil, drMax: Int? = nil, drMin: Int? = nil, prAllowed: Bool? = nil, raAllowed: Bool? = nil) {
            self.addGwMetadata = addGwMetadata
            self.drMax = drMax
            self.drMin = drMin
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
        }

        public func validate(name: String) throws {
            try self.validate(self.drMax, name: "drMax", parent: name, max: 15)
            try self.validate(self.drMax, name: "drMax", parent: name, min: 0)
            try self.validate(self.drMin, name: "drMin", parent: name, max: 15)
            try self.validate(self.drMin, name: "drMin", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case addGwMetadata = "AddGwMetadata"
            case drMax = "DrMax"
            case drMin = "DrMin"
            case prAllowed = "PrAllowed"
            case raAllowed = "RaAllowed"
        }
    }

    public struct LoRaWANStartFuotaTask: AWSEncodableShape {
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        @inlinable
        public init(startTime: Date? = nil) {
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
        }
    }

    public struct LoRaWANUpdateDevice: AWSEncodableShape {
        /// ABP device object for update APIs for v1.0.x
        public let abpV10X: UpdateAbpV10X?
        /// ABP device object for update APIs for v1.1
        public let abpV11: UpdateAbpV11?
        /// The ID of the device profile for the wireless device.
        public let deviceProfileId: String?
        /// FPorts object for the positioning information of the device.
        public let fPorts: UpdateFPorts?
        /// The ID of the service profile.
        public let serviceProfileId: String?

        @inlinable
        public init(abpV10X: UpdateAbpV10X? = nil, abpV11: UpdateAbpV11? = nil, deviceProfileId: String? = nil, fPorts: UpdateFPorts? = nil, serviceProfileId: String? = nil) {
            self.abpV10X = abpV10X
            self.abpV11 = abpV11
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.serviceProfileId = serviceProfileId
        }

        public func validate(name: String) throws {
            try self.abpV10X?.validate(name: "\(name).abpV10X")
            try self.abpV11?.validate(name: "\(name).abpV11")
            try self.validate(self.deviceProfileId, name: "deviceProfileId", parent: name, max: 256)
            try self.fPorts?.validate(name: "\(name).fPorts")
            try self.validate(self.serviceProfileId, name: "serviceProfileId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case abpV10X = "AbpV1_0_x"
            case abpV11 = "AbpV1_1"
            case deviceProfileId = "DeviceProfileId"
            case fPorts = "FPorts"
            case serviceProfileId = "ServiceProfileId"
        }
    }

    public struct LoRaWANUpdateGatewayTaskCreate: AWSEncodableShape & AWSDecodableShape {
        /// The version of the gateways that should receive the update.
        public let currentVersion: LoRaWANGatewayVersion?
        /// The CRC of the signature private key to check.
        public let sigKeyCrc: Int64?
        /// The signature used to verify the update firmware.
        public let updateSignature: String?
        /// The firmware version to update the gateway to.
        public let updateVersion: LoRaWANGatewayVersion?

        @inlinable
        public init(currentVersion: LoRaWANGatewayVersion? = nil, sigKeyCrc: Int64? = nil, updateSignature: String? = nil, updateVersion: LoRaWANGatewayVersion? = nil) {
            self.currentVersion = currentVersion
            self.sigKeyCrc = sigKeyCrc
            self.updateSignature = updateSignature
            self.updateVersion = updateVersion
        }

        public func validate(name: String) throws {
            try self.currentVersion?.validate(name: "\(name).currentVersion")
            try self.validate(self.sigKeyCrc, name: "sigKeyCrc", parent: name, max: 4294967295)
            try self.validate(self.sigKeyCrc, name: "sigKeyCrc", parent: name, min: 1)
            try self.validate(self.updateSignature, name: "updateSignature", parent: name, max: 4096)
            try self.validate(self.updateSignature, name: "updateSignature", parent: name, min: 1)
            try self.updateVersion?.validate(name: "\(name).updateVersion")
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "CurrentVersion"
            case sigKeyCrc = "SigKeyCrc"
            case updateSignature = "UpdateSignature"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct LoRaWANUpdateGatewayTaskEntry: AWSDecodableShape {
        /// The version of the gateways that should receive the update.
        public let currentVersion: LoRaWANGatewayVersion?
        /// The firmware version to update the gateway to.
        public let updateVersion: LoRaWANGatewayVersion?

        @inlinable
        public init(currentVersion: LoRaWANGatewayVersion? = nil, updateVersion: LoRaWANGatewayVersion? = nil) {
            self.currentVersion = currentVersion
            self.updateVersion = updateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "CurrentVersion"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct LteLocalId: AWSEncodableShape {
        /// Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).
        public let earfcn: Int
        /// Physical cell ID.
        public let pci: Int

        @inlinable
        public init(earfcn: Int, pci: Int) {
            self.earfcn = earfcn
            self.pci = pci
        }

        public func validate(name: String) throws {
            try self.validate(self.earfcn, name: "earfcn", parent: name, max: 262143)
            try self.validate(self.earfcn, name: "earfcn", parent: name, min: 0)
            try self.validate(self.pci, name: "pci", parent: name, max: 503)
            try self.validate(self.pci, name: "pci", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case earfcn = "Earfcn"
            case pci = "Pci"
        }
    }

    public struct LteNmrObj: AWSEncodableShape {
        /// E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).
        public let earfcn: Int
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).
        public let eutranCid: Int?
        /// Physical cell ID.
        public let pci: Int
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public let rsrp: Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public let rsrq: Float?

        @inlinable
        public init(earfcn: Int, eutranCid: Int? = nil, pci: Int, rsrp: Int? = nil, rsrq: Float? = nil) {
            self.earfcn = earfcn
            self.eutranCid = eutranCid
            self.pci = pci
            self.rsrp = rsrp
            self.rsrq = rsrq
        }

        public func validate(name: String) throws {
            try self.validate(self.earfcn, name: "earfcn", parent: name, max: 262143)
            try self.validate(self.earfcn, name: "earfcn", parent: name, min: 0)
            try self.validate(self.eutranCid, name: "eutranCid", parent: name, max: 268435455)
            try self.validate(self.eutranCid, name: "eutranCid", parent: name, min: 0)
            try self.validate(self.pci, name: "pci", parent: name, max: 503)
            try self.validate(self.pci, name: "pci", parent: name, min: 0)
            try self.validate(self.rsrp, name: "rsrp", parent: name, max: -44)
            try self.validate(self.rsrp, name: "rsrp", parent: name, min: -140)
            try self.validate(self.rsrq, name: "rsrq", parent: name, max: -3.0)
            try self.validate(self.rsrq, name: "rsrq", parent: name, min: -19.5)
        }

        private enum CodingKeys: String, CodingKey {
            case earfcn = "Earfcn"
            case eutranCid = "EutranCid"
            case pci = "Pci"
            case rsrp = "Rsrp"
            case rsrq = "Rsrq"
        }
    }

    public struct LteObj: AWSEncodableShape {
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.
        public let eutranCid: Int
        /// LTE local identification (local ID) information.
        public let lteLocalId: LteLocalId?
        /// LTE object for network measurement reports.
        public let lteNmr: [LteNmrObj]?
        /// LTE timing advance.
        public let lteTimingAdvance: Int?
        /// Mobile Country Code.
        public let mcc: Int
        /// Mobile Network Code.
        public let mnc: Int
        /// Parameter that determines whether the LTE object is capable of supporting NR (new radio).
        public let nrCapable: Bool?
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public let rsrp: Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public let rsrq: Float?
        /// LTE tracking area code.
        public let tac: Int?

        @inlinable
        public init(eutranCid: Int, lteLocalId: LteLocalId? = nil, lteNmr: [LteNmrObj]? = nil, lteTimingAdvance: Int? = nil, mcc: Int, mnc: Int, nrCapable: Bool? = nil, rsrp: Int? = nil, rsrq: Float? = nil, tac: Int? = nil) {
            self.eutranCid = eutranCid
            self.lteLocalId = lteLocalId
            self.lteNmr = lteNmr
            self.lteTimingAdvance = lteTimingAdvance
            self.mcc = mcc
            self.mnc = mnc
            self.nrCapable = nrCapable
            self.rsrp = rsrp
            self.rsrq = rsrq
            self.tac = tac
        }

        public func validate(name: String) throws {
            try self.validate(self.eutranCid, name: "eutranCid", parent: name, max: 268435455)
            try self.validate(self.eutranCid, name: "eutranCid", parent: name, min: 0)
            try self.lteLocalId?.validate(name: "\(name).lteLocalId")
            try self.lteNmr?.forEach {
                try $0.validate(name: "\(name).lteNmr[]")
            }
            try self.validate(self.lteNmr, name: "lteNmr", parent: name, max: 32)
            try self.validate(self.lteNmr, name: "lteNmr", parent: name, min: 1)
            try self.validate(self.lteTimingAdvance, name: "lteTimingAdvance", parent: name, max: 1282)
            try self.validate(self.lteTimingAdvance, name: "lteTimingAdvance", parent: name, min: 0)
            try self.validate(self.mcc, name: "mcc", parent: name, max: 999)
            try self.validate(self.mcc, name: "mcc", parent: name, min: 200)
            try self.validate(self.mnc, name: "mnc", parent: name, max: 999)
            try self.validate(self.mnc, name: "mnc", parent: name, min: 0)
            try self.validate(self.rsrp, name: "rsrp", parent: name, max: -44)
            try self.validate(self.rsrp, name: "rsrp", parent: name, min: -140)
            try self.validate(self.rsrq, name: "rsrq", parent: name, max: -3.0)
            try self.validate(self.rsrq, name: "rsrq", parent: name, min: -19.5)
            try self.validate(self.tac, name: "tac", parent: name, max: 65535)
            try self.validate(self.tac, name: "tac", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case eutranCid = "EutranCid"
            case lteLocalId = "LteLocalId"
            case lteNmr = "LteNmr"
            case lteTimingAdvance = "LteTimingAdvance"
            case mcc = "Mcc"
            case mnc = "Mnc"
            case nrCapable = "NrCapable"
            case rsrp = "Rsrp"
            case rsrq = "Rsrq"
            case tac = "Tac"
        }
    }

    public struct MessageDeliveryStatusEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let sidewalk: SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.
        public let wirelessDeviceIdEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(sidewalk: SidewalkEventNotificationConfigurations? = nil, wirelessDeviceIdEventTopic: EventNotificationTopicStatus? = nil) {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
            case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
        }
    }

    public struct MessageDeliveryStatusResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let sidewalk: SidewalkResourceTypeEventConfiguration?

        @inlinable
        public init(sidewalk: SidewalkResourceTypeEventConfiguration? = nil) {
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
        }
    }

    public struct MetricQueryValue: AWSDecodableShape {
        /// The average of the values of all data points collected during the aggregation period.
        public let avg: Double?
        /// The maximum of the values of all the data points collected during the aggregation period.
        public let max: Double?
        /// The minimum of the values of all data points collected during the aggregation period.
        public let min: Double?
        /// The 90th percentile of the values of all data points collected during the aggregation period.
        public let p90: Double?
        /// The standard deviation of the values of all data points collected during the aggregation period.
        public let std: Double?
        /// The sum of the values of all data points collected during the aggregation period.
        public let sum: Double?

        @inlinable
        public init(avg: Double? = nil, max: Double? = nil, min: Double? = nil, p90: Double? = nil, std: Double? = nil, sum: Double? = nil) {
            self.avg = avg
            self.max = max
            self.min = min
            self.p90 = p90
            self.std = std
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case avg = "Avg"
            case max = "Max"
            case min = "Min"
            case p90 = "P90"
            case std = "Std"
            case sum = "Sum"
        }
    }

    public struct MulticastGroup: AWSDecodableShape {
        public let arn: String?
        public let id: String?
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct MulticastGroupByFuotaTask: AWSDecodableShape {
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct MulticastWirelessMetadata: AWSEncodableShape {
        public let loRaWAN: LoRaWANMulticastMetadata?

        @inlinable
        public init(loRaWAN: LoRaWANMulticastMetadata? = nil) {
            self.loRaWAN = loRaWAN
        }

        public func validate(name: String) throws {
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct NetworkAnalyzerConfigurations: AWSDecodableShape {
        /// The Amazon Resource Name of the new resource.
        public let arn: String?
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct OtaaV10X: AWSEncodableShape & AWSDecodableShape {
        /// The AppEUI value. You specify this value when using LoRaWAN versions v1.0.2 or v1.0.3.
        public let appEui: String?
        /// The AppKey value.
        public let appKey: String?
        /// The GenAppKey value.
        public let genAppKey: String?
        /// The JoinEUI value. You specify this value instead of the AppEUI when using LoRaWAN version v1.0.4.
        public let joinEui: String?

        @inlinable
        public init(appEui: String? = nil, appKey: String? = nil, genAppKey: String? = nil, joinEui: String? = nil) {
            self.appEui = appEui
            self.appKey = appKey
            self.genAppKey = genAppKey
            self.joinEui = joinEui
        }

        public func validate(name: String) throws {
            try self.validate(self.appEui, name: "appEui", parent: name, pattern: "^[a-fA-F0-9]{16}$")
            try self.validate(self.appKey, name: "appKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.genAppKey, name: "genAppKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.joinEui, name: "joinEui", parent: name, pattern: "^[a-fA-F0-9]{16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appEui = "AppEui"
            case appKey = "AppKey"
            case genAppKey = "GenAppKey"
            case joinEui = "JoinEui"
        }
    }

    public struct OtaaV11: AWSEncodableShape & AWSDecodableShape {
        /// The AppKey value.
        public let appKey: String?
        /// The JoinEUI value.
        public let joinEui: String?
        /// The NwkKey value.
        public let nwkKey: String?

        @inlinable
        public init(appKey: String? = nil, joinEui: String? = nil, nwkKey: String? = nil) {
            self.appKey = appKey
            self.joinEui = joinEui
            self.nwkKey = nwkKey
        }

        public func validate(name: String) throws {
            try self.validate(self.appKey, name: "appKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.joinEui, name: "joinEui", parent: name, pattern: "^[a-fA-F0-9]{16}$")
            try self.validate(self.nwkKey, name: "nwkKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appKey = "AppKey"
            case joinEui = "JoinEui"
            case nwkKey = "NwkKey"
        }
    }

    public struct ParticipatingGateways: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.
        public let downlinkMode: DownlinkMode
        /// The list of gateways that you want to use for sending the downlink data traffic.
        public let gatewayList: [GatewayListItem]
        /// The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.
        public let transmissionInterval: Int

        @inlinable
        public init(downlinkMode: DownlinkMode, gatewayList: [GatewayListItem], transmissionInterval: Int) {
            self.downlinkMode = downlinkMode
            self.gatewayList = gatewayList
            self.transmissionInterval = transmissionInterval
        }

        public func validate(name: String) throws {
            try self.gatewayList.forEach {
                try $0.validate(name: "\(name).gatewayList[]")
            }
            try self.validate(self.transmissionInterval, name: "transmissionInterval", parent: name, max: 604800)
            try self.validate(self.transmissionInterval, name: "transmissionInterval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case downlinkMode = "DownlinkMode"
            case gatewayList = "GatewayList"
            case transmissionInterval = "TransmissionInterval"
        }
    }

    public struct ParticipatingGatewaysMulticast: AWSEncodableShape & AWSDecodableShape {
        /// The list of gateways that you want to use for sending the multicast downlink message. Each downlink message will be sent to all the gateways in the list in the order that you provided. If the gateway list is empty, then AWS IoT Core for LoRaWAN chooses the gateways that were most recently used by the devices to send an uplink message.
        public let gatewayList: [String]?
        /// The duration of time in milliseconds for which AWS IoT Core for LoRaWAN will wait before transmitting the multicast payload to the next gateway in the list.
        public let transmissionInterval: Int?

        @inlinable
        public init(gatewayList: [String]? = nil, transmissionInterval: Int? = nil) {
            self.gatewayList = gatewayList
            self.transmissionInterval = transmissionInterval
        }

        public func validate(name: String) throws {
            try self.gatewayList?.forEach {
                try validate($0, name: "gatewayList[]", parent: name, max: 256)
            }
            try self.validate(self.gatewayList, name: "gatewayList", parent: name, max: 20)
            try self.validate(self.transmissionInterval, name: "transmissionInterval", parent: name, max: 60000)
            try self.validate(self.transmissionInterval, name: "transmissionInterval", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayList = "GatewayList"
            case transmissionInterval = "TransmissionInterval"
        }
    }

    public struct PositionConfigurationItem: AWSDecodableShape {
        /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public let destination: String?
        /// Resource identifier for the position configuration.
        public let resourceIdentifier: String?
        /// Resource type of the resource for the position configuration.
        public let resourceType: PositionResourceType?
        /// The details of the positioning solver object used to compute the location.
        public let solvers: PositionSolverDetails?

        @inlinable
        public init(destination: String? = nil, resourceIdentifier: String? = nil, resourceType: PositionResourceType? = nil, solvers: PositionSolverDetails? = nil) {
            self.destination = destination
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
            self.solvers = solvers
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case resourceIdentifier = "ResourceIdentifier"
            case resourceType = "ResourceType"
            case solvers = "Solvers"
        }
    }

    public struct PositionSolverConfigurations: AWSEncodableShape {
        /// The Semtech GNSS solver configuration object.
        public let semtechGnss: SemtechGnssConfiguration?

        @inlinable
        public init(semtechGnss: SemtechGnssConfiguration? = nil) {
            self.semtechGnss = semtechGnss
        }

        private enum CodingKeys: String, CodingKey {
            case semtechGnss = "SemtechGnss"
        }
    }

    public struct PositionSolverDetails: AWSDecodableShape {
        /// The Semtech GNSS solver object details.
        public let semtechGnss: SemtechGnssDetail?

        @inlinable
        public init(semtechGnss: SemtechGnssDetail? = nil) {
            self.semtechGnss = semtechGnss
        }

        private enum CodingKeys: String, CodingKey {
            case semtechGnss = "SemtechGnss"
        }
    }

    public struct Positioning: AWSEncodableShape & AWSDecodableShape {
        public let clockSync: Int?
        public let gnss: Int?
        public let stream: Int?

        @inlinable
        public init(clockSync: Int? = nil, gnss: Int? = nil, stream: Int? = nil) {
            self.clockSync = clockSync
            self.gnss = gnss
            self.stream = stream
        }

        public func validate(name: String) throws {
            try self.validate(self.clockSync, name: "clockSync", parent: name, max: 223)
            try self.validate(self.clockSync, name: "clockSync", parent: name, min: 1)
            try self.validate(self.gnss, name: "gnss", parent: name, max: 223)
            try self.validate(self.gnss, name: "gnss", parent: name, min: 1)
            try self.validate(self.stream, name: "stream", parent: name, max: 223)
            try self.validate(self.stream, name: "stream", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clockSync = "ClockSync"
            case gnss = "Gnss"
            case stream = "Stream"
        }
    }

    public struct ProximityEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Proximity event configuration object for enabling or disabling Sidewalk related event topics.
        public let sidewalk: SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID proximity event topic is enabled or disabled.
        public let wirelessDeviceIdEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(sidewalk: SidewalkEventNotificationConfigurations? = nil, wirelessDeviceIdEventTopic: EventNotificationTopicStatus? = nil) {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
            case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
        }
    }

    public struct ProximityResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Proximity resource type event configuration object for enabling and disabling wireless device topic.
        public let sidewalk: SidewalkResourceTypeEventConfiguration?

        @inlinable
        public init(sidewalk: SidewalkResourceTypeEventConfiguration? = nil) {
            self.sidewalk = sidewalk
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
        }
    }

    public struct PutPositionConfigurationRequest: AWSEncodableShape {
        /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public let destination: String?
        /// Resource identifier used to update the position configuration.
        public let resourceIdentifier: String
        /// Resource type of the resource for which you want to update the position configuration.
        public let resourceType: PositionResourceType
        /// The positioning solvers used to update the position configuration of the resource.
        public let solvers: PositionSolverConfigurations?

        @inlinable
        public init(destination: String? = nil, resourceIdentifier: String, resourceType: PositionResourceType, solvers: PositionSolverConfigurations? = nil) {
            self.destination = destination
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
            self.solvers = solvers
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.destination, forKey: .destination)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
            try container.encodeIfPresent(self.solvers, forKey: .solvers)
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 128)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case solvers = "Solvers"
        }
    }

    public struct PutPositionConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutResourceLogLevelRequest: AWSEncodableShape {
        public let logLevel: LogLevel
        public let resourceIdentifier: String
        /// The type of resource, which can be WirelessDevice, WirelessGateway, or FuotaTask.
        public let resourceType: String

        @inlinable
        public init(logLevel: LogLevel, resourceIdentifier: String, resourceType: String) {
            self.logLevel = logLevel
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.logLevel, forKey: .logLevel)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
        }
    }

    public struct PutResourceLogLevelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResetAllResourceLogLevelsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct ResetAllResourceLogLevelsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResetResourceLogLevelRequest: AWSEncodableShape {
        public let resourceIdentifier: String
        /// The type of resource, which can be WirelessDevice, WirelessGateway, or FuotaTask.
        public let resourceType: String

        @inlinable
        public init(resourceIdentifier: String, resourceType: String) {
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ResetResourceLogLevelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// Id of the not found resource.
        public let resourceId: String?
        /// Type of the font found resource.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct SemtechGnssConfiguration: AWSEncodableShape {
        /// Whether forward error correction is enabled.
        public let fec: PositionConfigurationFec
        /// The status indicating whether the solver is enabled.
        public let status: PositionConfigurationStatus

        @inlinable
        public init(fec: PositionConfigurationFec, status: PositionConfigurationStatus) {
            self.fec = fec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case fec = "Fec"
            case status = "Status"
        }
    }

    public struct SemtechGnssDetail: AWSDecodableShape {
        /// Whether forward error correction is enabled.
        public let fec: PositionConfigurationFec?
        /// The vendor of the solver object.
        public let provider: PositionSolverProvider?
        /// The status indicating whether the solver is enabled.
        public let status: PositionConfigurationStatus?
        /// The type of positioning solver used.
        public let type: PositionSolverType?

        @inlinable
        public init(fec: PositionConfigurationFec? = nil, provider: PositionSolverProvider? = nil, status: PositionConfigurationStatus? = nil, type: PositionSolverType? = nil) {
            self.fec = fec
            self.provider = provider
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case fec = "Fec"
            case provider = "Provider"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct SendDataToMulticastGroupRequest: AWSEncodableShape {
        public let id: String
        public let payloadData: String
        public let wirelessMetadata: MulticastWirelessMetadata

        @inlinable
        public init(id: String, payloadData: String, wirelessMetadata: MulticastWirelessMetadata) {
            self.id = id
            self.payloadData = payloadData
            self.wirelessMetadata = wirelessMetadata
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.payloadData, forKey: .payloadData)
            try container.encode(self.wirelessMetadata, forKey: .wirelessMetadata)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.payloadData, name: "payloadData", parent: name, max: 2048)
            try self.validate(self.payloadData, name: "payloadData", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
            try self.wirelessMetadata.validate(name: "\(name).wirelessMetadata")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadData = "PayloadData"
            case wirelessMetadata = "WirelessMetadata"
        }
    }

    public struct SendDataToMulticastGroupResponse: AWSDecodableShape {
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendDataToWirelessDeviceRequest: AWSEncodableShape {
        /// The ID of the wireless device to receive the data.
        public let id: String
        public let payloadData: String
        /// The transmit mode to use to send data to the wireless device. Can be: 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
        public let transmitMode: Int
        /// Metadata about the message request.
        public let wirelessMetadata: WirelessMetadata?

        @inlinable
        public init(id: String, payloadData: String, transmitMode: Int, wirelessMetadata: WirelessMetadata? = nil) {
            self.id = id
            self.payloadData = payloadData
            self.transmitMode = transmitMode
            self.wirelessMetadata = wirelessMetadata
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.payloadData, forKey: .payloadData)
            try container.encode(self.transmitMode, forKey: .transmitMode)
            try container.encodeIfPresent(self.wirelessMetadata, forKey: .wirelessMetadata)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.payloadData, name: "payloadData", parent: name, max: 2048)
            try self.validate(self.payloadData, name: "payloadData", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
            try self.validate(self.transmitMode, name: "transmitMode", parent: name, max: 1)
            try self.validate(self.transmitMode, name: "transmitMode", parent: name, min: 0)
            try self.wirelessMetadata?.validate(name: "\(name).wirelessMetadata")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadData = "PayloadData"
            case transmitMode = "TransmitMode"
            case wirelessMetadata = "WirelessMetadata"
        }
    }

    public struct SendDataToWirelessDeviceResponse: AWSDecodableShape {
        /// The ID of the message sent to the wireless device.
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct ServiceProfile: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The ID of the service profile.
        public let id: String?
        /// The name of the resource.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct SessionKeysAbpV10X: AWSEncodableShape & AWSDecodableShape {
        /// The AppSKey value.
        public let appSKey: String?
        /// The NwkSKey value.
        public let nwkSKey: String?

        @inlinable
        public init(appSKey: String? = nil, nwkSKey: String? = nil) {
            self.appSKey = appSKey
            self.nwkSKey = nwkSKey
        }

        public func validate(name: String) throws {
            try self.validate(self.appSKey, name: "appSKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.nwkSKey, name: "nwkSKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appSKey = "AppSKey"
            case nwkSKey = "NwkSKey"
        }
    }

    public struct SessionKeysAbpV11: AWSEncodableShape & AWSDecodableShape {
        /// The AppSKey value.
        public let appSKey: String?
        /// The FNwkSIntKey value.
        public let fNwkSIntKey: String?
        /// The NwkSEncKey value.
        public let nwkSEncKey: String?
        /// The SNwkSIntKey value.
        public let sNwkSIntKey: String?

        @inlinable
        public init(appSKey: String? = nil, fNwkSIntKey: String? = nil, nwkSEncKey: String? = nil, sNwkSIntKey: String? = nil) {
            self.appSKey = appSKey
            self.fNwkSIntKey = fNwkSIntKey
            self.nwkSEncKey = nwkSEncKey
            self.sNwkSIntKey = sNwkSIntKey
        }

        public func validate(name: String) throws {
            try self.validate(self.appSKey, name: "appSKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.fNwkSIntKey, name: "fNwkSIntKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.nwkSEncKey, name: "nwkSEncKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
            try self.validate(self.sNwkSIntKey, name: "sNwkSIntKey", parent: name, pattern: "^[a-fA-F0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appSKey = "AppSKey"
            case fNwkSIntKey = "FNwkSIntKey"
            case nwkSEncKey = "NwkSEncKey"
            case sNwkSIntKey = "SNwkSIntKey"
        }
    }

    public struct SidewalkAccountInfo: AWSEncodableShape & AWSDecodableShape {
        /// The Sidewalk Amazon ID.
        public let amazonId: String?
        /// The Sidewalk application server private key.
        public let appServerPrivateKey: String?

        @inlinable
        public init(amazonId: String? = nil, appServerPrivateKey: String? = nil) {
            self.amazonId = amazonId
            self.appServerPrivateKey = appServerPrivateKey
        }

        public func validate(name: String) throws {
            try self.validate(self.amazonId, name: "amazonId", parent: name, max: 2048)
            try self.validate(self.appServerPrivateKey, name: "appServerPrivateKey", parent: name, max: 4096)
            try self.validate(self.appServerPrivateKey, name: "appServerPrivateKey", parent: name, min: 1)
            try self.validate(self.appServerPrivateKey, name: "appServerPrivateKey", parent: name, pattern: "^[a-fA-F0-9]{64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonId = "AmazonId"
            case appServerPrivateKey = "AppServerPrivateKey"
        }
    }

    public struct SidewalkAccountInfoWithFingerprint: AWSDecodableShape {
        /// The Sidewalk Amazon ID.
        public let amazonId: String?
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The fingerprint of the Sidewalk application server private key.
        public let fingerprint: String?

        @inlinable
        public init(amazonId: String? = nil, arn: String? = nil, fingerprint: String? = nil) {
            self.amazonId = amazonId
            self.arn = arn
            self.fingerprint = fingerprint
        }

        private enum CodingKeys: String, CodingKey {
            case amazonId = "AmazonId"
            case arn = "Arn"
            case fingerprint = "Fingerprint"
        }
    }

    public struct SidewalkCreateDeviceProfile: AWSEncodableShape {
        public init() {}
    }

    public struct SidewalkCreateWirelessDevice: AWSEncodableShape {
        /// The ID of the Sidewalk device profile.
        public let deviceProfileId: String?

        @inlinable
        public init(deviceProfileId: String? = nil) {
            self.deviceProfileId = deviceProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceProfileId, name: "deviceProfileId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceProfileId = "DeviceProfileId"
        }
    }

    public struct SidewalkDevice: AWSDecodableShape {
        public let amazonId: String?
        /// The ID of the Sidewalk device profile.
        public let certificateId: String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public let deviceCertificates: [CertificateList]?
        /// The ID of the Sidewalk device profile.
        public let deviceProfileId: String?
        /// The Sidewalk device private keys that will be used for onboarding the device.
        public let privateKeys: [CertificateList]?
        /// The sidewalk device identification.
        public let sidewalkId: String?
        /// The Sidewalk manufacturing series number.
        public let sidewalkManufacturingSn: String?
        /// The Sidewalk device status, such as provisioned or registered.
        public let status: WirelessDeviceSidewalkStatus?

        @inlinable
        public init(amazonId: String? = nil, certificateId: String? = nil, deviceCertificates: [CertificateList]? = nil, deviceProfileId: String? = nil, privateKeys: [CertificateList]? = nil, sidewalkId: String? = nil, sidewalkManufacturingSn: String? = nil, status: WirelessDeviceSidewalkStatus? = nil) {
            self.amazonId = amazonId
            self.certificateId = certificateId
            self.deviceCertificates = deviceCertificates
            self.deviceProfileId = deviceProfileId
            self.privateKeys = privateKeys
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case amazonId = "AmazonId"
            case certificateId = "CertificateId"
            case deviceCertificates = "DeviceCertificates"
            case deviceProfileId = "DeviceProfileId"
            case privateKeys = "PrivateKeys"
            case sidewalkId = "SidewalkId"
            case sidewalkManufacturingSn = "SidewalkManufacturingSn"
            case status = "Status"
        }
    }

    public struct SidewalkDeviceMetadata: AWSDecodableShape {
        /// Sidewalk device battery level.
        public let batteryLevel: BatteryLevel?
        /// Device state defines the device status of sidewalk device.
        public let deviceState: DeviceState?
        /// Sidewalk device status notification.
        public let event: Event?
        /// The RSSI value.
        public let rssi: Int?

        @inlinable
        public init(batteryLevel: BatteryLevel? = nil, deviceState: DeviceState? = nil, event: Event? = nil, rssi: Int? = nil) {
            self.batteryLevel = batteryLevel
            self.deviceState = deviceState
            self.event = event
            self.rssi = rssi
        }

        private enum CodingKeys: String, CodingKey {
            case batteryLevel = "BatteryLevel"
            case deviceState = "DeviceState"
            case event = "Event"
            case rssi = "Rssi"
        }
    }

    public struct SidewalkEventNotificationConfigurations: AWSEncodableShape & AWSDecodableShape {
        /// Denotes whether the Amazon ID event topic is enabled or disabled.
        public let amazonIdEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(amazonIdEventTopic: EventNotificationTopicStatus? = nil) {
            self.amazonIdEventTopic = amazonIdEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case amazonIdEventTopic = "AmazonIdEventTopic"
        }
    }

    public struct SidewalkGetDeviceProfile: AWSDecodableShape {
        /// The Sidewalk application server public key.
        public let applicationServerPublicKey: String?
        /// The DAK certificate information of the Sidewalk device profile.
        public let dakCertificateMetadata: [DakCertificateMetadata]?
        /// Gets information about the certification status of a Sidewalk device profile.
        public let qualificationStatus: Bool?

        @inlinable
        public init(applicationServerPublicKey: String? = nil, dakCertificateMetadata: [DakCertificateMetadata]? = nil, qualificationStatus: Bool? = nil) {
            self.applicationServerPublicKey = applicationServerPublicKey
            self.dakCertificateMetadata = dakCertificateMetadata
            self.qualificationStatus = qualificationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case applicationServerPublicKey = "ApplicationServerPublicKey"
            case dakCertificateMetadata = "DakCertificateMetadata"
            case qualificationStatus = "QualificationStatus"
        }
    }

    public struct SidewalkGetStartImportInfo: AWSDecodableShape {
        /// List of Sidewalk devices that are added to the import task.
        public let deviceCreationFileList: [String]?
        /// The IAM role that allows AWS IoT Wireless to access the CSV file in the S3 bucket.
        public let role: String?

        @inlinable
        public init(deviceCreationFileList: [String]? = nil, role: String? = nil) {
            self.deviceCreationFileList = deviceCreationFileList
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case deviceCreationFileList = "DeviceCreationFileList"
            case role = "Role"
        }
    }

    public struct SidewalkListDevice: AWSDecodableShape {
        /// The Sidewalk Amazon ID.
        public let amazonId: String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public let deviceCertificates: [CertificateList]?
        /// Sidewalk object used by list functions.
        public let deviceProfileId: String?
        /// The sidewalk device identification.
        public let sidewalkId: String?
        /// The Sidewalk manufacturing series number.
        public let sidewalkManufacturingSn: String?
        /// The status of the Sidewalk devices, such as provisioned or registered.
        public let status: WirelessDeviceSidewalkStatus?

        @inlinable
        public init(amazonId: String? = nil, deviceCertificates: [CertificateList]? = nil, deviceProfileId: String? = nil, sidewalkId: String? = nil, sidewalkManufacturingSn: String? = nil, status: WirelessDeviceSidewalkStatus? = nil) {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.deviceProfileId = deviceProfileId
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case amazonId = "AmazonId"
            case deviceCertificates = "DeviceCertificates"
            case deviceProfileId = "DeviceProfileId"
            case sidewalkId = "SidewalkId"
            case sidewalkManufacturingSn = "SidewalkManufacturingSn"
            case status = "Status"
        }
    }

    public struct SidewalkResourceTypeEventConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public let wirelessDeviceEventTopic: EventNotificationTopicStatus?

        @inlinable
        public init(wirelessDeviceEventTopic: EventNotificationTopicStatus? = nil) {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessDeviceEventTopic = "WirelessDeviceEventTopic"
        }
    }

    public struct SidewalkSendDataToDevice: AWSEncodableShape {
        /// The duration of time in seconds to retry sending the ACK.
        public let ackModeRetryDurationSecs: Int?
        public let messageType: MessageType?
        /// The sequence number.
        public let seq: Int?

        @inlinable
        public init(ackModeRetryDurationSecs: Int? = nil, messageType: MessageType? = nil, seq: Int? = nil) {
            self.ackModeRetryDurationSecs = ackModeRetryDurationSecs
            self.messageType = messageType
            self.seq = seq
        }

        public func validate(name: String) throws {
            try self.validate(self.ackModeRetryDurationSecs, name: "ackModeRetryDurationSecs", parent: name, max: 604800)
            try self.validate(self.ackModeRetryDurationSecs, name: "ackModeRetryDurationSecs", parent: name, min: 0)
            try self.validate(self.seq, name: "seq", parent: name, max: 16383)
            try self.validate(self.seq, name: "seq", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case ackModeRetryDurationSecs = "AckModeRetryDurationSecs"
            case messageType = "MessageType"
            case seq = "Seq"
        }
    }

    public struct SidewalkSingleStartImportInfo: AWSEncodableShape {
        /// The Sidewalk manufacturing serial number (SMSN) of the device added to the import task.
        public let sidewalkManufacturingSn: String?

        @inlinable
        public init(sidewalkManufacturingSn: String? = nil) {
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }

        public func validate(name: String) throws {
            try self.validate(self.sidewalkManufacturingSn, name: "sidewalkManufacturingSn", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalkManufacturingSn = "SidewalkManufacturingSn"
        }
    }

    public struct SidewalkStartImportInfo: AWSEncodableShape {
        /// The CSV file contained in an S3 bucket that's used for adding devices to an import task.
        public let deviceCreationFile: String?
        /// The IAM role that allows AWS IoT Wireless to access the CSV file in the S3 bucket.
        public let role: String?

        @inlinable
        public init(deviceCreationFile: String? = nil, role: String? = nil) {
            self.deviceCreationFile = deviceCreationFile
            self.role = role
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceCreationFile, name: "deviceCreationFile", parent: name, max: 1024)
            try self.validate(self.role, name: "role", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceCreationFile = "DeviceCreationFile"
            case role = "Role"
        }
    }

    public struct SidewalkUpdateAccount: AWSEncodableShape {
        /// The new Sidewalk application server private key.
        public let appServerPrivateKey: String?

        @inlinable
        public init(appServerPrivateKey: String? = nil) {
            self.appServerPrivateKey = appServerPrivateKey
        }

        public func validate(name: String) throws {
            try self.validate(self.appServerPrivateKey, name: "appServerPrivateKey", parent: name, max: 4096)
            try self.validate(self.appServerPrivateKey, name: "appServerPrivateKey", parent: name, min: 1)
            try self.validate(self.appServerPrivateKey, name: "appServerPrivateKey", parent: name, pattern: "^[a-fA-F0-9]{64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appServerPrivateKey = "AppServerPrivateKey"
        }
    }

    public struct SidewalkUpdateImportInfo: AWSEncodableShape {
        /// The CSV file contained in an S3 bucket that's used for appending devices to an existing import task.
        public let deviceCreationFile: String?

        @inlinable
        public init(deviceCreationFile: String? = nil) {
            self.deviceCreationFile = deviceCreationFile
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceCreationFile, name: "deviceCreationFile", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceCreationFile = "DeviceCreationFile"
        }
    }

    public struct StartBulkAssociateWirelessDeviceWithMulticastGroupRequest: AWSEncodableShape {
        public let id: String
        public let queryString: String?
        public let tags: [Tag]?

        @inlinable
        public init(id: String, queryString: String? = nil, tags: [Tag]? = nil) {
            self.id = id
            self.queryString = queryString
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.queryString, forKey: .queryString)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.queryString, name: "queryString", parent: name, max: 4096)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case queryString = "QueryString"
            case tags = "Tags"
        }
    }

    public struct StartBulkAssociateWirelessDeviceWithMulticastGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupRequest: AWSEncodableShape {
        public let id: String
        public let queryString: String?
        public let tags: [Tag]?

        @inlinable
        public init(id: String, queryString: String? = nil, tags: [Tag]? = nil) {
            self.id = id
            self.queryString = queryString
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.queryString, forKey: .queryString)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.queryString, name: "queryString", parent: name, max: 4096)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case queryString = "QueryString"
            case tags = "Tags"
        }
    }

    public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartFuotaTaskRequest: AWSEncodableShape {
        public let id: String
        public let loRaWAN: LoRaWANStartFuotaTask?

        @inlinable
        public init(id: String, loRaWAN: LoRaWANStartFuotaTask? = nil) {
            self.id = id
            self.loRaWAN = loRaWAN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.loRaWAN, forKey: .loRaWAN)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct StartFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartMulticastGroupSessionRequest: AWSEncodableShape {
        public let id: String
        public let loRaWAN: LoRaWANMulticastSession

        @inlinable
        public init(id: String, loRaWAN: LoRaWANMulticastSession) {
            self.id = id
            self.loRaWAN = loRaWAN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.loRaWAN, forKey: .loRaWAN)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.loRaWAN.validate(name: "\(name).loRaWAN")
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct StartMulticastGroupSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartSingleWirelessDeviceImportTaskRequest: AWSEncodableShape {
        public let clientRequestToken: String?
        /// The name of the Sidewalk destination that describes the IoT rule to route messages from the device in the import task that will be onboarded to AWS IoT Wireless.
        public let destinationName: String
        /// The name of the wireless device for which an import task is being started.
        public let deviceName: String?
        /// The Sidewalk-related parameters for importing a single wireless device.
        public let sidewalk: SidewalkSingleStartImportInfo
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = StartSingleWirelessDeviceImportTaskRequest.idempotencyToken(), destinationName: String, deviceName: String? = nil, sidewalk: SidewalkSingleStartImportInfo, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.destinationName = destinationName
            self.deviceName = deviceName
            self.sidewalk = sidewalk
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.sidewalk.validate(name: "\(name).sidewalk")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case destinationName = "DestinationName"
            case deviceName = "DeviceName"
            case sidewalk = "Sidewalk"
            case tags = "Tags"
        }
    }

    public struct StartSingleWirelessDeviceImportTaskResponse: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the import task.
        public let arn: String?
        /// The import task ID.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct StartWirelessDeviceImportTaskRequest: AWSEncodableShape {
        public let clientRequestToken: String?
        /// The name of the Sidewalk destination that describes the IoT rule to route messages from the devices in the import task that are onboarded to AWS IoT Wireless.
        public let destinationName: String
        /// The Sidewalk-related parameters for importing wireless devices that need to be provisioned in bulk.
        public let sidewalk: SidewalkStartImportInfo
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = StartWirelessDeviceImportTaskRequest.idempotencyToken(), destinationName: String, sidewalk: SidewalkStartImportInfo, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.destinationName = destinationName
            self.sidewalk = sidewalk
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.sidewalk.validate(name: "\(name).sidewalk")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case destinationName = "DestinationName"
            case sidewalk = "Sidewalk"
            case tags = "Tags"
        }
    }

    public struct StartWirelessDeviceImportTaskResponse: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the import task.
        public let arn: String?
        /// The import task ID.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct SummaryMetricConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The status of the configuration of summary metrics.
        public let status: SummaryMetricConfigurationStatus?

        @inlinable
        public init(status: SummaryMetricConfigurationStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct SummaryMetricQuery: AWSEncodableShape {
        /// The aggregation period of the summary metric.
        public let aggregationPeriod: AggregationPeriod?
        /// The dimensions of the summary metric.
        public let dimensions: [Dimension]?
        /// The end timestamp for the summary metric query.
        public let endTimestamp: Date?
        /// The name of the metric.
        public let metricName: MetricName?
        /// The id of the summary metric query.
        public let queryId: String?
        /// The start timestamp for the summary metric query.
        public let startTimestamp: Date?

        @inlinable
        public init(aggregationPeriod: AggregationPeriod? = nil, dimensions: [Dimension]? = nil, endTimestamp: Date? = nil, metricName: MetricName? = nil, queryId: String? = nil, startTimestamp: Date? = nil) {
            self.aggregationPeriod = aggregationPeriod
            self.dimensions = dimensions
            self.endTimestamp = endTimestamp
            self.metricName = metricName
            self.queryId = queryId
            self.startTimestamp = startTimestamp
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.queryId, name: "queryId", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationPeriod = "AggregationPeriod"
            case dimensions = "Dimensions"
            case endTimestamp = "EndTimestamp"
            case metricName = "MetricName"
            case queryId = "QueryId"
            case startTimestamp = "StartTimestamp"
        }
    }

    public struct SummaryMetricQueryResult: AWSDecodableShape {
        /// The aggregation period of the metric.
        public let aggregationPeriod: AggregationPeriod?
        /// The dimensions of the metric.
        public let dimensions: [Dimension]?
        /// The end timestamp for the summary metric query.
        public let endTimestamp: Date?
        /// The error message for the summary metric query result.
        public let error: String?
        /// The name of the summary metric query result.
        public let metricName: MetricName?
        /// The ID of the summary metric results query operation.
        public let queryId: String?
        /// The status of the summary metric query result.
        public let queryStatus: MetricQueryStatus?
        /// The start timestamp for the summary metric query.
        public let startTimestamp: Date?
        /// The timestamp of each aggregation result.
        public let timestamps: [Date]?
        /// The units of measurement to be used for interpreting the aggregation result.
        public let unit: String?
        /// The list of aggregated summary metric query results.
        public let values: [MetricQueryValue]?

        @inlinable
        public init(aggregationPeriod: AggregationPeriod? = nil, dimensions: [Dimension]? = nil, endTimestamp: Date? = nil, error: String? = nil, metricName: MetricName? = nil, queryId: String? = nil, queryStatus: MetricQueryStatus? = nil, startTimestamp: Date? = nil, timestamps: [Date]? = nil, unit: String? = nil, values: [MetricQueryValue]? = nil) {
            self.aggregationPeriod = aggregationPeriod
            self.dimensions = dimensions
            self.endTimestamp = endTimestamp
            self.error = error
            self.metricName = metricName
            self.queryId = queryId
            self.queryStatus = queryStatus
            self.startTimestamp = startTimestamp
            self.timestamps = timestamps
            self.unit = unit
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationPeriod = "AggregationPeriod"
            case dimensions = "Dimensions"
            case endTimestamp = "EndTimestamp"
            case error = "Error"
            case metricName = "MetricName"
            case queryId = "QueryId"
            case queryStatus = "QueryStatus"
            case startTimestamp = "StartTimestamp"
            case timestamps = "Timestamps"
            case unit = "Unit"
            case values = "Values"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag's key value.
        public let key: String
        /// The tag's value.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to add tags to.
        public let resourceArn: String
        /// Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TdscdmaLocalId: AWSEncodableShape {
        /// Cell parameters for TD-SCDMA.
        public let cellParams: Int
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).
        public let uarfcn: Int

        @inlinable
        public init(cellParams: Int, uarfcn: Int) {
            self.cellParams = cellParams
            self.uarfcn = uarfcn
        }

        public func validate(name: String) throws {
            try self.validate(self.cellParams, name: "cellParams", parent: name, max: 127)
            try self.validate(self.cellParams, name: "cellParams", parent: name, min: 0)
            try self.validate(self.uarfcn, name: "uarfcn", parent: name, max: 16383)
            try self.validate(self.uarfcn, name: "uarfcn", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case cellParams = "CellParams"
            case uarfcn = "Uarfcn"
        }
    }

    public struct TdscdmaNmrObj: AWSEncodableShape {
        /// Cell parameters for TD-SCDMA network measurement reports object.
        public let cellParams: Int
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public let pathLoss: Int?
        /// Code power of the received signal, measured in decibel-milliwatts (dBm).
        public let rscp: Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.
        public let uarfcn: Int
        /// UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.
        public let utranCid: Int?

        @inlinable
        public init(cellParams: Int, pathLoss: Int? = nil, rscp: Int? = nil, uarfcn: Int, utranCid: Int? = nil) {
            self.cellParams = cellParams
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.uarfcn = uarfcn
            self.utranCid = utranCid
        }

        public func validate(name: String) throws {
            try self.validate(self.cellParams, name: "cellParams", parent: name, max: 127)
            try self.validate(self.cellParams, name: "cellParams", parent: name, min: 0)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, max: 158)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, min: 46)
            try self.validate(self.rscp, name: "rscp", parent: name, max: -25)
            try self.validate(self.rscp, name: "rscp", parent: name, min: -120)
            try self.validate(self.uarfcn, name: "uarfcn", parent: name, max: 16383)
            try self.validate(self.uarfcn, name: "uarfcn", parent: name, min: 0)
            try self.validate(self.utranCid, name: "utranCid", parent: name, max: 268435455)
            try self.validate(self.utranCid, name: "utranCid", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case cellParams = "CellParams"
            case pathLoss = "PathLoss"
            case rscp = "Rscp"
            case uarfcn = "Uarfcn"
            case utranCid = "UtranCid"
        }
    }

    public struct TdscdmaObj: AWSEncodableShape {
        /// Location Area Code.
        public let lac: Int?
        /// Mobile Country Code.
        public let mcc: Int
        /// Mobile Network Code.
        public let mnc: Int
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public let pathLoss: Int?
        /// Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).
        public let rscp: Int?
        /// TD-SCDMA local identification (local ID) information.
        public let tdscdmaLocalId: TdscdmaLocalId?
        /// TD-SCDMA object for network measurement reports.
        public let tdscdmaNmr: [TdscdmaNmrObj]?
        /// TD-SCDMA Timing advance.
        public let tdscdmaTimingAdvance: Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        public let utranCid: Int

        @inlinable
        public init(lac: Int? = nil, mcc: Int, mnc: Int, pathLoss: Int? = nil, rscp: Int? = nil, tdscdmaLocalId: TdscdmaLocalId? = nil, tdscdmaNmr: [TdscdmaNmrObj]? = nil, tdscdmaTimingAdvance: Int? = nil, utranCid: Int) {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.tdscdmaLocalId = tdscdmaLocalId
            self.tdscdmaNmr = tdscdmaNmr
            self.tdscdmaTimingAdvance = tdscdmaTimingAdvance
            self.utranCid = utranCid
        }

        public func validate(name: String) throws {
            try self.validate(self.lac, name: "lac", parent: name, max: 65535)
            try self.validate(self.lac, name: "lac", parent: name, min: 1)
            try self.validate(self.mcc, name: "mcc", parent: name, max: 999)
            try self.validate(self.mcc, name: "mcc", parent: name, min: 200)
            try self.validate(self.mnc, name: "mnc", parent: name, max: 999)
            try self.validate(self.mnc, name: "mnc", parent: name, min: 0)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, max: 158)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, min: 46)
            try self.validate(self.rscp, name: "rscp", parent: name, max: -25)
            try self.validate(self.rscp, name: "rscp", parent: name, min: -120)
            try self.tdscdmaLocalId?.validate(name: "\(name).tdscdmaLocalId")
            try self.tdscdmaNmr?.forEach {
                try $0.validate(name: "\(name).tdscdmaNmr[]")
            }
            try self.validate(self.tdscdmaNmr, name: "tdscdmaNmr", parent: name, max: 32)
            try self.validate(self.tdscdmaNmr, name: "tdscdmaNmr", parent: name, min: 1)
            try self.validate(self.tdscdmaTimingAdvance, name: "tdscdmaTimingAdvance", parent: name, max: 1530)
            try self.validate(self.tdscdmaTimingAdvance, name: "tdscdmaTimingAdvance", parent: name, min: 0)
            try self.validate(self.utranCid, name: "utranCid", parent: name, max: 268435455)
            try self.validate(self.utranCid, name: "utranCid", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case lac = "Lac"
            case mcc = "Mcc"
            case mnc = "Mnc"
            case pathLoss = "PathLoss"
            case rscp = "Rscp"
            case tdscdmaLocalId = "TdscdmaLocalId"
            case tdscdmaNmr = "TdscdmaNmr"
            case tdscdmaTimingAdvance = "TdscdmaTimingAdvance"
            case utranCid = "UtranCid"
        }
    }

    public struct TestWirelessDeviceRequest: AWSEncodableShape {
        /// The ID of the wireless device to test.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct TestWirelessDeviceResponse: AWSDecodableShape {
        /// The result returned by the test.
        public let result: String?

        @inlinable
        public init(result: String? = nil) {
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case result = "Result"
        }
    }

    public struct TooManyTagsException: AWSErrorShape {
        public let message: String?
        /// Name of the resource that exceeds maximum number of tags allowed.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceName = "ResourceName"
        }
    }

    public struct TraceContent: AWSEncodableShape & AWSDecodableShape {
        public let logLevel: LogLevel?
        public let multicastFrameInfo: MulticastFrameInfo?
        public let wirelessDeviceFrameInfo: WirelessDeviceFrameInfo?

        @inlinable
        public init(logLevel: LogLevel? = nil, multicastFrameInfo: MulticastFrameInfo? = nil, wirelessDeviceFrameInfo: WirelessDeviceFrameInfo? = nil) {
            self.logLevel = logLevel
            self.multicastFrameInfo = multicastFrameInfo
            self.wirelessDeviceFrameInfo = wirelessDeviceFrameInfo
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
            case multicastFrameInfo = "MulticastFrameInfo"
            case wirelessDeviceFrameInfo = "WirelessDeviceFrameInfo"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to remove tags from.
        public let resourceArn: String
        /// A list of the keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAbpV10X: AWSEncodableShape {
        /// The FCnt init value.
        public let fCntStart: Int?

        @inlinable
        public init(fCntStart: Int? = nil) {
            self.fCntStart = fCntStart
        }

        public func validate(name: String) throws {
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, max: 65535)
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case fCntStart = "FCntStart"
        }
    }

    public struct UpdateAbpV11: AWSEncodableShape {
        /// The FCnt init value.
        public let fCntStart: Int?

        @inlinable
        public init(fCntStart: Int? = nil) {
            self.fCntStart = fCntStart
        }

        public func validate(name: String) throws {
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, max: 65535)
            try self.validate(self.fCntStart, name: "fCntStart", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case fCntStart = "FCntStart"
        }
    }

    public struct UpdateDestinationRequest: AWSEncodableShape {
        /// A new description of the resource.
        public let description: String?
        /// The new rule name or topic rule to send messages to.
        public let expression: String?
        /// The type of value in Expression.
        public let expressionType: ExpressionType?
        /// The new name of the resource.
        public let name: String
        /// The ARN of the IAM Role that authorizes the destination.
        public let roleArn: String?

        @inlinable
        public init(description: String? = nil, expression: String? = nil, expressionType: ExpressionType? = nil, name: String, roleArn: String? = nil) {
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.expression, forKey: .expression)
            try container.encodeIfPresent(self.expressionType, forKey: .expressionType)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case expression = "Expression"
            case expressionType = "ExpressionType"
            case roleArn = "RoleArn"
        }
    }

    public struct UpdateDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventConfigurationByResourceTypesRequest: AWSEncodableShape {
        /// Connection status resource type event configuration object for enabling and disabling wireless gateway topic.
        public let connectionStatus: ConnectionStatusResourceTypeEventConfiguration?
        /// Device registration state resource type event configuration object for enabling and disabling wireless gateway topic.
        public let deviceRegistrationState: DeviceRegistrationStateResourceTypeEventConfiguration?
        /// Join resource type event configuration object for enabling and disabling wireless device topic.
        public let join: JoinResourceTypeEventConfiguration?
        /// Message delivery status resource type event configuration object for enabling and disabling wireless device topic.
        public let messageDeliveryStatus: MessageDeliveryStatusResourceTypeEventConfiguration?
        /// Proximity resource type event configuration object for enabling and disabling wireless gateway topic.
        public let proximity: ProximityResourceTypeEventConfiguration?

        @inlinable
        public init(connectionStatus: ConnectionStatusResourceTypeEventConfiguration? = nil, deviceRegistrationState: DeviceRegistrationStateResourceTypeEventConfiguration? = nil, join: JoinResourceTypeEventConfiguration? = nil, messageDeliveryStatus: MessageDeliveryStatusResourceTypeEventConfiguration? = nil, proximity: ProximityResourceTypeEventConfiguration? = nil) {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case deviceRegistrationState = "DeviceRegistrationState"
            case join = "Join"
            case messageDeliveryStatus = "MessageDeliveryStatus"
            case proximity = "Proximity"
        }
    }

    public struct UpdateEventConfigurationByResourceTypesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFPorts: AWSEncodableShape {
        /// LoRaWAN application, which can be used for geolocation by activating positioning.
        public let applications: [ApplicationConfig]?
        /// Positioning FPorts for the ClockSync, Stream, and GNSS functions.
        public let positioning: Positioning?

        @inlinable
        public init(applications: [ApplicationConfig]? = nil, positioning: Positioning? = nil) {
            self.applications = applications
            self.positioning = positioning
        }

        public func validate(name: String) throws {
            try self.applications?.forEach {
                try $0.validate(name: "\(name).applications[]")
            }
            try self.positioning?.validate(name: "\(name).positioning")
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "Applications"
            case positioning = "Positioning"
        }
    }

    public struct UpdateFuotaTaskRequest: AWSEncodableShape {
        public let description: String?
        public let descriptor: String?
        public let firmwareUpdateImage: String?
        public let firmwareUpdateRole: String?
        public let fragmentIntervalMS: Int?
        public let fragmentSizeBytes: Int?
        public let id: String
        public let loRaWAN: LoRaWANFuotaTask?
        public let name: String?
        public let redundancyPercent: Int?

        @inlinable
        public init(description: String? = nil, descriptor: String? = nil, firmwareUpdateImage: String? = nil, firmwareUpdateRole: String? = nil, fragmentIntervalMS: Int? = nil, fragmentSizeBytes: Int? = nil, id: String, loRaWAN: LoRaWANFuotaTask? = nil, name: String? = nil, redundancyPercent: Int? = nil) {
            self.description = description
            self.descriptor = descriptor
            self.firmwareUpdateImage = firmwareUpdateImage
            self.firmwareUpdateRole = firmwareUpdateRole
            self.fragmentIntervalMS = fragmentIntervalMS
            self.fragmentSizeBytes = fragmentSizeBytes
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.redundancyPercent = redundancyPercent
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.descriptor, forKey: .descriptor)
            try container.encodeIfPresent(self.firmwareUpdateImage, forKey: .firmwareUpdateImage)
            try container.encodeIfPresent(self.firmwareUpdateRole, forKey: .firmwareUpdateRole)
            try container.encodeIfPresent(self.fragmentIntervalMS, forKey: .fragmentIntervalMS)
            try container.encodeIfPresent(self.fragmentSizeBytes, forKey: .fragmentSizeBytes)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.loRaWAN, forKey: .loRaWAN)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.redundancyPercent, forKey: .redundancyPercent)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.descriptor, name: "descriptor", parent: name, max: 332)
            try self.validate(self.descriptor, name: "descriptor", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
            try self.validate(self.firmwareUpdateImage, name: "firmwareUpdateImage", parent: name, max: 4096)
            try self.validate(self.firmwareUpdateImage, name: "firmwareUpdateImage", parent: name, min: 1)
            try self.validate(self.firmwareUpdateRole, name: "firmwareUpdateRole", parent: name, max: 2048)
            try self.validate(self.firmwareUpdateRole, name: "firmwareUpdateRole", parent: name, min: 1)
            try self.validate(self.fragmentIntervalMS, name: "fragmentIntervalMS", parent: name, min: 1)
            try self.validate(self.fragmentSizeBytes, name: "fragmentSizeBytes", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.redundancyPercent, name: "redundancyPercent", parent: name, max: 100)
            try self.validate(self.redundancyPercent, name: "redundancyPercent", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case descriptor = "Descriptor"
            case firmwareUpdateImage = "FirmwareUpdateImage"
            case firmwareUpdateRole = "FirmwareUpdateRole"
            case fragmentIntervalMS = "FragmentIntervalMS"
            case fragmentSizeBytes = "FragmentSizeBytes"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case redundancyPercent = "RedundancyPercent"
        }
    }

    public struct UpdateFuotaTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLogLevelsByResourceTypesRequest: AWSEncodableShape {
        public let defaultLogLevel: LogLevel?
        public let fuotaTaskLogOptions: [FuotaTaskLogOption]?
        public let wirelessDeviceLogOptions: [WirelessDeviceLogOption]?
        public let wirelessGatewayLogOptions: [WirelessGatewayLogOption]?

        @inlinable
        public init(defaultLogLevel: LogLevel? = nil, fuotaTaskLogOptions: [FuotaTaskLogOption]? = nil, wirelessDeviceLogOptions: [WirelessDeviceLogOption]? = nil, wirelessGatewayLogOptions: [WirelessGatewayLogOption]? = nil) {
            self.defaultLogLevel = defaultLogLevel
            self.fuotaTaskLogOptions = fuotaTaskLogOptions
            self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
        }

        private enum CodingKeys: String, CodingKey {
            case defaultLogLevel = "DefaultLogLevel"
            case fuotaTaskLogOptions = "FuotaTaskLogOptions"
            case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
            case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
        }
    }

    public struct UpdateLogLevelsByResourceTypesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMetricConfigurationRequest: AWSEncodableShape {
        /// The value to be used to set summary metric configuration.
        public let summaryMetric: SummaryMetricConfiguration?

        @inlinable
        public init(summaryMetric: SummaryMetricConfiguration? = nil) {
            self.summaryMetric = summaryMetric
        }

        private enum CodingKeys: String, CodingKey {
            case summaryMetric = "SummaryMetric"
        }
    }

    public struct UpdateMetricConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMulticastGroupRequest: AWSEncodableShape {
        public let description: String?
        public let id: String
        public let loRaWAN: LoRaWANMulticast?
        public let name: String?

        @inlinable
        public init(description: String? = nil, id: String, loRaWAN: LoRaWANMulticast? = nil, name: String? = nil) {
            self.description = description
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.loRaWAN, forKey: .loRaWAN)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
        }
    }

    public struct UpdateMulticastGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateNetworkAnalyzerConfigurationRequest: AWSEncodableShape {
        public let configurationName: String
        public let description: String?
        /// Multicast group resources to add to the network analyzer configuration. Provide the MulticastGroupId of the resource to add in the input array.
        public let multicastGroupsToAdd: [String]?
        /// Multicast group resources to remove from the network analyzer configuration. Provide the MulticastGroupId of the resources to remove in the input array.
        public let multicastGroupsToRemove: [String]?
        public let traceContent: TraceContent?
        /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
        public let wirelessDevicesToAdd: [String]?
        /// Wireless device resources to remove from the network analyzer configuration. Provide the WirelessDeviceId of the resources to remove in the input array.
        public let wirelessDevicesToRemove: [String]?
        /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
        public let wirelessGatewaysToAdd: [String]?
        /// Wireless gateway resources to remove from the network analyzer configuration. Provide the WirelessGatewayId of the resources to remove in the input array.
        public let wirelessGatewaysToRemove: [String]?

        @inlinable
        public init(configurationName: String, description: String? = nil, multicastGroupsToAdd: [String]? = nil, multicastGroupsToRemove: [String]? = nil, traceContent: TraceContent? = nil, wirelessDevicesToAdd: [String]? = nil, wirelessDevicesToRemove: [String]? = nil, wirelessGatewaysToAdd: [String]? = nil, wirelessGatewaysToRemove: [String]? = nil) {
            self.configurationName = configurationName
            self.description = description
            self.multicastGroupsToAdd = multicastGroupsToAdd
            self.multicastGroupsToRemove = multicastGroupsToRemove
            self.traceContent = traceContent
            self.wirelessDevicesToAdd = wirelessDevicesToAdd
            self.wirelessDevicesToRemove = wirelessDevicesToRemove
            self.wirelessGatewaysToAdd = wirelessGatewaysToAdd
            self.wirelessGatewaysToRemove = wirelessGatewaysToRemove
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationName, key: "ConfigurationName")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.multicastGroupsToAdd, forKey: .multicastGroupsToAdd)
            try container.encodeIfPresent(self.multicastGroupsToRemove, forKey: .multicastGroupsToRemove)
            try container.encodeIfPresent(self.traceContent, forKey: .traceContent)
            try container.encodeIfPresent(self.wirelessDevicesToAdd, forKey: .wirelessDevicesToAdd)
            try container.encodeIfPresent(self.wirelessDevicesToRemove, forKey: .wirelessDevicesToRemove)
            try container.encodeIfPresent(self.wirelessGatewaysToAdd, forKey: .wirelessGatewaysToAdd)
            try container.encodeIfPresent(self.wirelessGatewaysToRemove, forKey: .wirelessGatewaysToRemove)
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationName, name: "configurationName", parent: name, max: 1024)
            try self.validate(self.configurationName, name: "configurationName", parent: name, min: 1)
            try self.validate(self.configurationName, name: "configurationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.multicastGroupsToAdd?.forEach {
                try validate($0, name: "multicastGroupsToAdd[]", parent: name, max: 256)
            }
            try self.validate(self.multicastGroupsToAdd, name: "multicastGroupsToAdd", parent: name, max: 10)
            try self.multicastGroupsToRemove?.forEach {
                try validate($0, name: "multicastGroupsToRemove[]", parent: name, max: 256)
            }
            try self.validate(self.multicastGroupsToRemove, name: "multicastGroupsToRemove", parent: name, max: 10)
            try self.wirelessDevicesToAdd?.forEach {
                try validate($0, name: "wirelessDevicesToAdd[]", parent: name, max: 256)
            }
            try self.validate(self.wirelessDevicesToAdd, name: "wirelessDevicesToAdd", parent: name, max: 250)
            try self.wirelessDevicesToRemove?.forEach {
                try validate($0, name: "wirelessDevicesToRemove[]", parent: name, max: 256)
            }
            try self.validate(self.wirelessDevicesToRemove, name: "wirelessDevicesToRemove", parent: name, max: 250)
            try self.wirelessGatewaysToAdd?.forEach {
                try validate($0, name: "wirelessGatewaysToAdd[]", parent: name, max: 256)
            }
            try self.wirelessGatewaysToRemove?.forEach {
                try validate($0, name: "wirelessGatewaysToRemove[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case multicastGroupsToAdd = "MulticastGroupsToAdd"
            case multicastGroupsToRemove = "MulticastGroupsToRemove"
            case traceContent = "TraceContent"
            case wirelessDevicesToAdd = "WirelessDevicesToAdd"
            case wirelessDevicesToRemove = "WirelessDevicesToRemove"
            case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
            case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
        }
    }

    public struct UpdateNetworkAnalyzerConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePartnerAccountRequest: AWSEncodableShape {
        /// The ID of the partner account to update.
        public let partnerAccountId: String
        /// The partner type.
        public let partnerType: PartnerType
        /// The Sidewalk account credentials.
        public let sidewalk: SidewalkUpdateAccount

        @inlinable
        public init(partnerAccountId: String, partnerType: PartnerType, sidewalk: SidewalkUpdateAccount) {
            self.partnerAccountId = partnerAccountId
            self.partnerType = partnerType
            self.sidewalk = sidewalk
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnerAccountId, key: "PartnerAccountId")
            request.encodeQuery(self.partnerType, key: "partnerType")
            try container.encode(self.sidewalk, forKey: .sidewalk)
        }

        public func validate(name: String) throws {
            try self.validate(self.partnerAccountId, name: "partnerAccountId", parent: name, max: 256)
            try self.sidewalk.validate(name: "\(name).sidewalk")
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
        }
    }

    public struct UpdatePartnerAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePositionRequest: AWSEncodableShape {
        /// The position information of the resource.
        public let position: [Float]
        /// Resource identifier of the resource for which position is updated.
        public let resourceIdentifier: String
        /// Resource type of the resource for which position is updated.
        public let resourceType: PositionResourceType

        @inlinable
        public init(position: [Float], resourceIdentifier: String, resourceType: PositionResourceType) {
            self.position = position
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.position, forKey: .position)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
        }
    }

    public struct UpdatePositionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResourceEventConfigurationRequest: AWSEncodableShape {
        /// Event configuration for the connection status event.
        public let connectionStatus: ConnectionStatusEventConfiguration?
        /// Event configuration for the device registration state event.
        public let deviceRegistrationState: DeviceRegistrationStateEventConfiguration?
        /// Resource identifier to opt in for event messaging.
        public let identifier: String
        /// Identifier type of the particular resource identifier for event configuration.
        public let identifierType: IdentifierType
        /// Event configuration for the join event.
        public let join: JoinEventConfiguration?
        /// Event configuration for the message delivery status event.
        public let messageDeliveryStatus: MessageDeliveryStatusEventConfiguration?
        /// Partner type of the resource if the identifier type is PartnerAccountId
        public let partnerType: EventNotificationPartnerType?
        /// Event configuration for the proximity event.
        public let proximity: ProximityEventConfiguration?

        @inlinable
        public init(connectionStatus: ConnectionStatusEventConfiguration? = nil, deviceRegistrationState: DeviceRegistrationStateEventConfiguration? = nil, identifier: String, identifierType: IdentifierType, join: JoinEventConfiguration? = nil, messageDeliveryStatus: MessageDeliveryStatusEventConfiguration? = nil, partnerType: EventNotificationPartnerType? = nil, proximity: ProximityEventConfiguration? = nil) {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.identifier = identifier
            self.identifierType = identifierType
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.partnerType = partnerType
            self.proximity = proximity
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectionStatus, forKey: .connectionStatus)
            try container.encodeIfPresent(self.deviceRegistrationState, forKey: .deviceRegistrationState)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.identifierType, key: "identifierType")
            try container.encodeIfPresent(self.join, forKey: .join)
            try container.encodeIfPresent(self.messageDeliveryStatus, forKey: .messageDeliveryStatus)
            request.encodeQuery(self.partnerType, key: "partnerType")
            try container.encodeIfPresent(self.proximity, forKey: .proximity)
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case deviceRegistrationState = "DeviceRegistrationState"
            case join = "Join"
            case messageDeliveryStatus = "MessageDeliveryStatus"
            case proximity = "Proximity"
        }
    }

    public struct UpdateResourceEventConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResourcePositionRequest: AWSEncodableShape {
        /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see GeoJSON.
        public let geoJsonPayload: AWSHTTPBody?
        /// The identifier of the resource for which position information is updated. It can be the wireless device ID or the wireless gateway ID, depending on the resource type.
        public let resourceIdentifier: String
        /// The type of resource for which position information is updated, which can be a wireless device or a wireless gateway.
        public let resourceType: PositionResourceType

        @inlinable
        public init(geoJsonPayload: AWSHTTPBody? = nil, resourceIdentifier: String, resourceType: PositionResourceType) {
            self.geoJsonPayload = geoJsonPayload
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.geoJsonPayload)
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateResourcePositionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWirelessDeviceImportTaskRequest: AWSEncodableShape {
        /// The identifier of the import task to be updated.
        public let id: String
        /// The Sidewalk-related parameters of the import task to be updated.
        public let sidewalk: SidewalkUpdateImportInfo

        @inlinable
        public init(id: String, sidewalk: SidewalkUpdateImportInfo) {
            self.id = id
            self.sidewalk = sidewalk
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.sidewalk, forKey: .sidewalk)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.sidewalk.validate(name: "\(name).sidewalk")
        }

        private enum CodingKeys: String, CodingKey {
            case sidewalk = "Sidewalk"
        }
    }

    public struct UpdateWirelessDeviceImportTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWirelessDeviceRequest: AWSEncodableShape {
        /// A new description of the resource.
        public let description: String?
        /// The name of the new destination for the device.
        public let destinationName: String?
        /// The ID of the resource to update.
        public let id: String
        /// The updated wireless device's configuration.
        public let loRaWAN: LoRaWANUpdateDevice?
        /// The new name of the resource.
        public let name: String?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public let positioning: PositioningConfigStatus?

        @inlinable
        public init(description: String? = nil, destinationName: String? = nil, id: String, loRaWAN: LoRaWANUpdateDevice? = nil, name: String? = nil, positioning: PositioningConfigStatus? = nil) {
            self.description = description
            self.destinationName = destinationName
            self.id = id
            self.loRaWAN = loRaWAN
            self.name = name
            self.positioning = positioning
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.destinationName, forKey: .destinationName)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.loRaWAN, forKey: .loRaWAN)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.positioning, forKey: .positioning)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.validate(self.name, name: "name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case destinationName = "DestinationName"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
            case positioning = "Positioning"
        }
    }

    public struct UpdateWirelessDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWirelessGatewayRequest: AWSEncodableShape {
        /// A new description of the resource.
        public let description: String?
        /// The ID of the resource to update.
        public let id: String
        public let joinEuiFilters: [[String]]?
        /// The MaxEIRP value.
        public let maxEirp: Float?
        /// The new name of the resource.
        public let name: String?
        public let netIdFilters: [String]?

        @inlinable
        public init(description: String? = nil, id: String, joinEuiFilters: [[String]]? = nil, maxEirp: Float? = nil, name: String? = nil, netIdFilters: [String]? = nil) {
            self.description = description
            self.id = id
            self.joinEuiFilters = joinEuiFilters
            self.maxEirp = maxEirp
            self.name = name
            self.netIdFilters = netIdFilters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.joinEuiFilters, forKey: .joinEuiFilters)
            try container.encodeIfPresent(self.maxEirp, forKey: .maxEirp)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.netIdFilters, forKey: .netIdFilters)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.joinEuiFilters?.forEach {
                try validate($0, name: "joinEuiFilters[]", parent: name, max: 2)
                try validate($0, name: "joinEuiFilters[]", parent: name, min: 2)
            }
            try self.validate(self.joinEuiFilters, name: "joinEuiFilters", parent: name, max: 3)
            try self.validate(self.maxEirp, name: "maxEirp", parent: name, max: 30.0)
            try self.validate(self.maxEirp, name: "maxEirp", parent: name, min: 0.0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.netIdFilters?.forEach {
                try validate($0, name: "netIdFilters[]", parent: name, pattern: "^[a-fA-F0-9]{6}$")
            }
            try self.validate(self.netIdFilters, name: "netIdFilters", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case joinEuiFilters = "JoinEuiFilters"
            case maxEirp = "MaxEirp"
            case name = "Name"
            case netIdFilters = "NetIdFilters"
        }
    }

    public struct UpdateWirelessGatewayResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWirelessGatewayTaskCreate: AWSEncodableShape & AWSDecodableShape {
        /// The properties that relate to the LoRaWAN wireless gateway.
        public let loRaWAN: LoRaWANUpdateGatewayTaskCreate?
        /// The IAM role used to read data from the S3 bucket.
        public let updateDataRole: String?
        /// The link to the S3 bucket.
        public let updateDataSource: String?

        @inlinable
        public init(loRaWAN: LoRaWANUpdateGatewayTaskCreate? = nil, updateDataRole: String? = nil, updateDataSource: String? = nil) {
            self.loRaWAN = loRaWAN
            self.updateDataRole = updateDataRole
            self.updateDataSource = updateDataSource
        }

        public func validate(name: String) throws {
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.validate(self.updateDataRole, name: "updateDataRole", parent: name, max: 4096)
            try self.validate(self.updateDataRole, name: "updateDataRole", parent: name, min: 1)
            try self.validate(self.updateDataSource, name: "updateDataSource", parent: name, max: 4096)
            try self.validate(self.updateDataSource, name: "updateDataSource", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
            case updateDataRole = "UpdateDataRole"
            case updateDataSource = "UpdateDataSource"
        }
    }

    public struct UpdateWirelessGatewayTaskEntry: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The ID of the new wireless gateway task entry.
        public let id: String?
        /// The properties that relate to the LoRaWAN wireless gateway.
        public let loRaWAN: LoRaWANUpdateGatewayTaskEntry?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, loRaWAN: LoRaWANUpdateGatewayTaskEntry? = nil) {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case loRaWAN = "LoRaWAN"
        }
    }

    public struct WcdmaLocalId: AWSEncodableShape {
        /// Primary Scrambling Code.
        public let psc: Int
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        public let uarfcndl: Int

        @inlinable
        public init(psc: Int, uarfcndl: Int) {
            self.psc = psc
            self.uarfcndl = uarfcndl
        }

        public func validate(name: String) throws {
            try self.validate(self.psc, name: "psc", parent: name, max: 511)
            try self.validate(self.psc, name: "psc", parent: name, min: 0)
            try self.validate(self.uarfcndl, name: "uarfcndl", parent: name, max: 16383)
            try self.validate(self.uarfcndl, name: "uarfcndl", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case psc = "Psc"
            case uarfcndl = "Uarfcndl"
        }
    }

    public struct WcdmaNmrObj: AWSEncodableShape {
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public let pathLoss: Int?
        /// Primary Scrambling Code.
        public let psc: Int
        /// Received Signal Code Power (signal power) (dBm)
        public let rscp: Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        public let uarfcndl: Int
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        public let utranCid: Int

        @inlinable
        public init(pathLoss: Int? = nil, psc: Int, rscp: Int? = nil, uarfcndl: Int, utranCid: Int) {
            self.pathLoss = pathLoss
            self.psc = psc
            self.rscp = rscp
            self.uarfcndl = uarfcndl
            self.utranCid = utranCid
        }

        public func validate(name: String) throws {
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, max: 158)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, min: 46)
            try self.validate(self.psc, name: "psc", parent: name, max: 511)
            try self.validate(self.psc, name: "psc", parent: name, min: 0)
            try self.validate(self.rscp, name: "rscp", parent: name, max: -25)
            try self.validate(self.rscp, name: "rscp", parent: name, min: -120)
            try self.validate(self.uarfcndl, name: "uarfcndl", parent: name, max: 16383)
            try self.validate(self.uarfcndl, name: "uarfcndl", parent: name, min: 0)
            try self.validate(self.utranCid, name: "utranCid", parent: name, max: 268435455)
            try self.validate(self.utranCid, name: "utranCid", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case pathLoss = "PathLoss"
            case psc = "Psc"
            case rscp = "Rscp"
            case uarfcndl = "Uarfcndl"
            case utranCid = "UtranCid"
        }
    }

    public struct WcdmaObj: AWSEncodableShape {
        /// Location Area Code.
        public let lac: Int?
        /// Mobile Country Code.
        public let mcc: Int
        /// Mobile Network Code.
        public let mnc: Int
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public let pathLoss: Int?
        /// Received Signal Code Power (signal power) (dBm).
        public let rscp: Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        public let utranCid: Int
        /// WCDMA local ID information.
        public let wcdmaLocalId: WcdmaLocalId?
        /// WCDMA object for network measurement reports.
        public let wcdmaNmr: [WcdmaNmrObj]?

        @inlinable
        public init(lac: Int? = nil, mcc: Int, mnc: Int, pathLoss: Int? = nil, rscp: Int? = nil, utranCid: Int, wcdmaLocalId: WcdmaLocalId? = nil, wcdmaNmr: [WcdmaNmrObj]? = nil) {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.utranCid = utranCid
            self.wcdmaLocalId = wcdmaLocalId
            self.wcdmaNmr = wcdmaNmr
        }

        public func validate(name: String) throws {
            try self.validate(self.lac, name: "lac", parent: name, max: 65535)
            try self.validate(self.lac, name: "lac", parent: name, min: 1)
            try self.validate(self.mcc, name: "mcc", parent: name, max: 999)
            try self.validate(self.mcc, name: "mcc", parent: name, min: 200)
            try self.validate(self.mnc, name: "mnc", parent: name, max: 999)
            try self.validate(self.mnc, name: "mnc", parent: name, min: 0)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, max: 158)
            try self.validate(self.pathLoss, name: "pathLoss", parent: name, min: 46)
            try self.validate(self.rscp, name: "rscp", parent: name, max: -25)
            try self.validate(self.rscp, name: "rscp", parent: name, min: -120)
            try self.validate(self.utranCid, name: "utranCid", parent: name, max: 268435455)
            try self.validate(self.utranCid, name: "utranCid", parent: name, min: 0)
            try self.wcdmaLocalId?.validate(name: "\(name).wcdmaLocalId")
            try self.wcdmaNmr?.forEach {
                try $0.validate(name: "\(name).wcdmaNmr[]")
            }
            try self.validate(self.wcdmaNmr, name: "wcdmaNmr", parent: name, max: 32)
            try self.validate(self.wcdmaNmr, name: "wcdmaNmr", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case lac = "Lac"
            case mcc = "Mcc"
            case mnc = "Mnc"
            case pathLoss = "PathLoss"
            case rscp = "Rscp"
            case utranCid = "UtranCid"
            case wcdmaLocalId = "WcdmaLocalId"
            case wcdmaNmr = "WcdmaNmr"
        }
    }

    public struct WiFiAccessPoint: AWSEncodableShape {
        /// Wi-Fi MAC Address.
        public let macAddress: String
        /// Received signal strength (dBm) of the WLAN measurement data.
        public let rss: Int

        @inlinable
        public init(macAddress: String, rss: Int) {
            self.macAddress = macAddress
            self.rss = rss
        }

        public func validate(name: String) throws {
            try self.validate(self.macAddress, name: "macAddress", parent: name, max: 17)
            try self.validate(self.macAddress, name: "macAddress", parent: name, min: 12)
            try self.validate(self.macAddress, name: "macAddress", parent: name, pattern: "^([0-9A-Fa-f]{2}[:-]?){5}([0-9A-Fa-f]{2})$")
            try self.validate(self.rss, name: "rss", parent: name, max: 0)
            try self.validate(self.rss, name: "rss", parent: name, min: -128)
        }

        private enum CodingKeys: String, CodingKey {
            case macAddress = "MacAddress"
            case rss = "Rss"
        }
    }

    public struct WirelessDeviceEventLogOption: AWSEncodableShape & AWSDecodableShape {
        public let event: WirelessDeviceEvent
        public let logLevel: LogLevel

        @inlinable
        public init(event: WirelessDeviceEvent, logLevel: LogLevel) {
            self.event = event
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case event = "Event"
            case logLevel = "LogLevel"
        }
    }

    public struct WirelessDeviceImportTask: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the wireless device import task.
        public let arn: String?
        /// The time at which the import task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The name of the Sidewalk destination that that describes the IoT rule to route messages from the device in the import task that will be onboarded to AWS IoT Wireless
        public let destinationName: String?
        /// The summary information of count of wireless devices in an import task that failed to onboarded to the import task.
        public let failedImportedDeviceCount: Int64?
        /// The ID of the wireless device import task.
        public let id: String?
        /// The summary information of count of wireless devices that are waiting for the control log to be added to an import task.
        public let initializedImportedDeviceCount: Int64?
        /// The summary information of count of wireless devices in an import task that have been onboarded to the import task.
        public let onboardedImportedDeviceCount: Int64?
        /// The summary information of count of wireless devices in an import task that are waiting in the queue to be onboarded.
        public let pendingImportedDeviceCount: Int64?
        /// The Sidewalk-related information of the wireless device import task.
        public let sidewalk: SidewalkGetStartImportInfo?
        /// The status information of the wireless device import task.
        public let status: ImportTaskStatus?
        /// The reason that provides additional information about the import task status.
        public let statusReason: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, destinationName: String? = nil, failedImportedDeviceCount: Int64? = nil, id: String? = nil, initializedImportedDeviceCount: Int64? = nil, onboardedImportedDeviceCount: Int64? = nil, pendingImportedDeviceCount: Int64? = nil, sidewalk: SidewalkGetStartImportInfo? = nil, status: ImportTaskStatus? = nil, statusReason: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.failedImportedDeviceCount = failedImportedDeviceCount
            self.id = id
            self.initializedImportedDeviceCount = initializedImportedDeviceCount
            self.onboardedImportedDeviceCount = onboardedImportedDeviceCount
            self.pendingImportedDeviceCount = pendingImportedDeviceCount
            self.sidewalk = sidewalk
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case destinationName = "DestinationName"
            case failedImportedDeviceCount = "FailedImportedDeviceCount"
            case id = "Id"
            case initializedImportedDeviceCount = "InitializedImportedDeviceCount"
            case onboardedImportedDeviceCount = "OnboardedImportedDeviceCount"
            case pendingImportedDeviceCount = "PendingImportedDeviceCount"
            case sidewalk = "Sidewalk"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct WirelessDeviceLogOption: AWSEncodableShape & AWSDecodableShape {
        public let events: [WirelessDeviceEventLogOption]?
        public let logLevel: LogLevel
        /// The wireless device type.
        public let type: WirelessDeviceType

        @inlinable
        public init(events: [WirelessDeviceEventLogOption]? = nil, logLevel: LogLevel, type: WirelessDeviceType) {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case logLevel = "LogLevel"
            case type = "Type"
        }
    }

    public struct WirelessDeviceStatistics: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The name of the destination to which the device is assigned.
        public let destinationName: String?
        public let fuotaDeviceStatus: FuotaDeviceStatus?
        /// The ID of the wireless device reporting the data.
        public let id: String?
        /// The date and time when the most recent uplink was received.  Theis value is only valid for 3 months.
        public let lastUplinkReceivedAt: String?
        /// LoRaWAN device info.
        public let loRaWAN: LoRaWANListDevice?
        public let mcGroupId: Int?
        /// The status of the wireless device in the multicast group.
        public let multicastDeviceStatus: String?
        /// The name of the resource.
        public let name: String?
        /// The Sidewalk account credentials.
        public let sidewalk: SidewalkListDevice?
        /// The wireless device type.
        public let type: WirelessDeviceType?

        @inlinable
        public init(arn: String? = nil, destinationName: String? = nil, fuotaDeviceStatus: FuotaDeviceStatus? = nil, id: String? = nil, lastUplinkReceivedAt: String? = nil, loRaWAN: LoRaWANListDevice? = nil, mcGroupId: Int? = nil, multicastDeviceStatus: String? = nil, name: String? = nil, sidewalk: SidewalkListDevice? = nil, type: WirelessDeviceType? = nil) {
            self.arn = arn
            self.destinationName = destinationName
            self.fuotaDeviceStatus = fuotaDeviceStatus
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.mcGroupId = mcGroupId
            self.multicastDeviceStatus = multicastDeviceStatus
            self.name = name
            self.sidewalk = sidewalk
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case destinationName = "DestinationName"
            case fuotaDeviceStatus = "FuotaDeviceStatus"
            case id = "Id"
            case lastUplinkReceivedAt = "LastUplinkReceivedAt"
            case loRaWAN = "LoRaWAN"
            case mcGroupId = "McGroupId"
            case multicastDeviceStatus = "MulticastDeviceStatus"
            case name = "Name"
            case sidewalk = "Sidewalk"
            case type = "Type"
        }
    }

    public struct WirelessGatewayEventLogOption: AWSEncodableShape & AWSDecodableShape {
        public let event: WirelessGatewayEvent
        public let logLevel: LogLevel

        @inlinable
        public init(event: WirelessGatewayEvent, logLevel: LogLevel) {
            self.event = event
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case event = "Event"
            case logLevel = "LogLevel"
        }
    }

    public struct WirelessGatewayLogOption: AWSEncodableShape & AWSDecodableShape {
        public let events: [WirelessGatewayEventLogOption]?
        public let logLevel: LogLevel
        public let type: WirelessGatewayType

        @inlinable
        public init(events: [WirelessGatewayEventLogOption]? = nil, logLevel: LogLevel, type: WirelessGatewayType) {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case logLevel = "LogLevel"
            case type = "Type"
        }
    }

    public struct WirelessGatewayStatistics: AWSDecodableShape {
        /// The Amazon Resource Name of the resource.
        public let arn: String?
        /// The description of the resource.
        public let description: String?
        /// The ID of the wireless gateway reporting the data.
        public let id: String?
        /// The date and time when the most recent uplink was received.  This value is only valid for 3 months.
        public let lastUplinkReceivedAt: String?
        /// LoRaWAN gateway info.
        public let loRaWAN: LoRaWANGateway?
        /// The name of the resource.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, lastUplinkReceivedAt: String? = nil, loRaWAN: LoRaWANGateway? = nil, name: String? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case lastUplinkReceivedAt = "LastUplinkReceivedAt"
            case loRaWAN = "LoRaWAN"
            case name = "Name"
        }
    }

    public struct WirelessMetadata: AWSEncodableShape {
        /// LoRaWAN device info.
        public let loRaWAN: LoRaWANSendDataToDevice?
        /// The Sidewalk account credentials.
        public let sidewalk: SidewalkSendDataToDevice?

        @inlinable
        public init(loRaWAN: LoRaWANSendDataToDevice? = nil, sidewalk: SidewalkSendDataToDevice? = nil) {
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
        }

        public func validate(name: String) throws {
            try self.loRaWAN?.validate(name: "\(name).loRaWAN")
            try self.sidewalk?.validate(name: "\(name).sidewalk")
        }

        private enum CodingKeys: String, CodingKey {
            case loRaWAN = "LoRaWAN"
            case sidewalk = "Sidewalk"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTWireless
public struct IoTWirelessErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTWireless
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Adding, updating, or deleting the resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred while processing a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied because it exceeded the allowed API request rate.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request was denied because the resource can't have any more tags.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input did not meet the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTWirelessErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": IoTWireless.ConflictException.self,
        "ResourceNotFoundException": IoTWireless.ResourceNotFoundException.self,
        "TooManyTagsException": IoTWireless.TooManyTagsException.self
    ]
}

extension IoTWirelessErrorType: Equatable {
    public static func == (lhs: IoTWirelessErrorType, rhs: IoTWirelessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTWirelessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
