//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS IoTWireless service.
///
/// AWS IoT Wireless provides bi-directional communication between internet-connected wireless
/// 	        devices and the AWS Cloud. To onboard both LoRaWAN and Sidewalk devices to AWS IoT, use the
/// 	        IoT Wireless API. These wireless devices use the Low Power Wide Area Networking (LPWAN)
/// 	        communication protocol to communicate with AWS IoT.
/// 	        Using the API, you can perform create, read, update, and delete operations for your wireless
/// 	        devices, gateways, destinations, and profiles. After onboarding your devices, you
/// 	        can use the API operations to set log levels and monitor your devices with CloudWatch.
/// 	        You can also use the API operations to create multicast groups and schedule a multicast session for
/// 	        sending a downlink message to devices in the group. By using Firmware Updates Over-The-Air
/// 	        (FUOTA) API operations, you can create a FUOTA task and schedule a session to update the firmware
/// 	        of individual devices or an entire group of devices in a multicast group.
public struct IoTWireless: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the IoTWireless client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "api.iotwireless",
            signingName: "iotwireless",
            serviceProtocol: .restjson,
            apiVersion: "2020-11-22",
            endpoint: endpoint,
            serviceEndpoints: [
                "ap-northeast-1": "api.iotwireless.ap-northeast-1.amazonaws.com",
                "ap-southeast-2": "api.iotwireless.ap-southeast-2.amazonaws.com",
                "eu-central-1": "api.iotwireless.eu-central-1.amazonaws.com",
                "eu-west-1": "api.iotwireless.eu-west-1.amazonaws.com",
                "sa-east-1": "api.iotwireless.sa-east-1.amazonaws.com",
                "us-east-1": "api.iotwireless.us-east-1.amazonaws.com",
                "us-west-2": "api.iotwireless.us-west-2.amazonaws.com"
            ],
            errorType: IoTWirelessErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Associates a partner account with your AWS account.
    public func associateAwsAccountWithPartnerAccount(_ input: AssociateAwsAccountWithPartnerAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateAwsAccountWithPartnerAccountResponse> {
        return self.client.execute(operation: "AssociateAwsAccountWithPartnerAccount", path: "/partner-accounts", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Associate a multicast group with a FUOTA task.
    public func associateMulticastGroupWithFuotaTask(_ input: AssociateMulticastGroupWithFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateMulticastGroupWithFuotaTaskResponse> {
        return self.client.execute(operation: "AssociateMulticastGroupWithFuotaTask", path: "/fuota-tasks/{Id}/multicast-group", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Associate a wireless device with a FUOTA task.
    public func associateWirelessDeviceWithFuotaTask(_ input: AssociateWirelessDeviceWithFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateWirelessDeviceWithFuotaTaskResponse> {
        return self.client.execute(operation: "AssociateWirelessDeviceWithFuotaTask", path: "/fuota-tasks/{Id}/wireless-device", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Associates a wireless device with a multicast group.
    public func associateWirelessDeviceWithMulticastGroup(_ input: AssociateWirelessDeviceWithMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateWirelessDeviceWithMulticastGroupResponse> {
        return self.client.execute(operation: "AssociateWirelessDeviceWithMulticastGroup", path: "/multicast-groups/{Id}/wireless-device", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Associates a wireless device with a thing.
    public func associateWirelessDeviceWithThing(_ input: AssociateWirelessDeviceWithThingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateWirelessDeviceWithThingResponse> {
        return self.client.execute(operation: "AssociateWirelessDeviceWithThing", path: "/wireless-devices/{Id}/thing", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Associates a wireless gateway with a certificate.
    public func associateWirelessGatewayWithCertificate(_ input: AssociateWirelessGatewayWithCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateWirelessGatewayWithCertificateResponse> {
        return self.client.execute(operation: "AssociateWirelessGatewayWithCertificate", path: "/wireless-gateways/{Id}/certificate", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Associates a wireless gateway with a thing.
    public func associateWirelessGatewayWithThing(_ input: AssociateWirelessGatewayWithThingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateWirelessGatewayWithThingResponse> {
        return self.client.execute(operation: "AssociateWirelessGatewayWithThing", path: "/wireless-gateways/{Id}/thing", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Cancels an existing multicast group session.
    public func cancelMulticastGroupSession(_ input: CancelMulticastGroupSessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CancelMulticastGroupSessionResponse> {
        return self.client.execute(operation: "CancelMulticastGroupSession", path: "/multicast-groups/{Id}/session", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new destination that maps a device message to an AWS IoT rule.
    public func createDestination(_ input: CreateDestinationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDestinationResponse> {
        return self.client.execute(operation: "CreateDestination", path: "/destinations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new device profile.
    public func createDeviceProfile(_ input: CreateDeviceProfileRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDeviceProfileResponse> {
        return self.client.execute(operation: "CreateDeviceProfile", path: "/device-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a FUOTA task.
    public func createFuotaTask(_ input: CreateFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateFuotaTaskResponse> {
        return self.client.execute(operation: "CreateFuotaTask", path: "/fuota-tasks", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a multicast group.
    public func createMulticastGroup(_ input: CreateMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateMulticastGroupResponse> {
        return self.client.execute(operation: "CreateMulticastGroup", path: "/multicast-groups", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new network analyzer configuration.
    public func createNetworkAnalyzerConfiguration(_ input: CreateNetworkAnalyzerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateNetworkAnalyzerConfigurationResponse> {
        return self.client.execute(operation: "CreateNetworkAnalyzerConfiguration", path: "/network-analyzer-configurations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new service profile.
    public func createServiceProfile(_ input: CreateServiceProfileRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateServiceProfileResponse> {
        return self.client.execute(operation: "CreateServiceProfile", path: "/service-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provisions a wireless device.
    public func createWirelessDevice(_ input: CreateWirelessDeviceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateWirelessDeviceResponse> {
        return self.client.execute(operation: "CreateWirelessDevice", path: "/wireless-devices", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provisions a wireless gateway.
    public func createWirelessGateway(_ input: CreateWirelessGatewayRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateWirelessGatewayResponse> {
        return self.client.execute(operation: "CreateWirelessGateway", path: "/wireless-gateways", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a task for a wireless gateway.
    public func createWirelessGatewayTask(_ input: CreateWirelessGatewayTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateWirelessGatewayTaskResponse> {
        return self.client.execute(operation: "CreateWirelessGatewayTask", path: "/wireless-gateways/{Id}/tasks", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a gateway task definition.
    public func createWirelessGatewayTaskDefinition(_ input: CreateWirelessGatewayTaskDefinitionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateWirelessGatewayTaskDefinitionResponse> {
        return self.client.execute(operation: "CreateWirelessGatewayTaskDefinition", path: "/wireless-gateway-task-definitions", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a destination.
    public func deleteDestination(_ input: DeleteDestinationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDestinationResponse> {
        return self.client.execute(operation: "DeleteDestination", path: "/destinations/{Name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a device profile.
    public func deleteDeviceProfile(_ input: DeleteDeviceProfileRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDeviceProfileResponse> {
        return self.client.execute(operation: "DeleteDeviceProfile", path: "/device-profiles/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a FUOTA task.
    public func deleteFuotaTask(_ input: DeleteFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteFuotaTaskResponse> {
        return self.client.execute(operation: "DeleteFuotaTask", path: "/fuota-tasks/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a multicast group if it is not in use by a fuota task.
    public func deleteMulticastGroup(_ input: DeleteMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteMulticastGroupResponse> {
        return self.client.execute(operation: "DeleteMulticastGroup", path: "/multicast-groups/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a network analyzer configuration.
    public func deleteNetworkAnalyzerConfiguration(_ input: DeleteNetworkAnalyzerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteNetworkAnalyzerConfigurationResponse> {
        return self.client.execute(operation: "DeleteNetworkAnalyzerConfiguration", path: "/network-analyzer-configurations/{ConfigurationName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Remove queued messages from the downlink queue.
    public func deleteQueuedMessages(_ input: DeleteQueuedMessagesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteQueuedMessagesResponse> {
        return self.client.execute(operation: "DeleteQueuedMessages", path: "/wireless-devices/{Id}/data", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a service profile.
    public func deleteServiceProfile(_ input: DeleteServiceProfileRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteServiceProfileResponse> {
        return self.client.execute(operation: "DeleteServiceProfile", path: "/service-profiles/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a wireless device.
    public func deleteWirelessDevice(_ input: DeleteWirelessDeviceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteWirelessDeviceResponse> {
        return self.client.execute(operation: "DeleteWirelessDevice", path: "/wireless-devices/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a wireless gateway.
    public func deleteWirelessGateway(_ input: DeleteWirelessGatewayRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteWirelessGatewayResponse> {
        return self.client.execute(operation: "DeleteWirelessGateway", path: "/wireless-gateways/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a wireless gateway task.
    public func deleteWirelessGatewayTask(_ input: DeleteWirelessGatewayTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteWirelessGatewayTaskResponse> {
        return self.client.execute(operation: "DeleteWirelessGatewayTask", path: "/wireless-gateways/{Id}/tasks", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a wireless gateway task definition. Deleting this task definition does not affect tasks that are currently in progress.
    public func deleteWirelessGatewayTaskDefinition(_ input: DeleteWirelessGatewayTaskDefinitionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteWirelessGatewayTaskDefinitionResponse> {
        return self.client.execute(operation: "DeleteWirelessGatewayTaskDefinition", path: "/wireless-gateway-task-definitions/{Id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates your AWS account from a partner account. If PartnerAccountId and PartnerType are null, disassociates your AWS account from all partner accounts.
    public func disassociateAwsAccountFromPartnerAccount(_ input: DisassociateAwsAccountFromPartnerAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateAwsAccountFromPartnerAccountResponse> {
        return self.client.execute(operation: "DisassociateAwsAccountFromPartnerAccount", path: "/partner-accounts/{PartnerAccountId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates a multicast group from a fuota task.
    public func disassociateMulticastGroupFromFuotaTask(_ input: DisassociateMulticastGroupFromFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateMulticastGroupFromFuotaTaskResponse> {
        return self.client.execute(operation: "DisassociateMulticastGroupFromFuotaTask", path: "/fuota-tasks/{Id}/multicast-groups/{MulticastGroupId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates a wireless device from a FUOTA task.
    public func disassociateWirelessDeviceFromFuotaTask(_ input: DisassociateWirelessDeviceFromFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateWirelessDeviceFromFuotaTaskResponse> {
        return self.client.execute(operation: "DisassociateWirelessDeviceFromFuotaTask", path: "/fuota-tasks/{Id}/wireless-devices/{WirelessDeviceId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates a wireless device from a multicast group.
    public func disassociateWirelessDeviceFromMulticastGroup(_ input: DisassociateWirelessDeviceFromMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateWirelessDeviceFromMulticastGroupResponse> {
        return self.client.execute(operation: "DisassociateWirelessDeviceFromMulticastGroup", path: "/multicast-groups/{Id}/wireless-devices/{WirelessDeviceId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates a wireless device from its currently associated thing.
    public func disassociateWirelessDeviceFromThing(_ input: DisassociateWirelessDeviceFromThingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateWirelessDeviceFromThingResponse> {
        return self.client.execute(operation: "DisassociateWirelessDeviceFromThing", path: "/wireless-devices/{Id}/thing", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates a wireless gateway from its currently associated certificate.
    public func disassociateWirelessGatewayFromCertificate(_ input: DisassociateWirelessGatewayFromCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateWirelessGatewayFromCertificateResponse> {
        return self.client.execute(operation: "DisassociateWirelessGatewayFromCertificate", path: "/wireless-gateways/{Id}/certificate", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Disassociates a wireless gateway from its currently associated thing.
    public func disassociateWirelessGatewayFromThing(_ input: DisassociateWirelessGatewayFromThingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateWirelessGatewayFromThingResponse> {
        return self.client.execute(operation: "DisassociateWirelessGatewayFromThing", path: "/wireless-gateways/{Id}/thing", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a destination.
    public func getDestination(_ input: GetDestinationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDestinationResponse> {
        return self.client.execute(operation: "GetDestination", path: "/destinations/{Name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a device profile.
    public func getDeviceProfile(_ input: GetDeviceProfileRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDeviceProfileResponse> {
        return self.client.execute(operation: "GetDeviceProfile", path: "/device-profiles/{Id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get the event configuration based on resource types.
    public func getEventConfigurationByResourceTypes(_ input: GetEventConfigurationByResourceTypesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetEventConfigurationByResourceTypesResponse> {
        return self.client.execute(operation: "GetEventConfigurationByResourceTypes", path: "/event-configurations-resource-types", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a FUOTA task.
    public func getFuotaTask(_ input: GetFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetFuotaTaskResponse> {
        return self.client.execute(operation: "GetFuotaTask", path: "/fuota-tasks/{Id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns current default log levels or log levels by resource types. Based on resource types, log levels can be for wireless device log options or wireless gateway log options.
    public func getLogLevelsByResourceTypes(_ input: GetLogLevelsByResourceTypesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetLogLevelsByResourceTypesResponse> {
        return self.client.execute(operation: "GetLogLevelsByResourceTypes", path: "/log-levels", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a multicast group.
    public func getMulticastGroup(_ input: GetMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetMulticastGroupResponse> {
        return self.client.execute(operation: "GetMulticastGroup", path: "/multicast-groups/{Id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a multicast group session.
    public func getMulticastGroupSession(_ input: GetMulticastGroupSessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetMulticastGroupSessionResponse> {
        return self.client.execute(operation: "GetMulticastGroupSession", path: "/multicast-groups/{Id}/session", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get network analyzer configuration.
    public func getNetworkAnalyzerConfiguration(_ input: GetNetworkAnalyzerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetNetworkAnalyzerConfigurationResponse> {
        return self.client.execute(operation: "GetNetworkAnalyzerConfiguration", path: "/network-analyzer-configurations/{ConfigurationName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a partner account. If PartnerAccountId and PartnerType are null, returns all partner accounts.
    public func getPartnerAccount(_ input: GetPartnerAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPartnerAccountResponse> {
        return self.client.execute(operation: "GetPartnerAccount", path: "/partner-accounts/{PartnerAccountId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get the position information for a given resource.  This action is no longer supported. Calls to retrieve the position information should use the GetResourcePosition  API operation instead.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func getPosition(_ input: GetPositionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPositionResponse> {
        return self.client.execute(operation: "GetPosition", path: "/positions/{ResourceIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get position configuration for a given resource.  This action is no longer supported. Calls to retrieve the position configuration should use the GetResourcePosition  API operation instead.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func getPositionConfiguration(_ input: GetPositionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPositionConfigurationResponse> {
        return self.client.execute(operation: "GetPositionConfiguration", path: "/position-configurations/{ResourceIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get estimated position information as a payload in GeoJSON format. The payload measurement data is  resolved using solvers that are provided by third-party vendors.
    public func getPositionEstimate(_ input: GetPositionEstimateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPositionEstimateResponse> {
        return self.client.execute(operation: "GetPositionEstimate", path: "/position-estimate", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get the event configuration for a particular resource identifier.
    public func getResourceEventConfiguration(_ input: GetResourceEventConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetResourceEventConfigurationResponse> {
        return self.client.execute(operation: "GetResourceEventConfiguration", path: "/event-configurations/{Identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Fetches the log-level override, if any, for a given resource-ID and resource-type. It can be used for a wireless device or a wireless gateway.
    public func getResourceLogLevel(_ input: GetResourceLogLevelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetResourceLogLevelResponse> {
        return self.client.execute(operation: "GetResourceLogLevel", path: "/log-levels/{ResourceIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get the position information for a given wireless device or a wireless gateway resource. The postion information uses the  World Geodetic System (WGS84).
    public func getResourcePosition(_ input: GetResourcePositionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetResourcePositionResponse> {
        return self.client.execute(operation: "GetResourcePosition", path: "/resource-positions/{ResourceIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the account-specific endpoint for Configuration and Update Server (CUPS) protocol or LoRaWAN Network Server (LNS) connections.
    public func getServiceEndpoint(_ input: GetServiceEndpointRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetServiceEndpointResponse> {
        return self.client.execute(operation: "GetServiceEndpoint", path: "/service-endpoint", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a service profile.
    public func getServiceProfile(_ input: GetServiceProfileRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetServiceProfileResponse> {
        return self.client.execute(operation: "GetServiceProfile", path: "/service-profiles/{Id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a wireless device.
    public func getWirelessDevice(_ input: GetWirelessDeviceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessDeviceResponse> {
        return self.client.execute(operation: "GetWirelessDevice", path: "/wireless-devices/{Identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets operating information about a wireless device.
    public func getWirelessDeviceStatistics(_ input: GetWirelessDeviceStatisticsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessDeviceStatisticsResponse> {
        return self.client.execute(operation: "GetWirelessDeviceStatistics", path: "/wireless-devices/{WirelessDeviceId}/statistics", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a wireless gateway.
    public func getWirelessGateway(_ input: GetWirelessGatewayRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessGatewayResponse> {
        return self.client.execute(operation: "GetWirelessGateway", path: "/wireless-gateways/{Identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the ID of the certificate that is currently associated with a wireless gateway.
    public func getWirelessGatewayCertificate(_ input: GetWirelessGatewayCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessGatewayCertificateResponse> {
        return self.client.execute(operation: "GetWirelessGatewayCertificate", path: "/wireless-gateways/{Id}/certificate", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the firmware version and other information about a wireless gateway.
    public func getWirelessGatewayFirmwareInformation(_ input: GetWirelessGatewayFirmwareInformationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessGatewayFirmwareInformationResponse> {
        return self.client.execute(operation: "GetWirelessGatewayFirmwareInformation", path: "/wireless-gateways/{Id}/firmware-information", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets operating information about a wireless gateway.
    public func getWirelessGatewayStatistics(_ input: GetWirelessGatewayStatisticsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessGatewayStatisticsResponse> {
        return self.client.execute(operation: "GetWirelessGatewayStatistics", path: "/wireless-gateways/{WirelessGatewayId}/statistics", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a wireless gateway task.
    public func getWirelessGatewayTask(_ input: GetWirelessGatewayTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessGatewayTaskResponse> {
        return self.client.execute(operation: "GetWirelessGatewayTask", path: "/wireless-gateways/{Id}/tasks", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a wireless gateway task definition.
    public func getWirelessGatewayTaskDefinition(_ input: GetWirelessGatewayTaskDefinitionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWirelessGatewayTaskDefinitionResponse> {
        return self.client.execute(operation: "GetWirelessGatewayTaskDefinition", path: "/wireless-gateway-task-definitions/{Id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the destinations registered to your AWS account.
    public func listDestinations(_ input: ListDestinationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDestinationsResponse> {
        return self.client.execute(operation: "ListDestinations", path: "/destinations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the device profiles registered to your AWS account.
    public func listDeviceProfiles(_ input: ListDeviceProfilesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDeviceProfilesResponse> {
        return self.client.execute(operation: "ListDeviceProfiles", path: "/device-profiles", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List event configurations where at least one event topic has been enabled.
    public func listEventConfigurations(_ input: ListEventConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListEventConfigurationsResponse> {
        return self.client.execute(operation: "ListEventConfigurations", path: "/event-configurations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the FUOTA tasks registered to your AWS account.
    public func listFuotaTasks(_ input: ListFuotaTasksRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListFuotaTasksResponse> {
        return self.client.execute(operation: "ListFuotaTasks", path: "/fuota-tasks", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the multicast groups registered to your AWS account.
    public func listMulticastGroups(_ input: ListMulticastGroupsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMulticastGroupsResponse> {
        return self.client.execute(operation: "ListMulticastGroups", path: "/multicast-groups", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List all multicast groups associated with a fuota task.
    public func listMulticastGroupsByFuotaTask(_ input: ListMulticastGroupsByFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMulticastGroupsByFuotaTaskResponse> {
        return self.client.execute(operation: "ListMulticastGroupsByFuotaTask", path: "/fuota-tasks/{Id}/multicast-groups", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the network analyzer configurations.
    public func listNetworkAnalyzerConfigurations(_ input: ListNetworkAnalyzerConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListNetworkAnalyzerConfigurationsResponse> {
        return self.client.execute(operation: "ListNetworkAnalyzerConfigurations", path: "/network-analyzer-configurations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the partner accounts associated with your AWS account.
    public func listPartnerAccounts(_ input: ListPartnerAccountsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPartnerAccountsResponse> {
        return self.client.execute(operation: "ListPartnerAccounts", path: "/partner-accounts", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List position configurations for a given resource, such as positioning solvers.  This action is no longer supported. Calls to retrieve position information should use the GetResourcePosition  API operation instead.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func listPositionConfigurations(_ input: ListPositionConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPositionConfigurationsResponse> {
        return self.client.execute(operation: "ListPositionConfigurations", path: "/position-configurations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List queued messages in the downlink queue.
    public func listQueuedMessages(_ input: ListQueuedMessagesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListQueuedMessagesResponse> {
        return self.client.execute(operation: "ListQueuedMessages", path: "/wireless-devices/{Id}/data", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the service profiles registered to your AWS account.
    public func listServiceProfiles(_ input: ListServiceProfilesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListServiceProfilesResponse> {
        return self.client.execute(operation: "ListServiceProfiles", path: "/service-profiles", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the tags (metadata) you have assigned to the resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the wireless devices registered to your AWS account.
    public func listWirelessDevices(_ input: ListWirelessDevicesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListWirelessDevicesResponse> {
        return self.client.execute(operation: "ListWirelessDevices", path: "/wireless-devices", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the wireless gateway tasks definitions registered to your AWS account.
    public func listWirelessGatewayTaskDefinitions(_ input: ListWirelessGatewayTaskDefinitionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListWirelessGatewayTaskDefinitionsResponse> {
        return self.client.execute(operation: "ListWirelessGatewayTaskDefinitions", path: "/wireless-gateway-task-definitions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the wireless gateways registered to your AWS account.
    public func listWirelessGateways(_ input: ListWirelessGatewaysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListWirelessGatewaysResponse> {
        return self.client.execute(operation: "ListWirelessGateways", path: "/wireless-gateways", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Put position configuration for a given resource.  This action is no longer supported. Calls to update the position configuration should use the UpdateResourcePosition API operation instead.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func putPositionConfiguration(_ input: PutPositionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutPositionConfigurationResponse> {
        return self.client.execute(operation: "PutPositionConfiguration", path: "/position-configurations/{ResourceIdentifier}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Sets the log-level override for a resource-ID and resource-type. This option can be specified for a wireless gateway  or a wireless device. A limit of 200 log level override can be set per account.
    public func putResourceLogLevel(_ input: PutResourceLogLevelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutResourceLogLevelResponse> {
        return self.client.execute(operation: "PutResourceLogLevel", path: "/log-levels/{ResourceIdentifier}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes the log-level overrides for all resources; both wireless devices and wireless gateways.
    public func resetAllResourceLogLevels(_ input: ResetAllResourceLogLevelsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ResetAllResourceLogLevelsResponse> {
        return self.client.execute(operation: "ResetAllResourceLogLevels", path: "/log-levels", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes the log-level override, if any, for a specific resource-ID and resource-type. It can be used for a wireless device or a wireless gateway.
    public func resetResourceLogLevel(_ input: ResetResourceLogLevelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ResetResourceLogLevelResponse> {
        return self.client.execute(operation: "ResetResourceLogLevel", path: "/log-levels/{ResourceIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Sends the specified data to a multicast group.
    public func sendDataToMulticastGroup(_ input: SendDataToMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SendDataToMulticastGroupResponse> {
        return self.client.execute(operation: "SendDataToMulticastGroup", path: "/multicast-groups/{Id}/data", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Sends a decrypted application data frame to a device.
    public func sendDataToWirelessDevice(_ input: SendDataToWirelessDeviceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SendDataToWirelessDeviceResponse> {
        return self.client.execute(operation: "SendDataToWirelessDevice", path: "/wireless-devices/{Id}/data", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Starts a bulk association of all qualifying wireless devices with a multicast group.
    public func startBulkAssociateWirelessDeviceWithMulticastGroup(_ input: StartBulkAssociateWirelessDeviceWithMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartBulkAssociateWirelessDeviceWithMulticastGroupResponse> {
        return self.client.execute(operation: "StartBulkAssociateWirelessDeviceWithMulticastGroup", path: "/multicast-groups/{Id}/bulk", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Starts a bulk disassociatin of all qualifying wireless devices from a multicast group.
    public func startBulkDisassociateWirelessDeviceFromMulticastGroup(_ input: StartBulkDisassociateWirelessDeviceFromMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartBulkDisassociateWirelessDeviceFromMulticastGroupResponse> {
        return self.client.execute(operation: "StartBulkDisassociateWirelessDeviceFromMulticastGroup", path: "/multicast-groups/{Id}/bulk", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Starts a FUOTA task.
    public func startFuotaTask(_ input: StartFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartFuotaTaskResponse> {
        return self.client.execute(operation: "StartFuotaTask", path: "/fuota-tasks/{Id}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Starts a multicast group session.
    public func startMulticastGroupSession(_ input: StartMulticastGroupSessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartMulticastGroupSessionResponse> {
        return self.client.execute(operation: "StartMulticastGroupSession", path: "/multicast-groups/{Id}/session", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a tag to a resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/tags", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Simulates a provisioned device by sending an uplink data payload of Hello.
    public func testWirelessDevice(_ input: TestWirelessDeviceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TestWirelessDeviceResponse> {
        return self.client.execute(operation: "TestWirelessDevice", path: "/wireless-devices/{Id}/test", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes one or more tags from a resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/tags", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates properties of a destination.
    public func updateDestination(_ input: UpdateDestinationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDestinationResponse> {
        return self.client.execute(operation: "UpdateDestination", path: "/destinations/{Name}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the event configuration based on resource types.
    public func updateEventConfigurationByResourceTypes(_ input: UpdateEventConfigurationByResourceTypesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateEventConfigurationByResourceTypesResponse> {
        return self.client.execute(operation: "UpdateEventConfigurationByResourceTypes", path: "/event-configurations-resource-types", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates properties of a FUOTA task.
    public func updateFuotaTask(_ input: UpdateFuotaTaskRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateFuotaTaskResponse> {
        return self.client.execute(operation: "UpdateFuotaTask", path: "/fuota-tasks/{Id}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Set default log level, or log levels by resource types. This can be for wireless device log options or wireless gateways log options and is used to control the log messages that'll be displayed in CloudWatch.
    public func updateLogLevelsByResourceTypes(_ input: UpdateLogLevelsByResourceTypesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateLogLevelsByResourceTypesResponse> {
        return self.client.execute(operation: "UpdateLogLevelsByResourceTypes", path: "/log-levels", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates properties of a multicast group session.
    public func updateMulticastGroup(_ input: UpdateMulticastGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateMulticastGroupResponse> {
        return self.client.execute(operation: "UpdateMulticastGroup", path: "/multicast-groups/{Id}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update network analyzer configuration.
    public func updateNetworkAnalyzerConfiguration(_ input: UpdateNetworkAnalyzerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateNetworkAnalyzerConfigurationResponse> {
        return self.client.execute(operation: "UpdateNetworkAnalyzerConfiguration", path: "/network-analyzer-configurations/{ConfigurationName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates properties of a partner account.
    public func updatePartnerAccount(_ input: UpdatePartnerAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdatePartnerAccountResponse> {
        return self.client.execute(operation: "UpdatePartnerAccount", path: "/partner-accounts/{PartnerAccountId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the position information of a resource.  This action is no longer supported. Calls to update the position information should use the UpdateResourcePosition API operation instead.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func updatePosition(_ input: UpdatePositionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdatePositionResponse> {
        return self.client.execute(operation: "UpdatePosition", path: "/positions/{ResourceIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the event configuration for a particular resource identifier.
    public func updateResourceEventConfiguration(_ input: UpdateResourceEventConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateResourceEventConfigurationResponse> {
        return self.client.execute(operation: "UpdateResourceEventConfiguration", path: "/event-configurations/{Identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the position information of a given wireless device or a wireless gateway resource. The postion coordinates are based on the  World Geodetic System (WGS84).
    public func updateResourcePosition(_ input: UpdateResourcePositionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateResourcePositionResponse> {
        return self.client.execute(operation: "UpdateResourcePosition", path: "/resource-positions/{ResourceIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates properties of a wireless device.
    public func updateWirelessDevice(_ input: UpdateWirelessDeviceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateWirelessDeviceResponse> {
        return self.client.execute(operation: "UpdateWirelessDevice", path: "/wireless-devices/{Id}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates properties of a wireless gateway.
    public func updateWirelessGateway(_ input: UpdateWirelessGatewayRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateWirelessGatewayResponse> {
        return self.client.execute(operation: "UpdateWirelessGateway", path: "/wireless-gateways/{Id}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension IoTWireless {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: IoTWireless, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension IoTWireless {
    ///  Lists the destinations registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDestinationsPaginator<Result>(
        _ input: ListDestinationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDestinationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDestinations,
            inputKey: \ListDestinationsRequest.nextToken,
            outputKey: \ListDestinationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDestinationsPaginator(
        _ input: ListDestinationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDestinationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDestinations,
            inputKey: \ListDestinationsRequest.nextToken,
            outputKey: \ListDestinationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the device profiles registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDeviceProfilesPaginator<Result>(
        _ input: ListDeviceProfilesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDeviceProfilesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDeviceProfiles,
            inputKey: \ListDeviceProfilesRequest.nextToken,
            outputKey: \ListDeviceProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDeviceProfilesPaginator(
        _ input: ListDeviceProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDeviceProfilesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDeviceProfiles,
            inputKey: \ListDeviceProfilesRequest.nextToken,
            outputKey: \ListDeviceProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the FUOTA tasks registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listFuotaTasksPaginator<Result>(
        _ input: ListFuotaTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListFuotaTasksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listFuotaTasks,
            inputKey: \ListFuotaTasksRequest.nextToken,
            outputKey: \ListFuotaTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listFuotaTasksPaginator(
        _ input: ListFuotaTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListFuotaTasksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listFuotaTasks,
            inputKey: \ListFuotaTasksRequest.nextToken,
            outputKey: \ListFuotaTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the multicast groups registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMulticastGroupsPaginator<Result>(
        _ input: ListMulticastGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMulticastGroupsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listMulticastGroups,
            inputKey: \ListMulticastGroupsRequest.nextToken,
            outputKey: \ListMulticastGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMulticastGroupsPaginator(
        _ input: ListMulticastGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMulticastGroupsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listMulticastGroups,
            inputKey: \ListMulticastGroupsRequest.nextToken,
            outputKey: \ListMulticastGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List all multicast groups associated with a fuota task.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMulticastGroupsByFuotaTaskPaginator<Result>(
        _ input: ListMulticastGroupsByFuotaTaskRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMulticastGroupsByFuotaTaskResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listMulticastGroupsByFuotaTask,
            inputKey: \ListMulticastGroupsByFuotaTaskRequest.nextToken,
            outputKey: \ListMulticastGroupsByFuotaTaskResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMulticastGroupsByFuotaTaskPaginator(
        _ input: ListMulticastGroupsByFuotaTaskRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMulticastGroupsByFuotaTaskResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listMulticastGroupsByFuotaTask,
            inputKey: \ListMulticastGroupsByFuotaTaskRequest.nextToken,
            outputKey: \ListMulticastGroupsByFuotaTaskResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the network analyzer configurations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listNetworkAnalyzerConfigurationsPaginator<Result>(
        _ input: ListNetworkAnalyzerConfigurationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListNetworkAnalyzerConfigurationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listNetworkAnalyzerConfigurations,
            inputKey: \ListNetworkAnalyzerConfigurationsRequest.nextToken,
            outputKey: \ListNetworkAnalyzerConfigurationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listNetworkAnalyzerConfigurationsPaginator(
        _ input: ListNetworkAnalyzerConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListNetworkAnalyzerConfigurationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listNetworkAnalyzerConfigurations,
            inputKey: \ListNetworkAnalyzerConfigurationsRequest.nextToken,
            outputKey: \ListNetworkAnalyzerConfigurationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List position configurations for a given resource, such as positioning solvers.  This action is no longer supported. Calls to retrieve position information should use the GetResourcePosition  API operation instead.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func listPositionConfigurationsPaginator<Result>(
        _ input: ListPositionConfigurationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPositionConfigurationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listPositionConfigurations,
            inputKey: \ListPositionConfigurationsRequest.nextToken,
            outputKey: \ListPositionConfigurationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    @available(*, deprecated, message: "This operation is no longer supported.")
    public func listPositionConfigurationsPaginator(
        _ input: ListPositionConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPositionConfigurationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listPositionConfigurations,
            inputKey: \ListPositionConfigurationsRequest.nextToken,
            outputKey: \ListPositionConfigurationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List queued messages in the downlink queue.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listQueuedMessagesPaginator<Result>(
        _ input: ListQueuedMessagesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListQueuedMessagesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listQueuedMessages,
            inputKey: \ListQueuedMessagesRequest.nextToken,
            outputKey: \ListQueuedMessagesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listQueuedMessagesPaginator(
        _ input: ListQueuedMessagesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListQueuedMessagesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listQueuedMessages,
            inputKey: \ListQueuedMessagesRequest.nextToken,
            outputKey: \ListQueuedMessagesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the service profiles registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listServiceProfilesPaginator<Result>(
        _ input: ListServiceProfilesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListServiceProfilesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listServiceProfiles,
            inputKey: \ListServiceProfilesRequest.nextToken,
            outputKey: \ListServiceProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listServiceProfilesPaginator(
        _ input: ListServiceProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListServiceProfilesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listServiceProfiles,
            inputKey: \ListServiceProfilesRequest.nextToken,
            outputKey: \ListServiceProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the wireless devices registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listWirelessDevicesPaginator<Result>(
        _ input: ListWirelessDevicesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListWirelessDevicesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listWirelessDevices,
            inputKey: \ListWirelessDevicesRequest.nextToken,
            outputKey: \ListWirelessDevicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listWirelessDevicesPaginator(
        _ input: ListWirelessDevicesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListWirelessDevicesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listWirelessDevices,
            inputKey: \ListWirelessDevicesRequest.nextToken,
            outputKey: \ListWirelessDevicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the wireless gateways registered to your AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listWirelessGatewaysPaginator<Result>(
        _ input: ListWirelessGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListWirelessGatewaysResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listWirelessGateways,
            inputKey: \ListWirelessGatewaysRequest.nextToken,
            outputKey: \ListWirelessGatewaysResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listWirelessGatewaysPaginator(
        _ input: ListWirelessGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListWirelessGatewaysResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listWirelessGateways,
            inputKey: \ListWirelessGatewaysRequest.nextToken,
            outputKey: \ListWirelessGatewaysResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension IoTWireless.ListDestinationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListDestinationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListDeviceProfilesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListDeviceProfilesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListFuotaTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListFuotaTasksRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListMulticastGroupsByFuotaTaskRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListMulticastGroupsByFuotaTaskRequest {
        return .init(
            id: self.id,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListMulticastGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListMulticastGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListNetworkAnalyzerConfigurationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListNetworkAnalyzerConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListPositionConfigurationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListPositionConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )
    }
}

extension IoTWireless.ListQueuedMessagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListQueuedMessagesRequest {
        return .init(
            id: self.id,
            maxResults: self.maxResults,
            nextToken: token,
            wirelessDeviceType: self.wirelessDeviceType
        )
    }
}

extension IoTWireless.ListServiceProfilesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListServiceProfilesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTWireless.ListWirelessDevicesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListWirelessDevicesRequest {
        return .init(
            destinationName: self.destinationName,
            deviceProfileId: self.deviceProfileId,
            fuotaTaskId: self.fuotaTaskId,
            maxResults: self.maxResults,
            multicastGroupId: self.multicastGroupId,
            nextToken: token,
            serviceProfileId: self.serviceProfileId,
            wirelessDeviceType: self.wirelessDeviceType
        )
    }
}

extension IoTWireless.ListWirelessGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoTWireless.ListWirelessGatewaysRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
