//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS SupplyChain service.
///
///  AWS Supply Chain is a cloud-based application that works with your enterprise resource planning (ERP) and supply chain management systems. Using AWS Supply Chain, you can connect and extract your inventory, supply, and demand related data from existing ERP or supply chain systems into a single data model.  The AWS Supply Chain API supports configuration data import for Supply Planning.  All AWS Supply chain API operations are Amazon-authenticated and certificate-signed. They not only require the use of the AWS SDK, but also allow for the exclusive use of AWS Identity and Access Management users and roles to help facilitate access, trust, and permission policies.
public struct SupplyChain: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the SupplyChain client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "SupplyChain",
            serviceIdentifier: "scn",
            serviceProtocol: .restjson,
            apiVersion: "2024-01-01",
            endpoint: endpoint,
            errorType: SupplyChainErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// CreateBillOfMaterialsImportJob creates an import job for the Product Bill Of Materials (BOM) entity. For information on the product_bom entity, see the AWS Supply Chain User Guide. The CSV file must be located in an Amazon S3 location accessible to AWS Supply Chain. It is recommended to use the same Amazon S3 bucket created during your AWS Supply Chain instance creation.
    @Sendable
    @inlinable
    public func createBillOfMaterialsImportJob(_ input: CreateBillOfMaterialsImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBillOfMaterialsImportJobResponse {
        try await self.client.execute(
            operation: "CreateBillOfMaterialsImportJob", 
            path: "/api/configuration/instances/{instanceId}/bill-of-materials-import-jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// CreateBillOfMaterialsImportJob creates an import job for the Product Bill Of Materials (BOM) entity. For information on the product_bom entity, see the AWS Supply Chain User Guide. The CSV file must be located in an Amazon S3 location accessible to AWS Supply Chain. It is recommended to use the same Amazon S3 bucket created during your AWS Supply Chain instance creation.
    ///
    /// Parameters:
    ///   - clientToken: An idempotency token ensures the API request is only completed no more than once. This way, retrying the request will not trigger the operation multiple times. A client token is a unique, case-sensitive string of 33 to 128 ASCII characters. To make an idempotent API request, specify a client token in the request. You should not reuse the same client token for other requests. If you retry a successful request with the same client token, the request will succeed with no further actions being taken, and you will receive the same API response as the original successful request.
    ///   - instanceId: The AWS Supply Chain instance identifier.
    ///   - s3uri: The S3 URI of the CSV file to be imported. The bucket must grant permissions for AWS Supply Chain to read the file.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBillOfMaterialsImportJob(
        clientToken: String? = CreateBillOfMaterialsImportJobRequest.idempotencyToken(),
        instanceId: String,
        s3uri: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBillOfMaterialsImportJobResponse {
        let input = CreateBillOfMaterialsImportJobRequest(
            clientToken: clientToken, 
            instanceId: instanceId, 
            s3uri: s3uri
        )
        return try await self.createBillOfMaterialsImportJob(input, logger: logger)
    }

    /// Enables you to programmatically create a data pipeline to ingest data from source systems such as Amazon S3 buckets, to a predefined Amazon Web Services Supply Chain dataset (product, inbound_order) or a temporary dataset along with the data transformation query provided with the API.
    @Sendable
    @inlinable
    public func createDataIntegrationFlow(_ input: CreateDataIntegrationFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataIntegrationFlowResponse {
        try await self.client.execute(
            operation: "CreateDataIntegrationFlow", 
            path: "/api/data-integration/instance/{instanceId}/data-integration-flows/{name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically create a data pipeline to ingest data from source systems such as Amazon S3 buckets, to a predefined Amazon Web Services Supply Chain dataset (product, inbound_order) or a temporary dataset along with the data transformation query provided with the API.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - name: Name of the DataIntegrationFlow.
    ///   - sources: The source configurations for DataIntegrationFlow.
    ///   - tags: The tags of the DataIntegrationFlow to be created
    ///   - target: The target configurations for DataIntegrationFlow.
    ///   - transformation: The transformation configurations for DataIntegrationFlow.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataIntegrationFlow(
        instanceId: String,
        name: String,
        sources: [DataIntegrationFlowSource],
        tags: [String: String]? = nil,
        target: DataIntegrationFlowTarget,
        transformation: DataIntegrationFlowTransformation,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDataIntegrationFlowResponse {
        let input = CreateDataIntegrationFlowRequest(
            instanceId: instanceId, 
            name: name, 
            sources: sources, 
            tags: tags, 
            target: target, 
            transformation: transformation
        )
        return try await self.createDataIntegrationFlow(input, logger: logger)
    }

    /// Enables you to programmatically create an Amazon Web Services Supply Chain data lake dataset. Developers can create the datasets using their pre-defined or custom schema for a given instance ID, namespace, and dataset name.
    @Sendable
    @inlinable
    public func createDataLakeDataset(_ input: CreateDataLakeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataLakeDatasetResponse {
        try await self.client.execute(
            operation: "CreateDataLakeDataset", 
            path: "/api/datalake/instance/{instanceId}/namespaces/{namespace}/datasets/{name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically create an Amazon Web Services Supply Chain data lake dataset. Developers can create the datasets using their pre-defined or custom schema for a given instance ID, namespace, and dataset name.
    ///
    /// Parameters:
    ///   - description: The description of the dataset.
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - name: The name of the dataset. For asc name space, the name must be one of the supported data entities under https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.
    ///   - namespace: The name space of the dataset.    asc - For information on the  Amazon Web Services Supply Chain supported datasets see https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.    default - For datasets with custom user-defined schemas.
    ///   - schema: The custom schema of the data lake dataset and is only required when the name space is default.
    ///   - tags: The tags of the dataset.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataLakeDataset(
        description: String? = nil,
        instanceId: String,
        name: String,
        namespace: String,
        schema: DataLakeDatasetSchema? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDataLakeDatasetResponse {
        let input = CreateDataLakeDatasetRequest(
            description: description, 
            instanceId: instanceId, 
            name: name, 
            namespace: namespace, 
            schema: schema, 
            tags: tags
        )
        return try await self.createDataLakeDataset(input, logger: logger)
    }

    /// Enables you to programmatically create an Amazon Web Services Supply Chain instance by applying KMS keys and relevant information associated with the API without using the Amazon Web Services console. This is an asynchronous operation. Upon receiving a CreateInstance request, Amazon Web Services Supply Chain immediately returns the instance resource, instance ID, and the initializing state while simultaneously creating all required Amazon Web Services resources for an instance creation. You can use GetInstance to check the status of the instance. If the instance results in an unhealthy state, you need to check the error message, delete the current instance, and recreate a new one based on the mitigation from the error message.
    @Sendable
    @inlinable
    public func createInstance(_ input: CreateInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInstanceResponse {
        try await self.client.execute(
            operation: "CreateInstance", 
            path: "/api/instance", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically create an Amazon Web Services Supply Chain instance by applying KMS keys and relevant information associated with the API without using the Amazon Web Services console. This is an asynchronous operation. Upon receiving a CreateInstance request, Amazon Web Services Supply Chain immediately returns the instance resource, instance ID, and the initializing state while simultaneously creating all required Amazon Web Services resources for an instance creation. You can use GetInstance to check the status of the instance. If the instance results in an unhealthy state, you need to check the error message, delete the current instance, and recreate a new one based on the mitigation from the error message.
    ///
    /// Parameters:
    ///   - clientToken: The client token for idempotency.
    ///   - instanceDescription: The AWS Supply Chain instance description.
    ///   - instanceName: The AWS Supply Chain instance name.
    ///   - kmsKeyArn: The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon Web Services owned KMS key. If you don't provide anything here, AWS Supply Chain uses the Amazon Web Services owned KMS key.
    ///   - tags: The Amazon Web Services tags of an instance to be created.
    ///   - webAppDnsDomain: The DNS subdomain of the web app. This would be "example" in the URL "example.scn.global.on.aws". You can set this to a custom value, as long as the domain isn't already being used by someone else. The name may only include alphanumeric characters and hyphens.
    ///   - logger: Logger use during operation
    @inlinable
    public func createInstance(
        clientToken: String? = CreateInstanceRequest.idempotencyToken(),
        instanceDescription: String? = nil,
        instanceName: String? = nil,
        kmsKeyArn: String? = nil,
        tags: [String: String]? = nil,
        webAppDnsDomain: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateInstanceResponse {
        let input = CreateInstanceRequest(
            clientToken: clientToken, 
            instanceDescription: instanceDescription, 
            instanceName: instanceName, 
            kmsKeyArn: kmsKeyArn, 
            tags: tags, 
            webAppDnsDomain: webAppDnsDomain
        )
        return try await self.createInstance(input, logger: logger)
    }

    /// Enable you to programmatically delete an existing data pipeline for the provided Amazon Web Services Supply Chain instance and DataIntegrationFlow name.
    @Sendable
    @inlinable
    public func deleteDataIntegrationFlow(_ input: DeleteDataIntegrationFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDataIntegrationFlowResponse {
        try await self.client.execute(
            operation: "DeleteDataIntegrationFlow", 
            path: "/api/data-integration/instance/{instanceId}/data-integration-flows/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enable you to programmatically delete an existing data pipeline for the provided Amazon Web Services Supply Chain instance and DataIntegrationFlow name.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - name: The name of the DataIntegrationFlow to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataIntegrationFlow(
        instanceId: String,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDataIntegrationFlowResponse {
        let input = DeleteDataIntegrationFlowRequest(
            instanceId: instanceId, 
            name: name
        )
        return try await self.deleteDataIntegrationFlow(input, logger: logger)
    }

    /// Enables you to programmatically delete an Amazon Web Services Supply Chain data lake dataset. Developers can delete the existing datasets for a given instance ID, namespace, and instance name.
    @Sendable
    @inlinable
    public func deleteDataLakeDataset(_ input: DeleteDataLakeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDataLakeDatasetResponse {
        try await self.client.execute(
            operation: "DeleteDataLakeDataset", 
            path: "/api/datalake/instance/{instanceId}/namespaces/{namespace}/datasets/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically delete an Amazon Web Services Supply Chain data lake dataset. Developers can delete the existing datasets for a given instance ID, namespace, and instance name.
    ///
    /// Parameters:
    ///   - instanceId: The AWS Supply Chain instance identifier.
    ///   - name: The name of the dataset. For asc name space, the name must be one of the supported data entities under https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.
    ///   - namespace: The name space of the dataset. The available values are:    asc - For information on the  Amazon Web Services Supply Chain supported datasets see https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.    default - For datasets with custom user-defined schemas.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataLakeDataset(
        instanceId: String,
        name: String,
        namespace: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDataLakeDatasetResponse {
        let input = DeleteDataLakeDatasetRequest(
            instanceId: instanceId, 
            name: name, 
            namespace: namespace
        )
        return try await self.deleteDataLakeDataset(input, logger: logger)
    }

    /// Enables you to programmatically delete an Amazon Web Services Supply Chain instance by deleting the KMS keys and relevant information associated with the API without using the Amazon Web Services console. This is an asynchronous operation. Upon receiving a DeleteInstance request, Amazon Web Services Supply Chain immediately returns a response with the instance resource, delete state while cleaning up all Amazon Web Services resources created during the instance creation process. You can use the GetInstance action to check the instance status.
    @Sendable
    @inlinable
    public func deleteInstance(_ input: DeleteInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInstanceResponse {
        try await self.client.execute(
            operation: "DeleteInstance", 
            path: "/api/instance/{instanceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically delete an Amazon Web Services Supply Chain instance by deleting the KMS keys and relevant information associated with the API without using the Amazon Web Services console. This is an asynchronous operation. Upon receiving a DeleteInstance request, Amazon Web Services Supply Chain immediately returns a response with the instance resource, delete state while cleaning up all Amazon Web Services resources created during the instance creation process. You can use the GetInstance action to check the instance status.
    ///
    /// Parameters:
    ///   - instanceId: The AWS Supply Chain instance identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteInstance(
        instanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteInstanceResponse {
        let input = DeleteInstanceRequest(
            instanceId: instanceId
        )
        return try await self.deleteInstance(input, logger: logger)
    }

    /// Get status and details of a BillOfMaterialsImportJob.
    @Sendable
    @inlinable
    public func getBillOfMaterialsImportJob(_ input: GetBillOfMaterialsImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBillOfMaterialsImportJobResponse {
        try await self.client.execute(
            operation: "GetBillOfMaterialsImportJob", 
            path: "/api/configuration/instances/{instanceId}/bill-of-materials-import-jobs/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get status and details of a BillOfMaterialsImportJob.
    ///
    /// Parameters:
    ///   - instanceId: The AWS Supply Chain instance identifier.
    ///   - jobId: The BillOfMaterialsImportJob identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBillOfMaterialsImportJob(
        instanceId: String,
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBillOfMaterialsImportJobResponse {
        let input = GetBillOfMaterialsImportJobRequest(
            instanceId: instanceId, 
            jobId: jobId
        )
        return try await self.getBillOfMaterialsImportJob(input, logger: logger)
    }

    /// Enables you to programmatically view a specific data pipeline for the provided Amazon Web Services Supply Chain instance and DataIntegrationFlow name.
    @Sendable
    @inlinable
    public func getDataIntegrationFlow(_ input: GetDataIntegrationFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataIntegrationFlowResponse {
        try await self.client.execute(
            operation: "GetDataIntegrationFlow", 
            path: "/api/data-integration/instance/{instanceId}/data-integration-flows/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically view a specific data pipeline for the provided Amazon Web Services Supply Chain instance and DataIntegrationFlow name.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - name: The name of the DataIntegrationFlow created.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataIntegrationFlow(
        instanceId: String,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataIntegrationFlowResponse {
        let input = GetDataIntegrationFlowRequest(
            instanceId: instanceId, 
            name: name
        )
        return try await self.getDataIntegrationFlow(input, logger: logger)
    }

    /// Enables you to programmatically view an Amazon Web Services Supply Chain data lake dataset. Developers can view the data lake dataset information such as namespace, schema, and so on for a given instance ID, namespace, and dataset name.
    @Sendable
    @inlinable
    public func getDataLakeDataset(_ input: GetDataLakeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataLakeDatasetResponse {
        try await self.client.execute(
            operation: "GetDataLakeDataset", 
            path: "/api/datalake/instance/{instanceId}/namespaces/{namespace}/datasets/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically view an Amazon Web Services Supply Chain data lake dataset. Developers can view the data lake dataset information such as namespace, schema, and so on for a given instance ID, namespace, and dataset name.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - name: The name of the dataset. For asc name space, the name must be one of the supported data entities under https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.
    ///   - namespace: The name space of the dataset. The available values are:    asc - For information on the  Amazon Web Services Supply Chain supported datasets see https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.    default - For datasets with custom user-defined schemas.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataLakeDataset(
        instanceId: String,
        name: String,
        namespace: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataLakeDatasetResponse {
        let input = GetDataLakeDatasetRequest(
            instanceId: instanceId, 
            name: name, 
            namespace: namespace
        )
        return try await self.getDataLakeDataset(input, logger: logger)
    }

    /// Enables you to programmatically retrieve the information related to an Amazon Web Services Supply Chain instance ID.
    @Sendable
    @inlinable
    public func getInstance(_ input: GetInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetInstanceResponse {
        try await self.client.execute(
            operation: "GetInstance", 
            path: "/api/instance/{instanceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically retrieve the information related to an Amazon Web Services Supply Chain instance ID.
    ///
    /// Parameters:
    ///   - instanceId: The AWS Supply Chain instance identifier
    ///   - logger: Logger use during operation
    @inlinable
    public func getInstance(
        instanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetInstanceResponse {
        let input = GetInstanceRequest(
            instanceId: instanceId
        )
        return try await self.getInstance(input, logger: logger)
    }

    /// Enables you to programmatically list all data pipelines for the provided Amazon Web Services Supply Chain instance.
    @Sendable
    @inlinable
    public func listDataIntegrationFlows(_ input: ListDataIntegrationFlowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataIntegrationFlowsResponse {
        try await self.client.execute(
            operation: "ListDataIntegrationFlows", 
            path: "/api/data-integration/instance/{instanceId}/data-integration-flows", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically list all data pipelines for the provided Amazon Web Services Supply Chain instance.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - maxResults: Specify the maximum number of DataIntegrationFlows to fetch in one paginated request.
    ///   - nextToken: The pagination token to fetch the next page of the DataIntegrationFlows.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataIntegrationFlows(
        instanceId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataIntegrationFlowsResponse {
        let input = ListDataIntegrationFlowsRequest(
            instanceId: instanceId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDataIntegrationFlows(input, logger: logger)
    }

    /// Enables you to programmatically view the list of Amazon Web Services Supply Chain data lake datasets. Developers can view the datasets and the corresponding information such as namespace, schema, and so on for a given instance ID and namespace.
    @Sendable
    @inlinable
    public func listDataLakeDatasets(_ input: ListDataLakeDatasetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataLakeDatasetsResponse {
        try await self.client.execute(
            operation: "ListDataLakeDatasets", 
            path: "/api/datalake/instance/{instanceId}/namespaces/{namespace}/datasets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically view the list of Amazon Web Services Supply Chain data lake datasets. Developers can view the datasets and the corresponding information such as namespace, schema, and so on for a given instance ID and namespace.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - maxResults: The max number of datasets to fetch in this paginated request.
    ///   - namespace: The name space of the dataset. The available values are:    asc - For information on the  Amazon Web Services Supply Chain supported datasets see https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.    default - For datasets with custom user-defined schemas.
    ///   - nextToken: The pagination token to fetch next page of datasets.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataLakeDatasets(
        instanceId: String,
        maxResults: Int? = nil,
        namespace: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataLakeDatasetsResponse {
        let input = ListDataLakeDatasetsRequest(
            instanceId: instanceId, 
            maxResults: maxResults, 
            namespace: namespace, 
            nextToken: nextToken
        )
        return try await self.listDataLakeDatasets(input, logger: logger)
    }

    /// List all Amazon Web Services Supply Chain instances for a specific account. Enables you to programmatically list all Amazon Web Services Supply Chain instances based on their account ID, instance name, and state of the instance (active or delete).
    @Sendable
    @inlinable
    public func listInstances(_ input: ListInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInstancesResponse {
        try await self.client.execute(
            operation: "ListInstances", 
            path: "/api/instance", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all Amazon Web Services Supply Chain instances for a specific account. Enables you to programmatically list all Amazon Web Services Supply Chain instances based on their account ID, instance name, and state of the instance (active or delete).
    ///
    /// Parameters:
    ///   - instanceNameFilter: The filter to ListInstances based on their names.
    ///   - instanceStateFilter: The filter to ListInstances based on their state.
    ///   - maxResults: Specify the maximum number of instances to fetch in this paginated request.
    ///   - nextToken: The pagination token to fetch the next page of instances.
    ///   - logger: Logger use during operation
    @inlinable
    public func listInstances(
        instanceNameFilter: [String]? = nil,
        instanceStateFilter: [InstanceState]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInstancesResponse {
        let input = ListInstancesRequest(
            instanceNameFilter: instanceNameFilter, 
            instanceStateFilter: instanceStateFilter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listInstances(input, logger: logger)
    }

    /// List all the tags for an Amazon Web ServicesSupply Chain resource. You can list all the tags added to a resource. By listing the tags, developers can view the tag level information on a resource and perform actions such as, deleting a resource associated with a particular tag.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/api/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all the tags for an Amazon Web ServicesSupply Chain resource. You can list all the tags added to a resource. By listing the tags, developers can view the tag level information on a resource and perform actions such as, deleting a resource associated with a particular tag.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Web Services Supply chain resource ARN that needs tags to be listed.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Send the transactional data payload for the event with real-time data for analysis or monitoring. The real-time data events are stored in an Amazon Web Services service before being processed and stored in data lake. New data events are synced with data lake at 5 PM GMT everyday. The updated transactional data is available in data lake after ingestion.
    @Sendable
    @inlinable
    public func sendDataIntegrationEvent(_ input: SendDataIntegrationEventRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SendDataIntegrationEventResponse {
        try await self.client.execute(
            operation: "SendDataIntegrationEvent", 
            path: "/api-data/data-integration/instance/{instanceId}/data-integration-events", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Send the transactional data payload for the event with real-time data for analysis or monitoring. The real-time data events are stored in an Amazon Web Services service before being processed and stored in data lake. New data events are synced with data lake at 5 PM GMT everyday. The updated transactional data is available in data lake after ingestion.
    ///
    /// Parameters:
    ///   - clientToken: The idempotent client token.
    ///   - data: The data payload of the event. For more information on the data schema to use, see Data entities supported in AWS Supply Chain.
    ///   - eventGroupId: Event identifier (for example, orderId for InboundOrder) used for data sharing or partitioning.
    ///   - eventTimestamp: The event timestamp (in epoch seconds).
    ///   - eventType: The data event type.
    ///   - instanceId: The AWS Supply Chain instance identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func sendDataIntegrationEvent(
        clientToken: String? = SendDataIntegrationEventRequest.idempotencyToken(),
        data: String,
        eventGroupId: String,
        eventTimestamp: Date? = nil,
        eventType: DataIntegrationEventType,
        instanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SendDataIntegrationEventResponse {
        let input = SendDataIntegrationEventRequest(
            clientToken: clientToken, 
            data: data, 
            eventGroupId: eventGroupId, 
            eventTimestamp: eventTimestamp, 
            eventType: eventType, 
            instanceId: instanceId
        )
        return try await self.sendDataIntegrationEvent(input, logger: logger)
    }

    /// You can create tags during or after creating a resource such as instance, data flow, or dataset in AWS Supply chain. During the data ingestion process, you can add tags such as dev, test, or prod to data flows created during the data ingestion process in the AWS Supply Chain datasets.  You can use these tags to identify a group of resources or a single resource used by the developer.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/api/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// You can create tags during or after creating a resource such as instance, data flow, or dataset in AWS Supply chain. During the data ingestion process, you can add tags such as dev, test, or prod to data flows created during the data ingestion process in the AWS Supply Chain datasets.  You can use these tags to identify a group of resources or a single resource used by the developer.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Web Services Supply chain resource ARN that needs to be tagged.
    ///   - tags: The tags of the Amazon Web Services Supply chain resource to be created.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// You can delete tags for an Amazon Web Services Supply chain resource such as instance, data flow, or dataset in AWS Supply Chain. During the data ingestion process, you can delete tags such as dev, test, or prod to data flows created during the data ingestion process in the AWS Supply Chain datasets.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/api/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// You can delete tags for an Amazon Web Services Supply chain resource such as instance, data flow, or dataset in AWS Supply Chain. During the data ingestion process, you can delete tags such as dev, test, or prod to data flows created during the data ingestion process in the AWS Supply Chain datasets.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Web Services Supply chain resource ARN that needs to be untagged.
    ///   - tagKeys: The list of tag keys to be deleted for an Amazon Web Services Supply Chain resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Enables you to programmatically update an existing data pipeline to ingest data from the source systems such as, Amazon S3 buckets, to a predefined Amazon Web Services Supply Chain dataset (product, inbound_order) or a temporary dataset along with the data transformation query provided with the API.
    @Sendable
    @inlinable
    public func updateDataIntegrationFlow(_ input: UpdateDataIntegrationFlowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDataIntegrationFlowResponse {
        try await self.client.execute(
            operation: "UpdateDataIntegrationFlow", 
            path: "/api/data-integration/instance/{instanceId}/data-integration-flows/{name}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically update an existing data pipeline to ingest data from the source systems such as, Amazon S3 buckets, to a predefined Amazon Web Services Supply Chain dataset (product, inbound_order) or a temporary dataset along with the data transformation query provided with the API.
    ///
    /// Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - name: The name of the DataIntegrationFlow to be updated.
    ///   - sources: The new source configurations for the DataIntegrationFlow.
    ///   - target: The new target configurations for the DataIntegrationFlow.
    ///   - transformation: The new transformation configurations for the DataIntegrationFlow.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDataIntegrationFlow(
        instanceId: String,
        name: String,
        sources: [DataIntegrationFlowSource]? = nil,
        target: DataIntegrationFlowTarget? = nil,
        transformation: DataIntegrationFlowTransformation? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDataIntegrationFlowResponse {
        let input = UpdateDataIntegrationFlowRequest(
            instanceId: instanceId, 
            name: name, 
            sources: sources, 
            target: target, 
            transformation: transformation
        )
        return try await self.updateDataIntegrationFlow(input, logger: logger)
    }

    /// Enables you to programmatically update an Amazon Web Services Supply Chain data lake dataset. Developers can update the description of a data lake dataset for a given instance ID, namespace, and dataset name.
    @Sendable
    @inlinable
    public func updateDataLakeDataset(_ input: UpdateDataLakeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDataLakeDatasetResponse {
        try await self.client.execute(
            operation: "UpdateDataLakeDataset", 
            path: "/api/datalake/instance/{instanceId}/namespaces/{namespace}/datasets/{name}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically update an Amazon Web Services Supply Chain data lake dataset. Developers can update the description of a data lake dataset for a given instance ID, namespace, and dataset name.
    ///
    /// Parameters:
    ///   - description: The updated description of the data lake dataset.
    ///   - instanceId: The Amazon Web Services Chain instance identifier.
    ///   - name: The name of the dataset. For asc name space, the name must be one of the supported data entities under https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.
    ///   - namespace: The name space of the dataset. The available values are:    asc - For information on the  Amazon Web Services Supply Chain supported datasets see https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.    default - For datasets with custom user-defined schemas.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDataLakeDataset(
        description: String? = nil,
        instanceId: String,
        name: String,
        namespace: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDataLakeDatasetResponse {
        let input = UpdateDataLakeDatasetRequest(
            description: description, 
            instanceId: instanceId, 
            name: name, 
            namespace: namespace
        )
        return try await self.updateDataLakeDataset(input, logger: logger)
    }

    /// Enables you to programmatically update an Amazon Web Services Supply Chain instance description by providing all the relevant information such as account ID, instance ID and so on without using the AWS console.
    @Sendable
    @inlinable
    public func updateInstance(_ input: UpdateInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateInstanceResponse {
        try await self.client.execute(
            operation: "UpdateInstance", 
            path: "/api/instance/{instanceId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to programmatically update an Amazon Web Services Supply Chain instance description by providing all the relevant information such as account ID, instance ID and so on without using the AWS console.
    ///
    /// Parameters:
    ///   - instanceDescription: The AWS Supply Chain instance description.
    ///   - instanceId: The AWS Supply Chain instance identifier.
    ///   - instanceName: The AWS Supply Chain instance name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateInstance(
        instanceDescription: String? = nil,
        instanceId: String,
        instanceName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateInstanceResponse {
        let input = UpdateInstanceRequest(
            instanceDescription: instanceDescription, 
            instanceId: instanceId, 
            instanceName: instanceName
        )
        return try await self.updateInstance(input, logger: logger)
    }
}

extension SupplyChain {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: SupplyChain, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SupplyChain {
    /// Return PaginatorSequence for operation ``listDataIntegrationFlows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataIntegrationFlowsPaginator(
        _ input: ListDataIntegrationFlowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataIntegrationFlowsRequest, ListDataIntegrationFlowsResponse> {
        return .init(
            input: input,
            command: self.listDataIntegrationFlows,
            inputKey: \ListDataIntegrationFlowsRequest.nextToken,
            outputKey: \ListDataIntegrationFlowsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataIntegrationFlows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - maxResults: Specify the maximum number of DataIntegrationFlows to fetch in one paginated request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataIntegrationFlowsPaginator(
        instanceId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataIntegrationFlowsRequest, ListDataIntegrationFlowsResponse> {
        let input = ListDataIntegrationFlowsRequest(
            instanceId: instanceId, 
            maxResults: maxResults
        )
        return self.listDataIntegrationFlowsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataLakeDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataLakeDatasetsPaginator(
        _ input: ListDataLakeDatasetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataLakeDatasetsRequest, ListDataLakeDatasetsResponse> {
        return .init(
            input: input,
            command: self.listDataLakeDatasets,
            inputKey: \ListDataLakeDatasetsRequest.nextToken,
            outputKey: \ListDataLakeDatasetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataLakeDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - instanceId: The Amazon Web Services Supply Chain instance identifier.
    ///   - maxResults: The max number of datasets to fetch in this paginated request.
    ///   - namespace: The name space of the dataset. The available values are:    asc - For information on the  Amazon Web Services Supply Chain supported datasets see https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html.    default - For datasets with custom user-defined schemas.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataLakeDatasetsPaginator(
        instanceId: String,
        maxResults: Int? = nil,
        namespace: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataLakeDatasetsRequest, ListDataLakeDatasetsResponse> {
        let input = ListDataLakeDatasetsRequest(
            instanceId: instanceId, 
            maxResults: maxResults, 
            namespace: namespace
        )
        return self.listDataLakeDatasetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInstancesPaginator(
        _ input: ListInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInstancesRequest, ListInstancesResponse> {
        return .init(
            input: input,
            command: self.listInstances,
            inputKey: \ListInstancesRequest.nextToken,
            outputKey: \ListInstancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - instanceNameFilter: The filter to ListInstances based on their names.
    ///   - instanceStateFilter: The filter to ListInstances based on their state.
    ///   - maxResults: Specify the maximum number of instances to fetch in this paginated request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listInstancesPaginator(
        instanceNameFilter: [String]? = nil,
        instanceStateFilter: [InstanceState]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInstancesRequest, ListInstancesResponse> {
        let input = ListInstancesRequest(
            instanceNameFilter: instanceNameFilter, 
            instanceStateFilter: instanceStateFilter, 
            maxResults: maxResults
        )
        return self.listInstancesPaginator(input, logger: logger)
    }
}

extension SupplyChain.ListDataIntegrationFlowsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SupplyChain.ListDataIntegrationFlowsRequest {
        return .init(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SupplyChain.ListDataLakeDatasetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SupplyChain.ListDataLakeDatasetsRequest {
        return .init(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )
    }
}

extension SupplyChain.ListInstancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SupplyChain.ListInstancesRequest {
        return .init(
            instanceNameFilter: self.instanceNameFilter,
            instanceStateFilter: self.instanceStateFilter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
