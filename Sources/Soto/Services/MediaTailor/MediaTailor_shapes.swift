//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MediaTailor {
    // MARK: Enums

    public enum AccessType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autodetectSigv4 = "AUTODETECT_SIGV4"
        case s3Sigv4 = "S3_SIGV4"
        case secretsManagerAccessToken = "SECRETS_MANAGER_ACCESS_TOKEN"
        public var description: String { return self.rawValue }
    }

    public enum AdMarkupType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daterange = "DATERANGE"
        case scte35Enhanced = "SCTE35_ENHANCED"
        public var description: String { return self.rawValue }
    }

    public enum AlertCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case info = "INFO"
        case playbackWarning = "PLAYBACK_WARNING"
        case schedulingError = "SCHEDULING_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ChannelState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case running = "RUNNING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum FillPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullAvailOnly = "FULL_AVAIL_ONLY"
        case partialAvail = "PARTIAL_AVAIL"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asRun = "AS_RUN"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case spliceInsert = "SPLICE_INSERT"
        case timeSignal = "TIME_SIGNAL"
        public var description: String { return self.rawValue }
    }

    public enum Mode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterLiveEdge = "AFTER_LIVE_EDGE"
        case behindLiveEdge = "BEHIND_LIVE_EDGE"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum OriginManifestType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiPeriod = "MULTI_PERIOD"
        case singlePeriod = "SINGLE_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum PlaybackMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linear = "LINEAR"
        case loop = "LOOP"
        public var description: String { return self.rawValue }
    }

    public enum RelativePosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterProgram = "AFTER_PROGRAM"
        case beforeProgram = "BEFORE_PROGRAM"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleEntryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alternateMedia = "ALTERNATE_MEDIA"
        case fillerSlate = "FILLER_SLATE"
        case program = "PROGRAM"
        public var description: String { return self.rawValue }
    }

    public enum Tier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dash = "DASH"
        case hls = "HLS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of authentication used to access content from HttpConfiguration::BaseUrl on your source location.  S3_SIGV4 - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name. Before you can use S3_SIGV4, you must meet these requirements: • You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide. • The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.  AUTODETECT_SIGV4 - AWS Signature Version 4 authentication for a set of supported services: MediaPackage Version 2 and Amazon S3 hosted virtual-style access. If your source location base URL is a MediaPackage Version 2 endpoint or an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the resource where your source content is stored. Before you can use AUTODETECT_SIGV4 with a MediaPackage Version 2 endpoint, you must meet these requirements: • You must grant MediaTailor access to your MediaPackage endpoint by granting mediatailor.amazonaws.com principal access in an Origin Access policy on the endpoint. • Your MediaTailor source location base URL must be a MediaPackage V2 endpoint. • The caller of the API must have mediapackagev2:GetObject IAM permissions to read all top level manifests referenced by the MediaTailor source packaging configurations. Before you can use AUTODETECT_SIGV4 with an Amazon S3 bucket, you must meet these requirements: • You must grant MediaTailor access to your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For more information about configuring access in IAM, see Access management in the IAM User Guide.. • The mediatailor.amazonaws.com service principal must have permissions to read all top-level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.
        public let accessType: AccessType?
        /// AWS Secrets Manager access token configuration parameters.
        public let secretsManagerAccessTokenConfiguration: SecretsManagerAccessTokenConfiguration?

        public init(accessType: AccessType? = nil, secretsManagerAccessTokenConfiguration: SecretsManagerAccessTokenConfiguration? = nil) {
            self.accessType = accessType
            self.secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case accessType = "AccessType"
            case secretsManagerAccessTokenConfiguration = "SecretsManagerAccessTokenConfiguration"
        }
    }

    public struct AdBreak: AWSEncodableShape & AWSDecodableShape {
        /// Defines a list of key/value pairs that MediaTailor generates within the EXT-X-ASSETtag for SCTE35_ENHANCED output.
        public let adBreakMetadata: [KeyValuePair]?
        /// The SCTE-35 ad insertion type. Accepted value: SPLICE_INSERT, TIME_SIGNAL.
        public let messageType: MessageType?
        /// How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.
        public let offsetMillis: Int64
        /// Ad break slate configuration.
        public let slate: SlateSource?
        /// This defines the SCTE-35 splice_insert() message inserted around the ad. For information about using splice_insert(), see the SCTE-35 specficiaiton, section 9.7.3.1.
        public let spliceInsertMessage: SpliceInsertMessage?
        /// Defines the SCTE-35 time_signal message inserted around the ad. Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a splice_insert SCTE-35 message to the ad break. This message provides basic metadata about the ad break. See section 9.7.4 of the 2022 SCTE-35 specification for more information.
        public let timeSignalMessage: TimeSignalMessage?

        public init(adBreakMetadata: [KeyValuePair]? = nil, messageType: MessageType? = nil, offsetMillis: Int64, slate: SlateSource? = nil, spliceInsertMessage: SpliceInsertMessage? = nil, timeSignalMessage: TimeSignalMessage? = nil) {
            self.adBreakMetadata = adBreakMetadata
            self.messageType = messageType
            self.offsetMillis = offsetMillis
            self.slate = slate
            self.spliceInsertMessage = spliceInsertMessage
            self.timeSignalMessage = timeSignalMessage
        }

        private enum CodingKeys: String, CodingKey {
            case adBreakMetadata = "AdBreakMetadata"
            case messageType = "MessageType"
            case offsetMillis = "OffsetMillis"
            case slate = "Slate"
            case spliceInsertMessage = "SpliceInsertMessage"
            case timeSignalMessage = "TimeSignalMessage"
        }
    }

    public struct AdBreakOpportunity: AWSDecodableShape {
        /// The offset in milliseconds from the start of the VOD source at which an ad marker was detected.
        public let offsetMillis: Int64

        public init(offsetMillis: Int64) {
            self.offsetMillis = offsetMillis
        }

        private enum CodingKeys: String, CodingKey {
            case offsetMillis = "OffsetMillis"
        }
    }

    public struct AdMarkerPassthrough: AWSEncodableShape & AWSDecodableShape {
        /// Enables ad marker passthrough for your configuration.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct Alert: AWSDecodableShape {
        /// The code for the alert. For example, NOT_PROCESSED.
        public let alertCode: String
        /// If an alert is generated for a resource, an explanation of the reason for the alert.
        public let alertMessage: String
        /// The category that MediaTailor assigns to the alert.
        public let category: AlertCategory?
        /// The timestamp when the alert was last modified.
        @CustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date
        /// The Amazon Resource Names (ARNs) related to this alert.
        public let relatedResourceArns: [String]
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(alertCode: String, alertMessage: String, category: AlertCategory? = nil, lastModifiedTime: Date, relatedResourceArns: [String], resourceArn: String) {
            self.alertCode = alertCode
            self.alertMessage = alertMessage
            self.category = category
            self.lastModifiedTime = lastModifiedTime
            self.relatedResourceArns = relatedResourceArns
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case alertCode = "AlertCode"
            case alertMessage = "AlertMessage"
            case category = "Category"
            case lastModifiedTime = "LastModifiedTime"
            case relatedResourceArns = "RelatedResourceArns"
            case resourceArn = "ResourceArn"
        }
    }

    public struct AlternateMedia: AWSEncodableShape & AWSDecodableShape {
        /// Ad break configuration parameters defined in AlternateMedia.
        public let adBreaks: [AdBreak]?
        public let clipRange: ClipRange?
        /// The duration of the alternateMedia in milliseconds.
        public let durationMillis: Int64?
        /// The name of the live source for alternateMedia.
        public let liveSourceName: String?
        /// The date and time that the alternateMedia is scheduled to start, in epoch milliseconds.
        public let scheduledStartTimeMillis: Int64?
        /// The name of the source location for alternateMedia.
        public let sourceLocationName: String?
        /// The name of the VOD source for alternateMedia.
        public let vodSourceName: String?

        public init(adBreaks: [AdBreak]? = nil, clipRange: ClipRange? = nil, durationMillis: Int64? = nil, liveSourceName: String? = nil, scheduledStartTimeMillis: Int64? = nil, sourceLocationName: String? = nil, vodSourceName: String? = nil) {
            self.adBreaks = adBreaks
            self.clipRange = clipRange
            self.durationMillis = durationMillis
            self.liveSourceName = liveSourceName
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case adBreaks = "AdBreaks"
            case clipRange = "ClipRange"
            case durationMillis = "DurationMillis"
            case liveSourceName = "LiveSourceName"
            case scheduledStartTimeMillis = "ScheduledStartTimeMillis"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct AudienceMedia: AWSEncodableShape & AWSDecodableShape {
        /// The list of AlternateMedia defined in AudienceMedia.
        public let alternateMedia: [AlternateMedia]?
        /// The Audience defined in AudienceMedia.
        public let audience: String?

        public init(alternateMedia: [AlternateMedia]? = nil, audience: String? = nil) {
            self.alternateMedia = alternateMedia
            self.audience = audience
        }

        private enum CodingKeys: String, CodingKey {
            case alternateMedia = "AlternateMedia"
            case audience = "Audience"
        }
    }

    public struct AvailMatchingCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see Using dynamic ad variables in the MediaTailor User Guide. You can include up to 100 dynamic variables.
        public let dynamicVariable: String
        /// For the DynamicVariable specified in AvailMatchingCriteria, the Operator that is used for the comparison.
        public let `operator`: Operator

        public init(dynamicVariable: String, operator: Operator) {
            self.dynamicVariable = dynamicVariable
            self.`operator` = `operator`
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicVariable = "DynamicVariable"
            case `operator` = "Operator"
        }
    }

    public struct AvailSuppression: AWSEncodableShape & AWSDecodableShape {
        /// Defines the policy to apply to the avail suppression mode. BEHIND_LIVE_EDGE will always use the full avail suppression policy. AFTER_LIVE_EDGE mode can be used to invoke partial ad break fills when a session starts mid-break.
        public let fillPolicy: FillPolicy?
        /// Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window. When Mode is set to AFTER_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks that are within the live edge plus the avail suppression value.
        public let mode: Mode?
        /// A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.
        public let value: String?

        public init(fillPolicy: FillPolicy? = nil, mode: Mode? = nil, value: String? = nil) {
            self.fillPolicy = fillPolicy
            self.mode = mode
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case fillPolicy = "FillPolicy"
            case mode = "Mode"
            case value = "Value"
        }
    }

    public struct Bumper: AWSEncodableShape & AWSDecodableShape {
        /// The URL for the end bumper asset.
        public let endUrl: String?
        /// The URL for the start bumper asset.
        public let startUrl: String?

        public init(endUrl: String? = nil, startUrl: String? = nil) {
            self.endUrl = endUrl
            self.startUrl = startUrl
        }

        private enum CodingKeys: String, CodingKey {
            case endUrl = "EndUrl"
            case startUrl = "StartUrl"
        }
    }

    public struct CdnConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.&lt;region&gt;.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.
        public let adSegmentUrlPrefix: String?
        /// A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.
        public let contentSegmentUrlPrefix: String?

        public init(adSegmentUrlPrefix: String? = nil, contentSegmentUrlPrefix: String? = nil) {
            self.adSegmentUrlPrefix = adSegmentUrlPrefix
            self.contentSegmentUrlPrefix = contentSegmentUrlPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case adSegmentUrlPrefix = "AdSegmentUrlPrefix"
            case contentSegmentUrlPrefix = "ContentSegmentUrlPrefix"
        }
    }

    public struct Channel: AWSDecodableShape {
        /// The ARN of the channel.
        public let arn: String
        /// The list of audiences defined in channel.
        public let audiences: [String]?
        /// The name of the channel.
        public let channelName: String
        /// Returns the state whether the channel is running or not.
        public let channelState: String
        /// The timestamp of when the channel was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEAR PlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOP PlaybackMode.
        public let fillerSlate: SlateSource?
        /// The timestamp of when the channel was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The log configuration.
        public let logConfiguration: LogConfigurationForChannel
        /// The channel's output properties.
        public let outputs: [ResponseOutputItem]
        /// The type of playback mode for this channel.  LINEAR - Programs play back-to-back only once.  LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
        public let playbackMode: String
        /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The tier for this channel. STANDARD tier channels can contain live programs.
        public let tier: String

        public init(arn: String, audiences: [String]? = nil, channelName: String, channelState: String, creationTime: Date? = nil, fillerSlate: SlateSource? = nil, lastModifiedTime: Date? = nil, logConfiguration: LogConfigurationForChannel, outputs: [ResponseOutputItem], playbackMode: String, tags: [String: String]? = nil, tier: String) {
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.logConfiguration = logConfiguration
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case audiences = "Audiences"
            case channelName = "ChannelName"
            case channelState = "ChannelState"
            case creationTime = "CreationTime"
            case fillerSlate = "FillerSlate"
            case lastModifiedTime = "LastModifiedTime"
            case logConfiguration = "LogConfiguration"
            case outputs = "Outputs"
            case playbackMode = "PlaybackMode"
            case tags = "tags"
            case tier = "Tier"
        }
    }

    public struct ClipRange: AWSEncodableShape & AWSDecodableShape {
        /// The end offset of the clip range, in milliseconds, starting from the beginning of the VOD source associated with the program.
        public let endOffsetMillis: Int64?
        /// The start offset of the clip range, in milliseconds. This offset truncates the start at the number of milliseconds into the duration of the VOD source.
        public let startOffsetMillis: Int64?

        public init(endOffsetMillis: Int64? = nil, startOffsetMillis: Int64? = nil) {
            self.endOffsetMillis = endOffsetMillis
            self.startOffsetMillis = startOffsetMillis
        }

        private enum CodingKeys: String, CodingKey {
            case endOffsetMillis = "EndOffsetMillis"
            case startOffsetMillis = "StartOffsetMillis"
        }
    }

    public struct ConfigureLogsForChannelRequest: AWSEncodableShape {
        /// The name of the channel.
        public let channelName: String
        /// The types of logs to collect.
        public let logTypes: [LogType]

        public init(channelName: String, logTypes: [LogType]) {
            self.channelName = channelName
            self.logTypes = logTypes
        }

        private enum CodingKeys: String, CodingKey {
            case channelName = "ChannelName"
            case logTypes = "LogTypes"
        }
    }

    public struct ConfigureLogsForChannelResponse: AWSDecodableShape {
        /// The name of the channel.
        public let channelName: String?
        /// The types of logs collected.
        public let logTypes: [LogType]?

        public init(channelName: String? = nil, logTypes: [LogType]? = nil) {
            self.channelName = channelName
            self.logTypes = logTypes
        }

        private enum CodingKeys: String, CodingKey {
            case channelName = "ChannelName"
            case logTypes = "LogTypes"
        }
    }

    public struct ConfigureLogsForPlaybackConfigurationRequest: AWSEncodableShape {
        /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the debug log mode. Valid values: 0 - 100
        public let percentEnabled: Int
        /// The name of the playback configuration.
        public let playbackConfigurationName: String

        public init(percentEnabled: Int = 0, playbackConfigurationName: String) {
            self.percentEnabled = percentEnabled
            self.playbackConfigurationName = playbackConfigurationName
        }

        private enum CodingKeys: String, CodingKey {
            case percentEnabled = "PercentEnabled"
            case playbackConfigurationName = "PlaybackConfigurationName"
        }
    }

    public struct ConfigureLogsForPlaybackConfigurationResponse: AWSDecodableShape {
        /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.
        public let percentEnabled: Int
        /// The name of the playback configuration.
        public let playbackConfigurationName: String?

        public init(percentEnabled: Int, playbackConfigurationName: String? = nil) {
            self.percentEnabled = percentEnabled
            self.playbackConfigurationName = playbackConfigurationName
        }

        private enum CodingKeys: String, CodingKey {
            case percentEnabled = "PercentEnabled"
            case playbackConfigurationName = "PlaybackConfigurationName"
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        /// The list of audiences defined in channel.
        public let audiences: [String]?
        /// The name of the channel.
        public let channelName: String
        /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEAR PlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOP PlaybackMode.
        public let fillerSlate: SlateSource?
        /// The channel's output properties.
        public let outputs: [RequestOutputItem]
        /// The type of playback mode to use for this channel.  LINEAR - The programs in the schedule play once back-to-back in the schedule.  LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.
        public let playbackMode: PlaybackMode
        /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The tier of the channel.
        public let tier: Tier?
        ///  The time-shifted viewing configuration you want to associate to the channel.
        public let timeShiftConfiguration: TimeShiftConfiguration?

        public init(audiences: [String]? = nil, channelName: String, fillerSlate: SlateSource? = nil, outputs: [RequestOutputItem], playbackMode: PlaybackMode, tags: [String: String]? = nil, tier: Tier? = nil, timeShiftConfiguration: TimeShiftConfiguration? = nil) {
            self.audiences = audiences
            self.channelName = channelName
            self.fillerSlate = fillerSlate
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
            self.timeShiftConfiguration = timeShiftConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.audiences, forKey: .audiences)
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encodeIfPresent(self.fillerSlate, forKey: .fillerSlate)
            try container.encode(self.outputs, forKey: .outputs)
            try container.encode(self.playbackMode, forKey: .playbackMode)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.tier, forKey: .tier)
            try container.encodeIfPresent(self.timeShiftConfiguration, forKey: .timeShiftConfiguration)
        }

        private enum CodingKeys: String, CodingKey {
            case audiences = "Audiences"
            case fillerSlate = "FillerSlate"
            case outputs = "Outputs"
            case playbackMode = "PlaybackMode"
            case tags = "tags"
            case tier = "Tier"
            case timeShiftConfiguration = "TimeShiftConfiguration"
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) to assign to the channel.
        public let arn: String?
        /// The list of audiences defined in channel.
        public let audiences: [String]?
        /// The name to assign to the channel.
        public let channelName: String?
        /// Indicates whether the channel is in a running state or not.
        public let channelState: ChannelState?
        /// The timestamp of when the channel was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// Contains information about the slate used to fill gaps between programs in the schedule.
        public let fillerSlate: SlateSource?
        /// The timestamp of when the channel was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The output properties to assign to the channel.
        public let outputs: [ResponseOutputItem]?
        /// The playback mode to assign to the channel.
        public let playbackMode: String?
        /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The tier of the channel.
        public let tier: String?
        ///  The time-shifted viewing configuration assigned to the channel.
        public let timeShiftConfiguration: TimeShiftConfiguration?

        public init(arn: String? = nil, audiences: [String]? = nil, channelName: String? = nil, channelState: ChannelState? = nil, creationTime: Date? = nil, fillerSlate: SlateSource? = nil, lastModifiedTime: Date? = nil, outputs: [ResponseOutputItem]? = nil, playbackMode: String? = nil, tags: [String: String]? = nil, tier: String? = nil, timeShiftConfiguration: TimeShiftConfiguration? = nil) {
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
            self.timeShiftConfiguration = timeShiftConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case audiences = "Audiences"
            case channelName = "ChannelName"
            case channelState = "ChannelState"
            case creationTime = "CreationTime"
            case fillerSlate = "FillerSlate"
            case lastModifiedTime = "LastModifiedTime"
            case outputs = "Outputs"
            case playbackMode = "PlaybackMode"
            case tags = "tags"
            case tier = "Tier"
            case timeShiftConfiguration = "TimeShiftConfiguration"
        }
    }

    public struct CreateLiveSourceRequest: AWSEncodableShape {
        /// A list of HTTP package configuration parameters for this live source.
        public let httpPackageConfigurations: [HttpPackageConfiguration]
        /// The name of the live source.
        public let liveSourceName: String
        /// The name of the source location.
        public let sourceLocationName: String
        /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(httpPackageConfigurations: [HttpPackageConfiguration], liveSourceName: String, sourceLocationName: String, tags: [String: String]? = nil) {
            self.httpPackageConfigurations = httpPackageConfigurations
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.httpPackageConfigurations, forKey: .httpPackageConfigurations)
            request.encodePath(self.liveSourceName, key: "LiveSourceName")
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateLiveSourceResponse: AWSDecodableShape {
        /// The ARN to assign to the live source.
        public let arn: String?
        /// The time the live source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// A list of HTTP package configuration parameters for this live source.
        public let httpPackageConfigurations: [HttpPackageConfiguration]?
        /// The time the live source was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name to assign to the live source.
        public let liveSourceName: String?
        /// The name to assign to the source location of the live source.
        public let sourceLocationName: String?
        /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration]? = nil, lastModifiedTime: Date? = nil, liveSourceName: String? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case liveSourceName = "LiveSourceName"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct CreatePrefetchScheduleRequest: AWSEncodableShape {
        /// The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
        public let consumption: PrefetchConsumption
        /// The name to assign to the schedule request.
        public let name: String
        /// The name to assign to the playback configuration.
        public let playbackConfigurationName: String
        /// The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
        public let retrieval: PrefetchRetrieval
        /// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
        public let streamId: String?

        public init(consumption: PrefetchConsumption, name: String, playbackConfigurationName: String, retrieval: PrefetchRetrieval, streamId: String? = nil) {
            self.consumption = consumption
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
            self.retrieval = retrieval
            self.streamId = streamId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.consumption, forKey: .consumption)
            request.encodePath(self.name, key: "Name")
            request.encodePath(self.playbackConfigurationName, key: "PlaybackConfigurationName")
            try container.encode(self.retrieval, forKey: .retrieval)
            try container.encodeIfPresent(self.streamId, forKey: .streamId)
        }

        private enum CodingKeys: String, CodingKey {
            case consumption = "Consumption"
            case retrieval = "Retrieval"
            case streamId = "StreamId"
        }
    }

    public struct CreatePrefetchScheduleResponse: AWSDecodableShape {
        /// The ARN to assign to the prefetch schedule.
        public let arn: String?
        /// The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
        public let consumption: PrefetchConsumption?
        /// The name to assign to the prefetch schedule.
        public let name: String?
        /// The name to assign to the playback configuration.
        public let playbackConfigurationName: String?
        /// The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
        public let retrieval: PrefetchRetrieval?
        /// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
        public let streamId: String?

        public init(arn: String? = nil, consumption: PrefetchConsumption? = nil, name: String? = nil, playbackConfigurationName: String? = nil, retrieval: PrefetchRetrieval? = nil, streamId: String? = nil) {
            self.arn = arn
            self.consumption = consumption
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
            self.retrieval = retrieval
            self.streamId = streamId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case consumption = "Consumption"
            case name = "Name"
            case playbackConfigurationName = "PlaybackConfigurationName"
            case retrieval = "Retrieval"
            case streamId = "StreamId"
        }
    }

    public struct CreateProgramRequest: AWSEncodableShape {
        /// The ad break configuration settings.
        public let adBreaks: [AdBreak]?
        /// The list of AudienceMedia defined in program.
        public let audienceMedia: [AudienceMedia]?
        /// The name of the channel for this Program.
        public let channelName: String
        /// The name of the LiveSource for this Program.
        public let liveSourceName: String?
        /// The name of the Program.
        public let programName: String
        /// The schedule configuration settings.
        public let scheduleConfiguration: ScheduleConfiguration
        /// The name of the source location.
        public let sourceLocationName: String
        /// The name that's used to refer to a VOD source.
        public let vodSourceName: String?

        public init(adBreaks: [AdBreak]? = nil, audienceMedia: [AudienceMedia]? = nil, channelName: String, liveSourceName: String? = nil, programName: String, scheduleConfiguration: ScheduleConfiguration, sourceLocationName: String, vodSourceName: String? = nil) {
            self.adBreaks = adBreaks
            self.audienceMedia = audienceMedia
            self.channelName = channelName
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduleConfiguration = scheduleConfiguration
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.adBreaks, forKey: .adBreaks)
            try container.encodeIfPresent(self.audienceMedia, forKey: .audienceMedia)
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encodeIfPresent(self.liveSourceName, forKey: .liveSourceName)
            request.encodePath(self.programName, key: "ProgramName")
            try container.encode(self.scheduleConfiguration, forKey: .scheduleConfiguration)
            try container.encode(self.sourceLocationName, forKey: .sourceLocationName)
            try container.encodeIfPresent(self.vodSourceName, forKey: .vodSourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case adBreaks = "AdBreaks"
            case audienceMedia = "AudienceMedia"
            case liveSourceName = "LiveSourceName"
            case scheduleConfiguration = "ScheduleConfiguration"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct CreateProgramResponse: AWSDecodableShape {
        /// The ad break configuration settings.
        public let adBreaks: [AdBreak]?
        /// The ARN to assign to the program.
        public let arn: String?
        /// The list of AudienceMedia defined in program.
        public let audienceMedia: [AudienceMedia]?
        /// The name to assign to the channel for this program.
        public let channelName: String?
        /// The clip range configuration settings.
        public let clipRange: ClipRange?
        /// The time the program was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The duration of the live program in milliseconds.
        public let durationMillis: Int64?
        /// The name of the LiveSource for this Program.
        public let liveSourceName: String?
        /// The name to assign to this program.
        public let programName: String?
        /// The scheduled start time for this Program.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var scheduledStartTime: Date?
        /// The name to assign to the source location for this program.
        public let sourceLocationName: String?
        /// The name that's used to refer to a VOD source.
        public let vodSourceName: String?

        public init(adBreaks: [AdBreak]? = nil, arn: String? = nil, audienceMedia: [AudienceMedia]? = nil, channelName: String? = nil, clipRange: ClipRange? = nil, creationTime: Date? = nil, durationMillis: Int64? = nil, liveSourceName: String? = nil, programName: String? = nil, scheduledStartTime: Date? = nil, sourceLocationName: String? = nil, vodSourceName: String? = nil) {
            self.adBreaks = adBreaks
            self.arn = arn
            self.audienceMedia = audienceMedia
            self.channelName = channelName
            self.clipRange = clipRange
            self.creationTime = creationTime
            self.durationMillis = durationMillis
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduledStartTime = scheduledStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case adBreaks = "AdBreaks"
            case arn = "Arn"
            case audienceMedia = "AudienceMedia"
            case channelName = "ChannelName"
            case clipRange = "ClipRange"
            case creationTime = "CreationTime"
            case durationMillis = "DurationMillis"
            case liveSourceName = "LiveSourceName"
            case programName = "ProgramName"
            case scheduledStartTime = "ScheduledStartTime"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct CreateSourceLocationRequest: AWSEncodableShape {
        /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
        public let accessConfiguration: AccessConfiguration?
        /// The optional configuration for the server that serves segments.
        public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
        /// The source's HTTP package configurations.
        public let httpConfiguration: HttpConfiguration
        /// A list of the segment delivery configurations associated with this resource.
        public let segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]?
        /// The name associated with the source location.
        public let sourceLocationName: String
        /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(accessConfiguration: AccessConfiguration? = nil, defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil, httpConfiguration: HttpConfiguration, segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil, sourceLocationName: String, tags: [String: String]? = nil) {
            self.accessConfiguration = accessConfiguration
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accessConfiguration, forKey: .accessConfiguration)
            try container.encodeIfPresent(self.defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
            try container.encode(self.httpConfiguration, forKey: .httpConfiguration)
            try container.encodeIfPresent(self.segmentDeliveryConfigurations, forKey: .segmentDeliveryConfigurations)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "AccessConfiguration"
            case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
            case httpConfiguration = "HttpConfiguration"
            case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateSourceLocationResponse: AWSDecodableShape {
        /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
        public let accessConfiguration: AccessConfiguration?
        /// The ARN to assign to the source location.
        public let arn: String?
        /// The time the source location was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The optional configuration for the server that serves segments.
        public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
        /// The source's HTTP package configurations.
        public let httpConfiguration: HttpConfiguration?
        /// The time the source location was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The segment delivery configurations for the source location. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
        public let segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]?
        /// The name to assign to the source location.
        public let sourceLocationName: String?
        /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(accessConfiguration: AccessConfiguration? = nil, arn: String? = nil, creationTime: Date? = nil, defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil, httpConfiguration: HttpConfiguration? = nil, lastModifiedTime: Date? = nil, segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil) {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "AccessConfiguration"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
            case httpConfiguration = "HttpConfiguration"
            case lastModifiedTime = "LastModifiedTime"
            case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct CreateVodSourceRequest: AWSEncodableShape {
        /// A list of HTTP package configuration parameters for this VOD source.
        public let httpPackageConfigurations: [HttpPackageConfiguration]
        /// The name of the source location for this VOD source.
        public let sourceLocationName: String
        /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name associated with the VOD source.&gt;
        public let vodSourceName: String

        public init(httpPackageConfigurations: [HttpPackageConfiguration], sourceLocationName: String, tags: [String: String]? = nil, vodSourceName: String) {
            self.httpPackageConfigurations = httpPackageConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.httpPackageConfigurations, forKey: .httpPackageConfigurations)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.vodSourceName, key: "VodSourceName")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateVodSourceResponse: AWSDecodableShape {
        /// The ARN to assign to this VOD source.
        public let arn: String?
        /// The time the VOD source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// A list of HTTP package configuration parameters for this VOD source.
        public let httpPackageConfigurations: [HttpPackageConfiguration]?
        /// The time the VOD source was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name to assign to the source location for this VOD source.
        public let sourceLocationName: String?
        /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name to assign to the VOD source.
        public let vodSourceName: String?

        public init(arn: String? = nil, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration]? = nil, lastModifiedTime: Date? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil, vodSourceName: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct DashConfiguration: AWSDecodableShape {
        /// The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.
        public let manifestEndpointPrefix: String?
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public let mpdLocation: String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public let originManifestType: OriginManifestType?

        public init(manifestEndpointPrefix: String? = nil, mpdLocation: String? = nil, originManifestType: OriginManifestType? = nil) {
            self.manifestEndpointPrefix = manifestEndpointPrefix
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }

        private enum CodingKeys: String, CodingKey {
            case manifestEndpointPrefix = "ManifestEndpointPrefix"
            case mpdLocation = "MpdLocation"
            case originManifestType = "OriginManifestType"
        }
    }

    public struct DashConfigurationForPut: AWSEncodableShape {
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public let mpdLocation: String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public let originManifestType: OriginManifestType?

        public init(mpdLocation: String? = nil, originManifestType: OriginManifestType? = nil) {
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }

        private enum CodingKeys: String, CodingKey {
            case mpdLocation = "MpdLocation"
            case originManifestType = "OriginManifestType"
        }
    }

    public struct DashPlaylistSettings: AWSEncodableShape & AWSDecodableShape {
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public let manifestWindowSeconds: Int?
        /// Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public let minBufferTimeSeconds: Int?
        /// Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public let minUpdatePeriodSeconds: Int?
        /// Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public let suggestedPresentationDelaySeconds: Int?

        public init(manifestWindowSeconds: Int? = nil, minBufferTimeSeconds: Int? = nil, minUpdatePeriodSeconds: Int? = nil, suggestedPresentationDelaySeconds: Int? = nil) {
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        }

        private enum CodingKeys: String, CodingKey {
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case minBufferTimeSeconds = "MinBufferTimeSeconds"
            case minUpdatePeriodSeconds = "MinUpdatePeriodSeconds"
            case suggestedPresentationDelaySeconds = "SuggestedPresentationDelaySeconds"
        }
    }

    public struct DefaultSegmentDeliveryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The hostname of the server that will be used to serve segments. This string must include the protocol, such as https://.
        public let baseUrl: String?

        public init(baseUrl: String? = nil) {
            self.baseUrl = baseUrl
        }

        private enum CodingKeys: String, CodingKey {
            case baseUrl = "BaseUrl"
        }
    }

    public struct DeleteChannelPolicyRequest: AWSEncodableShape {
        /// The name of the channel associated with this channel policy.
        public let channelName: String

        public init(channelName: String) {
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        /// The name of the channel.
        public let channelName: String

        public init(channelName: String) {
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLiveSourceRequest: AWSEncodableShape {
        /// The name of the live source.
        public let liveSourceName: String
        /// The name of the source location associated with this Live Source.
        public let sourceLocationName: String

        public init(liveSourceName: String, sourceLocationName: String) {
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.liveSourceName, key: "LiveSourceName")
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLiveSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePlaybackConfigurationRequest: AWSEncodableShape {
        /// The name of the playback configuration.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePlaybackConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePrefetchScheduleRequest: AWSEncodableShape {
        /// The name of the prefetch schedule. If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
        public let name: String
        /// The name of the playback configuration for this prefetch schedule.
        public let playbackConfigurationName: String

        public init(name: String, playbackConfigurationName: String) {
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodePath(self.playbackConfigurationName, key: "PlaybackConfigurationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePrefetchScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProgramRequest: AWSEncodableShape {
        /// The name of the channel.
        public let channelName: String
        /// The name of the program.
        public let programName: String

        public init(channelName: String, programName: String) {
            self.channelName = channelName
            self.programName = programName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.programName, key: "ProgramName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProgramResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSourceLocationRequest: AWSEncodableShape {
        /// The name of the source location.
        public let sourceLocationName: String

        public init(sourceLocationName: String) {
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSourceLocationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVodSourceRequest: AWSEncodableShape {
        /// The name of the source location associated with this VOD Source.
        public let sourceLocationName: String
        /// The name of the VOD source.
        public let vodSourceName: String

        public init(sourceLocationName: String, vodSourceName: String) {
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
            request.encodePath(self.vodSourceName, key: "VodSourceName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVodSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeChannelRequest: AWSEncodableShape {
        /// The name of the channel.
        public let channelName: String

        public init(channelName: String) {
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let arn: String?
        /// The list of audiences defined in channel.
        public let audiences: [String]?
        /// The name of the channel.
        public let channelName: String?
        /// Indicates whether the channel is in a running state or not.
        public let channelState: ChannelState?
        /// The timestamp of when the channel was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// Contains information about the slate used to fill gaps between programs in the schedule.
        public let fillerSlate: SlateSource?
        /// The timestamp of when the channel was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The log configuration for the channel.
        public let logConfiguration: LogConfigurationForChannel
        /// The channel's output properties.
        public let outputs: [ResponseOutputItem]?
        /// The channel's playback mode.
        public let playbackMode: String?
        /// The tags assigned to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The channel's tier.
        public let tier: String?
        ///  The time-shifted viewing configuration for the channel.
        public let timeShiftConfiguration: TimeShiftConfiguration?

        public init(arn: String? = nil, audiences: [String]? = nil, channelName: String? = nil, channelState: ChannelState? = nil, creationTime: Date? = nil, fillerSlate: SlateSource? = nil, lastModifiedTime: Date? = nil, logConfiguration: LogConfigurationForChannel, outputs: [ResponseOutputItem]? = nil, playbackMode: String? = nil, tags: [String: String]? = nil, tier: String? = nil, timeShiftConfiguration: TimeShiftConfiguration? = nil) {
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.logConfiguration = logConfiguration
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
            self.timeShiftConfiguration = timeShiftConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case audiences = "Audiences"
            case channelName = "ChannelName"
            case channelState = "ChannelState"
            case creationTime = "CreationTime"
            case fillerSlate = "FillerSlate"
            case lastModifiedTime = "LastModifiedTime"
            case logConfiguration = "LogConfiguration"
            case outputs = "Outputs"
            case playbackMode = "PlaybackMode"
            case tags = "tags"
            case tier = "Tier"
            case timeShiftConfiguration = "TimeShiftConfiguration"
        }
    }

    public struct DescribeLiveSourceRequest: AWSEncodableShape {
        /// The name of the live source.
        public let liveSourceName: String
        /// The name of the source location associated with this Live Source.
        public let sourceLocationName: String

        public init(liveSourceName: String, sourceLocationName: String) {
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.liveSourceName, key: "LiveSourceName")
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeLiveSourceResponse: AWSDecodableShape {
        /// The ARN of the live source.
        public let arn: String?
        /// The timestamp that indicates when the live source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The HTTP package configurations.
        public let httpPackageConfigurations: [HttpPackageConfiguration]?
        /// The timestamp that indicates when the live source was modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name of the live source.
        public let liveSourceName: String?
        /// The name of the source location associated with the live source.
        public let sourceLocationName: String?
        /// The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration]? = nil, lastModifiedTime: Date? = nil, liveSourceName: String? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case liveSourceName = "LiveSourceName"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct DescribeProgramRequest: AWSEncodableShape {
        /// The name of the channel associated with this Program.
        public let channelName: String
        /// The name of the program.
        public let programName: String

        public init(channelName: String, programName: String) {
            self.channelName = channelName
            self.programName = programName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.programName, key: "ProgramName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProgramResponse: AWSDecodableShape {
        /// The ad break configuration settings.
        public let adBreaks: [AdBreak]?
        /// The ARN of the program.
        public let arn: String?
        /// The list of AudienceMedia defined in program.
        public let audienceMedia: [AudienceMedia]?
        /// The name of the channel that the program belongs to.
        public let channelName: String?
        /// The clip range configuration settings.
        public let clipRange: ClipRange?
        /// The timestamp of when the program was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The duration of the live program in milliseconds.
        public let durationMillis: Int64?
        /// The name of the LiveSource for this Program.
        public let liveSourceName: String?
        /// The name of the program.
        public let programName: String?
        /// The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var scheduledStartTime: Date?
        /// The source location name.
        public let sourceLocationName: String?
        /// The name that's used to refer to a VOD source.
        public let vodSourceName: String?

        public init(adBreaks: [AdBreak]? = nil, arn: String? = nil, audienceMedia: [AudienceMedia]? = nil, channelName: String? = nil, clipRange: ClipRange? = nil, creationTime: Date? = nil, durationMillis: Int64? = nil, liveSourceName: String? = nil, programName: String? = nil, scheduledStartTime: Date? = nil, sourceLocationName: String? = nil, vodSourceName: String? = nil) {
            self.adBreaks = adBreaks
            self.arn = arn
            self.audienceMedia = audienceMedia
            self.channelName = channelName
            self.clipRange = clipRange
            self.creationTime = creationTime
            self.durationMillis = durationMillis
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduledStartTime = scheduledStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case adBreaks = "AdBreaks"
            case arn = "Arn"
            case audienceMedia = "AudienceMedia"
            case channelName = "ChannelName"
            case clipRange = "ClipRange"
            case creationTime = "CreationTime"
            case durationMillis = "DurationMillis"
            case liveSourceName = "LiveSourceName"
            case programName = "ProgramName"
            case scheduledStartTime = "ScheduledStartTime"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct DescribeSourceLocationRequest: AWSEncodableShape {
        /// The name of the source location.
        public let sourceLocationName: String

        public init(sourceLocationName: String) {
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSourceLocationResponse: AWSDecodableShape {
        /// The access configuration for the source location.
        public let accessConfiguration: AccessConfiguration?
        /// The ARN of the source location.
        public let arn: String?
        /// The timestamp that indicates when the source location was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The default segment delivery configuration settings.
        public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
        /// The HTTP package configuration settings for the source location.
        public let httpConfiguration: HttpConfiguration?
        /// The timestamp that indicates when the source location was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// A list of the segment delivery configurations associated with this resource.
        public let segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]?
        /// The name of the source location.
        public let sourceLocationName: String?
        /// The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(accessConfiguration: AccessConfiguration? = nil, arn: String? = nil, creationTime: Date? = nil, defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil, httpConfiguration: HttpConfiguration? = nil, lastModifiedTime: Date? = nil, segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil) {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "AccessConfiguration"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
            case httpConfiguration = "HttpConfiguration"
            case lastModifiedTime = "LastModifiedTime"
            case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct DescribeVodSourceRequest: AWSEncodableShape {
        /// The name of the source location associated with this VOD Source.
        public let sourceLocationName: String
        /// The name of the VOD Source.
        public let vodSourceName: String

        public init(sourceLocationName: String, vodSourceName: String) {
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
            request.encodePath(self.vodSourceName, key: "VodSourceName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVodSourceResponse: AWSDecodableShape {
        /// The ad break opportunities within the VOD source.
        public let adBreakOpportunities: [AdBreakOpportunity]?
        /// The ARN of the VOD source.
        public let arn: String?
        /// The timestamp that indicates when the VOD source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The HTTP package configurations.
        public let httpPackageConfigurations: [HttpPackageConfiguration]?
        /// The last modified time of the VOD source.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name of the source location associated with the VOD source.
        public let sourceLocationName: String?
        /// The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name of the VOD source.
        public let vodSourceName: String?

        public init(adBreakOpportunities: [AdBreakOpportunity]? = nil, arn: String? = nil, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration]? = nil, lastModifiedTime: Date? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil, vodSourceName: String? = nil) {
            self.adBreakOpportunities = adBreakOpportunities
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case adBreakOpportunities = "AdBreakOpportunities"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct GetChannelPolicyRequest: AWSEncodableShape {
        /// The name of the channel associated with this Channel Policy.
        public let channelName: String

        public init(channelName: String) {
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelPolicyResponse: AWSDecodableShape {
        /// The IAM policy for the channel. IAM policies are used to control access to your channel.
        public let policy: String?

        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetChannelScheduleRequest: AWSEncodableShape {
        /// The single audience for GetChannelScheduleRequest.
        public let audience: String?
        /// The name of the channel associated with this Channel Schedule.
        public let channelName: String
        /// The duration in minutes of the channel schedule.
        public let durationMinutes: String?
        /// The maximum number of channel schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults channel schedules, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// (Optional) If the playback configuration has more than MaxResults channel schedules, use NextToken to get the second and subsequent pages of results. For the first GetChannelScheduleRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more channel schedules to get.
        public let nextToken: String?

        public init(audience: String? = nil, channelName: String, durationMinutes: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.audience = audience
            self.channelName = channelName
            self.durationMinutes = durationMinutes
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.audience, key: "audience")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeQuery(self.durationMinutes, key: "durationMinutes")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelScheduleResponse: AWSDecodableShape {
        /// A list of schedule entries for the channel.
        public let items: [ScheduleEntry]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [ScheduleEntry]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct GetPlaybackConfigurationRequest: AWSEncodableShape {
        /// The identifier for the playback configuration.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPlaybackConfigurationResponse: AWSDecodableShape {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
        public let adDecisionServerUrl: String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression.
        public let availSuppression: AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers.
        public let bumper: Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public let cdnConfiguration: CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see Domain Variables.
        public let configurationAliases: [String: [String: String]]?
        /// The configuration for DASH content.
        public let dashConfiguration: DashConfiguration?
        /// The configuration for HLS content.
        public let hlsConfiguration: HlsConfiguration?
        /// The configuration for pre-roll ad insertion.
        public let livePreRollConfiguration: LivePreRollConfiguration?
        /// The Amazon CloudWatch log settings for a playback configuration.
        public let logConfiguration: LogConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public let manifestProcessingRules: ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public let name: String?
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see Ad Behavior in AWS Elemental MediaTailor.
        public let personalizationThresholdSeconds: Int?
        /// The Amazon Resource Name (ARN) for the playback configuration.
        public let playbackConfigurationArn: String?
        /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.
        public let playbackEndpointPrefix: String?
        /// The URL that the player uses to initialize a session that uses client-side reporting.
        public let sessionInitializationEndpointPrefix: String?
        /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public let slateAdUrl: String?
        /// The tags assigned to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public let transcodeProfileName: String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public let videoContentSourceUrl: String?

        public init(adDecisionServerUrl: String? = nil, availSuppression: AvailSuppression? = nil, bumper: Bumper? = nil, cdnConfiguration: CdnConfiguration? = nil, configurationAliases: [String: [String: String]]? = nil, dashConfiguration: DashConfiguration? = nil, hlsConfiguration: HlsConfiguration? = nil, livePreRollConfiguration: LivePreRollConfiguration? = nil, logConfiguration: LogConfiguration? = nil, manifestProcessingRules: ManifestProcessingRules? = nil, name: String? = nil, personalizationThresholdSeconds: Int? = nil, playbackConfigurationArn: String? = nil, playbackEndpointPrefix: String? = nil, sessionInitializationEndpointPrefix: String? = nil, slateAdUrl: String? = nil, tags: [String: String]? = nil, transcodeProfileName: String? = nil, videoContentSourceUrl: String? = nil) {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.hlsConfiguration = hlsConfiguration
            self.livePreRollConfiguration = livePreRollConfiguration
            self.logConfiguration = logConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.playbackConfigurationArn = playbackConfigurationArn
            self.playbackEndpointPrefix = playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }

        private enum CodingKeys: String, CodingKey {
            case adDecisionServerUrl = "AdDecisionServerUrl"
            case availSuppression = "AvailSuppression"
            case bumper = "Bumper"
            case cdnConfiguration = "CdnConfiguration"
            case configurationAliases = "ConfigurationAliases"
            case dashConfiguration = "DashConfiguration"
            case hlsConfiguration = "HlsConfiguration"
            case livePreRollConfiguration = "LivePreRollConfiguration"
            case logConfiguration = "LogConfiguration"
            case manifestProcessingRules = "ManifestProcessingRules"
            case name = "Name"
            case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
            case playbackConfigurationArn = "PlaybackConfigurationArn"
            case playbackEndpointPrefix = "PlaybackEndpointPrefix"
            case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
            case slateAdUrl = "SlateAdUrl"
            case tags = "tags"
            case transcodeProfileName = "TranscodeProfileName"
            case videoContentSourceUrl = "VideoContentSourceUrl"
        }
    }

    public struct GetPrefetchScheduleRequest: AWSEncodableShape {
        /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
        public let name: String
        /// Returns information about the prefetch schedule for a specific playback configuration. If you call GetPrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.
        public let playbackConfigurationName: String

        public init(name: String, playbackConfigurationName: String) {
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodePath(self.playbackConfigurationName, key: "PlaybackConfigurationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPrefetchScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prefetch schedule.
        public let arn: String?
        /// Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a consumption window. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.
        public let consumption: PrefetchConsumption?
        /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
        public let name: String?
        /// The name of the playback configuration to create the prefetch schedule for.
        public let playbackConfigurationName: String?
        /// A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).
        public let retrieval: PrefetchRetrieval?
        /// An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.
        public let streamId: String?

        public init(arn: String? = nil, consumption: PrefetchConsumption? = nil, name: String? = nil, playbackConfigurationName: String? = nil, retrieval: PrefetchRetrieval? = nil, streamId: String? = nil) {
            self.arn = arn
            self.consumption = consumption
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
            self.retrieval = retrieval
            self.streamId = streamId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case consumption = "Consumption"
            case name = "Name"
            case playbackConfigurationName = "PlaybackConfigurationName"
            case retrieval = "Retrieval"
            case streamId = "StreamId"
        }
    }

    public struct HlsConfiguration: AWSDecodableShape {
        /// The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.
        public let manifestEndpointPrefix: String?

        public init(manifestEndpointPrefix: String? = nil) {
            self.manifestEndpointPrefix = manifestEndpointPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case manifestEndpointPrefix = "ManifestEndpointPrefix"
        }
    }

    public struct HlsPlaylistSettings: AWSEncodableShape & AWSDecodableShape {
        /// Determines the type of SCTE 35 tags to use in ad markup. Specify DATERANGE to use DATERANGE tags (for live or VOD content). Specify SCTE35_ENHANCED to use EXT-X-CUE-OUT and EXT-X-CUE-IN tags (for VOD content only).
        public let adMarkupType: [AdMarkupType]?
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public let manifestWindowSeconds: Int?

        public init(adMarkupType: [AdMarkupType]? = nil, manifestWindowSeconds: Int? = nil) {
            self.adMarkupType = adMarkupType
            self.manifestWindowSeconds = manifestWindowSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkupType = "AdMarkupType"
            case manifestWindowSeconds = "ManifestWindowSeconds"
        }
    }

    public struct HttpConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The base URL for the source location host server. This string must include the protocol, such as https://.
        public let baseUrl: String

        public init(baseUrl: String) {
            self.baseUrl = baseUrl
        }

        private enum CodingKeys: String, CodingKey {
            case baseUrl = "BaseUrl"
        }
    }

    public struct HttpPackageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The relative path to the URL for this VOD source. This is combined with SourceLocation::HttpConfiguration::BaseUrl to form a valid URL.
        public let path: String
        /// The name of the source group. This has to match one of the Channel::Outputs::SourceGroup.
        public let sourceGroup: String
        /// The streaming protocol for this package configuration. Supported values are HLS and DASH.
        public let type: `Type`

        public init(path: String, sourceGroup: String, type: `Type`) {
            self.path = path
            self.sourceGroup = sourceGroup
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
            case sourceGroup = "SourceGroup"
            case type = "Type"
        }
    }

    public struct KeyValuePair: AWSEncodableShape & AWSDecodableShape {
        /// For SCTE35_ENHANCED output, defines a key. MediaTailor takes this key, and its associated value, and generates the key/value pair within the EXT-X-ASSETtag. If you specify a key, you must also specify a corresponding value.
        public let key: String
        /// For SCTE35_ENHANCED output, defines a value. MediaTailor; takes this value, and its associated key, and generates the key/value pair within the EXT-X-ASSETtag. If you specify a value, you must also specify a corresponding key.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ListAlertsRequest: AWSEncodableShape {
        /// The maximum number of alerts that you want MediaTailor to return in response to the current request. If there are more than MaxResults alerts, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAlertsResponse: AWSDecodableShape {
        /// A list of alerts that are associated with this resource.
        public let items: [Alert]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [Alert]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// The maximum number of channels that you want MediaTailor to return in response to the current request. If there are more than MaxResults channels, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// A list of channels that are associated with this account.
        public let items: [Channel]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [Channel]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListLiveSourcesRequest: AWSEncodableShape {
        /// The maximum number of live sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults live sources, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?
        /// The name of the source location associated with this Live Sources list.
        public let sourceLocationName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, sourceLocationName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLiveSourcesResponse: AWSDecodableShape {
        /// Lists the live sources.
        public let items: [LiveSource]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [LiveSource]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaybackConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of playback configurations that you want MediaTailor to return in response to the current request. If there are more than MaxResults playback configurations, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPlaybackConfigurationsResponse: AWSDecodableShape {
        /// Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.
        public let items: [PlaybackConfiguration]?
        /// Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [PlaybackConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListPrefetchSchedulesRequest: AWSEncodableShape {
        /// The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// (Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results. For the first ListPrefetchSchedulesRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.
        public let nextToken: String?
        /// Retrieves the prefetch schedule(s) for a specific playback configuration.
        public let playbackConfigurationName: String
        /// An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.
        public let streamId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, playbackConfigurationName: String, streamId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.playbackConfigurationName = playbackConfigurationName
            self.streamId = streamId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.playbackConfigurationName, key: "PlaybackConfigurationName")
            try container.encodeIfPresent(self.streamId, forKey: .streamId)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case streamId = "StreamId"
        }
    }

    public struct ListPrefetchSchedulesResponse: AWSDecodableShape {
        /// Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.
        public let items: [PrefetchSchedule]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [PrefetchSchedule]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListSourceLocationsRequest: AWSEncodableShape {
        ///  The maximum number of source locations that you want MediaTailor to return in response to the current request. If there are more than MaxResults source locations, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSourceLocationsResponse: AWSDecodableShape {
        /// A list of source locations.
        public let items: [SourceLocation]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [SourceLocation]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with this resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with this resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListVodSourcesRequest: AWSEncodableShape {
        ///  The maximum number of VOD sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults VOD sources, use the value of NextToken in the response to get the next page of results.
        public let maxResults: Int?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?
        /// The name of the source location associated with this VOD Source list.
        public let sourceLocationName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, sourceLocationName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVodSourcesResponse: AWSDecodableShape {
        /// Lists the VOD sources.
        public let items: [VodSource]?
        /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [VodSource]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct LivePreRollConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
        public let adDecisionServerUrl: String?
        /// The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
        public let maxDurationSeconds: Int?

        public init(adDecisionServerUrl: String? = nil, maxDurationSeconds: Int? = nil) {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.maxDurationSeconds = maxDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adDecisionServerUrl = "AdDecisionServerUrl"
            case maxDurationSeconds = "MaxDurationSeconds"
        }
    }

    public struct LiveSource: AWSDecodableShape {
        /// The ARN for the live source.
        public let arn: String
        /// The timestamp that indicates when the live source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The HTTP package configurations for the live source.
        public let httpPackageConfigurations: [HttpPackageConfiguration]
        /// The timestamp that indicates when the live source was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name that's used to refer to a live source.
        public let liveSourceName: String
        /// The name of the source location.
        public let sourceLocationName: String
        /// The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(arn: String, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration], lastModifiedTime: Date? = nil, liveSourceName: String, sourceLocationName: String, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case liveSourceName = "LiveSourceName"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct LogConfiguration: AWSDecodableShape {
        /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the debug log mode. Valid values: 0 - 100
        public let percentEnabled: Int

        public init(percentEnabled: Int) {
            self.percentEnabled = percentEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case percentEnabled = "PercentEnabled"
        }
    }

    public struct LogConfigurationForChannel: AWSDecodableShape {
        /// The log types.
        public let logTypes: [LogType]?

        public init(logTypes: [LogType]? = nil) {
            self.logTypes = logTypes
        }

        private enum CodingKeys: String, CodingKey {
            case logTypes = "LogTypes"
        }
    }

    public struct ManifestProcessingRules: AWSEncodableShape & AWSDecodableShape {
        /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
        public let adMarkerPassthrough: AdMarkerPassthrough?

        public init(adMarkerPassthrough: AdMarkerPassthrough? = nil) {
            self.adMarkerPassthrough = adMarkerPassthrough
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkerPassthrough = "AdMarkerPassthrough"
        }
    }

    public struct PlaybackConfiguration: AWSDecodableShape {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
        public let adDecisionServerUrl: String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression.
        public let availSuppression: AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers.
        public let bumper: Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public let cdnConfiguration: CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see Domain Variables.
        public let configurationAliases: [String: [String: String]]?
        /// The configuration for a DASH source.
        public let dashConfiguration: DashConfiguration?
        /// The configuration for HLS content.
        public let hlsConfiguration: HlsConfiguration?
        /// The configuration for pre-roll ad insertion.
        public let livePreRollConfiguration: LivePreRollConfiguration?
        /// The Amazon CloudWatch log settings for a playback configuration.
        public let logConfiguration: LogConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public let manifestProcessingRules: ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public let name: String?
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see Ad Behavior in AWS Elemental MediaTailor.
        public let personalizationThresholdSeconds: Int?
        /// The Amazon Resource Name (ARN) for the playback configuration.
        public let playbackConfigurationArn: String?
        /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.
        public let playbackEndpointPrefix: String?
        /// The URL that the player uses to initialize a session that uses client-side reporting.
        public let sessionInitializationEndpointPrefix: String?
        /// The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public let slateAdUrl: String?
        /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public let transcodeProfileName: String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public let videoContentSourceUrl: String?

        public init(adDecisionServerUrl: String? = nil, availSuppression: AvailSuppression? = nil, bumper: Bumper? = nil, cdnConfiguration: CdnConfiguration? = nil, configurationAliases: [String: [String: String]]? = nil, dashConfiguration: DashConfiguration? = nil, hlsConfiguration: HlsConfiguration? = nil, livePreRollConfiguration: LivePreRollConfiguration? = nil, logConfiguration: LogConfiguration? = nil, manifestProcessingRules: ManifestProcessingRules? = nil, name: String? = nil, personalizationThresholdSeconds: Int? = nil, playbackConfigurationArn: String? = nil, playbackEndpointPrefix: String? = nil, sessionInitializationEndpointPrefix: String? = nil, slateAdUrl: String? = nil, tags: [String: String]? = nil, transcodeProfileName: String? = nil, videoContentSourceUrl: String? = nil) {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.hlsConfiguration = hlsConfiguration
            self.livePreRollConfiguration = livePreRollConfiguration
            self.logConfiguration = logConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.playbackConfigurationArn = playbackConfigurationArn
            self.playbackEndpointPrefix = playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }

        private enum CodingKeys: String, CodingKey {
            case adDecisionServerUrl = "AdDecisionServerUrl"
            case availSuppression = "AvailSuppression"
            case bumper = "Bumper"
            case cdnConfiguration = "CdnConfiguration"
            case configurationAliases = "ConfigurationAliases"
            case dashConfiguration = "DashConfiguration"
            case hlsConfiguration = "HlsConfiguration"
            case livePreRollConfiguration = "LivePreRollConfiguration"
            case logConfiguration = "LogConfiguration"
            case manifestProcessingRules = "ManifestProcessingRules"
            case name = "Name"
            case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
            case playbackConfigurationArn = "PlaybackConfigurationArn"
            case playbackEndpointPrefix = "PlaybackEndpointPrefix"
            case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
            case slateAdUrl = "SlateAdUrl"
            case tags = "tags"
            case transcodeProfileName = "TranscodeProfileName"
            case videoContentSourceUrl = "VideoContentSourceUrl"
        }
    }

    public struct PrefetchConsumption: AWSEncodableShape & AWSDecodableShape {
        /// If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as scte.event_id, set the avail matching criteria.
        public let availMatchingCriteria: [AvailMatchingCriteria]?
        /// The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call DeletePrefetchSchedule.
        @CustomCoding<UnixEpochDateCoder>
        public var endTime: Date
        /// The time when prefetched ads are considered for use in an ad break. If you don't specify StartTime, the prefetched ads are available after MediaTailor retrives them from the ad decision server.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var startTime: Date?

        public init(availMatchingCriteria: [AvailMatchingCriteria]? = nil, endTime: Date, startTime: Date? = nil) {
            self.availMatchingCriteria = availMatchingCriteria
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case availMatchingCriteria = "AvailMatchingCriteria"
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct PrefetchRetrieval: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS). You initially configure dynamic variables for the ADS URL when you set up your playback configuration. When you specify DynamicVariables for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.
        public let dynamicVariables: [String: String]?
        /// The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.
        @CustomCoding<UnixEpochDateCoder>
        public var endTime: Date
        /// The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var startTime: Date?

        public init(dynamicVariables: [String: String]? = nil, endTime: Date, startTime: Date? = nil) {
            self.dynamicVariables = dynamicVariables
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicVariables = "DynamicVariables"
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct PrefetchSchedule: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prefetch schedule.
        public let arn: String
        /// Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a consumption window. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.
        public let consumption: PrefetchConsumption
        /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
        public let name: String
        /// The name of the playback configuration to create the prefetch schedule for.
        public let playbackConfigurationName: String
        /// A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).
        public let retrieval: PrefetchRetrieval
        /// An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.
        public let streamId: String?

        public init(arn: String, consumption: PrefetchConsumption, name: String, playbackConfigurationName: String, retrieval: PrefetchRetrieval, streamId: String? = nil) {
            self.arn = arn
            self.consumption = consumption
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
            self.retrieval = retrieval
            self.streamId = streamId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case consumption = "Consumption"
            case name = "Name"
            case playbackConfigurationName = "PlaybackConfigurationName"
            case retrieval = "Retrieval"
            case streamId = "StreamId"
        }
    }

    public struct PutChannelPolicyRequest: AWSEncodableShape {
        /// The channel name associated with this Channel Policy.
        public let channelName: String
        /// Adds an IAM role that determines the permissions of your channel.
        public let policy: String

        public init(channelName: String, policy: String) {
            self.channelName = channelName
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encode(self.policy, forKey: .policy)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutChannelPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutPlaybackConfigurationRequest: AWSEncodableShape {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
        public let adDecisionServerUrl: String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression.
        public let availSuppression: AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers.
        public let bumper: Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public let cdnConfiguration: CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see Domain Variables.
        public let configurationAliases: [String: [String: String]]?
        /// The configuration for DASH content.
        public let dashConfiguration: DashConfigurationForPut?
        /// The configuration for pre-roll ad insertion.
        public let livePreRollConfiguration: LivePreRollConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public let manifestProcessingRules: ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public let name: String
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see Ad Behavior in AWS Elemental MediaTailor.
        public let personalizationThresholdSeconds: Int?
        /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public let slateAdUrl: String?
        /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public let transcodeProfileName: String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public let videoContentSourceUrl: String?

        public init(adDecisionServerUrl: String? = nil, availSuppression: AvailSuppression? = nil, bumper: Bumper? = nil, cdnConfiguration: CdnConfiguration? = nil, configurationAliases: [String: [String: String]]? = nil, dashConfiguration: DashConfigurationForPut? = nil, livePreRollConfiguration: LivePreRollConfiguration? = nil, manifestProcessingRules: ManifestProcessingRules? = nil, name: String, personalizationThresholdSeconds: Int? = nil, slateAdUrl: String? = nil, tags: [String: String]? = nil, transcodeProfileName: String? = nil, videoContentSourceUrl: String? = nil) {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.livePreRollConfiguration = livePreRollConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.personalizationThresholdSeconds, name: "personalizationThresholdSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case adDecisionServerUrl = "AdDecisionServerUrl"
            case availSuppression = "AvailSuppression"
            case bumper = "Bumper"
            case cdnConfiguration = "CdnConfiguration"
            case configurationAliases = "ConfigurationAliases"
            case dashConfiguration = "DashConfiguration"
            case livePreRollConfiguration = "LivePreRollConfiguration"
            case manifestProcessingRules = "ManifestProcessingRules"
            case name = "Name"
            case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
            case slateAdUrl = "SlateAdUrl"
            case tags = "tags"
            case transcodeProfileName = "TranscodeProfileName"
            case videoContentSourceUrl = "VideoContentSourceUrl"
        }
    }

    public struct PutPlaybackConfigurationResponse: AWSDecodableShape {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
        public let adDecisionServerUrl: String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression.
        public let availSuppression: AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers.
        public let bumper: Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public let cdnConfiguration: CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see Domain Variables.
        public let configurationAliases: [String: [String: String]]?
        /// The configuration for DASH content.
        public let dashConfiguration: DashConfiguration?
        /// The configuration for HLS content.
        public let hlsConfiguration: HlsConfiguration?
        /// The configuration for pre-roll ad insertion.
        public let livePreRollConfiguration: LivePreRollConfiguration?
        /// The Amazon CloudWatch log settings for a playback configuration.
        public let logConfiguration: LogConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public let manifestProcessingRules: ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public let name: String?
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see Ad Behavior in AWS Elemental MediaTailor.
        public let personalizationThresholdSeconds: Int?
        /// The Amazon Resource Name (ARN) associated with the playback configuration.
        public let playbackConfigurationArn: String?
        /// The playback endpoint prefix associated with the playback configuration.
        public let playbackEndpointPrefix: String?
        /// The session initialization endpoint prefix associated with the playback configuration.
        public let sessionInitializationEndpointPrefix: String?
        /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public let slateAdUrl: String?
        /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public let transcodeProfileName: String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public let videoContentSourceUrl: String?

        public init(adDecisionServerUrl: String? = nil, availSuppression: AvailSuppression? = nil, bumper: Bumper? = nil, cdnConfiguration: CdnConfiguration? = nil, configurationAliases: [String: [String: String]]? = nil, dashConfiguration: DashConfiguration? = nil, hlsConfiguration: HlsConfiguration? = nil, livePreRollConfiguration: LivePreRollConfiguration? = nil, logConfiguration: LogConfiguration? = nil, manifestProcessingRules: ManifestProcessingRules? = nil, name: String? = nil, personalizationThresholdSeconds: Int? = nil, playbackConfigurationArn: String? = nil, playbackEndpointPrefix: String? = nil, sessionInitializationEndpointPrefix: String? = nil, slateAdUrl: String? = nil, tags: [String: String]? = nil, transcodeProfileName: String? = nil, videoContentSourceUrl: String? = nil) {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.hlsConfiguration = hlsConfiguration
            self.livePreRollConfiguration = livePreRollConfiguration
            self.logConfiguration = logConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.playbackConfigurationArn = playbackConfigurationArn
            self.playbackEndpointPrefix = playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }

        private enum CodingKeys: String, CodingKey {
            case adDecisionServerUrl = "AdDecisionServerUrl"
            case availSuppression = "AvailSuppression"
            case bumper = "Bumper"
            case cdnConfiguration = "CdnConfiguration"
            case configurationAliases = "ConfigurationAliases"
            case dashConfiguration = "DashConfiguration"
            case hlsConfiguration = "HlsConfiguration"
            case livePreRollConfiguration = "LivePreRollConfiguration"
            case logConfiguration = "LogConfiguration"
            case manifestProcessingRules = "ManifestProcessingRules"
            case name = "Name"
            case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
            case playbackConfigurationArn = "PlaybackConfigurationArn"
            case playbackEndpointPrefix = "PlaybackEndpointPrefix"
            case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
            case slateAdUrl = "SlateAdUrl"
            case tags = "tags"
            case transcodeProfileName = "TranscodeProfileName"
            case videoContentSourceUrl = "VideoContentSourceUrl"
        }
    }

    public struct RequestOutputItem: AWSEncodableShape {
        /// DASH manifest configuration parameters.
        public let dashPlaylistSettings: DashPlaylistSettings?
        /// HLS playlist configuration parameters.
        public let hlsPlaylistSettings: HlsPlaylistSettings?
        /// The name of the manifest for the channel. The name appears in the PlaybackUrl.
        public let manifestName: String
        /// A string used to match which HttpPackageConfiguration is used for each VodSource.
        public let sourceGroup: String

        public init(dashPlaylistSettings: DashPlaylistSettings? = nil, hlsPlaylistSettings: HlsPlaylistSettings? = nil, manifestName: String, sourceGroup: String) {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.sourceGroup = sourceGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dashPlaylistSettings = "DashPlaylistSettings"
            case hlsPlaylistSettings = "HlsPlaylistSettings"
            case manifestName = "ManifestName"
            case sourceGroup = "SourceGroup"
        }
    }

    public struct ResponseOutputItem: AWSDecodableShape {
        /// DASH manifest configuration settings.
        public let dashPlaylistSettings: DashPlaylistSettings?
        /// HLS manifest configuration settings.
        public let hlsPlaylistSettings: HlsPlaylistSettings?
        /// The name of the manifest for the channel that will appear in the channel output's playback URL.
        public let manifestName: String
        /// The URL used for playback by content players.
        public let playbackUrl: String
        /// A string used to associate a package configuration source group with a channel output.
        public let sourceGroup: String

        public init(dashPlaylistSettings: DashPlaylistSettings? = nil, hlsPlaylistSettings: HlsPlaylistSettings? = nil, manifestName: String, playbackUrl: String, sourceGroup: String) {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.playbackUrl = playbackUrl
            self.sourceGroup = sourceGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dashPlaylistSettings = "DashPlaylistSettings"
            case hlsPlaylistSettings = "HlsPlaylistSettings"
            case manifestName = "ManifestName"
            case playbackUrl = "PlaybackUrl"
            case sourceGroup = "SourceGroup"
        }
    }

    public struct ScheduleAdBreak: AWSDecodableShape {
        /// The approximate duration of the ad break, in seconds.
        public let approximateDurationSeconds: Int64?
        /// The approximate time that the ad will start playing.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var approximateStartTime: Date?
        /// The name of the source location containing the VOD source used for the ad break.
        public let sourceLocationName: String?
        /// The name of the VOD source used for the ad break.
        public let vodSourceName: String?

        public init(approximateDurationSeconds: Int64? = nil, approximateStartTime: Date? = nil, sourceLocationName: String? = nil, vodSourceName: String? = nil) {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case approximateDurationSeconds = "ApproximateDurationSeconds"
            case approximateStartTime = "ApproximateStartTime"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape {
        /// Program clip range configuration.
        public let clipRange: ClipRange?
        /// Program transition configurations.
        public let transition: Transition

        public init(clipRange: ClipRange? = nil, transition: Transition) {
            self.clipRange = clipRange
            self.transition = transition
        }

        private enum CodingKeys: String, CodingKey {
            case clipRange = "ClipRange"
            case transition = "Transition"
        }
    }

    public struct ScheduleEntry: AWSDecodableShape {
        /// The approximate duration of this program, in seconds.
        public let approximateDurationSeconds: Int64?
        /// The approximate time that the program will start playing.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var approximateStartTime: Date?
        /// The ARN of the program.
        public let arn: String
        /// The list of audiences defined in ScheduleEntry.
        public let audiences: [String]?
        /// The name of the channel that uses this schedule.
        public let channelName: String
        /// The name of the live source used for the program.
        public let liveSourceName: String?
        /// The name of the program.
        public let programName: String
        /// The schedule's ad break properties.
        public let scheduleAdBreaks: [ScheduleAdBreak]?
        /// The type of schedule entry.
        public let scheduleEntryType: ScheduleEntryType?
        /// The name of the source location.
        public let sourceLocationName: String
        /// The name of the VOD source.
        public let vodSourceName: String?

        public init(approximateDurationSeconds: Int64? = nil, approximateStartTime: Date? = nil, arn: String, audiences: [String]? = nil, channelName: String, liveSourceName: String? = nil, programName: String, scheduleAdBreaks: [ScheduleAdBreak]? = nil, scheduleEntryType: ScheduleEntryType? = nil, sourceLocationName: String, vodSourceName: String? = nil) {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduleAdBreaks = scheduleAdBreaks
            self.scheduleEntryType = scheduleEntryType
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case approximateDurationSeconds = "ApproximateDurationSeconds"
            case approximateStartTime = "ApproximateStartTime"
            case arn = "Arn"
            case audiences = "Audiences"
            case channelName = "ChannelName"
            case liveSourceName = "LiveSourceName"
            case programName = "ProgramName"
            case scheduleAdBreaks = "ScheduleAdBreaks"
            case scheduleEntryType = "ScheduleEntryType"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct SecretsManagerAccessTokenConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the HTTP header used to supply the access token in requests to the source location.
        public let headerName: String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.
        public let secretArn: String?
        /// The AWS Secrets Manager SecretString key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.
        public let secretStringKey: String?

        public init(headerName: String? = nil, secretArn: String? = nil, secretStringKey: String? = nil) {
            self.headerName = headerName
            self.secretArn = secretArn
            self.secretStringKey = secretStringKey
        }

        private enum CodingKeys: String, CodingKey {
            case headerName = "HeaderName"
            case secretArn = "SecretArn"
            case secretStringKey = "SecretStringKey"
        }
    }

    public struct SegmentDeliveryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as https://example.com/some/path. To use a relative URL specify the relative path, such as /some/path*.
        public let baseUrl: String?
        /// A unique identifier used to distinguish between multiple segment delivery configurations in a source location.
        public let name: String?

        public init(baseUrl: String? = nil, name: String? = nil) {
            self.baseUrl = baseUrl
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case baseUrl = "BaseUrl"
            case name = "Name"
        }
    }

    public struct SegmentationDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// The Event Identifier to assign to the segmentation_descriptor.segmentation_event_id message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.
        public let segmentationEventId: Int?
        /// The Type Identifier to assign to the segmentation_descriptor.segmentation_type_id message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.
        public let segmentationTypeId: Int?
        /// The Upid to assign to the segmentation_descriptor.segmentation_upid message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).
        public let segmentationUpid: String?
        /// The Upid Type to assign to the segmentation_descriptor.segmentation_upid_type message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.
        public let segmentationUpidType: Int?
        /// The segment number to assign to the segmentation_descriptor.segment_num message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.
        public let segmentNum: Int?
        /// The number of segments expected, which is assigned to the segmentation_descriptor.segments_expectedS message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.
        public let segmentsExpected: Int?
        /// The sub-segment number to assign to the segmentation_descriptor.sub_segment_num message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.
        public let subSegmentNum: Int?
        /// The number of sub-segments expected, which is assigned to the segmentation_descriptor.sub_segments_expected message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.
        public let subSegmentsExpected: Int?

        public init(segmentationEventId: Int? = nil, segmentationTypeId: Int? = nil, segmentationUpid: String? = nil, segmentationUpidType: Int? = nil, segmentNum: Int? = nil, segmentsExpected: Int? = nil, subSegmentNum: Int? = nil, subSegmentsExpected: Int? = nil) {
            self.segmentationEventId = segmentationEventId
            self.segmentationTypeId = segmentationTypeId
            self.segmentationUpid = segmentationUpid
            self.segmentationUpidType = segmentationUpidType
            self.segmentNum = segmentNum
            self.segmentsExpected = segmentsExpected
            self.subSegmentNum = subSegmentNum
            self.subSegmentsExpected = subSegmentsExpected
        }

        private enum CodingKeys: String, CodingKey {
            case segmentationEventId = "SegmentationEventId"
            case segmentationTypeId = "SegmentationTypeId"
            case segmentationUpid = "SegmentationUpid"
            case segmentationUpidType = "SegmentationUpidType"
            case segmentNum = "SegmentNum"
            case segmentsExpected = "SegmentsExpected"
            case subSegmentNum = "SubSegmentNum"
            case subSegmentsExpected = "SubSegmentsExpected"
        }
    }

    public struct SlateSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the source location where the slate VOD source is stored.
        public let sourceLocationName: String?
        /// The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.
        public let vodSourceName: String?

        public init(sourceLocationName: String? = nil, vodSourceName: String? = nil) {
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct SourceLocation: AWSDecodableShape {
        /// The access configuration for the source location.
        public let accessConfiguration: AccessConfiguration?
        /// The ARN of the SourceLocation.
        public let arn: String
        /// The timestamp that indicates when the source location was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The default segment delivery configuration.
        public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
        /// The HTTP configuration for the source location.
        public let httpConfiguration: HttpConfiguration
        /// The timestamp that indicates when the source location was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The segment delivery configurations for the source location.
        public let segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]?
        /// The name of the source location.
        public let sourceLocationName: String
        /// The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(accessConfiguration: AccessConfiguration? = nil, arn: String, creationTime: Date? = nil, defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil, httpConfiguration: HttpConfiguration, lastModifiedTime: Date? = nil, segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil, sourceLocationName: String, tags: [String: String]? = nil) {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "AccessConfiguration"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
            case httpConfiguration = "HttpConfiguration"
            case lastModifiedTime = "LastModifiedTime"
            case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct SpliceInsertMessage: AWSEncodableShape & AWSDecodableShape {
        /// This is written to splice_insert.avail_num, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public let availNum: Int?
        /// This is written to splice_insert.avails_expected, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public let availsExpected: Int?
        /// This is written to splice_insert.splice_event_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 1.
        public let spliceEventId: Int?
        /// This is written to splice_insert.unique_program_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public let uniqueProgramId: Int?

        public init(availNum: Int? = nil, availsExpected: Int? = nil, spliceEventId: Int? = nil, uniqueProgramId: Int? = nil) {
            self.availNum = availNum
            self.availsExpected = availsExpected
            self.spliceEventId = spliceEventId
            self.uniqueProgramId = uniqueProgramId
        }

        private enum CodingKeys: String, CodingKey {
            case availNum = "AvailNum"
            case availsExpected = "AvailsExpected"
            case spliceEventId = "SpliceEventId"
            case uniqueProgramId = "UniqueProgramId"
        }
    }

    public struct StartChannelRequest: AWSEncodableShape {
        /// The name of the channel.
        public let channelName: String

        public init(channelName: String) {
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopChannelRequest: AWSEncodableShape {
        /// The name of the channel.
        public let channelName: String

        public init(channelName: String) {
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelName, key: "ChannelName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let resourceArn: String
        /// The tags to assign to the resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TimeShiftConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum time delay for time-shifted viewing. The minimum allowed maximum time delay is 0 seconds,  and the maximum allowed maximum time delay is 21600 seconds (6 hours).
        public let maxTimeDelaySeconds: Int

        public init(maxTimeDelaySeconds: Int) {
            self.maxTimeDelaySeconds = maxTimeDelaySeconds
        }

        private enum CodingKeys: String, CodingKey {
            case maxTimeDelaySeconds = "MaxTimeDelaySeconds"
        }
    }

    public struct TimeSignalMessage: AWSEncodableShape & AWSDecodableShape {
        /// The configurations for the SCTE-35 segmentation_descriptor message(s) sent with the time_signal message.
        public let segmentationDescriptors: [SegmentationDescriptor]?

        public init(segmentationDescriptors: [SegmentationDescriptor]? = nil) {
            self.segmentationDescriptors = segmentationDescriptors
        }

        private enum CodingKeys: String, CodingKey {
            case segmentationDescriptors = "SegmentationDescriptors"
        }
    }

    public struct Transition: AWSEncodableShape {
        /// The duration of the live program in seconds.
        public let durationMillis: Int64?
        /// The position where this program will be inserted relative to the RelativePosition.
        public let relativePosition: RelativePosition
        /// The name of the program that this program will be inserted next to, as defined by RelativePosition.
        public let relativeProgram: String?
        /// The date and time that the program is scheduled to start, in epoch milliseconds.
        public let scheduledStartTimeMillis: Int64?
        /// Defines when the program plays in the schedule. You can set the value to ABSOLUTE or RELATIVE.  ABSOLUTE - The program plays at a specific wall clock time. This setting can only be used for channels using the LINEAR PlaybackMode. Note the following considerations when using ABSOLUTE transitions: If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary. If there are gaps in playback, MediaTailor plays the FillerSlate you configured for your linear channel.  RELATIVE - The program is inserted into the schedule either before or after a program that you specify via RelativePosition.
        public let type: String

        public init(durationMillis: Int64? = nil, relativePosition: RelativePosition, relativeProgram: String? = nil, scheduledStartTimeMillis: Int64? = nil, type: String) {
            self.durationMillis = durationMillis
            self.relativePosition = relativePosition
            self.relativeProgram = relativeProgram
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case durationMillis = "DurationMillis"
            case relativePosition = "RelativePosition"
            case relativeProgram = "RelativeProgram"
            case scheduledStartTimeMillis = "ScheduledStartTimeMillis"
            case type = "Type"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to untag.
        public let resourceArn: String
        /// The tag keys associated with the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        /// The list of audiences defined in channel.
        public let audiences: [String]?
        /// The name of the channel.
        public let channelName: String
        /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEAR PlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOP PlaybackMode.
        public let fillerSlate: SlateSource?
        /// The channel's output properties.
        public let outputs: [RequestOutputItem]
        ///  The time-shifted viewing configuration you want to associate to the channel.
        public let timeShiftConfiguration: TimeShiftConfiguration?

        public init(audiences: [String]? = nil, channelName: String, fillerSlate: SlateSource? = nil, outputs: [RequestOutputItem], timeShiftConfiguration: TimeShiftConfiguration? = nil) {
            self.audiences = audiences
            self.channelName = channelName
            self.fillerSlate = fillerSlate
            self.outputs = outputs
            self.timeShiftConfiguration = timeShiftConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.audiences, forKey: .audiences)
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encodeIfPresent(self.fillerSlate, forKey: .fillerSlate)
            try container.encode(self.outputs, forKey: .outputs)
            try container.encodeIfPresent(self.timeShiftConfiguration, forKey: .timeShiftConfiguration)
        }

        private enum CodingKeys: String, CodingKey {
            case audiences = "Audiences"
            case fillerSlate = "FillerSlate"
            case outputs = "Outputs"
            case timeShiftConfiguration = "TimeShiftConfiguration"
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the channel.
        public let arn: String?
        /// The list of audiences defined in channel.
        public let audiences: [String]?
        /// The name of the channel.
        public let channelName: String?
        /// Returns the state whether the channel is running or not.
        public let channelState: ChannelState?
        /// The timestamp of when the channel was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEAR PlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOP PlaybackMode.
        public let fillerSlate: SlateSource?
        /// The timestamp that indicates when the channel was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The channel's output properties.
        public let outputs: [ResponseOutputItem]?
        /// The type of playback mode for this channel.  LINEAR - Programs play back-to-back only once.  LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
        public let playbackMode: String?
        /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The tier associated with this Channel.
        public let tier: String?
        ///  The time-shifted viewing configuration for the channel.
        public let timeShiftConfiguration: TimeShiftConfiguration?

        public init(arn: String? = nil, audiences: [String]? = nil, channelName: String? = nil, channelState: ChannelState? = nil, creationTime: Date? = nil, fillerSlate: SlateSource? = nil, lastModifiedTime: Date? = nil, outputs: [ResponseOutputItem]? = nil, playbackMode: String? = nil, tags: [String: String]? = nil, tier: String? = nil, timeShiftConfiguration: TimeShiftConfiguration? = nil) {
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
            self.timeShiftConfiguration = timeShiftConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case audiences = "Audiences"
            case channelName = "ChannelName"
            case channelState = "ChannelState"
            case creationTime = "CreationTime"
            case fillerSlate = "FillerSlate"
            case lastModifiedTime = "LastModifiedTime"
            case outputs = "Outputs"
            case playbackMode = "PlaybackMode"
            case tags = "tags"
            case tier = "Tier"
            case timeShiftConfiguration = "TimeShiftConfiguration"
        }
    }

    public struct UpdateLiveSourceRequest: AWSEncodableShape {
        /// A list of HTTP package configurations for the live source on this account.
        public let httpPackageConfigurations: [HttpPackageConfiguration]
        /// The name of the live source.
        public let liveSourceName: String
        /// The name of the source location associated with this Live Source.
        public let sourceLocationName: String

        public init(httpPackageConfigurations: [HttpPackageConfiguration], liveSourceName: String, sourceLocationName: String) {
            self.httpPackageConfigurations = httpPackageConfigurations
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.httpPackageConfigurations, forKey: .httpPackageConfigurations)
            request.encodePath(self.liveSourceName, key: "LiveSourceName")
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPackageConfigurations = "HttpPackageConfigurations"
        }
    }

    public struct UpdateLiveSourceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with this live source.
        public let arn: String?
        /// The timestamp that indicates when the live source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// A list of HTTP package configurations for the live source on this account.
        public let httpPackageConfigurations: [HttpPackageConfiguration]?
        /// The timestamp that indicates when the live source was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name of the live source.
        public let liveSourceName: String?
        /// The name of the source location associated with the live source.
        public let sourceLocationName: String?
        /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration]? = nil, lastModifiedTime: Date? = nil, liveSourceName: String? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case liveSourceName = "LiveSourceName"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct UpdateProgramRequest: AWSEncodableShape {
        /// The ad break configuration settings.
        public let adBreaks: [AdBreak]?
        /// The list of AudienceMedia defined in program.
        public let audienceMedia: [AudienceMedia]?
        /// The name of the channel for this Program.
        public let channelName: String
        /// The name of the Program.
        public let programName: String
        /// The schedule configuration settings.
        public let scheduleConfiguration: UpdateProgramScheduleConfiguration

        public init(adBreaks: [AdBreak]? = nil, audienceMedia: [AudienceMedia]? = nil, channelName: String, programName: String, scheduleConfiguration: UpdateProgramScheduleConfiguration) {
            self.adBreaks = adBreaks
            self.audienceMedia = audienceMedia
            self.channelName = channelName
            self.programName = programName
            self.scheduleConfiguration = scheduleConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.adBreaks, forKey: .adBreaks)
            try container.encodeIfPresent(self.audienceMedia, forKey: .audienceMedia)
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.programName, key: "ProgramName")
            try container.encode(self.scheduleConfiguration, forKey: .scheduleConfiguration)
        }

        private enum CodingKeys: String, CodingKey {
            case adBreaks = "AdBreaks"
            case audienceMedia = "AudienceMedia"
            case scheduleConfiguration = "ScheduleConfiguration"
        }
    }

    public struct UpdateProgramResponse: AWSDecodableShape {
        /// The ad break configuration settings.
        public let adBreaks: [AdBreak]?
        /// The ARN to assign to the program.
        public let arn: String?
        /// The list of AudienceMedia defined in program.
        public let audienceMedia: [AudienceMedia]?
        /// The name to assign to the channel for this program.
        public let channelName: String?
        /// The clip range configuration settings.
        public let clipRange: ClipRange?
        /// The time the program was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The duration of the live program in milliseconds.
        public let durationMillis: Int64?
        /// The name of the LiveSource for this Program.
        public let liveSourceName: String?
        /// The name to assign to this program.
        public let programName: String?
        /// The scheduled start time for this Program.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var scheduledStartTime: Date?
        /// The name to assign to the source location for this program.
        public let sourceLocationName: String?
        /// The name that's used to refer to a VOD source.
        public let vodSourceName: String?

        public init(adBreaks: [AdBreak]? = nil, arn: String? = nil, audienceMedia: [AudienceMedia]? = nil, channelName: String? = nil, clipRange: ClipRange? = nil, creationTime: Date? = nil, durationMillis: Int64? = nil, liveSourceName: String? = nil, programName: String? = nil, scheduledStartTime: Date? = nil, sourceLocationName: String? = nil, vodSourceName: String? = nil) {
            self.adBreaks = adBreaks
            self.arn = arn
            self.audienceMedia = audienceMedia
            self.channelName = channelName
            self.clipRange = clipRange
            self.creationTime = creationTime
            self.durationMillis = durationMillis
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduledStartTime = scheduledStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case adBreaks = "AdBreaks"
            case arn = "Arn"
            case audienceMedia = "AudienceMedia"
            case channelName = "ChannelName"
            case clipRange = "ClipRange"
            case creationTime = "CreationTime"
            case durationMillis = "DurationMillis"
            case liveSourceName = "LiveSourceName"
            case programName = "ProgramName"
            case scheduledStartTime = "ScheduledStartTime"
            case sourceLocationName = "SourceLocationName"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct UpdateProgramScheduleConfiguration: AWSEncodableShape {
        /// Program clip range configuration.
        public let clipRange: ClipRange?
        /// Program transition configuration.
        public let transition: UpdateProgramTransition?

        public init(clipRange: ClipRange? = nil, transition: UpdateProgramTransition? = nil) {
            self.clipRange = clipRange
            self.transition = transition
        }

        private enum CodingKeys: String, CodingKey {
            case clipRange = "ClipRange"
            case transition = "Transition"
        }
    }

    public struct UpdateProgramTransition: AWSEncodableShape {
        /// The duration of the live program in seconds.
        public let durationMillis: Int64?
        /// The date and time that the program is scheduled to start, in epoch milliseconds.
        public let scheduledStartTimeMillis: Int64?

        public init(durationMillis: Int64? = nil, scheduledStartTimeMillis: Int64? = nil) {
            self.durationMillis = durationMillis
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
        }

        private enum CodingKeys: String, CodingKey {
            case durationMillis = "DurationMillis"
            case scheduledStartTimeMillis = "ScheduledStartTimeMillis"
        }
    }

    public struct UpdateSourceLocationRequest: AWSEncodableShape {
        /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
        public let accessConfiguration: AccessConfiguration?
        /// The optional configuration for the host server that serves segments.
        public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
        /// The HTTP configuration for the source location.
        public let httpConfiguration: HttpConfiguration
        /// A list of the segment delivery configurations associated with this resource.
        public let segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]?
        /// The name of the source location.
        public let sourceLocationName: String

        public init(accessConfiguration: AccessConfiguration? = nil, defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil, httpConfiguration: HttpConfiguration, segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil, sourceLocationName: String) {
            self.accessConfiguration = accessConfiguration
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accessConfiguration, forKey: .accessConfiguration)
            try container.encodeIfPresent(self.defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
            try container.encode(self.httpConfiguration, forKey: .httpConfiguration)
            try container.encodeIfPresent(self.segmentDeliveryConfigurations, forKey: .segmentDeliveryConfigurations)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "AccessConfiguration"
            case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
            case httpConfiguration = "HttpConfiguration"
            case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        }
    }

    public struct UpdateSourceLocationResponse: AWSDecodableShape {
        /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
        public let accessConfiguration: AccessConfiguration?
        /// The Amazon Resource Name (ARN) associated with the source location.
        public let arn: String?
        /// The timestamp that indicates when the source location was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The optional configuration for the host server that serves segments.
        public let defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration?
        /// The HTTP configuration for the source location.
        public let httpConfiguration: HttpConfiguration?
        /// The timestamp that indicates when the source location was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The segment delivery configurations for the source location. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
        public let segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]?
        /// The name of the source location.
        public let sourceLocationName: String?
        /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?

        public init(accessConfiguration: AccessConfiguration? = nil, arn: String? = nil, creationTime: Date? = nil, defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil, httpConfiguration: HttpConfiguration? = nil, lastModifiedTime: Date? = nil, segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil) {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "AccessConfiguration"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
            case httpConfiguration = "HttpConfiguration"
            case lastModifiedTime = "LastModifiedTime"
            case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
        }
    }

    public struct UpdateVodSourceRequest: AWSEncodableShape {
        /// A list of HTTP package configurations for the VOD source on this account.
        public let httpPackageConfigurations: [HttpPackageConfiguration]
        /// The name of the source location associated with this VOD Source.
        public let sourceLocationName: String
        /// The name of the VOD source.
        public let vodSourceName: String

        public init(httpPackageConfigurations: [HttpPackageConfiguration], sourceLocationName: String, vodSourceName: String) {
            self.httpPackageConfigurations = httpPackageConfigurations
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.httpPackageConfigurations, forKey: .httpPackageConfigurations)
            request.encodePath(self.sourceLocationName, key: "SourceLocationName")
            request.encodePath(self.vodSourceName, key: "VodSourceName")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPackageConfigurations = "HttpPackageConfigurations"
        }
    }

    public struct UpdateVodSourceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the VOD source.
        public let arn: String?
        /// The timestamp that indicates when the VOD source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// A list of HTTP package configurations for the VOD source on this account.
        public let httpPackageConfigurations: [HttpPackageConfiguration]?
        /// The timestamp that indicates when the VOD source was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name of the source location associated with the VOD source.
        public let sourceLocationName: String?
        /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name of the VOD source.
        public let vodSourceName: String?

        public init(arn: String? = nil, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration]? = nil, lastModifiedTime: Date? = nil, sourceLocationName: String? = nil, tags: [String: String]? = nil, vodSourceName: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
            case vodSourceName = "VodSourceName"
        }
    }

    public struct VodSource: AWSDecodableShape {
        /// The ARN for the VOD source.
        public let arn: String
        /// The timestamp that indicates when the VOD source was created.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var creationTime: Date?
        /// The HTTP package configurations for the VOD source.
        public let httpPackageConfigurations: [HttpPackageConfiguration]
        /// The timestamp that indicates when the VOD source was last modified.
        @OptionalCustomCoding<UnixEpochDateCoder>
        public var lastModifiedTime: Date?
        /// The name of the source location that the VOD source is associated with.
        public let sourceLocationName: String
        /// The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
        public let tags: [String: String]?
        /// The name of the VOD source.
        public let vodSourceName: String

        public init(arn: String, creationTime: Date? = nil, httpPackageConfigurations: [HttpPackageConfiguration], lastModifiedTime: Date? = nil, sourceLocationName: String, tags: [String: String]? = nil, vodSourceName: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case httpPackageConfigurations = "HttpPackageConfigurations"
            case lastModifiedTime = "LastModifiedTime"
            case sourceLocationName = "SourceLocationName"
            case tags = "tags"
            case vodSourceName = "VodSourceName"
        }
    }
}

// MARK: - Errors

/// Error enum for MediaTailor
public struct MediaTailorErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MediaTailor
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// A request contains unexpected data.
    public static var badRequestException: Self { .init(.badRequestException) }
}

extension MediaTailorErrorType: Equatable {
    public static func == (lhs: MediaTailorErrorType, rhs: MediaTailorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MediaTailorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
