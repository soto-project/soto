//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS MediaTailor service.
///
/// Use the AWS Elemental MediaTailor SDKs and CLI to configure scalable ad insertion and linear channels. With MediaTailor, you can assemble existing content into a linear stream and serve targeted ads to viewers while maintaining broadcast quality in over-the-top (OTT) video applications. For information about using the service, including detailed information about the settings covered in this guide, see the AWS Elemental MediaTailor User Guide. Through the SDKs and the CLI you manage AWS Elemental MediaTailor configurations and channels the same as you do through the console. For example, you specify ad insertion behavior and mapping information for the origin server and the ad decision server (ADS).
public struct MediaTailor: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the MediaTailor client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "MediaTailor",
            serviceIdentifier: "api.mediatailor",
            signingName: "mediatailor",
            serviceProtocol: .restjson,
            apiVersion: "2018-04-23",
            endpoint: endpoint,
            errorType: MediaTailorErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Configures Amazon CloudWatch log settings for a channel.
    @Sendable
    @inlinable
    public func configureLogsForChannel(_ input: ConfigureLogsForChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ConfigureLogsForChannelResponse {
        try await self.client.execute(
            operation: "ConfigureLogsForChannel", 
            path: "/configureLogs/channel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Configures Amazon CloudWatch log settings for a channel.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - logTypes: The types of logs to collect.
    ///   - logger: Logger use during operation
    @inlinable
    public func configureLogsForChannel(
        channelName: String,
        logTypes: [LogType],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ConfigureLogsForChannelResponse {
        let input = ConfigureLogsForChannelRequest(
            channelName: channelName, 
            logTypes: logTypes
        )
        return try await self.configureLogsForChannel(input, logger: logger)
    }

    /// Defines where AWS Elemental MediaTailor sends logs for the playback configuration.
    @Sendable
    @inlinable
    public func configureLogsForPlaybackConfiguration(_ input: ConfigureLogsForPlaybackConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ConfigureLogsForPlaybackConfigurationResponse {
        try await self.client.execute(
            operation: "ConfigureLogsForPlaybackConfiguration", 
            path: "/configureLogs/playbackConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Defines where AWS Elemental MediaTailor sends logs for the playback configuration.
    ///
    /// Parameters:
    ///   - adsInteractionLog: The event types that MediaTailor emits in logs for interactions with the ADS.
    ///   - enabledLoggingStrategies: The method used for collecting logs from AWS Elemental MediaTailor. To configure MediaTailor to send logs directly to Amazon CloudWatch Logs, choose LEGACY_CLOUDWATCH. To configure MediaTailor to  send logs to CloudWatch, which then vends the logs to your destination of choice, choose VENDED_LOGS. Supported destinations are CloudWatch Logs log group, Amazon S3 bucket, and Amazon Data Firehose stream. To use vended logs, you must configure the delivery destination in Amazon CloudWatch, as described in Enable logging from AWS services, Logging that requires additional permissions [V2].
    ///   - manifestServiceInteractionLog: The event types that MediaTailor emits in logs for interactions with the origin server.
    ///   - percentEnabled: The percentage of session logs that MediaTailor sends to your CloudWatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the debug log mode. Valid values: 0 - 100
    ///   - playbackConfigurationName: The name of the playback configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func configureLogsForPlaybackConfiguration(
        adsInteractionLog: AdsInteractionLog? = nil,
        enabledLoggingStrategies: [LoggingStrategy]? = nil,
        manifestServiceInteractionLog: ManifestServiceInteractionLog? = nil,
        percentEnabled: Int = 0,
        playbackConfigurationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ConfigureLogsForPlaybackConfigurationResponse {
        let input = ConfigureLogsForPlaybackConfigurationRequest(
            adsInteractionLog: adsInteractionLog, 
            enabledLoggingStrategies: enabledLoggingStrategies, 
            manifestServiceInteractionLog: manifestServiceInteractionLog, 
            percentEnabled: percentEnabled, 
            playbackConfigurationName: playbackConfigurationName
        )
        return try await self.configureLogsForPlaybackConfiguration(input, logger: logger)
    }

    /// Creates a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func createChannel(_ input: CreateChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateChannelResponse {
        try await self.client.execute(
            operation: "CreateChannel", 
            path: "/channel/{ChannelName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - audiences: The list of audiences defined in channel.
    ///   - channelName: The name of the channel.
    ///   - fillerSlate: The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEAR PlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOP PlaybackMode.
    ///   - outputs: The channel's output properties.
    ///   - playbackMode: The type of playback mode to use for this channel.  LINEAR - The programs in the schedule play once back-to-back in the schedule.  LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.
    ///   - tags: The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///   - tier: The tier of the channel.
    ///   - timeShiftConfiguration:  The time-shifted viewing configuration you want to associate to the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func createChannel(
        audiences: [String]? = nil,
        channelName: String,
        fillerSlate: SlateSource? = nil,
        outputs: [RequestOutputItem],
        playbackMode: PlaybackMode,
        tags: [String: String]? = nil,
        tier: Tier? = nil,
        timeShiftConfiguration: TimeShiftConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateChannelResponse {
        let input = CreateChannelRequest(
            audiences: audiences, 
            channelName: channelName, 
            fillerSlate: fillerSlate, 
            outputs: outputs, 
            playbackMode: playbackMode, 
            tags: tags, 
            tier: tier, 
            timeShiftConfiguration: timeShiftConfiguration
        )
        return try await self.createChannel(input, logger: logger)
    }

    /// The live source configuration.
    @Sendable
    @inlinable
    public func createLiveSource(_ input: CreateLiveSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLiveSourceResponse {
        try await self.client.execute(
            operation: "CreateLiveSource", 
            path: "/sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The live source configuration.
    ///
    /// Parameters:
    ///   - httpPackageConfigurations: A list of HTTP package configuration parameters for this live source.
    ///   - liveSourceName: The name of the live source.
    ///   - sourceLocationName: The name of the source location.
    ///   - tags: The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLiveSource(
        httpPackageConfigurations: [HttpPackageConfiguration],
        liveSourceName: String,
        sourceLocationName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLiveSourceResponse {
        let input = CreateLiveSourceRequest(
            httpPackageConfigurations: httpPackageConfigurations, 
            liveSourceName: liveSourceName, 
            sourceLocationName: sourceLocationName, 
            tags: tags
        )
        return try await self.createLiveSource(input, logger: logger)
    }

    /// Creates a prefetch schedule for a playback configuration. A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see Using ad prefetching in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func createPrefetchSchedule(_ input: CreatePrefetchScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePrefetchScheduleResponse {
        try await self.client.execute(
            operation: "CreatePrefetchSchedule", 
            path: "/prefetchSchedule/{PlaybackConfigurationName}/{Name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a prefetch schedule for a playback configuration. A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see Using ad prefetching in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - consumption: The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
    ///   - name: The name to assign to the schedule request.
    ///   - playbackConfigurationName: The name to assign to the playback configuration.
    ///   - retrieval: The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
    ///   - streamId: An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPrefetchSchedule(
        consumption: PrefetchConsumption,
        name: String,
        playbackConfigurationName: String,
        retrieval: PrefetchRetrieval,
        streamId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePrefetchScheduleResponse {
        let input = CreatePrefetchScheduleRequest(
            consumption: consumption, 
            name: name, 
            playbackConfigurationName: playbackConfigurationName, 
            retrieval: retrieval, 
            streamId: streamId
        )
        return try await self.createPrefetchSchedule(input, logger: logger)
    }

    /// Creates a program within a channel. For information about programs, see Working with programs in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func createProgram(_ input: CreateProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProgramResponse {
        try await self.client.execute(
            operation: "CreateProgram", 
            path: "/channel/{ChannelName}/program/{ProgramName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a program within a channel. For information about programs, see Working with programs in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - adBreaks: The ad break configuration settings.
    ///   - audienceMedia: The list of AudienceMedia defined in program.
    ///   - channelName: The name of the channel for this Program.
    ///   - liveSourceName: The name of the LiveSource for this Program.
    ///   - programName: The name of the Program.
    ///   - scheduleConfiguration: The schedule configuration settings.
    ///   - sourceLocationName: The name of the source location.
    ///   - vodSourceName: The name that's used to refer to a VOD source.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProgram(
        adBreaks: [AdBreak]? = nil,
        audienceMedia: [AudienceMedia]? = nil,
        channelName: String,
        liveSourceName: String? = nil,
        programName: String,
        scheduleConfiguration: ScheduleConfiguration,
        sourceLocationName: String,
        vodSourceName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProgramResponse {
        let input = CreateProgramRequest(
            adBreaks: adBreaks, 
            audienceMedia: audienceMedia, 
            channelName: channelName, 
            liveSourceName: liveSourceName, 
            programName: programName, 
            scheduleConfiguration: scheduleConfiguration, 
            sourceLocationName: sourceLocationName, 
            vodSourceName: vodSourceName
        )
        return try await self.createProgram(input, logger: logger)
    }

    /// Creates a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func createSourceLocation(_ input: CreateSourceLocationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSourceLocationResponse {
        try await self.client.execute(
            operation: "CreateSourceLocation", 
            path: "/sourceLocation/{SourceLocationName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - accessConfiguration: Access configuration parameters. Configures the type of authentication used to access content from your source location.
    ///   - defaultSegmentDeliveryConfiguration: The optional configuration for the server that serves segments.
    ///   - httpConfiguration: The source's HTTP package configurations.
    ///   - segmentDeliveryConfigurations: A list of the segment delivery configurations associated with this resource.
    ///   - sourceLocationName: The name associated with the source location.
    ///   - tags: The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSourceLocation(
        accessConfiguration: AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration,
        segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSourceLocationResponse {
        let input = CreateSourceLocationRequest(
            accessConfiguration: accessConfiguration, 
            defaultSegmentDeliveryConfiguration: defaultSegmentDeliveryConfiguration, 
            httpConfiguration: httpConfiguration, 
            segmentDeliveryConfigurations: segmentDeliveryConfigurations, 
            sourceLocationName: sourceLocationName, 
            tags: tags
        )
        return try await self.createSourceLocation(input, logger: logger)
    }

    /// The VOD source configuration parameters.
    @Sendable
    @inlinable
    public func createVodSource(_ input: CreateVodSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVodSourceResponse {
        try await self.client.execute(
            operation: "CreateVodSource", 
            path: "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The VOD source configuration parameters.
    ///
    /// Parameters:
    ///   - httpPackageConfigurations: A list of HTTP package configuration parameters for this VOD source.
    ///   - sourceLocationName: The name of the source location for this VOD source.
    ///   - tags: The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///   - vodSourceName: The name associated with the VOD source.&gt;
    ///   - logger: Logger use during operation
    @inlinable
    public func createVodSource(
        httpPackageConfigurations: [HttpPackageConfiguration],
        sourceLocationName: String,
        tags: [String: String]? = nil,
        vodSourceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVodSourceResponse {
        let input = CreateVodSourceRequest(
            httpPackageConfigurations: httpPackageConfigurations, 
            sourceLocationName: sourceLocationName, 
            tags: tags, 
            vodSourceName: vodSourceName
        )
        return try await self.createVodSource(input, logger: logger)
    }

    /// Deletes a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func deleteChannel(_ input: DeleteChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteChannelResponse {
        try await self.client.execute(
            operation: "DeleteChannel", 
            path: "/channel/{ChannelName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteChannel(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteChannelResponse {
        let input = DeleteChannelRequest(
            channelName: channelName
        )
        return try await self.deleteChannel(input, logger: logger)
    }

    /// The channel policy to delete.
    @Sendable
    @inlinable
    public func deleteChannelPolicy(_ input: DeleteChannelPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteChannelPolicyResponse {
        try await self.client.execute(
            operation: "DeleteChannelPolicy", 
            path: "/channel/{ChannelName}/policy", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The channel policy to delete.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel associated with this channel policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteChannelPolicy(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteChannelPolicyResponse {
        let input = DeleteChannelPolicyRequest(
            channelName: channelName
        )
        return try await self.deleteChannelPolicy(input, logger: logger)
    }

    /// The live source to delete.
    @Sendable
    @inlinable
    public func deleteLiveSource(_ input: DeleteLiveSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLiveSourceResponse {
        try await self.client.execute(
            operation: "DeleteLiveSource", 
            path: "/sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The live source to delete.
    ///
    /// Parameters:
    ///   - liveSourceName: The name of the live source.
    ///   - sourceLocationName: The name of the source location associated with this Live Source.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLiveSource(
        liveSourceName: String,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLiveSourceResponse {
        let input = DeleteLiveSourceRequest(
            liveSourceName: liveSourceName, 
            sourceLocationName: sourceLocationName
        )
        return try await self.deleteLiveSource(input, logger: logger)
    }

    /// Deletes a playback configuration. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
    @Sendable
    @inlinable
    public func deletePlaybackConfiguration(_ input: DeletePlaybackConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePlaybackConfigurationResponse {
        try await self.client.execute(
            operation: "DeletePlaybackConfiguration", 
            path: "/playbackConfiguration/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a playback configuration. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
    ///
    /// Parameters:
    ///   - name: The name of the playback configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePlaybackConfiguration(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePlaybackConfigurationResponse {
        let input = DeletePlaybackConfigurationRequest(
            name: name
        )
        return try await self.deletePlaybackConfiguration(input, logger: logger)
    }

    /// Deletes a prefetch schedule for a specific playback configuration. If you call DeletePrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code. For more information about ad prefetching, see Using ad prefetching in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func deletePrefetchSchedule(_ input: DeletePrefetchScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePrefetchScheduleResponse {
        try await self.client.execute(
            operation: "DeletePrefetchSchedule", 
            path: "/prefetchSchedule/{PlaybackConfigurationName}/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a prefetch schedule for a specific playback configuration. If you call DeletePrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code. For more information about ad prefetching, see Using ad prefetching in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - name: The name of the prefetch schedule. If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
    ///   - playbackConfigurationName: The name of the playback configuration for this prefetch schedule.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePrefetchSchedule(
        name: String,
        playbackConfigurationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePrefetchScheduleResponse {
        let input = DeletePrefetchScheduleRequest(
            name: name, 
            playbackConfigurationName: playbackConfigurationName
        )
        return try await self.deletePrefetchSchedule(input, logger: logger)
    }

    /// Deletes a program within a channel. For information about programs, see Working with programs in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func deleteProgram(_ input: DeleteProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteProgramResponse {
        try await self.client.execute(
            operation: "DeleteProgram", 
            path: "/channel/{ChannelName}/program/{ProgramName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a program within a channel. For information about programs, see Working with programs in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - programName: The name of the program.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteProgram(
        channelName: String,
        programName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteProgramResponse {
        let input = DeleteProgramRequest(
            channelName: channelName, 
            programName: programName
        )
        return try await self.deleteProgram(input, logger: logger)
    }

    /// Deletes a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func deleteSourceLocation(_ input: DeleteSourceLocationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSourceLocationResponse {
        try await self.client.execute(
            operation: "DeleteSourceLocation", 
            path: "/sourceLocation/{SourceLocationName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - sourceLocationName: The name of the source location.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSourceLocation(
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSourceLocationResponse {
        let input = DeleteSourceLocationRequest(
            sourceLocationName: sourceLocationName
        )
        return try await self.deleteSourceLocation(input, logger: logger)
    }

    /// The video on demand (VOD) source to delete.
    @Sendable
    @inlinable
    public func deleteVodSource(_ input: DeleteVodSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVodSourceResponse {
        try await self.client.execute(
            operation: "DeleteVodSource", 
            path: "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The video on demand (VOD) source to delete.
    ///
    /// Parameters:
    ///   - sourceLocationName: The name of the source location associated with this VOD Source.
    ///   - vodSourceName: The name of the VOD source.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVodSource(
        sourceLocationName: String,
        vodSourceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVodSourceResponse {
        let input = DeleteVodSourceRequest(
            sourceLocationName: sourceLocationName, 
            vodSourceName: vodSourceName
        )
        return try await self.deleteVodSource(input, logger: logger)
    }

    /// Describes a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func describeChannel(_ input: DescribeChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeChannelResponse {
        try await self.client.execute(
            operation: "DescribeChannel", 
            path: "/channel/{ChannelName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeChannel(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeChannelResponse {
        let input = DescribeChannelRequest(
            channelName: channelName
        )
        return try await self.describeChannel(input, logger: logger)
    }

    /// The live source to describe.
    @Sendable
    @inlinable
    public func describeLiveSource(_ input: DescribeLiveSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLiveSourceResponse {
        try await self.client.execute(
            operation: "DescribeLiveSource", 
            path: "/sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The live source to describe.
    ///
    /// Parameters:
    ///   - liveSourceName: The name of the live source.
    ///   - sourceLocationName: The name of the source location associated with this Live Source.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLiveSource(
        liveSourceName: String,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLiveSourceResponse {
        let input = DescribeLiveSourceRequest(
            liveSourceName: liveSourceName, 
            sourceLocationName: sourceLocationName
        )
        return try await self.describeLiveSource(input, logger: logger)
    }

    /// Describes a program within a channel. For information about programs, see Working with programs in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func describeProgram(_ input: DescribeProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeProgramResponse {
        try await self.client.execute(
            operation: "DescribeProgram", 
            path: "/channel/{ChannelName}/program/{ProgramName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a program within a channel. For information about programs, see Working with programs in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel associated with this Program.
    ///   - programName: The name of the program.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeProgram(
        channelName: String,
        programName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeProgramResponse {
        let input = DescribeProgramRequest(
            channelName: channelName, 
            programName: programName
        )
        return try await self.describeProgram(input, logger: logger)
    }

    /// Describes a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func describeSourceLocation(_ input: DescribeSourceLocationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSourceLocationResponse {
        try await self.client.execute(
            operation: "DescribeSourceLocation", 
            path: "/sourceLocation/{SourceLocationName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - sourceLocationName: The name of the source location.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSourceLocation(
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSourceLocationResponse {
        let input = DescribeSourceLocationRequest(
            sourceLocationName: sourceLocationName
        )
        return try await self.describeSourceLocation(input, logger: logger)
    }

    /// Provides details about a specific video on demand (VOD) source in a specific source location.
    @Sendable
    @inlinable
    public func describeVodSource(_ input: DescribeVodSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVodSourceResponse {
        try await self.client.execute(
            operation: "DescribeVodSource", 
            path: "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides details about a specific video on demand (VOD) source in a specific source location.
    ///
    /// Parameters:
    ///   - sourceLocationName: The name of the source location associated with this VOD Source.
    ///   - vodSourceName: The name of the VOD Source.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVodSource(
        sourceLocationName: String,
        vodSourceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVodSourceResponse {
        let input = DescribeVodSourceRequest(
            sourceLocationName: sourceLocationName, 
            vodSourceName: vodSourceName
        )
        return try await self.describeVodSource(input, logger: logger)
    }

    /// Returns the channel's IAM policy. IAM policies are used to control access to your channel.
    @Sendable
    @inlinable
    public func getChannelPolicy(_ input: GetChannelPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetChannelPolicyResponse {
        try await self.client.execute(
            operation: "GetChannelPolicy", 
            path: "/channel/{ChannelName}/policy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the channel's IAM policy. IAM policies are used to control access to your channel.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel associated with this Channel Policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func getChannelPolicy(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetChannelPolicyResponse {
        let input = GetChannelPolicyRequest(
            channelName: channelName
        )
        return try await self.getChannelPolicy(input, logger: logger)
    }

    /// Retrieves information about your channel's schedule.
    @Sendable
    @inlinable
    public func getChannelSchedule(_ input: GetChannelScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetChannelScheduleResponse {
        try await self.client.execute(
            operation: "GetChannelSchedule", 
            path: "/channel/{ChannelName}/schedule", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about your channel's schedule.
    ///
    /// Parameters:
    ///   - audience: The single audience for GetChannelScheduleRequest.
    ///   - channelName: The name of the channel associated with this Channel Schedule.
    ///   - durationMinutes: The duration in minutes of the channel schedule.
    ///   - maxResults: The maximum number of channel schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults channel schedules, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: (Optional) If the playback configuration has more than MaxResults channel schedules, use NextToken to get the second and subsequent pages of results. For the first GetChannelScheduleRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more channel schedules to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func getChannelSchedule(
        audience: String? = nil,
        channelName: String,
        durationMinutes: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetChannelScheduleResponse {
        let input = GetChannelScheduleRequest(
            audience: audience, 
            channelName: channelName, 
            durationMinutes: durationMinutes, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getChannelSchedule(input, logger: logger)
    }

    /// Retrieves a playback configuration. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
    @Sendable
    @inlinable
    public func getPlaybackConfiguration(_ input: GetPlaybackConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPlaybackConfigurationResponse {
        try await self.client.execute(
            operation: "GetPlaybackConfiguration", 
            path: "/playbackConfiguration/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a playback configuration. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
    ///
    /// Parameters:
    ///   - name: The identifier for the playback configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPlaybackConfiguration(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPlaybackConfigurationResponse {
        let input = GetPlaybackConfigurationRequest(
            name: name
        )
        return try await self.getPlaybackConfiguration(input, logger: logger)
    }

    /// Retrieves a prefetch schedule for a playback configuration. A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see Using ad prefetching in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func getPrefetchSchedule(_ input: GetPrefetchScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPrefetchScheduleResponse {
        try await self.client.execute(
            operation: "GetPrefetchSchedule", 
            path: "/prefetchSchedule/{PlaybackConfigurationName}/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a prefetch schedule for a playback configuration. A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see Using ad prefetching in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - name: The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
    ///   - playbackConfigurationName: Returns information about the prefetch schedule for a specific playback configuration. If you call GetPrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPrefetchSchedule(
        name: String,
        playbackConfigurationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPrefetchScheduleResponse {
        let input = GetPrefetchScheduleRequest(
            name: name, 
            playbackConfigurationName: playbackConfigurationName
        )
        return try await self.getPrefetchSchedule(input, logger: logger)
    }

    /// Lists the alerts that are associated with a MediaTailor channel assembly resource.
    @Sendable
    @inlinable
    public func listAlerts(_ input: ListAlertsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAlertsResponse {
        try await self.client.execute(
            operation: "ListAlerts", 
            path: "/alerts", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the alerts that are associated with a MediaTailor channel assembly resource.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of alerts that you want MediaTailor to return in response to the current request. If there are more than MaxResults alerts, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAlerts(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAlertsResponse {
        let input = ListAlertsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.listAlerts(input, logger: logger)
    }

    /// Retrieves information about the channels that are associated with the current AWS account.
    @Sendable
    @inlinable
    public func listChannels(_ input: ListChannelsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListChannelsResponse {
        try await self.client.execute(
            operation: "ListChannels", 
            path: "/channels", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the channels that are associated with the current AWS account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of channels that you want MediaTailor to return in response to the current request. If there are more than MaxResults channels, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listChannels(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListChannelsResponse {
        let input = ListChannelsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listChannels(input, logger: logger)
    }

    /// Lists the live sources contained in a source location. A source represents a piece of content.
    @Sendable
    @inlinable
    public func listLiveSources(_ input: ListLiveSourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLiveSourcesResponse {
        try await self.client.execute(
            operation: "ListLiveSources", 
            path: "/sourceLocation/{SourceLocationName}/liveSources", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the live sources contained in a source location. A source represents a piece of content.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of live sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults live sources, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    ///   - sourceLocationName: The name of the source location associated with this Live Sources list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLiveSources(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLiveSourcesResponse {
        let input = ListLiveSourcesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sourceLocationName: sourceLocationName
        )
        return try await self.listLiveSources(input, logger: logger)
    }

    /// Retrieves existing playback configurations. For information about MediaTailor configurations, see Working with Configurations in AWS Elemental MediaTailor.
    @Sendable
    @inlinable
    public func listPlaybackConfigurations(_ input: ListPlaybackConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPlaybackConfigurationsResponse {
        try await self.client.execute(
            operation: "ListPlaybackConfigurations", 
            path: "/playbackConfigurations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves existing playback configurations. For information about MediaTailor configurations, see Working with Configurations in AWS Elemental MediaTailor.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of playback configurations that you want MediaTailor to return in response to the current request. If there are more than MaxResults playback configurations, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPlaybackConfigurations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPlaybackConfigurationsResponse {
        let input = ListPlaybackConfigurationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPlaybackConfigurations(input, logger: logger)
    }

    /// Lists the prefetch schedules for a playback configuration.
    @Sendable
    @inlinable
    public func listPrefetchSchedules(_ input: ListPrefetchSchedulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPrefetchSchedulesResponse {
        try await self.client.execute(
            operation: "ListPrefetchSchedules", 
            path: "/prefetchSchedule/{PlaybackConfigurationName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the prefetch schedules for a playback configuration.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: (Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results. For the first ListPrefetchSchedulesRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.
    ///   - playbackConfigurationName: Retrieves the prefetch schedule(s) for a specific playback configuration.
    ///   - streamId: An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPrefetchSchedules(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        playbackConfigurationName: String,
        streamId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPrefetchSchedulesResponse {
        let input = ListPrefetchSchedulesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            playbackConfigurationName: playbackConfigurationName, 
            streamId: streamId
        )
        return try await self.listPrefetchSchedules(input, logger: logger)
    }

    /// Lists the source locations for a channel. A source location defines the host server URL, and contains a list of sources.
    @Sendable
    @inlinable
    public func listSourceLocations(_ input: ListSourceLocationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSourceLocationsResponse {
        try await self.client.execute(
            operation: "ListSourceLocations", 
            path: "/sourceLocations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the source locations for a channel. A source location defines the host server URL, and contains a list of sources.
    ///
    /// Parameters:
    ///   - maxResults:  The maximum number of source locations that you want MediaTailor to return in response to the current request. If there are more than MaxResults source locations, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSourceLocations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSourceLocationsResponse {
        let input = ListSourceLocationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSourceLocations(input, logger: logger)
    }

    /// A list of tags that are associated with this resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A list of tags that are associated with this resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) associated with this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists the VOD sources contained in a source location. A source represents a piece of content.
    @Sendable
    @inlinable
    public func listVodSources(_ input: ListVodSourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVodSourcesResponse {
        try await self.client.execute(
            operation: "ListVodSources", 
            path: "/sourceLocation/{SourceLocationName}/vodSources", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the VOD sources contained in a source location. A source represents a piece of content.
    ///
    /// Parameters:
    ///   - maxResults:  The maximum number of VOD sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults VOD sources, use the value of NextToken in the response to get the next page of results.
    ///   - nextToken: Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    ///   - sourceLocationName: The name of the source location associated with this VOD Source list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVodSources(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVodSourcesResponse {
        let input = ListVodSourcesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sourceLocationName: sourceLocationName
        )
        return try await self.listVodSources(input, logger: logger)
    }

    /// Creates an IAM policy for the channel. IAM policies are used to control access to your channel.
    @Sendable
    @inlinable
    public func putChannelPolicy(_ input: PutChannelPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutChannelPolicyResponse {
        try await self.client.execute(
            operation: "PutChannelPolicy", 
            path: "/channel/{ChannelName}/policy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an IAM policy for the channel. IAM policies are used to control access to your channel.
    ///
    /// Parameters:
    ///   - channelName: The channel name associated with this Channel Policy.
    ///   - policy: Adds an IAM role that determines the permissions of your channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func putChannelPolicy(
        channelName: String,
        policy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutChannelPolicyResponse {
        let input = PutChannelPolicyRequest(
            channelName: channelName, 
            policy: policy
        )
        return try await self.putChannelPolicy(input, logger: logger)
    }

    /// Creates a playback configuration. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
    @Sendable
    @inlinable
    public func putPlaybackConfiguration(_ input: PutPlaybackConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutPlaybackConfigurationResponse {
        try await self.client.execute(
            operation: "PutPlaybackConfiguration", 
            path: "/playbackConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a playback configuration. For information about MediaTailor configurations, see Working with configurations in AWS Elemental MediaTailor.
    ///
    /// Parameters:
    ///   - adConditioningConfiguration: The setting that indicates what conditioning MediaTailor will perform on ads that the ad decision server (ADS) returns, and what priority MediaTailor uses when inserting ads.
    ///   - adDecisionServerUrl: The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
    ///   - availSuppression: The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression.
    ///   - bumper: The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers.
    ///   - cdnConfiguration: The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    ///   - configurationAliases: The player parameters and aliases used as dynamic variables during session initialization. For more information, see Domain Variables.
    ///   - dashConfiguration: The configuration for DASH content.
    ///   - insertionMode: The setting that controls whether players can use stitched or guided ad insertion. The default, STITCHED_ONLY, forces all player sessions to use stitched (server-side) ad insertion. Choosing PLAYER_SELECT allows players to select either stitched or guided ad insertion at session-initialization time. The default for players that do not specify an insertion mode is stitched.
    ///   - livePreRollConfiguration: The configuration for pre-roll ad insertion.
    ///   - manifestProcessingRules: The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    ///   - name: The identifier for the playback configuration.
    ///   - personalizationThresholdSeconds: Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see Ad Behavior in AWS Elemental MediaTailor.
    ///   - slateAdUrl: The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    ///   - tags: The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///   - transcodeProfileName: The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    ///   - videoContentSourceUrl: The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    ///   - logger: Logger use during operation
    @inlinable
    public func putPlaybackConfiguration(
        adConditioningConfiguration: AdConditioningConfiguration? = nil,
        adDecisionServerUrl: String? = nil,
        availSuppression: AvailSuppression? = nil,
        bumper: Bumper? = nil,
        cdnConfiguration: CdnConfiguration? = nil,
        configurationAliases: [String: [String: String]]? = nil,
        dashConfiguration: DashConfigurationForPut? = nil,
        insertionMode: InsertionMode? = nil,
        livePreRollConfiguration: LivePreRollConfiguration? = nil,
        manifestProcessingRules: ManifestProcessingRules? = nil,
        name: String,
        personalizationThresholdSeconds: Int? = nil,
        slateAdUrl: String? = nil,
        tags: [String: String]? = nil,
        transcodeProfileName: String? = nil,
        videoContentSourceUrl: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutPlaybackConfigurationResponse {
        let input = PutPlaybackConfigurationRequest(
            adConditioningConfiguration: adConditioningConfiguration, 
            adDecisionServerUrl: adDecisionServerUrl, 
            availSuppression: availSuppression, 
            bumper: bumper, 
            cdnConfiguration: cdnConfiguration, 
            configurationAliases: configurationAliases, 
            dashConfiguration: dashConfiguration, 
            insertionMode: insertionMode, 
            livePreRollConfiguration: livePreRollConfiguration, 
            manifestProcessingRules: manifestProcessingRules, 
            name: name, 
            personalizationThresholdSeconds: personalizationThresholdSeconds, 
            slateAdUrl: slateAdUrl, 
            tags: tags, 
            transcodeProfileName: transcodeProfileName, 
            videoContentSourceUrl: videoContentSourceUrl
        )
        return try await self.putPlaybackConfiguration(input, logger: logger)
    }

    /// Starts a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func startChannel(_ input: StartChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartChannelResponse {
        try await self.client.execute(
            operation: "StartChannel", 
            path: "/channel/{ChannelName}/start", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func startChannel(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartChannelResponse {
        let input = StartChannelRequest(
            channelName: channelName
        )
        return try await self.startChannel(input, logger: logger)
    }

    /// Stops a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func stopChannel(_ input: StopChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopChannelResponse {
        try await self.client.execute(
            operation: "StopChannel", 
            path: "/channel/{ChannelName}/stop", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - channelName: The name of the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopChannel(
        channelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopChannelResponse {
        let input = StopChannelRequest(
            channelName: channelName
        )
        return try await self.stopChannel(input, logger: logger)
    }

    /// The resource to tag. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The resource to tag. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) associated with the resource.
    ///   - tags: The tags to assign to the resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see Tagging AWS Elemental MediaTailor Resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// The resource to untag.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The resource to untag.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to untag.
    ///   - tagKeys: The tag keys associated with the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func updateChannel(_ input: UpdateChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateChannelResponse {
        try await self.client.execute(
            operation: "UpdateChannel", 
            path: "/channel/{ChannelName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a channel. For information about MediaTailor channels, see Working with channels in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - audiences: The list of audiences defined in channel.
    ///   - channelName: The name of the channel.
    ///   - fillerSlate: The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEAR PlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOP PlaybackMode.
    ///   - outputs: The channel's output properties.
    ///   - timeShiftConfiguration:  The time-shifted viewing configuration you want to associate to the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateChannel(
        audiences: [String]? = nil,
        channelName: String,
        fillerSlate: SlateSource? = nil,
        outputs: [RequestOutputItem],
        timeShiftConfiguration: TimeShiftConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateChannelResponse {
        let input = UpdateChannelRequest(
            audiences: audiences, 
            channelName: channelName, 
            fillerSlate: fillerSlate, 
            outputs: outputs, 
            timeShiftConfiguration: timeShiftConfiguration
        )
        return try await self.updateChannel(input, logger: logger)
    }

    /// Updates a live source's configuration.
    @Sendable
    @inlinable
    public func updateLiveSource(_ input: UpdateLiveSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLiveSourceResponse {
        try await self.client.execute(
            operation: "UpdateLiveSource", 
            path: "/sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a live source's configuration.
    ///
    /// Parameters:
    ///   - httpPackageConfigurations: A list of HTTP package configurations for the live source on this account.
    ///   - liveSourceName: The name of the live source.
    ///   - sourceLocationName: The name of the source location associated with this Live Source.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLiveSource(
        httpPackageConfigurations: [HttpPackageConfiguration],
        liveSourceName: String,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLiveSourceResponse {
        let input = UpdateLiveSourceRequest(
            httpPackageConfigurations: httpPackageConfigurations, 
            liveSourceName: liveSourceName, 
            sourceLocationName: sourceLocationName
        )
        return try await self.updateLiveSource(input, logger: logger)
    }

    /// Updates a program within a channel.
    @Sendable
    @inlinable
    public func updateProgram(_ input: UpdateProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateProgramResponse {
        try await self.client.execute(
            operation: "UpdateProgram", 
            path: "/channel/{ChannelName}/program/{ProgramName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a program within a channel.
    ///
    /// Parameters:
    ///   - adBreaks: The ad break configuration settings.
    ///   - audienceMedia: The list of AudienceMedia defined in program.
    ///   - channelName: The name of the channel for this Program.
    ///   - programName: The name of the Program.
    ///   - scheduleConfiguration: The schedule configuration settings.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateProgram(
        adBreaks: [AdBreak]? = nil,
        audienceMedia: [AudienceMedia]? = nil,
        channelName: String,
        programName: String,
        scheduleConfiguration: UpdateProgramScheduleConfiguration,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateProgramResponse {
        let input = UpdateProgramRequest(
            adBreaks: adBreaks, 
            audienceMedia: audienceMedia, 
            channelName: channelName, 
            programName: programName, 
            scheduleConfiguration: scheduleConfiguration
        )
        return try await self.updateProgram(input, logger: logger)
    }

    /// Updates a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    @Sendable
    @inlinable
    public func updateSourceLocation(_ input: UpdateSourceLocationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSourceLocationResponse {
        try await self.client.execute(
            operation: "UpdateSourceLocation", 
            path: "/sourceLocation/{SourceLocationName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a source location. A source location is a container for sources. For more information about source locations, see Working with source locations in the MediaTailor User Guide.
    ///
    /// Parameters:
    ///   - accessConfiguration: Access configuration parameters. Configures the type of authentication used to access content from your source location.
    ///   - defaultSegmentDeliveryConfiguration: The optional configuration for the host server that serves segments.
    ///   - httpConfiguration: The HTTP configuration for the source location.
    ///   - segmentDeliveryConfigurations: A list of the segment delivery configurations associated with this resource.
    ///   - sourceLocationName: The name of the source location.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSourceLocation(
        accessConfiguration: AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: HttpConfiguration,
        segmentDeliveryConfigurations: [SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSourceLocationResponse {
        let input = UpdateSourceLocationRequest(
            accessConfiguration: accessConfiguration, 
            defaultSegmentDeliveryConfiguration: defaultSegmentDeliveryConfiguration, 
            httpConfiguration: httpConfiguration, 
            segmentDeliveryConfigurations: segmentDeliveryConfigurations, 
            sourceLocationName: sourceLocationName
        )
        return try await self.updateSourceLocation(input, logger: logger)
    }

    /// Updates a VOD source's configuration.
    @Sendable
    @inlinable
    public func updateVodSource(_ input: UpdateVodSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVodSourceResponse {
        try await self.client.execute(
            operation: "UpdateVodSource", 
            path: "/sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a VOD source's configuration.
    ///
    /// Parameters:
    ///   - httpPackageConfigurations: A list of HTTP package configurations for the VOD source on this account.
    ///   - sourceLocationName: The name of the source location associated with this VOD Source.
    ///   - vodSourceName: The name of the VOD source.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVodSource(
        httpPackageConfigurations: [HttpPackageConfiguration],
        sourceLocationName: String,
        vodSourceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVodSourceResponse {
        let input = UpdateVodSourceRequest(
            httpPackageConfigurations: httpPackageConfigurations, 
            sourceLocationName: sourceLocationName, 
            vodSourceName: vodSourceName
        )
        return try await self.updateVodSource(input, logger: logger)
    }
}

extension MediaTailor {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: MediaTailor, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MediaTailor {
    /// Return PaginatorSequence for operation ``getChannelSchedule(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getChannelSchedulePaginator(
        _ input: GetChannelScheduleRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetChannelScheduleRequest, GetChannelScheduleResponse> {
        return .init(
            input: input,
            command: self.getChannelSchedule,
            inputKey: \GetChannelScheduleRequest.nextToken,
            outputKey: \GetChannelScheduleResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getChannelSchedule(_:logger:)``.
    ///
    /// - Parameters:
    ///   - audience: The single audience for GetChannelScheduleRequest.
    ///   - channelName: The name of the channel associated with this Channel Schedule.
    ///   - durationMinutes: The duration in minutes of the channel schedule.
    ///   - maxResults: The maximum number of channel schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults channel schedules, use the value of NextToken in the response to get the next page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func getChannelSchedulePaginator(
        audience: String? = nil,
        channelName: String,
        durationMinutes: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetChannelScheduleRequest, GetChannelScheduleResponse> {
        let input = GetChannelScheduleRequest(
            audience: audience, 
            channelName: channelName, 
            durationMinutes: durationMinutes, 
            maxResults: maxResults
        )
        return self.getChannelSchedulePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAlerts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAlertsPaginator(
        _ input: ListAlertsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAlertsRequest, ListAlertsResponse> {
        return .init(
            input: input,
            command: self.listAlerts,
            inputKey: \ListAlertsRequest.nextToken,
            outputKey: \ListAlertsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAlerts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of alerts that you want MediaTailor to return in response to the current request. If there are more than MaxResults alerts, use the value of NextToken in the response to get the next page of results.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAlertsPaginator(
        maxResults: Int? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAlertsRequest, ListAlertsResponse> {
        let input = ListAlertsRequest(
            maxResults: maxResults, 
            resourceArn: resourceArn
        )
        return self.listAlertsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listChannels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelsPaginator(
        _ input: ListChannelsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListChannelsRequest, ListChannelsResponse> {
        return .init(
            input: input,
            command: self.listChannels,
            inputKey: \ListChannelsRequest.nextToken,
            outputKey: \ListChannelsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listChannels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of channels that you want MediaTailor to return in response to the current request. If there are more than MaxResults channels, use the value of NextToken in the response to get the next page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListChannelsRequest, ListChannelsResponse> {
        let input = ListChannelsRequest(
            maxResults: maxResults
        )
        return self.listChannelsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLiveSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLiveSourcesPaginator(
        _ input: ListLiveSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLiveSourcesRequest, ListLiveSourcesResponse> {
        return .init(
            input: input,
            command: self.listLiveSources,
            inputKey: \ListLiveSourcesRequest.nextToken,
            outputKey: \ListLiveSourcesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLiveSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of live sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults live sources, use the value of NextToken in the response to get the next page of results.
    ///   - sourceLocationName: The name of the source location associated with this Live Sources list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLiveSourcesPaginator(
        maxResults: Int? = nil,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLiveSourcesRequest, ListLiveSourcesResponse> {
        let input = ListLiveSourcesRequest(
            maxResults: maxResults, 
            sourceLocationName: sourceLocationName
        )
        return self.listLiveSourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPlaybackConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPlaybackConfigurationsPaginator(
        _ input: ListPlaybackConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPlaybackConfigurationsRequest, ListPlaybackConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listPlaybackConfigurations,
            inputKey: \ListPlaybackConfigurationsRequest.nextToken,
            outputKey: \ListPlaybackConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPlaybackConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of playback configurations that you want MediaTailor to return in response to the current request. If there are more than MaxResults playback configurations, use the value of NextToken in the response to get the next page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPlaybackConfigurationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPlaybackConfigurationsRequest, ListPlaybackConfigurationsResponse> {
        let input = ListPlaybackConfigurationsRequest(
            maxResults: maxResults
        )
        return self.listPlaybackConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPrefetchSchedules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrefetchSchedulesPaginator(
        _ input: ListPrefetchSchedulesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPrefetchSchedulesRequest, ListPrefetchSchedulesResponse> {
        return .init(
            input: input,
            command: self.listPrefetchSchedules,
            inputKey: \ListPrefetchSchedulesRequest.nextToken,
            outputKey: \ListPrefetchSchedulesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPrefetchSchedules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.
    ///   - playbackConfigurationName: Retrieves the prefetch schedule(s) for a specific playback configuration.
    ///   - streamId: An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrefetchSchedulesPaginator(
        maxResults: Int? = nil,
        playbackConfigurationName: String,
        streamId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPrefetchSchedulesRequest, ListPrefetchSchedulesResponse> {
        let input = ListPrefetchSchedulesRequest(
            maxResults: maxResults, 
            playbackConfigurationName: playbackConfigurationName, 
            streamId: streamId
        )
        return self.listPrefetchSchedulesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSourceLocations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSourceLocationsPaginator(
        _ input: ListSourceLocationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSourceLocationsRequest, ListSourceLocationsResponse> {
        return .init(
            input: input,
            command: self.listSourceLocations,
            inputKey: \ListSourceLocationsRequest.nextToken,
            outputKey: \ListSourceLocationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSourceLocations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  The maximum number of source locations that you want MediaTailor to return in response to the current request. If there are more than MaxResults source locations, use the value of NextToken in the response to get the next page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSourceLocationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSourceLocationsRequest, ListSourceLocationsResponse> {
        let input = ListSourceLocationsRequest(
            maxResults: maxResults
        )
        return self.listSourceLocationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVodSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVodSourcesPaginator(
        _ input: ListVodSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVodSourcesRequest, ListVodSourcesResponse> {
        return .init(
            input: input,
            command: self.listVodSources,
            inputKey: \ListVodSourcesRequest.nextToken,
            outputKey: \ListVodSourcesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVodSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  The maximum number of VOD sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults VOD sources, use the value of NextToken in the response to get the next page of results.
    ///   - sourceLocationName: The name of the source location associated with this VOD Source list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVodSourcesPaginator(
        maxResults: Int? = nil,
        sourceLocationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVodSourcesRequest, ListVodSourcesResponse> {
        let input = ListVodSourcesRequest(
            maxResults: maxResults, 
            sourceLocationName: sourceLocationName
        )
        return self.listVodSourcesPaginator(input, logger: logger)
    }
}

extension MediaTailor.GetChannelScheduleRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.GetChannelScheduleRequest {
        return .init(
            audience: self.audience,
            channelName: self.channelName,
            durationMinutes: self.durationMinutes,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaTailor.ListAlertsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListAlertsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension MediaTailor.ListChannelsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListChannelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaTailor.ListLiveSourcesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListLiveSourcesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sourceLocationName: self.sourceLocationName
        )
    }
}

extension MediaTailor.ListPlaybackConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListPlaybackConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaTailor.ListPrefetchSchedulesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListPrefetchSchedulesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            playbackConfigurationName: self.playbackConfigurationName,
            streamId: self.streamId
        )
    }
}

extension MediaTailor.ListSourceLocationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListSourceLocationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaTailor.ListVodSourcesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaTailor.ListVodSourcesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sourceLocationName: self.sourceLocationName
        )
    }
}
