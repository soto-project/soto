//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CostOptimizationHub {
    // MARK: Enums

    public enum ActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "Delete"
        case migrateToGraviton = "MigrateToGraviton"
        case purchaseReservedInstances = "PurchaseReservedInstances"
        case purchaseSavingsPlans = "PurchaseSavingsPlans"
        case rightsize = "Rightsize"
        case scaleIn = "ScaleIn"
        case stop = "Stop"
        case upgrade = "Upgrade"
        public var description: String { return self.rawValue }
    }

    public enum AllocationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lowestPrice = "LowestPrice"
        case prioritized = "Prioritized"
        public var description: String { return self.rawValue }
    }

    public enum Ec2AutoScalingGroupType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mixedInstanceTypes = "MixedInstanceTypes"
        case singleInstanceType = "SingleInstanceType"
        public var description: String { return self.rawValue }
    }

    public enum EnrollmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum ImplementationEffort: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "High"
        case low = "Low"
        case medium = "Medium"
        case veryHigh = "VeryHigh"
        case veryLow = "VeryLow"
        public var description: String { return self.rawValue }
    }

    public enum MemberAccountDiscountVisibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "All"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "Asc"
        case desc = "Desc"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case computeSavingsPlans = "ComputeSavingsPlans"
        case dynamoDbReservedCapacity = "DynamoDbReservedCapacity"
        case ebsVolume = "EbsVolume"
        case ec2AutoScalingGroup = "Ec2AutoScalingGroup"
        case ec2Instance = "Ec2Instance"
        case ec2InstanceSavingsPlans = "Ec2InstanceSavingsPlans"
        case ec2ReservedInstances = "Ec2ReservedInstances"
        case ecsService = "EcsService"
        case elastiCacheReservedInstances = "ElastiCacheReservedInstances"
        case lambdaFunction = "LambdaFunction"
        case memoryDbReservedInstances = "MemoryDbReservedInstances"
        case openSearchReservedInstances = "OpenSearchReservedInstances"
        case rdsDbInstance = "RdsDbInstance"
        case rdsDbInstanceStorage = "RdsDbInstanceStorage"
        case rdsReservedInstances = "RdsReservedInstances"
        case redshiftReservedInstances = "RedshiftReservedInstances"
        case sageMakerSavingsPlans = "SageMakerSavingsPlans"
        public var description: String { return self.rawValue }
    }

    public enum SavingsEstimationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterDiscounts = "AfterDiscounts"
        case beforeDiscounts = "BeforeDiscounts"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case computeOptimizer = "ComputeOptimizer"
        case costExplorer = "CostExplorer"
        public var description: String { return self.rawValue }
    }

    public enum SummaryMetrics: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case savingsPercentage = "SavingsPercentage"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fieldValidationFailed = "FieldValidationFailed"
        case other = "Other"
        public var description: String { return self.rawValue }
    }

    public enum ResourceDetails: AWSDecodableShape, Sendable {
        /// The Compute Savings Plans recommendation details.
        case computeSavingsPlans(ComputeSavingsPlans)
        /// The DynamoDB reserved capacity recommendation details.
        case dynamoDbReservedCapacity(DynamoDbReservedCapacity)
        /// The Amazon Elastic Block Store volume recommendation details.
        case ebsVolume(EbsVolume)
        /// The EC2 Auto Scaling group recommendation details.
        case ec2AutoScalingGroup(Ec2AutoScalingGroup)
        /// The EC2 instance recommendation details.
        case ec2Instance(Ec2Instance)
        /// The EC2 instance Savings Plans recommendation details.
        case ec2InstanceSavingsPlans(Ec2InstanceSavingsPlans)
        /// The EC2 reserved instances recommendation details.
        case ec2ReservedInstances(Ec2ReservedInstances)
        /// The ECS service recommendation details.
        case ecsService(EcsService)
        /// The ElastiCache reserved instances recommendation details.
        case elastiCacheReservedInstances(ElastiCacheReservedInstances)
        /// The Lambda function recommendation details.
        case lambdaFunction(LambdaFunction)
        /// The MemoryDB reserved instances recommendation details.
        case memoryDbReservedInstances(MemoryDbReservedInstances)
        /// The OpenSearch reserved instances recommendation details.
        case openSearchReservedInstances(OpenSearchReservedInstances)
        /// The DB instance recommendation details.
        case rdsDbInstance(RdsDbInstance)
        /// The DB instance storage recommendation details.
        case rdsDbInstanceStorage(RdsDbInstanceStorage)
        /// The RDS reserved instances recommendation details.
        case rdsReservedInstances(RdsReservedInstances)
        /// The Redshift reserved instances recommendation details.
        case redshiftReservedInstances(RedshiftReservedInstances)
        /// The SageMaker AI Savings Plans recommendation details.
        case sageMakerSavingsPlans(SageMakerSavingsPlans)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .computeSavingsPlans:
                let value = try container.decode(ComputeSavingsPlans.self, forKey: .computeSavingsPlans)
                self = .computeSavingsPlans(value)
            case .dynamoDbReservedCapacity:
                let value = try container.decode(DynamoDbReservedCapacity.self, forKey: .dynamoDbReservedCapacity)
                self = .dynamoDbReservedCapacity(value)
            case .ebsVolume:
                let value = try container.decode(EbsVolume.self, forKey: .ebsVolume)
                self = .ebsVolume(value)
            case .ec2AutoScalingGroup:
                let value = try container.decode(Ec2AutoScalingGroup.self, forKey: .ec2AutoScalingGroup)
                self = .ec2AutoScalingGroup(value)
            case .ec2Instance:
                let value = try container.decode(Ec2Instance.self, forKey: .ec2Instance)
                self = .ec2Instance(value)
            case .ec2InstanceSavingsPlans:
                let value = try container.decode(Ec2InstanceSavingsPlans.self, forKey: .ec2InstanceSavingsPlans)
                self = .ec2InstanceSavingsPlans(value)
            case .ec2ReservedInstances:
                let value = try container.decode(Ec2ReservedInstances.self, forKey: .ec2ReservedInstances)
                self = .ec2ReservedInstances(value)
            case .ecsService:
                let value = try container.decode(EcsService.self, forKey: .ecsService)
                self = .ecsService(value)
            case .elastiCacheReservedInstances:
                let value = try container.decode(ElastiCacheReservedInstances.self, forKey: .elastiCacheReservedInstances)
                self = .elastiCacheReservedInstances(value)
            case .lambdaFunction:
                let value = try container.decode(LambdaFunction.self, forKey: .lambdaFunction)
                self = .lambdaFunction(value)
            case .memoryDbReservedInstances:
                let value = try container.decode(MemoryDbReservedInstances.self, forKey: .memoryDbReservedInstances)
                self = .memoryDbReservedInstances(value)
            case .openSearchReservedInstances:
                let value = try container.decode(OpenSearchReservedInstances.self, forKey: .openSearchReservedInstances)
                self = .openSearchReservedInstances(value)
            case .rdsDbInstance:
                let value = try container.decode(RdsDbInstance.self, forKey: .rdsDbInstance)
                self = .rdsDbInstance(value)
            case .rdsDbInstanceStorage:
                let value = try container.decode(RdsDbInstanceStorage.self, forKey: .rdsDbInstanceStorage)
                self = .rdsDbInstanceStorage(value)
            case .rdsReservedInstances:
                let value = try container.decode(RdsReservedInstances.self, forKey: .rdsReservedInstances)
                self = .rdsReservedInstances(value)
            case .redshiftReservedInstances:
                let value = try container.decode(RedshiftReservedInstances.self, forKey: .redshiftReservedInstances)
                self = .redshiftReservedInstances(value)
            case .sageMakerSavingsPlans:
                let value = try container.decode(SageMakerSavingsPlans.self, forKey: .sageMakerSavingsPlans)
                self = .sageMakerSavingsPlans(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case computeSavingsPlans = "computeSavingsPlans"
            case dynamoDbReservedCapacity = "dynamoDbReservedCapacity"
            case ebsVolume = "ebsVolume"
            case ec2AutoScalingGroup = "ec2AutoScalingGroup"
            case ec2Instance = "ec2Instance"
            case ec2InstanceSavingsPlans = "ec2InstanceSavingsPlans"
            case ec2ReservedInstances = "ec2ReservedInstances"
            case ecsService = "ecsService"
            case elastiCacheReservedInstances = "elastiCacheReservedInstances"
            case lambdaFunction = "lambdaFunction"
            case memoryDbReservedInstances = "memoryDbReservedInstances"
            case openSearchReservedInstances = "openSearchReservedInstances"
            case rdsDbInstance = "rdsDbInstance"
            case rdsDbInstanceStorage = "rdsDbInstanceStorage"
            case rdsReservedInstances = "rdsReservedInstances"
            case redshiftReservedInstances = "redshiftReservedInstances"
            case sageMakerSavingsPlans = "sageMakerSavingsPlans"
        }
    }

    // MARK: Shapes

    public struct AccountEnrollmentStatus: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The time when the account enrollment status was created.
        public let createdTimestamp: Date?
        /// The time when the account enrollment status was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The account enrollment status.
        public let status: EnrollmentStatus?

        @inlinable
        public init(accountId: String? = nil, createdTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, status: EnrollmentStatus? = nil) {
            self.accountId = accountId
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case createdTimestamp = "createdTimestamp"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case status = "status"
        }
    }

    public struct BlockStoragePerformanceConfiguration: AWSDecodableShape {
        /// The number of I/O operations per second.
        public let iops: Double?
        /// The throughput that the volume supports.
        public let throughput: Double?

        @inlinable
        public init(iops: Double? = nil, throughput: Double? = nil) {
            self.iops = iops
            self.throughput = throughput
        }

        private enum CodingKeys: String, CodingKey {
            case iops = "iops"
            case throughput = "throughput"
        }
    }

    public struct ComputeConfiguration: AWSDecodableShape {
        /// The architecture of the resource.
        public let architecture: String?
        /// The memory size of the resource.
        public let memorySizeInMB: Int?
        /// The platform of the resource. The platform is the specific combination of operating system, license model, and software on an instance.
        public let platform: String?
        /// The number of vCPU cores in the resource.
        public let vCpu: Double?

        @inlinable
        public init(architecture: String? = nil, memorySizeInMB: Int? = nil, platform: String? = nil, vCpu: Double? = nil) {
            self.architecture = architecture
            self.memorySizeInMB = memorySizeInMB
            self.platform = platform
            self.vCpu = vCpu
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case memorySizeInMB = "memorySizeInMB"
            case platform = "platform"
            case vCpu = "vCpu"
        }
    }

    public struct ComputeSavingsPlans: AWSDecodableShape {
        /// Configuration details of the Compute Savings Plans to purchase.
        public let configuration: ComputeSavingsPlansConfiguration?
        /// Cost impact of the Savings Plans purchase recommendation.
        public let costCalculation: SavingsPlansCostCalculation?

        @inlinable
        public init(configuration: ComputeSavingsPlansConfiguration? = nil, costCalculation: SavingsPlansCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct ComputeSavingsPlansConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public let accountScope: String?
        /// The hourly commitment for the Savings Plans type.
        public let hourlyCommitment: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Savings Plans recommendation term in years.
        public let term: String?

        @inlinable
        public init(accountScope: String? = nil, hourlyCommitment: String? = nil, paymentOption: String? = nil, term: String? = nil) {
            self.accountScope = accountScope
            self.hourlyCommitment = hourlyCommitment
            self.paymentOption = paymentOption
            self.term = term
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case hourlyCommitment = "hourlyCommitment"
            case paymentOption = "paymentOption"
            case term = "term"
        }
    }

    public struct DbInstanceConfiguration: AWSDecodableShape {
        /// The DB instance class of the DB instance.
        public let dbInstanceClass: String?

        @inlinable
        public init(dbInstanceClass: String? = nil) {
            self.dbInstanceClass = dbInstanceClass
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceClass = "dbInstanceClass"
        }
    }

    public struct DynamoDbReservedCapacity: AWSDecodableShape {
        /// The DynamoDB reserved capacity configuration used for recommendations.
        public let configuration: DynamoDbReservedCapacityConfiguration?
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: DynamoDbReservedCapacityConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct DynamoDbReservedCapacityConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// The capacity unit of the recommended reservation.
        public let capacityUnits: String?
        /// How much purchasing this reserved capacity costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of reserved capacity units that Amazon Web Services recommends that you purchase.
        public let numberOfCapacityUnitsToPurchase: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// The reserved capacity recommendation term in years.
        public let term: String?
        /// How much purchasing this reserved capacity costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, capacityUnits: String? = nil, monthlyRecurringCost: String? = nil, numberOfCapacityUnitsToPurchase: String? = nil, paymentOption: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.capacityUnits = capacityUnits
            self.monthlyRecurringCost = monthlyRecurringCost
            self.numberOfCapacityUnitsToPurchase = numberOfCapacityUnitsToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case capacityUnits = "capacityUnits"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case numberOfCapacityUnitsToPurchase = "numberOfCapacityUnitsToPurchase"
            case paymentOption = "paymentOption"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct EbsVolume: AWSDecodableShape {
        /// The Amazon Elastic Block Store volume configuration used for recommendations.
        public let configuration: EbsVolumeConfiguration?
        /// Cost impact of the recommendation.
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: EbsVolumeConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct EbsVolumeConfiguration: AWSDecodableShape {
        /// The Amazon Elastic Block Store attachment state.
        public let attachmentState: String?
        /// The Amazon Elastic Block Store performance configuration.
        public let performance: BlockStoragePerformanceConfiguration?
        /// The disk storage of the Amazon Elastic Block Store volume.
        public let storage: StorageConfiguration?

        @inlinable
        public init(attachmentState: String? = nil, performance: BlockStoragePerformanceConfiguration? = nil, storage: StorageConfiguration? = nil) {
            self.attachmentState = attachmentState
            self.performance = performance
            self.storage = storage
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentState = "attachmentState"
            case performance = "performance"
            case storage = "storage"
        }
    }

    public struct Ec2AutoScalingGroup: AWSDecodableShape {
        /// The EC2 Auto Scaling group configuration used for recommendations.
        public let configuration: Ec2AutoScalingGroupConfiguration?
        /// Cost impact of the recommendation.
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: Ec2AutoScalingGroupConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct Ec2AutoScalingGroupConfiguration: AWSDecodableShape {
        /// The strategy used for allocating instances, based on a predefined priority order or based on the lowest available price.
        public let allocationStrategy: AllocationStrategy?
        /// Details about the instance for the EC2 Auto Scaling group with a single instance type.
        public let instance: InstanceConfiguration?
        /// A list of instance types for an EC2 Auto Scaling group with mixed instance types.
        public let mixedInstances: [MixedInstanceConfiguration]?
        /// The type of EC2 Auto Scaling group, showing whether it consists of a single instance type or mixed instance types.
        public let type: Ec2AutoScalingGroupType?

        @inlinable
        public init(allocationStrategy: AllocationStrategy? = nil, instance: InstanceConfiguration? = nil, mixedInstances: [MixedInstanceConfiguration]? = nil, type: Ec2AutoScalingGroupType? = nil) {
            self.allocationStrategy = allocationStrategy
            self.instance = instance
            self.mixedInstances = mixedInstances
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allocationStrategy = "allocationStrategy"
            case instance = "instance"
            case mixedInstances = "mixedInstances"
            case type = "type"
        }
    }

    public struct Ec2Instance: AWSDecodableShape {
        /// The EC2 instance configuration used for recommendations.
        public let configuration: Ec2InstanceConfiguration?
        /// Cost impact of the recommendation.
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: Ec2InstanceConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct Ec2InstanceConfiguration: AWSDecodableShape {
        /// Details about the instance.
        public let instance: InstanceConfiguration?

        @inlinable
        public init(instance: InstanceConfiguration? = nil) {
            self.instance = instance
        }

        private enum CodingKeys: String, CodingKey {
            case instance = "instance"
        }
    }

    public struct Ec2InstanceSavingsPlans: AWSDecodableShape {
        /// The EC2 instance Savings Plans configuration used for recommendations.
        public let configuration: Ec2InstanceSavingsPlansConfiguration?
        /// Cost impact of the Savings Plans purchase recommendation.
        public let costCalculation: SavingsPlansCostCalculation?

        @inlinable
        public init(configuration: Ec2InstanceSavingsPlansConfiguration? = nil, costCalculation: SavingsPlansCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct Ec2InstanceSavingsPlansConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// The hourly commitment for the Savings Plans type.
        public let hourlyCommitment: String?
        /// The instance family of the recommended Savings Plan.
        public let instanceFamily: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let savingsPlansRegion: String?
        /// The Savings Plans recommendation term in years.
        public let term: String?

        @inlinable
        public init(accountScope: String? = nil, hourlyCommitment: String? = nil, instanceFamily: String? = nil, paymentOption: String? = nil, savingsPlansRegion: String? = nil, term: String? = nil) {
            self.accountScope = accountScope
            self.hourlyCommitment = hourlyCommitment
            self.instanceFamily = instanceFamily
            self.paymentOption = paymentOption
            self.savingsPlansRegion = savingsPlansRegion
            self.term = term
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case hourlyCommitment = "hourlyCommitment"
            case instanceFamily = "instanceFamily"
            case paymentOption = "paymentOption"
            case savingsPlansRegion = "savingsPlansRegion"
            case term = "term"
        }
    }

    public struct Ec2ReservedInstances: AWSDecodableShape {
        /// The EC2 reserved instances configuration used for recommendations.
        public let configuration: Ec2ReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: Ec2ReservedInstancesConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct Ec2ReservedInstancesConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: String?
        /// The instance family of the recommended reservation.
        public let instanceFamily: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// How much purchasing these reserved instances costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let normalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let numberOfInstancesToPurchase: String?
        /// Indicates whether the recommendation is for standard or convertible reservations.
        public let offeringClass: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The platform of the recommended reservation. The platform is the specific combination of operating system, license model, and software on an instance.
        public let platform: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// Determines whether the recommendation is size flexible.
        public let sizeFlexEligible: Bool?
        /// Determines whether the recommended reservation is dedicated or shared.
        public let tenancy: String?
        /// The reserved instances recommendation term in years.
        public let term: String?
        /// How much purchasing this instance costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, currentGeneration: String? = nil, instanceFamily: String? = nil, instanceType: String? = nil, monthlyRecurringCost: String? = nil, normalizedUnitsToPurchase: String? = nil, numberOfInstancesToPurchase: String? = nil, offeringClass: String? = nil, paymentOption: String? = nil, platform: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, sizeFlexEligible: Bool? = nil, tenancy: String? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.offeringClass = offeringClass
            self.paymentOption = paymentOption
            self.platform = platform
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.tenancy = tenancy
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case currentGeneration = "currentGeneration"
            case instanceFamily = "instanceFamily"
            case instanceType = "instanceType"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case normalizedUnitsToPurchase = "normalizedUnitsToPurchase"
            case numberOfInstancesToPurchase = "numberOfInstancesToPurchase"
            case offeringClass = "offeringClass"
            case paymentOption = "paymentOption"
            case platform = "platform"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case sizeFlexEligible = "sizeFlexEligible"
            case tenancy = "tenancy"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct EcsService: AWSDecodableShape {
        /// The ECS service configuration used for recommendations.
        public let configuration: EcsServiceConfiguration?
        /// Cost impact of the recommendation.
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: EcsServiceConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct EcsServiceConfiguration: AWSDecodableShape {
        /// Details about the compute configuration.
        public let compute: ComputeConfiguration?

        @inlinable
        public init(compute: ComputeConfiguration? = nil) {
            self.compute = compute
        }

        private enum CodingKeys: String, CodingKey {
            case compute = "compute"
        }
    }

    public struct ElastiCacheReservedInstances: AWSDecodableShape {
        /// The ElastiCache reserved instances configuration used for recommendations.
        public let configuration: ElastiCacheReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: ElastiCacheReservedInstancesConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct ElastiCacheReservedInstancesConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: String?
        /// The instance family of the recommended reservation.
        public let instanceFamily: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// How much purchasing these reserved instances costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let normalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let numberOfInstancesToPurchase: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// Determines whether the recommendation is size flexible.
        public let sizeFlexEligible: Bool?
        /// The reserved instances recommendation term in years.
        public let term: String?
        /// How much purchasing this instance costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, currentGeneration: String? = nil, instanceFamily: String? = nil, instanceType: String? = nil, monthlyRecurringCost: String? = nil, normalizedUnitsToPurchase: String? = nil, numberOfInstancesToPurchase: String? = nil, paymentOption: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, sizeFlexEligible: Bool? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case currentGeneration = "currentGeneration"
            case instanceFamily = "instanceFamily"
            case instanceType = "instanceType"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case normalizedUnitsToPurchase = "normalizedUnitsToPurchase"
            case numberOfInstancesToPurchase = "numberOfInstancesToPurchase"
            case paymentOption = "paymentOption"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case sizeFlexEligible = "sizeFlexEligible"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct EstimatedDiscounts: AWSDecodableShape {
        /// Estimated other discounts include all discounts that are not itemized. Itemized discounts include reservedInstanceDiscount and savingsPlansDiscount.
        public let otherDiscount: Double?
        /// Estimated reserved instance discounts.
        public let reservedInstancesDiscount: Double?
        /// Estimated Savings Plans discounts.
        public let savingsPlansDiscount: Double?

        @inlinable
        public init(otherDiscount: Double? = nil, reservedInstancesDiscount: Double? = nil, savingsPlansDiscount: Double? = nil) {
            self.otherDiscount = otherDiscount
            self.reservedInstancesDiscount = reservedInstancesDiscount
            self.savingsPlansDiscount = savingsPlansDiscount
        }

        private enum CodingKeys: String, CodingKey {
            case otherDiscount = "otherDiscount"
            case reservedInstancesDiscount = "reservedInstancesDiscount"
            case savingsPlansDiscount = "savingsPlansDiscount"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The account to which the recommendation applies.
        public let accountIds: [String]?
        /// The type of action you can take by adopting the recommendation.
        public let actionTypes: [ActionType]?
        /// The effort required to implement the recommendation.
        public let implementationEfforts: [ImplementationEffort]?
        /// The IDs for the recommendations.
        public let recommendationIds: [String]?
        /// The Amazon Web Services Region of the resource.
        public let regions: [String]?
        /// The Amazon Resource Name (ARN) of the recommendation.
        public let resourceArns: [String]?
        /// The resource ID of the recommendation.
        public let resourceIds: [String]?
        /// The resource type of the recommendation.
        public let resourceTypes: [ResourceType]?
        /// Whether or not implementing the recommendation requires a restart.
        public let restartNeeded: Bool?
        /// Whether or not implementing the recommendation can be rolled back.
        public let rollbackPossible: Bool?
        /// A list of tags assigned to the recommendation.
        public let tags: [Tag]?

        @inlinable
        public init(accountIds: [String]? = nil, actionTypes: [ActionType]? = nil, implementationEfforts: [ImplementationEffort]? = nil, recommendationIds: [String]? = nil, regions: [String]? = nil, resourceArns: [String]? = nil, resourceIds: [String]? = nil, resourceTypes: [ResourceType]? = nil, restartNeeded: Bool? = nil, rollbackPossible: Bool? = nil, tags: [Tag]? = nil) {
            self.accountIds = accountIds
            self.actionTypes = actionTypes
            self.implementationEfforts = implementationEfforts
            self.recommendationIds = recommendationIds
            self.regions = regions
            self.resourceArns = resourceArns
            self.resourceIds = resourceIds
            self.resourceTypes = resourceTypes
            self.restartNeeded = restartNeeded
            self.rollbackPossible = rollbackPossible
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.actionTypes, name: "actionTypes", parent: name, max: 100)
            try self.validate(self.actionTypes, name: "actionTypes", parent: name, min: 1)
            try self.validate(self.implementationEfforts, name: "implementationEfforts", parent: name, max: 100)
            try self.validate(self.implementationEfforts, name: "implementationEfforts", parent: name, min: 1)
            try self.validate(self.recommendationIds, name: "recommendationIds", parent: name, max: 100)
            try self.validate(self.recommendationIds, name: "recommendationIds", parent: name, min: 1)
            try self.validate(self.regions, name: "regions", parent: name, max: 100)
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 100)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, min: 1)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 100)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 100)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
            try self.validate(self.tags, name: "tags", parent: name, max: 100)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case actionTypes = "actionTypes"
            case implementationEfforts = "implementationEfforts"
            case recommendationIds = "recommendationIds"
            case regions = "regions"
            case resourceArns = "resourceArns"
            case resourceIds = "resourceIds"
            case resourceTypes = "resourceTypes"
            case restartNeeded = "restartNeeded"
            case rollbackPossible = "rollbackPossible"
            case tags = "tags"
        }
    }

    public struct GetPreferencesRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPreferencesResponse: AWSDecodableShape {
        /// Retrieves the status of the "member account discount visibility" preference.
        public let memberAccountDiscountVisibility: MemberAccountDiscountVisibility?
        /// Retrieves the status of the "savings estimation mode" preference.
        public let savingsEstimationMode: SavingsEstimationMode?

        @inlinable
        public init(memberAccountDiscountVisibility: MemberAccountDiscountVisibility? = nil, savingsEstimationMode: SavingsEstimationMode? = nil) {
            self.memberAccountDiscountVisibility = memberAccountDiscountVisibility
            self.savingsEstimationMode = savingsEstimationMode
        }

        private enum CodingKeys: String, CodingKey {
            case memberAccountDiscountVisibility = "memberAccountDiscountVisibility"
            case savingsEstimationMode = "savingsEstimationMode"
        }
    }

    public struct GetRecommendationRequest: AWSEncodableShape {
        /// The ID for the recommendation.
        public let recommendationId: String

        @inlinable
        public init(recommendationId: String) {
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case recommendationId = "recommendationId"
        }
    }

    public struct GetRecommendationResponse: AWSDecodableShape {
        /// The account to which the recommendation applies.
        public let accountId: String?
        /// The type of action you can take by adopting the recommendation.
        public let actionType: ActionType?
        /// The lookback period used to calculate cost impact for a recommendation.
        public let costCalculationLookbackPeriodInDays: Int?
        /// The currency code used for the recommendation.
        public let currencyCode: String?
        /// The details for the resource.
        public let currentResourceDetails: ResourceDetails?
        /// The type of resource.
        public let currentResourceType: ResourceType?
        /// The estimated monthly cost of the current resource. For Reserved Instances and Savings Plans, it refers to the cost for eligible usage.
        public let estimatedMonthlyCost: Double?
        /// The estimated monthly savings amount for the recommendation.
        public let estimatedMonthlySavings: Double?
        /// The estimated savings amount over the lookback period used to calculate cost impact for a recommendation.
        public let estimatedSavingsOverCostCalculationLookbackPeriod: Double?
        /// The estimated savings percentage relative to the total cost over the cost calculation lookback period.
        public let estimatedSavingsPercentage: Double?
        /// The effort required to implement the recommendation.
        public let implementationEffort: ImplementationEffort?
        /// The time when the recommendation was last generated.
        public let lastRefreshTimestamp: Date?
        /// The ID for the recommendation.
        public let recommendationId: String?
        /// The lookback period that's used to generate the recommendation.
        public let recommendationLookbackPeriodInDays: Int?
        /// The details about the recommended resource.
        public let recommendedResourceDetails: ResourceDetails?
        /// The resource type of the recommendation.
        public let recommendedResourceType: ResourceType?
        /// The Amazon Web Services Region of the resource.
        public let region: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?
        /// The unique identifier for the resource. This is the same as the Amazon Resource Name (ARN), if available.
        public let resourceId: String?
        /// Whether or not implementing the recommendation requires a restart.
        public let restartNeeded: Bool?
        /// Whether or not implementing the recommendation can be rolled back.
        public let rollbackPossible: Bool?
        /// The source of the recommendation.
        public let source: Source?
        /// A list of tags associated with the resource for which the recommendation exists.
        public let tags: [Tag]?

        @inlinable
        public init(accountId: String? = nil, actionType: ActionType? = nil, costCalculationLookbackPeriodInDays: Int? = nil, currencyCode: String? = nil, currentResourceDetails: ResourceDetails? = nil, currentResourceType: ResourceType? = nil, estimatedMonthlyCost: Double? = nil, estimatedMonthlySavings: Double? = nil, estimatedSavingsOverCostCalculationLookbackPeriod: Double? = nil, estimatedSavingsPercentage: Double? = nil, implementationEffort: ImplementationEffort? = nil, lastRefreshTimestamp: Date? = nil, recommendationId: String? = nil, recommendationLookbackPeriodInDays: Int? = nil, recommendedResourceDetails: ResourceDetails? = nil, recommendedResourceType: ResourceType? = nil, region: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, restartNeeded: Bool? = nil, rollbackPossible: Bool? = nil, source: Source? = nil, tags: [Tag]? = nil) {
            self.accountId = accountId
            self.actionType = actionType
            self.costCalculationLookbackPeriodInDays = costCalculationLookbackPeriodInDays
            self.currencyCode = currencyCode
            self.currentResourceDetails = currentResourceDetails
            self.currentResourceType = currentResourceType
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedSavingsOverCostCalculationLookbackPeriod = estimatedSavingsOverCostCalculationLookbackPeriod
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.implementationEffort = implementationEffort
            self.lastRefreshTimestamp = lastRefreshTimestamp
            self.recommendationId = recommendationId
            self.recommendationLookbackPeriodInDays = recommendationLookbackPeriodInDays
            self.recommendedResourceDetails = recommendedResourceDetails
            self.recommendedResourceType = recommendedResourceType
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.restartNeeded = restartNeeded
            self.rollbackPossible = rollbackPossible
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case actionType = "actionType"
            case costCalculationLookbackPeriodInDays = "costCalculationLookbackPeriodInDays"
            case currencyCode = "currencyCode"
            case currentResourceDetails = "currentResourceDetails"
            case currentResourceType = "currentResourceType"
            case estimatedMonthlyCost = "estimatedMonthlyCost"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case estimatedSavingsOverCostCalculationLookbackPeriod = "estimatedSavingsOverCostCalculationLookbackPeriod"
            case estimatedSavingsPercentage = "estimatedSavingsPercentage"
            case implementationEffort = "implementationEffort"
            case lastRefreshTimestamp = "lastRefreshTimestamp"
            case recommendationId = "recommendationId"
            case recommendationLookbackPeriodInDays = "recommendationLookbackPeriodInDays"
            case recommendedResourceDetails = "recommendedResourceDetails"
            case recommendedResourceType = "recommendedResourceType"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case restartNeeded = "restartNeeded"
            case rollbackPossible = "rollbackPossible"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct InstanceConfiguration: AWSDecodableShape {
        /// The instance type of the configuration.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct LambdaFunction: AWSDecodableShape {
        /// The Lambda function configuration used for recommendations.
        public let configuration: LambdaFunctionConfiguration?
        /// Cost impact of the recommendation.
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: LambdaFunctionConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct LambdaFunctionConfiguration: AWSDecodableShape {
        /// Details about the compute configuration.
        public let compute: ComputeConfiguration?

        @inlinable
        public init(compute: ComputeConfiguration? = nil) {
            self.compute = compute
        }

        private enum CodingKeys: String, CodingKey {
            case compute = "compute"
        }
    }

    public struct ListEnrollmentStatusesRequest: AWSEncodableShape {
        /// The account ID of a member account in the organization.
        public let accountId: String?
        /// Indicates whether to return the enrollment status for the organization.
        public let includeOrganizationInfo: Bool?
        /// The maximum number of objects that are returned for the request.
        public let maxResults: Int?
        /// The token to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(accountId: String? = nil, includeOrganizationInfo: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.includeOrganizationInfo = includeOrganizationInfo
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case includeOrganizationInfo = "includeOrganizationInfo"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnrollmentStatusesResponse: AWSDecodableShape {
        /// The enrollment status of all member accounts in the organization if the account is the management account or delegated administrator.
        public let includeMemberAccounts: Bool?
        /// The enrollment status of a specific account ID, including creation and last updated timestamps.
        public let items: [AccountEnrollmentStatus]?
        /// The token to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(includeMemberAccounts: Bool? = nil, items: [AccountEnrollmentStatus]? = nil, nextToken: String? = nil) {
            self.includeMemberAccounts = includeMemberAccounts
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case includeMemberAccounts = "includeMemberAccounts"
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendationSummariesRequest: AWSEncodableShape {
        public let filter: Filter?
        /// The grouping of recommendations by a dimension.
        public let groupBy: String
        /// The maximum number of recommendations to be returned for the request.
        public let maxResults: Int?
        /// Additional metrics to be returned for the request. The only valid value is savingsPercentage.
        public let metrics: [SummaryMetrics]?
        /// The token to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(filter: Filter? = nil, groupBy: String, maxResults: Int? = nil, metrics: [SummaryMetrics]? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.metrics, name: "metrics", parent: name, max: 100)
            try self.validate(self.metrics, name: "metrics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case groupBy = "groupBy"
            case maxResults = "maxResults"
            case metrics = "metrics"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendationSummariesResponse: AWSDecodableShape {
        /// The currency code used for the recommendation.
        public let currencyCode: String?
        /// The total overall savings for the aggregated view.
        public let estimatedTotalDedupedSavings: Double?
        /// The dimension used to group the recommendations by.
        public let groupBy: String?
        /// A list of all savings recommendations.
        public let items: [RecommendationSummary]?
        /// The results or descriptions for the additional metrics, based on whether the metrics were or were not requested.
        public let metrics: SummaryMetricsResult?
        /// The token to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(currencyCode: String? = nil, estimatedTotalDedupedSavings: Double? = nil, groupBy: String? = nil, items: [RecommendationSummary]? = nil, metrics: SummaryMetricsResult? = nil, nextToken: String? = nil) {
            self.currencyCode = currencyCode
            self.estimatedTotalDedupedSavings = estimatedTotalDedupedSavings
            self.groupBy = groupBy
            self.items = items
            self.metrics = metrics
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "currencyCode"
            case estimatedTotalDedupedSavings = "estimatedTotalDedupedSavings"
            case groupBy = "groupBy"
            case items = "items"
            case metrics = "metrics"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendationsRequest: AWSEncodableShape {
        /// The constraints that you want all returned recommendations to match.
        public let filter: Filter?
        /// List of all recommendations for a resource, or a single recommendation if de-duped by resourceId.
        public let includeAllRecommendations: Bool?
        /// The maximum number of recommendations that are returned for the request.
        public let maxResults: Int?
        /// The token to retrieve the next set of results.
        public let nextToken: String?
        /// The ordering of recommendations by a dimension.
        public let orderBy: OrderBy?

        @inlinable
        public init(filter: Filter? = nil, includeAllRecommendations: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderBy: OrderBy? = nil) {
            self.filter = filter
            self.includeAllRecommendations = includeAllRecommendations
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderBy = orderBy
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case includeAllRecommendations = "includeAllRecommendations"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case orderBy = "orderBy"
        }
    }

    public struct ListRecommendationsResponse: AWSDecodableShape {
        /// List of all savings recommendations.
        public let items: [Recommendation]?
        /// The token to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [Recommendation]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct MemoryDbReservedInstances: AWSDecodableShape {
        /// The MemoryDB reserved instances configuration used for recommendations.
        public let configuration: MemoryDbReservedInstancesConfiguration?
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: MemoryDbReservedInstancesConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct MemoryDbReservedInstancesConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: String?
        /// The instance family of the recommended reservation.
        public let instanceFamily: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// How much purchasing these reserved instances costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let normalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let numberOfInstancesToPurchase: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// Determines whether the recommendation is size flexible.
        public let sizeFlexEligible: Bool?
        /// The reserved instances recommendation term in years.
        public let term: String?
        /// How much purchasing these reserved instances costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, currentGeneration: String? = nil, instanceFamily: String? = nil, instanceType: String? = nil, monthlyRecurringCost: String? = nil, normalizedUnitsToPurchase: String? = nil, numberOfInstancesToPurchase: String? = nil, paymentOption: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, sizeFlexEligible: Bool? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case currentGeneration = "currentGeneration"
            case instanceFamily = "instanceFamily"
            case instanceType = "instanceType"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case normalizedUnitsToPurchase = "normalizedUnitsToPurchase"
            case numberOfInstancesToPurchase = "numberOfInstancesToPurchase"
            case paymentOption = "paymentOption"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case sizeFlexEligible = "sizeFlexEligible"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct MixedInstanceConfiguration: AWSDecodableShape {
        /// The instance type of the configuration.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct OpenSearchReservedInstances: AWSDecodableShape {
        /// The OpenSearch reserved instances configuration used for recommendations.
        public let configuration: OpenSearchReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: OpenSearchReservedInstancesConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct OpenSearchReservedInstancesConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// How much purchasing these reserved instances costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let normalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let numberOfInstancesToPurchase: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// Determines whether the recommendation is size flexible.
        public let sizeFlexEligible: Bool?
        /// The reserved instances recommendation term in years.
        public let term: String?
        /// How much purchasing this instance costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, currentGeneration: String? = nil, instanceType: String? = nil, monthlyRecurringCost: String? = nil, normalizedUnitsToPurchase: String? = nil, numberOfInstancesToPurchase: String? = nil, paymentOption: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, sizeFlexEligible: Bool? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case currentGeneration = "currentGeneration"
            case instanceType = "instanceType"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case normalizedUnitsToPurchase = "normalizedUnitsToPurchase"
            case numberOfInstancesToPurchase = "numberOfInstancesToPurchase"
            case paymentOption = "paymentOption"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case sizeFlexEligible = "sizeFlexEligible"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct OrderBy: AWSEncodableShape {
        /// Sorts by dimension values.
        public let dimension: String?
        /// The order that's used to sort the data.
        public let order: Order?

        @inlinable
        public init(dimension: String? = nil, order: Order? = nil) {
            self.dimension = dimension
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case dimension = "dimension"
            case order = "order"
        }
    }

    public struct RdsDbInstance: AWSDecodableShape {
        /// The Amazon RDS DB instance configuration used for recommendations.
        public let configuration: RdsDbInstanceConfiguration?
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: RdsDbInstanceConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct RdsDbInstanceConfiguration: AWSDecodableShape {
        /// Details about the instance configuration.
        public let instance: DbInstanceConfiguration?

        @inlinable
        public init(instance: DbInstanceConfiguration? = nil) {
            self.instance = instance
        }

        private enum CodingKeys: String, CodingKey {
            case instance = "instance"
        }
    }

    public struct RdsDbInstanceStorage: AWSDecodableShape {
        /// The Amazon RDS DB instance storage configuration used for recommendations.
        public let configuration: RdsDbInstanceStorageConfiguration?
        public let costCalculation: ResourceCostCalculation?

        @inlinable
        public init(configuration: RdsDbInstanceStorageConfiguration? = nil, costCalculation: ResourceCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct RdsDbInstanceStorageConfiguration: AWSDecodableShape {
        /// The new amount of storage in GB to allocate for the DB instance.
        public let allocatedStorageInGb: Double?
        /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.
        public let iops: Double?
        /// The storage throughput for the DB instance.
        public let storageThroughput: Double?
        /// The storage type to associate with the DB instance.
        public let storageType: String?

        @inlinable
        public init(allocatedStorageInGb: Double? = nil, iops: Double? = nil, storageThroughput: Double? = nil, storageType: String? = nil) {
            self.allocatedStorageInGb = allocatedStorageInGb
            self.iops = iops
            self.storageThroughput = storageThroughput
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorageInGb = "allocatedStorageInGb"
            case iops = "iops"
            case storageThroughput = "storageThroughput"
            case storageType = "storageType"
        }
    }

    public struct RdsReservedInstances: AWSDecodableShape {
        /// The RDS reserved instances configuration used for recommendations.
        public let configuration: RdsReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: RdsReservedInstancesConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct RdsReservedInstancesConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: String?
        /// The database edition that the recommended reservation supports.
        public let databaseEdition: String?
        /// The database engine that the recommended reservation supports.
        public let databaseEngine: String?
        /// Determines whether the recommendation is for a reservation in a single Availability Zone or a reservation with a backup in a second Availability Zone.
        public let deploymentOption: String?
        /// The instance family of the recommended reservation.
        public let instanceFamily: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// The license model that the recommended reservation supports.
        public let licenseModel: String?
        /// How much purchasing this instance costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let normalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let numberOfInstancesToPurchase: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// Determines whether the recommendation is size flexible.
        public let sizeFlexEligible: Bool?
        /// The reserved instances recommendation term in years.
        public let term: String?
        /// How much purchasing this instance costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, currentGeneration: String? = nil, databaseEdition: String? = nil, databaseEngine: String? = nil, deploymentOption: String? = nil, instanceFamily: String? = nil, instanceType: String? = nil, licenseModel: String? = nil, monthlyRecurringCost: String? = nil, normalizedUnitsToPurchase: String? = nil, numberOfInstancesToPurchase: String? = nil, paymentOption: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, sizeFlexEligible: Bool? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.databaseEdition = databaseEdition
            self.databaseEngine = databaseEngine
            self.deploymentOption = deploymentOption
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.licenseModel = licenseModel
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case currentGeneration = "currentGeneration"
            case databaseEdition = "databaseEdition"
            case databaseEngine = "databaseEngine"
            case deploymentOption = "deploymentOption"
            case instanceFamily = "instanceFamily"
            case instanceType = "instanceType"
            case licenseModel = "licenseModel"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case normalizedUnitsToPurchase = "normalizedUnitsToPurchase"
            case numberOfInstancesToPurchase = "numberOfInstancesToPurchase"
            case paymentOption = "paymentOption"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case sizeFlexEligible = "sizeFlexEligible"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The account to which the recommendation applies.
        public let accountId: String?
        /// The type of tasks that can be carried out by this action.
        public let actionType: String?
        /// The currency code used for the recommendation.
        public let currencyCode: String?
        /// Describes the current resource.
        public let currentResourceSummary: String?
        /// The current resource type.
        public let currentResourceType: String?
        /// The estimated monthly cost of the current resource. For Reserved Instances and Savings Plans, it refers to the cost for eligible usage.
        public let estimatedMonthlyCost: Double?
        /// The estimated monthly savings amount for the recommendation.
        public let estimatedMonthlySavings: Double?
        /// The estimated savings percentage relative to the total cost over the cost calculation lookback period.
        public let estimatedSavingsPercentage: Double?
        /// The effort required to implement the recommendation.
        public let implementationEffort: String?
        /// The time when the recommendation was last generated.
        public let lastRefreshTimestamp: Date?
        /// The ID for the recommendation.
        public let recommendationId: String?
        /// The lookback period that's used to generate the recommendation.
        public let recommendationLookbackPeriodInDays: Int?
        /// Describes the recommended resource.
        public let recommendedResourceSummary: String?
        /// The recommended resource type.
        public let recommendedResourceType: String?
        /// The Amazon Web Services Region of the resource.
        public let region: String?
        /// The Amazon Resource Name (ARN) for the recommendation.
        public let resourceArn: String?
        /// The resource ID for the recommendation.
        public let resourceId: String?
        /// Whether or not implementing the recommendation requires a restart.
        public let restartNeeded: Bool?
        /// Whether or not implementing the recommendation can be rolled back.
        public let rollbackPossible: Bool?
        /// The source of the recommendation.
        public let source: Source?
        /// A list of tags assigned to the recommendation.
        public let tags: [Tag]?

        @inlinable
        public init(accountId: String? = nil, actionType: String? = nil, currencyCode: String? = nil, currentResourceSummary: String? = nil, currentResourceType: String? = nil, estimatedMonthlyCost: Double? = nil, estimatedMonthlySavings: Double? = nil, estimatedSavingsPercentage: Double? = nil, implementationEffort: String? = nil, lastRefreshTimestamp: Date? = nil, recommendationId: String? = nil, recommendationLookbackPeriodInDays: Int? = nil, recommendedResourceSummary: String? = nil, recommendedResourceType: String? = nil, region: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, restartNeeded: Bool? = nil, rollbackPossible: Bool? = nil, source: Source? = nil, tags: [Tag]? = nil) {
            self.accountId = accountId
            self.actionType = actionType
            self.currencyCode = currencyCode
            self.currentResourceSummary = currentResourceSummary
            self.currentResourceType = currentResourceType
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.implementationEffort = implementationEffort
            self.lastRefreshTimestamp = lastRefreshTimestamp
            self.recommendationId = recommendationId
            self.recommendationLookbackPeriodInDays = recommendationLookbackPeriodInDays
            self.recommendedResourceSummary = recommendedResourceSummary
            self.recommendedResourceType = recommendedResourceType
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.restartNeeded = restartNeeded
            self.rollbackPossible = rollbackPossible
            self.source = source
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case actionType = "actionType"
            case currencyCode = "currencyCode"
            case currentResourceSummary = "currentResourceSummary"
            case currentResourceType = "currentResourceType"
            case estimatedMonthlyCost = "estimatedMonthlyCost"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case estimatedSavingsPercentage = "estimatedSavingsPercentage"
            case implementationEffort = "implementationEffort"
            case lastRefreshTimestamp = "lastRefreshTimestamp"
            case recommendationId = "recommendationId"
            case recommendationLookbackPeriodInDays = "recommendationLookbackPeriodInDays"
            case recommendedResourceSummary = "recommendedResourceSummary"
            case recommendedResourceType = "recommendedResourceType"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case restartNeeded = "restartNeeded"
            case rollbackPossible = "rollbackPossible"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct RecommendationSummary: AWSDecodableShape {
        /// The estimated total savings resulting from modifications, on a monthly basis.
        public let estimatedMonthlySavings: Double?
        /// The grouping of recommendations.
        public let group: String?
        /// The total number of instance recommendations.
        public let recommendationCount: Int?

        @inlinable
        public init(estimatedMonthlySavings: Double? = nil, group: String? = nil, recommendationCount: Int? = nil) {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.group = group
            self.recommendationCount = recommendationCount
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case group = "group"
            case recommendationCount = "recommendationCount"
        }
    }

    public struct RedshiftReservedInstances: AWSDecodableShape {
        /// The Redshift reserved instances configuration used for recommendations.
        public let configuration: RedshiftReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public let costCalculation: ReservedInstancesCostCalculation?

        @inlinable
        public init(configuration: RedshiftReservedInstancesConfiguration? = nil, costCalculation: ReservedInstancesCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct RedshiftReservedInstancesConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: String?
        /// The instance family of the recommended reservation.
        public let instanceFamily: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// How much purchasing these reserved instances costs you on a monthly basis.
        public let monthlyRecurringCost: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let normalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let numberOfInstancesToPurchase: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Amazon Web Services Region of the commitment.
        public let reservedInstancesRegion: String?
        /// The service for which you want recommendations.
        public let service: String?
        /// Determines whether the recommendation is size flexible.
        public let sizeFlexEligible: Bool?
        /// The reserved instances recommendation term in years.
        public let term: String?
        /// How much purchasing this instance costs you upfront.
        public let upfrontCost: String?

        @inlinable
        public init(accountScope: String? = nil, currentGeneration: String? = nil, instanceFamily: String? = nil, instanceType: String? = nil, monthlyRecurringCost: String? = nil, normalizedUnitsToPurchase: String? = nil, numberOfInstancesToPurchase: String? = nil, paymentOption: String? = nil, reservedInstancesRegion: String? = nil, service: String? = nil, sizeFlexEligible: Bool? = nil, term: String? = nil, upfrontCost: String? = nil) {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case currentGeneration = "currentGeneration"
            case instanceFamily = "instanceFamily"
            case instanceType = "instanceType"
            case monthlyRecurringCost = "monthlyRecurringCost"
            case normalizedUnitsToPurchase = "normalizedUnitsToPurchase"
            case numberOfInstancesToPurchase = "numberOfInstancesToPurchase"
            case paymentOption = "paymentOption"
            case reservedInstancesRegion = "reservedInstancesRegion"
            case service = "service"
            case sizeFlexEligible = "sizeFlexEligible"
            case term = "term"
            case upfrontCost = "upfrontCost"
        }
    }

    public struct ReservedInstancesCostCalculation: AWSDecodableShape {
        /// Pricing details of the purchase recommendation.
        public let pricing: ReservedInstancesPricing?

        @inlinable
        public init(pricing: ReservedInstancesPricing? = nil) {
            self.pricing = pricing
        }

        private enum CodingKeys: String, CodingKey {
            case pricing = "pricing"
        }
    }

    public struct ReservedInstancesPricing: AWSDecodableShape {
        /// The estimated cost of your recurring monthly fees for the recommended reserved instance across the month.
        public let estimatedMonthlyAmortizedReservationCost: Double?
        /// The remaining On-Demand cost estimated to not be covered by the recommended reserved instance, over the length of the lookback period.
        public let estimatedOnDemandCost: Double?
        /// The cost of paying for the recommended reserved instance monthly.
        public let monthlyReservationEligibleCost: Double?
        /// The savings percentage relative to the total On-Demand costs that are associated with this instance.
        public let savingsPercentage: Double?

        @inlinable
        public init(estimatedMonthlyAmortizedReservationCost: Double? = nil, estimatedOnDemandCost: Double? = nil, monthlyReservationEligibleCost: Double? = nil, savingsPercentage: Double? = nil) {
            self.estimatedMonthlyAmortizedReservationCost = estimatedMonthlyAmortizedReservationCost
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.monthlyReservationEligibleCost = monthlyReservationEligibleCost
            self.savingsPercentage = savingsPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMonthlyAmortizedReservationCost = "estimatedMonthlyAmortizedReservationCost"
            case estimatedOnDemandCost = "estimatedOnDemandCost"
            case monthlyReservationEligibleCost = "monthlyReservationEligibleCost"
            case savingsPercentage = "savingsPercentage"
        }
    }

    public struct ResourceCostCalculation: AWSDecodableShape {
        /// Pricing details of the resource recommendation.
        public let pricing: ResourcePricing?
        /// Usage details of the resource recommendation.
        public let usages: [Usage]?

        @inlinable
        public init(pricing: ResourcePricing? = nil, usages: [Usage]? = nil) {
            self.pricing = pricing
            self.usages = usages
        }

        private enum CodingKeys: String, CodingKey {
            case pricing = "pricing"
            case usages = "usages"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The identifier of the resource that was not found.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceId: String) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
        }
    }

    public struct ResourcePricing: AWSDecodableShape {
        /// The savings estimate incorporating all discounts with Amazon Web Services, such as Reserved Instances and Savings Plans.
        public let estimatedCostAfterDiscounts: Double?
        /// The savings estimate using Amazon Web Services public pricing without incorporating any discounts.
        public let estimatedCostBeforeDiscounts: Double?
        /// The estimated discounts for a recommendation.
        public let estimatedDiscounts: EstimatedDiscounts?
        /// The estimated net unused amortized commitment for the recommendation.
        public let estimatedNetUnusedAmortizedCommitments: Double?

        @inlinable
        public init(estimatedCostAfterDiscounts: Double? = nil, estimatedCostBeforeDiscounts: Double? = nil, estimatedDiscounts: EstimatedDiscounts? = nil, estimatedNetUnusedAmortizedCommitments: Double? = nil) {
            self.estimatedCostAfterDiscounts = estimatedCostAfterDiscounts
            self.estimatedCostBeforeDiscounts = estimatedCostBeforeDiscounts
            self.estimatedDiscounts = estimatedDiscounts
            self.estimatedNetUnusedAmortizedCommitments = estimatedNetUnusedAmortizedCommitments
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedCostAfterDiscounts = "estimatedCostAfterDiscounts"
            case estimatedCostBeforeDiscounts = "estimatedCostBeforeDiscounts"
            case estimatedDiscounts = "estimatedDiscounts"
            case estimatedNetUnusedAmortizedCommitments = "estimatedNetUnusedAmortizedCommitments"
        }
    }

    public struct SageMakerSavingsPlans: AWSDecodableShape {
        /// The SageMaker Savings Plans configuration used for recommendations.
        public let configuration: SageMakerSavingsPlansConfiguration?
        /// Cost impact of the Savings Plans purchase recommendation.
        public let costCalculation: SavingsPlansCostCalculation?

        @inlinable
        public init(configuration: SageMakerSavingsPlansConfiguration? = nil, costCalculation: SavingsPlansCostCalculation? = nil) {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case costCalculation = "costCalculation"
        }
    }

    public struct SageMakerSavingsPlansConfiguration: AWSDecodableShape {
        /// The account scope for which you want recommendations.
        public let accountScope: String?
        /// The hourly commitment for the Savings Plans type.
        public let hourlyCommitment: String?
        /// The payment option for the commitment.
        public let paymentOption: String?
        /// The Savings Plans recommendation term in years.
        public let term: String?

        @inlinable
        public init(accountScope: String? = nil, hourlyCommitment: String? = nil, paymentOption: String? = nil, term: String? = nil) {
            self.accountScope = accountScope
            self.hourlyCommitment = hourlyCommitment
            self.paymentOption = paymentOption
            self.term = term
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "accountScope"
            case hourlyCommitment = "hourlyCommitment"
            case paymentOption = "paymentOption"
            case term = "term"
        }
    }

    public struct SavingsPlansCostCalculation: AWSDecodableShape {
        /// Pricing details of the purchase recommendation.
        public let pricing: SavingsPlansPricing?

        @inlinable
        public init(pricing: SavingsPlansPricing? = nil) {
            self.pricing = pricing
        }

        private enum CodingKeys: String, CodingKey {
            case pricing = "pricing"
        }
    }

    public struct SavingsPlansPricing: AWSDecodableShape {
        /// Estimated monthly commitment for the Savings Plan.
        public let estimatedMonthlyCommitment: Double?
        /// Estimated On-Demand cost you will pay after buying the Savings Plan.
        public let estimatedOnDemandCost: Double?
        /// The cost of paying for the recommended Savings Plan monthly.
        public let monthlySavingsPlansEligibleCost: Double?
        /// Estimated savings as a percentage of your overall costs after buying the Savings Plan.
        public let savingsPercentage: Double?

        @inlinable
        public init(estimatedMonthlyCommitment: Double? = nil, estimatedOnDemandCost: Double? = nil, monthlySavingsPlansEligibleCost: Double? = nil, savingsPercentage: Double? = nil) {
            self.estimatedMonthlyCommitment = estimatedMonthlyCommitment
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.monthlySavingsPlansEligibleCost = monthlySavingsPlansEligibleCost
            self.savingsPercentage = savingsPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMonthlyCommitment = "estimatedMonthlyCommitment"
            case estimatedOnDemandCost = "estimatedOnDemandCost"
            case monthlySavingsPlansEligibleCost = "monthlySavingsPlansEligibleCost"
            case savingsPercentage = "savingsPercentage"
        }
    }

    public struct StorageConfiguration: AWSDecodableShape {
        /// The storage volume.
        public let sizeInGb: Double?
        /// The storage type.
        public let type: String?

        @inlinable
        public init(sizeInGb: Double? = nil, type: String? = nil) {
            self.sizeInGb = sizeInGb
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case sizeInGb = "sizeInGb"
            case type = "type"
        }
    }

    public struct SummaryMetricsResult: AWSDecodableShape {
        /// The savings percentage based on your Amazon Web Services spend over the past 30 days.  Savings percentage is only supported when filtering by Region, account ID, or tags.
        public let savingsPercentage: String?

        @inlinable
        public init(savingsPercentage: String? = nil) {
            self.savingsPercentage = savingsPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case savingsPercentage = "savingsPercentage"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key that's associated with the tag.
        public let key: String?
        /// The value that's associated with the tag.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct UpdateEnrollmentStatusRequest: AWSEncodableShape {
        /// Indicates whether to enroll member accounts of the organization if the account is the management account or delegated administrator.
        public let includeMemberAccounts: Bool?
        /// Sets the account status.
        public let status: EnrollmentStatus

        @inlinable
        public init(includeMemberAccounts: Bool? = nil, status: EnrollmentStatus) {
            self.includeMemberAccounts = includeMemberAccounts
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case includeMemberAccounts = "includeMemberAccounts"
            case status = "status"
        }
    }

    public struct UpdateEnrollmentStatusResponse: AWSDecodableShape {
        /// The enrollment status of the account.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdatePreferencesRequest: AWSEncodableShape {
        /// Sets the "member account discount visibility" preference.
        public let memberAccountDiscountVisibility: MemberAccountDiscountVisibility?
        /// Sets the "savings estimation mode" preference.
        public let savingsEstimationMode: SavingsEstimationMode?

        @inlinable
        public init(memberAccountDiscountVisibility: MemberAccountDiscountVisibility? = nil, savingsEstimationMode: SavingsEstimationMode? = nil) {
            self.memberAccountDiscountVisibility = memberAccountDiscountVisibility
            self.savingsEstimationMode = savingsEstimationMode
        }

        private enum CodingKeys: String, CodingKey {
            case memberAccountDiscountVisibility = "memberAccountDiscountVisibility"
            case savingsEstimationMode = "savingsEstimationMode"
        }
    }

    public struct UpdatePreferencesResponse: AWSDecodableShape {
        /// Shows the status of the "member account discount visibility" preference.
        public let memberAccountDiscountVisibility: MemberAccountDiscountVisibility?
        /// Shows the status of the "savings estimation mode" preference.
        public let savingsEstimationMode: SavingsEstimationMode?

        @inlinable
        public init(memberAccountDiscountVisibility: MemberAccountDiscountVisibility? = nil, savingsEstimationMode: SavingsEstimationMode? = nil) {
            self.memberAccountDiscountVisibility = memberAccountDiscountVisibility
            self.savingsEstimationMode = savingsEstimationMode
        }

        private enum CodingKeys: String, CodingKey {
            case memberAccountDiscountVisibility = "memberAccountDiscountVisibility"
            case savingsEstimationMode = "savingsEstimationMode"
        }
    }

    public struct Usage: AWSDecodableShape {
        /// The operation value.
        public let operation: String?
        /// The product code.
        public let productCode: String?
        /// The usage unit.
        public let unit: String?
        /// The usage amount.
        public let usageAmount: Double?
        /// The usage type.
        public let usageType: String?

        @inlinable
        public init(operation: String? = nil, productCode: String? = nil, unit: String? = nil, usageAmount: Double? = nil, usageType: String? = nil) {
            self.operation = operation
            self.productCode = productCode
            self.unit = unit
            self.usageAmount = usageAmount
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "operation"
            case productCode = "productCode"
            case unit = "unit"
            case usageAmount = "usageAmount"
            case usageType = "usageType"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The list of fields that are invalid.
        public let fields: [ValidationExceptionDetail]?
        public let message: String
        /// The reason for the validation exception.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fields: [ValidationExceptionDetail]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionDetail: AWSDecodableShape {
        /// The field name where the invalid entry was detected.
        public let fieldName: String
        /// A message with the reason for the validation exception error.
        public let message: String

        @inlinable
        public init(fieldName: String, message: String) {
            self.fieldName = fieldName
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
            case message = "message"
        }
    }
}

// MARK: - Errors

/// Error enum for CostOptimizationHub
public struct CostOptimizationHubErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CostOptimizationHub
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to use this operation with the given parameters.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An error on the server occurred during the processing of your request. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified Amazon Resource Name (ARN) in the request doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension CostOptimizationHubErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": CostOptimizationHub.ResourceNotFoundException.self,
        "ValidationException": CostOptimizationHub.ValidationException.self
    ]
}

extension CostOptimizationHubErrorType: Equatable {
    public static func == (lhs: CostOptimizationHubErrorType, rhs: CostOptimizationHubErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CostOptimizationHubErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
