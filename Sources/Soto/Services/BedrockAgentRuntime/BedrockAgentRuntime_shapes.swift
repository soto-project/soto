//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentRuntime {
    // MARK: Enums

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalResultLocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum RetrieveAndGenerateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "HYBRID"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case parser = "PARSER"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case askUser = "ASK_USER"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case reprompt = "REPROMPT"
        public var description: String { return self.rawValue }
    }

    public enum OrchestrationTrace: AWSDecodableShape, Sendable {
        /// Contains information pertaining to the action group or knowledge base that is being invoked.
        case invocationInput(InvocationInput)
        /// The input for the orchestration step.   The type is ORCHESTRATION.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// Details about the observation (the output of the action group Lambda or knowledge base) made by the agent.
        case observation(Observation)
        /// Details about the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
        case rationale(Rationale)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .invocationInput:
                let value = try container.decode(InvocationInput.self, forKey: .invocationInput)
                self = .invocationInput(value)
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .observation:
                let value = try container.decode(Observation.self, forKey: .observation)
                self = .observation(value)
            case .rationale:
                let value = try container.decode(Rationale.self, forKey: .rationale)
                self = .rationale(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invocationInput = "invocationInput"
            case modelInvocationInput = "modelInvocationInput"
            case observation = "observation"
            case rationale = "rationale"
        }
    }

    public enum PostProcessingTrace: AWSDecodableShape, Sendable {
        /// The input for the post-processing step.   The type is POST_PROCESSING.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// The foundation model output from the post-processing step.
        case modelInvocationOutput(PostProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PostProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum PreProcessingTrace: AWSDecodableShape, Sendable {
        /// The input for the pre-processing step.   The type is PRE_PROCESSING.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// The foundation model output from the pre-processing step.
        case modelInvocationOutput(PreProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PreProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// Contains a part of an agent response and citations for it.
        case chunk(PayloadPart)
        /// There was a conflict performing an operation. Resolve the conflict and retry your request.
        case conflictException(ConflictException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// The specified resource ARN was not found. Check the ARN and try your request again.
        case resourceNotFoundException(ResourceNotFoundException)
        /// The number of requests exceeds the service quota. Resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// The number of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling API actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see Trace events.
        case trace(TracePart)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .chunk:
                let value = try container.decode(PayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .trace:
                let value = try container.decode(TracePart.self, forKey: .trace)
                self = .trace(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case chunk = "chunk"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case trace = "trace"
            case validationException = "validationException"
        }
    }

    public enum RetrievalFilter: AWSEncodableShape, Sendable {
        /// Knowledge base data sources whose metadata attributes fulfill all the filter conditions inside this list are returned.
        case andAll([RetrievalFilter])
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value matches the value in this object are returned.
        case equals(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is greater than the value in this object are returned.
        case greaterThan(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object are returned.
        case greaterThanOrEquals(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object are returned.
        case `in`(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is less than the value in this object are returned.
        case lessThan(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object are returned.
        case lessThanOrEquals(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned.
        case notEquals(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object are returned.
        case notIn(FilterAttribute)
        /// Knowledge base data sources whose metadata attributes fulfill at least one of the filter conditions inside this list are returned.
        case orAll([RetrievalFilter])
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value starts with the value in this object are returned. This filter is currently only supported for Amazon OpenSearch Serverless vector stores.
        case startsWith(FilterAttribute)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .equals(let value):
                try container.encode(value, forKey: .equals)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEquals(let value):
                try container.encode(value, forKey: .greaterThanOrEquals)
            case .`in`(let value):
                try container.encode(value, forKey: .`in`)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEquals(let value):
                try container.encode(value, forKey: .lessThanOrEquals)
            case .notEquals(let value):
                try container.encode(value, forKey: .notEquals)
            case .notIn(let value):
                try container.encode(value, forKey: .notIn)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            case .startsWith(let value):
                try container.encode(value, forKey: .startsWith)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
                try self.validate(value, name: "andAll", parent: name, max: 5)
                try self.validate(value, name: "andAll", parent: name, min: 2)
            case .equals(let value):
                try value.validate(name: "\(name).equals")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEquals(let value):
                try value.validate(name: "\(name).greaterThanOrEquals")
            case .`in`(let value):
                try value.validate(name: "\(name).`in`")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEquals(let value):
                try value.validate(name: "\(name).lessThanOrEquals")
            case .notEquals(let value):
                try value.validate(name: "\(name).notEquals")
            case .notIn(let value):
                try value.validate(name: "\(name).notIn")
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
                try self.validate(value, name: "orAll", parent: name, max: 5)
                try self.validate(value, name: "orAll", parent: name, min: 2)
            case .startsWith(let value):
                try value.validate(name: "\(name).startsWith")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case equals = "equals"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case `in` = "in"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case notEquals = "notEquals"
            case notIn = "notIn"
            case orAll = "orAll"
            case startsWith = "startsWith"
        }
    }

    public enum Trace: AWSDecodableShape, Sendable {
        /// Contains information about the failure of the interaction.
        case failureTrace(FailureTrace)
        /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
        case orchestrationTrace(OrchestrationTrace)
        /// Details about the post-processing step, in which the agent shapes the response..
        case postProcessingTrace(PostProcessingTrace)
        /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
        case preProcessingTrace(PreProcessingTrace)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .failureTrace:
                let value = try container.decode(FailureTrace.self, forKey: .failureTrace)
                self = .failureTrace(value)
            case .orchestrationTrace:
                let value = try container.decode(OrchestrationTrace.self, forKey: .orchestrationTrace)
                self = .orchestrationTrace(value)
            case .postProcessingTrace:
                let value = try container.decode(PostProcessingTrace.self, forKey: .postProcessingTrace)
                self = .postProcessingTrace(value)
            case .preProcessingTrace:
                let value = try container.decode(PreProcessingTrace.self, forKey: .preProcessingTrace)
                self = .preProcessingTrace(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case failureTrace = "failureTrace"
            case orchestrationTrace = "orchestrationTrace"
            case postProcessingTrace = "postProcessingTrace"
            case preProcessingTrace = "preProcessingTrace"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActionGroupInvocationInput: AWSDecodableShape {
        /// The name of the action group.
        public let actionGroupName: String?
        /// The path to the API to call, based off the action group.
        public let apiPath: String?
        /// The parameters in the Lambda input event.
        public let parameters: [Parameter]?
        /// The parameters in the request body for the Lambda input event.
        public let requestBody: RequestBody?
        /// The API method being used, based off the action group.
        public let verb: String?

        public init(actionGroupName: String? = nil, apiPath: String? = nil, parameters: [Parameter]? = nil, requestBody: RequestBody? = nil, verb: String? = nil) {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupName = "actionGroupName"
            case apiPath = "apiPath"
            case parameters = "parameters"
            case requestBody = "requestBody"
            case verb = "verb"
        }
    }

    public struct ActionGroupInvocationOutput: AWSDecodableShape {
        /// The JSON-formatted string returned by the API invoked by the action group.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct Attribution: AWSDecodableShape {
        /// A list of citations and related information for a part of an agent response.
        public let citations: [Citation]?

        public init(citations: [Citation]? = nil) {
            self.citations = citations
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
        }
    }

    public struct BadGatewayException: AWSDecodableShape {
        public let message: String?
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public let resourceName: String?

        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct Citation: AWSDecodableShape {
        /// Contains the generated response and metadata
        public let generatedResponsePart: GeneratedResponsePart?
        /// Contains metadata about the sources cited for the generated response.
        public let retrievedReferences: [RetrievedReference]?

        public init(generatedResponsePart: GeneratedResponsePart? = nil, retrievedReferences: [RetrievedReference]? = nil) {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case generatedResponsePart = "generatedResponsePart"
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DependencyFailedException: AWSDecodableShape {
        public let message: String?
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public let resourceName: String?

        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct FailureTrace: AWSDecodableShape {
        /// The reason the interaction failed.
        public let failureReason: String?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(failureReason: String? = nil, traceId: String? = nil) {
            self.failureReason = failureReason
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "failureReason"
            case traceId = "traceId"
        }
    }

    public struct FilterAttribute: AWSEncodableShape {
        /// The name that the metadata attribute must match.
        public let key: String
        /// The value to whcih to compare the value of the metadata attribute.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 100)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct FinalResponse: AWSDecodableShape {
        /// The text in the response to the user.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct GeneratedResponsePart: AWSDecodableShape {
        /// Contains metadata about a textual part of the generated response that is accompanied by a citation.
        public let textResponsePart: TextResponsePart?

        public init(textResponsePart: TextResponsePart? = nil) {
            self.textResponsePart = textResponsePart
        }

        private enum CodingKeys: String, CodingKey {
            case textResponsePart = "textResponsePart"
        }
    }

    public struct GenerationConfiguration: AWSEncodableShape {
        /// Contains the template for the prompt that's sent to the model for response generation.
        public let promptTemplate: PromptTemplate?

        public init(promptTemplate: PromptTemplate? = nil) {
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case promptTemplate = "promptTemplate"
        }
    }

    public struct InferenceConfiguration: AWSDecodableShape {
        /// The maximum number of tokens allowed in the generated response.
        public let maximumLength: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public let temperature: Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public let topK: Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public let topP: Float?

        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvocationInput: AWSDecodableShape {
        /// Contains information about the action group to be invoked.
        public let actionGroupInvocationInput: ActionGroupInvocationInput?
        /// Specifies whether the agent is invoking an action group or a knowledge base.
        public let invocationType: InvocationType?
        /// Contains details about the knowledge base to look up and the query to be made.
        public let knowledgeBaseLookupInput: KnowledgeBaseLookupInput?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(actionGroupInvocationInput: ActionGroupInvocationInput? = nil, invocationType: InvocationType? = nil, knowledgeBaseLookupInput: KnowledgeBaseLookupInput? = nil, traceId: String? = nil) {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationInput = "actionGroupInvocationInput"
            case invocationType = "invocationType"
            case knowledgeBaseLookupInput = "knowledgeBaseLookupInput"
            case traceId = "traceId"
        }
    }

    public struct InvokeAgentRequest: AWSEncodableShape {
        /// The alias of the agent to use.
        public let agentAliasId: String
        /// The unique identifier of the agent to use.
        public let agentId: String
        /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see Trace enablement.
        public let enableTrace: Bool?
        /// Specifies whether to end the session with the agent or not.
        public let endSession: Bool?
        /// The prompt text to send the agent.
        public let inputText: String
        /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
        public let sessionId: String
        /// Contains parameters that specify various attributes of the session. For more information, see Control session context.
        public let sessionState: SessionState?

        public init(agentAliasId: String, agentId: String, enableTrace: Bool? = nil, endSession: Bool? = nil, inputText: String, sessionId: String, sessionState: SessionState? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.enableTrace = enableTrace
            self.endSession = endSession
            self.inputText = inputText
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.enableTrace, forKey: .enableTrace)
            try container.encodeIfPresent(self.endSession, forKey: .endSession)
            try container.encode(self.inputText, forKey: .inputText)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.sessionState, forKey: .sessionState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.inputText, name: "inputText", parent: name, max: 25000000)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case enableTrace = "enableTrace"
            case endSession = "endSession"
            case inputText = "inputText"
            case sessionState = "sessionState"
        }
    }

    public struct InvokeAgentResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The agent's response to the user prompt.
        public let completion: AWSEventStream<ResponseStream>
        /// The MIME type of the input data in the request. The default value is application/json.
        public let contentType: String
        /// The unique identifier of the session with the agent.
        public let sessionId: String

        public init(completion: AWSEventStream<ResponseStream>, contentType: String, sessionId: String) {
            self.completion = completion
            self.contentType = contentType
            self.sessionId = sessionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.completion = try container.decode(AWSEventStream<ResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "x-amzn-bedrock-agent-content-type")
            self.sessionId = try response.decodeHeader(String.self, key: "x-amz-bedrock-agent-session-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct KnowledgeBaseLookupInput: AWSDecodableShape {
        /// The unique identifier of the knowledge base to look up.
        public let knowledgeBaseId: String?
        /// The query made to the knowledge base.
        public let text: String?

        public init(knowledgeBaseId: String? = nil, text: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case text = "text"
        }
    }

    public struct KnowledgeBaseLookupOutput: AWSDecodableShape {
        /// Contains metadata about the sources cited for the generated response.
        public let retrievedReferences: [RetrievedReference]?

        public init(retrievedReferences: [RetrievedReference]? = nil) {
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct KnowledgeBaseQuery: AWSEncodableShape {
        /// The text of the query made to the knowledge base.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct KnowledgeBaseRetrievalConfiguration: AWSEncodableShape {
        /// Contains details about how the results from the vector search should be returned. For more information, see Query configurations.
        public let vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration

        public init(vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.vectorSearchConfiguration.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct KnowledgeBaseRetrievalResult: AWSDecodableShape {
        /// Contains a chunk of text from a data source in the knowledge base.
        public let content: RetrievalResultContent
        /// Contains information about the location of the data source.
        public let location: RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see Metadata and filtering.
        public let metadata: [String: String]?
        /// The level of relevance of the result to the query.
        public let score: Double?

        public init(content: RetrievalResultContent, location: RetrievalResultLocation? = nil, metadata: [String: String]? = nil, score: Double? = nil) {
            self.content = content
            self.location = location
            self.metadata = metadata
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case metadata = "metadata"
            case score = "score"
        }
    }

    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// Contains configurations for response generation based on the knowwledge base query results.
        public let generationConfiguration: GenerationConfiguration?
        /// The unique identifier of the knowledge base that is queried and the foundation model used for generation.
        public let knowledgeBaseId: String
        /// The ARN of the foundation model used to generate a response.
        public let modelArn: String
        /// Contains configurations for how to retrieve and return the knowledge base query.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?

        public init(generationConfiguration: GenerationConfiguration? = nil, knowledgeBaseId: String, modelArn: String, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil) {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 1011)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 20)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}))$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case modelArn = "modelArn"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseVectorSearchConfiguration: AWSEncodableShape {
        /// Specifies the filters to use on the metadata in the knowledge base data sources before returning results. For more information, see Query configurations.
        public let filter: RetrievalFilter?
        /// The number of source chunks to retrieve.
        public let numberOfResults: Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available. For more information, see Test a knowledge base.
        public let overrideSearchType: SearchType?

        public init(filter: RetrievalFilter? = nil, numberOfResults: Int? = nil, overrideSearchType: SearchType? = nil) {
            self.filter = filter
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case numberOfResults = "numberOfResults"
            case overrideSearchType = "overrideSearchType"
        }
    }

    public struct ModelInvocationInput: AWSDecodableShape {
        /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the PromptOverrideConfiguration object that was set when the agent was created or updated. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.
        public let overrideLambda: String?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType.
        public let parserMode: CreationMode?
        /// Specifies whether the default prompt template was OVERRIDDEN. If it was, the basePromptTemplate that was set in the PromptOverrideConfiguration object when the agent was created or updated is used instead.
        public let promptCreationMode: CreationMode?
        /// The text that prompted the agent at this step.
        public let text: String?
        /// The unique identifier of the trace.
        public let traceId: String?
        /// The step in the agent sequence.
        public let type: PromptType?

        public init(inferenceConfiguration: InferenceConfiguration? = nil, overrideLambda: String? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, text: String? = nil, traceId: String? = nil, type: PromptType? = nil) {
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceConfiguration = "inferenceConfiguration"
            case overrideLambda = "overrideLambda"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case text = "text"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct Observation: AWSDecodableShape {
        /// Contains the JSON-formatted string returned by the API invoked by the action group.
        public let actionGroupInvocationOutput: ActionGroupInvocationOutput?
        /// Contains details about the response to the user.
        public let finalResponse: FinalResponse?
        /// Contains details about the results from looking up the knowledge base.
        public let knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput?
        /// Contains details about the response to reprompt the input.
        public let repromptResponse: RepromptResponse?
        /// The unique identifier of the trace.
        public let traceId: String?
        /// Specifies what kind of information the agent returns in the observation. The following values are possible.    ACTION_GROUP – The agent returns the result of an action group.    KNOWLEDGE_BASE – The agent returns information from a knowledge base.    FINISH – The agent returns a final response to the user with no follow-up.    ASK_USER – The agent asks the user a question.    REPROMPT – The agent prompts the user again for the same information.
        public let type: `Type`?

        public init(actionGroupInvocationOutput: ActionGroupInvocationOutput? = nil, finalResponse: FinalResponse? = nil, knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput? = nil, repromptResponse: RepromptResponse? = nil, traceId: String? = nil, type: `Type`? = nil) {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationOutput = "actionGroupInvocationOutput"
            case finalResponse = "finalResponse"
            case knowledgeBaseLookupOutput = "knowledgeBaseLookupOutput"
            case repromptResponse = "repromptResponse"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct Parameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The type of the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct PayloadPart: AWSDecodableShape {
        /// Contains citations for a part of an agent response.
        public let attribution: Attribution?
        /// A part of the agent response in bytes.
        public let bytes: AWSBase64Data?

        public init(attribution: Attribution? = nil, bytes: AWSBase64Data? = nil) {
            self.attribution = attribution
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case attribution = "attribution"
            case bytes = "bytes"
        }
    }

    public struct PostProcessingModelInvocationOutput: AWSDecodableShape {
        /// Details about the response from the Lambda parsing of the output of the post-processing step.
        public let parsedResponse: PostProcessingParsedResponse?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(parsedResponse: PostProcessingParsedResponse? = nil, traceId: String? = nil) {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case parsedResponse = "parsedResponse"
            case traceId = "traceId"
        }
    }

    public struct PostProcessingParsedResponse: AWSDecodableShape {
        /// The text returned by the parser.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct PreProcessingModelInvocationOutput: AWSDecodableShape {
        /// Details about the response from the Lambda parsing of the output of the pre-processing step.
        public let parsedResponse: PreProcessingParsedResponse?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(parsedResponse: PreProcessingParsedResponse? = nil, traceId: String? = nil) {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case parsedResponse = "parsedResponse"
            case traceId = "traceId"
        }
    }

    public struct PreProcessingParsedResponse: AWSDecodableShape {
        /// Whether the user input is valid or not. If false, the agent doesn't proceed to orchestration.
        public let isValid: Bool?
        /// The text returned by the parsing of the pre-processing step, explaining the steps that the agent plans to take in orchestration, if the user input is valid.
        public let rationale: String?

        public init(isValid: Bool? = nil, rationale: String? = nil) {
            self.isValid = isValid
            self.rationale = rationale
        }

        private enum CodingKeys: String, CodingKey {
            case isValid = "isValid"
            case rationale = "rationale"
        }
    }

    public struct PromptTemplate: AWSEncodableShape {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see the following resources:    Knowledge base prompt templates     Use XML tags with Anthropic Claude models
        public let textPromptTemplate: String?

        public init(textPromptTemplate: String? = nil) {
            self.textPromptTemplate = textPromptTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, max: 4000)
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case textPromptTemplate = "textPromptTemplate"
        }
    }

    public struct Rationale: AWSDecodableShape {
        /// The reasoning or thought process of the agent, based on the input.
        public let text: String?
        /// The unique identifier of the trace step.
        public let traceId: String?

        public init(text: String? = nil, traceId: String? = nil) {
            self.text = text
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case traceId = "traceId"
        }
    }

    public struct RepromptResponse: AWSDecodableShape {
        /// Specifies what output is prompting the agent to reprompt the input.
        public let source: Source?
        /// The text reprompting the input.
        public let text: String?

        public init(source: Source? = nil, text: String? = nil) {
            self.source = source
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case text = "text"
        }
    }

    public struct RequestBody: AWSDecodableShape {
        /// The content in the request body.
        public let content: [String: [Parameter]]?

        public init(content: [String: [Parameter]]? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetrievalResultContent: AWSDecodableShape {
        /// The cited text from the data source.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrievalResultLocation: AWSDecodableShape {
        /// Contains the S3 location of the data source.
        public let s3Location: RetrievalResultS3Location?
        /// The type of the location of the data source.
        public let type: RetrievalResultLocationType

        public init(s3Location: RetrievalResultS3Location? = nil, type: RetrievalResultLocationType) {
            self.s3Location = s3Location
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
            case type = "type"
        }
    }

    public struct RetrievalResultS3Location: AWSDecodableShape {
        /// The S3 URI of the data source.
        public let uri: String?

        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct RetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// Contains details about the resource being queried.
        public let knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that is queried by the request.
        public let type: RetrieveAndGenerateType

        public init(knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration? = nil, type: RetrieveAndGenerateType) {
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.knowledgeBaseConfiguration?.validate(name: "\(name).knowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case type = "type"
        }
    }

    public struct RetrieveAndGenerateInput: AWSEncodableShape {
        /// The query made to the knowledge base.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateOutput: AWSDecodableShape {
        /// The response generated from querying the knowledge base.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateRequest: AWSEncodableShape {
        /// Contains the query to be made to the knowledge base.
        public let input: RetrieveAndGenerateInput
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration?
        /// Contains details about the session with the knowledge base.
        public let sessionConfiguration: RetrieveAndGenerateSessionConfiguration?
        /// The unique identifier of the session. Reuse the same value to continue the same session with the knowledge base.
        public let sessionId: String?

        public init(input: RetrieveAndGenerateInput, retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration? = nil, sessionConfiguration: RetrieveAndGenerateSessionConfiguration? = nil, sessionId: String? = nil) {
            self.input = input
            self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
            self.sessionConfiguration = sessionConfiguration
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.retrieveAndGenerateConfiguration?.validate(name: "\(name).retrieveAndGenerateConfiguration")
            try self.sessionConfiguration?.validate(name: "\(name).sessionConfiguration")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case retrieveAndGenerateConfiguration = "retrieveAndGenerateConfiguration"
            case sessionConfiguration = "sessionConfiguration"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateResponse: AWSDecodableShape {
        /// A list of segments of the generated response that are based on sources in the knowledge base, alongside information about the sources.
        public let citations: [Citation]?
        /// Contains the response generated from querying the knowledge base.
        public let output: RetrieveAndGenerateOutput
        /// The unique identifier of the session. Reuse the same value to continue the same session with the knowledge base.
        public let sessionId: String

        public init(citations: [Citation]? = nil, output: RetrieveAndGenerateOutput, sessionId: String) {
            self.citations = citations
            self.output = output
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
            case output = "output"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateSessionConfiguration: AWSEncodableShape {
        /// The ARN of the KMS key encrypting the session.
        public let kmsKeyArn: String

        public init(kmsKeyArn: String) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct RetrieveRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base to query.
        public let knowledgeBaseId: String
        /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
        public let nextToken: String?
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?
        /// Contains the query to send the knowledge base.
        public let retrievalQuery: KnowledgeBaseQuery

        public init(knowledgeBaseId: String, nextToken: String? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil, retrievalQuery: KnowledgeBaseQuery) {
            self.knowledgeBaseId = knowledgeBaseId
            self.nextToken = nextToken
            self.retrievalConfiguration = retrievalConfiguration
            self.retrievalQuery = retrievalQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.retrievalConfiguration, forKey: .retrievalConfiguration)
            try container.encode(self.retrievalQuery, forKey: .retrievalQuery)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievalConfiguration = "retrievalConfiguration"
            case retrievalQuery = "retrievalQuery"
        }
    }

    public struct RetrieveResponse: AWSDecodableShape {
        /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
        public let nextToken: String?
        /// A list of results from querying the knowledge base.
        public let retrievalResults: [KnowledgeBaseRetrievalResult]

        public init(nextToken: String? = nil, retrievalResults: [KnowledgeBaseRetrievalResult]) {
            self.nextToken = nextToken
            self.retrievalResults = retrievalResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievalResults = "retrievalResults"
        }
    }

    public struct RetrievedReference: AWSDecodableShape {
        /// Contains the cited text from the data source.
        public let content: RetrievalResultContent?
        /// Contains information about the location of the data source.
        public let location: RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see Metadata and filtering.
        public let metadata: [String: String]?

        public init(content: RetrievalResultContent? = nil, location: RetrievalResultLocation? = nil, metadata: [String: String]? = nil) {
            self.content = content
            self.location = location
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case metadata = "metadata"
        }
    }

    public struct ServiceQuotaExceededException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SessionState: AWSEncodableShape {
        /// Contains attributes that persist across a prompt and the values of those attributes. These attributes replace the $prompt_session_attributes$ placeholder variable in the orchestration prompt template. For more information, see Prompt template placeholder variables.
        public let promptSessionAttributes: [String: String]?
        /// Contains attributes that persist across a session and the values of those attributes.
        public let sessionAttributes: [String: String]?

        public init(promptSessionAttributes: [String: String]? = nil, sessionAttributes: [String: String]? = nil) {
            self.promptSessionAttributes = promptSessionAttributes
            self.sessionAttributes = sessionAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case promptSessionAttributes = "promptSessionAttributes"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct Span: AWSDecodableShape {
        /// Where the text with a citation ends in the generated output.
        public let end: Int?
        /// Where the text with a citation starts in the generated output.
        public let start: Int?

        public init(end: Int? = nil, start: Int? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct TextResponsePart: AWSDecodableShape {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public let span: Span?
        /// The part of the generated text that contains a citation.
        public let text: String?

        public init(span: Span? = nil, text: String? = nil) {
            self.span = span
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case span = "span"
            case text = "text"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TracePart: AWSDecodableShape {
        /// The unique identifier of the alias of the agent.
        public let agentAliasId: String?
        /// The unique identifier of the agent.
        public let agentId: String?
        /// The unique identifier of the session with the agent.
        public let sessionId: String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see Trace enablement.
        public let trace: Trace?

        public init(agentAliasId: String? = nil, agentId: String? = nil, sessionId: String? = nil, trace: Trace? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.sessionId = sessionId
            self.trace = trace
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentId = "agentId"
            case sessionId = "sessionId"
            case trace = "trace"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentRuntime
public struct BedrockAgentRuntimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentRuntime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions. Check your permissions and retry your request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was an issue with a dependency due to a server issue. Retry your request.
    public static var badGatewayException: Self { .init(.badGatewayException) }
    /// There was a conflict performing an operation. Resolve the conflict and retry your request.
    public static var conflictException: Self { .init(.conflictException) }
    /// There was an issue with a dependency. Check the resource configurations and retry the request.
    public static var dependencyFailedException: Self { .init(.dependencyFailedException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource ARN was not found. Check the ARN and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentRuntimeErrorType: Equatable {
    public static func == (lhs: BedrockAgentRuntimeErrorType, rhs: BedrockAgentRuntimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentRuntimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
