//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentRuntime {
    // MARK: Enums

    public enum ActionGroupSignature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonCodeinterpreter = "AMAZON.CodeInterpreter"
        case amazonUserinput = "AMAZON.UserInput"
        public var description: String { return self.rawValue }
    }

    public enum ActionInvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case result = "RESULT"
        case userConfirmation = "USER_CONFIRMATION"
        case userConfirmationAndResult = "USER_CONFIRMATION_AND_RESULT"
        public var description: String { return self.rawValue }
    }

    public enum AttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case number = "NUMBER"
        case string = "STRING"
        case stringList = "STRING_LIST"
        public var description: String { return self.rawValue }
    }

    public enum ConfirmationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case confirm = "CONFIRM"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum ConversationRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assistant = "assistant"
        case user = "user"
        public var description: String { return self.rawValue }
    }

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum CustomControlMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case returnControl = "RETURN_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lambda = "LAMBDA"
        case returnControl = "RETURN_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum ExternalSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byteContent = "BYTE_CONTENT"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum FileSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byteContent = "BYTE_CONTENT"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum FileUseCase: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chat = "CHAT"
        case codeInterpreter = "CODE_INTERPRETER"
        public var description: String { return self.rawValue }
    }

    public enum FlowCompletionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inputRequired = "INPUT_REQUIRED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum GeneratedQueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case redshiftSql = "REDSHIFT_SQL"
        public var description: String { return self.rawValue }
    }

    public enum GuadrailAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intervened = "INTERVENED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intervened = "INTERVENED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterConfidence: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hate = "HATE"
        case insults = "INSULTS"
        case misconduct = "MISCONDUCT"
        case promptAttack = "PROMPT_ATTACK"
        case sexual = "SEXUAL"
        case violence = "VIOLENCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailManagedWordType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case profanity = "PROFANITY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailPiiEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case age = "AGE"
        case awsAccessKey = "AWS_ACCESS_KEY"
        case awsSecretKey = "AWS_SECRET_KEY"
        case caHealthNumber = "CA_HEALTH_NUMBER"
        case caSocialInsuranceNumber = "CA_SOCIAL_INSURANCE_NUMBER"
        case creditDebitCardCvv = "CREDIT_DEBIT_CARD_CVV"
        case creditDebitCardExpiry = "CREDIT_DEBIT_CARD_EXPIRY"
        case creditDebitCardNumber = "CREDIT_DEBIT_CARD_NUMBER"
        case driverId = "DRIVER_ID"
        case email = "EMAIL"
        case internationalBankAccountNumber = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
        case ipAddress = "IP_ADDRESS"
        case licensePlate = "LICENSE_PLATE"
        case macAddress = "MAC_ADDRESS"
        case name = "NAME"
        case password = "PASSWORD"
        case phone = "PHONE"
        case pin = "PIN"
        case swiftCode = "SWIFT_CODE"
        case ukNationalHealthServiceNumber = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
        case ukNationalInsuranceNumber = "UK_NATIONAL_INSURANCE_NUMBER"
        case ukUniqueTaxpayerReferenceNumber = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
        case url = "URL"
        case usBankAccountNumber = "US_BANK_ACCOUNT_NUMBER"
        case usBankRoutingNumber = "US_BANK_ROUTING_NUMBER"
        case usIndividualTaxIdentificationNumber = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
        case usPassportNumber = "US_PASSPORT_NUMBER"
        case usSocialSecurityNumber = "US_SOCIAL_SECURITY_NUMBER"
        case username = "USERNAME"
        case vehicleIdentificationNumber = "VEHICLE_IDENTIFICATION_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailSensitiveInformationPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymized = "ANONYMIZED"
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailWordPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum ImageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gif = "gif"
        case jpeg = "jpeg"
        case png = "png"
        case webp = "webp"
        public var description: String { return self.rawValue }
    }

    public enum InputQueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case actionGroupCodeInterpreter = "ACTION_GROUP_CODE_INTERPRETER"
        case agentCollaborator = "AGENT_COLLABORATOR"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum MemoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sessionSummary = "SESSION_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditionNode = "ConditionNode"
        case flowInputNode = "FlowInputNode"
        case flowOutputNode = "FlowOutputNode"
        case knowledgeBaseNode = "KnowledgeBaseNode"
        case lambdaFunctionNode = "LambdaFunctionNode"
        case lexNode = "LexNode"
        case promptNode = "PromptNode"
        public var description: String { return self.rawValue }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "array"
        case boolean = "boolean"
        case integer = "integer"
        case number = "number"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum PayloadType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case returnControl = "RETURN_CONTROL"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum PerformanceConfigLatency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optimized = "optimized"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public enum PromptState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        case routingClassifier = "ROUTING_CLASSIFIER"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransformationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case textToSql = "TEXT_TO_SQL"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransformationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queryDecomposition = "QUERY_DECOMPOSITION"
        public var description: String { return self.rawValue }
    }

    public enum RequireConfirmation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum RerankDocumentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum RerankQueryContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum RerankSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inline = "INLINE"
        public var description: String { return self.rawValue }
    }

    public enum RerankingConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockRerankingModel = "BEDROCK_RERANKING_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum RerankingMetadataSelectionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case selective = "SELECTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ResponseState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "FAILURE"
        case reprompt = "REPROMPT"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalResultContentColumnType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blob = "BLOB"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case long = "LONG"
        case null = "NULL"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalResultContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "IMAGE"
        case row = "ROW"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalResultLocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case confluence = "CONFLUENCE"
        case custom = "CUSTOM"
        case kendra = "KENDRA"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case sharepoint = "SHAREPOINT"
        case sql = "SQL"
        case web = "WEB"
        public var description: String { return self.rawValue }
    }

    public enum RetrieveAndGenerateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalSources = "EXTERNAL_SOURCES"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "HYBRID"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case ended = "ENDED"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case parser = "PARSER"
        public var description: String { return self.rawValue }
    }

    public enum TextToSqlConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum VectorSearchRerankingConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockRerankingModel = "BEDROCK_RERANKING_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case agentCollaborator = "AGENT_COLLABORATOR"
        case askUser = "ASK_USER"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case reprompt = "REPROMPT"
        public var description: String { return self.rawValue }
    }

    public enum APISchema: AWSEncodableShape, Sendable {
        ///  The JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        case payload(String)
        ///  Contains details about the S3 object containing the OpenAPI schema for the action group.
        case s3(S3Identifier)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .payload(let value):
                try container.encode(value, forKey: .payload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case s3 = "s3"
        }
    }

    public enum ActionGroupExecutor: AWSEncodableShape, Sendable {
        ///  To return the action group invocation results directly in the InvokeInlineAgent response, specify RETURN_CONTROL.
        case customControl(CustomControlMethod)
        ///  The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customControl(let value):
                try container.encode(value, forKey: .customControl)
            case .lambda(let value):
                try container.encode(value, forKey: .lambda)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .lambda(let value):
                try self.validate(value, name: "lambda", parent: name, max: 2048)
                try self.validate(value, name: "lambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customControl = "customControl"
            case lambda = "lambda"
        }
    }

    public enum BedrockSessionContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The image in the invocation step.
        case image(ImageBlock)
        /// The text in the invocation step.
        case text(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .image:
                let value = try container.decode(ImageBlock.self, forKey: .image)
                self = .image(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .image(let value):
                try container.encode(value, forKey: .image)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .image(let value):
                try value.validate(name: "\(name).image")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
            case text = "text"
        }
    }

    public enum FlowResponseStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// There was a conflict performing an operation. Resolve the conflict and retry your request.
        case conflictException(ConflictException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// Contains information about why the flow completed.
        case flowCompletionEvent(FlowCompletionEvent)
        /// The event stream containing the multi-turn input request information from the flow.
        case flowMultiTurnInputRequestEvent(FlowMultiTurnInputRequestEvent)
        /// Contains information about an output from flow invocation.
        case flowOutputEvent(FlowOutputEvent)
        /// Contains information about a trace, which tracks an input or output for a node in the flow.
        case flowTraceEvent(FlowTraceEvent)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
        case resourceNotFoundException(ResourceNotFoundException)
        /// The number of requests exceeds the service quota. Resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// The number of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .flowCompletionEvent:
                let value = try container.decode(FlowCompletionEvent.self, forKey: .flowCompletionEvent)
                self = .flowCompletionEvent(value)
            case .flowMultiTurnInputRequestEvent:
                let value = try container.decode(FlowMultiTurnInputRequestEvent.self, forKey: .flowMultiTurnInputRequestEvent)
                self = .flowMultiTurnInputRequestEvent(value)
            case .flowOutputEvent:
                let value = try container.decode(FlowOutputEvent.self, forKey: .flowOutputEvent)
                self = .flowOutputEvent(value)
            case .flowTraceEvent:
                let value = try container.decode(FlowTraceEvent.self, forKey: .flowTraceEvent)
                self = .flowTraceEvent(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case flowCompletionEvent = "flowCompletionEvent"
            case flowMultiTurnInputRequestEvent = "flowMultiTurnInputRequestEvent"
            case flowOutputEvent = "flowOutputEvent"
            case flowTraceEvent = "flowTraceEvent"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum FlowTrace: AWSDecodableShape, Sendable {
        /// Contains information about an output from a condition node.
        case conditionNodeResultTrace(FlowTraceConditionNodeResultEvent)
        /// Contains information about the input into a node.
        case nodeInputTrace(FlowTraceNodeInputEvent)
        /// Contains information about the output from a node.
        case nodeOutputTrace(FlowTraceNodeOutputEvent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .conditionNodeResultTrace:
                let value = try container.decode(FlowTraceConditionNodeResultEvent.self, forKey: .conditionNodeResultTrace)
                self = .conditionNodeResultTrace(value)
            case .nodeInputTrace:
                let value = try container.decode(FlowTraceNodeInputEvent.self, forKey: .nodeInputTrace)
                self = .nodeInputTrace(value)
            case .nodeOutputTrace:
                let value = try container.decode(FlowTraceNodeOutputEvent.self, forKey: .nodeOutputTrace)
                self = .nodeOutputTrace(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditionNodeResultTrace = "conditionNodeResultTrace"
            case nodeInputTrace = "nodeInputTrace"
            case nodeOutputTrace = "nodeOutputTrace"
        }
    }

    public enum ImageSource: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  The raw image bytes for the image. If you use an Amazon Web Services SDK, you don't need to encode the image bytes in base64.
        case bytes(AWSBase64Data)
        /// The path to the Amazon S3 bucket where the image is stored.
        case s3Location(S3Location)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .bytes:
                let value = try container.decode(AWSBase64Data.self, forKey: .bytes)
                self = .bytes(value)
            case .s3Location:
                let value = try container.decode(S3Location.self, forKey: .s3Location)
                self = .s3Location(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .bytes(let value):
                try container.encode(value, forKey: .bytes)
            case .s3Location(let value):
                try container.encode(value, forKey: .s3Location)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3Location(let value):
                try value.validate(name: "\(name).s3Location")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case s3Location = "s3Location"
        }
    }

    public enum InlineAgentResponseStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// Contains a part of an agent response and citations for it.
        case chunk(InlineAgentPayloadPart)
        /// There was a conflict performing an operation. Resolve the conflict and retry your request.
        case conflictException(ConflictException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// Contains intermediate response for code interpreter if any files have been generated.
        case files(InlineAgentFilePart)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
        case resourceNotFoundException(ResourceNotFoundException)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system  and can be used in your own setup for fulfilling the action.
        case returnControl(InlineAgentReturnControlPayload)
        /// The number of requests exceeds the service quota. Resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// The number of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying  knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer.  For more information, see Trace events.
        case trace(InlineAgentTracePart)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .chunk:
                let value = try container.decode(InlineAgentPayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .files:
                let value = try container.decode(InlineAgentFilePart.self, forKey: .files)
                self = .files(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .returnControl:
                let value = try container.decode(InlineAgentReturnControlPayload.self, forKey: .returnControl)
                self = .returnControl(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .trace:
                let value = try container.decode(InlineAgentTracePart.self, forKey: .trace)
                self = .trace(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case chunk = "chunk"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case files = "files"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case returnControl = "returnControl"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case trace = "trace"
            case validationException = "validationException"
        }
    }

    public enum InvocationInputMember: AWSDecodableShape, Sendable {
        /// Contains information about the API operation that the agent predicts should be called.
        case apiInvocationInput(ApiInvocationInput)
        /// Contains information about the function that the agent predicts should be called.
        case functionInvocationInput(FunctionInvocationInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiInvocationInput:
                let value = try container.decode(ApiInvocationInput.self, forKey: .apiInvocationInput)
                self = .apiInvocationInput(value)
            case .functionInvocationInput:
                let value = try container.decode(FunctionInvocationInput.self, forKey: .functionInvocationInput)
                self = .functionInvocationInput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiInvocationInput = "apiInvocationInput"
            case functionInvocationInput = "functionInvocationInput"
        }
    }

    public enum InvocationResultMember: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The result from the API response from the action group invocation.
        case apiResult(ApiResult)
        /// The result from the function from the action group invocation.
        case functionResult(FunctionResult)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiResult:
                let value = try container.decode(ApiResult.self, forKey: .apiResult)
                self = .apiResult(value)
            case .functionResult:
                let value = try container.decode(FunctionResult.self, forKey: .functionResult)
                self = .functionResult(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiResult(let value):
                try container.encode(value, forKey: .apiResult)
            case .functionResult(let value):
                try container.encode(value, forKey: .functionResult)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiResult = "apiResult"
            case functionResult = "functionResult"
        }
    }

    public enum OptimizedPromptStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// An event in which the prompt was analyzed in preparation for optimization.
        case analyzePromptEvent(AnalyzePromptEvent)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// An event in which the prompt was optimized.
        case optimizedPromptEvent(OptimizedPromptEvent)
        /// Your request was throttled because of service-wide limitations. Resubmit your request later or in a different region. You can also purchase Provisioned Throughput to increase the rate or number of tokens you can process.
        case throttlingException(ThrottlingException)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .analyzePromptEvent:
                let value = try container.decode(AnalyzePromptEvent.self, forKey: .analyzePromptEvent)
                self = .analyzePromptEvent(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .optimizedPromptEvent:
                let value = try container.decode(OptimizedPromptEvent.self, forKey: .optimizedPromptEvent)
                self = .optimizedPromptEvent(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case analyzePromptEvent = "analyzePromptEvent"
            case badGatewayException = "badGatewayException"
            case dependencyFailedException = "dependencyFailedException"
            case internalServerException = "internalServerException"
            case optimizedPromptEvent = "optimizedPromptEvent"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum OrchestrationTrace: AWSDecodableShape, Sendable {
        /// Contains information pertaining to the action group or knowledge base that is being invoked.
        case invocationInput(InvocationInput)
        /// The input for the orchestration step.   The type is ORCHESTRATION.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// Contains information pertaining to the output from the foundation model that is being invoked.
        case modelInvocationOutput(OrchestrationModelInvocationOutput)
        /// Details about the observation (the output of the action group Lambda or knowledge base) made by the agent.
        case observation(Observation)
        /// Details about the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
        case rationale(Rationale)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .invocationInput:
                let value = try container.decode(InvocationInput.self, forKey: .invocationInput)
                self = .invocationInput(value)
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(OrchestrationModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            case .observation:
                let value = try container.decode(Observation.self, forKey: .observation)
                self = .observation(value)
            case .rationale:
                let value = try container.decode(Rationale.self, forKey: .rationale)
                self = .rationale(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invocationInput = "invocationInput"
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
            case observation = "observation"
            case rationale = "rationale"
        }
    }

    public enum PostProcessingTrace: AWSDecodableShape, Sendable {
        /// The input for the post-processing step.   The type is POST_PROCESSING.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// The foundation model output from the post-processing step.
        case modelInvocationOutput(PostProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PostProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum PreProcessingTrace: AWSDecodableShape, Sendable {
        /// The input for the pre-processing step.   The type is PRE_PROCESSING.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// The foundation model output from the pre-processing step.
        case modelInvocationOutput(PreProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PreProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum ReasoningContentBlock: AWSDecodableShape, Sendable {
        /// Contains information about the reasoning that the model used to return the content in the content block.
        case reasoningText(ReasoningTextBlock)
        /// The content in the reasoning that was encrypted by the model provider for trust and safety reasons.
        case redactedContent(AWSBase64Data)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .reasoningText:
                let value = try container.decode(ReasoningTextBlock.self, forKey: .reasoningText)
                self = .reasoningText(value)
            case .redactedContent:
                let value = try container.decode(AWSBase64Data.self, forKey: .redactedContent)
                self = .redactedContent(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case reasoningText = "reasoningText"
            case redactedContent = "redactedContent"
        }
    }

    public enum RerankingMetadataSelectiveModeConfiguration: AWSEncodableShape, Sendable {
        /// An array of objects, each of which specifies a metadata field to exclude from consideration when reranking.
        case fieldsToExclude([FieldForReranking])
        /// An array of objects, each of which specifies a metadata field to include in consideration when reranking. The remaining metadata fields are ignored.
        case fieldsToInclude([FieldForReranking])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fieldsToExclude(let value):
                try container.encode(value, forKey: .fieldsToExclude)
            case .fieldsToInclude(let value):
                try container.encode(value, forKey: .fieldsToInclude)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .fieldsToExclude(let value):
                try self.validate(value, name: "fieldsToExclude", parent: name, max: 100)
                try self.validate(value, name: "fieldsToExclude", parent: name, min: 1)
            case .fieldsToInclude(let value):
                try self.validate(value, name: "fieldsToInclude", parent: name, max: 100)
                try self.validate(value, name: "fieldsToInclude", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fieldsToExclude = "fieldsToExclude"
            case fieldsToInclude = "fieldsToInclude"
        }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// Contains a part of an agent response and citations for it.
        case chunk(PayloadPart)
        /// There was a conflict performing an operation. Resolve the conflict and retry your request.
        case conflictException(ConflictException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// Contains intermediate response for code interpreter if any files have been generated.
        case files(FilePart)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        ///  The model specified in the request is not ready to serve Inference requests. The AWS SDK will automatically retry the operation up to 5 times. For information about configuring automatic retries, see Retry behavior in the AWS SDKs and Tools reference guide.
        case modelNotReadyException(ModelNotReadyException)
        /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
        case resourceNotFoundException(ResourceNotFoundException)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system and can be used in your own setup for fulfilling the action.
        case returnControl(ReturnControlPayload)
        /// The number of requests exceeds the service quota. Resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// The number of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see Trace events.
        case trace(TracePart)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .chunk:
                let value = try container.decode(PayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .files:
                let value = try container.decode(FilePart.self, forKey: .files)
                self = .files(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .modelNotReadyException:
                let value = try container.decode(ModelNotReadyException.self, forKey: .modelNotReadyException)
                self = .modelNotReadyException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .returnControl:
                let value = try container.decode(ReturnControlPayload.self, forKey: .returnControl)
                self = .returnControl(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .trace:
                let value = try container.decode(TracePart.self, forKey: .trace)
                self = .trace(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case chunk = "chunk"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case files = "files"
            case internalServerException = "internalServerException"
            case modelNotReadyException = "modelNotReadyException"
            case resourceNotFoundException = "resourceNotFoundException"
            case returnControl = "returnControl"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case trace = "trace"
            case validationException = "validationException"
        }
    }

    public enum RetrievalFilter: AWSEncodableShape, Sendable {
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the filter conditions inside this list.
        case andAll([RetrievalFilter])
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is cat:  "equals": { "key": "animal", "value": "cat" }
        case equals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is greater than 1989:  "greaterThan": { "key": "year", "value": 1989 }
        case greaterThan(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is greater than or equal to 1989:  "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterThanOrEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either cat or dog:  "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to 1989.  "lessThan": { "key": "year", "value": 1989 }
        case lessThan(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal to 1989.  "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessThanOrEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat member (for example ["dog", "cat"]).  "listContains": { "key": "animals", "value": "cat" }
        case listContains(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned. The following example would return data sources that don't contain an animal attribute whose value is cat.  "notEquals": { "key": "animal", "value": "cat" }
        case notEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither cat nor dog.  "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notIn(FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter conditions inside this list.
        case orAll([RetrievalFilter])
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value starts with the value in this object. This filter is currently only supported for Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with ca (for example, cat or camel).  "startsWith": { "key": "animal", "value": "ca" }
        case startsWith(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is one of the following:   A string that contains the value as a substring. The following example would return data sources with an animal attribute that contains the substring at (for example cat).  "stringContains": { "key": "animal", "value": "at" }    A list with a member that contains the value as a substring. The following example would return data sources with an animals attribute that is a list containing a member that contains the substring at (for example ["dog", "cat"]).  "stringContains": { "key": "animals", "value": "at" }
        case stringContains(FilterAttribute)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .equals(let value):
                try container.encode(value, forKey: .equals)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEquals(let value):
                try container.encode(value, forKey: .greaterThanOrEquals)
            case .`in`(let value):
                try container.encode(value, forKey: .`in`)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEquals(let value):
                try container.encode(value, forKey: .lessThanOrEquals)
            case .listContains(let value):
                try container.encode(value, forKey: .listContains)
            case .notEquals(let value):
                try container.encode(value, forKey: .notEquals)
            case .notIn(let value):
                try container.encode(value, forKey: .notIn)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            case .startsWith(let value):
                try container.encode(value, forKey: .startsWith)
            case .stringContains(let value):
                try container.encode(value, forKey: .stringContains)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
                try self.validate(value, name: "andAll", parent: name, min: 2)
            case .equals(let value):
                try value.validate(name: "\(name).equals")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEquals(let value):
                try value.validate(name: "\(name).greaterThanOrEquals")
            case .`in`(let value):
                try value.validate(name: "\(name).`in`")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEquals(let value):
                try value.validate(name: "\(name).lessThanOrEquals")
            case .listContains(let value):
                try value.validate(name: "\(name).listContains")
            case .notEquals(let value):
                try value.validate(name: "\(name).notEquals")
            case .notIn(let value):
                try value.validate(name: "\(name).notIn")
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
                try self.validate(value, name: "orAll", parent: name, min: 2)
            case .startsWith(let value):
                try value.validate(name: "\(name).startsWith")
            case .stringContains(let value):
                try value.validate(name: "\(name).stringContains")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case equals = "equals"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case `in` = "in"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case listContains = "listContains"
            case notEquals = "notEquals"
            case notIn = "notIn"
            case orAll = "orAll"
            case startsWith = "startsWith"
            case stringContains = "stringContains"
        }
    }

    public enum RetrieveAndGenerateStreamResponseOutput: AWSDecodableShape, Sendable {
        /// The request is denied because you do not have sufficient permissions to perform the requested action. For troubleshooting this error,  see AccessDeniedException in the Amazon Bedrock User Guide.
        case accessDeniedException(AccessDeniedException)
        /// The request failed due to a bad gateway error.
        case badGatewayException(BadGatewayException)
        /// A citation event.
        case citation(CitationEvent)
        /// Error occurred because of a conflict while performing an operation.
        case conflictException(ConflictException)
        /// The request failed due to a dependency error.
        case dependencyFailedException(DependencyFailedException)
        /// A guardrail event.
        case guardrail(GuardrailEvent)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// An output event.
        case output(RetrieveAndGenerateOutputEvent)
        /// The specified resource ARN was not found. For troubleshooting this error,  see ResourceNotFound in the Amazon Bedrock User Guide.
        case resourceNotFoundException(ResourceNotFoundException)
        /// Your request exceeds the service quota for your account. You can view your quotas at Viewing service quotas. You can resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// Your request was denied due to exceeding the account quotas for Amazon Bedrock. For troubleshooting this error, see ThrottlingException in the Amazon Bedrock User Guide.
        case throttlingException(ThrottlingException)
        /// The input fails to satisfy the constraints specified by Amazon Bedrock. For troubleshooting this error,  see ValidationError in the Amazon Bedrock User Guide.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .citation:
                let value = try container.decode(CitationEvent.self, forKey: .citation)
                self = .citation(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .guardrail:
                let value = try container.decode(GuardrailEvent.self, forKey: .guardrail)
                self = .guardrail(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .output:
                let value = try container.decode(RetrieveAndGenerateOutputEvent.self, forKey: .output)
                self = .output(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case citation = "citation"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case guardrail = "guardrail"
            case internalServerException = "internalServerException"
            case output = "output"
            case resourceNotFoundException = "resourceNotFoundException"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum RoutingClassifierTrace: AWSDecodableShape, Sendable {
        /// The classifier's invocation input.
        case invocationInput(InvocationInput)
        /// The classifier's model invocation input.
        case modelInvocationInput(ModelInvocationInput)
        /// The classifier's model invocation output.
        case modelInvocationOutput(RoutingClassifierModelInvocationOutput)
        /// The classifier's observation.
        case observation(Observation)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .invocationInput:
                let value = try container.decode(InvocationInput.self, forKey: .invocationInput)
                self = .invocationInput(value)
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(RoutingClassifierModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            case .observation:
                let value = try container.decode(Observation.self, forKey: .observation)
                self = .observation(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invocationInput = "invocationInput"
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
            case observation = "observation"
        }
    }

    public enum Trace: AWSDecodableShape, Sendable {
        ///  Details about the custom orchestration step in which the agent determines the order in which actions are executed.
        case customOrchestrationTrace(CustomOrchestrationTrace)
        /// Contains information about the failure of the interaction.
        case failureTrace(FailureTrace)
        /// The trace details for a trace defined in the Guardrail filter.
        case guardrailTrace(GuardrailTrace)
        /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
        case orchestrationTrace(OrchestrationTrace)
        /// Details about the post-processing step, in which the agent shapes the response..
        case postProcessingTrace(PostProcessingTrace)
        /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
        case preProcessingTrace(PreProcessingTrace)
        /// A routing classifier's trace.
        case routingClassifierTrace(RoutingClassifierTrace)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customOrchestrationTrace:
                let value = try container.decode(CustomOrchestrationTrace.self, forKey: .customOrchestrationTrace)
                self = .customOrchestrationTrace(value)
            case .failureTrace:
                let value = try container.decode(FailureTrace.self, forKey: .failureTrace)
                self = .failureTrace(value)
            case .guardrailTrace:
                let value = try container.decode(GuardrailTrace.self, forKey: .guardrailTrace)
                self = .guardrailTrace(value)
            case .orchestrationTrace:
                let value = try container.decode(OrchestrationTrace.self, forKey: .orchestrationTrace)
                self = .orchestrationTrace(value)
            case .postProcessingTrace:
                let value = try container.decode(PostProcessingTrace.self, forKey: .postProcessingTrace)
                self = .postProcessingTrace(value)
            case .preProcessingTrace:
                let value = try container.decode(PreProcessingTrace.self, forKey: .preProcessingTrace)
                self = .preProcessingTrace(value)
            case .routingClassifierTrace:
                let value = try container.decode(RoutingClassifierTrace.self, forKey: .routingClassifierTrace)
                self = .routingClassifierTrace(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customOrchestrationTrace = "customOrchestrationTrace"
            case failureTrace = "failureTrace"
            case guardrailTrace = "guardrailTrace"
            case orchestrationTrace = "orchestrationTrace"
            case postProcessingTrace = "postProcessingTrace"
            case preProcessingTrace = "preProcessingTrace"
            case routingClassifierTrace = "routingClassifierTrace"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActionGroupInvocationInput: AWSDecodableShape {
        /// The name of the action group.
        public let actionGroupName: String?
        /// The path to the API to call, based off the action group.
        public let apiPath: String?
        /// How fulfillment of the action is handled. For more information, see Handling fulfillment of the action.
        public let executionType: ExecutionType?
        /// The function in the action group to call.
        public let function: String?
        /// The unique identifier of the invocation. Only returned if the executionType is RETURN_CONTROL.
        public let invocationId: String?
        /// The parameters in the Lambda input event.
        public let parameters: [Parameter]?
        /// The parameters in the request body for the Lambda input event.
        public let requestBody: RequestBody?
        /// The API method being used, based off the action group.
        public let verb: String?

        @inlinable
        public init(actionGroupName: String? = nil, apiPath: String? = nil, executionType: ExecutionType? = nil, function: String? = nil, invocationId: String? = nil, parameters: [Parameter]? = nil, requestBody: RequestBody? = nil, verb: String? = nil) {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.executionType = executionType
            self.function = function
            self.invocationId = invocationId
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupName = "actionGroupName"
            case apiPath = "apiPath"
            case executionType = "executionType"
            case function = "function"
            case invocationId = "invocationId"
            case parameters = "parameters"
            case requestBody = "requestBody"
            case verb = "verb"
        }
    }

    public struct ActionGroupInvocationOutput: AWSDecodableShape {
        /// The JSON-formatted string returned by the API invoked by the action group.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct AgentActionGroup: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking  the action or the custom control method for handling the information elicited from the user.
        public let actionGroupExecutor: ActionGroupExecutor?
        ///  The name of the action group.
        public let actionGroupName: String
        ///  Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted  payload defining the schema. For more information, see Action group OpenAPI schemas.
        public let apiSchema: APISchema?
        ///  A description of the action group.
        public let description: String?
        ///  Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public let functionSchema: FunctionSchema?
        ///  To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput.  You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group.  To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter. You must  leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an Observation reprompting the user for more information.
        public let parentActionGroupSignature: ActionGroupSignature?

        @inlinable
        public init(actionGroupExecutor: ActionGroupExecutor? = nil, actionGroupName: String, apiSchema: APISchema? = nil, description: String? = nil, functionSchema: FunctionSchema? = nil, parentActionGroupSignature: ActionGroupSignature? = nil) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupName = actionGroupName
            self.apiSchema = apiSchema
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignature = parentActionGroupSignature
        }

        public func validate(name: String) throws {
            try self.actionGroupExecutor?.validate(name: "\(name).actionGroupExecutor")
            try self.validate(self.actionGroupName, name: "actionGroupName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.apiSchema?.validate(name: "\(name).apiSchema")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.functionSchema?.validate(name: "\(name).functionSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupExecutor = "actionGroupExecutor"
            case actionGroupName = "actionGroupName"
            case apiSchema = "apiSchema"
            case description = "description"
            case functionSchema = "functionSchema"
            case parentActionGroupSignature = "parentActionGroupSignature"
        }
    }

    public struct AgentCollaboratorInputPayload: AWSDecodableShape {
        /// An action invocation result.
        public let returnControlResults: ReturnControlResults?
        /// Input text.
        public let text: String?
        /// The input type.
        public let type: PayloadType?

        @inlinable
        public init(returnControlResults: ReturnControlResults? = nil, text: String? = nil, type: PayloadType? = nil) {
            self.returnControlResults = returnControlResults
            self.text = text
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case returnControlResults = "returnControlResults"
            case text = "text"
            case type = "type"
        }
    }

    public struct AgentCollaboratorInvocationInput: AWSDecodableShape {
        /// The collaborator's alias ARN.
        public let agentCollaboratorAliasArn: String?
        /// The collaborator's name.
        public let agentCollaboratorName: String?
        /// Text or action invocation result input for the collaborator.
        public let input: AgentCollaboratorInputPayload?

        @inlinable
        public init(agentCollaboratorAliasArn: String? = nil, agentCollaboratorName: String? = nil, input: AgentCollaboratorInputPayload? = nil) {
            self.agentCollaboratorAliasArn = agentCollaboratorAliasArn
            self.agentCollaboratorName = agentCollaboratorName
            self.input = input
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaboratorAliasArn = "agentCollaboratorAliasArn"
            case agentCollaboratorName = "agentCollaboratorName"
            case input = "input"
        }
    }

    public struct AgentCollaboratorInvocationOutput: AWSDecodableShape {
        /// The output's agent collaborator alias ARN.
        public let agentCollaboratorAliasArn: String?
        /// The output's agent collaborator name.
        public let agentCollaboratorName: String?
        /// The output's output.
        public let output: AgentCollaboratorOutputPayload?

        @inlinable
        public init(agentCollaboratorAliasArn: String? = nil, agentCollaboratorName: String? = nil, output: AgentCollaboratorOutputPayload? = nil) {
            self.agentCollaboratorAliasArn = agentCollaboratorAliasArn
            self.agentCollaboratorName = agentCollaboratorName
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case agentCollaboratorAliasArn = "agentCollaboratorAliasArn"
            case agentCollaboratorName = "agentCollaboratorName"
            case output = "output"
        }
    }

    public struct AgentCollaboratorOutputPayload: AWSDecodableShape {
        /// An action invocation result.
        public let returnControlPayload: ReturnControlPayload?
        /// Text output.
        public let text: String?
        /// The type of output.
        public let type: PayloadType?

        @inlinable
        public init(returnControlPayload: ReturnControlPayload? = nil, text: String? = nil, type: PayloadType? = nil) {
            self.returnControlPayload = returnControlPayload
            self.text = text
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case returnControlPayload = "returnControlPayload"
            case text = "text"
            case type = "type"
        }
    }

    public struct AnalyzePromptEvent: AWSDecodableShape {
        /// A message describing the analysis of the prompt.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ApiInvocationInput: AWSDecodableShape {
        /// The action group that the API operation belongs to.
        public let actionGroup: String
        /// Contains information about the API operation to invoke.
        public let actionInvocationType: ActionInvocationType?
        /// The agent's ID.
        public let agentId: String?
        /// The path to the API operation.
        public let apiPath: String?
        /// The agent collaborator's name.
        public let collaboratorName: String?
        /// The HTTP method of the API operation.
        public let httpMethod: String?
        /// The parameters to provide for the API request, as the agent elicited from the user.
        public let parameters: [ApiParameter]?
        /// The request body to provide for the API request, as the agent elicited from the user.
        public let requestBody: ApiRequestBody?

        @inlinable
        public init(actionGroup: String, actionInvocationType: ActionInvocationType? = nil, agentId: String? = nil, apiPath: String? = nil, collaboratorName: String? = nil, httpMethod: String? = nil, parameters: [ApiParameter]? = nil, requestBody: ApiRequestBody? = nil) {
            self.actionGroup = actionGroup
            self.actionInvocationType = actionInvocationType
            self.agentId = agentId
            self.apiPath = apiPath
            self.collaboratorName = collaboratorName
            self.httpMethod = httpMethod
            self.parameters = parameters
            self.requestBody = requestBody
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case actionInvocationType = "actionInvocationType"
            case agentId = "agentId"
            case apiPath = "apiPath"
            case collaboratorName = "collaboratorName"
            case httpMethod = "httpMethod"
            case parameters = "parameters"
            case requestBody = "requestBody"
        }
    }

    public struct ApiParameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The data type for the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct ApiRequestBody: AWSDecodableShape {
        /// The content of the request body. The key of the object in this field is a media type defining the format of the request body.
        public let content: [String: PropertyParameters]?

        @inlinable
        public init(content: [String: PropertyParameters]? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct ApiResult: AWSEncodableShape & AWSDecodableShape {
        /// The action group that the API operation belongs to.
        public let actionGroup: String
        /// The agent's ID.
        public let agentId: String?
        /// The path to the API operation.
        public let apiPath: String?
        /// Controls the API operations or functions to invoke based on the user confirmation.
        public let confirmationState: ConfirmationState?
        /// The HTTP method for the API operation.
        public let httpMethod: String?
        /// http status code from API execution response (for example: 200, 400, 500).
        public let httpStatusCode: Int?
        /// The response body from the API operation. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public let responseBody: [String: ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public let responseState: ResponseState?

        @inlinable
        public init(actionGroup: String, agentId: String? = nil, apiPath: String? = nil, confirmationState: ConfirmationState? = nil, httpMethod: String? = nil, httpStatusCode: Int? = nil, responseBody: [String: ContentBody]? = nil, responseState: ResponseState? = nil) {
            self.actionGroup = actionGroup
            self.agentId = agentId
            self.apiPath = apiPath
            self.confirmationState = confirmationState
            self.httpMethod = httpMethod
            self.httpStatusCode = httpStatusCode
            self.responseBody = responseBody
            self.responseState = responseState
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case agentId = "agentId"
            case apiPath = "apiPath"
            case confirmationState = "confirmationState"
            case httpMethod = "httpMethod"
            case httpStatusCode = "httpStatusCode"
            case responseBody = "responseBody"
            case responseState = "responseState"
        }
    }

    public struct Attribution: AWSDecodableShape {
        /// A list of citations and related information for a part of an agent response.
        public let citations: [Citation]?

        @inlinable
        public init(citations: [Citation]? = nil) {
            self.citations = citations
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
        }
    }

    public struct BadGatewayException: AWSDecodableShape {
        public let message: String?
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct BedrockModelConfigurations: AWSEncodableShape {
        /// The performance configuration for the model.
        public let performanceConfig: PerformanceConfiguration?

        @inlinable
        public init(performanceConfig: PerformanceConfiguration? = nil) {
            self.performanceConfig = performanceConfig
        }

        private enum CodingKeys: String, CodingKey {
            case performanceConfig = "performanceConfig"
        }
    }

    public struct BedrockRerankingConfiguration: AWSEncodableShape {
        /// Contains configurations for a reranker model.
        public let modelConfiguration: BedrockRerankingModelConfiguration
        /// The number of results to return after reranking.
        public let numberOfResults: Int?

        @inlinable
        public init(modelConfiguration: BedrockRerankingModelConfiguration, numberOfResults: Int? = nil) {
            self.modelConfiguration = modelConfiguration
            self.numberOfResults = numberOfResults
        }

        public func validate(name: String) throws {
            try self.modelConfiguration.validate(name: "\(name).modelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case modelConfiguration = "modelConfiguration"
            case numberOfResults = "numberOfResults"
        }
    }

    public struct BedrockRerankingModelConfiguration: AWSEncodableShape {
        /// A JSON object whose keys are request fields for the model and whose values are values for those fields.
        public let additionalModelRequestFields: [String: AWSDocument]?
        /// The ARN of the reranker model.
        public let modelArn: String

        @inlinable
        public init(additionalModelRequestFields: [String: AWSDocument]? = nil, modelArn: String) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.modelArn = modelArn
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case modelArn = "modelArn"
        }
    }

    public struct ByteContentDoc: AWSEncodableShape {
        /// The MIME type of the document contained in the wrapper object.
        public let contentType: String
        /// The byte value of the file to upload, encoded as a Base-64 string.
        public let data: AWSBase64Data
        /// The file name of the document contained in the wrapper object.
        public let identifier: String

        @inlinable
        public init(contentType: String, data: AWSBase64Data, identifier: String) {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "[a-z]{1,20}/.{1,20}")
            try self.validate(self.data, name: "data", parent: name, max: 10485760)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case data = "data"
            case identifier = "identifier"
        }
    }

    public struct ByteContentFile: AWSEncodableShape {
        /// The raw bytes of the file to attach. The maximum size of all files that is attached is 10MB. You can attach a maximum of 5 files.
        public let data: AWSBase64Data
        /// The MIME type of data contained in the file used for chat.
        public let mediaType: String

        @inlinable
        public init(data: AWSBase64Data, mediaType: String) {
            self.data = data
            self.mediaType = mediaType
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 10485760)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case mediaType = "mediaType"
        }
    }

    public struct Citation: AWSDecodableShape {
        /// Contains the generated response and metadata
        public let generatedResponsePart: GeneratedResponsePart?
        /// Contains metadata about the sources cited for the generated response.
        public let retrievedReferences: [RetrievedReference]?

        @inlinable
        public init(generatedResponsePart: GeneratedResponsePart? = nil, retrievedReferences: [RetrievedReference]? = nil) {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case generatedResponsePart = "generatedResponsePart"
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct CitationEvent: AWSDecodableShape {
        /// The citation.
        public let citation: Citation?
        /// The generated response to the citation event.
        public let generatedResponsePart: GeneratedResponsePart?
        /// The retrieved references of the citation event.
        public let retrievedReferences: [RetrievedReference]?

        @inlinable
        public init(generatedResponsePart: GeneratedResponsePart? = nil, retrievedReferences: [RetrievedReference]? = nil) {
            self.citation = nil
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }

        @available(*, deprecated, message: "Members citation have been deprecated")
        @inlinable
        public init(citation: Citation? = nil, generatedResponsePart: GeneratedResponsePart? = nil, retrievedReferences: [RetrievedReference]? = nil) {
            self.citation = citation
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case citation = "citation"
            case generatedResponsePart = "generatedResponsePart"
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct CodeInterpreterInvocationInput: AWSDecodableShape {
        /// The code for the code interpreter to use.
        public let code: String?
        /// Files that are uploaded for code interpreter to use.
        public let files: [String]?

        @inlinable
        public init(code: String? = nil, files: [String]? = nil) {
            self.code = code
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case files = "files"
        }
    }

    public struct CodeInterpreterInvocationOutput: AWSDecodableShape {
        /// Contains the error returned from code execution.
        public let executionError: String?
        /// Contains the successful output returned from code execution
        public let executionOutput: String?
        /// Indicates if the execution of the code timed out.
        public let executionTimeout: Bool?
        /// Contains output files, if generated by code execution.
        public let files: [String]?

        @inlinable
        public init(executionError: String? = nil, executionOutput: String? = nil, executionTimeout: Bool? = nil, files: [String]? = nil) {
            self.executionError = executionError
            self.executionOutput = executionOutput
            self.executionTimeout = executionTimeout
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case executionError = "executionError"
            case executionOutput = "executionOutput"
            case executionTimeout = "executionTimeout"
            case files = "files"
        }
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ContentBody: AWSEncodableShape & AWSDecodableShape {
        /// The body of the API response.
        public let body: String?

        @inlinable
        public init(body: String? = nil) {
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
        }
    }

    public struct ConversationHistory: AWSEncodableShape {
        /// The conversation's messages.
        public let messages: [Message]?

        @inlinable
        public init(messages: [Message]? = nil) {
            self.messages = messages
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
        }
    }

    public struct CreateInvocationRequest: AWSEncodableShape {
        /// A description for the interactions in the invocation. For example, "User asking about weather in Seattle".
        public let description: String?
        /// A unique identifier for the invocation in UUID format.
        public let invocationId: String?
        /// The unique identifier for the associated session for the invocation. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(description: String? = nil, invocationId: String? = nil, sessionIdentifier: String) {
            self.description = description
            self.invocationId = invocationId
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.invocationId, forKey: .invocationId)
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.invocationId, name: "invocationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case invocationId = "invocationId"
        }
    }

    public struct CreateInvocationResponse: AWSDecodableShape {
        /// The timestamp for when the invocation was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier for the invocation.
        public let invocationId: String
        /// The unique identifier for the session associated with the invocation.
        public let sessionId: String

        @inlinable
        public init(createdAt: Date, invocationId: String, sessionId: String) {
            self.createdAt = createdAt
            self.invocationId = invocationId
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case invocationId = "invocationId"
            case sessionId = "sessionId"
        }
    }

    public struct CreateSessionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to use to encrypt the session data. The user or role creating the session must have permission to use the key. For more information, see Amazon Bedrock session encryption.
        public let encryptionKeyArn: String?
        /// A map of key-value pairs containing attributes to be persisted across the session. For example, the user's ID, their language preference,  and the type of device they are using.
        public let sessionMetadata: [String: String]?
        /// Specify the key-value pairs for the tags that you want to attach to the session.
        public let tags: [String: String]?

        @inlinable
        public init(encryptionKeyArn: String? = nil, sessionMetadata: [String: String]? = nil, tags: [String: String]? = nil) {
            self.encryptionKeyArn = encryptionKeyArn
            self.sessionMetadata = sessionMetadata
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.sessionMetadata?.forEach {
                try validate($0.key, name: "sessionMetadata.key", parent: name, max: 100)
                try validate($0.key, name: "sessionMetadata.key", parent: name, min: 1)
                try validate($0.value, name: "sessionMetadata[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.sessionMetadata, name: "sessionMetadata", parent: name, max: 50)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKeyArn = "encryptionKeyArn"
            case sessionMetadata = "sessionMetadata"
            case tags = "tags"
        }
    }

    public struct CreateSessionResponse: AWSDecodableShape {
        /// The timestamp for when the session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the created session.
        public let sessionArn: String
        /// The unique identifier for the session.
        public let sessionId: String
        /// The current status of the session.
        public let sessionStatus: SessionStatus

        @inlinable
        public init(createdAt: Date, sessionArn: String, sessionId: String, sessionStatus: SessionStatus) {
            self.createdAt = createdAt
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionStatus = sessionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionStatus = "sessionStatus"
        }
    }

    public struct CustomOrchestrationTrace: AWSDecodableShape {
        ///  The event details used with the custom orchestration.
        public let event: CustomOrchestrationTraceEvent?
        ///  The unique identifier of the trace.
        public let traceId: String?

        @inlinable
        public init(event: CustomOrchestrationTraceEvent? = nil, traceId: String? = nil) {
            self.event = event
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case traceId = "traceId"
        }
    }

    public struct CustomOrchestrationTraceEvent: AWSDecodableShape {
        ///  The text that prompted the event at this step.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct DeleteAgentMemoryRequest: AWSEncodableShape {
        /// The unique identifier of an alias of an agent.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias belongs.
        public let agentId: String
        /// The unique identifier of the memory.
        public let memoryId: String?
        /// The unique session identifier of the memory.
        public let sessionId: String?

        @inlinable
        public init(agentAliasId: String, agentId: String, memoryId: String? = nil, sessionId: String? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.memoryId, key: "memoryId")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, max: 100)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 2)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentMemoryResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSessionRequest: AWSEncodableShape {
        /// The unique identifier for the session to be deleted. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(sessionIdentifier: String) {
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DependencyFailedException: AWSDecodableShape {
        public let message: String?
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct EndSessionRequest: AWSEncodableShape {
        /// The unique identifier for the session to end. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(sessionIdentifier: String) {
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct EndSessionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the session you ended.
        public let sessionArn: String
        /// The unique identifier of the session you ended.
        public let sessionId: String
        /// The current status of the session you ended.
        public let sessionStatus: SessionStatus

        @inlinable
        public init(sessionArn: String, sessionId: String, sessionStatus: SessionStatus) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionStatus = sessionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionStatus = "sessionStatus"
        }
    }

    public struct ExternalSource: AWSEncodableShape {
        /// The identifier, contentType, and data of the external source wrapper object.
        public let byteContent: ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public let s3Location: S3ObjectDoc?
        /// The source type of the external source wrapper object.
        public let sourceType: ExternalSourceType

        @inlinable
        public init(byteContent: ByteContentDoc? = nil, s3Location: S3ObjectDoc? = nil, sourceType: ExternalSourceType) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.byteContent?.validate(name: "\(name).byteContent")
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case s3Location = "s3Location"
            case sourceType = "sourceType"
        }
    }

    public struct ExternalSourcesGenerationConfiguration: AWSEncodableShape {
        ///  Additional model parameters and their corresponding values not included in the textInferenceConfig structure for an external source. Takes in custom model parameters specific to the language model being used.
        public let additionalModelRequestFields: [String: AWSDocument]?
        /// The configuration details for the guardrail.
        public let guardrailConfiguration: GuardrailConfiguration?
        ///  Configuration settings for inference when using RetrieveAndGenerate to generate responses while using an external source.
        public let inferenceConfig: InferenceConfig?
        /// The latency configuration for the model.
        public let performanceConfig: PerformanceConfiguration?
        /// Contain the textPromptTemplate string for the external source wrapper object.
        public let promptTemplate: PromptTemplate?

        @inlinable
        public init(additionalModelRequestFields: [String: AWSDocument]? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, inferenceConfig: InferenceConfig? = nil, performanceConfig: PerformanceConfiguration? = nil, promptTemplate: PromptTemplate? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.performanceConfig = performanceConfig
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case guardrailConfiguration = "guardrailConfiguration"
            case inferenceConfig = "inferenceConfig"
            case performanceConfig = "performanceConfig"
            case promptTemplate = "promptTemplate"
        }
    }

    public struct ExternalSourcesRetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// The prompt used with the external source wrapper object with the retrieveAndGenerate function.
        public let generationConfiguration: ExternalSourcesGenerationConfiguration?
        /// The model Amazon Resource Name (ARN) for the external source wrapper object in the retrieveAndGenerate function.
        public let modelArn: String
        /// The document for the external source wrapper object in the retrieveAndGenerate function.
        public let sources: [ExternalSource]

        @inlinable
        public init(generationConfiguration: ExternalSourcesGenerationConfiguration? = nil, modelArn: String, sources: [ExternalSource]) {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case modelArn = "modelArn"
            case sources = "sources"
        }
    }

    public struct FailureTrace: AWSDecodableShape {
        /// The reason the interaction failed.
        public let failureReason: String?
        /// The unique identifier of the trace.
        public let traceId: String?

        @inlinable
        public init(failureReason: String? = nil, traceId: String? = nil) {
            self.failureReason = failureReason
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "failureReason"
            case traceId = "traceId"
        }
    }

    public struct FieldForReranking: AWSEncodableShape {
        /// The name of a metadata field to include in or exclude from consideration when reranking.
        public let fieldName: String

        @inlinable
        public init(fieldName: String) {
            self.fieldName = fieldName
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
        }
    }

    public struct FilePart: AWSDecodableShape {
        /// Files containing intermediate response for the user.
        public let files: [OutputFile]?

        @inlinable
        public init(files: [OutputFile]? = nil) {
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
        }
    }

    public struct FileSource: AWSEncodableShape {
        /// The data and the text of the attached files.
        public let byteContent: ByteContentFile?
        /// The s3 location of the files to attach.
        public let s3Location: S3ObjectFile?
        /// The source type of the files to attach.
        public let sourceType: FileSourceType

        @inlinable
        public init(byteContent: ByteContentFile? = nil, s3Location: S3ObjectFile? = nil, sourceType: FileSourceType) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.byteContent?.validate(name: "\(name).byteContent")
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case s3Location = "s3Location"
            case sourceType = "sourceType"
        }
    }

    public struct FilterAttribute: AWSEncodableShape {
        /// The name that the metadata attribute must match.
        public let key: String
        /// The value to whcih to compare the value of the metadata attribute.
        public let value: AWSDocument

        @inlinable
        public init(key: String, value: AWSDocument) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 100)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct FinalResponse: AWSDecodableShape {
        /// The text in the response to the user.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct FlowCompletionEvent: AWSDecodableShape {
        /// The reason that the flow completed.
        public let completionReason: FlowCompletionReason

        @inlinable
        public init(completionReason: FlowCompletionReason) {
            self.completionReason = completionReason
        }

        private enum CodingKeys: String, CodingKey {
            case completionReason = "completionReason"
        }
    }

    public struct FlowInput: AWSEncodableShape {
        /// Contains information about an input into the prompt flow.
        public let content: FlowInputContent
        /// The name of the input from the flow input node.
        public let nodeInputName: String?
        /// The name of the flow input node that begins the prompt flow.
        public let nodeName: String
        /// The name of the output from the flow input node that begins the prompt flow.
        public let nodeOutputName: String?

        @inlinable
        public init(content: FlowInputContent, nodeInputName: String? = nil, nodeName: String, nodeOutputName: String? = nil) {
            self.content = content
            self.nodeInputName = nodeInputName
            self.nodeName = nodeName
            self.nodeOutputName = nodeOutputName
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeInputName, name: "nodeInputName", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){0,99}$")
            try self.validate(self.nodeName, name: "nodeName", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){0,99}$")
            try self.validate(self.nodeOutputName, name: "nodeOutputName", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){0,99}$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeInputName = "nodeInputName"
            case nodeName = "nodeName"
            case nodeOutputName = "nodeOutputName"
        }
    }

    public struct FlowMultiTurnInputRequestEvent: AWSDecodableShape {
        /// The content payload containing the input request details for the multi-turn interaction.
        public let content: FlowMultiTurnInputContent
        /// The name of the node in the flow that is requesting the input.
        public let nodeName: String
        /// The type of the node in the flow that is requesting the input.
        public let nodeType: NodeType

        @inlinable
        public init(content: FlowMultiTurnInputContent, nodeName: String, nodeType: NodeType) {
            self.content = content
            self.nodeName = nodeName
            self.nodeType = nodeType
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeName = "nodeName"
            case nodeType = "nodeType"
        }
    }

    public struct FlowOutputEvent: AWSDecodableShape {
        /// The content in the output.
        public let content: FlowOutputContent
        /// The name of the flow output node that the output is from.
        public let nodeName: String
        /// The type of the node that the output is from.
        public let nodeType: NodeType?

        @inlinable
        public init(content: FlowOutputContent, nodeName: String, nodeType: NodeType? = nil) {
            self.content = content
            self.nodeName = nodeName
            self.nodeType = nodeType
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeName = "nodeName"
            case nodeType = "nodeType"
        }
    }

    public struct FlowTraceCondition: AWSDecodableShape {
        /// The name of the condition.
        public let conditionName: String

        @inlinable
        public init(conditionName: String) {
            self.conditionName = conditionName
        }

        private enum CodingKeys: String, CodingKey {
            case conditionName = "conditionName"
        }
    }

    public struct FlowTraceConditionNodeResultEvent: AWSDecodableShape {
        /// The name of the condition node.
        public let nodeName: String
        /// An array of objects containing information about the conditions that were satisfied.
        public let satisfiedConditions: [FlowTraceCondition]
        /// The date and time that the trace was returned.
        @CustomCoding<ISO8601DateCoder>
        public var timestamp: Date

        @inlinable
        public init(nodeName: String, satisfiedConditions: [FlowTraceCondition], timestamp: Date) {
            self.nodeName = nodeName
            self.satisfiedConditions = satisfiedConditions
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case nodeName = "nodeName"
            case satisfiedConditions = "satisfiedConditions"
            case timestamp = "timestamp"
        }
    }

    public struct FlowTraceEvent: AWSDecodableShape {
        /// The trace object containing information about an input or output for a node in the flow.
        public let trace: FlowTrace

        @inlinable
        public init(trace: FlowTrace) {
            self.trace = trace
        }

        private enum CodingKeys: String, CodingKey {
            case trace = "trace"
        }
    }

    public struct FlowTraceNodeInputEvent: AWSDecodableShape {
        /// An array of objects containing information about each field in the input.
        public let fields: [FlowTraceNodeInputField]
        /// The name of the node that received the input.
        public let nodeName: String
        /// The date and time that the trace was returned.
        @CustomCoding<ISO8601DateCoder>
        public var timestamp: Date

        @inlinable
        public init(fields: [FlowTraceNodeInputField], nodeName: String, timestamp: Date) {
            self.fields = fields
            self.nodeName = nodeName
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nodeName = "nodeName"
            case timestamp = "timestamp"
        }
    }

    public struct FlowTraceNodeInputField: AWSDecodableShape {
        /// The content of the node input.
        public let content: FlowTraceNodeInputContent
        /// The name of the node input.
        public let nodeInputName: String

        @inlinable
        public init(content: FlowTraceNodeInputContent, nodeInputName: String) {
            self.content = content
            self.nodeInputName = nodeInputName
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeInputName = "nodeInputName"
        }
    }

    public struct FlowTraceNodeOutputEvent: AWSDecodableShape {
        /// An array of objects containing information about each field in the output.
        public let fields: [FlowTraceNodeOutputField]
        /// The name of the node that yielded the output.
        public let nodeName: String
        /// The date and time that the trace was returned.
        @CustomCoding<ISO8601DateCoder>
        public var timestamp: Date

        @inlinable
        public init(fields: [FlowTraceNodeOutputField], nodeName: String, timestamp: Date) {
            self.fields = fields
            self.nodeName = nodeName
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nodeName = "nodeName"
            case timestamp = "timestamp"
        }
    }

    public struct FlowTraceNodeOutputField: AWSDecodableShape {
        /// The content of the node output.
        public let content: FlowTraceNodeOutputContent
        /// The name of the node output.
        public let nodeOutputName: String

        @inlinable
        public init(content: FlowTraceNodeOutputContent, nodeOutputName: String) {
            self.content = content
            self.nodeOutputName = nodeOutputName
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeOutputName = "nodeOutputName"
        }
    }

    public struct FunctionDefinition: AWSEncodableShape {
        ///  A description of the function and its purpose.
        public let description: String?
        ///  A name for the function.
        public let name: String
        ///  The parameters that the agent elicits from the user to fulfill the function.
        public let parameters: [String: ParameterDetail]?
        ///  Contains information if user confirmation is required to invoke the function.
        public let requireConfirmation: RequireConfirmation?

        @inlinable
        public init(description: String? = nil, name: String, parameters: [String: ParameterDetail]? = nil, requireConfirmation: RequireConfirmation? = nil) {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.requireConfirmation = requireConfirmation
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case parameters = "parameters"
            case requireConfirmation = "requireConfirmation"
        }
    }

    public struct FunctionInvocationInput: AWSDecodableShape {
        /// The action group that the function belongs to.
        public let actionGroup: String
        /// Contains information about the function to invoke,
        public let actionInvocationType: ActionInvocationType?
        /// The agent's ID.
        public let agentId: String?
        /// The collaborator's name.
        public let collaboratorName: String?
        /// The name of the function.
        public let function: String?
        /// A list of parameters of the function.
        public let parameters: [FunctionParameter]?

        @inlinable
        public init(actionGroup: String, actionInvocationType: ActionInvocationType? = nil, agentId: String? = nil, collaboratorName: String? = nil, function: String? = nil, parameters: [FunctionParameter]? = nil) {
            self.actionGroup = actionGroup
            self.actionInvocationType = actionInvocationType
            self.agentId = agentId
            self.collaboratorName = collaboratorName
            self.function = function
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case actionInvocationType = "actionInvocationType"
            case agentId = "agentId"
            case collaboratorName = "collaboratorName"
            case function = "function"
            case parameters = "parameters"
        }
    }

    public struct FunctionParameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The data type of the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct FunctionResult: AWSEncodableShape & AWSDecodableShape {
        /// The action group that the function belongs to.
        public let actionGroup: String
        /// The agent's ID.
        public let agentId: String?
        /// Contains the user confirmation information about the function that was called.
        public let confirmationState: ConfirmationState?
        /// The name of the function that was called.
        public let function: String?
        /// The response from the function call using the parameters. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public let responseBody: [String: ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public let responseState: ResponseState?

        @inlinable
        public init(actionGroup: String, agentId: String? = nil, confirmationState: ConfirmationState? = nil, function: String? = nil, responseBody: [String: ContentBody]? = nil, responseState: ResponseState? = nil) {
            self.actionGroup = actionGroup
            self.agentId = agentId
            self.confirmationState = confirmationState
            self.function = function
            self.responseBody = responseBody
            self.responseState = responseState
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case agentId = "agentId"
            case confirmationState = "confirmationState"
            case function = "function"
            case responseBody = "responseBody"
            case responseState = "responseState"
        }
    }

    public struct GenerateQueryRequest: AWSEncodableShape {
        /// Specifies information about a natural language query to transform into SQL.
        public let queryGenerationInput: QueryGenerationInput
        /// Specifies configurations for transforming the natural language query into SQL.
        public let transformationConfiguration: TransformationConfiguration

        @inlinable
        public init(queryGenerationInput: QueryGenerationInput, transformationConfiguration: TransformationConfiguration) {
            self.queryGenerationInput = queryGenerationInput
            self.transformationConfiguration = transformationConfiguration
        }

        public func validate(name: String) throws {
            try self.transformationConfiguration.validate(name: "\(name).transformationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case queryGenerationInput = "queryGenerationInput"
            case transformationConfiguration = "transformationConfiguration"
        }
    }

    public struct GenerateQueryResponse: AWSDecodableShape {
        /// A list of objects, each of which defines a generated query that can correspond to the natural language queries.
        public let queries: [GeneratedQuery]?

        @inlinable
        public init(queries: [GeneratedQuery]? = nil) {
            self.queries = queries
        }

        private enum CodingKeys: String, CodingKey {
            case queries = "queries"
        }
    }

    public struct GeneratedQuery: AWSDecodableShape {
        /// An SQL query that corresponds to the natural language query.
        public let sql: String?
        /// The type of transformed query.
        public let type: GeneratedQueryType?

        @inlinable
        public init(sql: String? = nil, type: GeneratedQueryType? = nil) {
            self.sql = sql
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case sql = "sql"
            case type = "type"
        }
    }

    public struct GeneratedResponsePart: AWSDecodableShape {
        /// Contains metadata about a textual part of the generated response that is accompanied by a citation.
        public let textResponsePart: TextResponsePart?

        @inlinable
        public init(textResponsePart: TextResponsePart? = nil) {
            self.textResponsePart = textResponsePart
        }

        private enum CodingKeys: String, CodingKey {
            case textResponsePart = "textResponsePart"
        }
    }

    public struct GenerationConfiguration: AWSEncodableShape {
        ///  Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows users to provide custom model parameters specific to the language model being used.
        public let additionalModelRequestFields: [String: AWSDocument]?
        /// The configuration details for the guardrail.
        public let guardrailConfiguration: GuardrailConfiguration?
        ///  Configuration settings for inference when using RetrieveAndGenerate to generate responses while using a knowledge base as a source.
        public let inferenceConfig: InferenceConfig?
        /// The latency configuration for the model.
        public let performanceConfig: PerformanceConfiguration?
        /// Contains the template for the prompt that's sent to the model for response generation. Generation prompts must include the $search_results$ variable. For more information, see Use placeholder variables in the user guide.
        public let promptTemplate: PromptTemplate?

        @inlinable
        public init(additionalModelRequestFields: [String: AWSDocument]? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, inferenceConfig: InferenceConfig? = nil, performanceConfig: PerformanceConfiguration? = nil, promptTemplate: PromptTemplate? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.performanceConfig = performanceConfig
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case guardrailConfiguration = "guardrailConfiguration"
            case inferenceConfig = "inferenceConfig"
            case performanceConfig = "performanceConfig"
            case promptTemplate = "promptTemplate"
        }
    }

    public struct GetAgentMemoryRequest: AWSEncodableShape {
        /// The unique identifier of an alias of an agent.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias belongs.
        public let agentId: String
        /// The maximum number of items to return in the response. If the total number of results is greater  than this value, use the token returned in the response in the nextToken field when making another  request to return the next batch of results.
        public let maxItems: Int?
        /// The unique identifier of the memory.
        public let memoryId: String
        /// The type of memory.
        public let memoryType: MemoryType
        /// If the total number of results is greater than the maxItems value provided in the request, enter the token returned  in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(agentAliasId: String, agentId: String, maxItems: Int? = nil, memoryId: String, memoryType: MemoryType, nextToken: String? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.maxItems = maxItems
            self.memoryId = memoryId
            self.memoryType = memoryType
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.maxItems, key: "maxItems")
            request.encodeQuery(self.memoryId, key: "memoryId")
            request.encodeQuery(self.memoryType, key: "memoryType")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 1000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, max: 100)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 2)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentMemoryResponse: AWSDecodableShape {
        /// Contains details of the sessions stored in the memory
        public let memoryContents: [Memory]?
        /// If the total number of results is greater than the maxItems value provided in the request, use this token  when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(memoryContents: [Memory]? = nil, nextToken: String? = nil) {
            self.memoryContents = memoryContents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memoryContents = "memoryContents"
            case nextToken = "nextToken"
        }
    }

    public struct GetInvocationStepRequest: AWSEncodableShape {
        /// The unique identifier for the invocation in UUID format.
        public let invocationIdentifier: String
        /// The unique identifier (in UUID format) for the specific invocation step to retrieve.
        public let invocationStepId: String
        /// The unique identifier for the invocation step's associated session. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(invocationIdentifier: String, invocationStepId: String, sessionIdentifier: String) {
            self.invocationIdentifier = invocationIdentifier
            self.invocationStepId = invocationStepId
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.invocationIdentifier, forKey: .invocationIdentifier)
            request.encodePath(self.invocationStepId, key: "invocationStepId")
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationIdentifier, name: "invocationIdentifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.invocationStepId, name: "invocationStepId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationIdentifier = "invocationIdentifier"
        }
    }

    public struct GetInvocationStepResponse: AWSDecodableShape {
        /// The complete details of the requested invocation step.
        public let invocationStep: InvocationStep

        @inlinable
        public init(invocationStep: InvocationStep) {
            self.invocationStep = invocationStep
        }

        private enum CodingKeys: String, CodingKey {
            case invocationStep = "invocationStep"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// A unique identifier for the session to retrieve. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(sessionIdentifier: String) {
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The timestamp for when the session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the session data. For more information, see Amazon Bedrock session encryption.
        public let encryptionKeyArn: String?
        /// The timestamp for when the session was last modified.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The unique identifier for the session in UUID format.
        public let sessionId: String
        /// A map of key-value pairs containing attributes persisted across the session.
        public let sessionMetadata: [String: String]?
        /// The current status of the session.
        public let sessionStatus: SessionStatus

        @inlinable
        public init(createdAt: Date, encryptionKeyArn: String? = nil, lastUpdatedAt: Date, sessionArn: String, sessionId: String, sessionMetadata: [String: String]? = nil, sessionStatus: SessionStatus) {
            self.createdAt = createdAt
            self.encryptionKeyArn = encryptionKeyArn
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionMetadata = sessionMetadata
            self.sessionStatus = sessionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case encryptionKeyArn = "encryptionKeyArn"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionMetadata = "sessionMetadata"
            case sessionStatus = "sessionStatus"
        }
    }

    public struct GuardrailAssessment: AWSDecodableShape {
        /// Content policy details of the Guardrail.
        public let contentPolicy: GuardrailContentPolicyAssessment?
        /// Sensitive Information policy details of Guardrail.
        public let sensitiveInformationPolicy: GuardrailSensitiveInformationPolicyAssessment?
        /// Topic policy details of the Guardrail.
        public let topicPolicy: GuardrailTopicPolicyAssessment?
        /// Word policy details of the Guardrail.
        public let wordPolicy: GuardrailWordPolicyAssessment?

        @inlinable
        public init(contentPolicy: GuardrailContentPolicyAssessment? = nil, sensitiveInformationPolicy: GuardrailSensitiveInformationPolicyAssessment? = nil, topicPolicy: GuardrailTopicPolicyAssessment? = nil, wordPolicy: GuardrailWordPolicyAssessment? = nil) {
            self.contentPolicy = contentPolicy
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.topicPolicy = topicPolicy
            self.wordPolicy = wordPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case contentPolicy = "contentPolicy"
            case sensitiveInformationPolicy = "sensitiveInformationPolicy"
            case topicPolicy = "topicPolicy"
            case wordPolicy = "wordPolicy"
        }
    }

    public struct GuardrailConfiguration: AWSEncodableShape {
        /// The unique identifier for the guardrail.
        public let guardrailId: String
        /// The version of the guardrail.
        public let guardrailVersion: String

        @inlinable
        public init(guardrailId: String, guardrailVersion: String) {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailId = "guardrailId"
            case guardrailVersion = "guardrailVersion"
        }
    }

    public struct GuardrailConfigurationWithArn: AWSEncodableShape {
        ///  The unique identifier for the guardrail.
        public let guardrailIdentifier: String
        ///  The version of the guardrail.
        public let guardrailVersion: String

        @inlinable
        public init(guardrailIdentifier: String, guardrailVersion: String) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, max: 5)
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, min: 1)
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailIdentifier = "guardrailIdentifier"
            case guardrailVersion = "guardrailVersion"
        }
    }

    public struct GuardrailContentFilter: AWSDecodableShape {
        /// The action placed on the content by the Guardrail filter.
        public let action: GuardrailContentPolicyAction?
        /// The confidence level regarding the content detected in the filter by the Guardrail.
        public let confidence: GuardrailContentFilterConfidence?
        /// The type of content detected in the filter by the Guardrail.
        public let type: GuardrailContentFilterType?

        @inlinable
        public init(action: GuardrailContentPolicyAction? = nil, confidence: GuardrailContentFilterConfidence? = nil, type: GuardrailContentFilterType? = nil) {
            self.action = action
            self.confidence = confidence
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case confidence = "confidence"
            case type = "type"
        }
    }

    public struct GuardrailContentPolicyAssessment: AWSDecodableShape {
        /// The filter details of the policy assessment used in the Guardrails filter.
        public let filters: [GuardrailContentFilter]?

        @inlinable
        public init(filters: [GuardrailContentFilter]? = nil) {
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct GuardrailCustomWord: AWSDecodableShape {
        /// The action details for the custom word filter in the Guardrail.
        public let action: GuardrailWordPolicyAction?
        /// The match details for the custom word filter in the Guardrail.
        public let match: String?

        @inlinable
        public init(action: GuardrailWordPolicyAction? = nil, match: String? = nil) {
            self.action = action
            self.match = match
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
        }
    }

    public struct GuardrailEvent: AWSDecodableShape {
        /// The guardrail action.
        public let action: GuadrailAction?

        @inlinable
        public init(action: GuadrailAction? = nil) {
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
        }
    }

    public struct GuardrailManagedWord: AWSDecodableShape {
        /// The action details for the managed word filter in the Guardrail.
        public let action: GuardrailWordPolicyAction?
        /// The match details for the managed word filter in the Guardrail.
        public let match: String?
        /// The type details for the managed word filter in the Guardrail.
        public let type: GuardrailManagedWordType?

        @inlinable
        public init(action: GuardrailWordPolicyAction? = nil, match: String? = nil, type: GuardrailManagedWordType? = nil) {
            self.action = action
            self.match = match
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case type = "type"
        }
    }

    public struct GuardrailPiiEntityFilter: AWSDecodableShape {
        /// The action of the Guardrail filter to identify and remove PII.
        public let action: GuardrailSensitiveInformationPolicyAction?
        /// The match to settings in the Guardrail filter to identify and remove PII.
        public let match: String?
        /// The type of PII the Guardrail filter has identified and removed.
        public let type: GuardrailPiiEntityType?

        @inlinable
        public init(action: GuardrailSensitiveInformationPolicyAction? = nil, match: String? = nil, type: GuardrailPiiEntityType? = nil) {
            self.action = action
            self.match = match
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case type = "type"
        }
    }

    public struct GuardrailRegexFilter: AWSDecodableShape {
        /// The action details for the regex filter used in the Guardrail.
        public let action: GuardrailSensitiveInformationPolicyAction?
        /// The match details for the regex filter used in the Guardrail.
        public let match: String?
        /// The name details for the regex filter used in the Guardrail.
        public let name: String?
        /// The regex details for the regex filter used in the Guardrail.
        public let regex: String?

        @inlinable
        public init(action: GuardrailSensitiveInformationPolicyAction? = nil, match: String? = nil, name: String? = nil, regex: String? = nil) {
            self.action = action
            self.match = match
            self.name = name
            self.regex = regex
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case name = "name"
            case regex = "regex"
        }
    }

    public struct GuardrailSensitiveInformationPolicyAssessment: AWSDecodableShape {
        /// The details of the PII entities used in the sensitive policy assessment for the Guardrail.
        public let piiEntities: [GuardrailPiiEntityFilter]?
        /// The details of the regexes used in the sensitive policy assessment for the Guardrail.
        public let regexes: [GuardrailRegexFilter]?

        @inlinable
        public init(piiEntities: [GuardrailPiiEntityFilter]? = nil, regexes: [GuardrailRegexFilter]? = nil) {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntities = "piiEntities"
            case regexes = "regexes"
        }
    }

    public struct GuardrailTopic: AWSDecodableShape {
        /// The action details on a specific topic in the Guardrail.
        public let action: GuardrailTopicPolicyAction?
        /// The name details on a specific topic in the Guardrail.
        public let name: String?
        /// The type details on a specific topic in the Guardrail.
        public let type: GuardrailTopicType?

        @inlinable
        public init(action: GuardrailTopicPolicyAction? = nil, name: String? = nil, type: GuardrailTopicType? = nil) {
            self.action = action
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case name = "name"
            case type = "type"
        }
    }

    public struct GuardrailTopicPolicyAssessment: AWSDecodableShape {
        /// The topic details of the policy assessment used in the Guardrail.
        public let topics: [GuardrailTopic]?

        @inlinable
        public init(topics: [GuardrailTopic]? = nil) {
            self.topics = topics
        }

        private enum CodingKeys: String, CodingKey {
            case topics = "topics"
        }
    }

    public struct GuardrailTrace: AWSDecodableShape {
        /// The trace action details used with the Guardrail.
        public let action: GuardrailAction?
        /// The details of the input assessments used in the Guardrail Trace.
        public let inputAssessments: [GuardrailAssessment]?
        /// The details of the output assessments used in the Guardrail Trace.
        public let outputAssessments: [GuardrailAssessment]?
        /// The details of the trace Id used in the Guardrail Trace.
        public let traceId: String?

        @inlinable
        public init(action: GuardrailAction? = nil, inputAssessments: [GuardrailAssessment]? = nil, outputAssessments: [GuardrailAssessment]? = nil, traceId: String? = nil) {
            self.action = action
            self.inputAssessments = inputAssessments
            self.outputAssessments = outputAssessments
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case inputAssessments = "inputAssessments"
            case outputAssessments = "outputAssessments"
            case traceId = "traceId"
        }
    }

    public struct GuardrailWordPolicyAssessment: AWSDecodableShape {
        /// The custom word details for words defined in the Guardrail filter.
        public let customWords: [GuardrailCustomWord]?
        /// The managed word lists for words defined in the Guardrail filter.
        public let managedWordLists: [GuardrailManagedWord]?

        @inlinable
        public init(customWords: [GuardrailCustomWord]? = nil, managedWordLists: [GuardrailManagedWord]? = nil) {
            self.customWords = customWords
            self.managedWordLists = managedWordLists
        }

        private enum CodingKeys: String, CodingKey {
            case customWords = "customWords"
            case managedWordLists = "managedWordLists"
        }
    }

    public struct ImageBlock: AWSEncodableShape & AWSDecodableShape {
        /// The format of the image.
        public let format: ImageFormat
        /// The source for the image.
        public let source: ImageSource

        @inlinable
        public init(format: ImageFormat, source: ImageSource) {
            self.format = format
            self.source = source
        }

        public func validate(name: String) throws {
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case source = "source"
        }
    }

    public struct ImplicitFilterConfiguration: AWSEncodableShape {
        /// Metadata that can be used in a filter.
        public let metadataAttributes: [MetadataAttributeSchema]
        /// The model that generates the filter.
        public let modelArn: String

        @inlinable
        public init(metadataAttributes: [MetadataAttributeSchema], modelArn: String) {
            self.metadataAttributes = metadataAttributes
            self.modelArn = modelArn
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataAttributes, name: "metadataAttributes", parent: name, max: 25)
            try self.validate(self.metadataAttributes, name: "metadataAttributes", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataAttributes = "metadataAttributes"
            case modelArn = "modelArn"
        }
    }

    public struct InferenceConfig: AWSEncodableShape {
        ///  Configuration settings specific to text generation while generating responses using RetrieveAndGenerate.
        public let textInferenceConfig: TextInferenceConfig?

        @inlinable
        public init(textInferenceConfig: TextInferenceConfig? = nil) {
            self.textInferenceConfig = textInferenceConfig
        }

        public func validate(name: String) throws {
            try self.textInferenceConfig?.validate(name: "\(name).textInferenceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case textInferenceConfig = "textInferenceConfig"
        }
    }

    public struct InferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens allowed in the generated response.
        public let maximumLength: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public let temperature: Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public let topK: Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 0.8, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public let topP: Float?

        @inlinable
        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, max: 8192)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topK, name: "topK", parent: name, max: 500)
            try self.validate(self.topK, name: "topK", parent: name, min: 0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct InlineAgentFilePart: AWSDecodableShape {
        /// Files containing intermediate response for the user.
        public let files: [OutputFile]?

        @inlinable
        public init(files: [OutputFile]? = nil) {
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
        }
    }

    public struct InlineAgentPayloadPart: AWSDecodableShape {
        /// Contains citations for a part of an agent response.
        public let attribution: Attribution?
        /// A part of the agent response in bytes.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(attribution: Attribution? = nil, bytes: AWSBase64Data? = nil) {
            self.attribution = attribution
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case attribution = "attribution"
            case bytes = "bytes"
        }
    }

    public struct InlineAgentReturnControlPayload: AWSDecodableShape {
        /// The identifier of the action group invocation.
        public let invocationId: String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent  determines from its session with the user.
        public let invocationInputs: [InvocationInputMember]?

        @inlinable
        public init(invocationId: String? = nil, invocationInputs: [InvocationInputMember]? = nil) {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }

        private enum CodingKeys: String, CodingKey {
            case invocationId = "invocationId"
            case invocationInputs = "invocationInputs"
        }
    }

    public struct InlineAgentTracePart: AWSDecodableShape {
        /// The unique identifier of the session with the agent.
        public let sessionId: String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the  agent arrived at the response it provided the customer. For more information, see Trace enablement.
        public let trace: Trace?

        @inlinable
        public init(sessionId: String? = nil, trace: Trace? = nil) {
            self.sessionId = sessionId
            self.trace = trace
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case trace = "trace"
        }
    }

    public struct InlineBedrockModelConfigurations: AWSEncodableShape {
        /// The latency configuration for the model.
        public let performanceConfig: PerformanceConfiguration?

        @inlinable
        public init(performanceConfig: PerformanceConfiguration? = nil) {
            self.performanceConfig = performanceConfig
        }

        private enum CodingKeys: String, CodingKey {
            case performanceConfig = "performanceConfig"
        }
    }

    public struct InlineSessionState: AWSEncodableShape {
        ///  Contains information about the files used by code interpreter.
        public let files: [InputFile]?
        ///  The identifier of the invocation of an action. This value must match the invocationId returned in the InvokeInlineAgent response for the action  whose results are provided in the returnControlInvocationResults field. For more information, see Return control to the agent developer.
        public let invocationId: String?
        ///  Contains attributes that persist across a session and the values of those attributes.
        public let promptSessionAttributes: [String: String]?
        ///  Contains information about the results from the action group invocation. For more information, see Return control to the agent developer.   If you include this field in the sessionState field, the inputText field will be ignored.
        public let returnControlInvocationResults: [InvocationResultMember]?
        ///  Contains attributes that persist across a session and the values of those attributes.
        public let sessionAttributes: [String: String]?

        @inlinable
        public init(files: [InputFile]? = nil, invocationId: String? = nil, promptSessionAttributes: [String: String]? = nil, returnControlInvocationResults: [InvocationResultMember]? = nil, sessionAttributes: [String: String]? = nil) {
            self.files = files
            self.invocationId = invocationId
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }

        public func validate(name: String) throws {
            try self.files?.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.validate(self.returnControlInvocationResults, name: "returnControlInvocationResults", parent: name, max: 5)
            try self.validate(self.returnControlInvocationResults, name: "returnControlInvocationResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
            case invocationId = "invocationId"
            case promptSessionAttributes = "promptSessionAttributes"
            case returnControlInvocationResults = "returnControlInvocationResults"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct InputFile: AWSEncodableShape {
        /// The name of the source file.
        public let name: String
        /// Specifies where the files are located.
        public let source: FileSource
        /// Specifies how the source files will be used by the code interpreter.
        public let useCase: FileUseCase

        @inlinable
        public init(name: String, source: FileSource, useCase: FileUseCase) {
            self.name = name
            self.source = source
            self.useCase = useCase
        }

        public func validate(name: String) throws {
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case source = "source"
            case useCase = "useCase"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?
        /// The reason for the exception. If the reason is BEDROCK_MODEL_INVOCATION_SERVICE_UNAVAILABLE, the model invocation service is unavailable. Retry your request.
        public let reason: String?

        @inlinable
        public init(message: String? = nil, reason: String? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }

    public struct InvocationInput: AWSDecodableShape {
        /// Contains information about the action group to be invoked.
        public let actionGroupInvocationInput: ActionGroupInvocationInput?
        /// The collaborator's invocation input.
        public let agentCollaboratorInvocationInput: AgentCollaboratorInvocationInput?
        /// Contains information about the code interpreter to be invoked.
        public let codeInterpreterInvocationInput: CodeInterpreterInvocationInput?
        /// Specifies whether the agent is invoking an action group or a knowledge base.
        public let invocationType: InvocationType?
        /// Contains details about the knowledge base to look up and the query to be made.
        public let knowledgeBaseLookupInput: KnowledgeBaseLookupInput?
        /// The unique identifier of the trace.
        public let traceId: String?

        @inlinable
        public init(actionGroupInvocationInput: ActionGroupInvocationInput? = nil, agentCollaboratorInvocationInput: AgentCollaboratorInvocationInput? = nil, codeInterpreterInvocationInput: CodeInterpreterInvocationInput? = nil, invocationType: InvocationType? = nil, knowledgeBaseLookupInput: KnowledgeBaseLookupInput? = nil, traceId: String? = nil) {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.agentCollaboratorInvocationInput = agentCollaboratorInvocationInput
            self.codeInterpreterInvocationInput = codeInterpreterInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationInput = "actionGroupInvocationInput"
            case agentCollaboratorInvocationInput = "agentCollaboratorInvocationInput"
            case codeInterpreterInvocationInput = "codeInterpreterInvocationInput"
            case invocationType = "invocationType"
            case knowledgeBaseLookupInput = "knowledgeBaseLookupInput"
            case traceId = "traceId"
        }
    }

    public struct InvocationStep: AWSDecodableShape {
        /// The unique identifier (in UUID format) for the invocation that includes the invocation step.
        public let invocationId: String
        /// The unique identifier (in UUID format) for the invocation step.
        public let invocationStepId: String
        /// The timestamp for when the invocation step was created.
        @CustomCoding<ISO8601DateCoder>
        public var invocationStepTime: Date
        /// Payload content, such as text and images, for the invocation step.
        public let payload: InvocationStepPayload
        /// The unique identifier of the session containing the invocation step.
        public let sessionId: String

        @inlinable
        public init(invocationId: String, invocationStepId: String, invocationStepTime: Date, payload: InvocationStepPayload, sessionId: String) {
            self.invocationId = invocationId
            self.invocationStepId = invocationStepId
            self.invocationStepTime = invocationStepTime
            self.payload = payload
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case invocationId = "invocationId"
            case invocationStepId = "invocationStepId"
            case invocationStepTime = "invocationStepTime"
            case payload = "payload"
            case sessionId = "sessionId"
        }
    }

    public struct InvocationStepSummary: AWSDecodableShape {
        /// A unique identifier for the invocation in UUID format.
        public let invocationId: String
        /// The unique identifier (in UUID format) for the invocation step.
        public let invocationStepId: String
        /// The timestamp for when the invocation step was created.
        @CustomCoding<ISO8601DateCoder>
        public var invocationStepTime: Date
        /// The unique identifier for the session associated with the invocation step.
        public let sessionId: String

        @inlinable
        public init(invocationId: String, invocationStepId: String, invocationStepTime: Date, sessionId: String) {
            self.invocationId = invocationId
            self.invocationStepId = invocationStepId
            self.invocationStepTime = invocationStepTime
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case invocationId = "invocationId"
            case invocationStepId = "invocationStepId"
            case invocationStepTime = "invocationStepTime"
            case sessionId = "sessionId"
        }
    }

    public struct InvocationSummary: AWSDecodableShape {
        /// The timestamp for when the invocation was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A unique identifier for the invocation in UUID format.
        public let invocationId: String
        /// The unique identifier for the session associated with the invocation.
        public let sessionId: String

        @inlinable
        public init(createdAt: Date, invocationId: String, sessionId: String) {
            self.createdAt = createdAt
            self.invocationId = invocationId
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case invocationId = "invocationId"
            case sessionId = "sessionId"
        }
    }

    public struct InvokeAgentRequest: AWSEncodableShape {
        /// The alias of the agent to use.
        public let agentAliasId: String
        /// The unique identifier of the agent to use.
        public let agentId: String
        /// Model performance settings for the request.
        public let bedrockModelConfigurations: BedrockModelConfigurations?
        /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see Trace enablement.
        public let enableTrace: Bool?
        /// Specifies whether to end the session with the agent or not.
        public let endSession: Bool?
        /// The prompt text to send the agent.  If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
        public let inputText: String?
        /// The unique identifier of the agent memory.
        public let memoryId: String?
        /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
        public let sessionId: String
        /// Contains parameters that specify various attributes of the session. For more information, see Control session context.  If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
        public let sessionState: SessionState?
        /// The ARN of the resource making the request.
        public let sourceArn: String?
        ///  Specifies the configurations for streaming.   To use agent streaming, you need permissions to perform the bedrock:InvokeModelWithResponseStream action.
        public let streamingConfigurations: StreamingConfigurations?

        @inlinable
        public init(agentAliasId: String, agentId: String, bedrockModelConfigurations: BedrockModelConfigurations? = nil, enableTrace: Bool? = nil, endSession: Bool? = nil, inputText: String? = nil, memoryId: String? = nil, sessionId: String, sessionState: SessionState? = nil, sourceArn: String? = nil, streamingConfigurations: StreamingConfigurations? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.bedrockModelConfigurations = bedrockModelConfigurations
            self.enableTrace = enableTrace
            self.endSession = endSession
            self.inputText = inputText
            self.memoryId = memoryId
            self.sessionId = sessionId
            self.sessionState = sessionState
            self.sourceArn = sourceArn
            self.streamingConfigurations = streamingConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.bedrockModelConfigurations, forKey: .bedrockModelConfigurations)
            try container.encodeIfPresent(self.enableTrace, forKey: .enableTrace)
            try container.encodeIfPresent(self.endSession, forKey: .endSession)
            try container.encodeIfPresent(self.inputText, forKey: .inputText)
            try container.encodeIfPresent(self.memoryId, forKey: .memoryId)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.sessionState, forKey: .sessionState)
            request.encodeHeader(self.sourceArn, key: "x-amz-source-arn")
            try container.encodeIfPresent(self.streamingConfigurations, forKey: .streamingConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.inputText, name: "inputText", parent: name, max: 25000000)
            try self.validate(self.memoryId, name: "memoryId", parent: name, max: 100)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 2)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.sessionState?.validate(name: "\(name).sessionState")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 2048)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:agent/[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockModelConfigurations = "bedrockModelConfigurations"
            case enableTrace = "enableTrace"
            case endSession = "endSession"
            case inputText = "inputText"
            case memoryId = "memoryId"
            case sessionState = "sessionState"
            case streamingConfigurations = "streamingConfigurations"
        }
    }

    public struct InvokeAgentResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The agent's response to the user prompt.
        public let completion: AWSEventStream<ResponseStream>
        /// The MIME type of the input data in the request. The default value is application/json.
        public let contentType: String
        /// The unique identifier of the agent memory.
        public let memoryId: String?
        /// The unique identifier of the session with the agent.
        public let sessionId: String

        @inlinable
        public init(completion: AWSEventStream<ResponseStream>, contentType: String, memoryId: String? = nil, sessionId: String) {
            self.completion = completion
            self.contentType = contentType
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.completion = try container.decode(AWSEventStream<ResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "x-amzn-bedrock-agent-content-type")
            self.memoryId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-bedrock-agent-memory-id")
            self.sessionId = try response.decodeHeader(String.self, key: "x-amz-bedrock-agent-session-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeFlowRequest: AWSEncodableShape {
        /// Specifies whether to return the trace for the flow or not. Traces track inputs and outputs for nodes in the flow. For more information, see Track each step in your prompt flow by viewing its trace in Amazon Bedrock.
        public let enableTrace: Bool?
        /// The unique identifier for the current flow execution. If you don't provide a value, Amazon Bedrock creates the identifier for you.
        public let executionId: String?
        /// The unique identifier of the flow alias.
        public let flowAliasIdentifier: String
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// A list of objects, each containing information about an input into the flow.
        public let inputs: [FlowInput]
        /// Model performance settings for the request.
        public let modelPerformanceConfiguration: ModelPerformanceConfiguration?

        @inlinable
        public init(enableTrace: Bool? = nil, executionId: String? = nil, flowAliasIdentifier: String, flowIdentifier: String, inputs: [FlowInput], modelPerformanceConfiguration: ModelPerformanceConfiguration? = nil) {
            self.enableTrace = enableTrace
            self.executionId = executionId
            self.flowAliasIdentifier = flowAliasIdentifier
            self.flowIdentifier = flowIdentifier
            self.inputs = inputs
            self.modelPerformanceConfiguration = modelPerformanceConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.enableTrace, forKey: .enableTrace)
            try container.encodeIfPresent(self.executionId, forKey: .executionId)
            request.encodePath(self.flowAliasIdentifier, key: "flowAliasIdentifier")
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.inputs, forKey: .inputs)
            try container.encodeIfPresent(self.modelPerformanceConfiguration, forKey: .modelPerformanceConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.executionId, name: "executionId", parent: name, max: 100)
            try self.validate(self.executionId, name: "executionId", parent: name, min: 2)
            try self.validate(self.executionId, name: "executionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.flowAliasIdentifier, name: "flowAliasIdentifier", parent: name, max: 2048)
            try self.validate(self.flowAliasIdentifier, name: "flowAliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, max: 2048)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.inputs.forEach {
                try $0.validate(name: "\(name).inputs[]")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case enableTrace = "enableTrace"
            case executionId = "executionId"
            case inputs = "inputs"
            case modelPerformanceConfiguration = "modelPerformanceConfiguration"
        }
    }

    public struct InvokeFlowResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The unique identifier for the current flow execution.
        public let executionId: String?
        /// The output of the flow, returned as a stream. If there's an error, the error is returned.
        public let responseStream: AWSEventStream<FlowResponseStream>

        @inlinable
        public init(executionId: String? = nil, responseStream: AWSEventStream<FlowResponseStream>) {
            self.executionId = executionId
            self.responseStream = responseStream
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.executionId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-bedrock-flow-execution-id")
            self.responseStream = try container.decode(AWSEventStream<FlowResponseStream>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeInlineAgentRequest: AWSEncodableShape {
        ///  A list of action groups with each action group defining the action the inline agent needs to carry out.
        public let actionGroups: [AgentActionGroup]?
        /// Model settings for the request.
        public let bedrockModelConfigurations: InlineBedrockModelConfigurations?
        ///  The Amazon Resource Name (ARN) of the Amazon Web Services KMS key to use to encrypt your inline agent.
        public let customerEncryptionKeyArn: String?
        ///  Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see Using trace.
        public let enableTrace: Bool?
        ///  Specifies whether to end the session with the inline agent or not.
        public let endSession: Bool?
        ///  The model identifier (ID) of the model to use for orchestration by the inline agent. For example, meta.llama3-1-70b-instruct-v1:0.
        public let foundationModel: String
        ///  The guardrails to assign to the inline agent.
        public let guardrailConfiguration: GuardrailConfigurationWithArn?
        ///  The number of seconds for which the inline agent should maintain session information. After this time expires, the subsequent InvokeInlineAgent request begins a new session.  A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and the data provided before the timeout is deleted.
        public let idleSessionTTLInSeconds: Int?
        ///  Parameters that specify the various attributes of a sessions. You can include attributes for the session or prompt or, if you configured an  action group to return control, results from invocation of the action group. For more information, see Control session context.   If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
        public let inlineSessionState: InlineSessionState?
        ///  The prompt text to send to the agent.   If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
        public let inputText: String?
        ///  The instructions that tell the inline agent what it should do and how it should interact with users.
        public let instruction: String
        ///  Contains information of the knowledge bases to associate with.
        public let knowledgeBases: [KnowledgeBase]?
        ///  Configurations for advanced prompts used to override the default prompts to enhance the accuracy of the inline agent.
        public let promptOverrideConfiguration: PromptOverrideConfiguration?
        ///  The unique identifier of the session. Use the same value across requests to continue the same conversation.
        public let sessionId: String
        ///  Specifies the configurations for streaming.   To use agent streaming, you need permissions to perform the bedrock:InvokeModelWithResponseStream action.
        public let streamingConfigurations: StreamingConfigurations?

        @inlinable
        public init(actionGroups: [AgentActionGroup]? = nil, bedrockModelConfigurations: InlineBedrockModelConfigurations? = nil, customerEncryptionKeyArn: String? = nil, enableTrace: Bool? = nil, endSession: Bool? = nil, foundationModel: String, guardrailConfiguration: GuardrailConfigurationWithArn? = nil, idleSessionTTLInSeconds: Int? = nil, inlineSessionState: InlineSessionState? = nil, inputText: String? = nil, instruction: String, knowledgeBases: [KnowledgeBase]? = nil, promptOverrideConfiguration: PromptOverrideConfiguration? = nil, sessionId: String, streamingConfigurations: StreamingConfigurations? = nil) {
            self.actionGroups = actionGroups
            self.bedrockModelConfigurations = bedrockModelConfigurations
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.enableTrace = enableTrace
            self.endSession = endSession
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.inlineSessionState = inlineSessionState
            self.inputText = inputText
            self.instruction = instruction
            self.knowledgeBases = knowledgeBases
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.sessionId = sessionId
            self.streamingConfigurations = streamingConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionGroups, forKey: .actionGroups)
            try container.encodeIfPresent(self.bedrockModelConfigurations, forKey: .bedrockModelConfigurations)
            try container.encodeIfPresent(self.customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
            try container.encodeIfPresent(self.enableTrace, forKey: .enableTrace)
            try container.encodeIfPresent(self.endSession, forKey: .endSession)
            try container.encode(self.foundationModel, forKey: .foundationModel)
            try container.encodeIfPresent(self.guardrailConfiguration, forKey: .guardrailConfiguration)
            try container.encodeIfPresent(self.idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
            try container.encodeIfPresent(self.inlineSessionState, forKey: .inlineSessionState)
            try container.encodeIfPresent(self.inputText, forKey: .inputText)
            try container.encode(self.instruction, forKey: .instruction)
            try container.encodeIfPresent(self.knowledgeBases, forKey: .knowledgeBases)
            try container.encodeIfPresent(self.promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.streamingConfigurations, forKey: .streamingConfigurations)
        }

        public func validate(name: String) throws {
            try self.actionGroups?.forEach {
                try $0.validate(name: "\(name).actionGroups[]")
            }
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyArn, name: "customerEncryptionKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, max: 2048)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, min: 1)
            try self.validate(self.foundationModel, name: "foundationModel", parent: name, pattern: "(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+))$|(^arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{1,20}):(|[0-9]{12}):inference-profile/[a-zA-Z0-9-:.]+)$")
            try self.guardrailConfiguration?.validate(name: "\(name).guardrailConfiguration")
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 3600)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.inlineSessionState?.validate(name: "\(name).inlineSessionState")
            try self.validate(self.inputText, name: "inputText", parent: name, max: 25000000)
            try self.validate(self.instruction, name: "instruction", parent: name, min: 40)
            try self.knowledgeBases?.forEach {
                try $0.validate(name: "\(name).knowledgeBases[]")
            }
            try self.promptOverrideConfiguration?.validate(name: "\(name).promptOverrideConfiguration")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroups = "actionGroups"
            case bedrockModelConfigurations = "bedrockModelConfigurations"
            case customerEncryptionKeyArn = "customerEncryptionKeyArn"
            case enableTrace = "enableTrace"
            case endSession = "endSession"
            case foundationModel = "foundationModel"
            case guardrailConfiguration = "guardrailConfiguration"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case inlineSessionState = "inlineSessionState"
            case inputText = "inputText"
            case instruction = "instruction"
            case knowledgeBases = "knowledgeBases"
            case promptOverrideConfiguration = "promptOverrideConfiguration"
            case streamingConfigurations = "streamingConfigurations"
        }
    }

    public struct InvokeInlineAgentResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        ///
        public let completion: AWSEventStream<InlineAgentResponseStream>
        ///  The MIME type of the input data in the request. The default value is application/json.
        public let contentType: String
        ///  The unique identifier of the session with the agent.
        public let sessionId: String

        @inlinable
        public init(completion: AWSEventStream<InlineAgentResponseStream>, contentType: String, sessionId: String) {
            self.completion = completion
            self.contentType = contentType
            self.sessionId = sessionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.completion = try container.decode(AWSEventStream<InlineAgentResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "x-amzn-bedrock-agent-content-type")
            self.sessionId = try response.decodeHeader(String.self, key: "x-amz-bedrock-agent-session-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct KnowledgeBase: AWSEncodableShape {
        ///  The description of the knowledge base associated with the inline agent.
        public let description: String
        ///  The unique identifier for a knowledge base associated with the inline agent.
        public let knowledgeBaseId: String
        ///  The configurations to apply to the knowledge base during query. For more information, see Query configurations.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?

        @inlinable
        public init(description: String, knowledgeBaseId: String, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseId = "knowledgeBaseId"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseConfiguration: AWSEncodableShape {
        /// The unique identifier for a knowledge base attached to the agent.
        public let knowledgeBaseId: String
        /// The configurations to apply to the knowledge base during query. For more information, see Query configurations.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration

        @inlinable
        public init(knowledgeBaseId: String, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration) {
            self.knowledgeBaseId = knowledgeBaseId
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.retrievalConfiguration.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseLookupInput: AWSDecodableShape {
        /// The unique identifier of the knowledge base to look up.
        public let knowledgeBaseId: String?
        /// The query made to the knowledge base.
        public let text: String?

        @inlinable
        public init(knowledgeBaseId: String? = nil, text: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case text = "text"
        }
    }

    public struct KnowledgeBaseLookupOutput: AWSDecodableShape {
        /// Contains metadata about the sources cited for the generated response.
        public let retrievedReferences: [RetrievedReference]?

        @inlinable
        public init(retrievedReferences: [RetrievedReference]? = nil) {
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct KnowledgeBaseQuery: AWSEncodableShape {
        /// The text of the query made to the knowledge base.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct KnowledgeBaseRetrievalConfiguration: AWSEncodableShape {
        /// Contains details about how the results from the vector search should be returned. For more information, see Query configurations.
        public let vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration

        @inlinable
        public init(vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.vectorSearchConfiguration.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct KnowledgeBaseRetrievalResult: AWSDecodableShape {
        /// Contains information about the content of the chunk.
        public let content: RetrievalResultContent
        /// Contains information about the location of the data source.
        public let location: RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see Metadata and filtering.
        public let metadata: [String: AWSDocument]?
        /// The level of relevance of the result to the query.
        public let score: Double?

        @inlinable
        public init(content: RetrievalResultContent, location: RetrievalResultLocation? = nil, metadata: [String: AWSDocument]? = nil, score: Double? = nil) {
            self.content = content
            self.location = location
            self.metadata = metadata
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case metadata = "metadata"
            case score = "score"
        }
    }

    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// Contains configurations for response generation based on the knowledge base query results.
        public let generationConfiguration: GenerationConfiguration?
        /// The unique identifier of the knowledge base that is queried.
        public let knowledgeBaseId: String
        /// The ARN of the foundation model or inference profile used to generate a response.
        public let modelArn: String
        /// Settings for how the model processes the prompt prior to retrieval and generation.
        public let orchestrationConfiguration: OrchestrationConfiguration?
        /// Contains configurations for how to retrieve and return the knowledge base query.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?

        @inlinable
        public init(generationConfiguration: GenerationConfiguration? = nil, knowledgeBaseId: String, modelArn: String, orchestrationConfiguration: OrchestrationConfiguration? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil) {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.orchestrationConfiguration = orchestrationConfiguration
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:(bedrock|sagemaker):[a-z0-9-]{1,20}:([0-9]{12})?:([a-z-]+/)?)?([a-z0-9.-]{1,63}){0,2}(([:][a-z0-9-]{1,63}){0,2})?(/[a-z0-9]{1,12})?$")
            try self.orchestrationConfiguration?.validate(name: "\(name).orchestrationConfiguration")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case modelArn = "modelArn"
            case orchestrationConfiguration = "orchestrationConfiguration"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseVectorSearchConfiguration: AWSEncodableShape {
        /// Specifies the filters to use on the metadata in the knowledge base data sources before returning results. For more information, see Query configurations.
        public let filter: RetrievalFilter?
        /// Settings for implicit filtering.
        public let implicitFilterConfiguration: ImplicitFilterConfiguration?
        /// The number of source chunks to retrieve.
        public let numberOfResults: Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available. For more information, see Test a knowledge base.
        public let overrideSearchType: SearchType?
        /// Contains configurations for reranking the retrieved results. For more information, see Improve the relevance of query responses with a reranker model.
        public let rerankingConfiguration: VectorSearchRerankingConfiguration?

        @inlinable
        public init(filter: RetrievalFilter? = nil, implicitFilterConfiguration: ImplicitFilterConfiguration? = nil, numberOfResults: Int? = nil, overrideSearchType: SearchType? = nil, rerankingConfiguration: VectorSearchRerankingConfiguration? = nil) {
            self.filter = filter
            self.implicitFilterConfiguration = implicitFilterConfiguration
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
            self.rerankingConfiguration = rerankingConfiguration
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.implicitFilterConfiguration?.validate(name: "\(name).implicitFilterConfiguration")
            try self.rerankingConfiguration?.validate(name: "\(name).rerankingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case implicitFilterConfiguration = "implicitFilterConfiguration"
            case numberOfResults = "numberOfResults"
            case overrideSearchType = "overrideSearchType"
            case rerankingConfiguration = "rerankingConfiguration"
        }
    }

    public struct ListInvocationStepsRequest: AWSEncodableShape {
        /// The unique identifier (in UUID format) for the invocation to list invocation steps for.
        public let invocationIdentifier: String?
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The unique identifier for the session associated with the invocation steps. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(invocationIdentifier: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sessionIdentifier: String) {
            self.invocationIdentifier = invocationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.invocationIdentifier, forKey: .invocationIdentifier)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationIdentifier, name: "invocationIdentifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationIdentifier = "invocationIdentifier"
        }
    }

    public struct ListInvocationStepsResponse: AWSDecodableShape {
        /// A list of summaries for each invocation step associated with a session and if you specified it, an invocation within the session.
        public let invocationStepSummaries: [InvocationStepSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(invocationStepSummaries: [InvocationStepSummary], nextToken: String? = nil) {
            self.invocationStepSummaries = invocationStepSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invocationStepSummaries = "invocationStepSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListInvocationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The unique identifier for the session to list invocations for. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sessionIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvocationsResponse: AWSDecodableShape {
        /// A list of invocation summaries associated with the session.
        public let invocationSummaries: [InvocationSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(invocationSummaries: [InvocationSummary], nextToken: String? = nil) {
            self.invocationSummaries = invocationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invocationSummaries = "invocationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListSessionsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSessionsResponse: AWSDecodableShape {
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?
        /// A list of summaries for each session in your Amazon Web Services account.
        public let sessionSummaries: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionSummaries = "sessionSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws(-[^:]+)?:bedrock:[a-zA-Z0-9-]+:[0-9]{12}:(session)/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pairs for the tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MemorySessionSummary: AWSDecodableShape {
        /// The unique identifier of the memory where the session summary is stored.
        public let memoryId: String?
        /// The time when the memory duration for the session is set to end.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var sessionExpiryTime: Date?
        /// The identifier for this session.
        public let sessionId: String?
        /// The start time for this session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var sessionStartTime: Date?
        /// The summarized text for this session.
        public let summaryText: String?

        @inlinable
        public init(memoryId: String? = nil, sessionExpiryTime: Date? = nil, sessionId: String? = nil, sessionStartTime: Date? = nil, summaryText: String? = nil) {
            self.memoryId = memoryId
            self.sessionExpiryTime = sessionExpiryTime
            self.sessionId = sessionId
            self.sessionStartTime = sessionStartTime
            self.summaryText = summaryText
        }

        private enum CodingKeys: String, CodingKey {
            case memoryId = "memoryId"
            case sessionExpiryTime = "sessionExpiryTime"
            case sessionId = "sessionId"
            case sessionStartTime = "sessionStartTime"
            case summaryText = "summaryText"
        }
    }

    public struct Message: AWSEncodableShape {
        /// The message's content.
        public let content: [ContentBlock]
        /// The message's role.
        public let role: ConversationRole

        @inlinable
        public init(content: [ContentBlock], role: ConversationRole) {
            self.content = content
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case role = "role"
        }
    }

    public struct Metadata: AWSDecodableShape {
        /// Contains details of the foundation model usage.
        public let usage: Usage?

        @inlinable
        public init(usage: Usage? = nil) {
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case usage = "usage"
        }
    }

    public struct MetadataAttributeSchema: AWSEncodableShape {
        /// The attribute's description.
        public let description: String
        /// The attribute's key.
        public let key: String
        /// The attribute's type.
        public let type: AttributeType

        @inlinable
        public init(description: String, key: String, type: AttributeType) {
            self.description = description
            self.key = key
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case key = "key"
            case type = "type"
        }
    }

    public struct MetadataConfigurationForReranking: AWSEncodableShape {
        /// Specifies whether to consider all metadata when reranking, or only the metadata that you select. If you specify SELECTIVE, include the selectiveModeConfiguration field.
        public let selectionMode: RerankingMetadataSelectionMode
        /// Contains configurations for the metadata fields to include or exclude when considering reranking.
        public let selectiveModeConfiguration: RerankingMetadataSelectiveModeConfiguration?

        @inlinable
        public init(selectionMode: RerankingMetadataSelectionMode, selectiveModeConfiguration: RerankingMetadataSelectiveModeConfiguration? = nil) {
            self.selectionMode = selectionMode
            self.selectiveModeConfiguration = selectiveModeConfiguration
        }

        public func validate(name: String) throws {
            try self.selectiveModeConfiguration?.validate(name: "\(name).selectiveModeConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case selectionMode = "selectionMode"
            case selectiveModeConfiguration = "selectiveModeConfiguration"
        }
    }

    public struct ModelInvocationInput: AWSDecodableShape {
        /// The identifier of a foundation model.
        public let foundationModel: String?
        /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the PromptOverrideConfiguration object that was set when the agent was created or updated. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.
        public let overrideLambda: String?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType.
        public let parserMode: CreationMode?
        /// Specifies whether the default prompt template was OVERRIDDEN. If it was, the basePromptTemplate that was set in the PromptOverrideConfiguration object when the agent was created or updated is used instead.
        public let promptCreationMode: CreationMode?
        /// The text that prompted the agent at this step.
        public let text: String?
        /// The unique identifier of the trace.
        public let traceId: String?
        /// The step in the agent sequence.
        public let type: PromptType?

        @inlinable
        public init(foundationModel: String? = nil, inferenceConfiguration: InferenceConfiguration? = nil, overrideLambda: String? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, text: String? = nil, traceId: String? = nil, type: PromptType? = nil) {
            self.foundationModel = foundationModel
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case foundationModel = "foundationModel"
            case inferenceConfiguration = "inferenceConfiguration"
            case overrideLambda = "overrideLambda"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case text = "text"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct ModelNotReadyException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ModelPerformanceConfiguration: AWSEncodableShape {
        /// The latency configuration for the model.
        public let performanceConfig: PerformanceConfiguration?

        @inlinable
        public init(performanceConfig: PerformanceConfiguration? = nil) {
            self.performanceConfig = performanceConfig
        }

        private enum CodingKeys: String, CodingKey {
            case performanceConfig = "performanceConfig"
        }
    }

    public struct Observation: AWSDecodableShape {
        /// Contains the JSON-formatted string returned by the API invoked by the action group.
        public let actionGroupInvocationOutput: ActionGroupInvocationOutput?
        /// A collaborator's invocation output.
        public let agentCollaboratorInvocationOutput: AgentCollaboratorInvocationOutput?
        /// Contains the JSON-formatted string returned by the API invoked by the code interpreter.
        public let codeInterpreterInvocationOutput: CodeInterpreterInvocationOutput?
        /// Contains details about the response to the user.
        public let finalResponse: FinalResponse?
        /// Contains details about the results from looking up the knowledge base.
        public let knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput?
        /// Contains details about the response to reprompt the input.
        public let repromptResponse: RepromptResponse?
        /// The unique identifier of the trace.
        public let traceId: String?
        /// Specifies what kind of information the agent returns in the observation. The following values are possible.    ACTION_GROUP – The agent returns the result of an action group.    KNOWLEDGE_BASE – The agent returns information from a knowledge base.    FINISH – The agent returns a final response to the user with no follow-up.    ASK_USER – The agent asks the user a question.    REPROMPT – The agent prompts the user again for the same information.
        public let type: `Type`?

        @inlinable
        public init(actionGroupInvocationOutput: ActionGroupInvocationOutput? = nil, agentCollaboratorInvocationOutput: AgentCollaboratorInvocationOutput? = nil, codeInterpreterInvocationOutput: CodeInterpreterInvocationOutput? = nil, finalResponse: FinalResponse? = nil, knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput? = nil, repromptResponse: RepromptResponse? = nil, traceId: String? = nil, type: `Type`? = nil) {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.agentCollaboratorInvocationOutput = agentCollaboratorInvocationOutput
            self.codeInterpreterInvocationOutput = codeInterpreterInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationOutput = "actionGroupInvocationOutput"
            case agentCollaboratorInvocationOutput = "agentCollaboratorInvocationOutput"
            case codeInterpreterInvocationOutput = "codeInterpreterInvocationOutput"
            case finalResponse = "finalResponse"
            case knowledgeBaseLookupOutput = "knowledgeBaseLookupOutput"
            case repromptResponse = "repromptResponse"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct OptimizePromptRequest: AWSEncodableShape {
        /// Contains the prompt to optimize.
        public let input: InputPrompt
        /// The unique identifier of the model that you want to optimize the prompt for.
        public let targetModelId: String

        @inlinable
        public init(input: InputPrompt, targetModelId: String) {
            self.input = input
            self.targetModelId = targetModelId
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case targetModelId = "targetModelId"
        }
    }

    public struct OptimizePromptResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The prompt after being optimized for the task.
        public let optimizedPrompt: AWSEventStream<OptimizedPromptStream>

        @inlinable
        public init(optimizedPrompt: AWSEventStream<OptimizedPromptStream>) {
            self.optimizedPrompt = optimizedPrompt
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.optimizedPrompt = try container.decode(AWSEventStream<OptimizedPromptStream>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct OptimizedPromptEvent: AWSDecodableShape {
        /// Contains information about the optimized prompt.
        public let optimizedPrompt: OptimizedPrompt?

        @inlinable
        public init(optimizedPrompt: OptimizedPrompt? = nil) {
            self.optimizedPrompt = optimizedPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case optimizedPrompt = "optimizedPrompt"
        }
    }

    public struct OrchestrationConfiguration: AWSEncodableShape {
        ///  Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows users to provide custom model parameters specific to the language model being used.
        public let additionalModelRequestFields: [String: AWSDocument]?
        ///  Configuration settings for inference when using RetrieveAndGenerate to generate responses while using a knowledge base as a source.
        public let inferenceConfig: InferenceConfig?
        /// The latency configuration for the model.
        public let performanceConfig: PerformanceConfiguration?
        /// Contains the template for the prompt that's sent to the model. Orchestration prompts must include the $conversation_history$ and $output_format_instructions$ variables. For more information, see Use placeholder variables in the user guide.
        public let promptTemplate: PromptTemplate?
        /// To split up the prompt and retrieve multiple sources, set the transformation type to QUERY_DECOMPOSITION.
        public let queryTransformationConfiguration: QueryTransformationConfiguration?

        @inlinable
        public init(additionalModelRequestFields: [String: AWSDocument]? = nil, inferenceConfig: InferenceConfig? = nil, performanceConfig: PerformanceConfiguration? = nil, promptTemplate: PromptTemplate? = nil, queryTransformationConfiguration: QueryTransformationConfiguration? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.inferenceConfig = inferenceConfig
            self.performanceConfig = performanceConfig
            self.promptTemplate = promptTemplate
            self.queryTransformationConfiguration = queryTransformationConfiguration
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case inferenceConfig = "inferenceConfig"
            case performanceConfig = "performanceConfig"
            case promptTemplate = "promptTemplate"
            case queryTransformationConfiguration = "queryTransformationConfiguration"
        }
    }

    public struct OrchestrationModelInvocationOutput: AWSDecodableShape {
        /// Contains information about the foundation model output from the orchestration step.
        public let metadata: Metadata?
        /// Contains details of the raw response from the foundation model output.
        public let rawResponse: RawResponse?
        /// Contains content about the reasoning that the model made during the orchestration step.
        public let reasoningContent: ReasoningContentBlock?
        /// The unique identifier of the trace.
        public let traceId: String?

        @inlinable
        public init(metadata: Metadata? = nil, rawResponse: RawResponse? = nil, reasoningContent: ReasoningContentBlock? = nil, traceId: String? = nil) {
            self.metadata = metadata
            self.rawResponse = rawResponse
            self.reasoningContent = reasoningContent
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case rawResponse = "rawResponse"
            case reasoningContent = "reasoningContent"
            case traceId = "traceId"
        }
    }

    public struct OutputFile: AWSDecodableShape {
        /// The byte count of files that contains response from code interpreter.
        public let bytes: AWSBase64Data?
        /// The name of the file containing response from code interpreter.
        public let name: String?
        /// The type of file that contains response from the code interpreter.
        public let type: String?

        @inlinable
        public init(bytes: AWSBase64Data? = nil, name: String? = nil, type: String? = nil) {
            self.bytes = bytes
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case name = "name"
            case type = "type"
        }
    }

    public struct Parameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The type of the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct ParameterDetail: AWSEncodableShape {
        ///  A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public let description: String?
        ///  Whether the parameter is required for the agent to complete the function for action group invocation.
        public let required: Bool?
        ///  The data type of the parameter.
        public let type: ParameterType

        @inlinable
        public init(description: String? = nil, required: Bool? = nil, type: ParameterType) {
            self.description = description
            self.required = required
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case required = "required"
            case type = "type"
        }
    }

    public struct PayloadPart: AWSDecodableShape {
        /// Contains citations for a part of an agent response.
        public let attribution: Attribution?
        /// A part of the agent response in bytes.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(attribution: Attribution? = nil, bytes: AWSBase64Data? = nil) {
            self.attribution = attribution
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case attribution = "attribution"
            case bytes = "bytes"
        }
    }

    public struct PerformanceConfiguration: AWSEncodableShape {
        /// To use a latency-optimized version of the model, set to optimized.
        public let latency: PerformanceConfigLatency?

        @inlinable
        public init(latency: PerformanceConfigLatency? = nil) {
            self.latency = latency
        }

        private enum CodingKeys: String, CodingKey {
            case latency = "latency"
        }
    }

    public struct PostProcessingModelInvocationOutput: AWSDecodableShape {
        ///  Contains information about the foundation model output from the post-processing step.
        public let metadata: Metadata?
        /// Details about the response from the Lambda parsing of the output of the post-processing step.
        public let parsedResponse: PostProcessingParsedResponse?
        ///  Details of the raw response from the foundation model output.
        public let rawResponse: RawResponse?
        /// Contains content about the reasoning that the model made during the post-processing step.
        public let reasoningContent: ReasoningContentBlock?
        /// The unique identifier of the trace.
        public let traceId: String?

        @inlinable
        public init(metadata: Metadata? = nil, parsedResponse: PostProcessingParsedResponse? = nil, rawResponse: RawResponse? = nil, reasoningContent: ReasoningContentBlock? = nil, traceId: String? = nil) {
            self.metadata = metadata
            self.parsedResponse = parsedResponse
            self.rawResponse = rawResponse
            self.reasoningContent = reasoningContent
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case parsedResponse = "parsedResponse"
            case rawResponse = "rawResponse"
            case reasoningContent = "reasoningContent"
            case traceId = "traceId"
        }
    }

    public struct PostProcessingParsedResponse: AWSDecodableShape {
        /// The text returned by the parser.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct PreProcessingModelInvocationOutput: AWSDecodableShape {
        ///  Contains information about the foundation model output from the pre-processing step.
        public let metadata: Metadata?
        /// Details about the response from the Lambda parsing of the output of the pre-processing step.
        public let parsedResponse: PreProcessingParsedResponse?
        ///  Details of the raw response from the foundation model output.
        public let rawResponse: RawResponse?
        /// Contains content about the reasoning that the model made during the pre-processing step.
        public let reasoningContent: ReasoningContentBlock?
        /// The unique identifier of the trace.
        public let traceId: String?

        @inlinable
        public init(metadata: Metadata? = nil, parsedResponse: PreProcessingParsedResponse? = nil, rawResponse: RawResponse? = nil, reasoningContent: ReasoningContentBlock? = nil, traceId: String? = nil) {
            self.metadata = metadata
            self.parsedResponse = parsedResponse
            self.rawResponse = rawResponse
            self.reasoningContent = reasoningContent
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case parsedResponse = "parsedResponse"
            case rawResponse = "rawResponse"
            case reasoningContent = "reasoningContent"
            case traceId = "traceId"
        }
    }

    public struct PreProcessingParsedResponse: AWSDecodableShape {
        /// Whether the user input is valid or not. If false, the agent doesn't proceed to orchestration.
        public let isValid: Bool?
        /// The text returned by the parsing of the pre-processing step, explaining the steps that the agent plans to take in orchestration, if the user input is valid.
        public let rationale: String?

        @inlinable
        public init(isValid: Bool? = nil, rationale: String? = nil) {
            self.isValid = isValid
            self.rationale = rationale
        }

        private enum CodingKeys: String, CodingKey {
            case isValid = "isValid"
            case rationale = "rationale"
        }
    }

    public struct PromptConfiguration: AWSEncodableShape {
        /// If the Converse or ConverseStream operations support the model, additionalModelRequestFields contains additional inference parameters, beyond the base set of inference parameters in the inferenceConfiguration field.  For more information, see Inference request parameters and response fields for foundation models in the Amazon Bedrock user guide.
        public let additionalModelRequestFields: AWSDocument?
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see Prompt template placeholder variables. For more information, see Configure the prompt templates.
        public let basePromptTemplate: String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDDEN, the overrideLambda field in the PromptOverrideConfiguration must be specified with the ARN of a Lambda function.
        public let parserMode: CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public let promptCreationMode: CreationMode?
        /// Specifies whether to allow the inline agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.    PRE_PROCESSING – ENABLED     ORCHESTRATION – ENABLED     KNOWLEDGE_BASE_RESPONSE_GENERATION – ENABLED     POST_PROCESSING – DISABLED
        public let promptState: PromptState?
        ///  The step in the agent sequence that this prompt configuration applies to.
        public let promptType: PromptType?

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, basePromptTemplate: String? = nil, inferenceConfiguration: InferenceConfiguration? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, promptState: PromptState? = nil, promptType: PromptType? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }

        public func validate(name: String) throws {
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, max: 100000)
            try self.validate(self.basePromptTemplate, name: "basePromptTemplate", parent: name, min: 1)
            try self.inferenceConfiguration?.validate(name: "\(name).inferenceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case basePromptTemplate = "basePromptTemplate"
            case inferenceConfiguration = "inferenceConfiguration"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case promptState = "promptState"
            case promptType = "promptType"
        }
    }

    public struct PromptOverrideConfiguration: AWSEncodableShape {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.  If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is  set to OVERRIDDEN. For more information, see Parser Lambda function in Amazon Bedrock Agents.
        public let overrideLambda: String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see Advanced prompts.
        public let promptConfigurations: [PromptConfiguration]

        @inlinable
        public init(overrideLambda: String? = nil, promptConfigurations: [PromptConfiguration]) {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, max: 2048)
            try self.validate(self.overrideLambda, name: "overrideLambda", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$")
            try self.promptConfigurations.forEach {
                try $0.validate(name: "\(name).promptConfigurations[]")
            }
            try self.validate(self.promptConfigurations, name: "promptConfigurations", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case overrideLambda = "overrideLambda"
            case promptConfigurations = "promptConfigurations"
        }
    }

    public struct PromptTemplate: AWSEncodableShape {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see the following resources:    Knowledge base prompt templates     Use XML tags with Anthropic Claude models
        public let textPromptTemplate: String?

        @inlinable
        public init(textPromptTemplate: String? = nil) {
            self.textPromptTemplate = textPromptTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, max: 4000)
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case textPromptTemplate = "textPromptTemplate"
        }
    }

    public struct PropertyParameters: AWSDecodableShape {
        /// A list of parameters in the request body.
        public let properties: [Parameter]?

        @inlinable
        public init(properties: [Parameter]? = nil) {
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case properties = "properties"
        }
    }

    public struct PutInvocationStepRequest: AWSEncodableShape {
        /// The unique identifier (in UUID format) of the invocation to add the invocation step to.
        public let invocationIdentifier: String
        /// The unique identifier of the invocation step in UUID format.
        public let invocationStepId: String?
        /// The timestamp for when the invocation step occurred.
        @CustomCoding<ISO8601DateCoder>
        public var invocationStepTime: Date
        /// The payload for the invocation step, including text and images for the interaction.
        public let payload: InvocationStepPayload
        /// The unique identifier for the session to add the invocation step to. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String

        @inlinable
        public init(invocationIdentifier: String, invocationStepId: String? = nil, invocationStepTime: Date, payload: InvocationStepPayload, sessionIdentifier: String) {
            self.invocationIdentifier = invocationIdentifier
            self.invocationStepId = invocationStepId
            self.invocationStepTime = invocationStepTime
            self.payload = payload
            self.sessionIdentifier = sessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.invocationIdentifier, forKey: .invocationIdentifier)
            try container.encodeIfPresent(self.invocationStepId, forKey: .invocationStepId)
            try container.encode(self.invocationStepTime, forKey: .invocationStepTime)
            try container.encode(self.payload, forKey: .payload)
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationIdentifier, name: "invocationIdentifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.invocationStepId, name: "invocationStepId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.payload.validate(name: "\(name).payload")
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationIdentifier = "invocationIdentifier"
            case invocationStepId = "invocationStepId"
            case invocationStepTime = "invocationStepTime"
            case payload = "payload"
        }
    }

    public struct PutInvocationStepResponse: AWSDecodableShape {
        /// The unique identifier of the invocation step in UUID format.
        public let invocationStepId: String

        @inlinable
        public init(invocationStepId: String) {
            self.invocationStepId = invocationStepId
        }

        private enum CodingKeys: String, CodingKey {
            case invocationStepId = "invocationStepId"
        }
    }

    public struct QueryGenerationInput: AWSEncodableShape {
        /// The text of the query.
        public let text: String
        /// The type of the query.
        public let type: InputQueryType

        @inlinable
        public init(text: String, type: InputQueryType) {
            self.text = text
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case type = "type"
        }
    }

    public struct QueryTransformationConfiguration: AWSEncodableShape {
        /// The type of transformation to apply to the prompt.
        public let type: QueryTransformationType

        @inlinable
        public init(type: QueryTransformationType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct Rationale: AWSDecodableShape {
        /// The reasoning or thought process of the agent, based on the input.
        public let text: String?
        /// The unique identifier of the trace step.
        public let traceId: String?

        @inlinable
        public init(text: String? = nil, traceId: String? = nil) {
            self.text = text
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case traceId = "traceId"
        }
    }

    public struct RawResponse: AWSDecodableShape {
        /// The foundation model's raw output content.
        public let content: String?

        @inlinable
        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct ReasoningTextBlock: AWSDecodableShape {
        /// A hash of all the messages in the conversation to ensure that the content in the reasoning text block isn't tampered with. You must submit the signature in subsequent Converse requests, in addition to the previous messages. If the previous messages are tampered with, the response throws an error.
        public let signature: String?
        /// Text describing the reasoning that the model used to return the content in the content block.
        public let text: String

        @inlinable
        public init(signature: String? = nil, text: String) {
            self.signature = signature
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case signature = "signature"
            case text = "text"
        }
    }

    public struct RepromptResponse: AWSDecodableShape {
        /// Specifies what output is prompting the agent to reprompt the input.
        public let source: Source?
        /// The text reprompting the input.
        public let text: String?

        @inlinable
        public init(source: Source? = nil, text: String? = nil) {
            self.source = source
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case text = "text"
        }
    }

    public struct RequestBody: AWSDecodableShape {
        /// The content in the request body.
        public let content: [String: [Parameter]]?

        @inlinable
        public init(content: [String: [Parameter]]? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct RerankDocument: AWSEncodableShape & AWSDecodableShape {
        /// Contains a JSON document to rerank.
        public let jsonDocument: AWSDocument?
        /// Contains information about a text document to rerank.
        public let textDocument: RerankTextDocument?
        /// The type of document to rerank.
        public let type: RerankDocumentType

        @inlinable
        public init(jsonDocument: AWSDocument? = nil, textDocument: RerankTextDocument? = nil, type: RerankDocumentType) {
            self.jsonDocument = jsonDocument
            self.textDocument = textDocument
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case jsonDocument = "jsonDocument"
            case textDocument = "textDocument"
            case type = "type"
        }
    }

    public struct RerankQuery: AWSEncodableShape {
        /// Contains information about a text query.
        public let textQuery: RerankTextDocument
        /// The type of the query.
        public let type: RerankQueryContentType

        @inlinable
        public init(textQuery: RerankTextDocument, type: RerankQueryContentType) {
            self.textQuery = textQuery
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case textQuery = "textQuery"
            case type = "type"
        }
    }

    public struct RerankRequest: AWSEncodableShape {
        /// If the total number of results was greater than could fit in a response, a token is returned in the nextToken field. You can enter that token in this field to return the next batch of results.
        public let nextToken: String?
        /// An array of objects, each of which contains information about a query to submit to the reranker model.
        public let queries: [RerankQuery]
        /// Contains configurations for reranking.
        public let rerankingConfiguration: RerankingConfiguration
        /// An array of objects, each of which contains information about the sources to rerank.
        public let sources: [RerankSource]

        @inlinable
        public init(nextToken: String? = nil, queries: [RerankQuery], rerankingConfiguration: RerankingConfiguration, sources: [RerankSource]) {
            self.nextToken = nextToken
            self.queries = queries
            self.rerankingConfiguration = rerankingConfiguration
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.queries, name: "queries", parent: name, max: 1)
            try self.validate(self.queries, name: "queries", parent: name, min: 1)
            try self.rerankingConfiguration.validate(name: "\(name).rerankingConfiguration")
            try self.validate(self.sources, name: "sources", parent: name, max: 1000)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queries = "queries"
            case rerankingConfiguration = "rerankingConfiguration"
            case sources = "sources"
        }
    }

    public struct RerankResponse: AWSDecodableShape {
        /// If the total number of results is greater than can fit in the response, use this token in the nextToken field when making another request to return the next batch of results.
        public let nextToken: String?
        /// An array of objects, each of which contains information about the results of reranking.
        public let results: [RerankResult]

        @inlinable
        public init(nextToken: String? = nil, results: [RerankResult]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct RerankResult: AWSDecodableShape {
        /// Contains information about the document.
        public let document: RerankDocument?
        /// The ranking of the document. The lower a number, the higher the document is ranked.
        public let index: Int
        /// The relevance score of the document.
        public let relevanceScore: Float

        @inlinable
        public init(document: RerankDocument? = nil, index: Int, relevanceScore: Float) {
            self.document = document
            self.index = index
            self.relevanceScore = relevanceScore
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
            case index = "index"
            case relevanceScore = "relevanceScore"
        }
    }

    public struct RerankSource: AWSEncodableShape {
        /// Contains an inline definition of a source for reranking.
        public let inlineDocumentSource: RerankDocument
        /// The type of the source.
        public let type: RerankSourceType

        @inlinable
        public init(inlineDocumentSource: RerankDocument, type: RerankSourceType) {
            self.inlineDocumentSource = inlineDocumentSource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inlineDocumentSource = "inlineDocumentSource"
            case type = "type"
        }
    }

    public struct RerankTextDocument: AWSEncodableShape & AWSDecodableShape {
        /// The text of the document.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RerankingConfiguration: AWSEncodableShape {
        /// Contains configurations for an Amazon Bedrock reranker.
        public let bedrockRerankingConfiguration: BedrockRerankingConfiguration
        /// The type of reranker that the configurations apply to.
        public let type: RerankingConfigurationType

        @inlinable
        public init(bedrockRerankingConfiguration: BedrockRerankingConfiguration, type: RerankingConfigurationType) {
            self.bedrockRerankingConfiguration = bedrockRerankingConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.bedrockRerankingConfiguration.validate(name: "\(name).bedrockRerankingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockRerankingConfiguration = "bedrockRerankingConfiguration"
            case type = "type"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetrievalResultConfluenceLocation: AWSDecodableShape {
        /// The Confluence host URL for the data source location.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrievalResultContent: AWSDecodableShape {
        /// A data URI with base64-encoded content from the data source. The URI is in the following format: returned in the following format: data:image/jpeg;base64,${base64-encoded string}.
        public let byteContent: String?
        /// Specifies information about the rows with the cells to return in retrieval.
        public let row: [RetrievalResultContentColumn]?
        /// The cited text from the data source.
        public let text: String?
        /// The type of content in the retrieval result.
        public let type: RetrievalResultContentType?

        @inlinable
        public init(byteContent: String? = nil, row: [RetrievalResultContentColumn]? = nil, text: String? = nil, type: RetrievalResultContentType? = nil) {
            self.byteContent = byteContent
            self.row = row
            self.text = text
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case row = "row"
            case text = "text"
            case type = "type"
        }
    }

    public struct RetrievalResultContentColumn: AWSDecodableShape {
        /// The name of the column.
        public let columnName: String?
        /// The value in the column.
        public let columnValue: String?
        /// The data type of the value.
        public let type: RetrievalResultContentColumnType?

        @inlinable
        public init(columnName: String? = nil, columnValue: String? = nil, type: RetrievalResultContentColumnType? = nil) {
            self.columnName = columnName
            self.columnValue = columnValue
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case columnValue = "columnValue"
            case type = "type"
        }
    }

    public struct RetrievalResultCustomDocumentLocation: AWSDecodableShape {
        /// The ID of the document.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct RetrievalResultKendraDocumentLocation: AWSDecodableShape {
        /// The document's uri.
        public let uri: String?

        @inlinable
        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct RetrievalResultLocation: AWSDecodableShape {
        /// The Confluence data source location.
        public let confluenceLocation: RetrievalResultConfluenceLocation?
        /// Specifies the location of a document in a custom data source.
        public let customDocumentLocation: RetrievalResultCustomDocumentLocation?
        /// The location of a document in Amazon Kendra.
        public let kendraDocumentLocation: RetrievalResultKendraDocumentLocation?
        /// The S3 data source location.
        public let s3Location: RetrievalResultS3Location?
        /// The Salesforce data source location.
        public let salesforceLocation: RetrievalResultSalesforceLocation?
        /// The SharePoint data source location.
        public let sharePointLocation: RetrievalResultSharePointLocation?
        /// Specifies information about the SQL query used to retrieve the result.
        public let sqlLocation: RetrievalResultSqlLocation?
        /// The type of data source location.
        public let type: RetrievalResultLocationType
        /// The web URL/URLs data source location.
        public let webLocation: RetrievalResultWebLocation?

        @inlinable
        public init(confluenceLocation: RetrievalResultConfluenceLocation? = nil, customDocumentLocation: RetrievalResultCustomDocumentLocation? = nil, kendraDocumentLocation: RetrievalResultKendraDocumentLocation? = nil, s3Location: RetrievalResultS3Location? = nil, salesforceLocation: RetrievalResultSalesforceLocation? = nil, sharePointLocation: RetrievalResultSharePointLocation? = nil, sqlLocation: RetrievalResultSqlLocation? = nil, type: RetrievalResultLocationType, webLocation: RetrievalResultWebLocation? = nil) {
            self.confluenceLocation = confluenceLocation
            self.customDocumentLocation = customDocumentLocation
            self.kendraDocumentLocation = kendraDocumentLocation
            self.s3Location = s3Location
            self.salesforceLocation = salesforceLocation
            self.sharePointLocation = sharePointLocation
            self.sqlLocation = sqlLocation
            self.type = type
            self.webLocation = webLocation
        }

        private enum CodingKeys: String, CodingKey {
            case confluenceLocation = "confluenceLocation"
            case customDocumentLocation = "customDocumentLocation"
            case kendraDocumentLocation = "kendraDocumentLocation"
            case s3Location = "s3Location"
            case salesforceLocation = "salesforceLocation"
            case sharePointLocation = "sharePointLocation"
            case sqlLocation = "sqlLocation"
            case type = "type"
            case webLocation = "webLocation"
        }
    }

    public struct RetrievalResultS3Location: AWSDecodableShape {
        /// The S3 URI for the data source location.
        public let uri: String?

        @inlinable
        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct RetrievalResultSalesforceLocation: AWSDecodableShape {
        /// The Salesforce host URL for the data source location.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrievalResultSharePointLocation: AWSDecodableShape {
        /// The SharePoint site URL for the data source location.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrievalResultSqlLocation: AWSDecodableShape {
        /// The SQL query used to retrieve the result.
        public let query: String?

        @inlinable
        public init(query: String? = nil) {
            self.query = query
        }

        private enum CodingKeys: String, CodingKey {
            case query = "query"
        }
    }

    public struct RetrievalResultWebLocation: AWSDecodableShape {
        /// The web URL/URLs for the data source location.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// The configuration for the external source wrapper object in the retrieveAndGenerate function.
        public let externalSourcesConfiguration: ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains details about the knowledge base for retrieving information and generating responses.
        public let knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that contains your data for retrieving information and generating responses. If you choose to use EXTERNAL_SOURCES, then currently only Anthropic Claude 3 Sonnet models for knowledge bases are supported.
        public let type: RetrieveAndGenerateType

        @inlinable
        public init(externalSourcesConfiguration: ExternalSourcesRetrieveAndGenerateConfiguration? = nil, knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration? = nil, type: RetrieveAndGenerateType) {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.externalSourcesConfiguration?.validate(name: "\(name).externalSourcesConfiguration")
            try self.knowledgeBaseConfiguration?.validate(name: "\(name).knowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case externalSourcesConfiguration = "externalSourcesConfiguration"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case type = "type"
        }
    }

    public struct RetrieveAndGenerateInput: AWSEncodableShape {
        /// The query made to the knowledge base.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateOutput: AWSDecodableShape {
        /// The response generated from querying the knowledge base.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateOutputEvent: AWSDecodableShape {
        /// A text response.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateRequest: AWSEncodableShape {
        /// Contains the query to be made to the knowledge base.
        public let input: RetrieveAndGenerateInput
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration?
        /// Contains details about the session with the knowledge base.
        public let sessionConfiguration: RetrieveAndGenerateSessionConfiguration?
        /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
        public let sessionId: String?

        @inlinable
        public init(input: RetrieveAndGenerateInput, retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration? = nil, sessionConfiguration: RetrieveAndGenerateSessionConfiguration? = nil, sessionId: String? = nil) {
            self.input = input
            self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
            self.sessionConfiguration = sessionConfiguration
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.retrieveAndGenerateConfiguration?.validate(name: "\(name).retrieveAndGenerateConfiguration")
            try self.sessionConfiguration?.validate(name: "\(name).sessionConfiguration")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case retrieveAndGenerateConfiguration = "retrieveAndGenerateConfiguration"
            case sessionConfiguration = "sessionConfiguration"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateResponse: AWSDecodableShape {
        /// A list of segments of the generated response that are based on sources in the knowledge base, alongside information about the sources.
        public let citations: [Citation]?
        /// Specifies if there is a guardrail intervention in the response.
        public let guardrailAction: GuadrailAction?
        /// Contains the response generated from querying the knowledge base.
        public let output: RetrieveAndGenerateOutput
        /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
        public let sessionId: String

        @inlinable
        public init(citations: [Citation]? = nil, guardrailAction: GuadrailAction? = nil, output: RetrieveAndGenerateOutput, sessionId: String) {
            self.citations = citations
            self.guardrailAction = guardrailAction
            self.output = output
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
            case guardrailAction = "guardrailAction"
            case output = "output"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateSessionConfiguration: AWSEncodableShape {
        /// The ARN of the KMS key encrypting the session.
        public let kmsKeyArn: String

        @inlinable
        public init(kmsKeyArn: String) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct RetrieveAndGenerateStreamRequest: AWSEncodableShape {
        /// Contains the query to be made to the knowledge base.
        public let input: RetrieveAndGenerateInput
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration?
        /// Contains details about the session with the knowledge base.
        public let sessionConfiguration: RetrieveAndGenerateSessionConfiguration?
        /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
        public let sessionId: String?

        @inlinable
        public init(input: RetrieveAndGenerateInput, retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration? = nil, sessionConfiguration: RetrieveAndGenerateSessionConfiguration? = nil, sessionId: String? = nil) {
            self.input = input
            self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
            self.sessionConfiguration = sessionConfiguration
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.retrieveAndGenerateConfiguration?.validate(name: "\(name).retrieveAndGenerateConfiguration")
            try self.sessionConfiguration?.validate(name: "\(name).sessionConfiguration")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case retrieveAndGenerateConfiguration = "retrieveAndGenerateConfiguration"
            case sessionConfiguration = "sessionConfiguration"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateStreamResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The session ID.
        public let sessionId: String
        /// A stream of events from the model.
        public let stream: AWSEventStream<RetrieveAndGenerateStreamResponseOutput>

        @inlinable
        public init(sessionId: String, stream: AWSEventStream<RetrieveAndGenerateStreamResponseOutput>) {
            self.sessionId = sessionId
            self.stream = stream
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.sessionId = try response.decodeHeader(String.self, key: "x-amzn-bedrock-knowledge-base-session-id")
            self.stream = try container.decode(AWSEventStream<RetrieveAndGenerateStreamResponseOutput>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RetrieveRequest: AWSEncodableShape {
        /// Guardrail settings.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// The unique identifier of the knowledge base to query.
        public let knowledgeBaseId: String
        /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
        public let nextToken: String?
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?
        /// Contains the query to send the knowledge base.
        public let retrievalQuery: KnowledgeBaseQuery

        @inlinable
        public init(guardrailConfiguration: GuardrailConfiguration? = nil, knowledgeBaseId: String, nextToken: String? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil, retrievalQuery: KnowledgeBaseQuery) {
            self.guardrailConfiguration = guardrailConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.nextToken = nextToken
            self.retrievalConfiguration = retrievalConfiguration
            self.retrievalQuery = retrievalQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.guardrailConfiguration, forKey: .guardrailConfiguration)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.retrievalConfiguration, forKey: .retrievalConfiguration)
            try container.encode(self.retrievalQuery, forKey: .retrievalQuery)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailConfiguration = "guardrailConfiguration"
            case nextToken = "nextToken"
            case retrievalConfiguration = "retrievalConfiguration"
            case retrievalQuery = "retrievalQuery"
        }
    }

    public struct RetrieveResponse: AWSDecodableShape {
        /// Specifies if there is a guardrail intervention in the response.
        public let guardrailAction: GuadrailAction?
        /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
        public let nextToken: String?
        /// A list of results from querying the knowledge base.
        public let retrievalResults: [KnowledgeBaseRetrievalResult]

        @inlinable
        public init(guardrailAction: GuadrailAction? = nil, nextToken: String? = nil, retrievalResults: [KnowledgeBaseRetrievalResult]) {
            self.guardrailAction = guardrailAction
            self.nextToken = nextToken
            self.retrievalResults = retrievalResults
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailAction = "guardrailAction"
            case nextToken = "nextToken"
            case retrievalResults = "retrievalResults"
        }
    }

    public struct RetrievedReference: AWSDecodableShape {
        /// Contains the cited text from the data source.
        public let content: RetrievalResultContent?
        /// Contains information about the location of the data source.
        public let location: RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see Metadata and filtering.
        public let metadata: [String: AWSDocument]?

        @inlinable
        public init(content: RetrievalResultContent? = nil, location: RetrievalResultLocation? = nil, metadata: [String: AWSDocument]? = nil) {
            self.content = content
            self.location = location
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case metadata = "metadata"
        }
    }

    public struct ReturnControlPayload: AWSDecodableShape {
        /// The identifier of the action group invocation.
        public let invocationId: String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent determines from its session with the user.
        public let invocationInputs: [InvocationInputMember]?

        @inlinable
        public init(invocationId: String? = nil, invocationInputs: [InvocationInputMember]? = nil) {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }

        private enum CodingKeys: String, CodingKey {
            case invocationId = "invocationId"
            case invocationInputs = "invocationInputs"
        }
    }

    public struct ReturnControlResults: AWSDecodableShape {
        /// The action's invocation ID.
        public let invocationId: String?
        /// The action invocation result.
        public let returnControlInvocationResults: [InvocationResultMember]?

        @inlinable
        public init(invocationId: String? = nil, returnControlInvocationResults: [InvocationResultMember]? = nil) {
            self.invocationId = invocationId
            self.returnControlInvocationResults = returnControlInvocationResults
        }

        private enum CodingKeys: String, CodingKey {
            case invocationId = "invocationId"
            case returnControlInvocationResults = "returnControlInvocationResults"
        }
    }

    public struct RoutingClassifierModelInvocationOutput: AWSDecodableShape {
        /// The invocation's metadata.
        public let metadata: Metadata?
        /// The invocation's raw response.
        public let rawResponse: RawResponse?
        /// The invocation's trace ID.
        public let traceId: String?

        @inlinable
        public init(metadata: Metadata? = nil, rawResponse: RawResponse? = nil, traceId: String? = nil) {
            self.metadata = metadata
            self.rawResponse = rawResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case rawResponse = "rawResponse"
            case traceId = "traceId"
        }
    }

    public struct S3Identifier: AWSEncodableShape {
        ///  The name of the S3 bucket.
        public let s3BucketName: String?
        ///  The S3 object key for the S3 resource.
        public let s3ObjectKey: String?

        @inlinable
        public init(s3BucketName: String? = nil, s3ObjectKey: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, max: 1024)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, min: 1)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3ObjectKey = "s3ObjectKey"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The path to the Amazon S3 bucket where the image is stored.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct S3ObjectDoc: AWSEncodableShape {
        /// The file location of the S3 wrapper object.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct S3ObjectFile: AWSEncodableShape {
        /// The uri of the s3 object.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct ServiceQuotaExceededException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SessionState: AWSEncodableShape {
        /// The state's conversation history.
        public let conversationHistory: ConversationHistory?
        /// Contains information about the files used by code interpreter.
        public let files: [InputFile]?
        /// The identifier of the invocation of an action. This value must match the invocationId returned in the InvokeAgent response for the action whose results are provided in the returnControlInvocationResults field. For more information, see Return control to the agent developer and Control session context.
        public let invocationId: String?
        /// An array of configurations, each of which applies to a knowledge base attached to the agent.
        public let knowledgeBaseConfigurations: [KnowledgeBaseConfiguration]?
        /// Contains attributes that persist across a prompt and the values of those attributes. These attributes replace the $prompt_session_attributes$ placeholder variable in the orchestration prompt template. For more information, see Prompt template placeholder variables.
        public let promptSessionAttributes: [String: String]?
        /// Contains information about the results from the action group invocation. For more information, see Return control to the agent developer and Control session context.  If you include this field, the inputText field will be ignored.
        public let returnControlInvocationResults: [InvocationResultMember]?
        /// Contains attributes that persist across a session and the values of those attributes.
        public let sessionAttributes: [String: String]?

        @inlinable
        public init(conversationHistory: ConversationHistory? = nil, files: [InputFile]? = nil, invocationId: String? = nil, knowledgeBaseConfigurations: [KnowledgeBaseConfiguration]? = nil, promptSessionAttributes: [String: String]? = nil, returnControlInvocationResults: [InvocationResultMember]? = nil, sessionAttributes: [String: String]? = nil) {
            self.conversationHistory = conversationHistory
            self.files = files
            self.invocationId = invocationId
            self.knowledgeBaseConfigurations = knowledgeBaseConfigurations
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }

        public func validate(name: String) throws {
            try self.files?.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.knowledgeBaseConfigurations?.forEach {
                try $0.validate(name: "\(name).knowledgeBaseConfigurations[]")
            }
            try self.validate(self.knowledgeBaseConfigurations, name: "knowledgeBaseConfigurations", parent: name, min: 1)
            try self.validate(self.returnControlInvocationResults, name: "returnControlInvocationResults", parent: name, max: 5)
            try self.validate(self.returnControlInvocationResults, name: "returnControlInvocationResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conversationHistory = "conversationHistory"
            case files = "files"
            case invocationId = "invocationId"
            case knowledgeBaseConfigurations = "knowledgeBaseConfigurations"
            case promptSessionAttributes = "promptSessionAttributes"
            case returnControlInvocationResults = "returnControlInvocationResults"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The timestamp for when the session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp for when the session was last modified.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The unique identifier for the session.
        public let sessionId: String
        /// The current status of the session.
        public let sessionStatus: SessionStatus

        @inlinable
        public init(createdAt: Date, lastUpdatedAt: Date, sessionArn: String, sessionId: String, sessionStatus: SessionStatus) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionStatus = sessionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionStatus = "sessionStatus"
        }
    }

    public struct Span: AWSDecodableShape {
        /// Where the text with a citation ends in the generated output.
        public let end: Int?
        /// Where the text with a citation starts in the generated output.
        public let start: Int?

        @inlinable
        public init(end: Int? = nil, start: Int? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct StreamingConfigurations: AWSEncodableShape {
        ///  The guardrail interval to apply as response is generated.
        public let applyGuardrailInterval: Int?
        ///  Specifies whether to enable streaming for the final response. This is set to false by default.
        public let streamFinalResponse: Bool?

        @inlinable
        public init(applyGuardrailInterval: Int? = nil, streamFinalResponse: Bool? = nil) {
            self.applyGuardrailInterval = applyGuardrailInterval
            self.streamFinalResponse = streamFinalResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applyGuardrailInterval = "applyGuardrailInterval"
            case streamFinalResponse = "streamFinalResponse"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceArn: String
        /// An object containing key-value pairs that define the tags to attach to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws(-[^:]+)?:bedrock:[a-zA-Z0-9-]+:[0-9]{12}:(session)/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$)")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextInferenceConfig: AWSEncodableShape {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0 or the maximum of 65536. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public let maxTokens: Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public let stopSequences: [String]?
        ///  Controls the random-ness of text generated by the language model, influencing how much the model sticks to the most predictable next words versus exploring more surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes the outputs more creative or unpredictable.
        public let temperature: Float?
        ///  A probability distribution threshold which controls what the model considers for the set of possible next tokens. The model will only consider the top p% of the probability distribution when generating the next token.
        public let topP: Float?

        @inlinable
        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, max: 65536)
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topP = "topP"
        }
    }

    public struct TextPrompt: AWSEncodableShape & AWSDecodableShape {
        /// The text in the text prompt to optimize.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct TextResponsePart: AWSDecodableShape {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public let span: Span?
        /// The part of the generated text that contains a citation.
        public let text: String?

        @inlinable
        public init(span: Span? = nil, text: String? = nil) {
            self.span = span
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case span = "span"
            case text = "text"
        }
    }

    public struct TextToSqlConfiguration: AWSEncodableShape {
        /// Specifies configurations for a knowledge base to use in transformation.
        public let knowledgeBaseConfiguration: TextToSqlKnowledgeBaseConfiguration?
        /// The type of resource to use in transformation.
        public let type: TextToSqlConfigurationType

        @inlinable
        public init(knowledgeBaseConfiguration: TextToSqlKnowledgeBaseConfiguration? = nil, type: TextToSqlConfigurationType) {
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.knowledgeBaseConfiguration?.validate(name: "\(name).knowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case type = "type"
        }
    }

    public struct TextToSqlKnowledgeBaseConfiguration: AWSEncodableShape {
        /// The ARN of the knowledge base
        public let knowledgeBaseArn: String

        @inlinable
        public init(knowledgeBaseArn: String) {
            self.knowledgeBaseArn = knowledgeBaseArn
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, max: 128)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):bedrock:[a-zA-Z0-9-]*:[0-9]{12}:knowledge-base/[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TracePart: AWSDecodableShape {
        /// The unique identifier of the alias of the agent.
        public let agentAliasId: String?
        /// The unique identifier of the agent.
        public let agentId: String?
        /// The version of the agent.
        public let agentVersion: String?
        /// The part's caller chain.
        public let callerChain: [Caller]?
        /// The part's collaborator name.
        public let collaboratorName: String?
        /// The unique identifier of the session with the agent.
        public let sessionId: String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see Trace enablement.
        public let trace: Trace?

        @inlinable
        public init(agentAliasId: String? = nil, agentId: String? = nil, agentVersion: String? = nil, callerChain: [Caller]? = nil, collaboratorName: String? = nil, sessionId: String? = nil, trace: Trace? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.callerChain = callerChain
            self.collaboratorName = collaboratorName
            self.sessionId = sessionId
            self.trace = trace
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case callerChain = "callerChain"
            case collaboratorName = "collaboratorName"
            case sessionId = "sessionId"
            case trace = "trace"
        }
    }

    public struct TransformationConfiguration: AWSEncodableShape {
        /// The mode of the transformation.
        public let mode: QueryTransformationMode
        /// Specifies configurations for transforming text to SQL.
        public let textToSqlConfiguration: TextToSqlConfiguration?

        @inlinable
        public init(mode: QueryTransformationMode, textToSqlConfiguration: TextToSqlConfiguration? = nil) {
            self.mode = mode
            self.textToSqlConfiguration = textToSqlConfiguration
        }

        public func validate(name: String) throws {
            try self.textToSqlConfiguration?.validate(name: "\(name).textToSqlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "mode"
            case textToSqlConfiguration = "textToSqlConfiguration"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
        public let resourceArn: String
        /// A list of keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "(^arn:aws(-[^:]+)?:bedrock:[a-zA-Z0-9-]+:[0-9]{12}:(session)/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$)")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSessionRequest: AWSEncodableShape {
        /// The unique identifier of the session to modify. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
        public let sessionIdentifier: String
        /// A map of key-value pairs containing attributes to be persisted across the session. For example the user's ID, their language preference,  and the type of device they are using.
        public let sessionMetadata: [String: String]?

        @inlinable
        public init(sessionIdentifier: String, sessionMetadata: [String: String]? = nil) {
            self.sessionIdentifier = sessionIdentifier
            self.sessionMetadata = sessionMetadata
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionIdentifier, key: "sessionIdentifier")
            try container.encodeIfPresent(self.sessionMetadata, forKey: .sessionMetadata)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionIdentifier, name: "sessionIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]+:[0-9]{12}:session/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$")
            try self.sessionMetadata?.forEach {
                try validate($0.key, name: "sessionMetadata.key", parent: name, max: 100)
                try validate($0.key, name: "sessionMetadata.key", parent: name, min: 1)
                try validate($0.value, name: "sessionMetadata[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.sessionMetadata, name: "sessionMetadata", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case sessionMetadata = "sessionMetadata"
        }
    }

    public struct UpdateSessionResponse: AWSDecodableShape {
        /// The timestamp for when the session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp for when the session was last modified.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the session that was updated.
        public let sessionArn: String
        /// The unique identifier of the session you updated.
        public let sessionId: String
        /// The status of the session you updated.
        public let sessionStatus: SessionStatus

        @inlinable
        public init(createdAt: Date, lastUpdatedAt: Date, sessionArn: String, sessionId: String, sessionStatus: SessionStatus) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionStatus = sessionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionStatus = "sessionStatus"
        }
    }

    public struct Usage: AWSDecodableShape {
        /// Contains information about the input tokens from the foundation model usage.
        public let inputTokens: Int?
        /// Contains information about the output tokens from the foundation model usage.
        public let outputTokens: Int?

        @inlinable
        public init(inputTokens: Int? = nil, outputTokens: Int? = nil) {
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
        }

        private enum CodingKeys: String, CodingKey {
            case inputTokens = "inputTokens"
            case outputTokens = "outputTokens"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct VectorSearchBedrockRerankingConfiguration: AWSEncodableShape {
        /// Contains configurations for the metadata to use in reranking.
        public let metadataConfiguration: MetadataConfigurationForReranking?
        /// Contains configurations for the reranker model.
        public let modelConfiguration: VectorSearchBedrockRerankingModelConfiguration
        /// The number of results to return after reranking.
        public let numberOfRerankedResults: Int?

        @inlinable
        public init(metadataConfiguration: MetadataConfigurationForReranking? = nil, modelConfiguration: VectorSearchBedrockRerankingModelConfiguration, numberOfRerankedResults: Int? = nil) {
            self.metadataConfiguration = metadataConfiguration
            self.modelConfiguration = modelConfiguration
            self.numberOfRerankedResults = numberOfRerankedResults
        }

        public func validate(name: String) throws {
            try self.metadataConfiguration?.validate(name: "\(name).metadataConfiguration")
            try self.modelConfiguration.validate(name: "\(name).modelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataConfiguration = "metadataConfiguration"
            case modelConfiguration = "modelConfiguration"
            case numberOfRerankedResults = "numberOfRerankedResults"
        }
    }

    public struct VectorSearchBedrockRerankingModelConfiguration: AWSEncodableShape {
        /// A JSON object whose keys are request fields for the model and whose values are values for those fields.
        public let additionalModelRequestFields: [String: AWSDocument]?
        /// The ARN of the reranker model to use.
        public let modelArn: String

        @inlinable
        public init(additionalModelRequestFields: [String: AWSDocument]? = nil, modelArn: String) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.modelArn = modelArn
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/(.*))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case modelArn = "modelArn"
        }
    }

    public struct VectorSearchRerankingConfiguration: AWSEncodableShape {
        /// Contains configurations for an Amazon Bedrock reranker model.
        public let bedrockRerankingConfiguration: VectorSearchBedrockRerankingConfiguration?
        /// The type of reranker model.
        public let type: VectorSearchRerankingConfigurationType

        @inlinable
        public init(bedrockRerankingConfiguration: VectorSearchBedrockRerankingConfiguration? = nil, type: VectorSearchRerankingConfigurationType) {
            self.bedrockRerankingConfiguration = bedrockRerankingConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.bedrockRerankingConfiguration?.validate(name: "\(name).bedrockRerankingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockRerankingConfiguration = "bedrockRerankingConfiguration"
            case type = "type"
        }
    }

    public struct Caller: AWSDecodableShape {
        /// The caller's agent alias ARN.
        public let agentAliasArn: String?

        @inlinable
        public init(agentAliasArn: String? = nil) {
            self.agentAliasArn = agentAliasArn
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasArn = "agentAliasArn"
        }
    }

    public struct ContentBlock: AWSEncodableShape {
        /// The block's text.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct FlowInputContent: AWSEncodableShape {
        /// The input to send to the prompt flow input node.
        public let document: AWSDocument?

        @inlinable
        public init(document: AWSDocument? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct FlowMultiTurnInputContent: AWSDecodableShape {
        /// The requested additional input to send back to the multi-turn flow node.
        public let document: AWSDocument?

        @inlinable
        public init(document: AWSDocument? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct FlowOutputContent: AWSDecodableShape {
        /// The content in the output.
        public let document: AWSDocument?

        @inlinable
        public init(document: AWSDocument? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct FlowTraceNodeInputContent: AWSDecodableShape {
        /// The content of the node input.
        public let document: AWSDocument?

        @inlinable
        public init(document: AWSDocument? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct FlowTraceNodeOutputContent: AWSDecodableShape {
        /// The content of the node output.
        public let document: AWSDocument?

        @inlinable
        public init(document: AWSDocument? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct FunctionSchema: AWSEncodableShape {
        ///  A list of functions that each define an action in the action group.
        public let functions: [FunctionDefinition]?

        @inlinable
        public init(functions: [FunctionDefinition]? = nil) {
            self.functions = functions
        }

        public func validate(name: String) throws {
            try self.functions?.forEach {
                try $0.validate(name: "\(name).functions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
        }
    }

    public struct InputPrompt: AWSEncodableShape {
        /// Contains information about the text prompt to optimize.
        public let textPrompt: TextPrompt?

        @inlinable
        public init(textPrompt: TextPrompt? = nil) {
            self.textPrompt = textPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case textPrompt = "textPrompt"
        }
    }

    public struct InvocationStepPayload: AWSEncodableShape & AWSDecodableShape {
        /// The content for the invocation step.
        public let contentBlocks: [BedrockSessionContentBlock]?

        @inlinable
        public init(contentBlocks: [BedrockSessionContentBlock]? = nil) {
            self.contentBlocks = contentBlocks
        }

        public func validate(name: String) throws {
            try self.contentBlocks?.forEach {
                try $0.validate(name: "\(name).contentBlocks[]")
            }
            try self.validate(self.contentBlocks, name: "contentBlocks", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlocks = "contentBlocks"
        }
    }

    public struct Memory: AWSDecodableShape {
        /// Contains summary of a session.
        public let sessionSummary: MemorySessionSummary?

        @inlinable
        public init(sessionSummary: MemorySessionSummary? = nil) {
            self.sessionSummary = sessionSummary
        }

        private enum CodingKeys: String, CodingKey {
            case sessionSummary = "sessionSummary"
        }
    }

    public struct OptimizedPrompt: AWSDecodableShape {
        /// Contains information about the text in the prompt that was optimized.
        public let textPrompt: TextPrompt?

        @inlinable
        public init(textPrompt: TextPrompt? = nil) {
            self.textPrompt = textPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case textPrompt = "textPrompt"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentRuntime
public struct BedrockAgentRuntimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case internalServerException = "InternalServerException"
        case modelNotReadyException = "ModelNotReadyException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentRuntime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions. Check your permissions and retry your request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was an issue with a dependency due to a server issue. Retry your request.
    public static var badGatewayException: Self { .init(.badGatewayException) }
    /// There was a conflict performing an operation. Resolve the conflict and retry your request.
    public static var conflictException: Self { .init(.conflictException) }
    /// There was an issue with a dependency. Check the resource configurations and retry the request.
    public static var dependencyFailedException: Self { .init(.dependencyFailedException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The model specified in the request is not ready to serve inference requests. The AWS SDK will automatically retry the operation up to 5 times. For information about configuring automatic retries, see Retry behavior in the AWS SDKs and Tools reference guide.
    public static var modelNotReadyException: Self { .init(.modelNotReadyException) }
    /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentRuntimeErrorType: Equatable {
    public static func == (lhs: BedrockAgentRuntimeErrorType, rhs: BedrockAgentRuntimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentRuntimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
