//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentRuntime {
    // MARK: Enums

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lambda = "LAMBDA"
        case returnControl = "RETURN_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum ExternalSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byteContent = "BYTE_CONTENT"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum FileSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byteContent = "BYTE_CONTENT"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum FileUseCase: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chat = "CHAT"
        case codeInterpreter = "CODE_INTERPRETER"
        public var description: String { return self.rawValue }
    }

    public enum FlowCompletionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum GuadrailAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intervened = "INTERVENED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intervened = "INTERVENED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterConfidence: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hate = "HATE"
        case insults = "INSULTS"
        case misconduct = "MISCONDUCT"
        case promptAttack = "PROMPT_ATTACK"
        case sexual = "SEXUAL"
        case violence = "VIOLENCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailManagedWordType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case profanity = "PROFANITY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailPiiEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case age = "AGE"
        case awsAccessKey = "AWS_ACCESS_KEY"
        case awsSecretKey = "AWS_SECRET_KEY"
        case caHealthNumber = "CA_HEALTH_NUMBER"
        case caSocialInsuranceNumber = "CA_SOCIAL_INSURANCE_NUMBER"
        case creditDebitCardCvv = "CREDIT_DEBIT_CARD_CVV"
        case creditDebitCardExpiry = "CREDIT_DEBIT_CARD_EXPIRY"
        case creditDebitCardNumber = "CREDIT_DEBIT_CARD_NUMBER"
        case driverId = "DRIVER_ID"
        case email = "EMAIL"
        case internationalBankAccountNumber = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
        case ipAddress = "IP_ADDRESS"
        case licensePlate = "LICENSE_PLATE"
        case macAddress = "MAC_ADDRESS"
        case name = "NAME"
        case password = "PASSWORD"
        case phone = "PHONE"
        case pin = "PIN"
        case swiftCode = "SWIFT_CODE"
        case ukNationalHealthServiceNumber = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
        case ukNationalInsuranceNumber = "UK_NATIONAL_INSURANCE_NUMBER"
        case ukUniqueTaxpayerReferenceNumber = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
        case url = "URL"
        case usBankAccountNumber = "US_BANK_ACCOUNT_NUMBER"
        case usBankRoutingNumber = "US_BANK_ROUTING_NUMBER"
        case usIndividualTaxIdentificationNumber = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
        case usPassportNumber = "US_PASSPORT_NUMBER"
        case usSocialSecurityNumber = "US_SOCIAL_SECURITY_NUMBER"
        case username = "USERNAME"
        case vehicleIdentificationNumber = "VEHICLE_IDENTIFICATION_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailSensitiveInformationPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymized = "ANONYMIZED"
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailWordPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case actionGroupCodeInterpreter = "ACTION_GROUP_CODE_INTERPRETER"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum MemoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sessionSummary = "SESSION_SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditionNode = "ConditionNode"
        case flowInputNode = "FlowInputNode"
        case flowOutputNode = "FlowOutputNode"
        case knowledgeBaseNode = "KnowledgeBaseNode"
        case lambdaFunctionNode = "LambdaFunctionNode"
        case lexNode = "LexNode"
        case promptNode = "PromptNode"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransformationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queryDecomposition = "QUERY_DECOMPOSITION"
        public var description: String { return self.rawValue }
    }

    public enum ResponseState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "FAILURE"
        case reprompt = "REPROMPT"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalResultLocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case confluence = "CONFLUENCE"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case sharepoint = "SHAREPOINT"
        case web = "WEB"
        public var description: String { return self.rawValue }
    }

    public enum RetrieveAndGenerateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalSources = "EXTERNAL_SOURCES"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "HYBRID"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case parser = "PARSER"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case askUser = "ASK_USER"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case reprompt = "REPROMPT"
        public var description: String { return self.rawValue }
    }

    public enum FlowResponseStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// There was a conflict performing an operation. Resolve the conflict and retry your request.
        case conflictException(ConflictException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// Contains information about why the flow completed.
        case flowCompletionEvent(FlowCompletionEvent)
        /// Contains information about an output from flow invocation.
        case flowOutputEvent(FlowOutputEvent)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
        case resourceNotFoundException(ResourceNotFoundException)
        /// The number of requests exceeds the service quota. Resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// The number of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .flowCompletionEvent:
                let value = try container.decode(FlowCompletionEvent.self, forKey: .flowCompletionEvent)
                self = .flowCompletionEvent(value)
            case .flowOutputEvent:
                let value = try container.decode(FlowOutputEvent.self, forKey: .flowOutputEvent)
                self = .flowOutputEvent(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case flowCompletionEvent = "flowCompletionEvent"
            case flowOutputEvent = "flowOutputEvent"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum InvocationInputMember: AWSDecodableShape, Sendable {
        /// Contains information about the API operation that the agent predicts should be called.
        case apiInvocationInput(ApiInvocationInput)
        /// Contains information about the function that the agent predicts should be called.
        case functionInvocationInput(FunctionInvocationInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiInvocationInput:
                let value = try container.decode(ApiInvocationInput.self, forKey: .apiInvocationInput)
                self = .apiInvocationInput(value)
            case .functionInvocationInput:
                let value = try container.decode(FunctionInvocationInput.self, forKey: .functionInvocationInput)
                self = .functionInvocationInput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiInvocationInput = "apiInvocationInput"
            case functionInvocationInput = "functionInvocationInput"
        }
    }

    public enum InvocationResultMember: AWSEncodableShape, Sendable {
        /// The result from the API response from the action group invocation.
        case apiResult(ApiResult)
        /// The result from the function from the action group invocation.
        case functionResult(FunctionResult)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiResult(let value):
                try container.encode(value, forKey: .apiResult)
            case .functionResult(let value):
                try container.encode(value, forKey: .functionResult)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiResult = "apiResult"
            case functionResult = "functionResult"
        }
    }

    public enum OrchestrationTrace: AWSDecodableShape, Sendable {
        /// Contains information pertaining to the action group or knowledge base that is being invoked.
        case invocationInput(InvocationInput)
        /// The input for the orchestration step.   The type is ORCHESTRATION.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// Details about the observation (the output of the action group Lambda or knowledge base) made by the agent.
        case observation(Observation)
        /// Details about the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
        case rationale(Rationale)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .invocationInput:
                let value = try container.decode(InvocationInput.self, forKey: .invocationInput)
                self = .invocationInput(value)
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .observation:
                let value = try container.decode(Observation.self, forKey: .observation)
                self = .observation(value)
            case .rationale:
                let value = try container.decode(Rationale.self, forKey: .rationale)
                self = .rationale(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invocationInput = "invocationInput"
            case modelInvocationInput = "modelInvocationInput"
            case observation = "observation"
            case rationale = "rationale"
        }
    }

    public enum PostProcessingTrace: AWSDecodableShape, Sendable {
        /// The input for the post-processing step.   The type is POST_PROCESSING.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// The foundation model output from the post-processing step.
        case modelInvocationOutput(PostProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PostProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum PreProcessingTrace: AWSDecodableShape, Sendable {
        /// The input for the pre-processing step.   The type is PRE_PROCESSING.   The text contains the prompt.   The inferenceConfiguration, parserMode, and overrideLambda values are set in the PromptOverrideConfiguration object that was set when the agent was created or updated.
        case modelInvocationInput(ModelInvocationInput)
        /// The foundation model output from the pre-processing step.
        case modelInvocationOutput(PreProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PreProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        /// The request is denied because of missing access permissions. Check your permissions and retry your request.
        case accessDeniedException(AccessDeniedException)
        /// There was an issue with a dependency due to a server issue. Retry your request.
        case badGatewayException(BadGatewayException)
        /// Contains a part of an agent response and citations for it.
        case chunk(PayloadPart)
        /// There was a conflict performing an operation. Resolve the conflict and retry your request.
        case conflictException(ConflictException)
        /// There was an issue with a dependency. Check the resource configurations and retry the request.
        case dependencyFailedException(DependencyFailedException)
        /// Contains intermediate response for code interpreter if any files have been generated.
        case files(FilePart)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
        case resourceNotFoundException(ResourceNotFoundException)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system and can be used in your own setup for fulfilling the action.
        case returnControl(ReturnControlPayload)
        /// The number of requests exceeds the service quota. Resubmit your request later.
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        /// The number of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see Trace events.
        case trace(TracePart)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .chunk:
                let value = try container.decode(PayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .files:
                let value = try container.decode(FilePart.self, forKey: .files)
                self = .files(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .returnControl:
                let value = try container.decode(ReturnControlPayload.self, forKey: .returnControl)
                self = .returnControl(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .trace:
                let value = try container.decode(TracePart.self, forKey: .trace)
                self = .trace(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case chunk = "chunk"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case files = "files"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case returnControl = "returnControl"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case trace = "trace"
            case validationException = "validationException"
        }
    }

    public enum RetrievalFilter: AWSEncodableShape, Sendable {
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the filter conditions inside this list.
        case andAll([RetrievalFilter])
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is cat:  "equals": { "key": "animal", "value": "cat" }
        case equals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is greater than 1989:  "greaterThan": { "key": "year", "value": 1989 }
        case greaterThan(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is greater than or equal to 1989:  "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterThanOrEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either cat or dog:  "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to 1989.  "lessThan": { "key": "year", "value": 1989 }
        case lessThan(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal to 1989.  "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessThanOrEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat member (for example ["dog", "cat"]).  "listContains": { "key": "animals", "value": "cat" }
        case listContains(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned. The following example would return data sources that don't contain an animal attribute whose value is cat.  "notEquals": { "key": "animal", "value": "cat" }
        case notEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither cat nor dog.  "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notIn(FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter conditions inside this list.
        case orAll([RetrievalFilter])
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value starts with the value in this object. This filter is currently only supported for Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with ca (for example, cat or camel).  "startsWith": { "key": "animal", "value": "ca" }
        case startsWith(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is one of the following:   A string that contains the value as a substring. The following example would return data sources with an animal attribute that contains the substring at (for example cat).  "stringContains": { "key": "animal", "value": "at" }    A list with a member that contains the value as a substring. The following example would return data sources with an animals attribute that is a list containing a member that contains the substring at (for example ["dog", "cat"]).  "stringContains": { "key": "animals", "value": "at" }
        case stringContains(FilterAttribute)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .equals(let value):
                try container.encode(value, forKey: .equals)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEquals(let value):
                try container.encode(value, forKey: .greaterThanOrEquals)
            case .`in`(let value):
                try container.encode(value, forKey: .`in`)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEquals(let value):
                try container.encode(value, forKey: .lessThanOrEquals)
            case .listContains(let value):
                try container.encode(value, forKey: .listContains)
            case .notEquals(let value):
                try container.encode(value, forKey: .notEquals)
            case .notIn(let value):
                try container.encode(value, forKey: .notIn)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            case .startsWith(let value):
                try container.encode(value, forKey: .startsWith)
            case .stringContains(let value):
                try container.encode(value, forKey: .stringContains)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
                try self.validate(value, name: "andAll", parent: name, max: 5)
                try self.validate(value, name: "andAll", parent: name, min: 2)
            case .equals(let value):
                try value.validate(name: "\(name).equals")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEquals(let value):
                try value.validate(name: "\(name).greaterThanOrEquals")
            case .`in`(let value):
                try value.validate(name: "\(name).`in`")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEquals(let value):
                try value.validate(name: "\(name).lessThanOrEquals")
            case .listContains(let value):
                try value.validate(name: "\(name).listContains")
            case .notEquals(let value):
                try value.validate(name: "\(name).notEquals")
            case .notIn(let value):
                try value.validate(name: "\(name).notIn")
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
                try self.validate(value, name: "orAll", parent: name, max: 5)
                try self.validate(value, name: "orAll", parent: name, min: 2)
            case .startsWith(let value):
                try value.validate(name: "\(name).startsWith")
            case .stringContains(let value):
                try value.validate(name: "\(name).stringContains")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case equals = "equals"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case `in` = "in"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case listContains = "listContains"
            case notEquals = "notEquals"
            case notIn = "notIn"
            case orAll = "orAll"
            case startsWith = "startsWith"
            case stringContains = "stringContains"
        }
    }

    public enum Trace: AWSDecodableShape, Sendable {
        /// Contains information about the failure of the interaction.
        case failureTrace(FailureTrace)
        /// The trace details for a trace defined in the Guardrail filter.
        case guardrailTrace(GuardrailTrace)
        /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
        case orchestrationTrace(OrchestrationTrace)
        /// Details about the post-processing step, in which the agent shapes the response..
        case postProcessingTrace(PostProcessingTrace)
        /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
        case preProcessingTrace(PreProcessingTrace)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .failureTrace:
                let value = try container.decode(FailureTrace.self, forKey: .failureTrace)
                self = .failureTrace(value)
            case .guardrailTrace:
                let value = try container.decode(GuardrailTrace.self, forKey: .guardrailTrace)
                self = .guardrailTrace(value)
            case .orchestrationTrace:
                let value = try container.decode(OrchestrationTrace.self, forKey: .orchestrationTrace)
                self = .orchestrationTrace(value)
            case .postProcessingTrace:
                let value = try container.decode(PostProcessingTrace.self, forKey: .postProcessingTrace)
                self = .postProcessingTrace(value)
            case .preProcessingTrace:
                let value = try container.decode(PreProcessingTrace.self, forKey: .preProcessingTrace)
                self = .preProcessingTrace(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case failureTrace = "failureTrace"
            case guardrailTrace = "guardrailTrace"
            case orchestrationTrace = "orchestrationTrace"
            case postProcessingTrace = "postProcessingTrace"
            case preProcessingTrace = "preProcessingTrace"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActionGroupInvocationInput: AWSDecodableShape {
        /// The name of the action group.
        public let actionGroupName: String?
        /// The path to the API to call, based off the action group.
        public let apiPath: String?
        /// How fulfillment of the action is handled. For more information, see Handling fulfillment of the action.
        public let executionType: ExecutionType?
        /// The function in the action group to call.
        public let function: String?
        /// The unique identifier of the invocation. Only returned if the executionType is RETURN_CONTROL.
        public let invocationId: String?
        /// The parameters in the Lambda input event.
        public let parameters: [Parameter]?
        /// The parameters in the request body for the Lambda input event.
        public let requestBody: RequestBody?
        /// The API method being used, based off the action group.
        public let verb: String?

        public init(actionGroupName: String? = nil, apiPath: String? = nil, executionType: ExecutionType? = nil, function: String? = nil, invocationId: String? = nil, parameters: [Parameter]? = nil, requestBody: RequestBody? = nil, verb: String? = nil) {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.executionType = executionType
            self.function = function
            self.invocationId = invocationId
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupName = "actionGroupName"
            case apiPath = "apiPath"
            case executionType = "executionType"
            case function = "function"
            case invocationId = "invocationId"
            case parameters = "parameters"
            case requestBody = "requestBody"
            case verb = "verb"
        }
    }

    public struct ActionGroupInvocationOutput: AWSDecodableShape {
        /// The JSON-formatted string returned by the API invoked by the action group.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct ApiInvocationInput: AWSDecodableShape {
        /// The action group that the API operation belongs to.
        public let actionGroup: String
        /// The path to the API operation.
        public let apiPath: String?
        /// The HTTP method of the API operation.
        public let httpMethod: String?
        /// The parameters to provide for the API request, as the agent elicited from the user.
        public let parameters: [ApiParameter]?
        /// The request body to provide for the API request, as the agent elicited from the user.
        public let requestBody: ApiRequestBody?

        public init(actionGroup: String, apiPath: String? = nil, httpMethod: String? = nil, parameters: [ApiParameter]? = nil, requestBody: ApiRequestBody? = nil) {
            self.actionGroup = actionGroup
            self.apiPath = apiPath
            self.httpMethod = httpMethod
            self.parameters = parameters
            self.requestBody = requestBody
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case apiPath = "apiPath"
            case httpMethod = "httpMethod"
            case parameters = "parameters"
            case requestBody = "requestBody"
        }
    }

    public struct ApiParameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The data type for the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct ApiRequestBody: AWSDecodableShape {
        /// The content of the request body. The key of the object in this field is a media type defining the format of the request body.
        public let content: [String: PropertyParameters]?

        public init(content: [String: PropertyParameters]? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct ApiResult: AWSEncodableShape {
        /// The action group that the API operation belongs to.
        public let actionGroup: String
        /// The path to the API operation.
        public let apiPath: String?
        /// The HTTP method for the API operation.
        public let httpMethod: String?
        /// http status code from API execution response (for example: 200, 400, 500).
        public let httpStatusCode: Int?
        /// The response body from the API operation. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public let responseBody: [String: ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public let responseState: ResponseState?

        public init(actionGroup: String, apiPath: String? = nil, httpMethod: String? = nil, httpStatusCode: Int? = nil, responseBody: [String: ContentBody]? = nil, responseState: ResponseState? = nil) {
            self.actionGroup = actionGroup
            self.apiPath = apiPath
            self.httpMethod = httpMethod
            self.httpStatusCode = httpStatusCode
            self.responseBody = responseBody
            self.responseState = responseState
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case apiPath = "apiPath"
            case httpMethod = "httpMethod"
            case httpStatusCode = "httpStatusCode"
            case responseBody = "responseBody"
            case responseState = "responseState"
        }
    }

    public struct Attribution: AWSDecodableShape {
        /// A list of citations and related information for a part of an agent response.
        public let citations: [Citation]?

        public init(citations: [Citation]? = nil) {
            self.citations = citations
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
        }
    }

    public struct BadGatewayException: AWSDecodableShape {
        public let message: String?
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public let resourceName: String?

        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ByteContentDoc: AWSEncodableShape {
        /// The MIME type of the document contained in the wrapper object.
        public let contentType: String
        /// The byte value of the file to upload, encoded as a Base-64 string.
        public let data: AWSBase64Data
        /// The file name of the document contained in the wrapper object.
        public let identifier: String

        public init(contentType: String, data: AWSBase64Data, identifier: String) {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "[a-z]{1,20}/.{1,20}")
            try self.validate(self.data, name: "data", parent: name, max: 10485760)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case data = "data"
            case identifier = "identifier"
        }
    }

    public struct ByteContentFile: AWSEncodableShape {
        /// The byte value of the file to attach, encoded as Base-64 string. The maximum size of all files that is attached is 10MB. You can attach a maximum of 5 files.
        public let data: AWSBase64Data
        /// The MIME type of data contained in the file used for chat.
        public let mediaType: String

        public init(data: AWSBase64Data, mediaType: String) {
            self.data = data
            self.mediaType = mediaType
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 10485760)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case mediaType = "mediaType"
        }
    }

    public struct Citation: AWSDecodableShape {
        /// Contains the generated response and metadata
        public let generatedResponsePart: GeneratedResponsePart?
        /// Contains metadata about the sources cited for the generated response.
        public let retrievedReferences: [RetrievedReference]?

        public init(generatedResponsePart: GeneratedResponsePart? = nil, retrievedReferences: [RetrievedReference]? = nil) {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case generatedResponsePart = "generatedResponsePart"
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct CodeInterpreterInvocationInput: AWSDecodableShape {
        /// The code for the code interpreter to use.
        public let code: String?
        /// Files that are uploaded for code interpreter to use.
        public let files: [String]?

        public init(code: String? = nil, files: [String]? = nil) {
            self.code = code
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case files = "files"
        }
    }

    public struct CodeInterpreterInvocationOutput: AWSDecodableShape {
        /// Contains the error returned from code execution.
        public let executionError: String?
        /// Contains the successful output returned from code execution
        public let executionOutput: String?
        /// Indicates if the execution of the code timed out.
        public let executionTimeout: Bool?
        /// Contains output files, if generated by code execution.
        public let files: [String]?

        public init(executionError: String? = nil, executionOutput: String? = nil, executionTimeout: Bool? = nil, files: [String]? = nil) {
            self.executionError = executionError
            self.executionOutput = executionOutput
            self.executionTimeout = executionTimeout
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case executionError = "executionError"
            case executionOutput = "executionOutput"
            case executionTimeout = "executionTimeout"
            case files = "files"
        }
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ContentBody: AWSEncodableShape {
        /// The body of the API response.
        public let body: String?

        public init(body: String? = nil) {
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
        }
    }

    public struct DeleteAgentMemoryRequest: AWSEncodableShape {
        /// The unique identifier of an alias of an agent.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias belongs.
        public let agentId: String
        /// The unique identifier of the memory.
        public let memoryId: String?

        public init(agentAliasId: String, agentId: String, memoryId: String? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, max: 100)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 2)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentMemoryResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DependencyFailedException: AWSDecodableShape {
        public let message: String?
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public let resourceName: String?

        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ExternalSource: AWSEncodableShape {
        /// The identifier, contentType, and data of the external source wrapper object.
        public let byteContent: ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public let s3Location: S3ObjectDoc?
        /// The source type of the external source wrapper object.
        public let sourceType: ExternalSourceType

        public init(byteContent: ByteContentDoc? = nil, s3Location: S3ObjectDoc? = nil, sourceType: ExternalSourceType) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.byteContent?.validate(name: "\(name).byteContent")
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case s3Location = "s3Location"
            case sourceType = "sourceType"
        }
    }

    public struct ExternalSourcesGenerationConfiguration: AWSEncodableShape {
        ///  Additional model parameters and their corresponding values not included in the textInferenceConfig structure for an external source. Takes in custom model parameters specific to the language model being used.
        public let additionalModelRequestFields: [String: String]?
        /// The configuration details for the guardrail.
        public let guardrailConfiguration: GuardrailConfiguration?
        ///  Configuration settings for inference when using RetrieveAndGenerate to generate responses while using an external source.
        public let inferenceConfig: InferenceConfig?
        /// Contain the textPromptTemplate string for the external source wrapper object.
        public let promptTemplate: PromptTemplate?

        public init(additionalModelRequestFields: [String: String]? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, inferenceConfig: InferenceConfig? = nil, promptTemplate: PromptTemplate? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case guardrailConfiguration = "guardrailConfiguration"
            case inferenceConfig = "inferenceConfig"
            case promptTemplate = "promptTemplate"
        }
    }

    public struct ExternalSourcesRetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// The prompt used with the external source wrapper object with the retrieveAndGenerate function.
        public let generationConfiguration: ExternalSourcesGenerationConfiguration?
        /// The modelArn used with the external source wrapper object in the retrieveAndGenerate function.
        public let modelArn: String
        /// The document used with the external source wrapper object in the retrieveAndGenerate function.
        public let sources: [ExternalSource]

        public init(generationConfiguration: ExternalSourcesGenerationConfiguration? = nil, modelArn: String, sources: [ExternalSource]) {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 1011)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 20)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}))$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case modelArn = "modelArn"
            case sources = "sources"
        }
    }

    public struct FailureTrace: AWSDecodableShape {
        /// The reason the interaction failed.
        public let failureReason: String?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(failureReason: String? = nil, traceId: String? = nil) {
            self.failureReason = failureReason
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "failureReason"
            case traceId = "traceId"
        }
    }

    public struct FilePart: AWSDecodableShape {
        /// Files containing intermediate response for the user.
        public let files: [OutputFile]?

        public init(files: [OutputFile]? = nil) {
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
        }
    }

    public struct FileSource: AWSEncodableShape {
        /// The data and the text of the attached files.
        public let byteContent: ByteContentFile?
        /// The s3 location of the files to attach.
        public let s3Location: S3ObjectFile?
        /// The source type of the files to attach.
        public let sourceType: FileSourceType

        public init(byteContent: ByteContentFile? = nil, s3Location: S3ObjectFile? = nil, sourceType: FileSourceType) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.byteContent?.validate(name: "\(name).byteContent")
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case s3Location = "s3Location"
            case sourceType = "sourceType"
        }
    }

    public struct FilterAttribute: AWSEncodableShape {
        /// The name that the metadata attribute must match.
        public let key: String
        /// The value to whcih to compare the value of the metadata attribute.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 100)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct FinalResponse: AWSDecodableShape {
        /// The text in the response to the user.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct FlowCompletionEvent: AWSDecodableShape {
        /// The reason that the flow completed.
        public let completionReason: FlowCompletionReason

        public init(completionReason: FlowCompletionReason) {
            self.completionReason = completionReason
        }

        private enum CodingKeys: String, CodingKey {
            case completionReason = "completionReason"
        }
    }

    public struct FlowInput: AWSEncodableShape {
        /// Contains information about an input into the flow.
        public let content: FlowInputContent
        /// A name for the input of the flow input node.
        public let nodeName: String
        /// A name for the output of the flow input node.
        public let nodeOutputName: String

        public init(content: FlowInputContent, nodeName: String, nodeOutputName: String) {
            self.content = content
            self.nodeName = nodeName
            self.nodeOutputName = nodeOutputName
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeName, name: "nodeName", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){0,99}$")
            try self.validate(self.nodeOutputName, name: "nodeOutputName", parent: name, pattern: "^[a-zA-Z]([_]?[0-9a-zA-Z]){0,99}$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeName = "nodeName"
            case nodeOutputName = "nodeOutputName"
        }
    }

    public struct FlowOutputEvent: AWSDecodableShape {
        /// The output of the node.
        public let content: FlowOutputContent
        /// The name of the node to which input was provided.
        public let nodeName: String
        /// The type of node to which input was provided.
        public let nodeType: NodeType

        public init(content: FlowOutputContent, nodeName: String, nodeType: NodeType) {
            self.content = content
            self.nodeName = nodeName
            self.nodeType = nodeType
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case nodeName = "nodeName"
            case nodeType = "nodeType"
        }
    }

    public struct FunctionInvocationInput: AWSDecodableShape {
        /// The action group that the function belongs to.
        public let actionGroup: String
        /// The name of the function.
        public let function: String?
        /// A list of parameters of the function.
        public let parameters: [FunctionParameter]?

        public init(actionGroup: String, function: String? = nil, parameters: [FunctionParameter]? = nil) {
            self.actionGroup = actionGroup
            self.function = function
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case function = "function"
            case parameters = "parameters"
        }
    }

    public struct FunctionParameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The data type of the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct FunctionResult: AWSEncodableShape {
        /// The action group that the function belongs to.
        public let actionGroup: String
        /// The name of the function that was called.
        public let function: String?
        /// The response from the function call using the parameters. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public let responseBody: [String: ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public let responseState: ResponseState?

        public init(actionGroup: String, function: String? = nil, responseBody: [String: ContentBody]? = nil, responseState: ResponseState? = nil) {
            self.actionGroup = actionGroup
            self.function = function
            self.responseBody = responseBody
            self.responseState = responseState
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroup = "actionGroup"
            case function = "function"
            case responseBody = "responseBody"
            case responseState = "responseState"
        }
    }

    public struct GeneratedResponsePart: AWSDecodableShape {
        /// Contains metadata about a textual part of the generated response that is accompanied by a citation.
        public let textResponsePart: TextResponsePart?

        public init(textResponsePart: TextResponsePart? = nil) {
            self.textResponsePart = textResponsePart
        }

        private enum CodingKeys: String, CodingKey {
            case textResponsePart = "textResponsePart"
        }
    }

    public struct GenerationConfiguration: AWSEncodableShape {
        ///  Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows users to provide custom model parameters specific to the language model being used.
        public let additionalModelRequestFields: [String: String]?
        /// The configuration details for the guardrail.
        public let guardrailConfiguration: GuardrailConfiguration?
        ///  Configuration settings for inference when using RetrieveAndGenerate to generate responses while using a knowledge base as a source.
        public let inferenceConfig: InferenceConfig?
        /// Contains the template for the prompt that's sent to the model for response generation.
        public let promptTemplate: PromptTemplate?

        public init(additionalModelRequestFields: [String: String]? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, inferenceConfig: InferenceConfig? = nil, promptTemplate: PromptTemplate? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case guardrailConfiguration = "guardrailConfiguration"
            case inferenceConfig = "inferenceConfig"
            case promptTemplate = "promptTemplate"
        }
    }

    public struct GetAgentMemoryRequest: AWSEncodableShape {
        /// The unique identifier of an alias of an agent.
        public let agentAliasId: String
        /// The unique identifier of the agent to which the alias belongs.
        public let agentId: String
        /// The maximum number of items to return in the response. If the total number of results is greater  than this value, use the token returned in the response in the nextToken field when making another  request to return the next batch of results.
        public let maxItems: Int?
        /// The unique identifier of the memory.
        public let memoryId: String
        /// The type of memory.
        public let memoryType: MemoryType
        /// If the total number of results is greater than the maxItems value provided in the request, enter the token returned  in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        public init(agentAliasId: String, agentId: String, maxItems: Int? = nil, memoryId: String, memoryType: MemoryType, nextToken: String? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.maxItems = maxItems
            self.memoryId = memoryId
            self.memoryType = memoryType
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            request.encodeQuery(self.maxItems, key: "maxItems")
            request.encodeQuery(self.memoryId, key: "memoryId")
            request.encodeQuery(self.memoryType, key: "memoryType")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 1000)
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, max: 100)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 2)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentMemoryResponse: AWSDecodableShape {
        /// Contains details of the sessions stored in the memory
        public let memoryContents: [Memory]?
        /// If the total number of results is greater than the maxItems value provided in the request, use this token  when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        public init(memoryContents: [Memory]? = nil, nextToken: String? = nil) {
            self.memoryContents = memoryContents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memoryContents = "memoryContents"
            case nextToken = "nextToken"
        }
    }

    public struct GuardrailAssessment: AWSDecodableShape {
        /// Content policy details of the Guardrail.
        public let contentPolicy: GuardrailContentPolicyAssessment?
        /// Sensitive Information policy details of Guardrail.
        public let sensitiveInformationPolicy: GuardrailSensitiveInformationPolicyAssessment?
        /// Topic policy details of the Guardrail.
        public let topicPolicy: GuardrailTopicPolicyAssessment?
        /// Word policy details of the Guardrail.
        public let wordPolicy: GuardrailWordPolicyAssessment?

        public init(contentPolicy: GuardrailContentPolicyAssessment? = nil, sensitiveInformationPolicy: GuardrailSensitiveInformationPolicyAssessment? = nil, topicPolicy: GuardrailTopicPolicyAssessment? = nil, wordPolicy: GuardrailWordPolicyAssessment? = nil) {
            self.contentPolicy = contentPolicy
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.topicPolicy = topicPolicy
            self.wordPolicy = wordPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case contentPolicy = "contentPolicy"
            case sensitiveInformationPolicy = "sensitiveInformationPolicy"
            case topicPolicy = "topicPolicy"
            case wordPolicy = "wordPolicy"
        }
    }

    public struct GuardrailConfiguration: AWSEncodableShape {
        /// The unique identifier for the guardrail.
        public let guardrailId: String
        /// The version of the guardrail.
        public let guardrailVersion: String

        public init(guardrailId: String, guardrailVersion: String) {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailId = "guardrailId"
            case guardrailVersion = "guardrailVersion"
        }
    }

    public struct GuardrailContentFilter: AWSDecodableShape {
        /// The action placed on the content by the Guardrail filter.
        public let action: GuardrailContentPolicyAction?
        /// The confidence level regarding the content detected in the filter by the Guardrail.
        public let confidence: GuardrailContentFilterConfidence?
        /// The type of content detected in the filter by the Guardrail.
        public let type: GuardrailContentFilterType?

        public init(action: GuardrailContentPolicyAction? = nil, confidence: GuardrailContentFilterConfidence? = nil, type: GuardrailContentFilterType? = nil) {
            self.action = action
            self.confidence = confidence
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case confidence = "confidence"
            case type = "type"
        }
    }

    public struct GuardrailContentPolicyAssessment: AWSDecodableShape {
        /// The filter details of the policy assessment used in the Guardrails filter.
        public let filters: [GuardrailContentFilter]?

        public init(filters: [GuardrailContentFilter]? = nil) {
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct GuardrailCustomWord: AWSDecodableShape {
        /// The action details for the custom word filter in the Guardrail.
        public let action: GuardrailWordPolicyAction?
        /// The match details for the custom word filter in the Guardrail.
        public let match: String?

        public init(action: GuardrailWordPolicyAction? = nil, match: String? = nil) {
            self.action = action
            self.match = match
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
        }
    }

    public struct GuardrailManagedWord: AWSDecodableShape {
        /// The action details for the managed word filter in the Guardrail.
        public let action: GuardrailWordPolicyAction?
        /// The match details for the managed word filter in the Guardrail.
        public let match: String?
        /// The type details for the managed word filter in the Guardrail.
        public let type: GuardrailManagedWordType?

        public init(action: GuardrailWordPolicyAction? = nil, match: String? = nil, type: GuardrailManagedWordType? = nil) {
            self.action = action
            self.match = match
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case type = "type"
        }
    }

    public struct GuardrailPiiEntityFilter: AWSDecodableShape {
        /// The action of the Guardrail filter to identify and remove PII.
        public let action: GuardrailSensitiveInformationPolicyAction?
        /// The match to settings in the Guardrail filter to identify and remove PII.
        public let match: String?
        /// The type of PII the Guardrail filter has identified and removed.
        public let type: GuardrailPiiEntityType?

        public init(action: GuardrailSensitiveInformationPolicyAction? = nil, match: String? = nil, type: GuardrailPiiEntityType? = nil) {
            self.action = action
            self.match = match
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case type = "type"
        }
    }

    public struct GuardrailRegexFilter: AWSDecodableShape {
        /// The action details for the regex filter used in the Guardrail.
        public let action: GuardrailSensitiveInformationPolicyAction?
        /// The match details for the regex filter used in the Guardrail.
        public let match: String?
        /// The name details for the regex filter used in the Guardrail.
        public let name: String?
        /// The regex details for the regex filter used in the Guardrail.
        public let regex: String?

        public init(action: GuardrailSensitiveInformationPolicyAction? = nil, match: String? = nil, name: String? = nil, regex: String? = nil) {
            self.action = action
            self.match = match
            self.name = name
            self.regex = regex
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case name = "name"
            case regex = "regex"
        }
    }

    public struct GuardrailSensitiveInformationPolicyAssessment: AWSDecodableShape {
        /// The details of the PII entities used in the sensitive policy assessment for the Guardrail.
        public let piiEntities: [GuardrailPiiEntityFilter]?
        /// The details of the regexes used in the sensitive policy assessment for the Guardrail.
        public let regexes: [GuardrailRegexFilter]?

        public init(piiEntities: [GuardrailPiiEntityFilter]? = nil, regexes: [GuardrailRegexFilter]? = nil) {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntities = "piiEntities"
            case regexes = "regexes"
        }
    }

    public struct GuardrailTopic: AWSDecodableShape {
        /// The action details on a specific topic in the Guardrail.
        public let action: GuardrailTopicPolicyAction?
        /// The name details on a specific topic in the Guardrail.
        public let name: String?
        /// The type details on a specific topic in the Guardrail.
        public let type: GuardrailTopicType?

        public init(action: GuardrailTopicPolicyAction? = nil, name: String? = nil, type: GuardrailTopicType? = nil) {
            self.action = action
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case name = "name"
            case type = "type"
        }
    }

    public struct GuardrailTopicPolicyAssessment: AWSDecodableShape {
        /// The topic details of the policy assessment used in the Guardrail.
        public let topics: [GuardrailTopic]?

        public init(topics: [GuardrailTopic]? = nil) {
            self.topics = topics
        }

        private enum CodingKeys: String, CodingKey {
            case topics = "topics"
        }
    }

    public struct GuardrailTrace: AWSDecodableShape {
        /// The trace action details used with the Guardrail.
        public let action: GuardrailAction?
        /// The details of the input assessments used in the Guardrail Trace.
        public let inputAssessments: [GuardrailAssessment]?
        /// The details of the output assessments used in the Guardrail Trace.
        public let outputAssessments: [GuardrailAssessment]?
        /// The details of the trace Id used in the Guardrail Trace.
        public let traceId: String?

        public init(action: GuardrailAction? = nil, inputAssessments: [GuardrailAssessment]? = nil, outputAssessments: [GuardrailAssessment]? = nil, traceId: String? = nil) {
            self.action = action
            self.inputAssessments = inputAssessments
            self.outputAssessments = outputAssessments
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case inputAssessments = "inputAssessments"
            case outputAssessments = "outputAssessments"
            case traceId = "traceId"
        }
    }

    public struct GuardrailWordPolicyAssessment: AWSDecodableShape {
        /// The custom word details for words defined in the Guardrail filter.
        public let customWords: [GuardrailCustomWord]?
        /// The managed word lists for words defined in the Guardrail filter.
        public let managedWordLists: [GuardrailManagedWord]?

        public init(customWords: [GuardrailCustomWord]? = nil, managedWordLists: [GuardrailManagedWord]? = nil) {
            self.customWords = customWords
            self.managedWordLists = managedWordLists
        }

        private enum CodingKeys: String, CodingKey {
            case customWords = "customWords"
            case managedWordLists = "managedWordLists"
        }
    }

    public struct InferenceConfig: AWSEncodableShape {
        ///  Configuration settings specific to text generation while generating responses using RetrieveAndGenerate.
        public let textInferenceConfig: TextInferenceConfig?

        public init(textInferenceConfig: TextInferenceConfig? = nil) {
            self.textInferenceConfig = textInferenceConfig
        }

        public func validate(name: String) throws {
            try self.textInferenceConfig?.validate(name: "\(name).textInferenceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case textInferenceConfig = "textInferenceConfig"
        }
    }

    public struct InferenceConfiguration: AWSDecodableShape {
        /// The maximum number of tokens allowed in the generated response.
        public let maximumLength: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public let temperature: Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public let topK: Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public let topP: Float?

        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct InputFile: AWSEncodableShape {
        /// The name of the source file.
        public let name: String
        /// Specifies where the files are located.
        public let source: FileSource
        /// Specifies how the source files will be used by the code interpreter.
        public let useCase: FileUseCase

        public init(name: String, source: FileSource, useCase: FileUseCase) {
            self.name = name
            self.source = source
            self.useCase = useCase
        }

        public func validate(name: String) throws {
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case source = "source"
            case useCase = "useCase"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvocationInput: AWSDecodableShape {
        /// Contains information about the action group to be invoked.
        public let actionGroupInvocationInput: ActionGroupInvocationInput?
        /// Contains information about the code interpreter to be invoked.
        public let codeInterpreterInvocationInput: CodeInterpreterInvocationInput?
        /// Specifies whether the agent is invoking an action group or a knowledge base.
        public let invocationType: InvocationType?
        /// Contains details about the knowledge base to look up and the query to be made.
        public let knowledgeBaseLookupInput: KnowledgeBaseLookupInput?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(actionGroupInvocationInput: ActionGroupInvocationInput? = nil, codeInterpreterInvocationInput: CodeInterpreterInvocationInput? = nil, invocationType: InvocationType? = nil, knowledgeBaseLookupInput: KnowledgeBaseLookupInput? = nil, traceId: String? = nil) {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.codeInterpreterInvocationInput = codeInterpreterInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationInput = "actionGroupInvocationInput"
            case codeInterpreterInvocationInput = "codeInterpreterInvocationInput"
            case invocationType = "invocationType"
            case knowledgeBaseLookupInput = "knowledgeBaseLookupInput"
            case traceId = "traceId"
        }
    }

    public struct InvokeAgentRequest: AWSEncodableShape {
        /// The alias of the agent to use.
        public let agentAliasId: String
        /// The unique identifier of the agent to use.
        public let agentId: String
        /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see Trace enablement.
        public let enableTrace: Bool?
        /// Specifies whether to end the session with the agent or not.
        public let endSession: Bool?
        /// The prompt text to send the agent.  If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
        public let inputText: String?
        /// The unique identifier of the agent memory.
        public let memoryId: String?
        /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
        public let sessionId: String
        /// Contains parameters that specify various attributes of the session. For more information, see Control session context.  If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
        public let sessionState: SessionState?

        public init(agentAliasId: String, agentId: String, enableTrace: Bool? = nil, endSession: Bool? = nil, inputText: String? = nil, memoryId: String? = nil, sessionId: String, sessionState: SessionState? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.enableTrace = enableTrace
            self.endSession = endSession
            self.inputText = inputText
            self.memoryId = memoryId
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.enableTrace, forKey: .enableTrace)
            try container.encodeIfPresent(self.endSession, forKey: .endSession)
            try container.encodeIfPresent(self.inputText, forKey: .inputText)
            try container.encodeIfPresent(self.memoryId, forKey: .memoryId)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.sessionState, forKey: .sessionState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.inputText, name: "inputText", parent: name, max: 25000000)
            try self.validate(self.memoryId, name: "memoryId", parent: name, max: 100)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 2)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.sessionState?.validate(name: "\(name).sessionState")
        }

        private enum CodingKeys: String, CodingKey {
            case enableTrace = "enableTrace"
            case endSession = "endSession"
            case inputText = "inputText"
            case memoryId = "memoryId"
            case sessionState = "sessionState"
        }
    }

    public struct InvokeAgentResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The agent's response to the user prompt.
        public let completion: AWSEventStream<ResponseStream>
        /// The MIME type of the input data in the request. The default value is application/json.
        public let contentType: String
        /// The unique identifier of the agent memory.
        public let memoryId: String?
        /// The unique identifier of the session with the agent.
        public let sessionId: String

        public init(completion: AWSEventStream<ResponseStream>, contentType: String, memoryId: String? = nil, sessionId: String) {
            self.completion = completion
            self.contentType = contentType
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.completion = try container.decode(AWSEventStream<ResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "x-amzn-bedrock-agent-content-type")
            self.memoryId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-bedrock-agent-memory-id")
            self.sessionId = try response.decodeHeader(String.self, key: "x-amz-bedrock-agent-session-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeFlowRequest: AWSEncodableShape {
        /// The unique identifier of the flow alias.
        public let flowAliasIdentifier: String
        /// The unique identifier of the flow.
        public let flowIdentifier: String
        /// A list of objects, each containing information about an input into the flow.
        public let inputs: [FlowInput]

        public init(flowAliasIdentifier: String, flowIdentifier: String, inputs: [FlowInput]) {
            self.flowAliasIdentifier = flowAliasIdentifier
            self.flowIdentifier = flowIdentifier
            self.inputs = inputs
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.flowAliasIdentifier, key: "flowAliasIdentifier")
            request.encodePath(self.flowIdentifier, key: "flowIdentifier")
            try container.encode(self.inputs, forKey: .inputs)
        }

        public func validate(name: String) throws {
            try self.validate(self.flowAliasIdentifier, name: "flowAliasIdentifier", parent: name, max: 2048)
            try self.validate(self.flowAliasIdentifier, name: "flowAliasIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10}/alias/[0-9a-zA-Z]{10})|(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, max: 2048)
            try self.validate(self.flowIdentifier, name: "flowIdentifier", parent: name, pattern: "^(arn:aws:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:flow/[0-9a-zA-Z]{10})|([0-9a-zA-Z]{10})$")
            try self.inputs.forEach {
                try $0.validate(name: "\(name).inputs[]")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "inputs"
        }
    }

    public struct InvokeFlowResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The output of the flow, returned as a stream. If there's an error, the error is returned.
        public let responseStream: AWSEventStream<FlowResponseStream>

        public init(responseStream: AWSEventStream<FlowResponseStream>) {
            self.responseStream = responseStream
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.responseStream = try container.decode(AWSEventStream<FlowResponseStream>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct KnowledgeBaseConfiguration: AWSEncodableShape {
        /// The unique identifier for a knowledge base attached to the agent.
        public let knowledgeBaseId: String
        /// The configurations to apply to the knowledge base during query. For more information, see Query configurations.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration

        public init(knowledgeBaseId: String, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration) {
            self.knowledgeBaseId = knowledgeBaseId
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.retrievalConfiguration.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseLookupInput: AWSDecodableShape {
        /// The unique identifier of the knowledge base to look up.
        public let knowledgeBaseId: String?
        /// The query made to the knowledge base.
        public let text: String?

        public init(knowledgeBaseId: String? = nil, text: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case text = "text"
        }
    }

    public struct KnowledgeBaseLookupOutput: AWSDecodableShape {
        /// Contains metadata about the sources cited for the generated response.
        public let retrievedReferences: [RetrievedReference]?

        public init(retrievedReferences: [RetrievedReference]? = nil) {
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct KnowledgeBaseQuery: AWSEncodableShape {
        /// The text of the query made to the knowledge base.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct KnowledgeBaseRetrievalConfiguration: AWSEncodableShape {
        /// Contains details about how the results from the vector search should be returned. For more information, see Query configurations.
        public let vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration

        public init(vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.vectorSearchConfiguration.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct KnowledgeBaseRetrievalResult: AWSDecodableShape {
        /// Contains a chunk of text from a data source in the knowledge base.
        public let content: RetrievalResultContent
        /// Contains information about the location of the data source.
        public let location: RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see Metadata and filtering.
        public let metadata: [String: String]?
        /// The level of relevance of the result to the query.
        public let score: Double?

        public init(content: RetrievalResultContent, location: RetrievalResultLocation? = nil, metadata: [String: String]? = nil, score: Double? = nil) {
            self.content = content
            self.location = location
            self.metadata = metadata
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case metadata = "metadata"
            case score = "score"
        }
    }

    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// Contains configurations for response generation based on the knowledge base query results.
        public let generationConfiguration: GenerationConfiguration?
        /// The unique identifier of the knowledge base that is queried and the foundation model used for generation.
        public let knowledgeBaseId: String
        /// The ARN of the foundation model used to generate a response.
        public let modelArn: String
        /// Settings for how the model processes the prompt prior to retrieval and generation.
        public let orchestrationConfiguration: OrchestrationConfiguration?
        /// Contains configurations for how to retrieve and return the knowledge base query.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?

        public init(generationConfiguration: GenerationConfiguration? = nil, knowledgeBaseId: String, modelArn: String, orchestrationConfiguration: OrchestrationConfiguration? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil) {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.orchestrationConfiguration = orchestrationConfiguration
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 1011)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 20)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}))$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case modelArn = "modelArn"
            case orchestrationConfiguration = "orchestrationConfiguration"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseVectorSearchConfiguration: AWSEncodableShape {
        /// Specifies the filters to use on the metadata in the knowledge base data sources before returning results. For more information, see Query configurations.
        public let filter: RetrievalFilter?
        /// The number of source chunks to retrieve.
        public let numberOfResults: Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available. For more information, see Test a knowledge base.
        public let overrideSearchType: SearchType?

        public init(filter: RetrievalFilter? = nil, numberOfResults: Int? = nil, overrideSearchType: SearchType? = nil) {
            self.filter = filter
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case numberOfResults = "numberOfResults"
            case overrideSearchType = "overrideSearchType"
        }
    }

    public struct MemorySessionSummary: AWSDecodableShape {
        /// The unique identifier of the memory where the session summary is stored.
        public let memoryId: String?
        /// The time when the memory duration for the session is set to end.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var sessionExpiryTime: Date?
        /// The identifier for this session.
        public let sessionId: String?
        /// The start time for this session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var sessionStartTime: Date?
        /// The summarized text for this session.
        public let summaryText: String?

        public init(memoryId: String? = nil, sessionExpiryTime: Date? = nil, sessionId: String? = nil, sessionStartTime: Date? = nil, summaryText: String? = nil) {
            self.memoryId = memoryId
            self.sessionExpiryTime = sessionExpiryTime
            self.sessionId = sessionId
            self.sessionStartTime = sessionStartTime
            self.summaryText = summaryText
        }

        private enum CodingKeys: String, CodingKey {
            case memoryId = "memoryId"
            case sessionExpiryTime = "sessionExpiryTime"
            case sessionId = "sessionId"
            case sessionStartTime = "sessionStartTime"
            case summaryText = "summaryText"
        }
    }

    public struct ModelInvocationInput: AWSDecodableShape {
        /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the PromptOverrideConfiguration object that was set when the agent was created or updated. For more information, see Inference parameters for foundation models.
        public let inferenceConfiguration: InferenceConfiguration?
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.
        public let overrideLambda: String?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType.
        public let parserMode: CreationMode?
        /// Specifies whether the default prompt template was OVERRIDDEN. If it was, the basePromptTemplate that was set in the PromptOverrideConfiguration object when the agent was created or updated is used instead.
        public let promptCreationMode: CreationMode?
        /// The text that prompted the agent at this step.
        public let text: String?
        /// The unique identifier of the trace.
        public let traceId: String?
        /// The step in the agent sequence.
        public let type: PromptType?

        public init(inferenceConfiguration: InferenceConfiguration? = nil, overrideLambda: String? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, text: String? = nil, traceId: String? = nil, type: PromptType? = nil) {
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceConfiguration = "inferenceConfiguration"
            case overrideLambda = "overrideLambda"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case text = "text"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct Observation: AWSDecodableShape {
        /// Contains the JSON-formatted string returned by the API invoked by the action group.
        public let actionGroupInvocationOutput: ActionGroupInvocationOutput?
        /// Contains the JSON-formatted string returned by the API invoked by the code interpreter.
        public let codeInterpreterInvocationOutput: CodeInterpreterInvocationOutput?
        /// Contains details about the response to the user.
        public let finalResponse: FinalResponse?
        /// Contains details about the results from looking up the knowledge base.
        public let knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput?
        /// Contains details about the response to reprompt the input.
        public let repromptResponse: RepromptResponse?
        /// The unique identifier of the trace.
        public let traceId: String?
        /// Specifies what kind of information the agent returns in the observation. The following values are possible.    ACTION_GROUP  The agent returns the result of an action group.    KNOWLEDGE_BASE  The agent returns information from a knowledge base.    FINISH  The agent returns a final response to the user with no follow-up.    ASK_USER  The agent asks the user a question.    REPROMPT  The agent prompts the user again for the same information.
        public let type: `Type`?

        public init(actionGroupInvocationOutput: ActionGroupInvocationOutput? = nil, codeInterpreterInvocationOutput: CodeInterpreterInvocationOutput? = nil, finalResponse: FinalResponse? = nil, knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput? = nil, repromptResponse: RepromptResponse? = nil, traceId: String? = nil, type: `Type`? = nil) {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.codeInterpreterInvocationOutput = codeInterpreterInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationOutput = "actionGroupInvocationOutput"
            case codeInterpreterInvocationOutput = "codeInterpreterInvocationOutput"
            case finalResponse = "finalResponse"
            case knowledgeBaseLookupOutput = "knowledgeBaseLookupOutput"
            case repromptResponse = "repromptResponse"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct OrchestrationConfiguration: AWSEncodableShape {
        /// To split up the prompt and retrieve multiple sources, set the transformation type to QUERY_DECOMPOSITION.
        public let queryTransformationConfiguration: QueryTransformationConfiguration

        public init(queryTransformationConfiguration: QueryTransformationConfiguration) {
            self.queryTransformationConfiguration = queryTransformationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case queryTransformationConfiguration = "queryTransformationConfiguration"
        }
    }

    public struct OutputFile: AWSDecodableShape {
        /// The byte count of files that contains response from code interpreter.
        public let bytes: AWSBase64Data?
        /// The name of the file containing response from code interpreter.
        public let name: String?
        /// The type of file that contains response from the code interpreter.
        public let type: String?

        public init(bytes: AWSBase64Data? = nil, name: String? = nil, type: String? = nil) {
            self.bytes = bytes
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case name = "name"
            case type = "type"
        }
    }

    public struct Parameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String?
        /// The type of the parameter.
        public let type: String?
        /// The value of the parameter.
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct PayloadPart: AWSDecodableShape {
        /// Contains citations for a part of an agent response.
        public let attribution: Attribution?
        /// A part of the agent response in bytes.
        public let bytes: AWSBase64Data?

        public init(attribution: Attribution? = nil, bytes: AWSBase64Data? = nil) {
            self.attribution = attribution
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case attribution = "attribution"
            case bytes = "bytes"
        }
    }

    public struct PostProcessingModelInvocationOutput: AWSDecodableShape {
        /// Details about the response from the Lambda parsing of the output of the post-processing step.
        public let parsedResponse: PostProcessingParsedResponse?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(parsedResponse: PostProcessingParsedResponse? = nil, traceId: String? = nil) {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case parsedResponse = "parsedResponse"
            case traceId = "traceId"
        }
    }

    public struct PostProcessingParsedResponse: AWSDecodableShape {
        /// The text returned by the parser.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct PreProcessingModelInvocationOutput: AWSDecodableShape {
        /// Details about the response from the Lambda parsing of the output of the pre-processing step.
        public let parsedResponse: PreProcessingParsedResponse?
        /// The unique identifier of the trace.
        public let traceId: String?

        public init(parsedResponse: PreProcessingParsedResponse? = nil, traceId: String? = nil) {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case parsedResponse = "parsedResponse"
            case traceId = "traceId"
        }
    }

    public struct PreProcessingParsedResponse: AWSDecodableShape {
        /// Whether the user input is valid or not. If false, the agent doesn't proceed to orchestration.
        public let isValid: Bool?
        /// The text returned by the parsing of the pre-processing step, explaining the steps that the agent plans to take in orchestration, if the user input is valid.
        public let rationale: String?

        public init(isValid: Bool? = nil, rationale: String? = nil) {
            self.isValid = isValid
            self.rationale = rationale
        }

        private enum CodingKeys: String, CodingKey {
            case isValid = "isValid"
            case rationale = "rationale"
        }
    }

    public struct PromptTemplate: AWSEncodableShape {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see the following resources:    Knowledge base prompt templates     Use XML tags with Anthropic Claude models
        public let textPromptTemplate: String?

        public init(textPromptTemplate: String? = nil) {
            self.textPromptTemplate = textPromptTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, max: 4000)
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case textPromptTemplate = "textPromptTemplate"
        }
    }

    public struct PropertyParameters: AWSDecodableShape {
        /// A list of parameters in the request body.
        public let properties: [Parameter]?

        public init(properties: [Parameter]? = nil) {
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case properties = "properties"
        }
    }

    public struct QueryTransformationConfiguration: AWSEncodableShape {
        /// The type of transformation to apply to the prompt.
        public let type: QueryTransformationType

        public init(type: QueryTransformationType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct Rationale: AWSDecodableShape {
        /// The reasoning or thought process of the agent, based on the input.
        public let text: String?
        /// The unique identifier of the trace step.
        public let traceId: String?

        public init(text: String? = nil, traceId: String? = nil) {
            self.text = text
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case traceId = "traceId"
        }
    }

    public struct RepromptResponse: AWSDecodableShape {
        /// Specifies what output is prompting the agent to reprompt the input.
        public let source: Source?
        /// The text reprompting the input.
        public let text: String?

        public init(source: Source? = nil, text: String? = nil) {
            self.source = source
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case text = "text"
        }
    }

    public struct RequestBody: AWSDecodableShape {
        /// The content in the request body.
        public let content: [String: [Parameter]]?

        public init(content: [String: [Parameter]]? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetrievalResultConfluenceLocation: AWSDecodableShape {
        /// The Confluence host URL for the data source location.
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrievalResultContent: AWSDecodableShape {
        /// The cited text from the data source.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrievalResultLocation: AWSDecodableShape {
        /// The Confluence data source location.
        public let confluenceLocation: RetrievalResultConfluenceLocation?
        /// The S3 data source location.
        public let s3Location: RetrievalResultS3Location?
        /// The Salesforce data source location.
        public let salesforceLocation: RetrievalResultSalesforceLocation?
        /// The SharePoint data source location.
        public let sharePointLocation: RetrievalResultSharePointLocation?
        /// The type of data source location.
        public let type: RetrievalResultLocationType
        /// The web URL/URLs data source location.
        public let webLocation: RetrievalResultWebLocation?

        public init(confluenceLocation: RetrievalResultConfluenceLocation? = nil, s3Location: RetrievalResultS3Location? = nil, salesforceLocation: RetrievalResultSalesforceLocation? = nil, sharePointLocation: RetrievalResultSharePointLocation? = nil, type: RetrievalResultLocationType, webLocation: RetrievalResultWebLocation? = nil) {
            self.confluenceLocation = confluenceLocation
            self.s3Location = s3Location
            self.salesforceLocation = salesforceLocation
            self.sharePointLocation = sharePointLocation
            self.type = type
            self.webLocation = webLocation
        }

        private enum CodingKeys: String, CodingKey {
            case confluenceLocation = "confluenceLocation"
            case s3Location = "s3Location"
            case salesforceLocation = "salesforceLocation"
            case sharePointLocation = "sharePointLocation"
            case type = "type"
            case webLocation = "webLocation"
        }
    }

    public struct RetrievalResultS3Location: AWSDecodableShape {
        /// The S3 URI for the data source location.
        public let uri: String?

        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct RetrievalResultSalesforceLocation: AWSDecodableShape {
        /// The Salesforce host URL for the data source location.
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrievalResultSharePointLocation: AWSDecodableShape {
        /// The SharePoint site URL for the data source location.
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrievalResultWebLocation: AWSDecodableShape {
        /// The web URL/URLs for the data source location.
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct RetrieveAndGenerateConfiguration: AWSEncodableShape {
        /// The configuration used with the external source wrapper object in the retrieveAndGenerate function.
        public let externalSourcesConfiguration: ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains details about the resource being queried.
        public let knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that is queried by the request.
        public let type: RetrieveAndGenerateType

        public init(externalSourcesConfiguration: ExternalSourcesRetrieveAndGenerateConfiguration? = nil, knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration? = nil, type: RetrieveAndGenerateType) {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.externalSourcesConfiguration?.validate(name: "\(name).externalSourcesConfiguration")
            try self.knowledgeBaseConfiguration?.validate(name: "\(name).knowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case externalSourcesConfiguration = "externalSourcesConfiguration"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case type = "type"
        }
    }

    public struct RetrieveAndGenerateInput: AWSEncodableShape {
        /// The query made to the knowledge base.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateOutput: AWSDecodableShape {
        /// The response generated from querying the knowledge base.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateRequest: AWSEncodableShape {
        /// Contains the query to be made to the knowledge base.
        public let input: RetrieveAndGenerateInput
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration?
        /// Contains details about the session with the knowledge base.
        public let sessionConfiguration: RetrieveAndGenerateSessionConfiguration?
        /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
        public let sessionId: String?

        public init(input: RetrieveAndGenerateInput, retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration? = nil, sessionConfiguration: RetrieveAndGenerateSessionConfiguration? = nil, sessionId: String? = nil) {
            self.input = input
            self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
            self.sessionConfiguration = sessionConfiguration
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.retrieveAndGenerateConfiguration?.validate(name: "\(name).retrieveAndGenerateConfiguration")
            try self.sessionConfiguration?.validate(name: "\(name).sessionConfiguration")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case retrieveAndGenerateConfiguration = "retrieveAndGenerateConfiguration"
            case sessionConfiguration = "sessionConfiguration"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateResponse: AWSDecodableShape {
        /// A list of segments of the generated response that are based on sources in the knowledge base, alongside information about the sources.
        public let citations: [Citation]?
        /// Specifies if there is a guardrail intervention in the response.
        public let guardrailAction: GuadrailAction?
        /// Contains the response generated from querying the knowledge base.
        public let output: RetrieveAndGenerateOutput
        /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
        public let sessionId: String

        public init(citations: [Citation]? = nil, guardrailAction: GuadrailAction? = nil, output: RetrieveAndGenerateOutput, sessionId: String) {
            self.citations = citations
            self.guardrailAction = guardrailAction
            self.output = output
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
            case guardrailAction = "guardrailAction"
            case output = "output"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateSessionConfiguration: AWSEncodableShape {
        /// The ARN of the KMS key encrypting the session.
        public let kmsKeyArn: String

        public init(kmsKeyArn: String) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct RetrieveRequest: AWSEncodableShape {
        /// The unique identifier of the knowledge base to query.
        public let knowledgeBaseId: String
        /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
        public let nextToken: String?
        /// Contains configurations for the knowledge base query and retrieval process. For more information, see Query configurations.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?
        /// Contains the query to send the knowledge base.
        public let retrievalQuery: KnowledgeBaseQuery

        public init(knowledgeBaseId: String, nextToken: String? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil, retrievalQuery: KnowledgeBaseQuery) {
            self.knowledgeBaseId = knowledgeBaseId
            self.nextToken = nextToken
            self.retrievalConfiguration = retrievalConfiguration
            self.retrievalQuery = retrievalQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.retrievalConfiguration, forKey: .retrievalConfiguration)
            try container.encode(self.retrievalQuery, forKey: .retrievalQuery)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievalConfiguration = "retrievalConfiguration"
            case retrievalQuery = "retrievalQuery"
        }
    }

    public struct RetrieveResponse: AWSDecodableShape {
        /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
        public let nextToken: String?
        /// A list of results from querying the knowledge base.
        public let retrievalResults: [KnowledgeBaseRetrievalResult]

        public init(nextToken: String? = nil, retrievalResults: [KnowledgeBaseRetrievalResult]) {
            self.nextToken = nextToken
            self.retrievalResults = retrievalResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievalResults = "retrievalResults"
        }
    }

    public struct RetrievedReference: AWSDecodableShape {
        /// Contains the cited text from the data source.
        public let content: RetrievalResultContent?
        /// Contains information about the location of the data source.
        public let location: RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see Metadata and filtering.
        public let metadata: [String: String]?

        public init(content: RetrievalResultContent? = nil, location: RetrievalResultLocation? = nil, metadata: [String: String]? = nil) {
            self.content = content
            self.location = location
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case metadata = "metadata"
        }
    }

    public struct ReturnControlPayload: AWSDecodableShape {
        /// The identifier of the action group invocation.
        public let invocationId: String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent determines from its session with the user.
        public let invocationInputs: [InvocationInputMember]?

        public init(invocationId: String? = nil, invocationInputs: [InvocationInputMember]? = nil) {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }

        private enum CodingKeys: String, CodingKey {
            case invocationId = "invocationId"
            case invocationInputs = "invocationInputs"
        }
    }

    public struct S3ObjectDoc: AWSEncodableShape {
        /// The file location of the S3 wrapper object.
        public let uri: String

        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct S3ObjectFile: AWSEncodableShape {
        /// The uri of the s3 object.
        public let uri: String

        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct ServiceQuotaExceededException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SessionState: AWSEncodableShape {
        /// Contains information about the files used by code interpreter.
        public let files: [InputFile]?
        /// The identifier of the invocation of an action. This value must match the invocationId returned in the InvokeAgent response for the action whose results are provided in the returnControlInvocationResults field. For more information, see Return control to the agent developer and Control session context.
        public let invocationId: String?
        /// An array of configurations, each of which applies to a knowledge base attached to the agent.
        public let knowledgeBaseConfigurations: [KnowledgeBaseConfiguration]?
        /// Contains attributes that persist across a prompt and the values of those attributes. These attributes replace the $prompt_session_attributes$ placeholder variable in the orchestration prompt template. For more information, see Prompt template placeholder variables.
        public let promptSessionAttributes: [String: String]?
        /// Contains information about the results from the action group invocation. For more information, see Return control to the agent developer and Control session context.  If you include this field, the inputText field will be ignored.
        public let returnControlInvocationResults: [InvocationResultMember]?
        /// Contains attributes that persist across a session and the values of those attributes.
        public let sessionAttributes: [String: String]?

        public init(files: [InputFile]? = nil, invocationId: String? = nil, knowledgeBaseConfigurations: [KnowledgeBaseConfiguration]? = nil, promptSessionAttributes: [String: String]? = nil, returnControlInvocationResults: [InvocationResultMember]? = nil, sessionAttributes: [String: String]? = nil) {
            self.files = files
            self.invocationId = invocationId
            self.knowledgeBaseConfigurations = knowledgeBaseConfigurations
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }

        public func validate(name: String) throws {
            try self.files?.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.knowledgeBaseConfigurations?.forEach {
                try $0.validate(name: "\(name).knowledgeBaseConfigurations[]")
            }
            try self.validate(self.knowledgeBaseConfigurations, name: "knowledgeBaseConfigurations", parent: name, min: 1)
            try self.validate(self.returnControlInvocationResults, name: "returnControlInvocationResults", parent: name, max: 5)
            try self.validate(self.returnControlInvocationResults, name: "returnControlInvocationResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
            case invocationId = "invocationId"
            case knowledgeBaseConfigurations = "knowledgeBaseConfigurations"
            case promptSessionAttributes = "promptSessionAttributes"
            case returnControlInvocationResults = "returnControlInvocationResults"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct Span: AWSDecodableShape {
        /// Where the text with a citation ends in the generated output.
        public let end: Int?
        /// Where the text with a citation starts in the generated output.
        public let start: Int?

        public init(end: Int? = nil, start: Int? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct TextInferenceConfig: AWSEncodableShape {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0 or the maximum of 65536. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public let maxTokens: Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public let stopSequences: [String]?
        ///  Controls the random-ness of text generated by the language model, influencing how much the model sticks to the most predictable next words versus exploring more surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes the outputs more creative or unpredictable.
        public let temperature: Float?
        ///  A probability distribution threshold which controls what the model considers for the set of possible next tokens. The model will only consider the top p% of the probability distribution when generating the next token.
        public let topP: Float?

        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, max: 65536)
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topP = "topP"
        }
    }

    public struct TextResponsePart: AWSDecodableShape {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public let span: Span?
        /// The part of the generated text that contains a citation.
        public let text: String?

        public init(span: Span? = nil, text: String? = nil) {
            self.span = span
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case span = "span"
            case text = "text"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TracePart: AWSDecodableShape {
        /// The unique identifier of the alias of the agent.
        public let agentAliasId: String?
        /// The unique identifier of the agent.
        public let agentId: String?
        /// The version of the agent.
        public let agentVersion: String?
        /// The unique identifier of the session with the agent.
        public let sessionId: String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see Trace enablement.
        public let trace: Trace?

        public init(agentAliasId: String? = nil, agentId: String? = nil, agentVersion: String? = nil, sessionId: String? = nil, trace: Trace? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.sessionId = sessionId
            self.trace = trace
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentId = "agentId"
            case agentVersion = "agentVersion"
            case sessionId = "sessionId"
            case trace = "trace"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct FlowInputContent: AWSEncodableShape {
        /// The input for the flow input node.
        public let document: String?

        public init(document: String? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct FlowOutputContent: AWSDecodableShape {
        /// A name for the output of the flow.
        public let document: String?

        public init(document: String? = nil) {
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
        }
    }

    public struct Memory: AWSDecodableShape {
        /// Contains summary of a session.
        public let sessionSummary: MemorySessionSummary?

        public init(sessionSummary: MemorySessionSummary? = nil) {
            self.sessionSummary = sessionSummary
        }

        private enum CodingKeys: String, CodingKey {
            case sessionSummary = "sessionSummary"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentRuntime
public struct BedrockAgentRuntimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentRuntime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions. Check your permissions and retry your request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was an issue with a dependency due to a server issue. Retry your request.
    public static var badGatewayException: Self { .init(.badGatewayException) }
    /// There was a conflict performing an operation. Resolve the conflict and retry your request.
    public static var conflictException: Self { .init(.conflictException) }
    /// There was an issue with a dependency. Check the resource configurations and retry the request.
    public static var dependencyFailedException: Self { .init(.dependencyFailedException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentRuntimeErrorType: Equatable {
    public static func == (lhs: BedrockAgentRuntimeErrorType, rhs: BedrockAgentRuntimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentRuntimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
