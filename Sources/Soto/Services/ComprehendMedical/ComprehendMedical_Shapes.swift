//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension ComprehendMedical {
    // MARK: Enums

    public enum AttributeName: String, CustomStringConvertible, Codable {
        case diagnosis = "DIAGNOSIS"
        case negation = "NEGATION"
        case sign = "SIGN"
        case symptom = "SYMPTOM"
        public var description: String { return self.rawValue }
    }

    public enum EntitySubType: String, CustomStringConvertible, Codable {
        case acuity = "ACUITY"
        case address = "ADDRESS"
        case age = "AGE"
        case brandName = "BRAND_NAME"
        case contactPoint = "CONTACT_POINT"
        case date = "DATE"
        case direction = "DIRECTION"
        case dosage = "DOSAGE"
        case duration = "DURATION"
        case dxName = "DX_NAME"
        case email = "EMAIL"
        case form = "FORM"
        case frequency = "FREQUENCY"
        case genericName = "GENERIC_NAME"
        case identifier = "IDENTIFIER"
        case name = "NAME"
        case procedureName = "PROCEDURE_NAME"
        case profession = "PROFESSION"
        case quality = "QUALITY"
        case quantity = "QUANTITY"
        case rate = "RATE"
        case routeOrMode = "ROUTE_OR_MODE"
        case strength = "STRENGTH"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case testName = "TEST_NAME"
        case testUnits = "TEST_UNITS"
        case testValue = "TEST_VALUE"
        case timeExpression = "TIME_EXPRESSION"
        case timeToDxName = "TIME_TO_DX_NAME"
        case timeToMedicationName = "TIME_TO_MEDICATION_NAME"
        case timeToProcedureName = "TIME_TO_PROCEDURE_NAME"
        case timeToTestName = "TIME_TO_TEST_NAME"
        case timeToTreatmentName = "TIME_TO_TREATMENT_NAME"
        case treatmentName = "TREATMENT_NAME"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum EntityType: String, CustomStringConvertible, Codable {
        case anatomy = "ANATOMY"
        case medicalCondition = "MEDICAL_CONDITION"
        case medication = "MEDICATION"
        case protectedHealthInformation = "PROTECTED_HEALTH_INFORMATION"
        case testTreatmentProcedure = "TEST_TREATMENT_PROCEDURE"
        case timeExpression = "TIME_EXPRESSION"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMAttributeType: String, CustomStringConvertible, Codable {
        case acuity = "ACUITY"
        case direction = "DIRECTION"
        case quality = "QUALITY"
        case quantity = "QUANTITY"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case timeExpression = "TIME_EXPRESSION"
        case timeToDxName = "TIME_TO_DX_NAME"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMEntityCategory: String, CustomStringConvertible, Codable {
        case medicalCondition = "MEDICAL_CONDITION"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMEntityType: String, CustomStringConvertible, Codable {
        case dxName = "DX_NAME"
        case timeExpression = "TIME_EXPRESSION"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMRelationshipType: String, CustomStringConvertible, Codable {
        case overlap = "OVERLAP"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMTraitName: String, CustomStringConvertible, Codable {
        case diagnosis = "DIAGNOSIS"
        case negation = "NEGATION"
        case sign = "SIGN"
        case symptom = "SYMPTOM"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case partialSuccess = "PARTIAL_SUCCESS"
        case stopRequested = "STOP_REQUESTED"
        case stopped = "STOPPED"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable {
        case en
        public var description: String { return self.rawValue }
    }

    public enum RelationshipType: String, CustomStringConvertible, Codable {
        case acuity = "ACUITY"
        case administeredVia = "ADMINISTERED_VIA"
        case direction = "DIRECTION"
        case dosage = "DOSAGE"
        case duration = "DURATION"
        case every = "EVERY"
        case `for` = "FOR"
        case form = "FORM"
        case frequency = "FREQUENCY"
        case negative = "NEGATIVE"
        case overlap = "OVERLAP"
        case rate = "RATE"
        case routeOrMode = "ROUTE_OR_MODE"
        case strength = "STRENGTH"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case testUnits = "TEST_UNITS"
        case testValue = "TEST_VALUE"
        case withDosage = "WITH_DOSAGE"
        public var description: String { return self.rawValue }
    }

    public enum RxNormAttributeType: String, CustomStringConvertible, Codable {
        case dosage = "DOSAGE"
        case duration = "DURATION"
        case form = "FORM"
        case frequency = "FREQUENCY"
        case rate = "RATE"
        case routeOrMode = "ROUTE_OR_MODE"
        case strength = "STRENGTH"
        public var description: String { return self.rawValue }
    }

    public enum RxNormEntityCategory: String, CustomStringConvertible, Codable {
        case medication = "MEDICATION"
        public var description: String { return self.rawValue }
    }

    public enum RxNormEntityType: String, CustomStringConvertible, Codable {
        case brandName = "BRAND_NAME"
        case genericName = "GENERIC_NAME"
        public var description: String { return self.rawValue }
    }

    public enum RxNormTraitName: String, CustomStringConvertible, Codable {
        case negation = "NEGATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Attribute: AWSDecodableShape {
        ///  The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of attribute.
        public let category: EntityType?
        ///  The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        ///  The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        ///  The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public let relationshipScore: Float?
        /// The type of relationship between the entity and attribute. Type for the relationship is OVERLAP, indicating that the entity occurred at the same time as the Date_Expression.
        public let relationshipType: RelationshipType?
        ///  The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        ///  The segment of input text extracted as this attribute.
        public let text: String?
        ///  Contextual information for this attribute.
        public let traits: [Trait]?
        ///  The type of attribute.
        public let type: EntitySubType?

        public init(beginOffset: Int? = nil, category: EntityType? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, relationshipType: RelationshipType? = nil, score: Float? = nil, text: String? = nil, traits: [Trait]? = nil, type: EntitySubType? = nil) {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case relationshipType = "RelationshipType"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ComprehendMedicalAsyncJobFilter: AWSEncodableShape {
        /// Filters on the name of the job.
        public let jobName: String?
        /// Filters the list of jobs based on job status. Returns only jobs with the specified status.
        public let jobStatus: JobStatus?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.
        public let submitTimeAfter: Date?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.
        public let submitTimeBefore: Date?

        public init(jobName: String? = nil, jobStatus: JobStatus? = nil, submitTimeAfter: Date? = nil, submitTimeBefore: Date? = nil) {
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case submitTimeAfter = "SubmitTimeAfter"
            case submitTimeBefore = "SubmitTimeBefore"
        }
    }

    public struct ComprehendMedicalAsyncJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that gives Amazon Comprehend Medical read access to your input data.
        public let dataAccessRoleArn: String?
        /// The time that the detection job completed.
        public let endTime: Date?
        /// The date and time that job metadata is deleted from the server. Output files in your S3 bucket will not be deleted. After the metadata is deleted, the job will no longer appear in the results of the ListEntitiesDetectionV2Job or the ListPHIDetectionJobs operation.
        public let expirationTime: Date?
        /// The input data configuration that you supplied when you created the detection job.
        public let inputDataConfig: InputDataConfig?
        /// The identifier assigned to the detection job.
        public let jobId: String?
        /// The name that you assigned to the detection job.
        public let jobName: String?
        /// The current status of the detection job. If the status is FAILED, the Message field shows the reason for the failure.
        public let jobStatus: JobStatus?
        /// The AWS Key Management Service key, if any, used to encrypt the output files.
        public let kMSKey: String?
        /// The language code of the input documents.
        public let languageCode: LanguageCode?
        /// The path to the file that describes the results of a batch job.
        public let manifestFilePath: String?
        /// A description of the status of a job.
        public let message: String?
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        /// The output data configuration that you supplied when you created the detection job.
        public let outputDataConfig: OutputDataConfig?
        /// The time that the detection job was submitted for processing.
        public let submitTime: Date?

        public init(dataAccessRoleArn: String? = nil, endTime: Date? = nil, expirationTime: Date? = nil, inputDataConfig: InputDataConfig? = nil, jobId: String? = nil, jobName: String? = nil, jobStatus: JobStatus? = nil, kMSKey: String? = nil, languageCode: LanguageCode? = nil, manifestFilePath: String? = nil, message: String? = nil, modelVersion: String? = nil, outputDataConfig: OutputDataConfig? = nil, submitTime: Date? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.endTime = endTime
            self.expirationTime = expirationTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.manifestFilePath = manifestFilePath
            self.message = message
            self.modelVersion = modelVersion
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "DataAccessRoleArn"
            case endTime = "EndTime"
            case expirationTime = "ExpirationTime"
            case inputDataConfig = "InputDataConfig"
            case jobId = "JobId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case kMSKey = "KMSKey"
            case languageCode = "LanguageCode"
            case manifestFilePath = "ManifestFilePath"
            case message = "Message"
            case modelVersion = "ModelVersion"
            case outputDataConfig = "OutputDataConfig"
            case submitTime = "SubmitTime"
        }
    }

    public struct DescribeEntitiesDetectionV2JobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartEntitiesDetectionV2Job operation returns this identifier in its response.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeEntitiesDetectionV2JobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribeICD10CMInferenceJobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartICD10CMInferenceJob operation returns this identifier in its response.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeICD10CMInferenceJobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribePHIDetectionJobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartPHIDetectionJob operation returns this identifier in its response.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribePHIDetectionJobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribeRxNormInferenceJobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartRxNormInferenceJob operation returns this identifier in its response.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeRxNormInferenceJobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DetectEntitiesRequest: AWSEncodableShape {
        ///  A UTF-8 text string containing the clinical content being examined for entities. Each string must contain fewer than 20,000 bytes of characters.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 20000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct DetectEntitiesResponse: AWSDecodableShape {
        ///  The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
        public let entities: [Entity]
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String
        ///  If the result of the previous request to DetectEntities was truncated, include the PaginationToken to fetch the next page of entities.
        public let paginationToken: String?
        ///  Attributes extracted from the input text that we were unable to relate to an entity.
        public let unmappedAttributes: [UnmappedAttribute]?

        public init(entities: [Entity], modelVersion: String, paginationToken: String? = nil, unmappedAttributes: [UnmappedAttribute]? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
            self.unmappedAttributes = unmappedAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
            case unmappedAttributes = "UnmappedAttributes"
        }
    }

    public struct DetectEntitiesV2Request: AWSEncodableShape {
        /// A UTF-8 string containing the clinical content being examined for entities. Each string must contain fewer than 20,000 bytes of characters.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 20000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct DetectEntitiesV2Response: AWSDecodableShape {
        /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.
        public let entities: [Entity]
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String
        /// If the result to the DetectEntitiesV2 operation was truncated, include the PaginationToken to fetch the next page of entities.
        public let paginationToken: String?
        /// Attributes extracted from the input text that couldn't be related to an entity.
        public let unmappedAttributes: [UnmappedAttribute]?

        public init(entities: [Entity], modelVersion: String, paginationToken: String? = nil, unmappedAttributes: [UnmappedAttribute]? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
            self.unmappedAttributes = unmappedAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
            case unmappedAttributes = "UnmappedAttributes"
        }
    }

    public struct DetectPHIRequest: AWSEncodableShape {
        ///  A UTF-8 text string containing the clinical content being examined for PHI entities. Each string must contain fewer than 20,000 bytes of characters.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 20000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct DetectPHIResponse: AWSDecodableShape {
        ///  The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its detection.
        public let entities: [Entity]
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String
        ///  If the result of the previous request to DetectPHI was truncated, include the PaginationToken to fetch the next page of PHI entities.
        public let paginationToken: String?

        public init(entities: [Entity], modelVersion: String, paginationToken: String? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
        }
    }

    public struct Entity: AWSDecodableShape {
        ///  The extracted attributes that relate to this entity.
        public let attributes: [Attribute]?
        ///  The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of the entity.
        public let category: EntityType?
        ///  The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        ///  The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public let score: Float?
        ///  The segment of input text extracted as this entity.
        public let text: String?
        /// Contextual information for the entity.
        public let traits: [Trait]?
        ///  Describes the specific type of entity with category of entities.
        public let type: EntitySubType?

        public init(attributes: [Attribute]? = nil, beginOffset: Int? = nil, category: EntityType? = nil, endOffset: Int? = nil, id: Int? = nil, score: Float? = nil, text: String? = nil, traits: [Trait]? = nil, type: EntitySubType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ICD10CMAttribute: AWSDecodableShape {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        /// The category of attribute. Can be either of DX_NAME or TIME_EXPRESSION.
        public let category: ICD10CMEntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public let relationshipScore: Float?
        /// The type of relationship between the entity and attribute. Type for the relationship can be either of OVERLAP or SYSTEM_ORGAN_SITE.
        public let relationshipType: ICD10CMRelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        /// The segment of input text which contains the detected attribute.
        public let text: String?
        /// The contextual information for the attribute. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public let traits: [ICD10CMTrait]?
        /// The type of attribute. InferICD10CM detects entities of the type DX_NAME.
        public let type: ICD10CMAttributeType?

        public init(beginOffset: Int? = nil, category: ICD10CMEntityType? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, relationshipType: ICD10CMRelationshipType? = nil, score: Float? = nil, text: String? = nil, traits: [ICD10CMTrait]? = nil, type: ICD10CMAttributeType? = nil) {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case relationshipType = "RelationshipType"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ICD10CMConcept: AWSDecodableShape {
        /// The ICD-10-CM code that identifies the concept found in the knowledge base from the Centers for Disease Control.
        public let code: String?
        /// The long description of the ICD-10-CM code in the ontology.
        public let description: String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to an ICD-10-CM concept.
        public let score: Float?

        public init(code: String? = nil, description: String? = nil, score: Float? = nil) {
            self.code = code
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case description = "Description"
            case score = "Score"
        }
    }

    public struct ICD10CMEntity: AWSDecodableShape {
        /// The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.
        public let attributes: [ICD10CMAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of the entity. InferICD10CM detects entities in the MEDICAL_CONDITION category.
        public let category: ICD10CMEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public let iCD10CMConcepts: [ICD10CMConcept]?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public let score: Float?
        /// The segment of input text that is matched to the detected entity.
        public let text: String?
        /// Provides Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public let traits: [ICD10CMTrait]?
        /// Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type DX_NAME and TIME_EXPRESSION.
        public let type: ICD10CMEntityType?

        public init(attributes: [ICD10CMAttribute]? = nil, beginOffset: Int? = nil, category: ICD10CMEntityCategory? = nil, endOffset: Int? = nil, iCD10CMConcepts: [ICD10CMConcept]? = nil, id: Int? = nil, score: Float? = nil, text: String? = nil, traits: [ICD10CMTrait]? = nil, type: ICD10CMEntityType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.iCD10CMConcepts = iCD10CMConcepts
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case iCD10CMConcepts = "ICD10CMConcepts"
            case id = "Id"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ICD10CMTrait: AWSDecodableShape {
        /// Provides a name or contextual description about the trait.
        public let name: ICD10CMTraitName?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as a trait.
        public let score: Float?

        public init(name: ICD10CMTraitName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct InferICD10CMRequest: AWSEncodableShape {
        /// The input text used for analysis. The input for InferICD10CM is a string from 1 to 10000 characters.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 10000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct InferICD10CMResponse: AWSDecodableShape {
        /// The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
        public let entities: [ICD10CMEntity]
        /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        /// If the result of the previous request to InferICD10CM was truncated, include the PaginationToken to fetch the next page of medical condition entities.
        public let paginationToken: String?

        public init(entities: [ICD10CMEntity], modelVersion: String? = nil, paginationToken: String? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
        }
    }

    public struct InferRxNormRequest: AWSEncodableShape {
        /// The input text used for analysis. The input for InferRxNorm is a string from 1 to 10000 characters.
        public let text: String

        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 10000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct InferRxNormResponse: AWSDecodableShape {
        /// The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
        public let entities: [RxNormEntity]
        /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        /// If the result of the previous request to InferRxNorm was truncated, include the PaginationToken to fetch the next page of medication entities.
        public let paginationToken: String?

        public init(entities: [RxNormEntity], modelVersion: String? = nil, paginationToken: String? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
        }
    }

    public struct InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the S3 bucket that contains the input data. The bucket must be in the same region as the API endpoint that you are calling. Each file in the document collection must be less than 40 KB. You can store a maximum of 30 GB in the bucket.
        public let s3Bucket: String
        /// The path to the input data files in the S3 bucket.
        public let s3Key: String?

        public init(s3Bucket: String, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9a-z\\.\\-_]*(?!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
        }
    }

    public struct ListEntitiesDetectionV2JobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEntitiesDetectionV2JobsResponse: AWSDecodableShape {
        /// A list containing the properties of each job returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListICD10CMInferenceJobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListICD10CMInferenceJobsResponse: AWSDecodableShape {
        /// A list containing the properties of each job that is returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListPHIDetectionJobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPHIDetectionJobsResponse: AWSDecodableShape {
        /// A list containing the properties of each job returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListRxNormInferenceJobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// Identifies the next page of results to return.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRxNormInferenceJobsResponse: AWSDecodableShape {
        /// The maximum number of results to return in each page. The default is 100.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// When you use the OutputDataConfig object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output.
        public let s3Bucket: String
        /// The path to the output data files in the S3 bucket. Amazon Comprehend Medical creates an output directory using the job ID so that the output from one job does not overwrite the output of another.
        public let s3Key: String?

        public init(s3Bucket: String, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9a-z\\.\\-_]*(?!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
        }
    }

    public struct RxNormAttribute: AWSDecodableShape {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has that the attribute is accurately linked to an entity.
        public let relationshipScore: Float?
        /// The level of confidence that Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        /// The segment of input text which corresponds to the detected attribute.
        public let text: String?
        /// Contextual information for the attribute. InferRxNorm recognizes the trait NEGATION for attributes, i.e. that the patient is not taking a specific dose or form of a medication.
        public let traits: [RxNormTrait]?
        /// The type of attribute. The types of attributes recognized by InferRxNorm are BRAND_NAME and GENERIC_NAME.
        public let type: RxNormAttributeType?

        public init(beginOffset: Int? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, score: Float? = nil, text: String? = nil, traits: [RxNormTrait]? = nil, type: RxNormAttributeType? = nil) {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct RxNormConcept: AWSDecodableShape {
        /// RxNorm concept ID, also known as the RxCUI.
        public let code: String?
        /// The description of the RxNorm concept.
        public let description: String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to the reported RxNorm concept.
        public let score: Float?

        public init(code: String? = nil, description: String? = nil, score: Float? = nil) {
            self.code = code
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case description = "Description"
            case score = "Score"
        }
    }

    public struct RxNormEntity: AWSDecodableShape {
        /// The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE, and STRENGTH.
        public let attributes: [RxNormAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        /// The category of the entity. The recognized categories are GENERIC or BRAND_NAME.
        public let category: RxNormEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        ///  The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public let rxNormConcepts: [RxNormConcept]?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public let score: Float?
        /// The segment of input text extracted from which the entity was detected.
        public let text: String?
        ///  Contextual information for the entity.
        public let traits: [RxNormTrait]?
        ///  Describes the specific type of entity. For InferRxNorm, the recognized entity type is MEDICATION.
        public let type: RxNormEntityType?

        public init(attributes: [RxNormAttribute]? = nil, beginOffset: Int? = nil, category: RxNormEntityCategory? = nil, endOffset: Int? = nil, id: Int? = nil, rxNormConcepts: [RxNormConcept]? = nil, score: Float? = nil, text: String? = nil, traits: [RxNormTrait]? = nil, type: RxNormEntityType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.rxNormConcepts = rxNormConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case rxNormConcepts = "RxNormConcepts"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct RxNormTrait: AWSDecodableShape {
        /// Provides a name or contextual description about the trait.
        public let name: RxNormTraitName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected trait.
        public let score: Float?

        public init(name: RxNormTraitName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct StartEntitiesDetectionV2JobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kMSKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        public init(clientRequestToken: String? = StartEntitiesDetectionV2JobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kMSKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, max: 2048)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, min: 1)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kMSKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartEntitiesDetectionV2JobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribeEntitiesDetectionV2Job operation.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartICD10CMInferenceJobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kMSKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        public init(clientRequestToken: String? = StartICD10CMInferenceJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kMSKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, max: 2048)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, min: 1)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kMSKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartICD10CMInferenceJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of a job, use this identifier with the StartICD10CMInferenceJob operation.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartPHIDetectionJobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kMSKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        public init(clientRequestToken: String? = StartPHIDetectionJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kMSKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, max: 2048)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, min: 1)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kMSKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartPHIDetectionJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribePHIDetectionJob operation.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartRxNormInferenceJobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kMSKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        public init(clientRequestToken: String? = StartRxNormInferenceJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kMSKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kMSKey = kMSKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, max: 2048)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, min: 1)
            try self.validate(self.kMSKey, name: "kMSKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kMSKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartRxNormInferenceJobResponse: AWSDecodableShape {
        /// The identifier of the job.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopEntitiesDetectionV2JobRequest: AWSEncodableShape {
        /// The identifier of the medical entities job to stop.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopEntitiesDetectionV2JobResponse: AWSDecodableShape {
        /// The identifier of the medical entities detection job that was stopped.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopICD10CMInferenceJobRequest: AWSEncodableShape {
        /// The identifier of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopICD10CMInferenceJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeICD10CMInferenceJob operation.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopPHIDetectionJobRequest: AWSEncodableShape {
        /// The identifier of the PHI detection job to stop.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopPHIDetectionJobResponse: AWSDecodableShape {
        /// The identifier of the PHI detection job that was stopped.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopRxNormInferenceJobRequest: AWSEncodableShape {
        /// The identifier of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopRxNormInferenceJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeRxNormInferenceJob operation.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct Trait: AWSDecodableShape {
        ///  Provides a name or contextual description about the trait.
        public let name: AttributeName?
        ///  The level of confidence that Amazon Comprehend Medical has in the accuracy of this trait.
        public let score: Float?

        public init(name: AttributeName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct UnmappedAttribute: AWSDecodableShape {
        ///  The specific attribute that has been extracted but not mapped to an entity.
        public let attribute: Attribute?
        ///  The type of the attribute, could be one of the following values: "MEDICATION", "MEDICAL_CONDITION", "ANATOMY", "TEST_AND_TREATMENT_PROCEDURE" or "PROTECTED_HEALTH_INFORMATION".
        public let type: EntityType?

        public init(attribute: Attribute? = nil, type: EntityType? = nil) {
            self.attribute = attribute
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
            case type = "Type"
        }
    }
}
