//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ComprehendMedical {
    // MARK: Enums

    public enum AttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case diagnosis = "DIAGNOSIS"
        case future = "FUTURE"
        case hypothetical = "HYPOTHETICAL"
        case lowConfidence = "LOW_CONFIDENCE"
        case negation = "NEGATION"
        case pastHistory = "PAST_HISTORY"
        case pertainsToFamily = "PERTAINS_TO_FAMILY"
        case sign = "SIGN"
        case symptom = "SYMPTOM"
        public var description: String { return self.rawValue }
    }

    public enum EntitySubType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acuity = "ACUITY"
        case address = "ADDRESS"
        case age = "AGE"
        case alcoholConsumption = "ALCOHOL_CONSUMPTION"
        case allergies = "ALLERGIES"
        case amount = "AMOUNT"
        case brandName = "BRAND_NAME"
        case contactPoint = "CONTACT_POINT"
        case date = "DATE"
        case direction = "DIRECTION"
        case dosage = "DOSAGE"
        case duration = "DURATION"
        case dxName = "DX_NAME"
        case email = "EMAIL"
        case form = "FORM"
        case frequency = "FREQUENCY"
        case gender = "GENDER"
        case genericName = "GENERIC_NAME"
        case id = "ID"
        case identifier = "IDENTIFIER"
        case name = "NAME"
        case phoneOrFax = "PHONE_OR_FAX"
        case procedureName = "PROCEDURE_NAME"
        case profession = "PROFESSION"
        case quality = "QUALITY"
        case quantity = "QUANTITY"
        case raceEthnicity = "RACE_ETHNICITY"
        case rate = "RATE"
        case recDrugUse = "REC_DRUG_USE"
        case routeOrMode = "ROUTE_OR_MODE"
        case strength = "STRENGTH"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case testName = "TEST_NAME"
        case testUnit = "TEST_UNIT"
        case testUnits = "TEST_UNITS"
        case testValue = "TEST_VALUE"
        case timeExpression = "TIME_EXPRESSION"
        case timeToDxName = "TIME_TO_DX_NAME"
        case timeToMedicationName = "TIME_TO_MEDICATION_NAME"
        case timeToProcedureName = "TIME_TO_PROCEDURE_NAME"
        case timeToTestName = "TIME_TO_TEST_NAME"
        case timeToTreatmentName = "TIME_TO_TREATMENT_NAME"
        case tobaccoUse = "TOBACCO_USE"
        case treatmentName = "TREATMENT_NAME"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum EntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anatomy = "ANATOMY"
        case behavioralEnvironmentalSocial = "BEHAVIORAL_ENVIRONMENTAL_SOCIAL"
        case medicalCondition = "MEDICAL_CONDITION"
        case medication = "MEDICATION"
        case protectedHealthInformation = "PROTECTED_HEALTH_INFORMATION"
        case testTreatmentProcedure = "TEST_TREATMENT_PROCEDURE"
        case timeExpression = "TIME_EXPRESSION"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acuity = "ACUITY"
        case direction = "DIRECTION"
        case quality = "QUALITY"
        case quantity = "QUANTITY"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case timeExpression = "TIME_EXPRESSION"
        case timeToDxName = "TIME_TO_DX_NAME"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMEntityCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case medicalCondition = "MEDICAL_CONDITION"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dxName = "DX_NAME"
        case timeExpression = "TIME_EXPRESSION"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMRelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case overlap = "OVERLAP"
        case quality = "QUALITY"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        public var description: String { return self.rawValue }
    }

    public enum ICD10CMTraitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case diagnosis = "DIAGNOSIS"
        case hypothetical = "HYPOTHETICAL"
        case lowConfidence = "LOW_CONFIDENCE"
        case negation = "NEGATION"
        case pertainsToFamily = "PERTAINS_TO_FAMILY"
        case sign = "SIGN"
        case symptom = "SYMPTOM"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case partialSuccess = "PARTIAL_SUCCESS"
        case stopRequested = "STOP_REQUESTED"
        case stopped = "STOPPED"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case en = "en"
        public var description: String { return self.rawValue }
    }

    public enum RelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `for` = "FOR"
        case acuity = "ACUITY"
        case administeredVia = "ADMINISTERED_VIA"
        case amount = "AMOUNT"
        case direction = "DIRECTION"
        case dosage = "DOSAGE"
        case duration = "DURATION"
        case every = "EVERY"
        case form = "FORM"
        case frequency = "FREQUENCY"
        case negative = "NEGATIVE"
        case overlap = "OVERLAP"
        case quality = "QUALITY"
        case rate = "RATE"
        case routeOrMode = "ROUTE_OR_MODE"
        case strength = "STRENGTH"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case testUnit = "TEST_UNIT"
        case testUnits = "TEST_UNITS"
        case testValue = "TEST_VALUE"
        case usage = "USAGE"
        case withDosage = "WITH_DOSAGE"
        public var description: String { return self.rawValue }
    }

    public enum RxNormAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dosage = "DOSAGE"
        case duration = "DURATION"
        case form = "FORM"
        case frequency = "FREQUENCY"
        case rate = "RATE"
        case routeOrMode = "ROUTE_OR_MODE"
        case strength = "STRENGTH"
        public var description: String { return self.rawValue }
    }

    public enum RxNormEntityCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case medication = "MEDICATION"
        public var description: String { return self.rawValue }
    }

    public enum RxNormEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case brandName = "BRAND_NAME"
        case genericName = "GENERIC_NAME"
        public var description: String { return self.rawValue }
    }

    public enum RxNormTraitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case negation = "NEGATION"
        case pastHistory = "PAST_HISTORY"
        public var description: String { return self.rawValue }
    }

    public enum SNOMEDCTAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acuity = "ACUITY"
        case direction = "DIRECTION"
        case quality = "QUALITY"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case testUnit = "TEST_UNIT"
        case testValue = "TEST_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum SNOMEDCTEntityCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anatomy = "ANATOMY"
        case medicalCondition = "MEDICAL_CONDITION"
        case testTreatmentProcedure = "TEST_TREATMENT_PROCEDURE"
        public var description: String { return self.rawValue }
    }

    public enum SNOMEDCTEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dxName = "DX_NAME"
        case procedureName = "PROCEDURE_NAME"
        case testName = "TEST_NAME"
        case treatmentName = "TREATMENT_NAME"
        public var description: String { return self.rawValue }
    }

    public enum SNOMEDCTRelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acuity = "ACUITY"
        case direction = "DIRECTION"
        case quality = "QUALITY"
        case systemOrganSite = "SYSTEM_ORGAN_SITE"
        case testUnit = "TEST_UNIT"
        case testUnits = "TEST_UNITS"
        case testValue = "TEST_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum SNOMEDCTTraitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case diagnosis = "DIAGNOSIS"
        case future = "FUTURE"
        case hypothetical = "HYPOTHETICAL"
        case lowConfidence = "LOW_CONFIDENCE"
        case negation = "NEGATION"
        case pastHistory = "PAST_HISTORY"
        case pertainsToFamily = "PERTAINS_TO_FAMILY"
        case sign = "SIGN"
        case symptom = "SYMPTOM"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Attribute: AWSDecodableShape {
        ///  The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of attribute.
        public let category: EntityType?
        ///  The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        ///  The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        ///  The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public let relationshipScore: Float?
        /// The type of relationship between the entity and attribute. Type for the relationship is OVERLAP, indicating that the entity occurred at the same time as the Date_Expression.
        public let relationshipType: RelationshipType?
        ///  The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        ///  The segment of input text extracted as this attribute.
        public let text: String?
        ///  Contextual information for this attribute.
        public let traits: [Trait]?
        ///  The type of attribute.
        public let type: EntitySubType?

        @inlinable
        public init(beginOffset: Int? = nil, category: EntityType? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, relationshipType: RelationshipType? = nil, score: Float? = nil, text: String? = nil, traits: [Trait]? = nil, type: EntitySubType? = nil) {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case relationshipType = "RelationshipType"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct Characters: AWSDecodableShape {
        ///  The number of characters present in the input text document as processed by Amazon Comprehend Medical.
        public let originalTextCharacters: Int?

        @inlinable
        public init(originalTextCharacters: Int? = nil) {
            self.originalTextCharacters = originalTextCharacters
        }

        private enum CodingKeys: String, CodingKey {
            case originalTextCharacters = "OriginalTextCharacters"
        }
    }

    public struct ComprehendMedicalAsyncJobFilter: AWSEncodableShape {
        /// Filters on the name of the job.
        public let jobName: String?
        /// Filters the list of jobs based on job status. Returns only jobs with the specified status.
        public let jobStatus: JobStatus?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.
        public let submitTimeAfter: Date?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.
        public let submitTimeBefore: Date?

        @inlinable
        public init(jobName: String? = nil, jobStatus: JobStatus? = nil, submitTimeAfter: Date? = nil, submitTimeBefore: Date? = nil) {
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case submitTimeAfter = "SubmitTimeAfter"
            case submitTimeBefore = "SubmitTimeBefore"
        }
    }

    public struct ComprehendMedicalAsyncJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that gives Amazon Comprehend Medical read access to your input data.
        public let dataAccessRoleArn: String?
        /// The time that the detection job completed.
        public let endTime: Date?
        /// The date and time that job metadata is deleted from the server. Output files in your S3 bucket will not be deleted. After the metadata is deleted, the job will no longer appear in the results of the ListEntitiesDetectionV2Job or the ListPHIDetectionJobs operation.
        public let expirationTime: Date?
        /// The input data configuration that you supplied when you created the detection job.
        public let inputDataConfig: InputDataConfig?
        /// The identifier assigned to the detection job.
        public let jobId: String?
        /// The name that you assigned to the detection job.
        public let jobName: String?
        /// The current status of the detection job. If the status is FAILED, the Message field shows the reason for the failure.
        public let jobStatus: JobStatus?
        /// The AWS Key Management Service key, if any, used to encrypt the output files.
        public let kmsKey: String?
        /// The language code of the input documents.
        public let languageCode: LanguageCode?
        /// The path to the file that describes the results of a batch job.
        public let manifestFilePath: String?
        /// A description of the status of a job.
        public let message: String?
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        /// The output data configuration that you supplied when you created the detection job.
        public let outputDataConfig: OutputDataConfig?
        /// The time that the detection job was submitted for processing.
        public let submitTime: Date?

        @inlinable
        public init(dataAccessRoleArn: String? = nil, endTime: Date? = nil, expirationTime: Date? = nil, inputDataConfig: InputDataConfig? = nil, jobId: String? = nil, jobName: String? = nil, jobStatus: JobStatus? = nil, kmsKey: String? = nil, languageCode: LanguageCode? = nil, manifestFilePath: String? = nil, message: String? = nil, modelVersion: String? = nil, outputDataConfig: OutputDataConfig? = nil, submitTime: Date? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.endTime = endTime
            self.expirationTime = expirationTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.manifestFilePath = manifestFilePath
            self.message = message
            self.modelVersion = modelVersion
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "DataAccessRoleArn"
            case endTime = "EndTime"
            case expirationTime = "ExpirationTime"
            case inputDataConfig = "InputDataConfig"
            case jobId = "JobId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case kmsKey = "KMSKey"
            case languageCode = "LanguageCode"
            case manifestFilePath = "ManifestFilePath"
            case message = "Message"
            case modelVersion = "ModelVersion"
            case outputDataConfig = "OutputDataConfig"
            case submitTime = "SubmitTime"
        }
    }

    public struct DescribeEntitiesDetectionV2JobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartEntitiesDetectionV2Job operation returns this identifier in its response.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeEntitiesDetectionV2JobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        @inlinable
        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribeICD10CMInferenceJobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartICD10CMInferenceJob operation returns this identifier in its response.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeICD10CMInferenceJobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        @inlinable
        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribePHIDetectionJobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartPHIDetectionJob operation returns this identifier in its response.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribePHIDetectionJobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        @inlinable
        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribeRxNormInferenceJobRequest: AWSEncodableShape {
        /// The identifier that Amazon Comprehend Medical generated for the job. The StartRxNormInferenceJob operation returns this identifier in its response.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeRxNormInferenceJobResponse: AWSDecodableShape {
        /// An object that contains the properties associated with a detection job.
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        @inlinable
        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DescribeSNOMEDCTInferenceJobRequest: AWSEncodableShape {
        ///  The identifier that Amazon Comprehend Medical generated for the job. The StartSNOMEDCTInferenceJob operation returns this identifier in its response.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeSNOMEDCTInferenceJobResponse: AWSDecodableShape {
        public let comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties?

        @inlinable
        public init(comprehendMedicalAsyncJobProperties: ComprehendMedicalAsyncJobProperties? = nil) {
            self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
        }
    }

    public struct DetectEntitiesRequest: AWSEncodableShape {
        ///  A UTF-8 text string containing the clinical content being examined for entities.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 20000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct DetectEntitiesResponse: AWSDecodableShape {
        /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
        public let entities: [Entity]
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String
        /// If the result of the previous request to DetectEntities was truncated, include the PaginationToken to fetch the next page of entities.
        public let paginationToken: String?
        /// Attributes extracted from the input text that we were unable to relate to an entity.
        public let unmappedAttributes: [UnmappedAttribute]?

        @inlinable
        public init(entities: [Entity], modelVersion: String, paginationToken: String? = nil, unmappedAttributes: [UnmappedAttribute]? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
            self.unmappedAttributes = unmappedAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
            case unmappedAttributes = "UnmappedAttributes"
        }
    }

    public struct DetectEntitiesV2Request: AWSEncodableShape {
        /// A UTF-8 string containing the clinical content being examined for entities.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 20000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct DetectEntitiesV2Response: AWSDecodableShape {
        /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.
        public let entities: [Entity]
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String
        /// If the result to the DetectEntitiesV2 operation was truncated, include the PaginationToken to fetch the next page of entities.
        public let paginationToken: String?
        /// Attributes extracted from the input text that couldn't be related to an entity.
        public let unmappedAttributes: [UnmappedAttribute]?

        @inlinable
        public init(entities: [Entity], modelVersion: String, paginationToken: String? = nil, unmappedAttributes: [UnmappedAttribute]? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
            self.unmappedAttributes = unmappedAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
            case unmappedAttributes = "UnmappedAttributes"
        }
    }

    public struct DetectPHIRequest: AWSEncodableShape {
        /// A UTF-8 text string containing the clinical content being examined for PHI entities.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 20000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct DetectPHIResponse: AWSDecodableShape {
        /// The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its detection.
        public let entities: [Entity]
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String
        /// If the result of the previous request to DetectPHI was truncated, include the PaginationToken to fetch the next page of PHI entities.
        public let paginationToken: String?

        @inlinable
        public init(entities: [Entity], modelVersion: String, paginationToken: String? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
        }
    }

    public struct Entity: AWSDecodableShape {
        ///  The extracted attributes that relate to this entity.
        public let attributes: [Attribute]?
        ///  The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of the entity.
        public let category: EntityType?
        ///  The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        ///  The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public let score: Float?
        ///  The segment of input text extracted as this entity.
        public let text: String?
        /// Contextual information for the entity.
        public let traits: [Trait]?
        ///  Describes the specific type of entity with category of entities.
        public let type: EntitySubType?

        @inlinable
        public init(attributes: [Attribute]? = nil, beginOffset: Int? = nil, category: EntityType? = nil, endOffset: Int? = nil, id: Int? = nil, score: Float? = nil, text: String? = nil, traits: [Trait]? = nil, type: EntitySubType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ICD10CMAttribute: AWSDecodableShape {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        /// The category of attribute. Can be either of DX_NAME or TIME_EXPRESSION.
        public let category: ICD10CMEntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public let relationshipScore: Float?
        /// The type of relationship between the entity and attribute. Type for the relationship can be either of OVERLAP or SYSTEM_ORGAN_SITE.
        public let relationshipType: ICD10CMRelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        /// The segment of input text which contains the detected attribute.
        public let text: String?
        /// The contextual information for the attribute. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public let traits: [ICD10CMTrait]?
        /// The type of attribute. InferICD10CM detects entities of the type DX_NAME.
        public let type: ICD10CMAttributeType?

        @inlinable
        public init(beginOffset: Int? = nil, category: ICD10CMEntityType? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, relationshipType: ICD10CMRelationshipType? = nil, score: Float? = nil, text: String? = nil, traits: [ICD10CMTrait]? = nil, type: ICD10CMAttributeType? = nil) {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case relationshipType = "RelationshipType"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ICD10CMConcept: AWSDecodableShape {
        /// The ICD-10-CM code that identifies the concept found in the knowledge base from the Centers for Disease Control.
        public let code: String?
        /// The long description of the ICD-10-CM code in the ontology.
        public let description: String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to an ICD-10-CM concept.
        public let score: Float?

        @inlinable
        public init(code: String? = nil, description: String? = nil, score: Float? = nil) {
            self.code = code
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case description = "Description"
            case score = "Score"
        }
    }

    public struct ICD10CMEntity: AWSDecodableShape {
        /// The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.
        public let attributes: [ICD10CMAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of the entity. InferICD10CM detects entities in the MEDICAL_CONDITION category.
        public let category: ICD10CMEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public let icd10cmConcepts: [ICD10CMConcept]?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public let score: Float?
        /// The segment of input text that is matched to the detected entity.
        public let text: String?
        /// Provides Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public let traits: [ICD10CMTrait]?
        /// Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type DX_NAME and TIME_EXPRESSION.
        public let type: ICD10CMEntityType?

        @inlinable
        public init(attributes: [ICD10CMAttribute]? = nil, beginOffset: Int? = nil, category: ICD10CMEntityCategory? = nil, endOffset: Int? = nil, icd10cmConcepts: [ICD10CMConcept]? = nil, id: Int? = nil, score: Float? = nil, text: String? = nil, traits: [ICD10CMTrait]? = nil, type: ICD10CMEntityType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.icd10cmConcepts = icd10cmConcepts
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case icd10cmConcepts = "ICD10CMConcepts"
            case id = "Id"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct ICD10CMTrait: AWSDecodableShape {
        /// Provides a name or contextual description about the trait.
        public let name: ICD10CMTraitName?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as a trait.
        public let score: Float?

        @inlinable
        public init(name: ICD10CMTraitName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct InferICD10CMRequest: AWSEncodableShape {
        /// The input text used for analysis.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 10000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct InferICD10CMResponse: AWSDecodableShape {
        /// The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
        public let entities: [ICD10CMEntity]
        /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        /// If the result of the previous request to InferICD10CM was truncated, include the PaginationToken to fetch the next page of medical condition entities.
        public let paginationToken: String?

        @inlinable
        public init(entities: [ICD10CMEntity], modelVersion: String? = nil, paginationToken: String? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
        }
    }

    public struct InferRxNormRequest: AWSEncodableShape {
        /// The input text used for analysis.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 10000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct InferRxNormResponse: AWSDecodableShape {
        /// The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
        public let entities: [RxNormEntity]
        /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        /// If the result of the previous request to InferRxNorm was truncated, include the PaginationToken to fetch the next page of medication entities.
        public let paginationToken: String?

        @inlinable
        public init(entities: [RxNormEntity], modelVersion: String? = nil, paginationToken: String? = nil) {
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
        }
    }

    public struct InferSNOMEDCTRequest: AWSEncodableShape {
        /// The input text to be analyzed using InferSNOMEDCT.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 10000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct InferSNOMEDCTResponse: AWSDecodableShape {
        ///  The number of characters in the input request documentation.
        public let characters: Characters?
        ///  The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
        public let entities: [SNOMEDCTEntity]
        ///  The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
        public let modelVersion: String?
        ///  If the result of the request is truncated, the pagination token can be used to fetch the next page of entities.
        public let paginationToken: String?
        ///  The details of the SNOMED-CT revision, including the edition, language, and version date.
        public let snomedctDetails: SNOMEDCTDetails?

        @inlinable
        public init(characters: Characters? = nil, entities: [SNOMEDCTEntity], modelVersion: String? = nil, paginationToken: String? = nil, snomedctDetails: SNOMEDCTDetails? = nil) {
            self.characters = characters
            self.entities = entities
            self.modelVersion = modelVersion
            self.paginationToken = paginationToken
            self.snomedctDetails = snomedctDetails
        }

        private enum CodingKeys: String, CodingKey {
            case characters = "Characters"
            case entities = "Entities"
            case modelVersion = "ModelVersion"
            case paginationToken = "PaginationToken"
            case snomedctDetails = "SNOMEDCTDetails"
        }
    }

    public struct InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the S3 bucket that contains the input data. The bucket must be in the same region as the API endpoint that you are calling.
        public let s3Bucket: String
        /// The path to the input data files in the S3 bucket.
        public let s3Key: String?

        @inlinable
        public init(s3Bucket: String, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9a-z\\.\\-_]*(?!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
        }
    }

    public struct ListEntitiesDetectionV2JobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEntitiesDetectionV2JobsResponse: AWSDecodableShape {
        /// A list containing the properties of each job returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListICD10CMInferenceJobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListICD10CMInferenceJobsResponse: AWSDecodableShape {
        /// A list containing the properties of each job that is returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListPHIDetectionJobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPHIDetectionJobsResponse: AWSDecodableShape {
        /// A list containing the properties of each job returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListRxNormInferenceJobsRequest: AWSEncodableShape {
        /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
        public let filter: ComprehendMedicalAsyncJobFilter?
        /// Identifies the next page of results to return.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRxNormInferenceJobsResponse: AWSDecodableShape {
        /// The maximum number of results to return in each page. The default is 100.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListSNOMEDCTInferenceJobsRequest: AWSEncodableShape {
        public let filter: ComprehendMedicalAsyncJobFilter?
        ///  The maximum number of results to return in each page. The default is 100.
        public let maxResults: Int?
        ///  Identifies the next page of InferSNOMEDCT results to return.
        public let nextToken: String?

        @inlinable
        public init(filter: ComprehendMedicalAsyncJobFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListSNOMEDCTInferenceJobsResponse: AWSDecodableShape {
        ///  A list containing the properties of each job that is returned.
        public let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]?
        ///  Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalAsyncJobProperties]? = nil, nextToken: String? = nil) {
            self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// When you use the OutputDataConfig object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output.
        public let s3Bucket: String
        /// The path to the output data files in the S3 bucket. Amazon Comprehend Medical creates an output directory using the job ID so that the output from one job does not overwrite the output of another.
        public let s3Key: String?

        @inlinable
        public init(s3Bucket: String, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[0-9a-z\\.\\-_]*(?!\\.)$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
        }
    }

    public struct RxNormAttribute: AWSDecodableShape {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The level of confidence that Amazon Comprehend Medical has that the attribute is accurately linked to an entity.
        public let relationshipScore: Float?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        /// The segment of input text which corresponds to the detected attribute.
        public let text: String?
        /// Contextual information for the attribute. InferRxNorm recognizes the trait NEGATION for attributes, i.e. that the patient is not taking a specific dose or form of a medication.
        public let traits: [RxNormTrait]?
        /// The type of attribute. The types of attributes recognized by InferRxNorm are BRAND_NAME and GENERIC_NAME.
        public let type: RxNormAttributeType?

        @inlinable
        public init(beginOffset: Int? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, score: Float? = nil, text: String? = nil, traits: [RxNormTrait]? = nil, type: RxNormAttributeType? = nil) {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct RxNormConcept: AWSDecodableShape {
        /// RxNorm concept ID, also known as the RxCUI.
        public let code: String?
        /// The description of the RxNorm concept.
        public let description: String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to the reported RxNorm concept.
        public let score: Float?

        @inlinable
        public init(code: String? = nil, description: String? = nil, score: Float? = nil) {
            self.code = code
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case description = "Description"
            case score = "Score"
        }
    }

    public struct RxNormEntity: AWSDecodableShape {
        /// The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE, and STRENGTH.
        public let attributes: [RxNormAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        /// The category of the entity. The recognized categories are GENERIC or BRAND_NAME.
        public let category: RxNormEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        /// The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public let rxNormConcepts: [RxNormConcept]?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public let score: Float?
        /// The segment of input text extracted from which the entity was detected.
        public let text: String?
        /// Contextual information for the entity.
        public let traits: [RxNormTrait]?
        ///  Describes the specific type of entity. For InferRxNorm, the recognized entity type is MEDICATION.
        public let type: RxNormEntityType?

        @inlinable
        public init(attributes: [RxNormAttribute]? = nil, beginOffset: Int? = nil, category: RxNormEntityCategory? = nil, endOffset: Int? = nil, id: Int? = nil, rxNormConcepts: [RxNormConcept]? = nil, score: Float? = nil, text: String? = nil, traits: [RxNormTrait]? = nil, type: RxNormEntityType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.rxNormConcepts = rxNormConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case rxNormConcepts = "RxNormConcepts"
            case score = "Score"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct RxNormTrait: AWSDecodableShape {
        /// Provides a name or contextual description about the trait.
        public let name: RxNormTraitName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected trait.
        public let score: Float?

        @inlinable
        public init(name: RxNormTraitName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct SNOMEDCTAttribute: AWSDecodableShape {
        ///  The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of the detected attribute. Possible categories include MEDICAL_CONDITION, ANATOMY, and TEST_TREATMENT_PROCEDURE.
        public let category: SNOMEDCTEntityCategory?
        ///  The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        ///  The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        ///  The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public let relationshipScore: Float?
        ///  The type of relationship that exists between the entity and the related attribute.
        public let relationshipType: SNOMEDCTRelationshipType?
        ///  The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public let score: Float?
        ///  The SNOMED-CT concepts specific to an attribute, along with a score indicating the likelihood of the match.
        public let snomedctConcepts: [SNOMEDCTConcept]?
        ///  The segment of input text extracted as this attribute.
        public let text: String?
        ///  Contextual information for an attribute. Examples include signs, symptoms, diagnosis, and negation.
        public let traits: [SNOMEDCTTrait]?
        ///  The type of attribute. Possible types include DX_NAME, ACUITY, DIRECTION, SYSTEM_ORGAN_SITE,TEST_NAME, TEST_VALUE, TEST_UNIT, PROCEDURE_NAME, and TREATMENT_NAME.
        public let type: SNOMEDCTAttributeType?

        @inlinable
        public init(beginOffset: Int? = nil, category: SNOMEDCTEntityCategory? = nil, endOffset: Int? = nil, id: Int? = nil, relationshipScore: Float? = nil, relationshipType: SNOMEDCTRelationshipType? = nil, score: Float? = nil, snomedctConcepts: [SNOMEDCTConcept]? = nil, text: String? = nil, traits: [SNOMEDCTTrait]? = nil, type: SNOMEDCTAttributeType? = nil) {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.snomedctConcepts = snomedctConcepts
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case relationshipScore = "RelationshipScore"
            case relationshipType = "RelationshipType"
            case score = "Score"
            case snomedctConcepts = "SNOMEDCTConcepts"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct SNOMEDCTConcept: AWSDecodableShape {
        ///  The numeric ID for the SNOMED-CT concept.
        public let code: String?
        ///  The description of the SNOMED-CT concept.
        public let description: String?
        ///  The level of confidence Amazon Comprehend Medical has that the entity should be linked to the identified SNOMED-CT concept.
        public let score: Float?

        @inlinable
        public init(code: String? = nil, description: String? = nil, score: Float? = nil) {
            self.code = code
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case description = "Description"
            case score = "Score"
        }
    }

    public struct SNOMEDCTDetails: AWSDecodableShape {
        ///  The edition of SNOMED-CT used. The edition used for the InferSNOMEDCT editions is the US edition.
        public let edition: String?
        ///  The language used in the SNOMED-CT ontology. All Amazon Comprehend Medical operations are US English (en).
        public let language: String?
        ///  The version date of the SNOMED-CT ontology used.
        public let versionDate: String?

        @inlinable
        public init(edition: String? = nil, language: String? = nil, versionDate: String? = nil) {
            self.edition = edition
            self.language = language
            self.versionDate = versionDate
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
            case language = "Language"
            case versionDate = "VersionDate"
        }
    }

    public struct SNOMEDCTEntity: AWSDecodableShape {
        ///  An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken.
        public let attributes: [SNOMEDCTAttribute]?
        ///  The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public let beginOffset: Int?
        ///  The category of the detected entity. Possible categories are MEDICAL_CONDITION, ANATOMY, or TEST_TREATMENT_PROCEDURE.
        public let category: SNOMEDCTEntityCategory?
        ///  The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public let endOffset: Int?
        ///  The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public let id: Int?
        ///  The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public let score: Float?
        ///  The SNOMED concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public let snomedctConcepts: [SNOMEDCTConcept]?
        ///  The segment of input text extracted as this entity.
        public let text: String?
        ///  Contextual information for the entity.
        public let traits: [SNOMEDCTTrait]?
        ///  Describes the specific type of entity with category of entities. Possible types include DX_NAME, ACUITY, DIRECTION, SYSTEM_ORGAN_SITE, TEST_NAME, TEST_VALUE, TEST_UNIT, PROCEDURE_NAME, or TREATMENT_NAME.
        public let type: SNOMEDCTEntityType?

        @inlinable
        public init(attributes: [SNOMEDCTAttribute]? = nil, beginOffset: Int? = nil, category: SNOMEDCTEntityCategory? = nil, endOffset: Int? = nil, id: Int? = nil, score: Float? = nil, snomedctConcepts: [SNOMEDCTConcept]? = nil, text: String? = nil, traits: [SNOMEDCTTrait]? = nil, type: SNOMEDCTEntityType? = nil) {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.snomedctConcepts = snomedctConcepts
            self.text = text
            self.traits = traits
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case beginOffset = "BeginOffset"
            case category = "Category"
            case endOffset = "EndOffset"
            case id = "Id"
            case score = "Score"
            case snomedctConcepts = "SNOMEDCTConcepts"
            case text = "Text"
            case traits = "Traits"
            case type = "Type"
        }
    }

    public struct SNOMEDCTTrait: AWSDecodableShape {
        ///  The name or contextual description of a detected trait.
        public let name: SNOMEDCTTraitName?
        ///  The level of confidence that Amazon Comprehend Medical has in the accuracy of a detected trait.
        public let score: Float?

        @inlinable
        public init(name: SNOMEDCTTraitName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct StartEntitiesDetectionV2JobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one for you.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// The input configuration that specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kmsKey: String?
        /// The language of the input documents. All documents must be in the same language. Amazon Comprehend Medical processes files in US English (en).
        public let languageCode: LanguageCode
        /// The output configuration that specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientRequestToken: String? = StartEntitiesDetectionV2JobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kmsKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kmsKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartEntitiesDetectionV2JobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribeEntitiesDetectionV2Job operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartICD10CMInferenceJobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kmsKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientRequestToken: String? = StartICD10CMInferenceJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kmsKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kmsKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartICD10CMInferenceJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of a job, use this identifier with the StartICD10CMInferenceJob operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartPHIDetectionJobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kmsKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientRequestToken: String? = StartPHIDetectionJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kmsKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kmsKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartPHIDetectionJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribePHIDetectionJob operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartRxNormInferenceJobRequest: AWSEncodableShape {
        /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see  Role-Based Permissions Required for Asynchronous Operations.
        public let dataAccessRoleArn: String
        /// Specifies the format and location of the input data for the job.
        public let inputDataConfig: InputDataConfig
        /// The identifier of the job.
        public let jobName: String?
        /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kmsKey: String?
        /// The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        /// Specifies where to send the output files.
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientRequestToken: String? = StartRxNormInferenceJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kmsKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kmsKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartRxNormInferenceJobResponse: AWSDecodableShape {
        /// The identifier of the job.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartSNOMEDCTInferenceJobRequest: AWSEncodableShape {
        ///  A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
        public let clientRequestToken: String?
        ///  The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data.
        public let dataAccessRoleArn: String
        public let inputDataConfig: InputDataConfig
        ///  The user generated name the asynchronous InferSNOMEDCT job.
        public let jobName: String?
        ///  An AWS Key Management Service key used to encrypt your output files. If you do not specify a key, the files are written in plain text.
        public let kmsKey: String?
        ///  The language of the input documents. All documents must be in the same language.
        public let languageCode: LanguageCode
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientRequestToken: String? = StartSNOMEDCTInferenceJobRequest.idempotencyToken(), dataAccessRoleArn: String, inputDataConfig: InputDataConfig, jobName: String? = nil, kmsKey: String? = nil, languageCode: LanguageCode, outputDataConfig: OutputDataConfig) {
            self.clientRequestToken = clientRequestToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: ".*")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case kmsKey = "KMSKey"
            case languageCode = "LanguageCode"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartSNOMEDCTInferenceJobResponse: AWSDecodableShape {
        ///  The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopEntitiesDetectionV2JobRequest: AWSEncodableShape {
        /// The identifier of the medical entities job to stop.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopEntitiesDetectionV2JobResponse: AWSDecodableShape {
        /// The identifier of the medical entities detection job that was stopped.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopICD10CMInferenceJobRequest: AWSEncodableShape {
        /// The identifier of the job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopICD10CMInferenceJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeICD10CMInferenceJob operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopPHIDetectionJobRequest: AWSEncodableShape {
        /// The identifier of the PHI detection job to stop.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopPHIDetectionJobResponse: AWSDecodableShape {
        /// The identifier of the PHI detection job that was stopped.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopRxNormInferenceJobRequest: AWSEncodableShape {
        /// The identifier of the job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopRxNormInferenceJobResponse: AWSDecodableShape {
        /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeRxNormInferenceJob operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopSNOMEDCTInferenceJobRequest: AWSEncodableShape {
        ///  The job id of the asynchronous InferSNOMEDCT job to be stopped.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopSNOMEDCTInferenceJobResponse: AWSDecodableShape {
        ///  The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct Trait: AWSDecodableShape {
        ///  Provides a name or contextual description about the trait.
        public let name: AttributeName?
        ///  The level of confidence that Amazon Comprehend Medical has in the accuracy of this trait.
        public let score: Float?

        @inlinable
        public init(name: AttributeName? = nil, score: Float? = nil) {
            self.name = name
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case score = "Score"
        }
    }

    public struct UnmappedAttribute: AWSDecodableShape {
        ///  The specific attribute that has been extracted but not mapped to an entity.
        public let attribute: Attribute?
        ///  The type of the unmapped attribute, could be one of the following values: "MEDICATION", "MEDICAL_CONDITION", "ANATOMY", "TEST_AND_TREATMENT_PROCEDURE" or "PROTECTED_HEALTH_INFORMATION".
        public let type: EntityType?

        @inlinable
        public init(attribute: Attribute? = nil, type: EntityType? = nil) {
            self.attribute = attribute
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
            case type = "Type"
        }
    }
}

// MARK: - Errors

/// Error enum for ComprehendMedical
public struct ComprehendMedicalErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case invalidEncodingException = "InvalidEncodingException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case textSizeLimitExceededException = "TextSizeLimitExceededException"
        case tooManyRequestsException = "TooManyRequestsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ComprehendMedical
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The input text was not in valid UTF-8 character encoding. Check your text then retry your request.
    public static var invalidEncodingException: Self { .init(.invalidEncodingException) }
    ///  The request that you made is invalid. Check your request to determine why it's invalid and then retry the request.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The resource identified by the specified Amazon Resource Name (ARN) was not found. Check the ARN and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The Amazon Comprehend Medical service is temporarily unavailable. Please wait and then retry your request.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    ///  The size of the text you submitted exceeds the size limit. Reduce the size of the text or use a smaller document and then retry your request.
    public static var textSizeLimitExceededException: Self { .init(.textSizeLimitExceededException) }
    ///  You have made too many requests within a short period of time. Wait for a short time and then try your request again. Contact customer support for more information about a service limit increase.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The filter that you specified for the operation is invalid. Check the filter values that you entered and try your request again.
    public static var validationException: Self { .init(.validationException) }
}

extension ComprehendMedicalErrorType: Equatable {
    public static func == (lhs: ComprehendMedicalErrorType, rhs: ComprehendMedicalErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ComprehendMedicalErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
