//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension XRay {
    // MARK: Enums

    public enum EncryptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kms = "KMS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum InsightCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fault = "FAULT"
        public var description: String { return self.rawValue }
    }

    public enum InsightState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case running = "RUNNING"
        case scheduled = "SCHEDULED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum SamplingStrategyName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedRate = "FixedRate"
        case partialScan = "PartialScan"
        public var description: String { return self.rawValue }
    }

    public enum TimeRangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "Event"
        case service = "Service"
        case traceId = "TraceId"
        public var description: String { return self.rawValue }
    }

    public enum TraceFormatType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case otel = "OTEL"
        case xray = "XRAY"
        public var description: String { return self.rawValue }
    }

    public enum TraceSegmentDestination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudWatchLogs = "CloudWatchLogs"
        case xRay = "XRay"
        public var description: String { return self.rawValue }
    }

    public enum TraceSegmentDestinationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AnnotationValue: AWSDecodableShape, Sendable {
        /// Value for a Boolean annotation.
        case booleanValue(Bool)
        /// Value for a Number annotation.
        case numberValue(Double)
        /// Value for a String annotation.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .numberValue:
                let value = try container.decode(Double.self, forKey: .numberValue)
                self = .numberValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "BooleanValue"
            case numberValue = "NumberValue"
            case stringValue = "StringValue"
        }
    }

    // MARK: Shapes

    public struct Alias: AWSDecodableShape {
        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?
        /// The type of the alias.
        public let type: String?

        @inlinable
        public init(name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct AnomalousService: AWSDecodableShape {
        public let serviceId: ServiceId?

        @inlinable
        public init(serviceId: ServiceId? = nil) {
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case serviceId = "ServiceId"
        }
    }

    public struct AvailabilityZoneDetail: AWSDecodableShape {
        /// The name of a corresponding Availability Zone.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct BackendConnectionErrors: AWSEncodableShape {
        public let connectionRefusedCount: Int?
        public let httpCode4XXCount: Int?
        public let httpCode5XXCount: Int?
        public let otherCount: Int?
        public let timeoutCount: Int?
        public let unknownHostCount: Int?

        @inlinable
        public init(connectionRefusedCount: Int? = nil, httpCode4XXCount: Int? = nil, httpCode5XXCount: Int? = nil, otherCount: Int? = nil, timeoutCount: Int? = nil, unknownHostCount: Int? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.httpCode4XXCount = httpCode4XXCount
            self.httpCode5XXCount = httpCode5XXCount
            self.otherCount = otherCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
        }

        private enum CodingKeys: String, CodingKey {
            case connectionRefusedCount = "ConnectionRefusedCount"
            case httpCode4XXCount = "HTTPCode4XXCount"
            case httpCode5XXCount = "HTTPCode5XXCount"
            case otherCount = "OtherCount"
            case timeoutCount = "TimeoutCount"
            case unknownHostCount = "UnknownHostCount"
        }
    }

    public struct BatchGetTracesRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]

        @inlinable
        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct BatchGetTracesResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        @inlinable
        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traces = "Traces"
            case unprocessedTraceIds = "UnprocessedTraceIds"
        }
    }

    public struct CancelTraceRetrievalRequest: AWSEncodableShape {
        /// Retrieval token.
        public let retrievalToken: String

        @inlinable
        public init(retrievalToken: String) {
            self.retrievalToken = retrievalToken
        }

        public func validate(name: String) throws {
            try self.validate(self.retrievalToken, name: "retrievalToken", parent: name, max: 1020)
        }

        private enum CodingKeys: String, CodingKey {
            case retrievalToken = "RetrievalToken"
        }
    }

    public struct CancelTraceRetrievalResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        /// The filter expression defining criteria by which to group traces.
        public let filterExpression: String?
        /// The case-sensitive name of the new group. Default is a reserved name and names must be unique.
        public let groupName: String
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the new group or false to disable insights for the new group.   The NotificationsEnabled boolean can be set to true to enable insights notifications for the new group. Notifications may only be enabled on a group with InsightsEnabled set to true.
        public let insightsConfiguration: InsightsConfiguration?
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray group. For more information about ways to use tags, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use.
        public let tags: [Tag]?

        @inlinable
        public init(filterExpression: String? = nil, groupName: String, insightsConfiguration: InsightsConfiguration? = nil, tags: [Tag]? = nil) {
            self.filterExpression = filterExpression
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateGroupResult: AWSDecodableShape {
        /// The group that was created. Contains the name of the group that was created, the Amazon Resource Name (ARN) of the group that was generated based on the group name, the filter expression, and the insight configuration that was assigned to the group.
        public let group: Group?

        @inlinable
        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct CreateSamplingRuleRequest: AWSEncodableShape {
        /// The rule definition.
        public let samplingRule: SamplingRule
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray sampling rule. For more information about ways to use tags, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use.
        public let tags: [Tag]?

        @inlinable
        public init(samplingRule: SamplingRule, tags: [Tag]? = nil) {
            self.samplingRule = samplingRule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.samplingRule.validate(name: "\(name).samplingRule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRule = "SamplingRule"
            case tags = "Tags"
        }
    }

    public struct CreateSamplingRuleResult: AWSDecodableShape {
        /// The saved rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        @inlinable
        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        @inlinable
        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct DeleteGroupResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The name of the resource policy to delete.
        public let policyName: String
        /// Specifies a specific policy revision to delete. Provide a PolicyRevisionId to ensure an atomic delete operation. If the provided revision id does  not match the latest policy revision id, an InvalidPolicyRevisionIdException exception is returned.
        public let policyRevisionId: String?

        @inlinable
        public init(policyName: String, policyRevisionId: String? = nil) {
            self.policyName = policyName
            self.policyRevisionId = policyRevisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, max: 128)
            try self.validate(self.policyName, name: "policyName", parent: name, min: 1)
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "^[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct DeleteResourcePolicyResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSamplingRuleRequest: AWSEncodableShape {
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?

        @inlinable
        public init(ruleARN: String? = nil, ruleName: String? = nil) {
            self.ruleARN = ruleARN
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
        }
    }

    public struct DeleteSamplingRuleResult: AWSDecodableShape {
        /// The deleted rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        @inlinable
        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct Edge: AWSDecodableShape {
        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// Describes an asynchronous connection, with a value of link.
        public let edgeType: String?
        /// The end time of the last segment on the edge.
        public let endTime: Date?
        /// A histogram that maps the spread of event age when received by consumers.  Age is calculated each time an event is received. Only populated when EdgeType is  link.
        public let receivedEventAgeHistogram: [HistogramEntry]?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int?
        /// A histogram that maps the spread of client response times on an edge. Only populated for synchronous edges.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The start time of the first segment on the edge.
        public let startTime: Date?
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?

        @inlinable
        public init(aliases: [Alias]? = nil, edgeType: String? = nil, endTime: Date? = nil, receivedEventAgeHistogram: [HistogramEntry]? = nil, referenceId: Int? = nil, responseTimeHistogram: [HistogramEntry]? = nil, startTime: Date? = nil, summaryStatistics: EdgeStatistics? = nil) {
            self.aliases = aliases
            self.edgeType = edgeType
            self.endTime = endTime
            self.receivedEventAgeHistogram = receivedEventAgeHistogram
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case edgeType = "EdgeType"
            case endTime = "EndTime"
            case receivedEventAgeHistogram = "ReceivedEventAgeHistogram"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case startTime = "StartTime"
            case summaryStatistics = "SummaryStatistics"
        }
    }

    public struct EdgeStatistics: AWSDecodableShape {
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?

        @inlinable
        public init(errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, totalCount: Int64? = nil, totalResponseTime: Double? = nil) {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
        }
    }

    public struct EncryptionConfig: AWSDecodableShape {
        /// The ID of the KMS key used for encryption, if applicable.
        public let keyId: String?
        /// The encryption status. While the status is UPDATING, X-Ray may encrypt data with a combination of the new and old settings.
        public let status: EncryptionStatus?
        /// The type of encryption. Set to KMS for encryption with KMS keys. Set to NONE for default encryption.
        public let type: EncryptionType?

        @inlinable
        public init(keyId: String? = nil, status: EncryptionStatus? = nil, type: EncryptionType? = nil) {
            self.keyId = keyId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ErrorRootCause: AWSDecodableShape {
        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of services corresponding to an error. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [ErrorRootCauseService]?

        @inlinable
        public init(clientImpacting: Bool? = nil, services: [ErrorRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct ErrorRootCauseEntity: AWSDecodableShape {
        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        @inlinable
        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct ErrorRootCauseService: AWSDecodableShape {
        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service.
        public let entityPath: [ErrorRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let type: String?

        @inlinable
        public init(accountId: String? = nil, entityPath: [ErrorRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct ErrorStatistics: AWSDecodableShape {
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 429 throttling status code.
        public let throttleCount: Int64?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?

        @inlinable
        public init(otherCount: Int64? = nil, throttleCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case throttleCount = "ThrottleCount"
            case totalCount = "TotalCount"
        }
    }

    public struct FaultRootCause: AWSDecodableShape {
        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of corresponding services. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [FaultRootCauseService]?

        @inlinable
        public init(clientImpacting: Bool? = nil, services: [FaultRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct FaultRootCauseEntity: AWSDecodableShape {
        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        @inlinable
        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct FaultRootCauseService: AWSDecodableShape {
        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service.
        public let entityPath: [FaultRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let type: String?

        @inlinable
        public init(accountId: String? = nil, entityPath: [FaultRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct FaultStatistics: AWSDecodableShape {
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?

        @inlinable
        public init(otherCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case totalCount = "TotalCount"
        }
    }

    public struct ForecastStatistics: AWSDecodableShape {
        /// The upper limit of fault counts for a service.
        public let faultCountHigh: Int64?
        /// The lower limit of fault counts for a service.
        public let faultCountLow: Int64?

        @inlinable
        public init(faultCountHigh: Int64? = nil, faultCountLow: Int64? = nil) {
            self.faultCountHigh = faultCountHigh
            self.faultCountLow = faultCountLow
        }

        private enum CodingKeys: String, CodingKey {
            case faultCountHigh = "FaultCountHigh"
            case faultCountLow = "FaultCountLow"
        }
    }

    public struct GetEncryptionConfigRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEncryptionConfigResult: AWSDecodableShape {
        /// The encryption configuration document.
        public let encryptionConfig: EncryptionConfig?

        @inlinable
        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct GetGroupRequest: AWSEncodableShape {
        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        @inlinable
        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct GetGroupResult: AWSDecodableShape {
        /// The group that was requested. Contains the name of the group, the ARN of the group, the filter expression, and the insight configuration assigned to the group.
        public let group: Group?

        @inlinable
        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct GetGroupsRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetGroupsResult: AWSDecodableShape {
        /// The collection of all active groups.
        public let groups: [GroupSummary]?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(groups: [GroupSummary]? = nil, nextToken: String? = nil) {
            self.groups = groups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case nextToken = "NextToken"
        }
    }

    public struct GetIndexingRulesRequest: AWSEncodableShape {
        /// Specify the pagination token returned by a previous request to retrieve the next page of indexes.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetIndexingRulesResult: AWSDecodableShape {
        ///  Retrieves all indexing rules.
        public let indexingRules: [IndexingRule]?
        ///  Specify the pagination token returned by a previous request to retrieve the next page of indexes.
        public let nextToken: String?

        @inlinable
        public init(indexingRules: [IndexingRule]? = nil, nextToken: String? = nil) {
            self.indexingRules = indexingRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case indexingRules = "IndexingRules"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightEventsRequest: AWSEncodableShape {
        /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
        public let insightId: String
        /// Used to retrieve at most the specified value of events.
        public let maxResults: Int?
        /// Specify the pagination token returned by a previous request to retrieve the next page of events.
        public let nextToken: String?

        @inlinable
        public init(insightId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightId = insightId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightEventsResult: AWSDecodableShape {
        /// A detailed description of the event. This includes the time of the event, client and root cause impact statistics, and the top anomalous service at the time of the event.
        public let insightEvents: [InsightEvent]?
        /// Use this token to retrieve the next page of insight events.
        public let nextToken: String?

        @inlinable
        public init(insightEvents: [InsightEvent]? = nil, nextToken: String? = nil) {
            self.insightEvents = insightEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insightEvents = "InsightEvents"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightImpactGraphRequest: AWSEncodableShape {
        /// The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided. The time range between the start time and end time can't be more than six hours.
        public let endTime: Date
        /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
        public let insightId: String
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value provided and can't be more than 30 days old.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, insightId: String, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.insightId = insightId
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case insightId = "InsightId"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetInsightImpactGraphResult: AWSDecodableShape {
        /// The provided end time.
        public let endTime: Date?
        /// The insight's unique identifier.
        public let insightId: String?
        /// Pagination token.
        public let nextToken: String?
        /// The time, in Unix seconds, at which the service graph ended.
        public let serviceGraphEndTime: Date?
        /// The time, in Unix seconds, at which the service graph started.
        public let serviceGraphStartTime: Date?
        /// The Amazon Web Services instrumented services related to the insight.
        public let services: [InsightImpactGraphService]?
        /// The provided start time.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, insightId: String? = nil, nextToken: String? = nil, serviceGraphEndTime: Date? = nil, serviceGraphStartTime: Date? = nil, services: [InsightImpactGraphService]? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.insightId = insightId
            self.nextToken = nextToken
            self.serviceGraphEndTime = serviceGraphEndTime
            self.serviceGraphStartTime = serviceGraphStartTime
            self.services = services
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case insightId = "InsightId"
            case nextToken = "NextToken"
            case serviceGraphEndTime = "ServiceGraphEndTime"
            case serviceGraphStartTime = "ServiceGraphStartTime"
            case services = "Services"
            case startTime = "StartTime"
        }
    }

    public struct GetInsightRequest: AWSEncodableShape {
        /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
        public let insightId: String

        @inlinable
        public init(insightId: String) {
            self.insightId = insightId
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
        }
    }

    public struct GetInsightResult: AWSDecodableShape {
        /// The summary information of an insight.
        public let insight: Insight?

        @inlinable
        public init(insight: Insight? = nil) {
            self.insight = insight
        }

        private enum CodingKeys: String, CodingKey {
            case insight = "Insight"
        }
    }

    public struct GetInsightSummariesRequest: AWSEncodableShape {
        /// The end of the time frame in which the insights ended. The end time can't be more than 30 days old.
        public let endTime: Date
        /// The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.
        public let groupARN: String?
        /// The name of the group. Required if the GroupARN isn't provided.
        public let groupName: String?
        /// The maximum number of results to display.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?
        /// The beginning of the time frame in which the insights started. The start time can't be more than 30 days old.
        public let startTime: Date
        /// The list of insight states.
        public let states: [InsightState]?

        @inlinable
        public init(endTime: Date, groupARN: String? = nil, groupName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date, states: [InsightState]? = nil) {
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
            self.states = states
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.states, name: "states", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTime = "StartTime"
            case states = "States"
        }
    }

    public struct GetInsightSummariesResult: AWSDecodableShape {
        /// The summary of each insight within the group matching the provided filters. The summary contains the InsightID, start and end time, the root cause service, the root cause and client impact statistics, the top anomalous services, and the status of the insight.
        public let insightSummaries: [InsightSummary]?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(insightSummaries: [InsightSummary]? = nil, nextToken: String? = nil) {
            self.insightSummaries = insightSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insightSummaries = "InsightSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct GetRetrievedTracesGraphRequest: AWSEncodableShape {
        ///  Specify the pagination token returned by a previous request to retrieve the next page of indexes.
        public let nextToken: String?
        ///  Retrieval token.
        public let retrievalToken: String

        @inlinable
        public init(nextToken: String? = nil, retrievalToken: String) {
            self.nextToken = nextToken
            self.retrievalToken = retrievalToken
        }

        public func validate(name: String) throws {
            try self.validate(self.retrievalToken, name: "retrievalToken", parent: name, max: 1020)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retrievalToken = "RetrievalToken"
        }
    }

    public struct GetRetrievedTracesGraphResult: AWSDecodableShape {
        ///  Specify the pagination token returned by a previous request to retrieve the next page of indexes.
        public let nextToken: String?
        /// Status of the retrieval.
        public let retrievalStatus: RetrievalStatus?
        /// Retrieved services.
        public let services: [RetrievedService]?

        @inlinable
        public init(nextToken: String? = nil, retrievalStatus: RetrievalStatus? = nil, services: [RetrievedService]? = nil) {
            self.nextToken = nextToken
            self.retrievalStatus = retrievalStatus
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retrievalStatus = "RetrievalStatus"
            case services = "Services"
        }
    }

    public struct GetSamplingRulesRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingRulesResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Rule definitions and metadata.
        public let samplingRuleRecords: [SamplingRuleRecord]?

        @inlinable
        public init(nextToken: String? = nil, samplingRuleRecords: [SamplingRuleRecord]? = nil) {
            self.nextToken = nextToken
            self.samplingRuleRecords = samplingRuleRecords
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingRuleRecords = "SamplingRuleRecords"
        }
    }

    public struct GetSamplingStatisticSummariesRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingStatisticSummariesResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Information about the number of requests instrumented for each sampling rule.
        public let samplingStatisticSummaries: [SamplingStatisticSummary]?

        @inlinable
        public init(nextToken: String? = nil, samplingStatisticSummaries: [SamplingStatisticSummary]? = nil) {
            self.nextToken = nextToken
            self.samplingStatisticSummaries = samplingStatisticSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingStatisticSummaries = "SamplingStatisticSummaries"
        }
    }

    public struct GetSamplingTargetsRequest: AWSEncodableShape {
        /// Information about rules that the service is using to sample requests.
        public let samplingStatisticsDocuments: [SamplingStatisticsDocument]

        @inlinable
        public init(samplingStatisticsDocuments: [SamplingStatisticsDocument]) {
            self.samplingStatisticsDocuments = samplingStatisticsDocuments
        }

        public func validate(name: String) throws {
            try self.samplingStatisticsDocuments.forEach {
                try $0.validate(name: "\(name).samplingStatisticsDocuments[]")
            }
            try self.validate(self.samplingStatisticsDocuments, name: "samplingStatisticsDocuments", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
        }
    }

    public struct GetSamplingTargetsResult: AWSDecodableShape {
        /// The last time a user changed the sampling rule configuration. If the sampling rule configuration changed since the service last retrieved it, the service should call GetSamplingRules to get the latest version.
        public let lastRuleModification: Date?
        /// Updated rules that the service should use to sample requests.
        public let samplingTargetDocuments: [SamplingTargetDocument]?
        /// Information about SamplingStatisticsDocument that X-Ray could not process.
        public let unprocessedStatistics: [UnprocessedStatistics]?

        @inlinable
        public init(lastRuleModification: Date? = nil, samplingTargetDocuments: [SamplingTargetDocument]? = nil, unprocessedStatistics: [UnprocessedStatistics]? = nil) {
            self.lastRuleModification = lastRuleModification
            self.samplingTargetDocuments = samplingTargetDocuments
            self.unprocessedStatistics = unprocessedStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case lastRuleModification = "LastRuleModification"
            case samplingTargetDocuments = "SamplingTargetDocuments"
            case unprocessedStatistics = "UnprocessedStatistics"
        }
    }

    public struct GetServiceGraphRequest: AWSEncodableShape {
        /// The end of the timeframe for which to generate a graph.
        public let endTime: Date
        /// The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.
        public let groupARN: String?
        /// The name of a group based on which you want to generate a graph.
        public let groupName: String?
        /// Pagination token.
        public let nextToken: String?
        /// The start of the time frame for which to generate a graph.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, groupARN: String? = nil, groupName: String? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetServiceGraphResult: AWSDecodableShape {
        /// A flag indicating whether the group's filter expression has been consistent, or if the returned service graph may show traces from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// The end of the time frame for which the graph was generated.
        public let endTime: Date?
        /// Pagination token.
        public let nextToken: String?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// The start of the time frame for which the graph was generated.
        public let startTime: Date?

        @inlinable
        public init(containsOldGroupVersions: Bool? = nil, endTime: Date? = nil, nextToken: String? = nil, services: [Service]? = nil, startTime: Date? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.endTime = endTime
            self.nextToken = nextToken
            self.services = services
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case services = "Services"
            case startTime = "StartTime"
        }
    }

    public struct GetTimeSeriesServiceStatisticsRequest: AWSEncodableShape {
        /// The end of the time frame for which to aggregate statistics.
        public let endTime: Date
        /// A filter expression defining entities that will be aggregated for statistics. Supports ID, service, and edge functions. If no selector expression is specified, edge statistics are returned.
        public let entitySelectorExpression: String?
        /// The forecasted high and low fault count values. Forecast enabled requests require the EntitySelectorExpression ID be provided.
        public let forecastStatistics: Bool?
        /// The Amazon Resource Name (ARN) of the group for which to pull statistics from.
        public let groupARN: String?
        /// The case-sensitive name of the group for which to pull statistics from.
        public let groupName: String?
        /// Pagination token.
        public let nextToken: String?
        /// Aggregation period in seconds.
        public let period: Int?
        /// The start of the time frame for which to aggregate statistics.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, entitySelectorExpression: String? = nil, forecastStatistics: Bool? = nil, groupARN: String? = nil, groupName: String? = nil, nextToken: String? = nil, period: Int? = nil, startTime: Date) {
            self.endTime = endTime
            self.entitySelectorExpression = entitySelectorExpression
            self.forecastStatistics = forecastStatistics
            self.groupARN = groupARN
            self.groupName = groupName
            self.nextToken = nextToken
            self.period = period
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.entitySelectorExpression, name: "entitySelectorExpression", parent: name, max: 500)
            try self.validate(self.entitySelectorExpression, name: "entitySelectorExpression", parent: name, min: 1)
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case entitySelectorExpression = "EntitySelectorExpression"
            case forecastStatistics = "ForecastStatistics"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case nextToken = "NextToken"
            case period = "Period"
            case startTime = "StartTime"
        }
    }

    public struct GetTimeSeriesServiceStatisticsResult: AWSDecodableShape {
        /// A flag indicating whether or not a group's filter expression has been consistent, or if a returned aggregation might show statistics from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// Pagination token.
        public let nextToken: String?
        /// The collection of statistics.
        public let timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]?

        @inlinable
        public init(containsOldGroupVersions: Bool? = nil, nextToken: String? = nil, timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.nextToken = nextToken
            self.timeSeriesServiceStatistics = timeSeriesServiceStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case nextToken = "NextToken"
            case timeSeriesServiceStatistics = "TimeSeriesServiceStatistics"
        }
    }

    public struct GetTraceGraphRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]

        @inlinable
        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct GetTraceGraphResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// The services that have processed one of the specified requests.
        public let services: [Service]?

        @inlinable
        public init(nextToken: String? = nil, services: [Service]? = nil) {
            self.nextToken = nextToken
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case services = "Services"
        }
    }

    public struct GetTraceSegmentDestinationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetTraceSegmentDestinationResult: AWSDecodableShape {
        /// Retrieves the current destination.
        public let destination: TraceSegmentDestination?
        ///  Status of the retrieval.
        public let status: TraceSegmentDestinationStatus?

        @inlinable
        public init(destination: TraceSegmentDestination? = nil, status: TraceSegmentDestinationStatus? = nil) {
            self.destination = destination
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case status = "Status"
        }
    }

    public struct GetTraceSummariesRequest: AWSEncodableShape {
        /// The end of the time frame for which to retrieve traces.
        public let endTime: Date
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// A parameter to indicate whether to enable sampling on trace summaries. Input parameters are Name and Value.
        public let samplingStrategy: SamplingStrategy?
        /// The start of the time frame for which to retrieve traces.
        public let startTime: Date
        /// Query trace summaries by TraceId (trace start time), Event (trace update time), or Service (trace segment end time).
        public let timeRangeType: TimeRangeType?

        @inlinable
        public init(endTime: Date, filterExpression: String? = nil, nextToken: String? = nil, sampling: Bool? = nil, samplingStrategy: SamplingStrategy? = nil, startTime: Date, timeRangeType: TimeRangeType? = nil) {
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.nextToken = nextToken
            self.sampling = sampling
            self.samplingStrategy = samplingStrategy
            self.startTime = startTime
            self.timeRangeType = timeRangeType
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filterExpression = "FilterExpression"
            case nextToken = "NextToken"
            case sampling = "Sampling"
            case samplingStrategy = "SamplingStrategy"
            case startTime = "StartTime"
            case timeRangeType = "TimeRangeType"
        }
    }

    public struct GetTraceSummariesResult: AWSDecodableShape {
        /// The start time of this page of results.
        public let approximateTime: Date?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The total number of traces processed, including traces that did not match the specified filter expression.
        public let tracesProcessedCount: Int64?
        /// Trace IDs and annotations for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?

        @inlinable
        public init(approximateTime: Date? = nil, nextToken: String? = nil, tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil) {
            self.approximateTime = approximateTime
            self.nextToken = nextToken
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTime = "ApproximateTime"
            case nextToken = "NextToken"
            case tracesProcessedCount = "TracesProcessedCount"
            case traceSummaries = "TraceSummaries"
        }
    }

    public struct GraphLink: AWSDecodableShape {
        /// Destination traces of a link relationship.
        public let destinationTraceIds: [String]?
        /// Relationship of a trace to the corresponding service.
        public let referenceType: String?
        /// Source trace of a link relationship.
        public let sourceTraceId: String?

        @inlinable
        public init(destinationTraceIds: [String]? = nil, referenceType: String? = nil, sourceTraceId: String? = nil) {
            self.destinationTraceIds = destinationTraceIds
            self.referenceType = referenceType
            self.sourceTraceId = sourceTraceId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationTraceIds = "DestinationTraceIds"
            case referenceType = "ReferenceType"
            case sourceTraceId = "SourceTraceId"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?
        /// The Amazon Resource Name (ARN) of the group generated based on the GroupName.
        public let groupARN: String?
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.   The NotificationsEnabled boolean can be set to true to enable insights notifications through Amazon EventBridge for the group.
        public let insightsConfiguration: InsightsConfiguration?

        @inlinable
        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct GroupSummary: AWSDecodableShape {
        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?
        /// The ARN of the group generated based on the GroupName.
        public let groupARN: String?
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.   The NotificationsEnabled boolean can be set to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public let insightsConfiguration: InsightsConfiguration?

        @inlinable
        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct HistogramEntry: AWSDecodableShape {
        /// The prevalence of the entry.
        public let count: Int?
        /// The value of the entry.
        public let value: Double?

        @inlinable
        public init(count: Int? = nil, value: Double? = nil) {
            self.count = count
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case value = "Value"
        }
    }

    public struct Http: AWSDecodableShape {
        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int?
        /// The request URL.
        public let httpURL: String?
        /// The request's user agent string.
        public let userAgent: String?

        @inlinable
        public init(clientIp: String? = nil, httpMethod: String? = nil, httpStatus: Int? = nil, httpURL: String? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.httpURL = httpURL
            self.userAgent = userAgent
        }

        private enum CodingKeys: String, CodingKey {
            case clientIp = "ClientIp"
            case httpMethod = "HttpMethod"
            case httpStatus = "HttpStatus"
            case httpURL = "HttpURL"
            case userAgent = "UserAgent"
        }
    }

    public struct IndexingRule: AWSDecodableShape {
        /// Displays when the rule was last modified, in Unix time seconds.
        public let modifiedAt: Date?
        ///  The name of the indexing rule.
        public let name: String?
        ///  The indexing rule.
        public let rule: IndexingRuleValue?

        @inlinable
        public init(modifiedAt: Date? = nil, name: String? = nil, rule: IndexingRuleValue? = nil) {
            self.modifiedAt = modifiedAt
            self.name = name
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case modifiedAt = "ModifiedAt"
            case name = "Name"
            case rule = "Rule"
        }
    }

    public struct Insight: AWSDecodableShape {
        /// The categories that label and describe the type of insight.
        public let categories: [InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let clientRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public let endTime: Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public let groupARN: String?
        /// The name of the group  that the insight belongs to.
        public let groupName: String?
        /// The insights unique identifier.
        public let insightId: String?
        public let rootCauseServiceId: ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public let startTime: Date?
        /// The current state of the insight.
        public let state: InsightState?
        /// A brief description of the insight.
        public let summary: String?
        /// The service within the insight that is most impacted by the incident.
        public let topAnomalousServices: [AnomalousService]?

        @inlinable
        public init(categories: [InsightCategory]? = nil, clientRequestImpactStatistics: RequestImpactStatistics? = nil, endTime: Date? = nil, groupARN: String? = nil, groupName: String? = nil, insightId: String? = nil, rootCauseServiceId: ServiceId? = nil, rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil, startTime: Date? = nil, state: InsightState? = nil, summary: String? = nil, topAnomalousServices: [AnomalousService]? = nil) {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightId = "InsightId"
            case rootCauseServiceId = "RootCauseServiceId"
            case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
            case startTime = "StartTime"
            case state = "State"
            case summary = "Summary"
            case topAnomalousServices = "TopAnomalousServices"
        }
    }

    public struct InsightEvent: AWSDecodableShape {
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let clientRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the event was recorded.
        public let eventTime: Date?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
        /// A brief description of the event.
        public let summary: String?
        /// The service during the event that is most impacted by the incident.
        public let topAnomalousServices: [AnomalousService]?

        @inlinable
        public init(clientRequestImpactStatistics: RequestImpactStatistics? = nil, eventTime: Date? = nil, rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil, summary: String? = nil, topAnomalousServices: [AnomalousService]? = nil) {
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.eventTime = eventTime
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
            case eventTime = "EventTime"
            case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
            case summary = "Summary"
            case topAnomalousServices = "TopAnomalousServices"
        }
    }

    public struct InsightImpactGraphEdge: AWSDecodableShape {
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int?

        @inlinable
        public init(referenceId: Int? = nil) {
            self.referenceId = referenceId
        }

        private enum CodingKeys: String, CodingKey {
            case referenceId = "ReferenceId"
        }
    }

    public struct InsightImpactGraphService: AWSDecodableShape {
        /// Identifier of the Amazon Web Services account in which the service runs.
        public let accountId: String?
        /// Connections to downstream services.
        public let edges: [InsightImpactGraphEdge]?
        /// The canonical name of the service.
        public let name: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int?
        /// Identifier for the service. Unique within the service map.   Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.    Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    remote - A downstream service of indeterminate type.
        public let type: String?

        @inlinable
        public init(accountId: String? = nil, edges: [InsightImpactGraphEdge]? = nil, name: String? = nil, names: [String]? = nil, referenceId: Int? = nil, type: String? = nil) {
            self.accountId = accountId
            self.edges = edges
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case edges = "Edges"
            case name = "Name"
            case names = "Names"
            case referenceId = "ReferenceId"
            case type = "Type"
        }
    }

    public struct InsightSummary: AWSDecodableShape {
        ///  Categories The categories that label and describe the type of insight.
        public let categories: [InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let clientRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public let endTime: Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public let groupARN: String?
        /// The name of the group  that the insight belongs to.
        public let groupName: String?
        /// The insights unique identifier.
        public let insightId: String?
        /// The time, in Unix seconds, that the insight was last updated.
        public let lastUpdateTime: Date?
        public let rootCauseServiceId: ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public let startTime: Date?
        /// The current state of the insight.
        public let state: InsightState?
        /// A brief description of the insight.
        public let summary: String?
        /// The service within the insight that is most impacted by the incident.
        public let topAnomalousServices: [AnomalousService]?

        @inlinable
        public init(categories: [InsightCategory]? = nil, clientRequestImpactStatistics: RequestImpactStatistics? = nil, endTime: Date? = nil, groupARN: String? = nil, groupName: String? = nil, insightId: String? = nil, lastUpdateTime: Date? = nil, rootCauseServiceId: ServiceId? = nil, rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil, startTime: Date? = nil, state: InsightState? = nil, summary: String? = nil, topAnomalousServices: [AnomalousService]? = nil) {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.lastUpdateTime = lastUpdateTime
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightId = "InsightId"
            case lastUpdateTime = "LastUpdateTime"
            case rootCauseServiceId = "RootCauseServiceId"
            case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
            case startTime = "StartTime"
            case state = "State"
            case summary = "Summary"
            case topAnomalousServices = "TopAnomalousServices"
        }
    }

    public struct InsightsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Set the InsightsEnabled value to true to enable insights or false to disable insights.
        public let insightsEnabled: Bool?
        /// Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public let notificationsEnabled: Bool?

        @inlinable
        public init(insightsEnabled: Bool? = nil, notificationsEnabled: Bool? = nil) {
            self.insightsEnabled = insightsEnabled
            self.notificationsEnabled = notificationsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case insightsEnabled = "InsightsEnabled"
            case notificationsEnabled = "NotificationsEnabled"
        }
    }

    public struct InstanceIdDetail: AWSDecodableShape {
        /// The ID of a corresponding EC2 instance.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct ListResourcePoliciesRequest: AWSEncodableShape {
        /// Not currently supported.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ListResourcePoliciesResult: AWSDecodableShape {
        /// Pagination token. Not currently supported.
        public let nextToken: String?
        /// The list of resource policies in the target Amazon Web Services account.
        public let resourcePolicies: [ResourcePolicy]?

        @inlinable
        public init(nextToken: String? = nil, resourcePolicies: [ResourcePolicy]? = nil) {
            self.nextToken = nextToken
            self.resourcePolicies = resourcePolicies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourcePolicies = "ResourcePolicies"
        }
    }

    public struct ListRetrievedTracesRequest: AWSEncodableShape {
        ///  Specify the pagination token returned by a previous request to retrieve the next page of indexes.
        public let nextToken: String?
        /// Retrieval token.
        public let retrievalToken: String
        /// Format of the requested traces.
        public let traceFormat: TraceFormatType?

        @inlinable
        public init(nextToken: String? = nil, retrievalToken: String, traceFormat: TraceFormatType? = nil) {
            self.nextToken = nextToken
            self.retrievalToken = retrievalToken
            self.traceFormat = traceFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.retrievalToken, name: "retrievalToken", parent: name, max: 1020)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retrievalToken = "RetrievalToken"
            case traceFormat = "TraceFormat"
        }
    }

    public struct ListRetrievedTracesResult: AWSDecodableShape {
        ///  Specify the pagination token returned by a previous request to retrieve the next page of indexes.
        public let nextToken: String?
        ///  Status of the retrieval.
        public let retrievalStatus: RetrievalStatus?
        ///  Format of the requested traces.
        public let traceFormat: TraceFormatType?
        /// Full traces for the specified requests.
        public let traces: [RetrievedTrace]?

        @inlinable
        public init(nextToken: String? = nil, retrievalStatus: RetrievalStatus? = nil, traceFormat: TraceFormatType? = nil, traces: [RetrievedTrace]? = nil) {
            self.nextToken = nextToken
            self.retrievalStatus = retrievalStatus
            self.traceFormat = traceFormat
            self.traces = traces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retrievalStatus = "RetrievalStatus"
            case traceFormat = "TraceFormat"
            case traces = "Traces"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with  the current page of results as the value of this parameter to get the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String

        @inlinable
        public init(nextToken: String? = nil, resourceARN: String) {
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with  the current page of results to get the next page of results.
        public let nextToken: String?
        /// A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.
        public let tags: [Tag]?

        @inlinable
        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ProbabilisticRuleValue: AWSDecodableShape {
        ///  Applied sampling percentage of traceIds.
        public let actualSamplingPercentage: Double?
        ///  Configured sampling percentage of traceIds. Note that sampling can be subject to limits to ensure completeness of data.
        public let desiredSamplingPercentage: Double

        @inlinable
        public init(actualSamplingPercentage: Double? = nil, desiredSamplingPercentage: Double) {
            self.actualSamplingPercentage = actualSamplingPercentage
            self.desiredSamplingPercentage = desiredSamplingPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case actualSamplingPercentage = "ActualSamplingPercentage"
            case desiredSamplingPercentage = "DesiredSamplingPercentage"
        }
    }

    public struct ProbabilisticRuleValueUpdate: AWSEncodableShape {
        ///  Configured sampling percentage of traceIds. Note that sampling can be subject to limits to ensure completeness of data.
        public let desiredSamplingPercentage: Double

        @inlinable
        public init(desiredSamplingPercentage: Double) {
            self.desiredSamplingPercentage = desiredSamplingPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case desiredSamplingPercentage = "DesiredSamplingPercentage"
        }
    }

    public struct PutEncryptionConfigRequest: AWSEncodableShape {
        /// An Amazon Web Services KMS key in one of the following formats:    Alias - The name of the key. For example, alias/MyKey.    Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Amazon Web Services X-Ray does not support asymmetric KMS keys.    ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.   Omit this key if you set Type to NONE.
        public let keyId: String?
        /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
        public let type: EncryptionType

        @inlinable
        public init(keyId: String? = nil, type: EncryptionType) {
            self.keyId = keyId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.keyId, name: "keyId", parent: name, max: 3000)
            try self.validate(self.keyId, name: "keyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case type = "Type"
        }
    }

    public struct PutEncryptionConfigResult: AWSDecodableShape {
        /// The new encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        @inlinable
        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// A flag to indicate whether to bypass the resource policy lockout safety check.  Setting this value to true increases the risk that the policy becomes unmanageable. Do not set this value to true indiscriminately.  Use this parameter only when you include a policy in the request and you intend to prevent the principal that is making the request from making a subsequent PutResourcePolicy request. The default value is false.
        public let bypassPolicyLockoutCheck: Bool?
        /// The resource policy document, which can be up to 5kb in size.
        public let policyDocument: String
        /// The name of the resource policy. Must be unique within a specific Amazon Web Services account.
        public let policyName: String
        /// Specifies a specific policy revision, to ensure an atomic create operation. By default the resource policy is created if it does not exist, or updated with an incremented revision id.  The revision id is unique to each policy in the account. If the policy revision id does not match the latest revision id, the operation will fail with an InvalidPolicyRevisionIdException exception. You can also provide a  PolicyRevisionId of 0. In this case, the operation will fail with an InvalidPolicyRevisionIdException exception if a resource policy with the same name already exists.
        public let policyRevisionId: String?

        @inlinable
        public init(bypassPolicyLockoutCheck: Bool? = nil, policyDocument: String, policyName: String, policyRevisionId: String? = nil) {
            self.bypassPolicyLockoutCheck = bypassPolicyLockoutCheck
            self.policyDocument = policyDocument
            self.policyName = policyName
            self.policyRevisionId = policyRevisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, max: 128)
            try self.validate(self.policyName, name: "policyName", parent: name, min: 1)
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "^[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bypassPolicyLockoutCheck = "BypassPolicyLockoutCheck"
            case policyDocument = "PolicyDocument"
            case policyName = "PolicyName"
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct PutResourcePolicyResult: AWSDecodableShape {
        /// The resource policy document, as provided in the PutResourcePolicyRequest.
        public let resourcePolicy: ResourcePolicy?

        @inlinable
        public init(resourcePolicy: ResourcePolicy? = nil) {
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "ResourcePolicy"
        }
    }

    public struct PutTelemetryRecordsRequest: AWSEncodableShape {
        public let ec2InstanceId: String?
        public let hostname: String?
        public let resourceARN: String?
        public let telemetryRecords: [TelemetryRecord]

        @inlinable
        public init(ec2InstanceId: String? = nil, hostname: String? = nil, resourceARN: String? = nil, telemetryRecords: [TelemetryRecord]) {
            self.ec2InstanceId = ec2InstanceId
            self.hostname = hostname
            self.resourceARN = resourceARN
            self.telemetryRecords = telemetryRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2InstanceId, name: "ec2InstanceId", parent: name, max: 20)
            try self.validate(self.hostname, name: "hostname", parent: name, max: 255)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceId = "EC2InstanceId"
            case hostname = "Hostname"
            case resourceARN = "ResourceARN"
            case telemetryRecords = "TelemetryRecords"
        }
    }

    public struct PutTelemetryRecordsResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutTraceSegmentsRequest: AWSEncodableShape {
        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        @inlinable
        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case traceSegmentDocuments = "TraceSegmentDocuments"
        }
    }

    public struct PutTraceSegmentsResult: AWSDecodableShape {
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        @inlinable
        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceSegments = "UnprocessedTraceSegments"
        }
    }

    public struct RequestImpactStatistics: AWSDecodableShape {
        /// The number of requests that have resulted in a fault,
        public let faultCount: Int64?
        /// The number of successful requests.
        public let okCount: Int64?
        /// The total number of requests to the service.
        public let totalCount: Int64?

        @inlinable
        public init(faultCount: Int64? = nil, okCount: Int64? = nil, totalCount: Int64? = nil) {
            self.faultCount = faultCount
            self.okCount = okCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case faultCount = "FaultCount"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
        }
    }

    public struct ResourceARNDetail: AWSDecodableShape {
        /// The ARN of a corresponding resource.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceName = "ResourceName"
        }
    }

    public struct ResourcePolicy: AWSDecodableShape {
        /// When the policy was last updated, in Unix time seconds.
        public let lastUpdatedTime: Date?
        /// The resource policy document, which can be up to 5kb in size.
        public let policyDocument: String?
        /// The name of the resource policy. Must be unique within a specific Amazon Web Services account.
        public let policyName: String?
        /// Returns the current policy revision id for this policy name.
        public let policyRevisionId: String?

        @inlinable
        public init(lastUpdatedTime: Date? = nil, policyDocument: String? = nil, policyName: String? = nil, policyRevisionId: String? = nil) {
            self.lastUpdatedTime = lastUpdatedTime
            self.policyDocument = policyDocument
            self.policyName = policyName
            self.policyRevisionId = policyRevisionId
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdatedTime = "LastUpdatedTime"
            case policyDocument = "PolicyDocument"
            case policyName = "PolicyName"
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct ResponseTimeRootCause: AWSDecodableShape {
        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of corresponding services. A service identifies a segment and contains a name, account ID, type, and inferred flag.
        public let services: [ResponseTimeRootCauseService]?

        @inlinable
        public init(clientImpacting: Bool? = nil, services: [ResponseTimeRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct ResponseTimeRootCauseEntity: AWSDecodableShape {
        /// The type and messages of the exceptions.
        public let coverage: Double?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        @inlinable
        public init(coverage: Double? = nil, name: String? = nil, remote: Bool? = nil) {
            self.coverage = coverage
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case coverage = "Coverage"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct ResponseTimeRootCauseService: AWSDecodableShape {
        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service.
        public let entityPath: [ResponseTimeRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let type: String?

        @inlinable
        public init(accountId: String? = nil, entityPath: [ResponseTimeRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct RetrievedService: AWSDecodableShape {
        ///  Relation between two 2 services.
        public let links: [GraphLink]?
        public let service: Service?

        @inlinable
        public init(links: [GraphLink]? = nil, service: Service? = nil) {
            self.links = links
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case links = "Links"
            case service = "Service"
        }
    }

    public struct RetrievedTrace: AWSDecodableShape {
        ///  The length of time in seconds between the start time of the root span and the end time of the last span that completed.
        public let duration: Double?
        ///  The unique identifier for the span.
        public let id: String?
        ///  Spans that comprise the trace.
        public let spans: [Span]?

        @inlinable
        public init(duration: Double? = nil, id: String? = nil, spans: [Span]? = nil) {
            self.duration = duration
            self.id = id
            self.spans = spans
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case id = "Id"
            case spans = "Spans"
        }
    }

    public struct RootCauseException: AWSDecodableShape {
        /// The message of the exception.
        public let message: String?
        /// The name of the exception.
        public let name: String?

        @inlinable
        public init(message: String? = nil, name: String? = nil) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct SamplingRule: AWSEncodableShape & AWSDecodableShape {
        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double
        /// Matches the hostname from a request URL.
        public let host: String
        /// Matches the HTTP method of a request.
        public let httpMethod: String
        /// The priority of the sampling rule.
        public let priority: Int
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int
        /// Matches the ARN of the Amazon Web Services resource on which the service runs.
        public let resourceARN: String
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String
        /// Matches the path from a request URL.
        public let urlPath: String
        /// The version of the sampling rule format (1).
        public let version: Int

        @inlinable
        public init(attributes: [String: String]? = nil, fixedRate: Double, host: String, httpMethod: String, priority: Int, reservoirSize: Int, resourceARN: String, ruleARN: String? = nil, ruleName: String? = nil, serviceName: String, serviceType: String, urlPath: String, version: Int) {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.httpMethod = httpMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.urlPath = urlPath
            self.version = version
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 5)
            try self.validate(self.fixedRate, name: "fixedRate", parent: name, max: 1.0)
            try self.validate(self.fixedRate, name: "fixedRate", parent: name, min: 0.0)
            try self.validate(self.host, name: "host", parent: name, max: 64)
            try self.validate(self.httpMethod, name: "httpMethod", parent: name, max: 10)
            try self.validate(self.priority, name: "priority", parent: name, max: 9999)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.reservoirSize, name: "reservoirSize", parent: name, min: 0)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 32)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 64)
            try self.validate(self.serviceType, name: "serviceType", parent: name, max: 64)
            try self.validate(self.urlPath, name: "urlPath", parent: name, max: 128)
            try self.validate(self.version, name: "version", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case fixedRate = "FixedRate"
            case host = "Host"
            case httpMethod = "HTTPMethod"
            case priority = "Priority"
            case reservoirSize = "ReservoirSize"
            case resourceARN = "ResourceARN"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case serviceName = "ServiceName"
            case serviceType = "ServiceType"
            case urlPath = "URLPath"
            case version = "Version"
        }
    }

    public struct SamplingRuleRecord: AWSDecodableShape {
        /// When the rule was created.
        public let createdAt: Date?
        /// When the rule was last modified.
        public let modifiedAt: Date?
        /// The sampling rule.
        public let samplingRule: SamplingRule?

        @inlinable
        public init(createdAt: Date? = nil, modifiedAt: Date? = nil, samplingRule: SamplingRule? = nil) {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.samplingRule = samplingRule
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case modifiedAt = "ModifiedAt"
            case samplingRule = "SamplingRule"
        }
    }

    public struct SamplingRuleUpdate: AWSEncodableShape {
        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// Matches the hostname from a request URL.
        public let host: String?
        /// Matches the HTTP method of a request.
        public let httpMethod: String?
        /// The priority of the sampling rule.
        public let priority: Int?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int?
        /// Matches the ARN of the Amazon Web Services resource on which the service runs.
        public let resourceARN: String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String?
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String?
        /// Matches the path from a request URL.
        public let urlPath: String?

        @inlinable
        public init(attributes: [String: String]? = nil, fixedRate: Double? = nil, host: String? = nil, httpMethod: String? = nil, priority: Int? = nil, reservoirSize: Int? = nil, resourceARN: String? = nil, ruleARN: String? = nil, ruleName: String? = nil, serviceName: String? = nil, serviceType: String? = nil, urlPath: String? = nil) {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.httpMethod = httpMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.urlPath = urlPath
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 5)
            try self.validate(self.host, name: "host", parent: name, max: 64)
            try self.validate(self.httpMethod, name: "httpMethod", parent: name, max: 10)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 32)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 64)
            try self.validate(self.serviceType, name: "serviceType", parent: name, max: 64)
            try self.validate(self.urlPath, name: "urlPath", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case fixedRate = "FixedRate"
            case host = "Host"
            case httpMethod = "HTTPMethod"
            case priority = "Priority"
            case reservoirSize = "ReservoirSize"
            case resourceARN = "ResourceARN"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case serviceName = "ServiceName"
            case serviceType = "ServiceType"
            case urlPath = "URLPath"
        }
    }

    public struct SamplingStatisticSummary: AWSDecodableShape {
        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int?
        /// The number of requests that matched the rule.
        public let requestCount: Int?
        /// The name of the sampling rule.
        public let ruleName: String?
        /// The number of requests recorded.
        public let sampledCount: Int?
        /// The start time of the reporting window.
        public let timestamp: Date?

        @inlinable
        public init(borrowCount: Int? = nil, requestCount: Int? = nil, ruleName: String? = nil, sampledCount: Int? = nil, timestamp: Date? = nil) {
            self.borrowCount = borrowCount
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case borrowCount = "BorrowCount"
            case requestCount = "RequestCount"
            case ruleName = "RuleName"
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
        }
    }

    public struct SamplingStatisticsDocument: AWSEncodableShape {
        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int?
        /// A unique identifier for the service in hexadecimal.
        public let clientID: String
        /// The number of requests that matched the rule.
        public let requestCount: Int
        /// The name of the sampling rule.
        public let ruleName: String
        /// The number of requests recorded.
        public let sampledCount: Int
        /// The current time.
        public let timestamp: Date

        @inlinable
        public init(borrowCount: Int? = nil, clientID: String, requestCount: Int = 0, ruleName: String, sampledCount: Int = 0, timestamp: Date) {
            self.borrowCount = borrowCount
            self.clientID = clientID
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.borrowCount, name: "borrowCount", parent: name, min: 0)
            try self.validate(self.clientID, name: "clientID", parent: name, max: 24)
            try self.validate(self.clientID, name: "clientID", parent: name, min: 24)
            try self.validate(self.requestCount, name: "requestCount", parent: name, min: 0)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 32)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.sampledCount, name: "sampledCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case borrowCount = "BorrowCount"
            case clientID = "ClientID"
            case requestCount = "RequestCount"
            case ruleName = "RuleName"
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
        }
    }

    public struct SamplingStrategy: AWSEncodableShape {
        /// The name of a sampling rule.
        public let name: SamplingStrategyName?
        /// The value of a sampling rule.
        public let value: Double?

        @inlinable
        public init(name: SamplingStrategyName? = nil, value: Double? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SamplingTargetDocument: AWSDecodableShape {
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// The number of seconds for the service to wait before getting sampling targets again.
        public let interval: Int?
        /// The number of requests per second that X-Ray allocated for this service.
        public let reservoirQuota: Int?
        /// When the reservoir quota expires.
        public let reservoirQuotaTTL: Date?
        /// The name of the sampling rule.
        public let ruleName: String?

        @inlinable
        public init(fixedRate: Double? = nil, interval: Int? = nil, reservoirQuota: Int? = nil, reservoirQuotaTTL: Date? = nil, ruleName: String? = nil) {
            self.fixedRate = fixedRate
            self.interval = interval
            self.reservoirQuota = reservoirQuota
            self.reservoirQuotaTTL = reservoirQuotaTTL
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case fixedRate = "FixedRate"
            case interval = "Interval"
            case reservoirQuota = "ReservoirQuota"
            case reservoirQuotaTTL = "ReservoirQuotaTTL"
            case ruleName = "RuleName"
        }
    }

    public struct Segment: AWSDecodableShape {
        /// The segment document.
        public let document: String?
        /// The segment's ID.
        public let id: String?

        @inlinable
        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case document = "Document"
            case id = "Id"
        }
    }

    public struct Service: AWSDecodableShape {
        /// Identifier of the Amazon Web Services account in which the service runs.
        public let accountId: String?
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// The end time of the last segment that the service generated.
        public let endTime: Date?
        /// The canonical name of the service.
        public let name: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int?
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The start time of the first segment that the service generated.
        public let startTime: Date?
        /// The service's state.
        public let state: String?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// The type of service.   Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.
        public let type: String?

        @inlinable
        public init(accountId: String? = nil, durationHistogram: [HistogramEntry]? = nil, edges: [Edge]? = nil, endTime: Date? = nil, name: String? = nil, names: [String]? = nil, referenceId: Int? = nil, responseTimeHistogram: [HistogramEntry]? = nil, root: Bool? = nil, startTime: Date? = nil, state: String? = nil, summaryStatistics: ServiceStatistics? = nil, type: String? = nil) {
            self.accountId = accountId
            self.durationHistogram = durationHistogram
            self.edges = edges
            self.endTime = endTime
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.root = root
            self.startTime = startTime
            self.state = state
            self.summaryStatistics = summaryStatistics
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case durationHistogram = "DurationHistogram"
            case edges = "Edges"
            case endTime = "EndTime"
            case name = "Name"
            case names = "Names"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case root = "Root"
            case startTime = "StartTime"
            case state = "State"
            case summaryStatistics = "SummaryStatistics"
            case type = "Type"
        }
    }

    public struct ServiceId: AWSDecodableShape {
        public let accountId: String?
        public let name: String?
        public let names: [String]?
        public let type: String?

        @inlinable
        public init(accountId: String? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct ServiceStatistics: AWSDecodableShape {
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?

        @inlinable
        public init(errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, totalCount: Int64? = nil, totalResponseTime: Double? = nil) {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
        }
    }

    public struct Span: AWSDecodableShape {
        /// The span document.
        public let document: String?
        /// The span ID.
        public let id: String?

        @inlinable
        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case document = "Document"
            case id = "Id"
        }
    }

    public struct StartTraceRetrievalRequest: AWSEncodableShape {
        ///  The end of the time range to retrieve traces. The range is inclusive, so the specified end time is included in the query. Specified as epoch time, the number of seconds since January 1, 1970, 00:00:00 UTC.
        public let endTime: Date
        ///  The start of the time range to retrieve traces. The range is inclusive, so the specified start time is included in the query.  Specified as epoch time, the number of seconds since January 1, 1970, 00:00:00 UTC.
        public let startTime: Date
        ///  Specify the trace IDs of the traces to be retrieved.
        public let traceIds: [String]

        @inlinable
        public init(endTime: Date, startTime: Date, traceIds: [String]) {
            self.endTime = endTime
            self.startTime = startTime
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
            try self.validate(self.traceIds, name: "traceIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
            case traceIds = "TraceIds"
        }
    }

    public struct StartTraceRetrievalResult: AWSDecodableShape {
        /// Retrieval token.
        public let retrievalToken: String?

        @inlinable
        public init(retrievalToken: String? = nil) {
            self.retrievalToken = retrievalToken
        }

        private enum CodingKeys: String, CodingKey {
            case retrievalToken = "RetrievalToken"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A tag key, such as Stage or Name. A tag key cannot be empty. The  key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators,  or the following special characters: + - = . _ : /
        public let key: String
        /// An optional tag value, such as Production or test-only. The value can be  a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following  special characters: + - = . _ : /
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray group or sampling rule. For more information about ways to use tags, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use. You cannot edit or delete system tags.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TelemetryRecord: AWSEncodableShape {
        public let backendConnectionErrors: BackendConnectionErrors?
        public let segmentsReceivedCount: Int?
        public let segmentsRejectedCount: Int?
        public let segmentsSentCount: Int?
        public let segmentsSpilloverCount: Int?
        public let timestamp: Date

        @inlinable
        public init(backendConnectionErrors: BackendConnectionErrors? = nil, segmentsReceivedCount: Int? = nil, segmentsRejectedCount: Int? = nil, segmentsSentCount: Int? = nil, segmentsSpilloverCount: Int? = nil, timestamp: Date) {
            self.backendConnectionErrors = backendConnectionErrors
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsRejectedCount = segmentsRejectedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case backendConnectionErrors = "BackendConnectionErrors"
            case segmentsReceivedCount = "SegmentsReceivedCount"
            case segmentsRejectedCount = "SegmentsRejectedCount"
            case segmentsSentCount = "SegmentsSentCount"
            case segmentsSpilloverCount = "SegmentsSpilloverCount"
            case timestamp = "Timestamp"
        }
    }

    public struct TimeSeriesServiceStatistics: AWSDecodableShape {
        public let edgeSummaryStatistics: EdgeStatistics?
        /// The response time histogram for the selected entities.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The forecasted high and low fault count values.
        public let serviceForecastStatistics: ForecastStatistics?
        public let serviceSummaryStatistics: ServiceStatistics?
        /// Timestamp of the window for which statistics are aggregated.
        public let timestamp: Date?

        @inlinable
        public init(edgeSummaryStatistics: EdgeStatistics? = nil, responseTimeHistogram: [HistogramEntry]? = nil, serviceForecastStatistics: ForecastStatistics? = nil, serviceSummaryStatistics: ServiceStatistics? = nil, timestamp: Date? = nil) {
            self.edgeSummaryStatistics = edgeSummaryStatistics
            self.responseTimeHistogram = responseTimeHistogram
            self.serviceForecastStatistics = serviceForecastStatistics
            self.serviceSummaryStatistics = serviceSummaryStatistics
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case edgeSummaryStatistics = "EdgeSummaryStatistics"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case serviceForecastStatistics = "ServiceForecastStatistics"
            case serviceSummaryStatistics = "ServiceSummaryStatistics"
            case timestamp = "Timestamp"
        }
    }

    public struct TooManyTagsException: AWSErrorShape {
        public let message: String?
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceName = "ResourceName"
        }
    }

    public struct Trace: AWSDecodableShape {
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// LimitExceeded is set to true when the trace has exceeded the Trace document size limit. For more information about this limit and other X-Ray limits and quotas, see Amazon Web Services X-Ray endpoints and quotas.
        public let limitExceeded: Bool?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?

        @inlinable
        public init(duration: Double? = nil, id: String? = nil, limitExceeded: Bool? = nil, segments: [Segment]? = nil) {
            self.duration = duration
            self.id = id
            self.limitExceeded = limitExceeded
            self.segments = segments
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case id = "Id"
            case limitExceeded = "LimitExceeded"
            case segments = "Segments"
        }
    }

    public struct TraceSummary: AWSDecodableShape {
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// A list of Availability Zones for any zone corresponding to the trace segments.
        public let availabilityZones: [AvailabilityZoneDetail]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The root of a trace.
        public let entryPoint: ServiceId?
        /// A collection of ErrorRootCause structures corresponding to the trace segments.
        public let errorRootCauses: [ErrorRootCause]?
        /// A collection of FaultRootCause structures corresponding to the trace segments.
        public let faultRootCauses: [FaultRootCause]?
        /// The root segment document has a 400 series error.
        public let hasError: Bool?
        /// The root segment document has a 500 series error.
        public let hasFault: Bool?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// A list of EC2 instance IDs for any instance corresponding to the trace segments.
        public let instanceIds: [InstanceIdDetail]?
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// The matched time stamp of a defined event.
        public let matchedEventTime: Date?
        /// A list of resource ARNs for any resource corresponding to the trace segments.
        public let resourceARNs: [ResourceARNDetail]?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?
        /// A collection of ResponseTimeRootCause structures corresponding to the trace segments.
        public let responseTimeRootCauses: [ResponseTimeRootCause]?
        /// The revision number of a trace.
        public let revision: Int?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// The start time of a trace, based on the earliest trace segment start time.
        public let startTime: Date?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?

        @inlinable
        public init(annotations: [String: [ValueWithServiceIds]]? = nil, availabilityZones: [AvailabilityZoneDetail]? = nil, duration: Double? = nil, entryPoint: ServiceId? = nil, errorRootCauses: [ErrorRootCause]? = nil, faultRootCauses: [FaultRootCause]? = nil, hasError: Bool? = nil, hasFault: Bool? = nil, hasThrottle: Bool? = nil, http: Http? = nil, id: String? = nil, instanceIds: [InstanceIdDetail]? = nil, isPartial: Bool? = nil, matchedEventTime: Date? = nil, resourceARNs: [ResourceARNDetail]? = nil, responseTime: Double? = nil, responseTimeRootCauses: [ResponseTimeRootCause]? = nil, revision: Int? = nil, serviceIds: [ServiceId]? = nil, startTime: Date? = nil, users: [TraceUser]? = nil) {
            self.annotations = annotations
            self.availabilityZones = availabilityZones
            self.duration = duration
            self.entryPoint = entryPoint
            self.errorRootCauses = errorRootCauses
            self.faultRootCauses = faultRootCauses
            self.hasError = hasError
            self.hasFault = hasFault
            self.hasThrottle = hasThrottle
            self.http = http
            self.id = id
            self.instanceIds = instanceIds
            self.isPartial = isPartial
            self.matchedEventTime = matchedEventTime
            self.resourceARNs = resourceARNs
            self.responseTime = responseTime
            self.responseTimeRootCauses = responseTimeRootCauses
            self.revision = revision
            self.serviceIds = serviceIds
            self.startTime = startTime
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case annotations = "Annotations"
            case availabilityZones = "AvailabilityZones"
            case duration = "Duration"
            case entryPoint = "EntryPoint"
            case errorRootCauses = "ErrorRootCauses"
            case faultRootCauses = "FaultRootCauses"
            case hasError = "HasError"
            case hasFault = "HasFault"
            case hasThrottle = "HasThrottle"
            case http = "Http"
            case id = "Id"
            case instanceIds = "InstanceIds"
            case isPartial = "IsPartial"
            case matchedEventTime = "MatchedEventTime"
            case resourceARNs = "ResourceARNs"
            case responseTime = "ResponseTime"
            case responseTimeRootCauses = "ResponseTimeRootCauses"
            case revision = "Revision"
            case serviceIds = "ServiceIds"
            case startTime = "StartTime"
            case users = "Users"
        }
    }

    public struct TraceUser: AWSDecodableShape {
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        @inlinable
        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIds = "ServiceIds"
            case userName = "UserName"
        }
    }

    public struct UnprocessedStatistics: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?
        /// The name of the sampling rule.
        public let ruleName: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil, ruleName: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
            case ruleName = "RuleName"
        }
    }

    public struct UnprocessedTraceSegment: AWSDecodableShape {
        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The segment's ID.
        public let id: String?
        /// The error message.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, id: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case id = "Id"
            case message = "Message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String
        /// Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        /// The updated filter expression defining criteria by which to group traces.
        public let filterExpression: String?
        /// The ARN that was generated upon creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.   The NotificationsEnabled boolean can be set to true to enable insights notifications for the group. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public let insightsConfiguration: InsightsConfiguration?

        @inlinable
        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct UpdateGroupResult: AWSDecodableShape {
        /// The group that was updated. Contains the name of the group that was updated, the ARN of the group that was updated, the updated filter expression, and the updated insight configuration assigned to the group.
        public let group: Group?

        @inlinable
        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct UpdateIndexingRuleRequest: AWSEncodableShape {
        ///  Name of the indexing rule to be updated.
        public let name: String
        ///  Rule configuration to be updated.
        public let rule: IndexingRuleValueUpdate

        @inlinable
        public init(name: String, rule: IndexingRuleValueUpdate) {
            self.name = name
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case rule = "Rule"
        }
    }

    public struct UpdateIndexingRuleResult: AWSDecodableShape {
        ///  Updated indexing rule.
        public let indexingRule: IndexingRule?

        @inlinable
        public init(indexingRule: IndexingRule? = nil) {
            self.indexingRule = indexingRule
        }

        private enum CodingKeys: String, CodingKey {
            case indexingRule = "IndexingRule"
        }
    }

    public struct UpdateSamplingRuleRequest: AWSEncodableShape {
        /// The rule and fields to change.
        public let samplingRuleUpdate: SamplingRuleUpdate

        @inlinable
        public init(samplingRuleUpdate: SamplingRuleUpdate) {
            self.samplingRuleUpdate = samplingRuleUpdate
        }

        public func validate(name: String) throws {
            try self.samplingRuleUpdate.validate(name: "\(name).samplingRuleUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleUpdate = "SamplingRuleUpdate"
        }
    }

    public struct UpdateSamplingRuleResult: AWSDecodableShape {
        /// The updated rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        @inlinable
        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct UpdateTraceSegmentDestinationRequest: AWSEncodableShape {
        /// The configured destination of trace segments.
        public let destination: TraceSegmentDestination?

        @inlinable
        public init(destination: TraceSegmentDestination? = nil) {
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct UpdateTraceSegmentDestinationResult: AWSDecodableShape {
        ///  The destination of the trace segments.
        public let destination: TraceSegmentDestination?
        /// The status of the update.
        public let status: TraceSegmentDestinationStatus?

        @inlinable
        public init(destination: TraceSegmentDestination? = nil, status: TraceSegmentDestinationStatus? = nil) {
            self.destination = destination
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case status = "Status"
        }
    }

    public struct ValueWithServiceIds: AWSDecodableShape {
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?

        @inlinable
        public init(annotationValue: AnnotationValue? = nil, serviceIds: [ServiceId]? = nil) {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }

        private enum CodingKeys: String, CodingKey {
            case annotationValue = "AnnotationValue"
            case serviceIds = "ServiceIds"
        }
    }

    public struct IndexingRuleValue: AWSDecodableShape {
        ///  Indexing rule configuration that is used to probabilistically  sample traceIds.
        public let probabilistic: ProbabilisticRuleValue?

        @inlinable
        public init(probabilistic: ProbabilisticRuleValue? = nil) {
            self.probabilistic = probabilistic
        }

        private enum CodingKeys: String, CodingKey {
            case probabilistic = "Probabilistic"
        }
    }

    public struct IndexingRuleValueUpdate: AWSEncodableShape {
        ///  Indexing rule configuration that is used to probabilistically  sample traceIds.
        public let probabilistic: ProbabilisticRuleValueUpdate?

        @inlinable
        public init(probabilistic: ProbabilisticRuleValueUpdate? = nil) {
            self.probabilistic = probabilistic
        }

        private enum CodingKeys: String, CodingKey {
            case probabilistic = "Probabilistic"
        }
    }
}

// MARK: - Errors

/// Error enum for XRay
public struct XRayErrorType: AWSErrorType {
    enum Code: String {
        case invalidPolicyRevisionIdException = "InvalidPolicyRevisionIdException"
        case invalidRequestException = "InvalidRequestException"
        case lockoutPreventionException = "LockoutPreventionException"
        case malformedPolicyDocumentException = "MalformedPolicyDocumentException"
        case policyCountLimitExceededException = "PolicyCountLimitExceededException"
        case policySizeLimitExceededException = "PolicySizeLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case ruleLimitExceededException = "RuleLimitExceededException"
        case throttledException = "ThrottledException"
        case tooManyTagsException = "TooManyTagsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize XRay
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// A policy revision id was provided which does not match the latest policy revision. This exception is also  if a policy revision id of 0 is provided via PutResourcePolicy and a policy with the same name already exists.
    public static var invalidPolicyRevisionIdException: Self { .init(.invalidPolicyRevisionIdException) }
    /// The request is missing required parameters or has invalid parameters.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The provided resource policy would prevent the caller of this request from calling PutResourcePolicy in the future.
    public static var lockoutPreventionException: Self { .init(.lockoutPreventionException) }
    /// Invalid policy document provided in request.
    public static var malformedPolicyDocumentException: Self { .init(.malformedPolicyDocumentException) }
    /// Exceeded the maximum number of resource policies for a target Amazon Web Services account.
    public static var policyCountLimitExceededException: Self { .init(.policyCountLimitExceededException) }
    /// Exceeded the maximum size for a resource policy.
    public static var policySizeLimitExceededException: Self { .init(.policySizeLimitExceededException) }
    /// The resource was not found. Verify that the name or Amazon Resource Name (ARN) of the resource is correct.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have reached the maximum number of sampling rules.
    public static var ruleLimitExceededException: Self { .init(.ruleLimitExceededException) }
    /// The request exceeds the maximum number of requests per second.
    public static var throttledException: Self { .init(.throttledException) }
    /// You have exceeded the maximum number of tags you can apply to this resource.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
}

extension XRayErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": XRay.ResourceNotFoundException.self,
        "TooManyTagsException": XRay.TooManyTagsException.self
    ]
}

extension XRayErrorType: Equatable {
    public static func == (lhs: XRayErrorType, rhs: XRayErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension XRayErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
