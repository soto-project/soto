//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension XRay {
    // MARK: Enums

    public enum EncryptionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case kms = "KMS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum InsightCategory: String, CustomStringConvertible, Codable {
        case fault = "FAULT"
        public var description: String { return self.rawValue }
    }

    public enum InsightState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        public var description: String { return self.rawValue }
    }

    public enum SamplingStrategyName: String, CustomStringConvertible, Codable {
        case fixedrate = "FixedRate"
        case partialscan = "PartialScan"
        public var description: String { return self.rawValue }
    }

    public enum TimeRangeType: String, CustomStringConvertible, Codable {
        case event = "Event"
        case traceid = "TraceId"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Alias: AWSDecodableShape {
        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?
        /// The type of the alias.
        public let type: String?

        public init(name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct AnnotationValue: AWSDecodableShape {
        /// Value for a Boolean annotation.
        public let booleanValue: Bool?
        /// Value for a Number annotation.
        public let numberValue: Double?
        /// Value for a String annotation.
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, numberValue: Double? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.numberValue = numberValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "BooleanValue"
            case numberValue = "NumberValue"
            case stringValue = "StringValue"
        }
    }

    public struct AnomalousService: AWSDecodableShape {
        public let serviceId: ServiceId?

        public init(serviceId: ServiceId? = nil) {
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case serviceId = "ServiceId"
        }
    }

    public struct AvailabilityZoneDetail: AWSDecodableShape {
        /// The name of a corresponding Availability Zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct BackendConnectionErrors: AWSEncodableShape {
        public let connectionRefusedCount: Int?
        public let hTTPCode4XXCount: Int?
        public let hTTPCode5XXCount: Int?
        public let otherCount: Int?
        public let timeoutCount: Int?
        public let unknownHostCount: Int?

        public init(connectionRefusedCount: Int? = nil, hTTPCode4XXCount: Int? = nil, hTTPCode5XXCount: Int? = nil, otherCount: Int? = nil, timeoutCount: Int? = nil, unknownHostCount: Int? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
        }

        private enum CodingKeys: String, CodingKey {
            case connectionRefusedCount = "ConnectionRefusedCount"
            case hTTPCode4XXCount = "HTTPCode4XXCount"
            case hTTPCode5XXCount = "HTTPCode5XXCount"
            case otherCount = "OtherCount"
            case timeoutCount = "TimeoutCount"
            case unknownHostCount = "UnknownHostCount"
        }
    }

    public struct BatchGetTracesRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct BatchGetTracesResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traces = "Traces"
            case unprocessedTraceIds = "UnprocessedTraceIds"
        }
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        /// The filter expression defining criteria by which to group traces.
        public let filterExpression: String?
        /// The case-sensitive name of the new group. Default is a reserved name and names must be unique.
        public let groupName: String
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the new group or false to disable insights for the new group.   The NotifcationsEnabled boolean can be set to true to enable insights notifications for the new group. Notifications may only be enabled on a group with InsightsEnabled set to true.
        public let insightsConfiguration: InsightsConfiguration?
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray group. For more information about ways to use tags, see Tagging AWS resources in the AWS General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for AWS use.
        public let tags: [Tag]?

        public init(filterExpression: String? = nil, groupName: String, insightsConfiguration: InsightsConfiguration? = nil, tags: [Tag]? = nil) {
            self.filterExpression = filterExpression
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateGroupResult: AWSDecodableShape {
        /// The group that was created. Contains the name of the group that was created, the Amazon Resource Name (ARN) of the group that was generated based on the group name, the filter expression, and the insight configuration that was assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct CreateSamplingRuleRequest: AWSEncodableShape {
        /// The rule definition.
        public let samplingRule: SamplingRule
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray sampling rule. For more information about ways to use tags, see Tagging AWS resources in the AWS General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for AWS use.
        public let tags: [Tag]?

        public init(samplingRule: SamplingRule, tags: [Tag]? = nil) {
            self.samplingRule = samplingRule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.samplingRule.validate(name: "\(name).samplingRule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRule = "SamplingRule"
            case tags = "Tags"
        }
    }

    public struct CreateSamplingRuleResult: AWSDecodableShape {
        /// The saved rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct DeleteGroupResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSamplingRuleRequest: AWSEncodableShape {
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?

        public init(ruleARN: String? = nil, ruleName: String? = nil) {
            self.ruleARN = ruleARN
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
        }
    }

    public struct DeleteSamplingRuleResult: AWSDecodableShape {
        /// The deleted rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct Edge: AWSDecodableShape {
        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// The end time of the last segment on the edge.
        public let endTime: Date?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int?
        /// A histogram that maps the spread of client response times on an edge.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The start time of the first segment on the edge.
        public let startTime: Date?
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?

        public init(aliases: [Alias]? = nil, endTime: Date? = nil, referenceId: Int? = nil, responseTimeHistogram: [HistogramEntry]? = nil, startTime: Date? = nil, summaryStatistics: EdgeStatistics? = nil) {
            self.aliases = aliases
            self.endTime = endTime
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case endTime = "EndTime"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case startTime = "StartTime"
            case summaryStatistics = "SummaryStatistics"
        }
    }

    public struct EdgeStatistics: AWSDecodableShape {
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?

        public init(errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, totalCount: Int64? = nil, totalResponseTime: Double? = nil) {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
        }
    }

    public struct EncryptionConfig: AWSDecodableShape {
        /// The ID of the customer master key (CMK) used for encryption, if applicable.
        public let keyId: String?
        /// The encryption status. While the status is UPDATING, X-Ray may encrypt data with a combination of the new and old settings.
        public let status: EncryptionStatus?
        /// The type of encryption. Set to KMS for encryption with CMKs. Set to NONE for default encryption.
        public let type: EncryptionType?

        public init(keyId: String? = nil, status: EncryptionStatus? = nil, type: EncryptionType? = nil) {
            self.keyId = keyId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ErrorRootCause: AWSDecodableShape {
        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of services corresponding to an error. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [ErrorRootCauseService]?

        public init(clientImpacting: Bool? = nil, services: [ErrorRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct ErrorRootCauseEntity: AWSDecodableShape {
        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct ErrorRootCauseService: AWSDecodableShape {
        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service.
        public let entityPath: [ErrorRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let type: String?

        public init(accountId: String? = nil, entityPath: [ErrorRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct ErrorStatistics: AWSDecodableShape {
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, throttleCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case throttleCount = "ThrottleCount"
            case totalCount = "TotalCount"
        }
    }

    public struct FaultRootCause: AWSDecodableShape {
        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of corresponding services. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [FaultRootCauseService]?

        public init(clientImpacting: Bool? = nil, services: [FaultRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct FaultRootCauseEntity: AWSDecodableShape {
        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct FaultRootCauseService: AWSDecodableShape {
        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service.
        public let entityPath: [FaultRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let type: String?

        public init(accountId: String? = nil, entityPath: [FaultRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct FaultStatistics: AWSDecodableShape {
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case totalCount = "TotalCount"
        }
    }

    public struct ForecastStatistics: AWSDecodableShape {
        /// The upper limit of fault counts for a service.
        public let faultCountHigh: Int64?
        /// The lower limit of fault counts for a service.
        public let faultCountLow: Int64?

        public init(faultCountHigh: Int64? = nil, faultCountLow: Int64? = nil) {
            self.faultCountHigh = faultCountHigh
            self.faultCountLow = faultCountLow
        }

        private enum CodingKeys: String, CodingKey {
            case faultCountHigh = "FaultCountHigh"
            case faultCountLow = "FaultCountLow"
        }
    }

    public struct GetEncryptionConfigRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEncryptionConfigResult: AWSDecodableShape {
        /// The encryption configuration document.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct GetGroupRequest: AWSEncodableShape {
        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct GetGroupResult: AWSDecodableShape {
        /// The group that was requested. Contains the name of the group, the ARN of the group, the filter expression, and the insight configuration assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct GetGroupsRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetGroupsResult: AWSDecodableShape {
        /// The collection of all active groups.
        public let groups: [GroupSummary]?
        /// Pagination token.
        public let nextToken: String?

        public init(groups: [GroupSummary]? = nil, nextToken: String? = nil) {
            self.groups = groups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightEventsRequest: AWSEncodableShape {
        /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
        public let insightId: String
        /// Used to retrieve at most the specified value of events.
        public let maxResults: Int?
        /// Specify the pagination token returned by a previous request to retrieve the next page of events.
        public let nextToken: String?

        public init(insightId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightId = insightId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightEventsResult: AWSDecodableShape {
        /// A detailed description of the event. This includes the time of the event, client and root cause impact statistics, and the top anomalous service at the time of the event.
        public let insightEvents: [InsightEvent]?
        /// Use this token to retrieve the next page of insight events.
        public let nextToken: String?

        public init(insightEvents: [InsightEvent]? = nil, nextToken: String? = nil) {
            self.insightEvents = insightEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insightEvents = "InsightEvents"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightImpactGraphRequest: AWSEncodableShape {
        /// The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided. The time range between the start time and end time can't be more than six hours.
        public let endTime: Date
        /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
        public let insightId: String
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value provided and can't be more than 30 days old.
        public let startTime: Date

        public init(endTime: Date, insightId: String, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.insightId = insightId
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case insightId = "InsightId"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetInsightImpactGraphResult: AWSDecodableShape {
        /// The provided end time.
        public let endTime: Date?
        /// The insight's unique identifier.
        public let insightId: String?
        /// Pagination token.
        public let nextToken: String?
        /// The time, in Unix seconds, at which the service graph ended.
        public let serviceGraphEndTime: Date?
        /// The time, in Unix seconds, at which the service graph started.
        public let serviceGraphStartTime: Date?
        /// The AWS instrumented services related to the insight.
        public let services: [InsightImpactGraphService]?
        /// The provided start time.
        public let startTime: Date?

        public init(endTime: Date? = nil, insightId: String? = nil, nextToken: String? = nil, serviceGraphEndTime: Date? = nil, serviceGraphStartTime: Date? = nil, services: [InsightImpactGraphService]? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.insightId = insightId
            self.nextToken = nextToken
            self.serviceGraphEndTime = serviceGraphEndTime
            self.serviceGraphStartTime = serviceGraphStartTime
            self.services = services
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case insightId = "InsightId"
            case nextToken = "NextToken"
            case serviceGraphEndTime = "ServiceGraphEndTime"
            case serviceGraphStartTime = "ServiceGraphStartTime"
            case services = "Services"
            case startTime = "StartTime"
        }
    }

    public struct GetInsightRequest: AWSEncodableShape {
        /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
        public let insightId: String

        public init(insightId: String) {
            self.insightId = insightId
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
        }
    }

    public struct GetInsightResult: AWSDecodableShape {
        /// The summary information of an insight.
        public let insight: Insight?

        public init(insight: Insight? = nil) {
            self.insight = insight
        }

        private enum CodingKeys: String, CodingKey {
            case insight = "Insight"
        }
    }

    public struct GetInsightSummariesRequest: AWSEncodableShape {
        /// The end of the time frame in which the insights ended. The end time can't be more than 30 days old.
        public let endTime: Date
        /// The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.
        public let groupARN: String?
        /// The name of the group. Required if the GroupARN isn't provided.
        public let groupName: String?
        /// The maximum number of results to display.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?
        /// The beginning of the time frame in which the insights started. The start time can't be more than 30 days old.
        public let startTime: Date
        /// The list of insight states.
        public let states: [InsightState]?

        public init(endTime: Date, groupARN: String? = nil, groupName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date, states: [InsightState]? = nil) {
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
            self.states = states
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.states, name: "states", parent: name, max: 1)
            try self.validate(self.states, name: "states", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTime = "StartTime"
            case states = "States"
        }
    }

    public struct GetInsightSummariesResult: AWSDecodableShape {
        /// The summary of each insight within the group matching the provided filters. The summary contains the InsightID, start and end time, the root cause service, the root cause and client impact statistics, the top anomalous services, and the status of the insight.
        public let insightSummaries: [InsightSummary]?
        /// Pagination token.
        public let nextToken: String?

        public init(insightSummaries: [InsightSummary]? = nil, nextToken: String? = nil) {
            self.insightSummaries = insightSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insightSummaries = "InsightSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingRulesRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingRulesResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Rule definitions and metadata.
        public let samplingRuleRecords: [SamplingRuleRecord]?

        public init(nextToken: String? = nil, samplingRuleRecords: [SamplingRuleRecord]? = nil) {
            self.nextToken = nextToken
            self.samplingRuleRecords = samplingRuleRecords
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingRuleRecords = "SamplingRuleRecords"
        }
    }

    public struct GetSamplingStatisticSummariesRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingStatisticSummariesResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Information about the number of requests instrumented for each sampling rule.
        public let samplingStatisticSummaries: [SamplingStatisticSummary]?

        public init(nextToken: String? = nil, samplingStatisticSummaries: [SamplingStatisticSummary]? = nil) {
            self.nextToken = nextToken
            self.samplingStatisticSummaries = samplingStatisticSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingStatisticSummaries = "SamplingStatisticSummaries"
        }
    }

    public struct GetSamplingTargetsRequest: AWSEncodableShape {
        /// Information about rules that the service is using to sample requests.
        public let samplingStatisticsDocuments: [SamplingStatisticsDocument]

        public init(samplingStatisticsDocuments: [SamplingStatisticsDocument]) {
            self.samplingStatisticsDocuments = samplingStatisticsDocuments
        }

        public func validate(name: String) throws {
            try self.samplingStatisticsDocuments.forEach {
                try $0.validate(name: "\(name).samplingStatisticsDocuments[]")
            }
            try self.validate(self.samplingStatisticsDocuments, name: "samplingStatisticsDocuments", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
        }
    }

    public struct GetSamplingTargetsResult: AWSDecodableShape {
        /// The last time a user changed the sampling rule configuration. If the sampling rule configuration changed since the service last retrieved it, the service should call GetSamplingRules to get the latest version.
        public let lastRuleModification: Date?
        /// Updated rules that the service should use to sample requests.
        public let samplingTargetDocuments: [SamplingTargetDocument]?
        /// Information about SamplingStatisticsDocument that X-Ray could not process.
        public let unprocessedStatistics: [UnprocessedStatistics]?

        public init(lastRuleModification: Date? = nil, samplingTargetDocuments: [SamplingTargetDocument]? = nil, unprocessedStatistics: [UnprocessedStatistics]? = nil) {
            self.lastRuleModification = lastRuleModification
            self.samplingTargetDocuments = samplingTargetDocuments
            self.unprocessedStatistics = unprocessedStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case lastRuleModification = "LastRuleModification"
            case samplingTargetDocuments = "SamplingTargetDocuments"
            case unprocessedStatistics = "UnprocessedStatistics"
        }
    }

    public struct GetServiceGraphRequest: AWSEncodableShape {
        /// The end of the timeframe for which to generate a graph.
        public let endTime: Date
        /// The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.
        public let groupARN: String?
        /// The name of a group based on which you want to generate a graph.
        public let groupName: String?
        /// Pagination token.
        public let nextToken: String?
        /// The start of the time frame for which to generate a graph.
        public let startTime: Date

        public init(endTime: Date, groupARN: String? = nil, groupName: String? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetServiceGraphResult: AWSDecodableShape {
        /// A flag indicating whether the group's filter expression has been consistent, or if the returned service graph may show traces from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// The end of the time frame for which the graph was generated.
        public let endTime: Date?
        /// Pagination token.
        public let nextToken: String?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// The start of the time frame for which the graph was generated.
        public let startTime: Date?

        public init(containsOldGroupVersions: Bool? = nil, endTime: Date? = nil, nextToken: String? = nil, services: [Service]? = nil, startTime: Date? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.endTime = endTime
            self.nextToken = nextToken
            self.services = services
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case services = "Services"
            case startTime = "StartTime"
        }
    }

    public struct GetTimeSeriesServiceStatisticsRequest: AWSEncodableShape {
        /// The end of the time frame for which to aggregate statistics.
        public let endTime: Date
        /// A filter expression defining entities that will be aggregated for statistics. Supports ID, service, and edge functions. If no selector expression is specified, edge statistics are returned.
        public let entitySelectorExpression: String?
        /// The forecasted high and low fault count values. Forecast enabled requests require the EntitySelectorExpression ID be provided.
        public let forecastStatistics: Bool?
        /// The Amazon Resource Name (ARN) of the group for which to pull statistics from.
        public let groupARN: String?
        /// The case-sensitive name of the group for which to pull statistics from.
        public let groupName: String?
        /// Pagination token.
        public let nextToken: String?
        /// Aggregation period in seconds.
        public let period: Int?
        /// The start of the time frame for which to aggregate statistics.
        public let startTime: Date

        public init(endTime: Date, entitySelectorExpression: String? = nil, forecastStatistics: Bool? = nil, groupARN: String? = nil, groupName: String? = nil, nextToken: String? = nil, period: Int? = nil, startTime: Date) {
            self.endTime = endTime
            self.entitySelectorExpression = entitySelectorExpression
            self.forecastStatistics = forecastStatistics
            self.groupARN = groupARN
            self.groupName = groupName
            self.nextToken = nextToken
            self.period = period
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.entitySelectorExpression, name: "entitySelectorExpression", parent: name, max: 500)
            try self.validate(self.entitySelectorExpression, name: "entitySelectorExpression", parent: name, min: 1)
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case entitySelectorExpression = "EntitySelectorExpression"
            case forecastStatistics = "ForecastStatistics"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case nextToken = "NextToken"
            case period = "Period"
            case startTime = "StartTime"
        }
    }

    public struct GetTimeSeriesServiceStatisticsResult: AWSDecodableShape {
        /// A flag indicating whether or not a group's filter expression has been consistent, or if a returned aggregation might show statistics from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// Pagination token.
        public let nextToken: String?
        /// The collection of statistics.
        public let timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]?

        public init(containsOldGroupVersions: Bool? = nil, nextToken: String? = nil, timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.nextToken = nextToken
            self.timeSeriesServiceStatistics = timeSeriesServiceStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case nextToken = "NextToken"
            case timeSeriesServiceStatistics = "TimeSeriesServiceStatistics"
        }
    }

    public struct GetTraceGraphRequest: AWSEncodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct GetTraceGraphResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// The services that have processed one of the specified requests.
        public let services: [Service]?

        public init(nextToken: String? = nil, services: [Service]? = nil) {
            self.nextToken = nextToken
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case services = "Services"
        }
    }

    public struct GetTraceSummariesRequest: AWSEncodableShape {
        /// The end of the time frame for which to retrieve traces.
        public let endTime: Date
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// A parameter to indicate whether to enable sampling on trace summaries. Input parameters are Name and Value.
        public let samplingStrategy: SamplingStrategy?
        /// The start of the time frame for which to retrieve traces.
        public let startTime: Date
        /// A parameter to indicate whether to query trace summaries by TraceId or Event time.
        public let timeRangeType: TimeRangeType?

        public init(endTime: Date, filterExpression: String? = nil, nextToken: String? = nil, sampling: Bool? = nil, samplingStrategy: SamplingStrategy? = nil, startTime: Date, timeRangeType: TimeRangeType? = nil) {
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.nextToken = nextToken
            self.sampling = sampling
            self.samplingStrategy = samplingStrategy
            self.startTime = startTime
            self.timeRangeType = timeRangeType
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filterExpression = "FilterExpression"
            case nextToken = "NextToken"
            case sampling = "Sampling"
            case samplingStrategy = "SamplingStrategy"
            case startTime = "StartTime"
            case timeRangeType = "TimeRangeType"
        }
    }

    public struct GetTraceSummariesResult: AWSDecodableShape {
        /// The start time of this page of results.
        public let approximateTime: Date?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The total number of traces processed, including traces that did not match the specified filter expression.
        public let tracesProcessedCount: Int64?
        /// Trace IDs and annotations for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?

        public init(approximateTime: Date? = nil, nextToken: String? = nil, tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil) {
            self.approximateTime = approximateTime
            self.nextToken = nextToken
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTime = "ApproximateTime"
            case nextToken = "NextToken"
            case tracesProcessedCount = "TracesProcessedCount"
            case traceSummaries = "TraceSummaries"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?
        /// The Amazon Resource Name (ARN) of the group generated based on the GroupName.
        public let groupARN: String?
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.   The NotifcationsEnabled boolean can be set to true to enable insights notifications through Amazon EventBridge for the group.
        public let insightsConfiguration: InsightsConfiguration?

        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct GroupSummary: AWSDecodableShape {
        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?
        /// The ARN of the group generated based on the GroupName.
        public let groupARN: String?
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.   The NotificationsEnabled boolean can be set to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public let insightsConfiguration: InsightsConfiguration?

        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct HistogramEntry: AWSDecodableShape {
        /// The prevalence of the entry.
        public let count: Int?
        /// The value of the entry.
        public let value: Double?

        public init(count: Int? = nil, value: Double? = nil) {
            self.count = count
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case value = "Value"
        }
    }

    public struct Http: AWSDecodableShape {
        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int?
        /// The request URL.
        public let httpURL: String?
        /// The request's user agent string.
        public let userAgent: String?

        public init(clientIp: String? = nil, httpMethod: String? = nil, httpStatus: Int? = nil, httpURL: String? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.httpURL = httpURL
            self.userAgent = userAgent
        }

        private enum CodingKeys: String, CodingKey {
            case clientIp = "ClientIp"
            case httpMethod = "HttpMethod"
            case httpStatus = "HttpStatus"
            case httpURL = "HttpURL"
            case userAgent = "UserAgent"
        }
    }

    public struct Insight: AWSDecodableShape {
        /// The categories that label and describe the type of insight.
        public let categories: [InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let clientRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public let endTime: Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public let groupARN: String?
        /// The name of the group that the insight belongs to.
        public let groupName: String?
        /// The insights unique identifier.
        public let insightId: String?
        public let rootCauseServiceId: ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public let startTime: Date?
        /// The current state of the insight.
        public let state: InsightState?
        /// A brief description of the insight.
        public let summary: String?
        /// The service within the insight that is most impacted by the incident.
        public let topAnomalousServices: [AnomalousService]?

        public init(categories: [InsightCategory]? = nil, clientRequestImpactStatistics: RequestImpactStatistics? = nil, endTime: Date? = nil, groupARN: String? = nil, groupName: String? = nil, insightId: String? = nil, rootCauseServiceId: ServiceId? = nil, rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil, startTime: Date? = nil, state: InsightState? = nil, summary: String? = nil, topAnomalousServices: [AnomalousService]? = nil) {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightId = "InsightId"
            case rootCauseServiceId = "RootCauseServiceId"
            case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
            case startTime = "StartTime"
            case state = "State"
            case summary = "Summary"
            case topAnomalousServices = "TopAnomalousServices"
        }
    }

    public struct InsightEvent: AWSDecodableShape {
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let clientRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the event was recorded.
        public let eventTime: Date?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
        /// A brief description of the event.
        public let summary: String?
        /// The service during the event that is most impacted by the incident.
        public let topAnomalousServices: [AnomalousService]?

        public init(clientRequestImpactStatistics: RequestImpactStatistics? = nil, eventTime: Date? = nil, rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil, summary: String? = nil, topAnomalousServices: [AnomalousService]? = nil) {
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.eventTime = eventTime
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
            case eventTime = "EventTime"
            case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
            case summary = "Summary"
            case topAnomalousServices = "TopAnomalousServices"
        }
    }

    public struct InsightImpactGraphEdge: AWSDecodableShape {
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int?

        public init(referenceId: Int? = nil) {
            self.referenceId = referenceId
        }

        private enum CodingKeys: String, CodingKey {
            case referenceId = "ReferenceId"
        }
    }

    public struct InsightImpactGraphService: AWSDecodableShape {
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// Connections to downstream services.
        public let edges: [InsightImpactGraphEdge]?
        /// The canonical name of the service.
        public let name: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int?
        /// Identifier for the service. Unique within the service map.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.    AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    remote - A downstream service of indeterminate type.
        public let type: String?

        public init(accountId: String? = nil, edges: [InsightImpactGraphEdge]? = nil, name: String? = nil, names: [String]? = nil, referenceId: Int? = nil, type: String? = nil) {
            self.accountId = accountId
            self.edges = edges
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case edges = "Edges"
            case name = "Name"
            case names = "Names"
            case referenceId = "ReferenceId"
            case type = "Type"
        }
    }

    public struct InsightSummary: AWSDecodableShape {
        ///  Categories The categories that label and describe the type of insight.
        public let categories: [InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let clientRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public let endTime: Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public let groupARN: String?
        /// The name of the group that the insight belongs to.
        public let groupName: String?
        /// The insights unique identifier.
        public let insightId: String?
        /// The time, in Unix seconds, that the insight was last updated.
        public let lastUpdateTime: Date?
        public let rootCauseServiceId: ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public let startTime: Date?
        /// The current state of the insight.
        public let state: InsightState?
        /// A brief description of the insight.
        public let summary: String?
        /// The service within the insight that is most impacted by the incident.
        public let topAnomalousServices: [AnomalousService]?

        public init(categories: [InsightCategory]? = nil, clientRequestImpactStatistics: RequestImpactStatistics? = nil, endTime: Date? = nil, groupARN: String? = nil, groupName: String? = nil, insightId: String? = nil, lastUpdateTime: Date? = nil, rootCauseServiceId: ServiceId? = nil, rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil, startTime: Date? = nil, state: InsightState? = nil, summary: String? = nil, topAnomalousServices: [AnomalousService]? = nil) {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.lastUpdateTime = lastUpdateTime
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightId = "InsightId"
            case lastUpdateTime = "LastUpdateTime"
            case rootCauseServiceId = "RootCauseServiceId"
            case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
            case startTime = "StartTime"
            case state = "State"
            case summary = "Summary"
            case topAnomalousServices = "TopAnomalousServices"
        }
    }

    public struct InsightsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Set the InsightsEnabled value to true to enable insights or false to disable insights.
        public let insightsEnabled: Bool?
        /// Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public let notificationsEnabled: Bool?

        public init(insightsEnabled: Bool? = nil, notificationsEnabled: Bool? = nil) {
            self.insightsEnabled = insightsEnabled
            self.notificationsEnabled = notificationsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case insightsEnabled = "InsightsEnabled"
            case notificationsEnabled = "NotificationsEnabled"
        }
    }

    public struct InstanceIdDetail: AWSDecodableShape {
        /// The ID of a corresponding EC2 instance.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results as the value of this parameter to get the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String

        public init(nextToken: String? = nil, resourceARN: String) {
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results to get the next page of results.
        public let nextToken: String?
        /// A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct PutEncryptionConfigRequest: AWSEncodableShape {
        /// An AWS KMS customer master key (CMK) in one of the following formats:    Alias - The name of the key. For example, alias/MyKey.    Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. AWS X-Ray does not support asymmetric CMKs.    ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.   Omit this key if you set Type to NONE.
        public let keyId: String?
        /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
        public let type: EncryptionType

        public init(keyId: String? = nil, type: EncryptionType) {
            self.keyId = keyId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.keyId, name: "keyId", parent: name, max: 3000)
            try self.validate(self.keyId, name: "keyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case type = "Type"
        }
    }

    public struct PutEncryptionConfigResult: AWSDecodableShape {
        /// The new encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct PutTelemetryRecordsRequest: AWSEncodableShape {
        public let eC2InstanceId: String?
        public let hostname: String?
        public let resourceARN: String?
        public let telemetryRecords: [TelemetryRecord]

        public init(eC2InstanceId: String? = nil, hostname: String? = nil, resourceARN: String? = nil, telemetryRecords: [TelemetryRecord]) {
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
            self.resourceARN = resourceARN
            self.telemetryRecords = telemetryRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.eC2InstanceId, name: "eC2InstanceId", parent: name, max: 20)
            try self.validate(self.hostname, name: "hostname", parent: name, max: 255)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case eC2InstanceId = "EC2InstanceId"
            case hostname = "Hostname"
            case resourceARN = "ResourceARN"
            case telemetryRecords = "TelemetryRecords"
        }
    }

    public struct PutTelemetryRecordsResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutTraceSegmentsRequest: AWSEncodableShape {
        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case traceSegmentDocuments = "TraceSegmentDocuments"
        }
    }

    public struct PutTraceSegmentsResult: AWSDecodableShape {
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceSegments = "UnprocessedTraceSegments"
        }
    }

    public struct RequestImpactStatistics: AWSDecodableShape {
        /// The number of requests that have resulted in a fault,
        public let faultCount: Int64?
        /// The number of successful requests.
        public let okCount: Int64?
        /// The total number of requests to the service.
        public let totalCount: Int64?

        public init(faultCount: Int64? = nil, okCount: Int64? = nil, totalCount: Int64? = nil) {
            self.faultCount = faultCount
            self.okCount = okCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case faultCount = "FaultCount"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
        }
    }

    public struct ResourceARNDetail: AWSDecodableShape {
        /// The ARN of a corresponding resource.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
        }
    }

    public struct ResponseTimeRootCause: AWSDecodableShape {
        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of corresponding services. A service identifies a segment and contains a name, account ID, type, and inferred flag.
        public let services: [ResponseTimeRootCauseService]?

        public init(clientImpacting: Bool? = nil, services: [ResponseTimeRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct ResponseTimeRootCauseEntity: AWSDecodableShape {
        /// The type and messages of the exceptions.
        public let coverage: Double?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(coverage: Double? = nil, name: String? = nil, remote: Bool? = nil) {
            self.coverage = coverage
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case coverage = "Coverage"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct ResponseTimeRootCauseService: AWSDecodableShape {
        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service.
        public let entityPath: [ResponseTimeRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let type: String?

        public init(accountId: String? = nil, entityPath: [ResponseTimeRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct RootCauseException: AWSDecodableShape {
        /// The message of the exception.
        public let message: String?
        /// The name of the exception.
        public let name: String?

        public init(message: String? = nil, name: String? = nil) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct SamplingRule: AWSEncodableShape & AWSDecodableShape {
        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double
        /// Matches the hostname from a request URL.
        public let host: String
        /// Matches the HTTP method of a request.
        public let hTTPMethod: String
        /// The priority of the sampling rule.
        public let priority: Int
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int
        /// Matches the ARN of the AWS resource on which the service runs.
        public let resourceARN: String
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String
        /// Matches the path from a request URL.
        public let uRLPath: String
        /// The version of the sampling rule format (1).
        public let version: Int

        public init(attributes: [String: String]? = nil, fixedRate: Double, host: String, hTTPMethod: String, priority: Int, reservoirSize: Int, resourceARN: String, ruleARN: String? = nil, ruleName: String? = nil, serviceName: String, serviceType: String, uRLPath: String, version: Int) {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.hTTPMethod = hTTPMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.uRLPath = uRLPath
            self.version = version
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.fixedRate, name: "fixedRate", parent: name, max: 1)
            try self.validate(self.fixedRate, name: "fixedRate", parent: name, min: 0)
            try self.validate(self.host, name: "host", parent: name, max: 64)
            try self.validate(self.hTTPMethod, name: "hTTPMethod", parent: name, max: 10)
            try self.validate(self.priority, name: "priority", parent: name, max: 9999)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.reservoirSize, name: "reservoirSize", parent: name, min: 0)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 32)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 64)
            try self.validate(self.serviceType, name: "serviceType", parent: name, max: 64)
            try self.validate(self.uRLPath, name: "uRLPath", parent: name, max: 128)
            try self.validate(self.version, name: "version", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case fixedRate = "FixedRate"
            case host = "Host"
            case hTTPMethod = "HTTPMethod"
            case priority = "Priority"
            case reservoirSize = "ReservoirSize"
            case resourceARN = "ResourceARN"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case serviceName = "ServiceName"
            case serviceType = "ServiceType"
            case uRLPath = "URLPath"
            case version = "Version"
        }
    }

    public struct SamplingRuleRecord: AWSDecodableShape {
        /// When the rule was created.
        public let createdAt: Date?
        /// When the rule was last modified.
        public let modifiedAt: Date?
        /// The sampling rule.
        public let samplingRule: SamplingRule?

        public init(createdAt: Date? = nil, modifiedAt: Date? = nil, samplingRule: SamplingRule? = nil) {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.samplingRule = samplingRule
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case modifiedAt = "ModifiedAt"
            case samplingRule = "SamplingRule"
        }
    }

    public struct SamplingRuleUpdate: AWSEncodableShape {
        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// Matches the hostname from a request URL.
        public let host: String?
        /// Matches the HTTP method of a request.
        public let hTTPMethod: String?
        /// The priority of the sampling rule.
        public let priority: Int?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int?
        /// Matches the ARN of the AWS resource on which the service runs.
        public let resourceARN: String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String?
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String?
        /// Matches the path from a request URL.
        public let uRLPath: String?

        public init(attributes: [String: String]? = nil, fixedRate: Double? = nil, host: String? = nil, hTTPMethod: String? = nil, priority: Int? = nil, reservoirSize: Int? = nil, resourceARN: String? = nil, ruleARN: String? = nil, ruleName: String? = nil, serviceName: String? = nil, serviceType: String? = nil, uRLPath: String? = nil) {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.hTTPMethod = hTTPMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.uRLPath = uRLPath
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.host, name: "host", parent: name, max: 64)
            try self.validate(self.hTTPMethod, name: "hTTPMethod", parent: name, max: 10)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 32)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 64)
            try self.validate(self.serviceType, name: "serviceType", parent: name, max: 64)
            try self.validate(self.uRLPath, name: "uRLPath", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case fixedRate = "FixedRate"
            case host = "Host"
            case hTTPMethod = "HTTPMethod"
            case priority = "Priority"
            case reservoirSize = "ReservoirSize"
            case resourceARN = "ResourceARN"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case serviceName = "ServiceName"
            case serviceType = "ServiceType"
            case uRLPath = "URLPath"
        }
    }

    public struct SamplingStatisticSummary: AWSDecodableShape {
        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int?
        /// The number of requests that matched the rule.
        public let requestCount: Int?
        /// The name of the sampling rule.
        public let ruleName: String?
        /// The number of requests recorded.
        public let sampledCount: Int?
        /// The start time of the reporting window.
        public let timestamp: Date?

        public init(borrowCount: Int? = nil, requestCount: Int? = nil, ruleName: String? = nil, sampledCount: Int? = nil, timestamp: Date? = nil) {
            self.borrowCount = borrowCount
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case borrowCount = "BorrowCount"
            case requestCount = "RequestCount"
            case ruleName = "RuleName"
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
        }
    }

    public struct SamplingStatisticsDocument: AWSEncodableShape {
        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int?
        /// A unique identifier for the service in hexadecimal.
        public let clientID: String
        /// The number of requests that matched the rule.
        public let requestCount: Int
        /// The name of the sampling rule.
        public let ruleName: String
        /// The number of requests recorded.
        public let sampledCount: Int
        /// The current time.
        public let timestamp: Date

        public init(borrowCount: Int? = nil, clientID: String, requestCount: Int, ruleName: String, sampledCount: Int, timestamp: Date) {
            self.borrowCount = borrowCount
            self.clientID = clientID
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.borrowCount, name: "borrowCount", parent: name, min: 0)
            try self.validate(self.clientID, name: "clientID", parent: name, max: 24)
            try self.validate(self.clientID, name: "clientID", parent: name, min: 24)
            try self.validate(self.requestCount, name: "requestCount", parent: name, min: 0)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 32)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.sampledCount, name: "sampledCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case borrowCount = "BorrowCount"
            case clientID = "ClientID"
            case requestCount = "RequestCount"
            case ruleName = "RuleName"
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
        }
    }

    public struct SamplingStrategy: AWSEncodableShape {
        /// The name of a sampling rule.
        public let name: SamplingStrategyName?
        /// The value of a sampling rule.
        public let value: Double?

        public init(name: SamplingStrategyName? = nil, value: Double? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SamplingTargetDocument: AWSDecodableShape {
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// The number of seconds for the service to wait before getting sampling targets again.
        public let interval: Int?
        /// The number of requests per second that X-Ray allocated for this service.
        public let reservoirQuota: Int?
        /// When the reservoir quota expires.
        public let reservoirQuotaTTL: Date?
        /// The name of the sampling rule.
        public let ruleName: String?

        public init(fixedRate: Double? = nil, interval: Int? = nil, reservoirQuota: Int? = nil, reservoirQuotaTTL: Date? = nil, ruleName: String? = nil) {
            self.fixedRate = fixedRate
            self.interval = interval
            self.reservoirQuota = reservoirQuota
            self.reservoirQuotaTTL = reservoirQuotaTTL
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case fixedRate = "FixedRate"
            case interval = "Interval"
            case reservoirQuota = "ReservoirQuota"
            case reservoirQuotaTTL = "ReservoirQuotaTTL"
            case ruleName = "RuleName"
        }
    }

    public struct Segment: AWSDecodableShape {
        /// The segment document.
        public let document: String?
        /// The segment's ID.
        public let id: String?

        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case document = "Document"
            case id = "Id"
        }
    }

    public struct Service: AWSDecodableShape {
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// The end time of the last segment that the service generated.
        public let endTime: Date?
        /// The canonical name of the service.
        public let name: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int?
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The start time of the first segment that the service generated.
        public let startTime: Date?
        /// The service's state.
        public let state: String?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.
        public let type: String?

        public init(accountId: String? = nil, durationHistogram: [HistogramEntry]? = nil, edges: [Edge]? = nil, endTime: Date? = nil, name: String? = nil, names: [String]? = nil, referenceId: Int? = nil, responseTimeHistogram: [HistogramEntry]? = nil, root: Bool? = nil, startTime: Date? = nil, state: String? = nil, summaryStatistics: ServiceStatistics? = nil, type: String? = nil) {
            self.accountId = accountId
            self.durationHistogram = durationHistogram
            self.edges = edges
            self.endTime = endTime
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.root = root
            self.startTime = startTime
            self.state = state
            self.summaryStatistics = summaryStatistics
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case durationHistogram = "DurationHistogram"
            case edges = "Edges"
            case endTime = "EndTime"
            case name = "Name"
            case names = "Names"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case root = "Root"
            case startTime = "StartTime"
            case state = "State"
            case summaryStatistics = "SummaryStatistics"
            case type = "Type"
        }
    }

    public struct ServiceId: AWSDecodableShape {
        public let accountId: String?
        public let name: String?
        public let names: [String]?
        public let type: String?

        public init(accountId: String? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.name = name
            self.names = names
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case name = "Name"
            case names = "Names"
            case type = "Type"
        }
    }

    public struct ServiceStatistics: AWSDecodableShape {
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?

        public init(errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, totalCount: Int64? = nil, totalResponseTime: Double? = nil) {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A tag key, such as Stage or Name. A tag key cannot be empty. The key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        public let key: String
        /// An optional tag value, such as Production or test-only. The value can be a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray group or sampling rule. For more information about ways to use tags, see Tagging AWS resources in the AWS General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for AWS use. You cannot edit or delete system tags.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TelemetryRecord: AWSEncodableShape {
        public let backendConnectionErrors: BackendConnectionErrors?
        public let segmentsReceivedCount: Int?
        public let segmentsRejectedCount: Int?
        public let segmentsSentCount: Int?
        public let segmentsSpilloverCount: Int?
        public let timestamp: Date

        public init(backendConnectionErrors: BackendConnectionErrors? = nil, segmentsReceivedCount: Int? = nil, segmentsRejectedCount: Int? = nil, segmentsSentCount: Int? = nil, segmentsSpilloverCount: Int? = nil, timestamp: Date) {
            self.backendConnectionErrors = backendConnectionErrors
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsRejectedCount = segmentsRejectedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case backendConnectionErrors = "BackendConnectionErrors"
            case segmentsReceivedCount = "SegmentsReceivedCount"
            case segmentsRejectedCount = "SegmentsRejectedCount"
            case segmentsSentCount = "SegmentsSentCount"
            case segmentsSpilloverCount = "SegmentsSpilloverCount"
            case timestamp = "Timestamp"
        }
    }

    public struct TimeSeriesServiceStatistics: AWSDecodableShape {
        public let edgeSummaryStatistics: EdgeStatistics?
        /// The response time histogram for the selected entities.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The forecasted high and low fault count values.
        public let serviceForecastStatistics: ForecastStatistics?
        public let serviceSummaryStatistics: ServiceStatistics?
        /// Timestamp of the window for which statistics are aggregated.
        public let timestamp: Date?

        public init(edgeSummaryStatistics: EdgeStatistics? = nil, responseTimeHistogram: [HistogramEntry]? = nil, serviceForecastStatistics: ForecastStatistics? = nil, serviceSummaryStatistics: ServiceStatistics? = nil, timestamp: Date? = nil) {
            self.edgeSummaryStatistics = edgeSummaryStatistics
            self.responseTimeHistogram = responseTimeHistogram
            self.serviceForecastStatistics = serviceForecastStatistics
            self.serviceSummaryStatistics = serviceSummaryStatistics
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case edgeSummaryStatistics = "EdgeSummaryStatistics"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case serviceForecastStatistics = "ServiceForecastStatistics"
            case serviceSummaryStatistics = "ServiceSummaryStatistics"
            case timestamp = "Timestamp"
        }
    }

    public struct Trace: AWSDecodableShape {
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// LimitExceeded is set to true when the trace has exceeded one of the defined quotas. For more information about quotas, see AWS X-Ray endpoints and quotas.
        public let limitExceeded: Bool?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?

        public init(duration: Double? = nil, id: String? = nil, limitExceeded: Bool? = nil, segments: [Segment]? = nil) {
            self.duration = duration
            self.id = id
            self.limitExceeded = limitExceeded
            self.segments = segments
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case id = "Id"
            case limitExceeded = "LimitExceeded"
            case segments = "Segments"
        }
    }

    public struct TraceSummary: AWSDecodableShape {
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// A list of Availability Zones for any zone corresponding to the trace segments.
        public let availabilityZones: [AvailabilityZoneDetail]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The root of a trace.
        public let entryPoint: ServiceId?
        /// A collection of ErrorRootCause structures corresponding to the trace segments.
        public let errorRootCauses: [ErrorRootCause]?
        /// A collection of FaultRootCause structures corresponding to the trace segments.
        public let faultRootCauses: [FaultRootCause]?
        /// The root segment document has a 400 series error.
        public let hasError: Bool?
        /// The root segment document has a 500 series error.
        public let hasFault: Bool?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// A list of EC2 instance IDs for any instance corresponding to the trace segments.
        public let instanceIds: [InstanceIdDetail]?
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// The matched time stamp of a defined event.
        public let matchedEventTime: Date?
        /// A list of resource ARNs for any resource corresponding to the trace segments.
        public let resourceARNs: [ResourceARNDetail]?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?
        /// A collection of ResponseTimeRootCause structures corresponding to the trace segments.
        public let responseTimeRootCauses: [ResponseTimeRootCause]?
        /// The revision number of a trace.
        public let revision: Int?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?

        public init(annotations: [String: [ValueWithServiceIds]]? = nil, availabilityZones: [AvailabilityZoneDetail]? = nil, duration: Double? = nil, entryPoint: ServiceId? = nil, errorRootCauses: [ErrorRootCause]? = nil, faultRootCauses: [FaultRootCause]? = nil, hasError: Bool? = nil, hasFault: Bool? = nil, hasThrottle: Bool? = nil, http: Http? = nil, id: String? = nil, instanceIds: [InstanceIdDetail]? = nil, isPartial: Bool? = nil, matchedEventTime: Date? = nil, resourceARNs: [ResourceARNDetail]? = nil, responseTime: Double? = nil, responseTimeRootCauses: [ResponseTimeRootCause]? = nil, revision: Int? = nil, serviceIds: [ServiceId]? = nil, users: [TraceUser]? = nil) {
            self.annotations = annotations
            self.availabilityZones = availabilityZones
            self.duration = duration
            self.entryPoint = entryPoint
            self.errorRootCauses = errorRootCauses
            self.faultRootCauses = faultRootCauses
            self.hasError = hasError
            self.hasFault = hasFault
            self.hasThrottle = hasThrottle
            self.http = http
            self.id = id
            self.instanceIds = instanceIds
            self.isPartial = isPartial
            self.matchedEventTime = matchedEventTime
            self.resourceARNs = resourceARNs
            self.responseTime = responseTime
            self.responseTimeRootCauses = responseTimeRootCauses
            self.revision = revision
            self.serviceIds = serviceIds
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case annotations = "Annotations"
            case availabilityZones = "AvailabilityZones"
            case duration = "Duration"
            case entryPoint = "EntryPoint"
            case errorRootCauses = "ErrorRootCauses"
            case faultRootCauses = "FaultRootCauses"
            case hasError = "HasError"
            case hasFault = "HasFault"
            case hasThrottle = "HasThrottle"
            case http = "Http"
            case id = "Id"
            case instanceIds = "InstanceIds"
            case isPartial = "IsPartial"
            case matchedEventTime = "MatchedEventTime"
            case resourceARNs = "ResourceARNs"
            case responseTime = "ResponseTime"
            case responseTimeRootCauses = "ResponseTimeRootCauses"
            case revision = "Revision"
            case serviceIds = "ServiceIds"
            case users = "Users"
        }
    }

    public struct TraceUser: AWSDecodableShape {
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIds = "ServiceIds"
            case userName = "UserName"
        }
    }

    public struct UnprocessedStatistics: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?
        /// The name of the sampling rule.
        public let ruleName: String?

        public init(errorCode: String? = nil, message: String? = nil, ruleName: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
            case ruleName = "RuleName"
        }
    }

    public struct UnprocessedTraceSegment: AWSDecodableShape {
        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The segment's ID.
        public let id: String?
        /// The error message.
        public let message: String?

        public init(errorCode: String? = nil, id: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case id = "Id"
            case message = "Message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String
        /// Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        /// The updated filter expression defining criteria by which to group traces.
        public let filterExpression: String?
        /// The ARN that was generated upon creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights.   The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.   The NotifcationsEnabled boolean can be set to true to enable insights notifications for the group. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public let insightsConfiguration: InsightsConfiguration?

        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.groupARN, name: "groupARN", parent: name, max: 400)
            try self.validate(self.groupARN, name: "groupARN", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, max: 32)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct UpdateGroupResult: AWSDecodableShape {
        /// The group that was updated. Contains the name of the group that was updated, the ARN of the group that was updated, the updated filter expression, and the updated insight configuration assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct UpdateSamplingRuleRequest: AWSEncodableShape {
        /// The rule and fields to change.
        public let samplingRuleUpdate: SamplingRuleUpdate

        public init(samplingRuleUpdate: SamplingRuleUpdate) {
            self.samplingRuleUpdate = samplingRuleUpdate
        }

        public func validate(name: String) throws {
            try self.samplingRuleUpdate.validate(name: "\(name).samplingRuleUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleUpdate = "SamplingRuleUpdate"
        }
    }

    public struct UpdateSamplingRuleResult: AWSDecodableShape {
        /// The updated rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct ValueWithServiceIds: AWSDecodableShape {
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?

        public init(annotationValue: AnnotationValue? = nil, serviceIds: [ServiceId]? = nil) {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }

        private enum CodingKeys: String, CodingKey {
            case annotationValue = "AnnotationValue"
            case serviceIds = "ServiceIds"
        }
    }
}
