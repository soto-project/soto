//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension KendraRanking {
    // MARK: Enums

    public enum RescoreExecutionPlanStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CapacityUnitsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The amount of extra capacity for your rescore execution  plan. A single extra capacity unit for a rescore execution  plan provides 0.01 rescore requests per second. You can add  up to 1000 extra capacity units.
        public let rescoreCapacityUnits: Int

        public init(rescoreCapacityUnits: Int) {
            self.rescoreCapacityUnits = rescoreCapacityUnits
        }

        public func validate(name: String) throws {
            try self.validate(self.rescoreCapacityUnits, name: "rescoreCapacityUnits", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case rescoreCapacityUnits = "RescoreCapacityUnits"
        }
    }

    public struct CreateRescoreExecutionPlanRequest: AWSEncodableShape {
        /// You can set additional capacity units to meet the  needs of your rescore execution plan. You are given a single  capacity unit by default. If you want to use the default  capacity, you don't set additional capacity units. For more  information on the default capacity and additional capacity  units, see Adjusting  capacity.
        public let capacityUnits: CapacityUnitsConfiguration?
        /// A token that you provide to identify the request to create  a rescore execution plan. Multiple calls to the  CreateRescoreExecutionPlanRequest API with the  same client token will create only one rescore execution plan.
        public let clientToken: String?
        /// A description for the rescore execution plan.
        public let description: String?
        /// A name for the rescore execution plan.
        public let name: String
        /// A list of key-value pairs that identify or categorize your  rescore execution plan. You can also use tags to help control  access to the rescore execution plan. Tag keys and values can  consist of Unicode letters, digits, white space, and any of  the following symbols: _ . : / = + - @.
        public let tags: [Tag]?

        public init(capacityUnits: CapacityUnitsConfiguration? = nil, clientToken: String? = CreateRescoreExecutionPlanRequest.idempotencyToken(), description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.capacityUnits = capacityUnits
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.capacityUnits?.validate(name: "\(name).capacityUnits")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^$|[\\x00-\\x7F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case capacityUnits = "CapacityUnits"
            case clientToken = "ClientToken"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateRescoreExecutionPlanResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rescore  execution plan.
        public let arn: String
        /// The identifier of the rescore execution plan.
        public let id: String

        public init(arn: String, id: String) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct DeleteRescoreExecutionPlanRequest: AWSEncodableShape {
        /// The identifier of the rescore execution plan that you  want to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRescoreExecutionPlanRequest: AWSEncodableShape {
        /// The identifier of the rescore execution plan that you want  to get information on.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRescoreExecutionPlanResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rescore execution  plan.
        public let arn: String?
        /// The capacity units set for the rescore execution plan.  A capacity of zero indicates that the rescore execution  plan is using the default capacity. For more information on the  default capacity and additional capacity units, see Adjusting  capacity.
        public let capacityUnits: CapacityUnitsConfiguration?
        /// The Unix timestamp of when the rescore execution plan was  created.
        public let createdAt: Date?
        /// The description for the rescore execution plan.
        public let description: String?
        /// When the Status field value is  FAILED, the ErrorMessage field  contains a message that explains why.
        public let errorMessage: String?
        /// The identifier of the rescore execution plan.
        public let id: String?
        /// The name for the rescore execution plan.
        public let name: String?
        /// The current status of the rescore execution plan. When the  value is ACTIVE, the rescore execution plan is  ready for use. If the Status field value is  FAILED, the ErrorMessage field  contains a message that explains why.
        public let status: RescoreExecutionPlanStatus?
        /// The Unix timestamp of when the rescore execution plan was  last updated.
        public let updatedAt: Date?

        public init(arn: String? = nil, capacityUnits: CapacityUnitsConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, errorMessage: String? = nil, id: String? = nil, name: String? = nil, status: RescoreExecutionPlanStatus? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.capacityUnits = capacityUnits
            self.createdAt = createdAt
            self.description = description
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityUnits = "CapacityUnits"
            case createdAt = "CreatedAt"
            case description = "Description"
            case errorMessage = "ErrorMessage"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Document: AWSEncodableShape {
        /// The body text of the search service's document.
        public let body: String?
        /// The optional group identifier of the document from the search  service. Documents with the same group identifier are grouped  together and processed as one document within the service.
        public let groupId: String?
        /// The identifier of the document from the search service.
        public let id: String
        /// The original document score or rank from the search service.  Amazon Kendra Intelligent Ranking gives the document a new  score or rank based on its intelligent search algorithms.
        public let originalScore: Float
        /// The title of the search service's document.
        public let title: String?
        /// The body text of the search service's document represented  as a list of tokens or words. You must choose to provide  Body or TokenizedBody. You cannot  provide both.
        public let tokenizedBody: [String]?
        /// The title of the search service's document represented as  a list of tokens or words. You must choose to provide  Title or TokenizedTitle. You cannot provide both.
        public let tokenizedTitle: [String]?

        public init(body: String? = nil, groupId: String? = nil, id: String, originalScore: Float, title: String? = nil, tokenizedBody: [String]? = nil, tokenizedTitle: [String]? = nil) {
            self.body = body
            self.groupId = groupId
            self.id = id
            self.originalScore = originalScore
            self.title = title
            self.tokenizedBody = tokenizedBody
            self.tokenizedTitle = tokenizedTitle
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 2048)
            try self.validate(self.body, name: "body", parent: name, min: 1)
            try self.validate(self.body, name: "body", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.groupId, name: "groupId", parent: name, max: 2048)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 2048)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.originalScore, name: "originalScore", parent: name, max: 100000.0)
            try self.validate(self.originalScore, name: "originalScore", parent: name, min: -100000.0)
            try self.validate(self.title, name: "title", parent: name, max: 1024)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.tokenizedBody?.forEach {
                try validate($0, name: "tokenizedBody[]", parent: name, max: 2048)
                try validate($0, name: "tokenizedBody[]", parent: name, min: 1)
            }
            try self.validate(self.tokenizedBody, name: "tokenizedBody", parent: name, min: 1)
            try self.tokenizedTitle?.forEach {
                try validate($0, name: "tokenizedTitle[]", parent: name, max: 2048)
                try validate($0, name: "tokenizedTitle[]", parent: name, min: 1)
            }
            try self.validate(self.tokenizedTitle, name: "tokenizedTitle", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case groupId = "GroupId"
            case id = "Id"
            case originalScore = "OriginalScore"
            case title = "Title"
            case tokenizedBody = "TokenizedBody"
            case tokenizedTitle = "TokenizedTitle"
        }
    }

    public struct ListRescoreExecutionPlansRequest: AWSEncodableShape {
        /// The maximum number of rescore execution plans to return.
        public let maxResults: Int?
        /// If the response is truncated, Amazon Kendra Intelligent  Ranking returns a pagination token in the response. You can use  this pagination token to retrieve the next set of rescore  execution plans.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRescoreExecutionPlansResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Kendra Intelligent  Ranking returns a pagination token in the response.
        public let nextToken: String?
        /// An array of summary information for one or more rescore  execution plans.
        public let summaryItems: [RescoreExecutionPlanSummary]?

        public init(nextToken: String? = nil, summaryItems: [RescoreExecutionPlanSummary]? = nil) {
            self.nextToken = nextToken
            self.summaryItems = summaryItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case summaryItems = "SummaryItems"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the rescore execution  plan to get a list of tags for.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the rescore execution  plan.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct RescoreExecutionPlanSummary: AWSDecodableShape {
        /// The Unix timestamp when the rescore execution plan  was created.
        public let createdAt: Date?
        /// The identifier of the rescore execution plan.
        public let id: String?
        /// The name of the rescore execution plan.
        public let name: String?
        /// The current status of the rescore execution plan. When  the value is ACTIVE, the rescore execution  plan is ready for use.
        public let status: RescoreExecutionPlanStatus?
        /// The Unix timestamp when the rescore execution plan  was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, id: String? = nil, name: String? = nil, status: RescoreExecutionPlanStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct RescoreRequest: AWSEncodableShape {
        /// The list of documents for Amazon Kendra Intelligent  Ranking to rescore or rank on.
        public let documents: [Document]
        /// The identifier of the rescore execution plan. A rescore  execution plan is an Amazon Kendra Intelligent Ranking  resource used for provisioning the Rescore API.
        public let rescoreExecutionPlanId: String
        /// The input query from the search service.
        public let searchQuery: String

        public init(documents: [Document], rescoreExecutionPlanId: String, searchQuery: String) {
            self.documents = documents
            self.rescoreExecutionPlanId = rescoreExecutionPlanId
            self.searchQuery = searchQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.documents, forKey: .documents)
            request.encodePath(self.rescoreExecutionPlanId, key: "RescoreExecutionPlanId")
            try container.encode(self.searchQuery, forKey: .searchQuery)
        }

        public func validate(name: String) throws {
            try self.documents.forEach {
                try $0.validate(name: "\(name).documents[]")
            }
            try self.validate(self.documents, name: "documents", parent: name, min: 1)
            try self.validate(self.rescoreExecutionPlanId, name: "rescoreExecutionPlanId", parent: name, max: 36)
            try self.validate(self.rescoreExecutionPlanId, name: "rescoreExecutionPlanId", parent: name, min: 36)
            try self.validate(self.rescoreExecutionPlanId, name: "rescoreExecutionPlanId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.searchQuery, name: "searchQuery", parent: name, max: 1000)
            try self.validate(self.searchQuery, name: "searchQuery", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case documents = "Documents"
            case searchQuery = "SearchQuery"
        }
    }

    public struct RescoreResult: AWSDecodableShape {
        /// The identifier associated with the scores that  Amazon Kendra Intelligent Ranking gives to the  results. Amazon Kendra Intelligent Ranking  rescores or re-ranks the results for the search service.
        public let rescoreId: String?
        /// A list of result items for documents with new relevancy  scores. The results are in descending order.
        public let resultItems: [RescoreResultItem]?

        public init(rescoreId: String? = nil, resultItems: [RescoreResultItem]? = nil) {
            self.rescoreId = rescoreId
            self.resultItems = resultItems
        }

        private enum CodingKeys: String, CodingKey {
            case rescoreId = "RescoreId"
            case resultItems = "ResultItems"
        }
    }

    public struct RescoreResultItem: AWSDecodableShape {
        /// The identifier of the document from the search service.
        public let documentId: String?
        /// The relevancy score or rank that Amazon Kendra  Intelligent Ranking gives to the result.
        public let score: Float?

        public init(documentId: String? = nil, score: Float? = nil) {
            self.documentId = documentId
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case documentId = "DocumentId"
            case score = "Score"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key for the tag. Keys are not case sensitive and must  be unique.
        public let key: String
        /// The value associated with the tag. The value can be an  empty string but it can't be null.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the rescore execution  plan to tag.
        public let resourceARN: String
        /// A list of tag keys to add to a rescore execution plan.  If a tag already exists, the existing value is replaced  with the new value.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the rescore execution  plan to remove the tag.
        public let resourceARN: String
        /// A list of tag keys to remove from the rescore execution  plan. If a tag key does not exist on the resource, it is  ignored.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRescoreExecutionPlanRequest: AWSEncodableShape {
        /// You can set additional capacity units to meet the needs  of your rescore execution plan. You are given a single capacity  unit by default. If you want to use the default capacity, you  don't set additional capacity units. For more information on the default capacity and additional capacity units, see  Adjusting capacity.
        public let capacityUnits: CapacityUnitsConfiguration?
        /// A new description for the rescore execution plan.
        public let description: String?
        /// The identifier of the rescore execution plan that you want  to update.
        public let id: String
        /// A new name for the rescore execution plan.
        public let name: String?

        public init(capacityUnits: CapacityUnitsConfiguration? = nil, description: String? = nil, id: String, name: String? = nil) {
            self.capacityUnits = capacityUnits
            self.description = description
            self.id = id
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capacityUnits, forKey: .capacityUnits)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.capacityUnits?.validate(name: "\(name).capacityUnits")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityUnits = "CapacityUnits"
            case description = "Description"
            case name = "Name"
        }
    }
}

// MARK: - Errors

/// Error enum for KendraRanking
public struct KendraRankingErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceUnavailableException = "ResourceUnavailableException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize KendraRanking
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don’t have sufficient access to perform this action.  Please ensure you have the required permission policies  and user accounts and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A conflict occurred with the request. Please fix any  inconsistencies with your resources and try again.
    public static var conflictException: Self { .init(.conflictException) }
    /// An issue occurred with the internal server used for  your Amazon Kendra Intelligent Ranking service.  Please wait a few minutes and try again, or contact  Support  for help.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource you want to use doesn't exist. Please  check you have provided the correct resource and try  again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The resource you want to use is unavailable. Please  check you have provided the correct resource  information and try again.
    public static var resourceUnavailableException: Self { .init(.resourceUnavailableException) }
    /// You have exceeded the set limits for your  Amazon Kendra Intelligent Ranking service. Please  see Quotas  for more information, or contact Support to inquire about  an increase of limits.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.  Please reduce the number of requests and try again.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints set by  the Amazon Kendra Intelligent Ranking service.  Please provide the correct input and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension KendraRankingErrorType: Equatable {
    public static func == (lhs: KendraRankingErrorType, rhs: KendraRankingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension KendraRankingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
