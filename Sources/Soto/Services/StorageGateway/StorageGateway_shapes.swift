//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension StorageGateway {
    // MARK: Enums

    public enum ActiveDirectoryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case detached = "DETACHED"
        case insufficientPermissions = "INSUFFICIENT_PERMISSIONS"
        case joined = "JOINED"
        case joining = "JOINING"
        case networkError = "NETWORK_ERROR"
        case timeout = "TIMEOUT"
        case unknownError = "UNKNOWN_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum AutomaticUpdatePolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allVersions = "ALL_VERSIONS"
        case emergencyVersionsOnly = "EMERGENCY_VERSIONS_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum AvailabilityMonitorTestStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum CacheReportFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case uploadFailureReason = "UploadFailureReason"
        case uploadState = "UploadState"
        public var description: String { return self.rawValue }
    }

    public enum CacheReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case completed = "COMPLETED"
        case error = "ERROR"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum CaseSensitivity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case caseSensitive = "CaseSensitive"
        case clientSpecified = "ClientSpecified"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dsseKms = "DsseKms"
        case sseKms = "SseKms"
        case sseS3 = "SseS3"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activationKeyExpired = "ActivationKeyExpired"
        case activationKeyInvalid = "ActivationKeyInvalid"
        case activationKeyNotFound = "ActivationKeyNotFound"
        case authenticationFailure = "AuthenticationFailure"
        case bandwidthThrottleScheduleNotFound = "BandwidthThrottleScheduleNotFound"
        case blocked = "Blocked"
        case cannotExportSnapshot = "CannotExportSnapshot"
        case chapCredentialNotFound = "ChapCredentialNotFound"
        case diskAlreadyAllocated = "DiskAlreadyAllocated"
        case diskDoesNotExist = "DiskDoesNotExist"
        case diskSizeGreaterThanVolumeMaxSize = "DiskSizeGreaterThanVolumeMaxSize"
        case diskSizeLessThanVolumeSize = "DiskSizeLessThanVolumeSize"
        case diskSizeNotGigAligned = "DiskSizeNotGigAligned"
        case duplicateCertificateInfo = "DuplicateCertificateInfo"
        case duplicateSchedule = "DuplicateSchedule"
        case endpointNotFound = "EndpointNotFound"
        case gatewayInternalError = "GatewayInternalError"
        case gatewayNotConnected = "GatewayNotConnected"
        case gatewayNotFound = "GatewayNotFound"
        case gatewayProxyNetworkConnectionBusy = "GatewayProxyNetworkConnectionBusy"
        case iamNotSupported = "IAMNotSupported"
        case initiatorInvalid = "InitiatorInvalid"
        case initiatorNotFound = "InitiatorNotFound"
        case internalError = "InternalError"
        case invalidEndpoint = "InvalidEndpoint"
        case invalidGateway = "InvalidGateway"
        case invalidParameters = "InvalidParameters"
        case invalidSchedule = "InvalidSchedule"
        case joinDomainInProgress = "JoinDomainInProgress"
        case localStorageLimitExceeded = "LocalStorageLimitExceeded"
        case lunAlreadyAllocated = "LunAlreadyAllocated "
        case lunInvalid = "LunInvalid"
        case maximumContentLengthExceeded = "MaximumContentLengthExceeded"
        case maximumTapeCartridgeCountExceeded = "MaximumTapeCartridgeCountExceeded"
        case maximumVolumeCountExceeded = "MaximumVolumeCountExceeded"
        case networkConfigurationChanged = "NetworkConfigurationChanged"
        case noDisksAvailable = "NoDisksAvailable"
        case notImplemented = "NotImplemented"
        case notSupported = "NotSupported"
        case operationAborted = "OperationAborted"
        case outdatedGateway = "OutdatedGateway"
        case parametersNotImplemented = "ParametersNotImplemented"
        case regionInvalid = "RegionInvalid"
        case requestTimeout = "RequestTimeout"
        case serviceUnavailable = "ServiceUnavailable"
        case snapshotDeleted = "SnapshotDeleted"
        case snapshotIdInvalid = "SnapshotIdInvalid"
        case snapshotInProgress = "SnapshotInProgress"
        case snapshotNotFound = "SnapshotNotFound"
        case snapshotScheduleNotFound = "SnapshotScheduleNotFound"
        case stagingAreaFull = "StagingAreaFull"
        case storageFailure = "StorageFailure"
        case tapeCartridgeNotFound = "TapeCartridgeNotFound"
        case targetAlreadyExists = "TargetAlreadyExists"
        case targetInvalid = "TargetInvalid"
        case targetNotFound = "TargetNotFound"
        case unauthorizedOperation = "UnauthorizedOperation"
        case volumeAlreadyExists = "VolumeAlreadyExists"
        case volumeIdInvalid = "VolumeIdInvalid"
        case volumeInUse = "VolumeInUse"
        case volumeNotFound = "VolumeNotFound"
        case volumeNotReady = "VolumeNotReady"
        public var description: String { return self.rawValue }
    }

    public enum FileShareType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nfs = "NFS"
        case smb = "SMB"
        public var description: String { return self.rawValue }
    }

    public enum GatewayCapacity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "Large"
        case medium = "Medium"
        case small = "Small"
        public var description: String { return self.rawValue }
    }

    public enum HostEnvironment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2 = "EC2"
        case hyperV = "HYPER-V"
        case kvm = "KVM"
        case other = "OTHER"
        case snowball = "SNOWBALL"
        case vmware = "VMWARE"
        public var description: String { return self.rawValue }
    }

    public enum ObjectACL: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "private"
        case authenticatedRead = "authenticated-read"
        case awsExecRead = "aws-exec-read"
        case bucketOwnerFullControl = "bucket-owner-full-control"
        case bucketOwnerRead = "bucket-owner-read"
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        public var description: String { return self.rawValue }
    }

    public enum PoolStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public enum RetentionLockType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compliance = "COMPLIANCE"
        case governance = "GOVERNANCE"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum SMBSecurityStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clientSpecified = "ClientSpecified"
        case mandatoryEncryption = "MandatoryEncryption"
        case mandatoryEncryptionNoAes128 = "MandatoryEncryptionNoAes128"
        case mandatorySigning = "MandatorySigning"
        public var description: String { return self.rawValue }
    }

    public enum TapeStorageClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deepArchive = "DEEP_ARCHIVE"
        case glacier = "GLACIER"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActivateGatewayInput: AWSEncodableShape {
        /// Your gateway activation key. You can obtain the activation key by sending an HTTP GET request with redirects enabled to the gateway IP address (port 80). The redirect URL returned in the response provides you the activation key for your gateway in the query string parameter activationKey. It may also include other activation-related parameters, however, these are merely defaults -- the arguments you pass to the ActivateGateway API call determine the actual configuration of your gateway. For more information, see Getting activation key in the Storage Gateway User Guide.
        public let activationKey: String
        /// The name you configured for your gateway.
        public let gatewayName: String
        /// A value that indicates the Amazon Web Services Region where you want to store your data. The gateway Amazon Web Services Region specified must be the same Amazon Web Services Region as the Amazon Web Services Region in your Host header in the request. For more information about available Amazon Web Services Regions and endpoints for Storage Gateway, see  Storage Gateway endpoints and quotas in the Amazon Web Services General Reference. Valid Values: See  Storage Gateway endpoints and quotas in the Amazon Web Services General Reference.
        public let gatewayRegion: String
        /// A value that indicates the time zone you want to set for the gateway. The time zone is of the format "GMT", "GMT-hr:mm", or "GMT+hr:mm". For example, GMT indicates Greenwich Mean Time without any offset. GMT-4:00 indicates the time is 4 hours behind GMT. GMT+2:00 indicates the time is 2 hours ahead of GMT. The time zone is used, for example, for scheduling snapshots and your gateway's maintenance schedule.
        public let gatewayTimezone: String
        /// A value that defines the type of gateway to activate. The type specified is critical to all later functions of the gateway and cannot be changed after activation. The default value is CACHED.  Amazon FSx File Gateway is no longer available to new customers. Existing customers of FSx File Gateway can continue to use the service normally. For capabilities similar to FSx File Gateway, visit this blog post.  Valid Values: STORED | CACHED | VTL | FILE_S3 | FILE_FSX_SMB
        public let gatewayType: String?
        /// The value that indicates the type of medium changer to use for tape gateway. This field is optional. Valid Values: STK-L700 | AWS-Gateway-VTL | IBM-03584L32-0402
        public let mediumChangerType: String?
        /// A list of up to 50 tags that you can assign to the gateway. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers that can be represented in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256 characters.
        public let tags: [Tag]?
        /// The value that indicates the type of tape drive to use for tape gateway. This field is optional. Valid Values: IBM-ULT3580-TD5
        public let tapeDriveType: String?

        @inlinable
        public init(activationKey: String, gatewayName: String, gatewayRegion: String, gatewayTimezone: String, gatewayType: String? = nil, mediumChangerType: String? = nil, tags: [Tag]? = nil, tapeDriveType: String? = nil) {
            self.activationKey = activationKey
            self.gatewayName = gatewayName
            self.gatewayRegion = gatewayRegion
            self.gatewayTimezone = gatewayTimezone
            self.gatewayType = gatewayType
            self.mediumChangerType = mediumChangerType
            self.tags = tags
            self.tapeDriveType = tapeDriveType
        }

        public func validate(name: String) throws {
            try self.validate(self.activationKey, name: "activationKey", parent: name, max: 50)
            try self.validate(self.activationKey, name: "activationKey", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 255)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 2)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[ -\\.0-\\[\\]-~]*[!-\\.0-\\[\\]-~][ -\\.0-\\[\\]-~]*$")
            try self.validate(self.gatewayRegion, name: "gatewayRegion", parent: name, max: 25)
            try self.validate(self.gatewayRegion, name: "gatewayRegion", parent: name, min: 1)
            try self.validate(self.gatewayTimezone, name: "gatewayTimezone", parent: name, max: 10)
            try self.validate(self.gatewayTimezone, name: "gatewayTimezone", parent: name, min: 3)
            try self.validate(self.gatewayType, name: "gatewayType", parent: name, max: 20)
            try self.validate(self.gatewayType, name: "gatewayType", parent: name, min: 2)
            try self.validate(self.mediumChangerType, name: "mediumChangerType", parent: name, max: 50)
            try self.validate(self.mediumChangerType, name: "mediumChangerType", parent: name, min: 2)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tapeDriveType, name: "tapeDriveType", parent: name, max: 50)
            try self.validate(self.tapeDriveType, name: "tapeDriveType", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case activationKey = "ActivationKey"
            case gatewayName = "GatewayName"
            case gatewayRegion = "GatewayRegion"
            case gatewayTimezone = "GatewayTimezone"
            case gatewayType = "GatewayType"
            case mediumChangerType = "MediumChangerType"
            case tags = "Tags"
            case tapeDriveType = "TapeDriveType"
        }
    }

    public struct ActivateGatewayOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AddCacheInput: AWSEncodableShape {
        /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the ListLocalDisks API.
        public let diskIds: [String]
        public let gatewayARN: String

        @inlinable
        public init(diskIds: [String], gatewayARN: String) {
            self.diskIds = diskIds
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.diskIds.forEach {
                try validate($0, name: "diskIds[]", parent: name, max: 300)
                try validate($0, name: "diskIds[]", parent: name, min: 1)
            }
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case diskIds = "DiskIds"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AddCacheOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AddTagsToResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
        public let resourceARN: String
        /// The key-value pair that represents the tag you want to add to the resource. The value can be an empty string.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 50)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct AddTagsToResourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
        public let resourceARN: String?

        @inlinable
        public init(resourceARN: String? = nil) {
            self.resourceARN = resourceARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct AddUploadBufferInput: AWSEncodableShape {
        /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the ListLocalDisks API.
        public let diskIds: [String]
        public let gatewayARN: String

        @inlinable
        public init(diskIds: [String], gatewayARN: String) {
            self.diskIds = diskIds
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.diskIds.forEach {
                try validate($0, name: "diskIds[]", parent: name, max: 300)
                try validate($0, name: "diskIds[]", parent: name, min: 1)
            }
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case diskIds = "DiskIds"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AddUploadBufferOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AddWorkingStorageInput: AWSEncodableShape {
        /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the ListLocalDisks API.
        public let diskIds: [String]
        public let gatewayARN: String

        @inlinable
        public init(diskIds: [String], gatewayARN: String) {
            self.diskIds = diskIds
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.diskIds.forEach {
                try validate($0, name: "diskIds[]", parent: name, max: 300)
                try validate($0, name: "diskIds[]", parent: name, min: 1)
            }
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case diskIds = "DiskIds"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AddWorkingStorageOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AssignTapePoolInput: AWSEncodableShape {
        /// Set permissions to bypass governance retention. If the lock type of the archived tape is Governance, the tape's archived age is not older than RetentionLockInDays, and the user does not already have BypassGovernanceRetention, setting this to TRUE enables the user to bypass the retention lock. This parameter is set to true by default for calls from the console. Valid values: TRUE | FALSE
        public let bypassGovernanceRetention: Bool?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let poolId: String
        /// The unique Amazon Resource Name (ARN) of the virtual tape that you want to add to the tape pool.
        public let tapeARN: String

        @inlinable
        public init(bypassGovernanceRetention: Bool? = nil, poolId: String, tapeARN: String) {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.poolId = poolId
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.poolId, name: "poolId", parent: name, max: 100)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bypassGovernanceRetention = "BypassGovernanceRetention"
            case poolId = "PoolId"
            case tapeARN = "TapeARN"
        }
    }

    public struct AssignTapePoolOutput: AWSDecodableShape {
        /// The unique Amazon Resource Names (ARN) of the virtual tape that was added to the tape pool.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct AssociateFileSystemInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
        public let auditDestinationARN: String?
        public let cacheAttributes: CacheAttributes?
        /// A unique string value that you supply that is used by the FSx File Gateway to ensure idempotent file system association creation.
        public let clientToken: String
        /// Specifies the network configuration information for the gateway associated with the Amazon FSx file system.  If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
        public let endpointNetworkConfiguration: EndpointNetworkConfiguration?
        public let gatewayARN: String
        /// The Amazon Resource Name (ARN) of the Amazon FSx file system to associate with the FSx File Gateway.
        public let locationARN: String
        /// The password of the user credential.
        public let password: String
        /// A list of up to 50 tags that can be assigned to the file system association. Each tag is a key-value pair.
        public let tags: [Tag]?
        /// The user name of the user credential that has permission to access the root share D$ of the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin user group.
        public let userName: String

        @inlinable
        public init(auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, clientToken: String, endpointNetworkConfiguration: EndpointNetworkConfiguration? = nil, gatewayARN: String, locationARN: String, password: String, tags: [Tag]? = nil, userName: String) {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.clientToken = clientToken
            self.endpointNetworkConfiguration = endpointNetworkConfiguration
            self.gatewayARN = gatewayARN
            self.locationARN = locationARN
            self.password = password
            self.tags = tags
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.auditDestinationARN, name: "auditDestinationARN", parent: name, max: 1024)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 5)
            try self.endpointNetworkConfiguration?.validate(name: "\(name).endpointNetworkConfiguration")
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.locationARN, name: "locationARN", parent: name, max: 512)
            try self.validate(self.locationARN, name: "locationARN", parent: name, min: 8)
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[ -~]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.userName, name: "userName", parent: name, max: 1024)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^\\w[\\w\\.\\- ]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case auditDestinationARN = "AuditDestinationARN"
            case cacheAttributes = "CacheAttributes"
            case clientToken = "ClientToken"
            case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
            case gatewayARN = "GatewayARN"
            case locationARN = "LocationARN"
            case password = "Password"
            case tags = "Tags"
            case userName = "UserName"
        }
    }

    public struct AssociateFileSystemOutput: AWSDecodableShape {
        /// The ARN of the newly created file system association.
        public let fileSystemAssociationARN: String?

        @inlinable
        public init(fileSystemAssociationARN: String? = nil) {
            self.fileSystemAssociationARN = fileSystemAssociationARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationARN = "FileSystemAssociationARN"
        }
    }

    public struct AttachVolumeInput: AWSEncodableShape {
        /// The unique device ID or other distinguishing data that identifies the local disk used to create the volume. This value is only required when you are attaching a stored volume.
        public let diskId: String?
        /// The Amazon Resource Name (ARN) of the gateway that you want to attach the volume to.
        public let gatewayARN: String
        /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use DescribeGatewayInformation to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
        public let networkInterfaceId: String
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public let targetName: String?
        /// The Amazon Resource Name (ARN) of the volume to attach to the specified gateway.
        public let volumeARN: String

        @inlinable
        public init(diskId: String? = nil, gatewayARN: String, networkInterfaceId: String, targetName: String? = nil, volumeARN: String) {
            self.diskId = diskId
            self.gatewayARN = gatewayARN
            self.networkInterfaceId = networkInterfaceId
            self.targetName = targetName
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.diskId, name: "diskId", parent: name, max: 300)
            try self.validate(self.diskId, name: "diskId", parent: name, min: 1)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "^\\A(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\z$")
            try self.validate(self.targetName, name: "targetName", parent: name, max: 200)
            try self.validate(self.targetName, name: "targetName", parent: name, min: 1)
            try self.validate(self.targetName, name: "targetName", parent: name, pattern: "^[-\\.;a-z0-9]+$")
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case diskId = "DiskId"
            case gatewayARN = "GatewayARN"
            case networkInterfaceId = "NetworkInterfaceId"
            case targetName = "TargetName"
            case volumeARN = "VolumeARN"
        }
    }

    public struct AttachVolumeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name for the initiator that was used to connect to the target.
        public let targetARN: String?
        /// The Amazon Resource Name (ARN) of the volume that was attached to the gateway.
        public let volumeARN: String?

        @inlinable
        public init(targetARN: String? = nil, volumeARN: String? = nil) {
            self.targetARN = targetARN
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case targetARN = "TargetARN"
            case volumeARN = "VolumeARN"
        }
    }

    public struct AutomaticTapeCreationPolicyInfo: AWSDecodableShape {
        /// An automatic tape creation policy consists of a list of automatic tape creation rules. This returns the rules that determine when and how to automatically create new tapes.
        public let automaticTapeCreationRules: [AutomaticTapeCreationRule]?
        public let gatewayARN: String?

        @inlinable
        public init(automaticTapeCreationRules: [AutomaticTapeCreationRule]? = nil, gatewayARN: String? = nil) {
            self.automaticTapeCreationRules = automaticTapeCreationRules
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTapeCreationRules = "AutomaticTapeCreationRules"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct AutomaticTapeCreationRule: AWSEncodableShape & AWSDecodableShape {
        /// The minimum number of available virtual tapes that the gateway maintains at all times. If the number of tapes on the gateway goes below this value, the gateway creates as many new tapes as are needed to have MinimumNumTapes on the gateway. For more information about automatic tape creation, see Creating Tapes Automatically.
        public let minimumNumTapes: Int
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the Amazon S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let poolId: String
        /// A prefix that you append to the barcode of the virtual tape that you are creating. This prefix makes the barcode unique.  The prefix must be 1-4 characters in length and must be one of the uppercase letters from A to Z.
        public let tapeBarcodePrefix: String
        /// The size, in bytes, of the virtual tape capacity.
        public let tapeSizeInBytes: Int64
        /// Set to true to indicate that tapes are to be archived as write-once-read-many (WORM). Set to false when WORM is not enabled for tapes.
        public let worm: Bool?

        @inlinable
        public init(minimumNumTapes: Int, poolId: String, tapeBarcodePrefix: String, tapeSizeInBytes: Int64, worm: Bool? = nil) {
            self.minimumNumTapes = minimumNumTapes
            self.poolId = poolId
            self.tapeBarcodePrefix = tapeBarcodePrefix
            self.tapeSizeInBytes = tapeSizeInBytes
            self.worm = worm
        }

        public func validate(name: String) throws {
            try self.validate(self.minimumNumTapes, name: "minimumNumTapes", parent: name, max: 10)
            try self.validate(self.minimumNumTapes, name: "minimumNumTapes", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, max: 100)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.tapeBarcodePrefix, name: "tapeBarcodePrefix", parent: name, max: 4)
            try self.validate(self.tapeBarcodePrefix, name: "tapeBarcodePrefix", parent: name, min: 1)
            try self.validate(self.tapeBarcodePrefix, name: "tapeBarcodePrefix", parent: name, pattern: "^[A-Z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case minimumNumTapes = "MinimumNumTapes"
            case poolId = "PoolId"
            case tapeBarcodePrefix = "TapeBarcodePrefix"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case worm = "Worm"
        }
    }

    public struct BandwidthRateLimitInterval: AWSEncodableShape & AWSDecodableShape {
        ///  The average download rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the download rate limit is not set.   S3 File Gateway does not support this feature.
        public let averageDownloadRateLimitInBitsPerSec: Int64?
        ///  The average upload rate limit component of the bandwidth rate limit interval, in bits per second. This field does not appear in the response if the upload rate limit is not set.   For Tape Gateway and Volume Gateway, the minimum value is 51200. This field is required for S3 File Gateway, and the minimum value is 104857600.
        public let averageUploadRateLimitInBitsPerSec: Int64?
        ///  The days of the week component of the bandwidth rate limit interval, represented as ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        public let daysOfWeek: [Int]
        ///  The hour of the day to end the bandwidth rate limit interval.
        public let endHourOfDay: Int
        ///  The minute of the hour to end the bandwidth rate limit interval.   The bandwidth rate limit interval ends at the end of the minute. To end an interval at the end of an hour, use the value 59.
        public let endMinuteOfHour: Int
        ///  The hour of the day to start the bandwidth rate limit interval.
        public let startHourOfDay: Int
        ///  The minute of the hour to start the bandwidth rate limit interval. The interval begins at the start of that minute. To begin an interval exactly at the start of the hour, use the value 0.
        public let startMinuteOfHour: Int

        @inlinable
        public init(averageDownloadRateLimitInBitsPerSec: Int64? = nil, averageUploadRateLimitInBitsPerSec: Int64? = nil, daysOfWeek: [Int], endHourOfDay: Int, endMinuteOfHour: Int, startHourOfDay: Int, startMinuteOfHour: Int) {
            self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.daysOfWeek = daysOfWeek
            self.endHourOfDay = endHourOfDay
            self.endMinuteOfHour = endMinuteOfHour
            self.startHourOfDay = startHourOfDay
            self.startMinuteOfHour = startMinuteOfHour
        }

        public func validate(name: String) throws {
            try self.validate(self.averageDownloadRateLimitInBitsPerSec, name: "averageDownloadRateLimitInBitsPerSec", parent: name, min: 102400)
            try self.validate(self.averageUploadRateLimitInBitsPerSec, name: "averageUploadRateLimitInBitsPerSec", parent: name, min: 51200)
            try self.daysOfWeek.forEach {
                try validate($0, name: "daysOfWeek[]", parent: name, max: 6)
                try validate($0, name: "daysOfWeek[]", parent: name, min: 0)
            }
            try self.validate(self.daysOfWeek, name: "daysOfWeek", parent: name, max: 7)
            try self.validate(self.daysOfWeek, name: "daysOfWeek", parent: name, min: 1)
            try self.validate(self.endHourOfDay, name: "endHourOfDay", parent: name, max: 23)
            try self.validate(self.endHourOfDay, name: "endHourOfDay", parent: name, min: 0)
            try self.validate(self.endMinuteOfHour, name: "endMinuteOfHour", parent: name, max: 59)
            try self.validate(self.endMinuteOfHour, name: "endMinuteOfHour", parent: name, min: 0)
            try self.validate(self.startHourOfDay, name: "startHourOfDay", parent: name, max: 23)
            try self.validate(self.startHourOfDay, name: "startHourOfDay", parent: name, min: 0)
            try self.validate(self.startMinuteOfHour, name: "startMinuteOfHour", parent: name, max: 59)
            try self.validate(self.startMinuteOfHour, name: "startMinuteOfHour", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
            case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
            case daysOfWeek = "DaysOfWeek"
            case endHourOfDay = "EndHourOfDay"
            case endMinuteOfHour = "EndMinuteOfHour"
            case startHourOfDay = "StartHourOfDay"
            case startMinuteOfHour = "StartMinuteOfHour"
        }
    }

    public struct CacheAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Refreshes a file share's cache by using Time To Live (TTL). TTL is the length of time since the last refresh after which access to the directory would cause the file gateway to first refresh that directory's contents from the Amazon S3 bucket or Amazon FSx file system. The TTL duration is in seconds. Valid Values:0, 300 to 2,592,000 seconds (5 minutes to 30 days)
        public let cacheStaleTimeoutInSeconds: Int?

        @inlinable
        public init(cacheStaleTimeoutInSeconds: Int? = nil) {
            self.cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case cacheStaleTimeoutInSeconds = "CacheStaleTimeoutInSeconds"
        }
    }

    public struct CacheReportFilter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter name for a filter that determines which files are included or excluded from a cache report.  Valid Names:  UploadFailureReason | UploadState
        public let name: CacheReportFilterName
        /// The parameter value for a filter that determines which files are included or excluded from a cache report.  Valid UploadFailureReason Values:   InaccessibleStorageClass | InvalidObjectState | ObjectMissing | S3AccessDenied   Valid UploadState Values:   FailingUpload
        public let values: [String]

        @inlinable
        public init(name: CacheReportFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 25)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct CacheReportInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cache report you want to describe.
        public let cacheReportARN: String?
        /// The status of the specified cache report.
        public let cacheReportStatus: CacheReportStatus?
        /// The time at which the gateway stopped generating the cache report.
        public let endTime: Date?
        /// The list of filters and parameters that determine which files are excluded from the report.
        public let exclusionFilters: [CacheReportFilter]?
        public let fileShareARN: String?
        /// The list of filters and parameters that determine which files are included in the report.
        public let inclusionFilters: [CacheReportFilter]?
        /// The ARN of the Amazon S3 bucket location where the cache report is saved.
        public let locationARN: String?
        /// The percentage of the report generation process that has been completed at time of inquiry.
        public let reportCompletionPercent: Int?
        /// The file name of the completed cache report object stored in Amazon S3.
        public let reportName: String?
        public let role: String?
        /// The time at which the gateway started generating the cache report.
        public let startTime: Date?
        /// The list of key/value tags associated with the report.
        public let tags: [Tag]?

        @inlinable
        public init(cacheReportARN: String? = nil, cacheReportStatus: CacheReportStatus? = nil, endTime: Date? = nil, exclusionFilters: [CacheReportFilter]? = nil, fileShareARN: String? = nil, inclusionFilters: [CacheReportFilter]? = nil, locationARN: String? = nil, reportCompletionPercent: Int? = nil, reportName: String? = nil, role: String? = nil, startTime: Date? = nil, tags: [Tag]? = nil) {
            self.cacheReportARN = cacheReportARN
            self.cacheReportStatus = cacheReportStatus
            self.endTime = endTime
            self.exclusionFilters = exclusionFilters
            self.fileShareARN = fileShareARN
            self.inclusionFilters = inclusionFilters
            self.locationARN = locationARN
            self.reportCompletionPercent = reportCompletionPercent
            self.reportName = reportName
            self.role = role
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
            case cacheReportStatus = "CacheReportStatus"
            case endTime = "EndTime"
            case exclusionFilters = "ExclusionFilters"
            case fileShareARN = "FileShareARN"
            case inclusionFilters = "InclusionFilters"
            case locationARN = "LocationARN"
            case reportCompletionPercent = "ReportCompletionPercent"
            case reportName = "ReportName"
            case role = "Role"
            case startTime = "StartTime"
            case tags = "Tags"
        }
    }

    public struct CachediSCSIVolume: AWSDecodableShape {
        /// The date the volume was created. Volumes created prior to March 28, 2017 donâ€™t have this timestamp.
        public let createdDate: Date?
        public let kmsKey: String?
        /// If the cached volume was created from a snapshot, this field contains the snapshot ID used, e.g., snap-78e22663. Otherwise, this field is not included.
        public let sourceSnapshotId: String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public let targetName: String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public let volumeARN: String?
        /// A value that indicates whether a storage volume is attached to or detached from a gateway. For more information, see Moving your volumes to a different gateway.
        public let volumeAttachmentStatus: String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public let volumeId: String?
        /// An VolumeiSCSIAttributes object that represents a collection of iSCSI attributes for one stored volume.
        public let volumeiSCSIAttributes: VolumeiSCSIAttributes?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the cached volume is not restoring or bootstrapping.
        public let volumeProgress: Double?
        /// The size, in bytes, of the volume capacity.
        public let volumeSizeInBytes: Int64?
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public let volumeStatus: String?
        /// One of the VolumeType enumeration values that describes the type of the volume.
        public let volumeType: String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on the number of blocks that are touched, instead of the actual amount of data written. This value can be useful for sequential write patterns but less accurate for random write patterns. VolumeUsedInBytes is different from the compressed size of the volume, which is the value that is used to calculate your bill.  This value is not available for volumes created prior to May 13, 2015, until you store data on the volume. If you use a delete tool that overwrites the data on your volume with random data, your usage will not be reduced. This is because the random data is not compressible. If you want to reduce the amount of billed storage on your volume, we recommend overwriting your files with zeros to compress the data to a negligible amount of actual storage.
        public let volumeUsedInBytes: Int64?

        @inlinable
        public init(createdDate: Date? = nil, kmsKey: String? = nil, sourceSnapshotId: String? = nil, targetName: String? = nil, volumeARN: String? = nil, volumeAttachmentStatus: String? = nil, volumeId: String? = nil, volumeiSCSIAttributes: VolumeiSCSIAttributes? = nil, volumeProgress: Double? = nil, volumeSizeInBytes: Int64? = nil, volumeStatus: String? = nil, volumeType: String? = nil, volumeUsedInBytes: Int64? = nil) {
            self.createdDate = createdDate
            self.kmsKey = kmsKey
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case kmsKey = "KMSKey"
            case sourceSnapshotId = "SourceSnapshotId"
            case targetName = "TargetName"
            case volumeARN = "VolumeARN"
            case volumeAttachmentStatus = "VolumeAttachmentStatus"
            case volumeId = "VolumeId"
            case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
            case volumeProgress = "VolumeProgress"
            case volumeSizeInBytes = "VolumeSizeInBytes"
            case volumeStatus = "VolumeStatus"
            case volumeType = "VolumeType"
            case volumeUsedInBytes = "VolumeUsedInBytes"
        }
    }

    public struct CancelArchivalInput: AWSEncodableShape {
        public let gatewayARN: String
        /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel archiving for.
        public let tapeARN: String

        @inlinable
        public init(gatewayARN: String, tapeARN: String) {
            self.gatewayARN = gatewayARN
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case tapeARN = "TapeARN"
        }
    }

    public struct CancelArchivalOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the virtual tape for which archiving was canceled.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct CancelCacheReportInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cache report you want to cancel.
        public let cacheReportARN: String

        @inlinable
        public init(cacheReportARN: String) {
            self.cacheReportARN = cacheReportARN
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheReportARN, name: "cacheReportARN", parent: name, max: 500)
            try self.validate(self.cacheReportARN, name: "cacheReportARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
        }
    }

    public struct CancelCacheReportOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cache report you want to cancel.
        public let cacheReportARN: String?

        @inlinable
        public init(cacheReportARN: String? = nil) {
            self.cacheReportARN = cacheReportARN
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
        }
    }

    public struct CancelRetrievalInput: AWSEncodableShape {
        public let gatewayARN: String
        /// The Amazon Resource Name (ARN) of the virtual tape you want to cancel retrieval for.
        public let tapeARN: String

        @inlinable
        public init(gatewayARN: String, tapeARN: String) {
            self.gatewayARN = gatewayARN
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case tapeARN = "TapeARN"
        }
    }

    public struct CancelRetrievalOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the virtual tape for which retrieval was canceled.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct ChapInfo: AWSDecodableShape {
        /// The iSCSI initiator that connects to the target.
        public let initiatorName: String?
        /// The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.
        public let secretToAuthenticateInitiator: String?
        /// The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g., Windows client).
        public let secretToAuthenticateTarget: String?
        /// The Amazon Resource Name (ARN) of the volume. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public let targetARN: String?

        @inlinable
        public init(initiatorName: String? = nil, secretToAuthenticateInitiator: String? = nil, secretToAuthenticateTarget: String? = nil, targetARN: String? = nil) {
            self.initiatorName = initiatorName
            self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
            self.secretToAuthenticateTarget = secretToAuthenticateTarget
            self.targetARN = targetARN
        }

        private enum CodingKeys: String, CodingKey {
            case initiatorName = "InitiatorName"
            case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
            case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
            case targetARN = "TargetARN"
        }
    }

    public struct CreateCachediSCSIVolumeInput: AWSEncodableShape {
        /// A unique identifier that you use to retry a request. If you retry a request, use the same ClientToken you specified in the initial request.
        public let clientToken: String
        public let gatewayARN: String
        /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public let kmsKey: String?
        /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use DescribeGatewayInformation to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
        public let networkInterfaceId: String
        /// The snapshot ID (e.g. "snap-1122aabb") of the snapshot to restore as the new cached volume. Specify this field if you want to create the iSCSI storage volume from a snapshot; otherwise, do not include this field. To list snapshots for your account use DescribeSnapshots in the Amazon Elastic Compute Cloud API Reference.
        public let snapshotId: String?
        /// The ARN for an existing volume. Specifying this ARN makes the new volume into an exact copy of the specified existing volume's latest recovery point. The VolumeSizeInBytes value for this new volume must be equal to or larger than the size of the existing volume, in bytes.
        public let sourceVolumeARN: String?
        /// A list of up to 50 tags that you can assign to a cached volume. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers that you can represent in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256 characters.
        public let tags: [Tag]?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public let targetName: String
        /// The size of the volume in bytes.
        public let volumeSizeInBytes: Int64

        @inlinable
        public init(clientToken: String, gatewayARN: String, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, networkInterfaceId: String, snapshotId: String? = nil, sourceVolumeARN: String? = nil, tags: [Tag]? = nil, targetName: String, volumeSizeInBytes: Int64 = 0) {
            self.clientToken = clientToken
            self.gatewayARN = gatewayARN
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.networkInterfaceId = networkInterfaceId
            self.snapshotId = snapshotId
            self.sourceVolumeARN = sourceVolumeARN
            self.tags = tags
            self.targetName = targetName
            self.volumeSizeInBytes = volumeSizeInBytes
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 5)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "^\\A(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\z$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^\\Asnap-([0-9A-Fa-f]{8}|[0-9A-Fa-f]{17})\\z$")
            try self.validate(self.sourceVolumeARN, name: "sourceVolumeARN", parent: name, max: 500)
            try self.validate(self.sourceVolumeARN, name: "sourceVolumeARN", parent: name, min: 50)
            try self.validate(self.sourceVolumeARN, name: "sourceVolumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.targetName, name: "targetName", parent: name, max: 200)
            try self.validate(self.targetName, name: "targetName", parent: name, min: 1)
            try self.validate(self.targetName, name: "targetName", parent: name, pattern: "^[-\\.;a-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case gatewayARN = "GatewayARN"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case networkInterfaceId = "NetworkInterfaceId"
            case snapshotId = "SnapshotId"
            case sourceVolumeARN = "SourceVolumeARN"
            case tags = "Tags"
            case targetName = "TargetName"
            case volumeSizeInBytes = "VolumeSizeInBytes"
        }
    }

    public struct CreateCachediSCSIVolumeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that initiators can use to connect to the target.
        public let targetARN: String?
        /// The Amazon Resource Name (ARN) of the configured volume.
        public let volumeARN: String?

        @inlinable
        public init(targetARN: String? = nil, volumeARN: String? = nil) {
            self.targetARN = targetARN
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case targetARN = "TargetARN"
            case volumeARN = "VolumeARN"
        }
    }

    public struct CreateNFSFileShareInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public let auditDestinationARN: String?
        /// Specifies the Region of the S3 bucket where the NFS file share stores files.  This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let bucketRegion: String?
        /// Specifies refresh cache information for the file share.
        public let cacheAttributes: CacheAttributes?
        /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
        public let clientList: [String]?
        /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent file share creation.
        public let clientToken: String
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public let defaultStorageClass: String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public let encryptionType: EncryptionType?
        /// The name of the file share. Optional.   FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used. A valid NFS file share name can only contain the following characters: a-z, A-Z, 0-9, -, ., and _.
        public let fileShareName: String?
        /// The Amazon Resource Name (ARN) of the S3 File Gateway on which you want to create a file share.
        public let gatewayARN: String
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public let guessMIMETypeEnabled: Bool?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.  Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public let kmsKey: String?
        /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/).  You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN:  arn:aws:s3:::amzn-s3-demo-bucket/prefix/  Access point ARN:  arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/  If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see Delegating access control to access points in the Amazon S3 User Guide. Access point alias:  test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
        public let locationARN: String
        /// File share default values. Optional.
        public let nfsFileShareDefaults: NFSFileShareDefaults?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period.   SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications.  The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60.  {\"Upload\": {\"SettlingTimeInSeconds\": 60}}  The following example sets NotificationPolicy off.  {}
        public let notificationPolicy: String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
        public let objectACL: ObjectACL?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public let readOnly: Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data.   RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration.  Valid Values: true | false
        public let requesterPays: Bool?
        /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes when it accesses the underlying storage.
        public let role: String
        /// A value that maps a user to anonymous user. Valid values are the following:    RootSquash: Only root is mapped to anonymous user.    NoSquash: No one is mapped to anonymous user.    AllSquash: Everyone is mapped to anonymous user.
        public let squash: String?
        /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3.  This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let vpcEndpointDNSName: String?

        @inlinable
        public init(auditDestinationARN: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, clientList: [String]? = nil, clientToken: String, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareName: String? = nil, gatewayARN: String, guessMIMETypeEnabled: Bool? = nil, kmsKey: String? = nil, locationARN: String, nfsFileShareDefaults: NFSFileShareDefaults? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String, squash: String? = nil, tags: [Tag]? = nil, vpcEndpointDNSName: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.clientToken = clientToken
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareName = fileShareName
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = nil
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        @available(*, deprecated, message: "Members kmsEncrypted have been deprecated")
        @inlinable
        public init(auditDestinationARN: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, clientList: [String]? = nil, clientToken: String, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareName: String? = nil, gatewayARN: String, guessMIMETypeEnabled: Bool? = nil, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, locationARN: String, nfsFileShareDefaults: NFSFileShareDefaults? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String, squash: String? = nil, tags: [Tag]? = nil, vpcEndpointDNSName: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.clientToken = clientToken
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareName = fileShareName
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        public func validate(name: String) throws {
            try self.validate(self.auditDestinationARN, name: "auditDestinationARN", parent: name, max: 1024)
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, max: 25)
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, min: 1)
            try self.clientList?.forEach {
                try validate($0, name: "clientList[]", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))?$")
            }
            try self.validate(self.clientList, name: "clientList", parent: name, max: 100)
            try self.validate(self.clientList, name: "clientList", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 5)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, max: 50)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, min: 5)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, max: 255)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, min: 1)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.locationARN, name: "locationARN", parent: name, max: 1400)
            try self.validate(self.locationARN, name: "locationARN", parent: name, min: 16)
            try self.nfsFileShareDefaults?.validate(name: "\(name).nfsFileShareDefaults")
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, max: 100)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, min: 2)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, pattern: "^\\{[\\w\\s:\\{\\}\\[\\]\"]*}$")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):iam::([0-9]+):role/(\\S+)$")
            try self.validate(self.squash, name: "squash", parent: name, max: 15)
            try self.validate(self.squash, name: "squash", parent: name, min: 5)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, max: 255)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, min: 1)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, pattern: "^(([a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9\\-]*[A-Za-z0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case auditDestinationARN = "AuditDestinationARN"
            case bucketRegion = "BucketRegion"
            case cacheAttributes = "CacheAttributes"
            case clientList = "ClientList"
            case clientToken = "ClientToken"
            case defaultStorageClass = "DefaultStorageClass"
            case encryptionType = "EncryptionType"
            case fileShareName = "FileShareName"
            case gatewayARN = "GatewayARN"
            case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case locationARN = "LocationARN"
            case nfsFileShareDefaults = "NFSFileShareDefaults"
            case notificationPolicy = "NotificationPolicy"
            case objectACL = "ObjectACL"
            case readOnly = "ReadOnly"
            case requesterPays = "RequesterPays"
            case role = "Role"
            case squash = "Squash"
            case tags = "Tags"
            case vpcEndpointDNSName = "VPCEndpointDNSName"
        }
    }

    public struct CreateNFSFileShareOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created file share.
        public let fileShareARN: String?

        @inlinable
        public init(fileShareARN: String? = nil) {
            self.fileShareARN = fileShareARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
        }
    }

    public struct CreateSMBFileShareInput: AWSEncodableShape {
        /// The files and folders on this share will only be visible to users with read access.
        public let accessBasedEnumeration: Bool?
        /// A list of users or groups in the Active Directory that will be granted administrator privileges on the file share. These users can do all file operations as the super-user. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1.  Use this option very carefully, because any user in this list can do anything they like on the file share, regardless of file permissions.
        public let adminUserList: [String]?
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public let auditDestinationARN: String?
        /// The authentication method that users use to access the file share. The default is ActiveDirectory. Valid Values: ActiveDirectory | GuestAccess
        public let authentication: String?
        /// Specifies the Region of the S3 bucket where the SMB file share stores files.  This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let bucketRegion: String?
        /// Specifies refresh cache information for the file share.
        public let cacheAttributes: CacheAttributes?
        /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
        public let caseSensitivity: CaseSensitivity?
        /// A unique string value that you supply that is used by S3 File Gateway to ensure idempotent file share creation.
        public let clientToken: String
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public let defaultStorageClass: String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public let encryptionType: EncryptionType?
        /// The name of the file share. Optional.   FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used. A valid SMB file share name cannot contain the following characters: [,],#,;,,>,:,",\,/,|,?,*,+, or ASCII control characters 1-31.
        public let fileShareName: String?
        /// The ARN of the S3 File Gateway on which you want to create a file share.
        public let gatewayARN: String
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public let guessMIMETypeEnabled: Bool?
        /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let invalidUserList: [String]?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.  Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public let kmsKey: String?
        /// A custom ARN for the backend storage used for storing data for file shares. It includes a resource ARN with an optional prefix concatenation. The prefix must end with a forward slash (/).  You can specify LocationARN as a bucket ARN, access point ARN or access point alias, as shown in the following examples. Bucket ARN:  arn:aws:s3:::amzn-s3-demo-bucket/prefix/  Access point ARN:  arn:aws:s3:region:account-id:accesspoint/access-point-name/prefix/  If you specify an access point, the bucket policy must be configured to delegate access control to the access point. For information, see Delegating access control to access points in the Amazon S3 User Guide. Access point alias:  test-ap-ab123cdef4gehijklmn5opqrstuvuse1a-s3alias
        public let locationARN: String
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period.   SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications.  The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60.  {\"Upload\": {\"SettlingTimeInSeconds\": 60}}  The following example sets NotificationPolicy off.  {}
        public let notificationPolicy: String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
        public let objectACL: ObjectACL?
        /// Specifies whether opportunistic locking is enabled for the SMB file share.  Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case.  Valid Values: true | false
        public let oplocksEnabled: Bool?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public let readOnly: Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data.   RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration.  Valid Values: true | false
        public let requesterPays: Bool?
        /// The ARN of the Identity and Access Management (IAM) role that an S3 File Gateway assumes when it accesses the underlying storage.
        public let role: String
        /// Set this value to true to enable access control list (ACL) on the SMB file share. Set it to false to map file and directory permissions to the POSIX permissions. For more information, see Using Windows ACLs to limit SMB file share access in the Amazon S3 File Gateway User Guide. Valid Values: true | false
        public let smbaclEnabled: Bool?
        /// A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let validUserList: [String]?
        /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3.  This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let vpcEndpointDNSName: String?

        @inlinable
        public init(accessBasedEnumeration: Bool? = nil, adminUserList: [String]? = nil, auditDestinationARN: String? = nil, authentication: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, caseSensitivity: CaseSensitivity? = nil, clientToken: String, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareName: String? = nil, gatewayARN: String, guessMIMETypeEnabled: Bool? = nil, invalidUserList: [String]? = nil, kmsKey: String? = nil, locationARN: String, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, oplocksEnabled: Bool? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String, smbaclEnabled: Bool? = nil, tags: [Tag]? = nil, validUserList: [String]? = nil, vpcEndpointDNSName: String? = nil) {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.clientToken = clientToken
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareName = fileShareName
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = nil
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.smbaclEnabled = smbaclEnabled
            self.tags = tags
            self.validUserList = validUserList
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        @available(*, deprecated, message: "Members kmsEncrypted have been deprecated")
        @inlinable
        public init(accessBasedEnumeration: Bool? = nil, adminUserList: [String]? = nil, auditDestinationARN: String? = nil, authentication: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, caseSensitivity: CaseSensitivity? = nil, clientToken: String, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareName: String? = nil, gatewayARN: String, guessMIMETypeEnabled: Bool? = nil, invalidUserList: [String]? = nil, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, locationARN: String, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, oplocksEnabled: Bool? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String, smbaclEnabled: Bool? = nil, tags: [Tag]? = nil, validUserList: [String]? = nil, vpcEndpointDNSName: String? = nil) {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.clientToken = clientToken
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareName = fileShareName
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.smbaclEnabled = smbaclEnabled
            self.tags = tags
            self.validUserList = validUserList
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        public func validate(name: String) throws {
            try self.adminUserList?.forEach {
                try validate($0, name: "adminUserList[]", parent: name, max: 64)
                try validate($0, name: "adminUserList[]", parent: name, min: 1)
            }
            try self.validate(self.adminUserList, name: "adminUserList", parent: name, max: 100)
            try self.validate(self.auditDestinationARN, name: "auditDestinationARN", parent: name, max: 1024)
            try self.validate(self.authentication, name: "authentication", parent: name, max: 15)
            try self.validate(self.authentication, name: "authentication", parent: name, min: 5)
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, max: 25)
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 5)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, max: 50)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, min: 5)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, max: 255)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, min: 1)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.invalidUserList?.forEach {
                try validate($0, name: "invalidUserList[]", parent: name, max: 64)
                try validate($0, name: "invalidUserList[]", parent: name, min: 1)
            }
            try self.validate(self.invalidUserList, name: "invalidUserList", parent: name, max: 100)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.locationARN, name: "locationARN", parent: name, max: 1400)
            try self.validate(self.locationARN, name: "locationARN", parent: name, min: 16)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, max: 100)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, min: 2)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, pattern: "^\\{[\\w\\s:\\{\\}\\[\\]\"]*}$")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):iam::([0-9]+):role/(\\S+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validUserList?.forEach {
                try validate($0, name: "validUserList[]", parent: name, max: 64)
                try validate($0, name: "validUserList[]", parent: name, min: 1)
            }
            try self.validate(self.validUserList, name: "validUserList", parent: name, max: 100)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, max: 255)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, min: 1)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, pattern: "^(([a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9\\-]*[A-Za-z0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessBasedEnumeration = "AccessBasedEnumeration"
            case adminUserList = "AdminUserList"
            case auditDestinationARN = "AuditDestinationARN"
            case authentication = "Authentication"
            case bucketRegion = "BucketRegion"
            case cacheAttributes = "CacheAttributes"
            case caseSensitivity = "CaseSensitivity"
            case clientToken = "ClientToken"
            case defaultStorageClass = "DefaultStorageClass"
            case encryptionType = "EncryptionType"
            case fileShareName = "FileShareName"
            case gatewayARN = "GatewayARN"
            case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
            case invalidUserList = "InvalidUserList"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case locationARN = "LocationARN"
            case notificationPolicy = "NotificationPolicy"
            case objectACL = "ObjectACL"
            case oplocksEnabled = "OplocksEnabled"
            case readOnly = "ReadOnly"
            case requesterPays = "RequesterPays"
            case role = "Role"
            case smbaclEnabled = "SMBACLEnabled"
            case tags = "Tags"
            case validUserList = "ValidUserList"
            case vpcEndpointDNSName = "VPCEndpointDNSName"
        }
    }

    public struct CreateSMBFileShareOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created file share.
        public let fileShareARN: String?

        @inlinable
        public init(fileShareARN: String? = nil) {
            self.fileShareARN = fileShareARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
        }
    }

    public struct CreateSnapshotFromVolumeRecoveryPointInput: AWSEncodableShape {
        /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic Block Store snapshots panel in the Description field, and in the Storage Gateway snapshot Details pane, Description field.
        public let snapshotDescription: String
        /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for specified VolumeARN.
        public let volumeARN: String

        @inlinable
        public init(snapshotDescription: String, tags: [Tag]? = nil, volumeARN: String) {
            self.snapshotDescription = snapshotDescription
            self.tags = tags
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotDescription, name: "snapshotDescription", parent: name, max: 255)
            try self.validate(self.snapshotDescription, name: "snapshotDescription", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotDescription = "SnapshotDescription"
            case tags = "Tags"
            case volumeARN = "VolumeARN"
        }
    }

    public struct CreateSnapshotFromVolumeRecoveryPointOutput: AWSDecodableShape {
        /// The ID of the snapshot.
        public let snapshotId: String?
        /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for specified VolumeARN.
        public let volumeARN: String?
        /// The time the volume was created from the recovery point.
        public let volumeRecoveryPointTime: String?

        @inlinable
        public init(snapshotId: String? = nil, volumeARN: String? = nil, volumeRecoveryPointTime: String? = nil) {
            self.snapshotId = snapshotId
            self.volumeARN = volumeARN
            self.volumeRecoveryPointTime = volumeRecoveryPointTime
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotId = "SnapshotId"
            case volumeARN = "VolumeARN"
            case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
        }
    }

    public struct CreateSnapshotInput: AWSEncodableShape {
        /// Textual description of the snapshot that appears in the Amazon EC2 console, Elastic Block Store snapshots panel in the Description field, and in the Storage Gateway snapshot Details pane, Description field.
        public let snapshotDescription: String
        /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes operation to return a list of gateway volumes.
        public let volumeARN: String

        @inlinable
        public init(snapshotDescription: String, tags: [Tag]? = nil, volumeARN: String) {
            self.snapshotDescription = snapshotDescription
            self.tags = tags
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotDescription, name: "snapshotDescription", parent: name, max: 255)
            try self.validate(self.snapshotDescription, name: "snapshotDescription", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotDescription = "SnapshotDescription"
            case tags = "Tags"
            case volumeARN = "VolumeARN"
        }
    }

    public struct CreateSnapshotOutput: AWSDecodableShape {
        /// The snapshot ID that is used to refer to the snapshot in future operations such as describing snapshots (Amazon Elastic Compute Cloud API DescribeSnapshots) or creating a volume from a snapshot (CreateStorediSCSIVolume).
        public let snapshotId: String?
        /// The Amazon Resource Name (ARN) of the volume of which the snapshot was taken.
        public let volumeARN: String?

        @inlinable
        public init(snapshotId: String? = nil, volumeARN: String? = nil) {
            self.snapshotId = snapshotId
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotId = "SnapshotId"
            case volumeARN = "VolumeARN"
        }
    }

    public struct CreateStorediSCSIVolumeInput: AWSEncodableShape {
        /// The unique identifier for the gateway local disk that is configured as a stored volume. Use ListLocalDisks to list disk IDs for a gateway.
        public let diskId: String
        public let gatewayARN: String
        /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public let kmsKey: String?
        /// The network interface of the gateway on which to expose the iSCSI target. Only IPv4 addresses are accepted. Use DescribeGatewayInformation to get a list of the network interfaces available on a gateway. Valid Values: A valid IP address.
        public let networkInterfaceId: String
        /// Set to true if you want to preserve the data on the local disk. Otherwise, set to false to create an empty volume. Valid Values: true | false
        public let preserveExistingData: Bool
        /// The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as the new stored volume. Specify this field if you want to create the iSCSI storage volume from a snapshot; otherwise, do not include this field. To list snapshots for your account use DescribeSnapshots in the Amazon Elastic Compute Cloud API Reference.
        public let snapshotId: String?
        /// A list of up to 50 tags that can be assigned to a stored volume. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public let targetName: String

        @inlinable
        public init(diskId: String, gatewayARN: String, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, networkInterfaceId: String, preserveExistingData: Bool = false, snapshotId: String? = nil, tags: [Tag]? = nil, targetName: String) {
            self.diskId = diskId
            self.gatewayARN = gatewayARN
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.networkInterfaceId = networkInterfaceId
            self.preserveExistingData = preserveExistingData
            self.snapshotId = snapshotId
            self.tags = tags
            self.targetName = targetName
        }

        public func validate(name: String) throws {
            try self.validate(self.diskId, name: "diskId", parent: name, max: 300)
            try self.validate(self.diskId, name: "diskId", parent: name, min: 1)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "^\\A(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\z$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^\\Asnap-([0-9A-Fa-f]{8}|[0-9A-Fa-f]{17})\\z$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.targetName, name: "targetName", parent: name, max: 200)
            try self.validate(self.targetName, name: "targetName", parent: name, min: 1)
            try self.validate(self.targetName, name: "targetName", parent: name, pattern: "^[-\\.;a-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case diskId = "DiskId"
            case gatewayARN = "GatewayARN"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case networkInterfaceId = "NetworkInterfaceId"
            case preserveExistingData = "PreserveExistingData"
            case snapshotId = "SnapshotId"
            case tags = "Tags"
            case targetName = "TargetName"
        }
    }

    public struct CreateStorediSCSIVolumeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that initiators can use to connect to the target.
        public let targetARN: String?
        /// The Amazon Resource Name (ARN) of the configured volume.
        public let volumeARN: String?
        /// The size of the volume in bytes.
        public let volumeSizeInBytes: Int64?

        @inlinable
        public init(targetARN: String? = nil, volumeARN: String? = nil, volumeSizeInBytes: Int64? = nil) {
            self.targetARN = targetARN
            self.volumeARN = volumeARN
            self.volumeSizeInBytes = volumeSizeInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case targetARN = "TargetARN"
            case volumeARN = "VolumeARN"
            case volumeSizeInBytes = "VolumeSizeInBytes"
        }
    }

    public struct CreateTapePoolInput: AWSEncodableShape {
        /// The name of the new custom tape pool.
        public let poolName: String
        /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to 100 years (36,500 days).
        public let retentionLockTimeInDays: Int?
        /// Tape retention lock can be configured in two modes. When configured in governance mode, Amazon Web Services accounts with specific IAM permissions are authorized to remove the tape retention lock from archived virtual tapes. When configured in compliance mode, the tape retention lock cannot be removed by any user, including the root Amazon Web Services account.
        public let retentionLockType: RetentionLockType?
        /// The storage class that is associated with the new custom pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let storageClass: TapeStorageClass
        /// A list of up to 50 tags that can be assigned to tape pool. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?

        @inlinable
        public init(poolName: String, retentionLockTimeInDays: Int? = nil, retentionLockType: RetentionLockType? = nil, storageClass: TapeStorageClass, tags: [Tag]? = nil) {
            self.poolName = poolName
            self.retentionLockTimeInDays = retentionLockTimeInDays
            self.retentionLockType = retentionLockType
            self.storageClass = storageClass
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.poolName, name: "poolName", parent: name, max: 100)
            try self.validate(self.poolName, name: "poolName", parent: name, min: 1)
            try self.validate(self.poolName, name: "poolName", parent: name, pattern: "^[ -\\.0-\\[\\]-~]*[!-\\.0-\\[\\]-~][ -\\.0-\\[\\]-~]*$")
            try self.validate(self.retentionLockTimeInDays, name: "retentionLockTimeInDays", parent: name, max: 36500)
            try self.validate(self.retentionLockTimeInDays, name: "retentionLockTimeInDays", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case poolName = "PoolName"
            case retentionLockTimeInDays = "RetentionLockTimeInDays"
            case retentionLockType = "RetentionLockType"
            case storageClass = "StorageClass"
            case tags = "Tags"
        }
    }

    public struct CreateTapePoolOutput: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) that represents the custom tape pool. Use the ListTapePools operation to return a list of tape pools for your account and Amazon Web Services Region.
        public let poolARN: String?

        @inlinable
        public init(poolARN: String? = nil) {
            self.poolARN = poolARN
        }

        private enum CodingKeys: String, CodingKey {
            case poolARN = "PoolARN"
        }
    }

    public struct CreateTapeWithBarcodeInput: AWSEncodableShape {
        /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tape with. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public let gatewayARN: String
        /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public let kmsKey: String?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Deep Archive) that corresponds to the pool.
        public let poolId: String?
        /// A list of up to 50 tags that can be assigned to a virtual tape that has a barcode. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// The barcode that you want to assign to the tape.  Barcodes cannot be reused. This includes barcodes used for tapes that have been deleted.
        public let tapeBarcode: String
        /// The size, in bytes, of the virtual tape that you want to create.  The size must be aligned by gigabyte (1024*1024*1024 bytes).
        public let tapeSizeInBytes: Int64
        /// Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM) tape.
        public let worm: Bool?

        @inlinable
        public init(gatewayARN: String, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, poolId: String? = nil, tags: [Tag]? = nil, tapeBarcode: String, tapeSizeInBytes: Int64, worm: Bool? = nil) {
            self.gatewayARN = gatewayARN
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.poolId = poolId
            self.tags = tags
            self.tapeBarcode = tapeBarcode
            self.tapeSizeInBytes = tapeSizeInBytes
            self.worm = worm
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 100)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tapeBarcode, name: "tapeBarcode", parent: name, max: 16)
            try self.validate(self.tapeBarcode, name: "tapeBarcode", parent: name, min: 5)
            try self.validate(self.tapeBarcode, name: "tapeBarcode", parent: name, pattern: "^[A-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case poolId = "PoolId"
            case tags = "Tags"
            case tapeBarcode = "TapeBarcode"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case worm = "Worm"
        }
    }

    public struct CreateTapeWithBarcodeOutput: AWSDecodableShape {
        /// A unique Amazon Resource Name (ARN) that represents the virtual tape that was created.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct CreateTapesInput: AWSEncodableShape {
        /// A unique identifier that you use to retry a request. If you retry a request, use the same ClientToken you specified in the initial request.  Using the same ClientToken prevents creating the tape multiple times.
        public let clientToken: String
        /// The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tapes with. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public let gatewayARN: String
        /// Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key managed by Amazon S3. Optional. Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be set when KMSEncrypted is true. Optional.
        public let kmsKey: String?
        /// The number of virtual tapes that you want to create.
        public let numTapesToCreate: Int
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let poolId: String?
        /// A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// A prefix that you append to the barcode of the virtual tape you are creating. This prefix makes the barcode unique.  The prefix must be 1-4 characters in length and must be one of the uppercase letters from A to Z.
        public let tapeBarcodePrefix: String
        /// The size, in bytes, of the virtual tapes that you want to create.  The size must be aligned by gigabyte (1024*1024*1024 bytes).
        public let tapeSizeInBytes: Int64
        /// Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM) tape.
        public let worm: Bool?

        @inlinable
        public init(clientToken: String, gatewayARN: String, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, numTapesToCreate: Int, poolId: String? = nil, tags: [Tag]? = nil, tapeBarcodePrefix: String, tapeSizeInBytes: Int64, worm: Bool? = nil) {
            self.clientToken = clientToken
            self.gatewayARN = gatewayARN
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.numTapesToCreate = numTapesToCreate
            self.poolId = poolId
            self.tags = tags
            self.tapeBarcodePrefix = tapeBarcodePrefix
            self.tapeSizeInBytes = tapeSizeInBytes
            self.worm = worm
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 5)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.numTapesToCreate, name: "numTapesToCreate", parent: name, max: 10)
            try self.validate(self.numTapesToCreate, name: "numTapesToCreate", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, max: 100)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tapeBarcodePrefix, name: "tapeBarcodePrefix", parent: name, max: 4)
            try self.validate(self.tapeBarcodePrefix, name: "tapeBarcodePrefix", parent: name, min: 1)
            try self.validate(self.tapeBarcodePrefix, name: "tapeBarcodePrefix", parent: name, pattern: "^[A-Z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case gatewayARN = "GatewayARN"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case numTapesToCreate = "NumTapesToCreate"
            case poolId = "PoolId"
            case tags = "Tags"
            case tapeBarcodePrefix = "TapeBarcodePrefix"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case worm = "Worm"
        }
    }

    public struct CreateTapesOutput: AWSDecodableShape {
        /// A list of unique Amazon Resource Names (ARNs) that represents the virtual tapes that were created.
        public let tapeARNs: [String]?

        @inlinable
        public init(tapeARNs: [String]? = nil) {
            self.tapeARNs = tapeARNs
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARNs = "TapeARNs"
        }
    }

    public struct DeleteAutomaticTapeCreationPolicyInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DeleteAutomaticTapeCreationPolicyOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DeleteBandwidthRateLimitInput: AWSEncodableShape {
        /// One of the BandwidthType values that indicates the gateway bandwidth rate limit to delete. Valid Values: UPLOAD | DOWNLOAD | ALL
        public let bandwidthType: String
        public let gatewayARN: String

        @inlinable
        public init(bandwidthType: String, gatewayARN: String) {
            self.bandwidthType = bandwidthType
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthType, name: "bandwidthType", parent: name, max: 25)
            try self.validate(self.bandwidthType, name: "bandwidthType", parent: name, min: 3)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthType = "BandwidthType"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DeleteBandwidthRateLimitOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DeleteCacheReportInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cache report you want to delete.
        public let cacheReportARN: String

        @inlinable
        public init(cacheReportARN: String) {
            self.cacheReportARN = cacheReportARN
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheReportARN, name: "cacheReportARN", parent: name, max: 500)
            try self.validate(self.cacheReportARN, name: "cacheReportARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
        }
    }

    public struct DeleteCacheReportOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cache report you want to delete.
        public let cacheReportARN: String?

        @inlinable
        public init(cacheReportARN: String? = nil) {
            self.cacheReportARN = cacheReportARN
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
        }
    }

    public struct DeleteChapCredentialsInput: AWSEncodableShape {
        /// The iSCSI initiator that connects to the target.
        public let initiatorName: String
        /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for specified VolumeARN.
        public let targetARN: String

        @inlinable
        public init(initiatorName: String, targetARN: String) {
            self.initiatorName = initiatorName
            self.targetARN = targetARN
        }

        public func validate(name: String) throws {
            try self.validate(self.initiatorName, name: "initiatorName", parent: name, max: 255)
            try self.validate(self.initiatorName, name: "initiatorName", parent: name, min: 1)
            try self.validate(self.initiatorName, name: "initiatorName", parent: name, pattern: "^[0-9a-z:.-]+$")
            try self.validate(self.targetARN, name: "targetARN", parent: name, max: 800)
            try self.validate(self.targetARN, name: "targetARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case initiatorName = "InitiatorName"
            case targetARN = "TargetARN"
        }
    }

    public struct DeleteChapCredentialsOutput: AWSDecodableShape {
        /// The iSCSI initiator that connects to the target.
        public let initiatorName: String?
        /// The Amazon Resource Name (ARN) of the target.
        public let targetARN: String?

        @inlinable
        public init(initiatorName: String? = nil, targetARN: String? = nil) {
            self.initiatorName = initiatorName
            self.targetARN = targetARN
        }

        private enum CodingKeys: String, CodingKey {
            case initiatorName = "InitiatorName"
            case targetARN = "TargetARN"
        }
    }

    public struct DeleteFileShareInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the file share to be deleted.
        public let fileShareARN: String
        /// If this value is set to true, the operation deletes a file share immediately and aborts all data uploads to Amazon Web Services. Otherwise, the file share is not deleted until all data is uploaded to Amazon Web Services. This process aborts the data upload process, and the file share enters the FORCE_DELETING status. Valid Values: true | false
        public let forceDelete: Bool?

        @inlinable
        public init(fileShareARN: String, forceDelete: Bool? = nil) {
            self.fileShareARN = fileShareARN
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
            case forceDelete = "ForceDelete"
        }
    }

    public struct DeleteFileShareOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted file share.
        public let fileShareARN: String?

        @inlinable
        public init(fileShareARN: String? = nil) {
            self.fileShareARN = fileShareARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
        }
    }

    public struct DeleteGatewayInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DeleteGatewayOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DeleteSnapshotScheduleInput: AWSEncodableShape {
        /// The volume which snapshot schedule to delete.
        public let volumeARN: String

        @inlinable
        public init(volumeARN: String) {
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct DeleteSnapshotScheduleOutput: AWSDecodableShape {
        /// The volume which snapshot schedule was deleted.
        public let volumeARN: String?

        @inlinable
        public init(volumeARN: String? = nil) {
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct DeleteTapeArchiveInput: AWSEncodableShape {
        /// Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock. Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes with tape retention lock set to compliance can't be deleted.
        public let bypassGovernanceRetention: Bool?
        /// The Amazon Resource Name (ARN) of the virtual tape to delete from the virtual tape shelf (VTS).
        public let tapeARN: String

        @inlinable
        public init(bypassGovernanceRetention: Bool? = nil, tapeARN: String) {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bypassGovernanceRetention = "BypassGovernanceRetention"
            case tapeARN = "TapeARN"
        }
    }

    public struct DeleteTapeArchiveOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the virtual tape that was deleted from the virtual tape shelf (VTS).
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct DeleteTapeInput: AWSEncodableShape {
        /// Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock. Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes with tape retention lock set to compliance can't be deleted.
        public let bypassGovernanceRetention: Bool?
        /// The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is associated with. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public let gatewayARN: String
        /// The Amazon Resource Name (ARN) of the virtual tape to delete.
        public let tapeARN: String

        @inlinable
        public init(bypassGovernanceRetention: Bool? = nil, gatewayARN: String, tapeARN: String) {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.gatewayARN = gatewayARN
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bypassGovernanceRetention = "BypassGovernanceRetention"
            case gatewayARN = "GatewayARN"
            case tapeARN = "TapeARN"
        }
    }

    public struct DeleteTapeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted virtual tape.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct DeleteTapePoolInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom tape pool to delete.
        public let poolARN: String

        @inlinable
        public init(poolARN: String) {
            self.poolARN = poolARN
        }

        public func validate(name: String) throws {
            try self.validate(self.poolARN, name: "poolARN", parent: name, max: 500)
            try self.validate(self.poolARN, name: "poolARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case poolARN = "PoolARN"
        }
    }

    public struct DeleteTapePoolOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom tape pool being deleted.
        public let poolARN: String?

        @inlinable
        public init(poolARN: String? = nil) {
            self.poolARN = poolARN
        }

        private enum CodingKeys: String, CodingKey {
            case poolARN = "PoolARN"
        }
    }

    public struct DeleteVolumeInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes operation to return a list of gateway volumes.
        public let volumeARN: String

        @inlinable
        public init(volumeARN: String) {
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct DeleteVolumeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the storage volume that was deleted. It is the same ARN you provided in the request.
        public let volumeARN: String?

        @inlinable
        public init(volumeARN: String? = nil) {
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct DescribeAvailabilityMonitorTestInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeAvailabilityMonitorTestOutput: AWSDecodableShape {
        public let gatewayARN: String?
        /// The time the high availability monitoring test was started. If a test hasn't been performed, the value of this field is null.
        public let startTime: Date?
        /// The status of the high availability monitoring test. If a test hasn't been performed, the value of this field is null.
        public let status: AvailabilityMonitorTestStatus?

        @inlinable
        public init(gatewayARN: String? = nil, startTime: Date? = nil, status: AvailabilityMonitorTestStatus? = nil) {
            self.gatewayARN = gatewayARN
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case startTime = "StartTime"
            case status = "Status"
        }
    }

    public struct DescribeBandwidthRateLimitInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeBandwidthRateLimitOutput: AWSDecodableShape {
        /// The average download bandwidth rate limit in bits per second. This field does not appear in the response if the download rate limit is not set.
        public let averageDownloadRateLimitInBitsPerSec: Int64?
        /// The average upload bandwidth rate limit in bits per second. This field does not appear in the response if the upload rate limit is not set.
        public let averageUploadRateLimitInBitsPerSec: Int64?
        public let gatewayARN: String?

        @inlinable
        public init(averageDownloadRateLimitInBitsPerSec: Int64? = nil, averageUploadRateLimitInBitsPerSec: Int64? = nil, gatewayARN: String? = nil) {
            self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
            case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeBandwidthRateLimitScheduleInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeBandwidthRateLimitScheduleOutput: AWSDecodableShape {
        ///  An array that contains the bandwidth rate limit intervals for a tape or volume gateway.
        public let bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]?
        public let gatewayARN: String?

        @inlinable
        public init(bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]? = nil, gatewayARN: String? = nil) {
            self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeCacheInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeCacheOutput: AWSDecodableShape {
        /// The amount of cache in bytes allocated to a gateway.
        public let cacheAllocatedInBytes: Int64?
        /// The file share's contribution to the overall percentage of the gateway's cache that has not been persisted to Amazon Web Services. The sample is taken at the end of the reporting period.
        public let cacheDirtyPercentage: Double?
        /// Percent of application read operations from the file shares that are served from cache. The sample is taken at the end of the reporting period.
        public let cacheHitPercentage: Double?
        /// Percent of application read operations from the file shares that are not served from cache. The sample is taken at the end of the reporting period.
        public let cacheMissPercentage: Double?
        /// Percent use of the gateway's cache storage. This metric applies only to the gateway-cached volume setup. The sample is taken at the end of the reporting period.
        public let cacheUsedPercentage: Double?
        /// An array of strings that identify disks that are to be configured as working storage. Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs from the ListLocalDisks API.
        public let diskIds: [String]?
        public let gatewayARN: String?

        @inlinable
        public init(cacheAllocatedInBytes: Int64? = nil, cacheDirtyPercentage: Double? = nil, cacheHitPercentage: Double? = nil, cacheMissPercentage: Double? = nil, cacheUsedPercentage: Double? = nil, diskIds: [String]? = nil, gatewayARN: String? = nil) {
            self.cacheAllocatedInBytes = cacheAllocatedInBytes
            self.cacheDirtyPercentage = cacheDirtyPercentage
            self.cacheHitPercentage = cacheHitPercentage
            self.cacheMissPercentage = cacheMissPercentage
            self.cacheUsedPercentage = cacheUsedPercentage
            self.diskIds = diskIds
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case cacheAllocatedInBytes = "CacheAllocatedInBytes"
            case cacheDirtyPercentage = "CacheDirtyPercentage"
            case cacheHitPercentage = "CacheHitPercentage"
            case cacheMissPercentage = "CacheMissPercentage"
            case cacheUsedPercentage = "CacheUsedPercentage"
            case diskIds = "DiskIds"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeCacheReportInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cache report you want to describe.
        public let cacheReportARN: String

        @inlinable
        public init(cacheReportARN: String) {
            self.cacheReportARN = cacheReportARN
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheReportARN, name: "cacheReportARN", parent: name, max: 500)
            try self.validate(self.cacheReportARN, name: "cacheReportARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
        }
    }

    public struct DescribeCacheReportOutput: AWSDecodableShape {
        /// Contains all informational fields associated with a cache report. Includes name, ARN, tags, status, progress, filters, start time, and end time.
        public let cacheReportInfo: CacheReportInfo?

        @inlinable
        public init(cacheReportInfo: CacheReportInfo? = nil) {
            self.cacheReportInfo = cacheReportInfo
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportInfo = "CacheReportInfo"
        }
    }

    public struct DescribeCachediSCSIVolumesInput: AWSEncodableShape {
        /// An array of strings where each string represents the Amazon Resource Name (ARN) of a cached volume. All of the specified cached volumes must be from the same gateway. Use ListVolumes to get volume ARNs for a gateway.
        public let volumeARNs: [String]

        @inlinable
        public init(volumeARNs: [String]) {
            self.volumeARNs = volumeARNs
        }

        public func validate(name: String) throws {
            try self.volumeARNs.forEach {
                try validate($0, name: "volumeARNs[]", parent: name, max: 500)
                try validate($0, name: "volumeARNs[]", parent: name, min: 50)
                try validate($0, name: "volumeARNs[]", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARNs = "VolumeARNs"
        }
    }

    public struct DescribeCachediSCSIVolumesOutput: AWSDecodableShape {
        /// An array of objects where each object contains metadata about one cached volume.
        public let cachediSCSIVolumes: [CachediSCSIVolume]?

        @inlinable
        public init(cachediSCSIVolumes: [CachediSCSIVolume]? = nil) {
            self.cachediSCSIVolumes = cachediSCSIVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case cachediSCSIVolumes = "CachediSCSIVolumes"
        }
    }

    public struct DescribeChapCredentialsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return to retrieve the TargetARN for specified VolumeARN.
        public let targetARN: String

        @inlinable
        public init(targetARN: String) {
            self.targetARN = targetARN
        }

        public func validate(name: String) throws {
            try self.validate(self.targetARN, name: "targetARN", parent: name, max: 800)
            try self.validate(self.targetARN, name: "targetARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case targetARN = "TargetARN"
        }
    }

    public struct DescribeChapCredentialsOutput: AWSDecodableShape {
        /// An array of ChapInfo objects that represent CHAP credentials. Each object in the array contains CHAP credential information for one target-initiator pair. If no CHAP credentials are set, an empty array is returned. CHAP credential information is provided in a JSON object with the following fields:    InitiatorName: The iSCSI initiator that connects to the target.    SecretToAuthenticateInitiator: The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.    SecretToAuthenticateTarget: The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g. Windows client).    TargetARN: The Amazon Resource Name (ARN) of the storage volume.
        public let chapCredentials: [ChapInfo]?

        @inlinable
        public init(chapCredentials: [ChapInfo]? = nil) {
            self.chapCredentials = chapCredentials
        }

        private enum CodingKeys: String, CodingKey {
            case chapCredentials = "ChapCredentials"
        }
    }

    public struct DescribeFileSystemAssociationsInput: AWSEncodableShape {
        /// An array containing the Amazon Resource Name (ARN) of each file system association to be described.
        public let fileSystemAssociationARNList: [String]

        @inlinable
        public init(fileSystemAssociationARNList: [String]) {
            self.fileSystemAssociationARNList = fileSystemAssociationARNList
        }

        public func validate(name: String) throws {
            try self.fileSystemAssociationARNList.forEach {
                try validate($0, name: "fileSystemAssociationARNList[]", parent: name, max: 500)
                try validate($0, name: "fileSystemAssociationARNList[]", parent: name, min: 50)
            }
            try self.validate(self.fileSystemAssociationARNList, name: "fileSystemAssociationARNList", parent: name, max: 10)
            try self.validate(self.fileSystemAssociationARNList, name: "fileSystemAssociationARNList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationARNList = "FileSystemAssociationARNList"
        }
    }

    public struct DescribeFileSystemAssociationsOutput: AWSDecodableShape {
        /// An array containing the FileSystemAssociationInfo data type of each file system association to be described.
        public let fileSystemAssociationInfoList: [FileSystemAssociationInfo]?

        @inlinable
        public init(fileSystemAssociationInfoList: [FileSystemAssociationInfo]? = nil) {
            self.fileSystemAssociationInfoList = fileSystemAssociationInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationInfoList = "FileSystemAssociationInfoList"
        }
    }

    public struct DescribeGatewayInformationInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeGatewayInformationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to monitor events in the gateway. This field only only exist and returns once it have been chosen and set by the SGW service, based on the OS version of the gateway VM
        public let cloudWatchLogGroupARN: String?
        /// Date after which this gateway will not receive software updates for new features and bug fixes.
        public let deprecationDate: String?
        /// The ID of the Amazon EC2 instance that was used to launch the gateway.
        public let ec2InstanceId: String?
        /// The Amazon Web Services Region where the Amazon EC2 instance is located.
        public let ec2InstanceRegion: String?
        /// The type of endpoint for your gateway. Valid Values: STANDARD | FIPS
        public let endpointType: String?
        public let gatewayARN: String?
        /// Specifies the size of the gateway's metadata cache.
        public let gatewayCapacity: GatewayCapacity?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations.
        public let gatewayId: String?
        /// The name you configured for your gateway.
        public let gatewayName: String?
        /// A NetworkInterface array that contains descriptions of the gateway network interfaces.
        public let gatewayNetworkInterfaces: [NetworkInterface]?
        /// A value that indicates the operating state of the gateway.
        public let gatewayState: String?
        /// A value that indicates the time zone configured for the gateway.
        public let gatewayTimezone: String?
        /// The type of the gateway.  Amazon FSx File Gateway is no longer available to new customers. Existing customers of FSx File Gateway can continue to use the service normally. For capabilities similar to FSx File Gateway, visit this blog post.
        public let gatewayType: String?
        /// The type of hardware or software platform on which the gateway is running.  Tape Gateway is no longer available on Snow Family devices.
        public let hostEnvironment: HostEnvironment?
        /// A unique identifier for the specific instance of the host platform running the gateway. This value is only available for certain host environments, and its format depends on the host environment type.
        public let hostEnvironmentId: String?
        /// The date on which the last software update was applied to the gateway. If the gateway has never been updated, this field does not return a value in the response. This only only exist and returns once it have been chosen and set by the SGW service, based on the OS version of the gateway VM
        public let lastSoftwareUpdate: String?
        /// The date on which an update to the gateway is available. This date is in the time zone of the gateway. If the gateway is not available for an update this field is not returned in the response.
        public let nextUpdateAvailabilityDate: String?
        /// Date after which this gateway will not receive software updates for new features.
        public let softwareUpdatesEndDate: String?
        /// The version number of the software running on the gateway appliance.
        public let softwareVersion: String?
        /// A list of the metadata cache sizes that the gateway can support based on its current hardware specifications.
        public let supportedGatewayCapacities: [GatewayCapacity]?
        /// A list of up to 50 tags assigned to the gateway, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public let tags: [Tag]?
        /// The configuration settings for the virtual private cloud (VPC) endpoint for your gateway.
        public let vpcEndpoint: String?

        @inlinable
        public init(cloudWatchLogGroupARN: String? = nil, deprecationDate: String? = nil, ec2InstanceId: String? = nil, ec2InstanceRegion: String? = nil, endpointType: String? = nil, gatewayARN: String? = nil, gatewayCapacity: GatewayCapacity? = nil, gatewayId: String? = nil, gatewayName: String? = nil, gatewayNetworkInterfaces: [NetworkInterface]? = nil, gatewayState: String? = nil, gatewayTimezone: String? = nil, gatewayType: String? = nil, hostEnvironment: HostEnvironment? = nil, hostEnvironmentId: String? = nil, lastSoftwareUpdate: String? = nil, nextUpdateAvailabilityDate: String? = nil, softwareUpdatesEndDate: String? = nil, softwareVersion: String? = nil, supportedGatewayCapacities: [GatewayCapacity]? = nil, tags: [Tag]? = nil, vpcEndpoint: String? = nil) {
            self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
            self.deprecationDate = deprecationDate
            self.ec2InstanceId = ec2InstanceId
            self.ec2InstanceRegion = ec2InstanceRegion
            self.endpointType = endpointType
            self.gatewayARN = gatewayARN
            self.gatewayCapacity = gatewayCapacity
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayNetworkInterfaces = gatewayNetworkInterfaces
            self.gatewayState = gatewayState
            self.gatewayTimezone = gatewayTimezone
            self.gatewayType = gatewayType
            self.hostEnvironment = hostEnvironment
            self.hostEnvironmentId = hostEnvironmentId
            self.lastSoftwareUpdate = lastSoftwareUpdate
            self.nextUpdateAvailabilityDate = nextUpdateAvailabilityDate
            self.softwareUpdatesEndDate = softwareUpdatesEndDate
            self.softwareVersion = softwareVersion
            self.supportedGatewayCapacities = supportedGatewayCapacities
            self.tags = tags
            self.vpcEndpoint = vpcEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
            case deprecationDate = "DeprecationDate"
            case ec2InstanceId = "Ec2InstanceId"
            case ec2InstanceRegion = "Ec2InstanceRegion"
            case endpointType = "EndpointType"
            case gatewayARN = "GatewayARN"
            case gatewayCapacity = "GatewayCapacity"
            case gatewayId = "GatewayId"
            case gatewayName = "GatewayName"
            case gatewayNetworkInterfaces = "GatewayNetworkInterfaces"
            case gatewayState = "GatewayState"
            case gatewayTimezone = "GatewayTimezone"
            case gatewayType = "GatewayType"
            case hostEnvironment = "HostEnvironment"
            case hostEnvironmentId = "HostEnvironmentId"
            case lastSoftwareUpdate = "LastSoftwareUpdate"
            case nextUpdateAvailabilityDate = "NextUpdateAvailabilityDate"
            case softwareUpdatesEndDate = "SoftwareUpdatesEndDate"
            case softwareVersion = "SoftwareVersion"
            case supportedGatewayCapacities = "SupportedGatewayCapacities"
            case tags = "Tags"
            case vpcEndpoint = "VPCEndpoint"
        }
    }

    public struct DescribeMaintenanceStartTimeInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeMaintenanceStartTimeOutput: AWSDecodableShape {
        /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month. It is not possible to set the maintenance schedule to start on days 29 through 31.
        public let dayOfMonth: Int?
        /// An ordinal number between 0 and 6 that represents the day of the week, where 0 represents Sunday and 6 represents Saturday. The day of week is in the time zone of the gateway.
        public let dayOfWeek: Int?
        public let gatewayARN: String?
        /// The hour component of the maintenance start time represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        public let hourOfDay: Int?
        /// The minute component of the maintenance start time represented as mm, where mm is the minute (0 to 59). The minute of the hour is in the time zone of the gateway.
        public let minuteOfHour: Int?
        /// A set of variables indicating the software update preferences for the gateway. Includes AutomaticUpdatePolicy parameter with the following inputs:  ALL_VERSIONS - Enables regular gateway maintenance updates.  EMERGENCY_VERSIONS_ONLY - Disables regular gateway maintenance updates. The gateway will still receive emergency version updates on rare occasions if necessary to remedy highly critical security or durability issues. You will be notified before an emergency version update is applied. These updates are applied during your gateway's scheduled maintenance window.
        public let softwareUpdatePreferences: SoftwareUpdatePreferences?
        /// A value that indicates the time zone that is set for the gateway. The start time and day of week specified should be in the time zone of the gateway.
        public let timezone: String?

        @inlinable
        public init(dayOfMonth: Int? = nil, dayOfWeek: Int? = nil, gatewayARN: String? = nil, hourOfDay: Int? = nil, minuteOfHour: Int? = nil, softwareUpdatePreferences: SoftwareUpdatePreferences? = nil, timezone: String? = nil) {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.gatewayARN = gatewayARN
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
            self.softwareUpdatePreferences = softwareUpdatePreferences
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfMonth = "DayOfMonth"
            case dayOfWeek = "DayOfWeek"
            case gatewayARN = "GatewayARN"
            case hourOfDay = "HourOfDay"
            case minuteOfHour = "MinuteOfHour"
            case softwareUpdatePreferences = "SoftwareUpdatePreferences"
            case timezone = "Timezone"
        }
    }

    public struct DescribeNFSFileSharesInput: AWSEncodableShape {
        /// An array containing the Amazon Resource Name (ARN) of each file share to be described.
        public let fileShareARNList: [String]

        @inlinable
        public init(fileShareARNList: [String]) {
            self.fileShareARNList = fileShareARNList
        }

        public func validate(name: String) throws {
            try self.fileShareARNList.forEach {
                try validate($0, name: "fileShareARNList[]", parent: name, max: 500)
                try validate($0, name: "fileShareARNList[]", parent: name, min: 50)
            }
            try self.validate(self.fileShareARNList, name: "fileShareARNList", parent: name, max: 10)
            try self.validate(self.fileShareARNList, name: "fileShareARNList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARNList = "FileShareARNList"
        }
    }

    public struct DescribeNFSFileSharesOutput: AWSDecodableShape {
        /// An array containing a description for each requested file share.
        public let nfsFileShareInfoList: [NFSFileShareInfo]?

        @inlinable
        public init(nfsFileShareInfoList: [NFSFileShareInfo]? = nil) {
            self.nfsFileShareInfoList = nfsFileShareInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case nfsFileShareInfoList = "NFSFileShareInfoList"
        }
    }

    public struct DescribeSMBFileSharesInput: AWSEncodableShape {
        /// An array containing the Amazon Resource Name (ARN) of each file share to be described.
        public let fileShareARNList: [String]

        @inlinable
        public init(fileShareARNList: [String]) {
            self.fileShareARNList = fileShareARNList
        }

        public func validate(name: String) throws {
            try self.fileShareARNList.forEach {
                try validate($0, name: "fileShareARNList[]", parent: name, max: 500)
                try validate($0, name: "fileShareARNList[]", parent: name, min: 50)
            }
            try self.validate(self.fileShareARNList, name: "fileShareARNList", parent: name, max: 10)
            try self.validate(self.fileShareARNList, name: "fileShareARNList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARNList = "FileShareARNList"
        }
    }

    public struct DescribeSMBFileSharesOutput: AWSDecodableShape {
        /// An array containing a description for each requested file share.
        public let smbFileShareInfoList: [SMBFileShareInfo]?

        @inlinable
        public init(smbFileShareInfoList: [SMBFileShareInfo]? = nil) {
            self.smbFileShareInfoList = smbFileShareInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case smbFileShareInfoList = "SMBFileShareInfoList"
        }
    }

    public struct DescribeSMBSettingsInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeSMBSettingsOutput: AWSDecodableShape {
        /// Indicates the status of a gateway that is a member of the Active Directory domain.  This field is only used as part of a JoinDomain request. It is not affected by Active Directory connectivity changes that occur after the JoinDomain request succeeds.     ACCESS_DENIED: Indicates that the JoinDomain operation failed due to an authentication error.    DETACHED: Indicates that gateway is not joined to a domain.    JOINED: Indicates that the gateway has successfully joined a domain.    JOINING: Indicates that a JoinDomain operation is in progress.    NETWORK_ERROR: Indicates that JoinDomain operation failed due to a network or connectivity error.    TIMEOUT: Indicates that the JoinDomain operation failed because the operation didn't complete within the allotted time.    UNKNOWN_ERROR: Indicates that the JoinDomain operation failed due to another type of error.
        public let activeDirectoryStatus: ActiveDirectoryStatus?
        /// The name of the domain that the gateway is joined to.
        public let domainName: String?
        /// The shares on this gateway appear when listing shares. Only supported for S3 File Gateways.
        public let fileSharesVisible: Bool?
        public let gatewayARN: String?
        /// This value is true if a password for the guest user smbguest is set, otherwise false. Only supported for S3 File Gateways. Valid Values: true | false
        public let smbGuestPasswordSet: Bool?
        /// A list of Active Directory users and groups that have special permissions for SMB file shares on the gateway.
        public let smbLocalGroups: SMBLocalGroups?
        /// The type of security strategy that was specified for file gateway.    ClientSpecified: If you choose this option, requests are established based on what is negotiated by the client. This option is recommended when you want to maximize compatibility across different clients in your environment. Supported only for S3 File Gateway.    MandatorySigning: If you choose this option, File Gateway only allows connections from SMBv2 or SMBv3 clients that have signing turned on. This option works with SMB clients on Microsoft Windows Vista, Windows Server 2008, or later.     MandatoryEncryption: If you choose this option, File Gateway only allows connections from SMBv3 clients that have encryption turned on. Both 256-bit and 128-bit algorithms are allowed. This option is recommended for environments that handle sensitive data. It works with SMB clients on Microsoft Windows 8, Windows Server 2012, or later.    MandatoryEncryptionNoAes128: If you choose this option, File Gateway only allows connections from SMBv3 clients that use 256-bit AES encryption algorithms. 128-bit algorithms are not allowed. This option is recommended for environments that handle sensitive data. It works with SMB clients on Microsoft Windows 8, Windows Server 2012, or later.
        public let smbSecurityStrategy: SMBSecurityStrategy?

        @inlinable
        public init(activeDirectoryStatus: ActiveDirectoryStatus? = nil, domainName: String? = nil, fileSharesVisible: Bool? = nil, gatewayARN: String? = nil, smbGuestPasswordSet: Bool? = nil, smbLocalGroups: SMBLocalGroups? = nil, smbSecurityStrategy: SMBSecurityStrategy? = nil) {
            self.activeDirectoryStatus = activeDirectoryStatus
            self.domainName = domainName
            self.fileSharesVisible = fileSharesVisible
            self.gatewayARN = gatewayARN
            self.smbGuestPasswordSet = smbGuestPasswordSet
            self.smbLocalGroups = smbLocalGroups
            self.smbSecurityStrategy = smbSecurityStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryStatus = "ActiveDirectoryStatus"
            case domainName = "DomainName"
            case fileSharesVisible = "FileSharesVisible"
            case gatewayARN = "GatewayARN"
            case smbGuestPasswordSet = "SMBGuestPasswordSet"
            case smbLocalGroups = "SMBLocalGroups"
            case smbSecurityStrategy = "SMBSecurityStrategy"
        }
    }

    public struct DescribeSnapshotScheduleInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes operation to return a list of gateway volumes.
        public let volumeARN: String

        @inlinable
        public init(volumeARN: String) {
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct DescribeSnapshotScheduleOutput: AWSDecodableShape {
        /// The snapshot description.
        public let description: String?
        /// The number of hours between snapshots.
        public let recurrenceInHours: Int?
        /// The hour of the day at which the snapshot schedule begins represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        public let startAt: Int?
        /// A list of up to 50 tags assigned to the snapshot schedule, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public let tags: [Tag]?
        /// A value that indicates the time zone of the gateway.
        public let timezone: String?
        /// The Amazon Resource Name (ARN) of the volume that was specified in the request.
        public let volumeARN: String?

        @inlinable
        public init(description: String? = nil, recurrenceInHours: Int? = nil, startAt: Int? = nil, tags: [Tag]? = nil, timezone: String? = nil, volumeARN: String? = nil) {
            self.description = description
            self.recurrenceInHours = recurrenceInHours
            self.startAt = startAt
            self.tags = tags
            self.timezone = timezone
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case recurrenceInHours = "RecurrenceInHours"
            case startAt = "StartAt"
            case tags = "Tags"
            case timezone = "Timezone"
            case volumeARN = "VolumeARN"
        }
    }

    public struct DescribeStorediSCSIVolumesInput: AWSEncodableShape {
        /// An array of strings where each string represents the Amazon Resource Name (ARN) of a stored volume. All of the specified stored volumes must be from the same gateway. Use ListVolumes to get volume ARNs for a gateway.
        public let volumeARNs: [String]

        @inlinable
        public init(volumeARNs: [String]) {
            self.volumeARNs = volumeARNs
        }

        public func validate(name: String) throws {
            try self.volumeARNs.forEach {
                try validate($0, name: "volumeARNs[]", parent: name, max: 500)
                try validate($0, name: "volumeARNs[]", parent: name, min: 50)
                try validate($0, name: "volumeARNs[]", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARNs = "VolumeARNs"
        }
    }

    public struct DescribeStorediSCSIVolumesOutput: AWSDecodableShape {
        /// Describes a single unit of output from DescribeStorediSCSIVolumes. The following fields are returned:    ChapEnabled: Indicates whether mutual CHAP is enabled for the iSCSI target.    LunNumber: The logical disk number.    NetworkInterfaceId: The network interface ID of the stored volume that initiator use to map the stored volume as an iSCSI target.    NetworkInterfacePort: The port used to communicate with iSCSI targets.    PreservedExistingData: Indicates when the stored volume was created, existing data on the underlying local disk was preserved.    SourceSnapshotId: If the stored volume was created from a snapshot, this field contains the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not included.    StorediSCSIVolumes: An array of StorediSCSIVolume objects where each object contains metadata about one stored volume.    TargetARN: The Amazon Resource Name (ARN) of the volume target.    VolumeARN: The Amazon Resource Name (ARN) of the stored volume.    VolumeDiskId: The disk ID of the local disk that was specified in the CreateStorediSCSIVolume operation.    VolumeId: The unique identifier of the storage volume, e.g. vol-1122AABB.    VolumeiSCSIAttributes: An VolumeiSCSIAttributes object that represents a collection of iSCSI attributes for one stored volume.    VolumeProgress: Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the stored volume is not restoring or bootstrapping.    VolumeSizeInBytes: The size of the volume in bytes.    VolumeStatus: One of the VolumeStatus values that indicates the state of the volume.    VolumeType: One of the enumeration values describing the type of the volume. Currently, only STORED volumes are supported.
        public let storediSCSIVolumes: [StorediSCSIVolume]?

        @inlinable
        public init(storediSCSIVolumes: [StorediSCSIVolume]? = nil) {
            self.storediSCSIVolumes = storediSCSIVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case storediSCSIVolumes = "StorediSCSIVolumes"
        }
    }

    public struct DescribeTapeArchivesInput: AWSEncodableShape {
        /// Specifies that the number of virtual tapes described be limited to the specified number.
        public let limit: Int?
        /// An opaque string that indicates the position at which to begin describing virtual tapes.
        public let marker: String?
        /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual tapes you want to describe.
        public let tapeARNs: [String]?

        @inlinable
        public init(limit: Int? = nil, marker: String? = nil, tapeARNs: [String]? = nil) {
            self.limit = limit
            self.marker = marker
            self.tapeARNs = tapeARNs
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.tapeARNs?.forEach {
                try validate($0, name: "tapeARNs[]", parent: name, max: 500)
                try validate($0, name: "tapeARNs[]", parent: name, min: 50)
                try validate($0, name: "tapeARNs[]", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case marker = "Marker"
            case tapeARNs = "TapeARNs"
        }
    }

    public struct DescribeTapeArchivesOutput: AWSDecodableShape {
        /// An opaque string that indicates the position at which the virtual tapes that were fetched for description ended. Use this marker in your next request to fetch the next set of virtual tapes in the virtual tape shelf (VTS). If there are no more virtual tapes to describe, this field does not appear in the response.
        public let marker: String?
        /// An array of virtual tape objects in the virtual tape shelf (VTS). The description includes of the Amazon Resource Name (ARN) of the virtual tapes. The information returned includes the Amazon Resource Names (ARNs) of the tapes, size of the tapes, status of the tapes, progress of the description, and tape barcode.
        public let tapeArchives: [TapeArchive]?

        @inlinable
        public init(marker: String? = nil, tapeArchives: [TapeArchive]? = nil) {
            self.marker = marker
            self.tapeArchives = tapeArchives
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case tapeArchives = "TapeArchives"
        }
    }

    public struct DescribeTapeRecoveryPointsInput: AWSEncodableShape {
        public let gatewayARN: String
        /// Specifies that the number of virtual tape recovery points that are described be limited to the specified number.
        public let limit: Int?
        /// An opaque string that indicates the position at which to begin describing the virtual tape recovery points.
        public let marker: String?

        @inlinable
        public init(gatewayARN: String, limit: Int? = nil, marker: String? = nil) {
            self.gatewayARN = gatewayARN
            self.limit = limit
            self.marker = marker
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case limit = "Limit"
            case marker = "Marker"
        }
    }

    public struct DescribeTapeRecoveryPointsOutput: AWSDecodableShape {
        public let gatewayARN: String?
        /// An opaque string that indicates the position at which the virtual tape recovery points that were listed for description ended. Use this marker in your next request to list the next set of virtual tape recovery points in the list. If there are no more recovery points to describe, this field does not appear in the response.
        public let marker: String?
        /// An array of TapeRecoveryPointInfos that are available for the specified gateway.
        public let tapeRecoveryPointInfos: [TapeRecoveryPointInfo]?

        @inlinable
        public init(gatewayARN: String? = nil, marker: String? = nil, tapeRecoveryPointInfos: [TapeRecoveryPointInfo]? = nil) {
            self.gatewayARN = gatewayARN
            self.marker = marker
            self.tapeRecoveryPointInfos = tapeRecoveryPointInfos
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case marker = "Marker"
            case tapeRecoveryPointInfos = "TapeRecoveryPointInfos"
        }
    }

    public struct DescribeTapesInput: AWSEncodableShape {
        public let gatewayARN: String
        /// Specifies that the number of virtual tapes described be limited to the specified number.  Amazon Web Services may impose its own limit, if this field is not set.
        public let limit: Int?
        /// A marker value, obtained in a previous call to DescribeTapes. This marker indicates which page of results to retrieve. If not specified, the first page of results is retrieved.
        public let marker: String?
        /// Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual tapes you want to describe. If this parameter is not specified, Tape gateway returns a description of all virtual tapes associated with the specified gateway.
        public let tapeARNs: [String]?

        @inlinable
        public init(gatewayARN: String, limit: Int? = nil, marker: String? = nil, tapeARNs: [String]? = nil) {
            self.gatewayARN = gatewayARN
            self.limit = limit
            self.marker = marker
            self.tapeARNs = tapeARNs
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.tapeARNs?.forEach {
                try validate($0, name: "tapeARNs[]", parent: name, max: 500)
                try validate($0, name: "tapeARNs[]", parent: name, min: 50)
                try validate($0, name: "tapeARNs[]", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case limit = "Limit"
            case marker = "Marker"
            case tapeARNs = "TapeARNs"
        }
    }

    public struct DescribeTapesOutput: AWSDecodableShape {
        /// An opaque string that can be used as part of a subsequent DescribeTapes call to retrieve the next page of results. If a response does not contain a marker, then there are no more results to be retrieved.
        public let marker: String?
        /// An array of virtual tape descriptions.
        public let tapes: [Tape]?

        @inlinable
        public init(marker: String? = nil, tapes: [Tape]? = nil) {
            self.marker = marker
            self.tapes = tapes
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case tapes = "Tapes"
        }
    }

    public struct DescribeUploadBufferInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeUploadBufferOutput: AWSDecodableShape {
        /// An array of the gateway's local disk IDs that are configured as working storage. Each local disk ID is specified as a string (minimum length of 1 and maximum length of 300). If no local disks are configured as working storage, then the DiskIds array is empty.
        public let diskIds: [String]?
        public let gatewayARN: String?
        /// The total number of bytes allocated in the gateway's as upload buffer.
        public let uploadBufferAllocatedInBytes: Int64?
        /// The total number of bytes being used in the gateway's upload buffer.
        public let uploadBufferUsedInBytes: Int64?

        @inlinable
        public init(diskIds: [String]? = nil, gatewayARN: String? = nil, uploadBufferAllocatedInBytes: Int64? = nil, uploadBufferUsedInBytes: Int64? = nil) {
            self.diskIds = diskIds
            self.gatewayARN = gatewayARN
            self.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes
            self.uploadBufferUsedInBytes = uploadBufferUsedInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case diskIds = "DiskIds"
            case gatewayARN = "GatewayARN"
            case uploadBufferAllocatedInBytes = "UploadBufferAllocatedInBytes"
            case uploadBufferUsedInBytes = "UploadBufferUsedInBytes"
        }
    }

    public struct DescribeVTLDevicesInput: AWSEncodableShape {
        public let gatewayARN: String
        /// Specifies that the number of VTL devices described be limited to the specified number.
        public let limit: Int?
        /// An opaque string that indicates the position at which to begin describing the VTL devices.
        public let marker: String?
        /// An array of strings, where each string represents the Amazon Resource Name (ARN) of a VTL device.  All of the specified VTL devices must be from the same gateway. If no VTL devices are specified, the result will contain all devices on the specified gateway.
        public let vtlDeviceARNs: [String]?

        @inlinable
        public init(gatewayARN: String, limit: Int? = nil, marker: String? = nil, vtlDeviceARNs: [String]? = nil) {
            self.gatewayARN = gatewayARN
            self.limit = limit
            self.marker = marker
            self.vtlDeviceARNs = vtlDeviceARNs
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.vtlDeviceARNs?.forEach {
                try validate($0, name: "vtlDeviceARNs[]", parent: name, max: 500)
                try validate($0, name: "vtlDeviceARNs[]", parent: name, min: 50)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case limit = "Limit"
            case marker = "Marker"
            case vtlDeviceARNs = "VTLDeviceARNs"
        }
    }

    public struct DescribeVTLDevicesOutput: AWSDecodableShape {
        public let gatewayARN: String?
        /// An opaque string that indicates the position at which the VTL devices that were fetched for description ended. Use the marker in your next request to fetch the next set of VTL devices in the list. If there are no more VTL devices to describe, this field does not appear in the response.
        public let marker: String?
        /// An array of VTL device objects composed of the Amazon Resource Name (ARN) of the VTL devices.
        public let vtlDevices: [VTLDevice]?

        @inlinable
        public init(gatewayARN: String? = nil, marker: String? = nil, vtlDevices: [VTLDevice]? = nil) {
            self.gatewayARN = gatewayARN
            self.marker = marker
            self.vtlDevices = vtlDevices
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case marker = "Marker"
            case vtlDevices = "VTLDevices"
        }
    }

    public struct DescribeWorkingStorageInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DescribeWorkingStorageOutput: AWSDecodableShape {
        /// An array of the gateway's local disk IDs that are configured as working storage. Each local disk ID is specified as a string (minimum length of 1 and maximum length of 300). If no local disks are configured as working storage, then the DiskIds array is empty.
        public let diskIds: [String]?
        public let gatewayARN: String?
        /// The total working storage in bytes allocated for the gateway. If no working storage is configured for the gateway, this field returns 0.
        public let workingStorageAllocatedInBytes: Int64?
        /// The total working storage in bytes in use by the gateway. If no working storage is configured for the gateway, this field returns 0.
        public let workingStorageUsedInBytes: Int64?

        @inlinable
        public init(diskIds: [String]? = nil, gatewayARN: String? = nil, workingStorageAllocatedInBytes: Int64? = nil, workingStorageUsedInBytes: Int64? = nil) {
            self.diskIds = diskIds
            self.gatewayARN = gatewayARN
            self.workingStorageAllocatedInBytes = workingStorageAllocatedInBytes
            self.workingStorageUsedInBytes = workingStorageUsedInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case diskIds = "DiskIds"
            case gatewayARN = "GatewayARN"
            case workingStorageAllocatedInBytes = "WorkingStorageAllocatedInBytes"
            case workingStorageUsedInBytes = "WorkingStorageUsedInBytes"
        }
    }

    public struct DetachVolumeInput: AWSEncodableShape {
        /// Set to true to forcibly remove the iSCSI connection of the target volume and detach the volume. The default is false. If this value is set to false, you must manually disconnect the iSCSI connection from the target volume. Valid Values: true | false
        public let forceDetach: Bool?
        /// The Amazon Resource Name (ARN) of the volume to detach from the gateway.
        public let volumeARN: String

        @inlinable
        public init(forceDetach: Bool? = nil, volumeARN: String) {
            self.forceDetach = forceDetach
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case forceDetach = "ForceDetach"
            case volumeARN = "VolumeARN"
        }
    }

    public struct DetachVolumeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the volume that was detached.
        public let volumeARN: String?

        @inlinable
        public init(volumeARN: String? = nil) {
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct DeviceiSCSIAttributes: AWSDecodableShape {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public let chapEnabled: Bool?
        /// The network interface identifier of the VTL device.
        public let networkInterfaceId: String?
        /// The port used to communicate with iSCSI VTL device targets.
        public let networkInterfacePort: Int?
        /// Specifies the unique Amazon Resource Name (ARN) that encodes the iSCSI qualified name(iqn) of a tape drive or media changer target.
        public let targetARN: String?

        @inlinable
        public init(chapEnabled: Bool? = nil, networkInterfaceId: String? = nil, networkInterfacePort: Int? = nil, targetARN: String? = nil) {
            self.chapEnabled = chapEnabled
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }

        private enum CodingKeys: String, CodingKey {
            case chapEnabled = "ChapEnabled"
            case networkInterfaceId = "NetworkInterfaceId"
            case networkInterfacePort = "NetworkInterfacePort"
            case targetARN = "TargetARN"
        }
    }

    public struct DisableGatewayInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DisableGatewayOutput: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) of the disabled gateway.
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct DisassociateFileSystemInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the file system association to be deleted.
        public let fileSystemAssociationARN: String
        /// If this value is set to true, the operation disassociates an Amazon FSx file system immediately. It ends all data uploads to the file system, and the file system association enters the FORCE_DELETING status. If this value is set to false, the Amazon FSx file system does not disassociate until all data is uploaded.
        public let forceDelete: Bool?

        @inlinable
        public init(fileSystemAssociationARN: String, forceDelete: Bool? = nil) {
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemAssociationARN, name: "fileSystemAssociationARN", parent: name, max: 500)
            try self.validate(self.fileSystemAssociationARN, name: "fileSystemAssociationARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationARN = "FileSystemAssociationARN"
            case forceDelete = "ForceDelete"
        }
    }

    public struct DisassociateFileSystemOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted file system association.
        public let fileSystemAssociationARN: String?

        @inlinable
        public init(fileSystemAssociationARN: String? = nil) {
            self.fileSystemAssociationARN = fileSystemAssociationARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationARN = "FileSystemAssociationARN"
        }
    }

    public struct Disk: AWSDecodableShape {
        /// The iSCSI qualified name (IQN) that is defined for a disk. This field is not included in the response if the local disk is not defined as an iSCSI target. The format of this field is targetIqn::LUNNumber::region-volumeId.
        public let diskAllocationResource: String?
        public let diskAllocationType: String?
        public let diskAttributeList: [String]?
        /// The unique device ID or other distinguishing data that identifies a local disk.
        public let diskId: String?
        /// The device node of a local disk as assigned by the virtualization environment.
        public let diskNode: String?
        /// The path of a local disk in the gateway virtual machine (VM).
        public let diskPath: String?
        /// The local disk size in bytes.
        public let diskSizeInBytes: Int64?
        /// A value that represents the status of a local disk.
        public let diskStatus: String?

        @inlinable
        public init(diskAllocationResource: String? = nil, diskAllocationType: String? = nil, diskAttributeList: [String]? = nil, diskId: String? = nil, diskNode: String? = nil, diskPath: String? = nil, diskSizeInBytes: Int64? = nil, diskStatus: String? = nil) {
            self.diskAllocationResource = diskAllocationResource
            self.diskAllocationType = diskAllocationType
            self.diskAttributeList = diskAttributeList
            self.diskId = diskId
            self.diskNode = diskNode
            self.diskPath = diskPath
            self.diskSizeInBytes = diskSizeInBytes
            self.diskStatus = diskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case diskAllocationResource = "DiskAllocationResource"
            case diskAllocationType = "DiskAllocationType"
            case diskAttributeList = "DiskAttributeList"
            case diskId = "DiskId"
            case diskNode = "DiskNode"
            case diskPath = "DiskPath"
            case diskSizeInBytes = "DiskSizeInBytes"
            case diskStatus = "DiskStatus"
        }
    }

    public struct EndpointNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of gateway IP addresses on which the associated Amazon FSx file system is available.  If multiple file systems are associated with this gateway, this field is required.
        public let ipAddresses: [String]?

        @inlinable
        public init(ipAddresses: [String]? = nil) {
            self.ipAddresses = ipAddresses
        }

        public func validate(name: String) throws {
            try self.ipAddresses?.forEach {
                try validate($0, name: "ipAddresses[]", parent: name, max: 15)
                try validate($0, name: "ipAddresses[]", parent: name, min: 7)
                try validate($0, name: "ipAddresses[]", parent: name, pattern: "^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\\.(?!$)|$)){4}$")
            }
            try self.validate(self.ipAddresses, name: "ipAddresses", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddresses = "IpAddresses"
        }
    }

    public struct EvictFilesFailingUploadInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the file share for which you want to start the cache clean operation.
        public let fileShareARN: String
        /// Specifies whether cache entries with full or partial file data currently stored on the gateway will be forcibly removed by the cache clean operation. Valid arguments:    False - The cache clean operation skips cache entries failing upload if they are associated with data currently stored on the gateway. This preserves the cached data.    True - The cache clean operation removes cache entries failing upload even if they are associated with data currently stored on the gateway. This deletes the cached data.  If ForceRemove is set to True, the cache clean operation will delete file data from the gateway which might otherwise be recoverable.
        public let forceRemove: Bool?

        @inlinable
        public init(fileShareARN: String, forceRemove: Bool? = nil) {
            self.fileShareARN = fileShareARN
            self.forceRemove = forceRemove
        }

        public func validate(name: String) throws {
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
            case forceRemove = "ForceRemove"
        }
    }

    public struct EvictFilesFailingUploadOutput: AWSDecodableShape {
        /// The randomly generated ID of the CloudWatch notification associated with the cache clean operation. This ID is in UUID format.
        public let notificationId: String?

        @inlinable
        public init(notificationId: String? = nil) {
            self.notificationId = notificationId
        }

        private enum CodingKeys: String, CodingKey {
            case notificationId = "NotificationId"
        }
    }

    public struct FileShareInfo: AWSDecodableShape {
        public let fileShareARN: String?
        public let fileShareId: String?
        public let fileShareStatus: String?
        public let fileShareType: FileShareType?
        public let gatewayARN: String?

        @inlinable
        public init(fileShareARN: String? = nil, fileShareId: String? = nil, fileShareStatus: String? = nil, fileShareType: FileShareType? = nil, gatewayARN: String? = nil) {
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareStatus = fileShareStatus
            self.fileShareType = fileShareType
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
            case fileShareId = "FileShareId"
            case fileShareStatus = "FileShareStatus"
            case fileShareType = "FileShareType"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct FileSystemAssociationInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
        public let auditDestinationARN: String?
        public let cacheAttributes: CacheAttributes?
        /// Specifies network configuration information for the gateway associated with the Amazon FSx file system.  If multiple file systems are associated with this gateway, this parameter's IpAddresses field is required.
        public let endpointNetworkConfiguration: EndpointNetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the file system association.
        public let fileSystemAssociationARN: String?
        /// The status of the file system association. Valid Values: AVAILABLE | CREATING | DELETING | FORCE_DELETING | UPDATING | ERROR
        public let fileSystemAssociationStatus: String?
        /// An array containing the FileSystemAssociationStatusDetail data type, which provides detailed information on file system association status.
        public let fileSystemAssociationStatusDetails: [FileSystemAssociationStatusDetail]?
        public let gatewayARN: String?
        /// The ARN of the backend Amazon FSx file system used for storing file data. For information, see FileSystem in the Amazon FSx API Reference.
        public let locationARN: String?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, endpointNetworkConfiguration: EndpointNetworkConfiguration? = nil, fileSystemAssociationARN: String? = nil, fileSystemAssociationStatus: String? = nil, fileSystemAssociationStatusDetails: [FileSystemAssociationStatusDetail]? = nil, gatewayARN: String? = nil, locationARN: String? = nil, tags: [Tag]? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.endpointNetworkConfiguration = endpointNetworkConfiguration
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.fileSystemAssociationStatusDetails = fileSystemAssociationStatusDetails
            self.gatewayARN = gatewayARN
            self.locationARN = locationARN
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case auditDestinationARN = "AuditDestinationARN"
            case cacheAttributes = "CacheAttributes"
            case endpointNetworkConfiguration = "EndpointNetworkConfiguration"
            case fileSystemAssociationARN = "FileSystemAssociationARN"
            case fileSystemAssociationStatus = "FileSystemAssociationStatus"
            case fileSystemAssociationStatusDetails = "FileSystemAssociationStatusDetails"
            case gatewayARN = "GatewayARN"
            case locationARN = "LocationARN"
            case tags = "Tags"
        }
    }

    public struct FileSystemAssociationStatusDetail: AWSDecodableShape {
        /// The error code for a given file system association status.
        public let errorCode: String?

        @inlinable
        public init(errorCode: String? = nil) {
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
        }
    }

    public struct FileSystemAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the file system association.
        public let fileSystemAssociationARN: String?
        /// The ID of the file system association.
        public let fileSystemAssociationId: String?
        /// The status of the file share. Valid Values: AVAILABLE | CREATING | DELETING | FORCE_DELETING | UPDATING | ERROR
        public let fileSystemAssociationStatus: String?
        public let gatewayARN: String?

        @inlinable
        public init(fileSystemAssociationARN: String? = nil, fileSystemAssociationId: String? = nil, fileSystemAssociationStatus: String? = nil, gatewayARN: String? = nil) {
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.fileSystemAssociationId = fileSystemAssociationId
            self.fileSystemAssociationStatus = fileSystemAssociationStatus
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationARN = "FileSystemAssociationARN"
            case fileSystemAssociationId = "FileSystemAssociationId"
            case fileSystemAssociationStatus = "FileSystemAssociationStatus"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct GatewayInfo: AWSDecodableShape {
        /// Date after which this gateway will not receive software updates for new features and bug fixes.
        public let deprecationDate: String?
        /// The ID of the Amazon EC2 instance that was used to launch the gateway.
        public let ec2InstanceId: String?
        /// The Amazon Web Services Region where the Amazon EC2 instance is located.
        public let ec2InstanceRegion: String?
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public let gatewayARN: String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations.
        public let gatewayId: String?
        /// The name of the gateway.
        public let gatewayName: String?
        /// The state of the gateway. Valid Values: DISABLED | ACTIVE
        public let gatewayOperationalState: String?
        /// The type of the gateway.  Amazon FSx File Gateway is no longer available to new customers. Existing customers of FSx File Gateway can continue to use the service normally. For capabilities similar to FSx File Gateway, visit this blog post.
        public let gatewayType: String?
        /// The type of hardware or software platform on which the gateway is running.  Tape Gateway is no longer available on Snow Family devices.
        public let hostEnvironment: HostEnvironment?
        /// A unique identifier for the specific instance of the host platform running the gateway. This value is only available for certain host environments, and its format depends on the host environment type.
        public let hostEnvironmentId: String?
        /// The version number of the software running on the gateway appliance.
        public let softwareVersion: String?

        @inlinable
        public init(deprecationDate: String? = nil, ec2InstanceId: String? = nil, ec2InstanceRegion: String? = nil, gatewayARN: String? = nil, gatewayId: String? = nil, gatewayName: String? = nil, gatewayOperationalState: String? = nil, gatewayType: String? = nil, hostEnvironment: HostEnvironment? = nil, hostEnvironmentId: String? = nil, softwareVersion: String? = nil) {
            self.deprecationDate = deprecationDate
            self.ec2InstanceId = ec2InstanceId
            self.ec2InstanceRegion = ec2InstanceRegion
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayOperationalState = gatewayOperationalState
            self.gatewayType = gatewayType
            self.hostEnvironment = hostEnvironment
            self.hostEnvironmentId = hostEnvironmentId
            self.softwareVersion = softwareVersion
        }

        private enum CodingKeys: String, CodingKey {
            case deprecationDate = "DeprecationDate"
            case ec2InstanceId = "Ec2InstanceId"
            case ec2InstanceRegion = "Ec2InstanceRegion"
            case gatewayARN = "GatewayARN"
            case gatewayId = "GatewayId"
            case gatewayName = "GatewayName"
            case gatewayOperationalState = "GatewayOperationalState"
            case gatewayType = "GatewayType"
            case hostEnvironment = "HostEnvironment"
            case hostEnvironmentId = "HostEnvironmentId"
            case softwareVersion = "SoftwareVersion"
        }
    }

    public struct InternalServerError: AWSErrorShape {
        /// A StorageGatewayError that provides more information about the cause of the error.
        public let error: StorageGatewayError?
        /// A human-readable message describing the error that occurred.
        public let message: String?

        @inlinable
        public init(error: StorageGatewayError? = nil, message: String? = nil) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct InvalidGatewayRequestException: AWSErrorShape {
        /// A StorageGatewayError that provides more detail about the cause of the error.
        public let error: StorageGatewayError?
        /// A human-readable message describing the error that occurred.
        public let message: String?

        @inlinable
        public init(error: StorageGatewayError? = nil, message: String? = nil) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct JoinDomainInput: AWSEncodableShape {
        /// List of IPv4 addresses, NetBIOS names, or host names of your domain server. If you need to specify the port number include it after the colon (â€œ:â€). For example, mydc.mydomain.com:389.
        public let domainControllers: [String]?
        /// The name of the domain that you want the gateway to join.
        public let domainName: String
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public let gatewayARN: String
        /// The organizational unit (OU) is a container in an Active Directory that can hold users, groups, computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
        public let organizationalUnit: String?
        /// Sets the password of the user who has permission to add the gateway to the Active Directory domain.
        public let password: String
        /// Specifies the time in seconds, in which the JoinDomain operation must complete. The default is 20 seconds.
        public let timeoutInSeconds: Int?
        /// Sets the user name of user who has permission to add the gateway to the Active Directory domain. The domain user account should be enabled to join computers to the domain. For example, you can use the domain administrator account or an account with delegated permissions to join computers to the domain.
        public let userName: String

        @inlinable
        public init(domainControllers: [String]? = nil, domainName: String, gatewayARN: String, organizationalUnit: String? = nil, password: String, timeoutInSeconds: Int? = nil, userName: String) {
            self.domainControllers = domainControllers
            self.domainName = domainName
            self.gatewayARN = gatewayARN
            self.organizationalUnit = organizationalUnit
            self.password = password
            self.timeoutInSeconds = timeoutInSeconds
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.domainControllers?.forEach {
                try validate($0, name: "domainControllers[]", parent: name, max: 1024)
                try validate($0, name: "domainControllers[]", parent: name, min: 6)
                try validate($0, name: "domainControllers[]", parent: name, pattern: "^(([a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9\\-]*[A-Za-z0-9])(:(\\d+))?$")
            }
            try self.validate(self.domainName, name: "domainName", parent: name, max: 1024)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^([a-zA-Z0-9]+[\\\\.-])+([a-zA-Z0-9])+$")
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.organizationalUnit, name: "organizationalUnit", parent: name, max: 1024)
            try self.validate(self.organizationalUnit, name: "organizationalUnit", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, max: 3600)
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, min: 0)
            try self.validate(self.userName, name: "userName", parent: name, max: 1024)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^\\w[\\w\\.\\- ]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainControllers = "DomainControllers"
            case domainName = "DomainName"
            case gatewayARN = "GatewayARN"
            case organizationalUnit = "OrganizationalUnit"
            case password = "Password"
            case timeoutInSeconds = "TimeoutInSeconds"
            case userName = "UserName"
        }
    }

    public struct JoinDomainOutput: AWSDecodableShape {
        /// Indicates the status of the gateway as a member of the Active Directory domain.  This field is only used as part of a JoinDomain request. It is not affected by Active Directory connectivity changes that occur after the JoinDomain request succeeds.     ACCESS_DENIED: Indicates that the JoinDomain operation failed due to an authentication error.    DETACHED: Indicates that gateway is not joined to a domain.    JOINED: Indicates that the gateway has successfully joined a domain.    JOINING: Indicates that a JoinDomain operation is in progress.    INSUFFICIENT_PERMISSIONS: Indicates that the JoinDomain operation failed because the specified user lacks the necessary permissions to join the domain.    NETWORK_ERROR: Indicates that JoinDomain operation failed due to a network or connectivity error.    TIMEOUT: Indicates that the JoinDomain operation failed because the operation didn't complete within the allotted time.    UNKNOWN_ERROR: Indicates that the JoinDomain operation failed due to another type of error.
        public let activeDirectoryStatus: ActiveDirectoryStatus?
        /// The unique Amazon Resource Name (ARN) of the gateway that joined the domain.
        public let gatewayARN: String?

        @inlinable
        public init(activeDirectoryStatus: ActiveDirectoryStatus? = nil, gatewayARN: String? = nil) {
            self.activeDirectoryStatus = activeDirectoryStatus
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryStatus = "ActiveDirectoryStatus"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ListAutomaticTapeCreationPoliciesInput: AWSEncodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ListAutomaticTapeCreationPoliciesOutput: AWSDecodableShape {
        /// Gets a listing of information about the gateway's automatic tape creation policies, including the automatic tape creation rules and the gateway that is using the policies.
        public let automaticTapeCreationPolicyInfos: [AutomaticTapeCreationPolicyInfo]?

        @inlinable
        public init(automaticTapeCreationPolicyInfos: [AutomaticTapeCreationPolicyInfo]? = nil) {
            self.automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfos
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTapeCreationPolicyInfos = "AutomaticTapeCreationPolicyInfos"
        }
    }

    public struct ListCacheReportsInput: AWSEncodableShape {
        /// Opaque pagination token returned from a previous ListCacheReports operation. If present, Marker specifies where to continue the list from after a previous call to ListCacheReports. Optional.
        public let marker: String?

        @inlinable
        public init(marker: String? = nil) {
            self.marker = marker
        }

        public func validate(name: String) throws {
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
        }
    }

    public struct ListCacheReportsOutput: AWSDecodableShape {
        /// A list of existing cache reports for all file shares associated with your Amazon Web Services account. This list includes all information provided by the DescribeCacheReport action, such as report status, completion progress, start time, end time, filters, and tags.
        public let cacheReportList: [CacheReportInfo]?
        /// If the request includes Marker, the response returns that value in this field.
        public let marker: String?

        @inlinable
        public init(cacheReportList: [CacheReportInfo]? = nil, marker: String? = nil) {
            self.cacheReportList = cacheReportList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportList = "CacheReportList"
            case marker = "Marker"
        }
    }

    public struct ListFileSharesInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the gateway whose file shares you want to list. If this field is not present, all file shares under your account are listed.
        public let gatewayARN: String?
        /// The maximum number of file shares to return in the response. The value must be an integer with a value greater than zero. Optional.
        public let limit: Int?
        /// Opaque pagination token returned from a previous ListFileShares operation. If present, Marker specifies where to continue the list from after a previous call to ListFileShares. Optional.
        public let marker: String?

        @inlinable
        public init(gatewayARN: String? = nil, limit: Int? = nil, marker: String? = nil) {
            self.gatewayARN = gatewayARN
            self.limit = limit
            self.marker = marker
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case limit = "Limit"
            case marker = "Marker"
        }
    }

    public struct ListFileSharesOutput: AWSDecodableShape {
        /// An array of information about the S3 File Gateway's file shares.
        public let fileShareInfoList: [FileShareInfo]?
        /// If the request includes Marker, the response returns that value in this field.
        public let marker: String?
        /// If a value is present, there are more file shares to return. In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file shares.
        public let nextMarker: String?

        @inlinable
        public init(fileShareInfoList: [FileShareInfo]? = nil, marker: String? = nil, nextMarker: String? = nil) {
            self.fileShareInfoList = fileShareInfoList
            self.marker = marker
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareInfoList = "FileShareInfoList"
            case marker = "Marker"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListFileSystemAssociationsInput: AWSEncodableShape {
        public let gatewayARN: String?
        /// The maximum number of file system associations to return in the response. If present, Limit must be an integer with a value greater than zero. Optional.
        public let limit: Int?
        /// Opaque pagination token returned from a previous ListFileSystemAssociations operation. If present, Marker specifies where to continue the list from after a previous call to ListFileSystemAssociations. Optional.
        public let marker: String?

        @inlinable
        public init(gatewayARN: String? = nil, limit: Int? = nil, marker: String? = nil) {
            self.gatewayARN = gatewayARN
            self.limit = limit
            self.marker = marker
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case limit = "Limit"
            case marker = "Marker"
        }
    }

    public struct ListFileSystemAssociationsOutput: AWSDecodableShape {
        /// An array of information about the Amazon FSx gateway's file system associations.
        public let fileSystemAssociationSummaryList: [FileSystemAssociationSummary]?
        /// If the request includes Marker, the response returns that value in this field.
        public let marker: String?
        /// If a value is present, there are more file system associations to return. In a subsequent request, use NextMarker as the value for Marker to retrieve the next set of file system associations.
        public let nextMarker: String?

        @inlinable
        public init(fileSystemAssociationSummaryList: [FileSystemAssociationSummary]? = nil, marker: String? = nil, nextMarker: String? = nil) {
            self.fileSystemAssociationSummaryList = fileSystemAssociationSummaryList
            self.marker = marker
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationSummaryList = "FileSystemAssociationSummaryList"
            case marker = "Marker"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListGatewaysInput: AWSEncodableShape {
        /// Specifies that the list of gateways returned be limited to the specified number of items.
        public let limit: Int?
        /// An opaque string that indicates the position at which to begin the returned list of gateways.
        public let marker: String?

        @inlinable
        public init(limit: Int? = nil, marker: String? = nil) {
            self.limit = limit
            self.marker = marker
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case marker = "Marker"
        }
    }

    public struct ListGatewaysOutput: AWSDecodableShape {
        /// An array of GatewayInfo objects.
        public let gateways: [GatewayInfo]?
        /// Use the marker in your next request to fetch the next set of gateways in the list. If there are no more gateways to list, this field does not appear in the response.
        public let marker: String?

        @inlinable
        public init(gateways: [GatewayInfo]? = nil, marker: String? = nil) {
            self.gateways = gateways
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case gateways = "Gateways"
            case marker = "Marker"
        }
    }

    public struct ListLocalDisksInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ListLocalDisksOutput: AWSDecodableShape {
        /// A JSON object containing the following fields:    ListLocalDisksOutput$Disks
        public let disks: [Disk]?
        public let gatewayARN: String?

        @inlinable
        public init(disks: [Disk]? = nil, gatewayARN: String? = nil) {
            self.disks = disks
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case disks = "Disks"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// Specifies that the list of tags returned be limited to the specified number of items.
        public let limit: Int?
        /// An opaque string that indicates the position at which to begin returning the list of tags.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceARN: String

        @inlinable
        public init(limit: Int? = nil, marker: String? = nil, resourceARN: String) {
            self.limit = limit
            self.marker = marker
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case marker = "Marker"
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// An opaque string that indicates the position at which to stop returning the list of tags.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceARN: String?
        /// An array that contains the tags for the specified resource.
        public let tags: [Tag]?

        @inlinable
        public init(marker: String? = nil, resourceARN: String? = nil, tags: [Tag]? = nil) {
            self.marker = marker
            self.resourceARN = resourceARN
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct ListTapePoolsInput: AWSEncodableShape {
        /// An optional number limit for the tape pools in the list returned by this call.
        public let limit: Int?
        /// A string that indicates the position at which to begin the returned list of tape pools.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of each of the custom tape pools you want to list. If you don't specify a custom tape pool ARN, the response lists all custom tape pools.
        public let poolARNs: [String]?

        @inlinable
        public init(limit: Int? = nil, marker: String? = nil, poolARNs: [String]? = nil) {
            self.limit = limit
            self.marker = marker
            self.poolARNs = poolARNs
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.poolARNs?.forEach {
                try validate($0, name: "poolARNs[]", parent: name, max: 500)
                try validate($0, name: "poolARNs[]", parent: name, min: 50)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case marker = "Marker"
            case poolARNs = "PoolARNs"
        }
    }

    public struct ListTapePoolsOutput: AWSDecodableShape {
        /// A string that indicates the position at which to begin the returned list of tape pools. Use the marker in your next request to continue pagination of tape pools. If there are no more tape pools to list, this element does not appear in the response body.
        public let marker: String?
        /// An array of PoolInfo objects, where each object describes a single custom tape pool. If there are no custom tape pools, the PoolInfos is an empty array.
        public let poolInfos: [PoolInfo]?

        @inlinable
        public init(marker: String? = nil, poolInfos: [PoolInfo]? = nil) {
            self.marker = marker
            self.poolInfos = poolInfos
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case poolInfos = "PoolInfos"
        }
    }

    public struct ListTapesInput: AWSEncodableShape {
        /// An optional number limit for the tapes in the list returned by this call.
        public let limit: Int?
        /// A string that indicates the position at which to begin the returned list of tapes.
        public let marker: String?
        public let tapeARNs: [String]?

        @inlinable
        public init(limit: Int? = nil, marker: String? = nil, tapeARNs: [String]? = nil) {
            self.limit = limit
            self.marker = marker
            self.tapeARNs = tapeARNs
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.tapeARNs?.forEach {
                try validate($0, name: "tapeARNs[]", parent: name, max: 500)
                try validate($0, name: "tapeARNs[]", parent: name, min: 50)
                try validate($0, name: "tapeARNs[]", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case marker = "Marker"
            case tapeARNs = "TapeARNs"
        }
    }

    public struct ListTapesOutput: AWSDecodableShape {
        /// A string that indicates the position at which to begin returning the next list of tapes. Use the marker in your next request to continue pagination of tapes. If there are no more tapes to list, this element does not appear in the response body.
        public let marker: String?
        public let tapeInfos: [TapeInfo]?

        @inlinable
        public init(marker: String? = nil, tapeInfos: [TapeInfo]? = nil) {
            self.marker = marker
            self.tapeInfos = tapeInfos
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case tapeInfos = "TapeInfos"
        }
    }

    public struct ListVolumeInitiatorsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes operation to return a list of gateway volumes for the gateway.
        public let volumeARN: String

        @inlinable
        public init(volumeARN: String) {
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct ListVolumeInitiatorsOutput: AWSDecodableShape {
        /// The host names and port numbers of all iSCSI initiators that are connected to the gateway.
        public let initiators: [String]?

        @inlinable
        public init(initiators: [String]? = nil) {
            self.initiators = initiators
        }

        private enum CodingKeys: String, CodingKey {
            case initiators = "Initiators"
        }
    }

    public struct ListVolumeRecoveryPointsInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ListVolumeRecoveryPointsOutput: AWSDecodableShape {
        public let gatewayARN: String?
        /// An array of VolumeRecoveryPointInfo objects.
        public let volumeRecoveryPointInfos: [VolumeRecoveryPointInfo]?

        @inlinable
        public init(gatewayARN: String? = nil, volumeRecoveryPointInfos: [VolumeRecoveryPointInfo]? = nil) {
            self.gatewayARN = gatewayARN
            self.volumeRecoveryPointInfos = volumeRecoveryPointInfos
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case volumeRecoveryPointInfos = "VolumeRecoveryPointInfos"
        }
    }

    public struct ListVolumesInput: AWSEncodableShape {
        public let gatewayARN: String?
        /// Specifies that the list of volumes returned be limited to the specified number of items.
        public let limit: Int?
        /// A string that indicates the position at which to begin the returned list of volumes. Obtain the marker from the response of a previous List iSCSI Volumes request.
        public let marker: String?

        @inlinable
        public init(gatewayARN: String? = nil, limit: Int? = nil, marker: String? = nil) {
            self.gatewayARN = gatewayARN
            self.limit = limit
            self.marker = marker
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2000)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case limit = "Limit"
            case marker = "Marker"
        }
    }

    public struct ListVolumesOutput: AWSDecodableShape {
        public let gatewayARN: String?
        /// Use the marker in your next request to continue pagination of iSCSI volumes. If there are no more volumes to list, this field does not appear in the response body.
        public let marker: String?
        /// An array of VolumeInfo objects, where each object describes an iSCSI volume. If no volumes are defined for the gateway, then VolumeInfos is an empty array "[]".
        public let volumeInfos: [VolumeInfo]?

        @inlinable
        public init(gatewayARN: String? = nil, marker: String? = nil, volumeInfos: [VolumeInfo]? = nil) {
            self.gatewayARN = gatewayARN
            self.marker = marker
            self.volumeInfos = volumeInfos
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case marker = "Marker"
            case volumeInfos = "VolumeInfos"
        }
    }

    public struct NFSFileShareDefaults: AWSEncodableShape & AWSDecodableShape {
        /// The Unix directory mode in the form "nnnn". For example, 0666 represents the default access mode for all directories inside the file share. The default value is 0777.
        public let directoryMode: String?
        /// The Unix file mode in the form "nnnn". For example, 0666 represents the default file mode inside the file share. The default value is 0666.
        public let fileMode: String?
        /// The default group ID for the file share (unless the files have another group ID specified). The default value is nfsnobody.
        public let groupId: Int64?
        /// The default owner ID for files in the file share (unless the files have another owner ID specified). The default value is nfsnobody.
        public let ownerId: Int64?

        @inlinable
        public init(directoryMode: String? = nil, fileMode: String? = nil, groupId: Int64? = nil, ownerId: Int64? = nil) {
            self.directoryMode = directoryMode
            self.fileMode = fileMode
            self.groupId = groupId
            self.ownerId = ownerId
        }

        public func validate(name: String) throws {
            try self.validate(self.directoryMode, name: "directoryMode", parent: name, max: 4)
            try self.validate(self.directoryMode, name: "directoryMode", parent: name, min: 1)
            try self.validate(self.directoryMode, name: "directoryMode", parent: name, pattern: "^[0-7]{4}$")
            try self.validate(self.fileMode, name: "fileMode", parent: name, max: 4)
            try self.validate(self.fileMode, name: "fileMode", parent: name, min: 1)
            try self.validate(self.fileMode, name: "fileMode", parent: name, pattern: "^[0-7]{4}$")
            try self.validate(self.groupId, name: "groupId", parent: name, max: 4294967294)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 0)
            try self.validate(self.ownerId, name: "ownerId", parent: name, max: 4294967294)
            try self.validate(self.ownerId, name: "ownerId", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case directoryMode = "DirectoryMode"
            case fileMode = "FileMode"
            case groupId = "GroupId"
            case ownerId = "OwnerId"
        }
    }

    public struct NFSFileShareInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public let auditDestinationARN: String?
        /// Specifies the Region of the S3 bucket where the NFS file share stores files.  This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let bucketRegion: String?
        /// Refresh cache information for the file share.
        public let cacheAttributes: CacheAttributes?
        public let clientList: [String]?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public let defaultStorageClass: String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public let encryptionType: EncryptionType?
        public let fileShareARN: String?
        public let fileShareId: String?
        /// The name of the file share. Optional.   FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
        public let fileShareName: String?
        public let fileShareStatus: String?
        public let gatewayARN: String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public let guessMIMETypeEnabled: Bool?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.  Valid Values: true | false
        public let kmsEncrypted: Bool?
        public let kmsKey: String?
        public let locationARN: String?
        public let nfsFileShareDefaults: NFSFileShareDefaults?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period.   SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications.  The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60.  {\"Upload\": {\"SettlingTimeInSeconds\": 60}}  The following example sets NotificationPolicy off.  {}
        public let notificationPolicy: String?
        public let objectACL: ObjectACL?
        public let path: String?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public let readOnly: Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data.   RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration.  Valid Values: true | false
        public let requesterPays: Bool?
        public let role: String?
        public let squash: String?
        /// A list of up to 50 tags assigned to the NFS file share, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public let tags: [Tag]?
        /// Specifies the DNS name for the VPC endpoint that the NFS file share uses to connect to Amazon S3.  This parameter is required for NFS file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let vpcEndpointDNSName: String?

        @inlinable
        public init(auditDestinationARN: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, clientList: [String]? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String? = nil, fileShareId: String? = nil, fileShareName: String? = nil, fileShareStatus: String? = nil, gatewayARN: String? = nil, guessMIMETypeEnabled: Bool? = nil, kmsKey: String? = nil, locationARN: String? = nil, nfsFileShareDefaults: NFSFileShareDefaults? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, path: String? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String? = nil, squash: String? = nil, tags: [Tag]? = nil, vpcEndpointDNSName: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = nil
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        @available(*, deprecated, message: "Members kmsEncrypted have been deprecated")
        @inlinable
        public init(auditDestinationARN: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, clientList: [String]? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String? = nil, fileShareId: String? = nil, fileShareName: String? = nil, fileShareStatus: String? = nil, gatewayARN: String? = nil, guessMIMETypeEnabled: Bool? = nil, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, locationARN: String? = nil, nfsFileShareDefaults: NFSFileShareDefaults? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, path: String? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String? = nil, squash: String? = nil, tags: [Tag]? = nil, vpcEndpointDNSName: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.squash = squash
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        private enum CodingKeys: String, CodingKey {
            case auditDestinationARN = "AuditDestinationARN"
            case bucketRegion = "BucketRegion"
            case cacheAttributes = "CacheAttributes"
            case clientList = "ClientList"
            case defaultStorageClass = "DefaultStorageClass"
            case encryptionType = "EncryptionType"
            case fileShareARN = "FileShareARN"
            case fileShareId = "FileShareId"
            case fileShareName = "FileShareName"
            case fileShareStatus = "FileShareStatus"
            case gatewayARN = "GatewayARN"
            case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case locationARN = "LocationARN"
            case nfsFileShareDefaults = "NFSFileShareDefaults"
            case notificationPolicy = "NotificationPolicy"
            case objectACL = "ObjectACL"
            case path = "Path"
            case readOnly = "ReadOnly"
            case requesterPays = "RequesterPays"
            case role = "Role"
            case squash = "Squash"
            case tags = "Tags"
            case vpcEndpointDNSName = "VPCEndpointDNSName"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// The Internet Protocol version 4 (IPv4) address of the interface.
        public let ipv4Address: String?
        /// The Internet Protocol version 6 (IPv6) address of the interface. Currently not supported.
        public let ipv6Address: String?
        /// The Media Access Control (MAC) address of the interface.  This is currently unsupported and will not be returned in output.
        public let macAddress: String?

        @inlinable
        public init(ipv4Address: String? = nil, ipv6Address: String? = nil, macAddress: String? = nil) {
            self.ipv4Address = ipv4Address
            self.ipv6Address = ipv6Address
            self.macAddress = macAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ipv4Address = "Ipv4Address"
            case ipv6Address = "Ipv6Address"
            case macAddress = "MacAddress"
        }
    }

    public struct NotifyWhenUploadedInput: AWSEncodableShape {
        public let fileShareARN: String

        @inlinable
        public init(fileShareARN: String) {
            self.fileShareARN = fileShareARN
        }

        public func validate(name: String) throws {
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
        }
    }

    public struct NotifyWhenUploadedOutput: AWSDecodableShape {
        public let fileShareARN: String?
        public let notificationId: String?

        @inlinable
        public init(fileShareARN: String? = nil, notificationId: String? = nil) {
            self.fileShareARN = fileShareARN
            self.notificationId = notificationId
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
            case notificationId = "NotificationId"
        }
    }

    public struct PoolInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom tape pool. Use the ListTapePools operation to return a list of custom tape pools for your account and Amazon Web Services Region.
        public let poolARN: String?
        /// The name of the custom tape pool. PoolName can use all ASCII characters, except '/' and '\'.
        public let poolName: String?
        /// Status of the custom tape pool. Pool can be ACTIVE or DELETED.
        public let poolStatus: PoolStatus?
        /// Tape retention lock time is set in days. Tape retention lock can be enabled for up to 100 years (36,500 days).
        public let retentionLockTimeInDays: Int?
        /// Tape retention lock type, which can be configured in two modes. When configured in governance mode, Amazon Web Services accounts with specific IAM permissions are authorized to remove the tape retention lock from archived virtual tapes. When configured in compliance mode, the tape retention lock cannot be removed by any user, including the root Amazon Web Services account.
        public let retentionLockType: RetentionLockType?
        /// The storage class that is associated with the custom pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let storageClass: TapeStorageClass?

        @inlinable
        public init(poolARN: String? = nil, poolName: String? = nil, poolStatus: PoolStatus? = nil, retentionLockTimeInDays: Int? = nil, retentionLockType: RetentionLockType? = nil, storageClass: TapeStorageClass? = nil) {
            self.poolARN = poolARN
            self.poolName = poolName
            self.poolStatus = poolStatus
            self.retentionLockTimeInDays = retentionLockTimeInDays
            self.retentionLockType = retentionLockType
            self.storageClass = storageClass
        }

        private enum CodingKeys: String, CodingKey {
            case poolARN = "PoolARN"
            case poolName = "PoolName"
            case poolStatus = "PoolStatus"
            case retentionLockTimeInDays = "RetentionLockTimeInDays"
            case retentionLockType = "RetentionLockType"
            case storageClass = "StorageClass"
        }
    }

    public struct RefreshCacheInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the file share you want to refresh.
        public let fileShareARN: String
        /// A comma-separated list of the paths of folders to refresh in the cache. The default is ["/"]. The default refreshes objects and folders at the root of the Amazon S3 bucket. If Recursive is set to true, the entire S3 bucket that the file share has access to is refreshed. Do not include / when specifying folder names. For example, you would specify samplefolder rather than samplefolder/.
        public let folderList: [String]?
        /// A value that specifies whether to recursively refresh folders in the cache. The refresh includes folders that were in the cache the last time the gateway listed the folder's contents. If this value set to true, each folder that is listed in FolderList is recursively updated. Otherwise, subfolders listed in FolderList are not refreshed. Only objects that are in folders listed directly under FolderList are found and used for the update. The default is true. Valid Values: true | false
        public let recursive: Bool?

        @inlinable
        public init(fileShareARN: String, folderList: [String]? = nil, recursive: Bool? = nil) {
            self.fileShareARN = fileShareARN
            self.folderList = folderList
            self.recursive = recursive
        }

        public func validate(name: String) throws {
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
            try self.folderList?.forEach {
                try validate($0, name: "folderList[]", parent: name, max: 1024)
                try validate($0, name: "folderList[]", parent: name, min: 1)
            }
            try self.validate(self.folderList, name: "folderList", parent: name, max: 50)
            try self.validate(self.folderList, name: "folderList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
            case folderList = "FolderList"
            case recursive = "Recursive"
        }
    }

    public struct RefreshCacheOutput: AWSDecodableShape {
        public let fileShareARN: String?
        public let notificationId: String?

        @inlinable
        public init(fileShareARN: String? = nil, notificationId: String? = nil) {
            self.fileShareARN = fileShareARN
            self.notificationId = notificationId
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
            case notificationId = "NotificationId"
        }
    }

    public struct RemoveTagsFromResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to remove the tags from.
        public let resourceARN: String
        /// The keys of the tags you want to remove from the specified resource. A tag is composed of a key-value pair.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 500)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 50)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct RemoveTagsFromResourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource that the tags were removed from.
        public let resourceARN: String?

        @inlinable
        public init(resourceARN: String? = nil) {
            self.resourceARN = resourceARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ResetCacheInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ResetCacheOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct RetrieveTapeArchiveInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the gateway you want to retrieve the virtual tape to. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region. You retrieve archived virtual tapes to only one gateway and the gateway must be a tape gateway.
        public let gatewayARN: String
        /// The Amazon Resource Name (ARN) of the virtual tape you want to retrieve from the virtual tape shelf (VTS).
        public let tapeARN: String

        @inlinable
        public init(gatewayARN: String, tapeARN: String) {
            self.gatewayARN = gatewayARN
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case tapeARN = "TapeARN"
        }
    }

    public struct RetrieveTapeArchiveOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the retrieved virtual tape.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct RetrieveTapeRecoveryPointInput: AWSEncodableShape {
        public let gatewayARN: String
        /// The Amazon Resource Name (ARN) of the virtual tape for which you want to retrieve the recovery point.
        public let tapeARN: String

        @inlinable
        public init(gatewayARN: String, tapeARN: String) {
            self.gatewayARN = gatewayARN
            self.tapeARN = tapeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, max: 500)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, min: 50)
            try self.validate(self.tapeARN, name: "tapeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:tape\\/[0-9A-Z]{5,16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case tapeARN = "TapeARN"
        }
    }

    public struct RetrieveTapeRecoveryPointOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the virtual tape for which the recovery point was retrieved.
        public let tapeARN: String?

        @inlinable
        public init(tapeARN: String? = nil) {
            self.tapeARN = tapeARN
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
        }
    }

    public struct SMBFileShareInfo: AWSDecodableShape {
        /// Indicates whether AccessBasedEnumeration is enabled.
        public let accessBasedEnumeration: Bool?
        /// A list of users or groups in the Active Directory that have administrator rights to the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let adminUserList: [String]?
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public let auditDestinationARN: String?
        public let authentication: String?
        /// Specifies the Region of the S3 bucket where the SMB file share stores files.  This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let bucketRegion: String?
        /// Refresh cache information for the file share.
        public let cacheAttributes: CacheAttributes?
        /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
        public let caseSensitivity: CaseSensitivity?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public let defaultStorageClass: String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public let encryptionType: EncryptionType?
        public let fileShareARN: String?
        public let fileShareId: String?
        /// The name of the file share. Optional.   FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used.
        public let fileShareName: String?
        public let fileShareStatus: String?
        public let gatewayARN: String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public let guessMIMETypeEnabled: Bool?
        /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let invalidUserList: [String]?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.  Valid Values: true | false
        public let kmsEncrypted: Bool?
        public let kmsKey: String?
        public let locationARN: String?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period.   SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications.  The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60.  {\"Upload\": {\"SettlingTimeInSeconds\": 60}}  The following example sets NotificationPolicy off.  {}
        public let notificationPolicy: String?
        public let objectACL: ObjectACL?
        /// Specifies whether opportunistic locking is enabled for the SMB file share.  Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case.  Valid Values: true | false
        public let oplocksEnabled: Bool?
        /// The file share path used by the SMB client to identify the mount point.
        public let path: String?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public let readOnly: Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data.   RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration.  Valid Values: true | false
        public let requesterPays: Bool?
        public let role: String?
        /// If this value is set to true, it indicates that access control list (ACL) is enabled on the SMB file share. If it is set to false, it indicates that file and directory permissions are mapped to the POSIX permission. For more information, see Using Windows ACLs to limit SMB file share access in the Amazon S3 File Gateway User Guide.
        public let smbaclEnabled: Bool?
        /// A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all tags using the ListTagsForResource API operation.
        public let tags: [Tag]?
        /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let validUserList: [String]?
        /// Specifies the DNS name for the VPC endpoint that the SMB file share uses to connect to Amazon S3.  This parameter is required for SMB file shares that connect to Amazon S3 through a VPC endpoint, a VPC access point, or an access point alias that points to a VPC access point.
        public let vpcEndpointDNSName: String?

        @inlinable
        public init(accessBasedEnumeration: Bool? = nil, adminUserList: [String]? = nil, auditDestinationARN: String? = nil, authentication: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, caseSensitivity: CaseSensitivity? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String? = nil, fileShareId: String? = nil, fileShareName: String? = nil, fileShareStatus: String? = nil, gatewayARN: String? = nil, guessMIMETypeEnabled: Bool? = nil, invalidUserList: [String]? = nil, kmsKey: String? = nil, locationARN: String? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, oplocksEnabled: Bool? = nil, path: String? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String? = nil, smbaclEnabled: Bool? = nil, tags: [Tag]? = nil, validUserList: [String]? = nil, vpcEndpointDNSName: String? = nil) {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = nil
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.smbaclEnabled = smbaclEnabled
            self.tags = tags
            self.validUserList = validUserList
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        @available(*, deprecated, message: "Members kmsEncrypted have been deprecated")
        @inlinable
        public init(accessBasedEnumeration: Bool? = nil, adminUserList: [String]? = nil, auditDestinationARN: String? = nil, authentication: String? = nil, bucketRegion: String? = nil, cacheAttributes: CacheAttributes? = nil, caseSensitivity: CaseSensitivity? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String? = nil, fileShareId: String? = nil, fileShareName: String? = nil, fileShareStatus: String? = nil, gatewayARN: String? = nil, guessMIMETypeEnabled: Bool? = nil, invalidUserList: [String]? = nil, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, locationARN: String? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, oplocksEnabled: Bool? = nil, path: String? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, role: String? = nil, smbaclEnabled: Bool? = nil, tags: [Tag]? = nil, validUserList: [String]? = nil, vpcEndpointDNSName: String? = nil) {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.authentication = authentication
            self.bucketRegion = bucketRegion
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareId = fileShareId
            self.fileShareName = fileShareName
            self.fileShareStatus = fileShareStatus
            self.gatewayARN = gatewayARN
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.locationARN = locationARN
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.path = path
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.role = role
            self.smbaclEnabled = smbaclEnabled
            self.tags = tags
            self.validUserList = validUserList
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        private enum CodingKeys: String, CodingKey {
            case accessBasedEnumeration = "AccessBasedEnumeration"
            case adminUserList = "AdminUserList"
            case auditDestinationARN = "AuditDestinationARN"
            case authentication = "Authentication"
            case bucketRegion = "BucketRegion"
            case cacheAttributes = "CacheAttributes"
            case caseSensitivity = "CaseSensitivity"
            case defaultStorageClass = "DefaultStorageClass"
            case encryptionType = "EncryptionType"
            case fileShareARN = "FileShareARN"
            case fileShareId = "FileShareId"
            case fileShareName = "FileShareName"
            case fileShareStatus = "FileShareStatus"
            case gatewayARN = "GatewayARN"
            case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
            case invalidUserList = "InvalidUserList"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case locationARN = "LocationARN"
            case notificationPolicy = "NotificationPolicy"
            case objectACL = "ObjectACL"
            case oplocksEnabled = "OplocksEnabled"
            case path = "Path"
            case readOnly = "ReadOnly"
            case requesterPays = "RequesterPays"
            case role = "Role"
            case smbaclEnabled = "SMBACLEnabled"
            case tags = "Tags"
            case validUserList = "ValidUserList"
            case vpcEndpointDNSName = "VPCEndpointDNSName"
        }
    }

    public struct SMBLocalGroups: AWSEncodableShape & AWSDecodableShape {
        /// A list of Active Directory users and groups that have local Gateway Admin permissions. Acceptable formats include: DOMAIN\User1, user1, DOMAIN\group1, and group1. Gateway Admins can use the Shared Folders Microsoft Management Console snap-in to force-close files that are open and locked.
        public let gatewayAdmins: [String]?

        @inlinable
        public init(gatewayAdmins: [String]? = nil) {
            self.gatewayAdmins = gatewayAdmins
        }

        public func validate(name: String) throws {
            try self.gatewayAdmins?.forEach {
                try validate($0, name: "gatewayAdmins[]", parent: name, max: 64)
                try validate($0, name: "gatewayAdmins[]", parent: name, min: 1)
            }
            try self.validate(self.gatewayAdmins, name: "gatewayAdmins", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayAdmins = "GatewayAdmins"
        }
    }

    public struct ServiceUnavailableError: AWSErrorShape {
        /// A StorageGatewayError that provides more information about the cause of the error.
        public let error: StorageGatewayError?
        /// A human-readable message describing the error that occurred.
        public let message: String?

        @inlinable
        public init(error: StorageGatewayError? = nil, message: String? = nil) {
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case message = "message"
        }
    }

    public struct SetLocalConsolePasswordInput: AWSEncodableShape {
        public let gatewayARN: String
        /// The password you want to set for your VM local console.
        public let localConsolePassword: String

        @inlinable
        public init(gatewayARN: String, localConsolePassword: String) {
            self.gatewayARN = gatewayARN
            self.localConsolePassword = localConsolePassword
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.localConsolePassword, name: "localConsolePassword", parent: name, max: 512)
            try self.validate(self.localConsolePassword, name: "localConsolePassword", parent: name, min: 6)
            try self.validate(self.localConsolePassword, name: "localConsolePassword", parent: name, pattern: "^[ -~]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case localConsolePassword = "LocalConsolePassword"
        }
    }

    public struct SetLocalConsolePasswordOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct SetSMBGuestPasswordInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 File Gateway the SMB file share is associated with.
        public let gatewayARN: String
        /// The password that you want to set for your SMB server.
        public let password: String

        @inlinable
        public init(gatewayARN: String, password: String) {
            self.gatewayARN = gatewayARN
            self.password = password
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, min: 6)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[ -~]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case password = "Password"
        }
    }

    public struct SetSMBGuestPasswordOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ShutdownGatewayInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct ShutdownGatewayOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct SoftwareUpdatePreferences: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the automatic update policy for a gateway.  ALL_VERSIONS - Enables regular gateway maintenance updates.  EMERGENCY_VERSIONS_ONLY - Disables regular gateway maintenance updates. The gateway will still receive emergency version updates on rare occasions if necessary to remedy highly critical security or durability issues. You will be notified before an emergency version update is applied. These updates are applied during your gateway's scheduled maintenance window.
        public let automaticUpdatePolicy: AutomaticUpdatePolicy?

        @inlinable
        public init(automaticUpdatePolicy: AutomaticUpdatePolicy? = nil) {
            self.automaticUpdatePolicy = automaticUpdatePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case automaticUpdatePolicy = "AutomaticUpdatePolicy"
        }
    }

    public struct StartAvailabilityMonitorTestInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct StartAvailabilityMonitorTestOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct StartCacheReportInput: AWSEncodableShape {
        /// The Amazon Web Services Region of the Amazon S3 bucket where you want to save the cache report.
        public let bucketRegion: String
        /// A unique identifier that you use to ensure idempotent report generation if you need to retry an unsuccessful StartCacheReport request. If you retry a request, use the same ClientToken you specified in the initial request.
        public let clientToken: String
        /// The list of filters and parameters that determine which files are excluded from the report. You must specify at least one value for InclusionFilters or ExclusionFilters in a StartCacheReport request.
        public let exclusionFilters: [CacheReportFilter]?
        public let fileShareARN: String
        /// The list of filters and parameters that determine which files are included in the report. You must specify at least one value for InclusionFilters or ExclusionFilters in a StartCacheReport request.
        public let inclusionFilters: [CacheReportFilter]?
        /// The ARN of the Amazon S3 bucket where you want to save the cache report.  We do not recommend saving the cache report to the same Amazon S3 bucket for which you are generating the report. This field does not accept access point ARNs.
        public let locationARN: String
        /// The ARN of the IAM role used when saving the cache report to Amazon S3.
        public let role: String
        /// A list of up to 50 key/value tags that you can assign to the cache report. Using tags can help you categorize your reports and more easily locate them in search results.
        public let tags: [Tag]?
        /// The DNS name of the VPC endpoint associated with the Amazon S3 where you want to save the cache report. Optional.
        public let vpcEndpointDNSName: String?

        @inlinable
        public init(bucketRegion: String, clientToken: String, exclusionFilters: [CacheReportFilter]? = nil, fileShareARN: String, inclusionFilters: [CacheReportFilter]? = nil, locationARN: String, role: String, tags: [Tag]? = nil, vpcEndpointDNSName: String? = nil) {
            self.bucketRegion = bucketRegion
            self.clientToken = clientToken
            self.exclusionFilters = exclusionFilters
            self.fileShareARN = fileShareARN
            self.inclusionFilters = inclusionFilters
            self.locationARN = locationARN
            self.role = role
            self.tags = tags
            self.vpcEndpointDNSName = vpcEndpointDNSName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, max: 25)
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 5)
            try self.exclusionFilters?.forEach {
                try $0.validate(name: "\(name).exclusionFilters[]")
            }
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
            try self.inclusionFilters?.forEach {
                try $0.validate(name: "\(name).inclusionFilters[]")
            }
            try self.validate(self.locationARN, name: "locationARN", parent: name, max: 1400)
            try self.validate(self.locationARN, name: "locationARN", parent: name, min: 16)
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):iam::([0-9]+):role/(\\S+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, max: 255)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, min: 1)
            try self.validate(self.vpcEndpointDNSName, name: "vpcEndpointDNSName", parent: name, pattern: "^(([a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9\\-]*[A-Za-z0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketRegion = "BucketRegion"
            case clientToken = "ClientToken"
            case exclusionFilters = "ExclusionFilters"
            case fileShareARN = "FileShareARN"
            case inclusionFilters = "InclusionFilters"
            case locationARN = "LocationARN"
            case role = "Role"
            case tags = "Tags"
            case vpcEndpointDNSName = "VPCEndpointDNSName"
        }
    }

    public struct StartCacheReportOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cache report generated by the StartCacheReport request.
        public let cacheReportARN: String?

        @inlinable
        public init(cacheReportARN: String? = nil) {
            self.cacheReportARN = cacheReportARN
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReportARN = "CacheReportARN"
        }
    }

    public struct StartGatewayInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct StartGatewayOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct StorageGatewayError: AWSDecodableShape {
        /// Additional information about the error.
        public let errorCode: ErrorCode?
        /// Human-readable text that provides detail about the error that occurred.
        public let errorDetails: [String: String]?

        @inlinable
        public init(errorCode: ErrorCode? = nil, errorDetails: [String: String]? = nil) {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorDetails = "errorDetails"
        }
    }

    public struct StorediSCSIVolume: AWSDecodableShape {
        /// The date the volume was created. Volumes created prior to March 28, 2017 donâ€™t have this timestamp.
        public let createdDate: Date?
        public let kmsKey: String?
        /// Indicates if when the stored volume was created, existing data on the underlying local disk was preserved. Valid Values: true | false
        public let preservedExistingData: Bool?
        /// If the stored volume was created from a snapshot, this field contains the snapshot ID used, e.g. snap-78e22663. Otherwise, this field is not included.
        public let sourceSnapshotId: String?
        /// The name of the iSCSI target used by an initiator to connect to a volume and used as a suffix for the target ARN. For example, specifying TargetName as myvolume results in the target ARN of arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume. The target name must be unique across all volumes on a gateway. If you don't specify a value, Storage Gateway uses the value that was previously used for this volume as the new target name.
        public let targetName: String?
        /// The Amazon Resource Name (ARN) of the storage volume.
        public let volumeARN: String?
        /// A value that indicates whether a storage volume is attached to, detached from, or is in the process of detaching from a gateway. For more information, see Moving your volumes to a different gateway.
        public let volumeAttachmentStatus: String?
        /// The ID of the local disk that was specified in the CreateStorediSCSIVolume operation.
        public let volumeDiskId: String?
        /// The unique identifier of the volume, e.g., vol-AE4B946D.
        public let volumeId: String?
        /// An VolumeiSCSIAttributes object that represents a collection of iSCSI attributes for one stored volume.
        public let volumeiSCSIAttributes: VolumeiSCSIAttributes?
        /// Represents the percentage complete if the volume is restoring or bootstrapping that represents the percent of data transferred. This field does not appear in the response if the stored volume is not restoring or bootstrapping.
        public let volumeProgress: Double?
        /// The size of the volume in bytes.
        public let volumeSizeInBytes: Int64?
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public let volumeStatus: String?
        /// One of the VolumeType enumeration values describing the type of the volume.
        public let volumeType: String?
        /// The size of the data stored on the volume in bytes. This value is calculated based on the number of blocks that are touched, instead of the actual amount of data written. This value can be useful for sequential write patterns but less accurate for random write patterns. VolumeUsedInBytes is different from the compressed size of the volume, which is the value that is used to calculate your bill.  This value is not available for volumes created prior to May 13, 2015, until you store data on the volume.
        public let volumeUsedInBytes: Int64?

        @inlinable
        public init(createdDate: Date? = nil, kmsKey: String? = nil, preservedExistingData: Bool? = nil, sourceSnapshotId: String? = nil, targetName: String? = nil, volumeARN: String? = nil, volumeAttachmentStatus: String? = nil, volumeDiskId: String? = nil, volumeId: String? = nil, volumeiSCSIAttributes: VolumeiSCSIAttributes? = nil, volumeProgress: Double? = nil, volumeSizeInBytes: Int64? = nil, volumeStatus: String? = nil, volumeType: String? = nil, volumeUsedInBytes: Int64? = nil) {
            self.createdDate = createdDate
            self.kmsKey = kmsKey
            self.preservedExistingData = preservedExistingData
            self.sourceSnapshotId = sourceSnapshotId
            self.targetName = targetName
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeDiskId = volumeDiskId
            self.volumeId = volumeId
            self.volumeiSCSIAttributes = volumeiSCSIAttributes
            self.volumeProgress = volumeProgress
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeStatus = volumeStatus
            self.volumeType = volumeType
            self.volumeUsedInBytes = volumeUsedInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case kmsKey = "KMSKey"
            case preservedExistingData = "PreservedExistingData"
            case sourceSnapshotId = "SourceSnapshotId"
            case targetName = "TargetName"
            case volumeARN = "VolumeARN"
            case volumeAttachmentStatus = "VolumeAttachmentStatus"
            case volumeDiskId = "VolumeDiskId"
            case volumeId = "VolumeId"
            case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
            case volumeProgress = "VolumeProgress"
            case volumeSizeInBytes = "VolumeSizeInBytes"
            case volumeStatus = "VolumeStatus"
            case volumeType = "VolumeType"
            case volumeUsedInBytes = "VolumeUsedInBytes"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Tag key. The key can't start with aws:.
        public let key: String
        /// Value of the tag key.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct Tape: AWSDecodableShape {
        public let kmsKey: String?
        /// The date that the tape enters a custom tape pool.
        public let poolEntryDate: Date?
        /// The ID of the pool that contains tapes that will be archived. The tapes in this pool are archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let poolId: String?
        /// For archiving virtual tapes, indicates how much data remains to be uploaded before archiving is complete. Range: 0 (not started) to 100 (complete).
        public let progress: Double?
        /// The date that the tape is first archived with tape retention lock enabled.
        public let retentionStartDate: Date?
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public let tapeARN: String?
        /// The barcode that identifies a specific virtual tape.
        public let tapeBarcode: String?
        /// The date the virtual tape was created.
        public let tapeCreatedDate: Date?
        /// The size, in bytes, of the virtual tape capacity.
        public let tapeSizeInBytes: Int64?
        /// The current state of the virtual tape.
        public let tapeStatus: String?
        /// The size, in bytes, of data stored on the virtual tape.  This value is not available for tapes created prior to May 13, 2015.
        public let tapeUsedInBytes: Int64?
        /// The virtual tape library (VTL) device that the virtual tape is associated with.
        public let vtlDevice: String?
        /// If the tape is archived as write-once-read-many (WORM), this value is true.
        public let worm: Bool?

        @inlinable
        public init(kmsKey: String? = nil, poolEntryDate: Date? = nil, poolId: String? = nil, progress: Double? = nil, retentionStartDate: Date? = nil, tapeARN: String? = nil, tapeBarcode: String? = nil, tapeCreatedDate: Date? = nil, tapeSizeInBytes: Int64? = nil, tapeStatus: String? = nil, tapeUsedInBytes: Int64? = nil, vtlDevice: String? = nil, worm: Bool? = nil) {
            self.kmsKey = kmsKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.progress = progress
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.vtlDevice = vtlDevice
            self.worm = worm
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKey = "KMSKey"
            case poolEntryDate = "PoolEntryDate"
            case poolId = "PoolId"
            case progress = "Progress"
            case retentionStartDate = "RetentionStartDate"
            case tapeARN = "TapeARN"
            case tapeBarcode = "TapeBarcode"
            case tapeCreatedDate = "TapeCreatedDate"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case tapeStatus = "TapeStatus"
            case tapeUsedInBytes = "TapeUsedInBytes"
            case vtlDevice = "VTLDevice"
            case worm = "Worm"
        }
    }

    public struct TapeArchive: AWSDecodableShape {
        /// The time that the archiving of the virtual tape was completed. The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public let completionTime: Date?
        public let kmsKey: String?
        /// The time that the tape entered the custom tape pool. The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public let poolEntryDate: Date?
        /// The ID of the pool that was used to archive the tape. The tapes in this pool are archived in the S3 storage class that is associated with the pool.
        public let poolId: String?
        /// If the archived tape is subject to tape retention lock, the date that the archived tape started being retained.
        public let retentionStartDate: Date?
        /// The Amazon Resource Name (ARN) of the tape gateway that the virtual tape is being retrieved to. The virtual tape is retrieved from the virtual tape shelf (VTS).
        public let retrievedTo: String?
        /// The Amazon Resource Name (ARN) of an archived virtual tape.
        public let tapeARN: String?
        /// The barcode that identifies the archived virtual tape.
        public let tapeBarcode: String?
        /// The date the virtual tape was created.
        public let tapeCreatedDate: Date?
        /// The size, in bytes, of the archived virtual tape.
        public let tapeSizeInBytes: Int64?
        /// The current state of the archived virtual tape.
        public let tapeStatus: String?
        /// The size, in bytes, of data stored on the virtual tape.  This value is not available for tapes created prior to May 13, 2015.
        public let tapeUsedInBytes: Int64?
        /// Set to true if the archived tape is stored as write-once-read-many (WORM).
        public let worm: Bool?

        @inlinable
        public init(completionTime: Date? = nil, kmsKey: String? = nil, poolEntryDate: Date? = nil, poolId: String? = nil, retentionStartDate: Date? = nil, retrievedTo: String? = nil, tapeARN: String? = nil, tapeBarcode: String? = nil, tapeCreatedDate: Date? = nil, tapeSizeInBytes: Int64? = nil, tapeStatus: String? = nil, tapeUsedInBytes: Int64? = nil, worm: Bool? = nil) {
            self.completionTime = completionTime
            self.kmsKey = kmsKey
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.retrievedTo = retrievedTo
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeCreatedDate = tapeCreatedDate
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
            self.tapeUsedInBytes = tapeUsedInBytes
            self.worm = worm
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case kmsKey = "KMSKey"
            case poolEntryDate = "PoolEntryDate"
            case poolId = "PoolId"
            case retentionStartDate = "RetentionStartDate"
            case retrievedTo = "RetrievedTo"
            case tapeARN = "TapeARN"
            case tapeBarcode = "TapeBarcode"
            case tapeCreatedDate = "TapeCreatedDate"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case tapeStatus = "TapeStatus"
            case tapeUsedInBytes = "TapeUsedInBytes"
            case worm = "Worm"
        }
    }

    public struct TapeInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the gateway. Use the ListGateways operation to return a list of gateways for your account and Amazon Web Services Region.
        public let gatewayARN: String?
        /// The date that the tape entered the custom tape pool with tape retention lock enabled.
        public let poolEntryDate: Date?
        /// The ID of the pool that you want to add your tape to for archiving. The tape in this pool is archived in the S3 storage class that is associated with the pool. When you use your backup application to eject the tape, the tape is archived directly into the storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.
        public let poolId: String?
        /// The date that the tape became subject to tape retention lock.
        public let retentionStartDate: Date?
        /// The Amazon Resource Name (ARN) of a virtual tape.
        public let tapeARN: String?
        /// The barcode that identifies a specific virtual tape.
        public let tapeBarcode: String?
        /// The size, in bytes, of a virtual tape.
        public let tapeSizeInBytes: Int64?
        /// The status of the tape.
        public let tapeStatus: String?

        @inlinable
        public init(gatewayARN: String? = nil, poolEntryDate: Date? = nil, poolId: String? = nil, retentionStartDate: Date? = nil, tapeARN: String? = nil, tapeBarcode: String? = nil, tapeSizeInBytes: Int64? = nil, tapeStatus: String? = nil) {
            self.gatewayARN = gatewayARN
            self.poolEntryDate = poolEntryDate
            self.poolId = poolId
            self.retentionStartDate = retentionStartDate
            self.tapeARN = tapeARN
            self.tapeBarcode = tapeBarcode
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case poolEntryDate = "PoolEntryDate"
            case poolId = "PoolId"
            case retentionStartDate = "RetentionStartDate"
            case tapeARN = "TapeARN"
            case tapeBarcode = "TapeBarcode"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case tapeStatus = "TapeStatus"
        }
    }

    public struct TapeRecoveryPointInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the virtual tape.
        public let tapeARN: String?
        /// The time when the point-in-time view of the virtual tape was replicated for later recovery. The default timestamp format of the tape recovery point time is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
        public let tapeRecoveryPointTime: Date?
        /// The size, in bytes, of the virtual tapes to recover.
        public let tapeSizeInBytes: Int64?
        /// The status of the virtual tapes.
        public let tapeStatus: String?

        @inlinable
        public init(tapeARN: String? = nil, tapeRecoveryPointTime: Date? = nil, tapeSizeInBytes: Int64? = nil, tapeStatus: String? = nil) {
            self.tapeARN = tapeARN
            self.tapeRecoveryPointTime = tapeRecoveryPointTime
            self.tapeSizeInBytes = tapeSizeInBytes
            self.tapeStatus = tapeStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tapeARN = "TapeARN"
            case tapeRecoveryPointTime = "TapeRecoveryPointTime"
            case tapeSizeInBytes = "TapeSizeInBytes"
            case tapeStatus = "TapeStatus"
        }
    }

    public struct UpdateAutomaticTapeCreationPolicyInput: AWSEncodableShape {
        /// An automatic tape creation policy consists of a list of automatic tape creation rules. The rules determine when and how to automatically create new tapes.
        public let automaticTapeCreationRules: [AutomaticTapeCreationRule]
        public let gatewayARN: String

        @inlinable
        public init(automaticTapeCreationRules: [AutomaticTapeCreationRule], gatewayARN: String) {
            self.automaticTapeCreationRules = automaticTapeCreationRules
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.automaticTapeCreationRules.forEach {
                try $0.validate(name: "\(name).automaticTapeCreationRules[]")
            }
            try self.validate(self.automaticTapeCreationRules, name: "automaticTapeCreationRules", parent: name, max: 10)
            try self.validate(self.automaticTapeCreationRules, name: "automaticTapeCreationRules", parent: name, min: 1)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTapeCreationRules = "AutomaticTapeCreationRules"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateAutomaticTapeCreationPolicyOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateBandwidthRateLimitInput: AWSEncodableShape {
        /// The average download bandwidth rate limit in bits per second.
        public let averageDownloadRateLimitInBitsPerSec: Int64?
        /// The average upload bandwidth rate limit in bits per second.
        public let averageUploadRateLimitInBitsPerSec: Int64?
        public let gatewayARN: String

        @inlinable
        public init(averageDownloadRateLimitInBitsPerSec: Int64? = nil, averageUploadRateLimitInBitsPerSec: Int64? = nil, gatewayARN: String) {
            self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.averageDownloadRateLimitInBitsPerSec, name: "averageDownloadRateLimitInBitsPerSec", parent: name, min: 102400)
            try self.validate(self.averageUploadRateLimitInBitsPerSec, name: "averageUploadRateLimitInBitsPerSec", parent: name, min: 51200)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
            case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateBandwidthRateLimitOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateBandwidthRateLimitScheduleInput: AWSEncodableShape {
        ///  An array containing bandwidth rate limit schedule intervals for a gateway. When no bandwidth rate limit intervals have been scheduled, the array is empty.
        public let bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]
        public let gatewayARN: String

        @inlinable
        public init(bandwidthRateLimitIntervals: [BandwidthRateLimitInterval], gatewayARN: String) {
            self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.bandwidthRateLimitIntervals.forEach {
                try $0.validate(name: "\(name).bandwidthRateLimitIntervals[]")
            }
            try self.validate(self.bandwidthRateLimitIntervals, name: "bandwidthRateLimitIntervals", parent: name, max: 20)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateBandwidthRateLimitScheduleOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateChapCredentialsInput: AWSEncodableShape {
        /// The iSCSI initiator that connects to the target.
        public let initiatorName: String
        /// The secret key that the initiator (for example, the Windows client) must provide to participate in mutual CHAP with the target.  The secret key must be between 12 and 16 bytes when encoded in UTF-8.
        public let secretToAuthenticateInitiator: String
        /// The secret key that the target must provide to participate in mutual CHAP with the initiator (e.g. Windows client). Byte constraints: Minimum bytes of 12. Maximum bytes of 16.  The secret key must be between 12 and 16 bytes when encoded in UTF-8.
        public let secretToAuthenticateTarget: String?
        /// The Amazon Resource Name (ARN) of the iSCSI volume target. Use the DescribeStorediSCSIVolumes operation to return the TargetARN for specified VolumeARN.
        public let targetARN: String

        @inlinable
        public init(initiatorName: String, secretToAuthenticateInitiator: String, secretToAuthenticateTarget: String? = nil, targetARN: String) {
            self.initiatorName = initiatorName
            self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
            self.secretToAuthenticateTarget = secretToAuthenticateTarget
            self.targetARN = targetARN
        }

        public func validate(name: String) throws {
            try self.validate(self.initiatorName, name: "initiatorName", parent: name, max: 255)
            try self.validate(self.initiatorName, name: "initiatorName", parent: name, min: 1)
            try self.validate(self.initiatorName, name: "initiatorName", parent: name, pattern: "^[0-9a-z:.-]+$")
            try self.validate(self.secretToAuthenticateInitiator, name: "secretToAuthenticateInitiator", parent: name, max: 100)
            try self.validate(self.secretToAuthenticateInitiator, name: "secretToAuthenticateInitiator", parent: name, min: 1)
            try self.validate(self.secretToAuthenticateTarget, name: "secretToAuthenticateTarget", parent: name, max: 100)
            try self.validate(self.secretToAuthenticateTarget, name: "secretToAuthenticateTarget", parent: name, min: 1)
            try self.validate(self.targetARN, name: "targetARN", parent: name, max: 800)
            try self.validate(self.targetARN, name: "targetARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case initiatorName = "InitiatorName"
            case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
            case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
            case targetARN = "TargetARN"
        }
    }

    public struct UpdateChapCredentialsOutput: AWSDecodableShape {
        /// The iSCSI initiator that connects to the target. This is the same initiator name specified in the request.
        public let initiatorName: String?
        /// The Amazon Resource Name (ARN) of the target. This is the same target specified in the request.
        public let targetARN: String?

        @inlinable
        public init(initiatorName: String? = nil, targetARN: String? = nil) {
            self.initiatorName = initiatorName
            self.targetARN = targetARN
        }

        private enum CodingKeys: String, CodingKey {
            case initiatorName = "InitiatorName"
            case targetARN = "TargetARN"
        }
    }

    public struct UpdateFileSystemAssociationInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the storage used for the audit logs.
        public let auditDestinationARN: String?
        public let cacheAttributes: CacheAttributes?
        /// The Amazon Resource Name (ARN) of the file system association that you want to update.
        public let fileSystemAssociationARN: String
        /// The password of the user credential.
        public let password: String?
        /// The user name of the user credential that has permission to access the root share D$ of the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin user group.
        public let userName: String?

        @inlinable
        public init(auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, fileSystemAssociationARN: String, password: String? = nil, userName: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.fileSystemAssociationARN = fileSystemAssociationARN
            self.password = password
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.auditDestinationARN, name: "auditDestinationARN", parent: name, max: 1024)
            try self.validate(self.fileSystemAssociationARN, name: "fileSystemAssociationARN", parent: name, max: 500)
            try self.validate(self.fileSystemAssociationARN, name: "fileSystemAssociationARN", parent: name, min: 50)
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[ -~]+$")
            try self.validate(self.userName, name: "userName", parent: name, max: 1024)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^\\w[\\w\\.\\- ]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case auditDestinationARN = "AuditDestinationARN"
            case cacheAttributes = "CacheAttributes"
            case fileSystemAssociationARN = "FileSystemAssociationARN"
            case password = "Password"
            case userName = "UserName"
        }
    }

    public struct UpdateFileSystemAssociationOutput: AWSDecodableShape {
        /// The ARN of the updated file system association.
        public let fileSystemAssociationARN: String?

        @inlinable
        public init(fileSystemAssociationARN: String? = nil) {
            self.fileSystemAssociationARN = fileSystemAssociationARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemAssociationARN = "FileSystemAssociationARN"
        }
    }

    public struct UpdateGatewayInformationInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that you want to use to monitor and log events in the gateway. For more information, see What is Amazon CloudWatch Logs?
        public let cloudWatchLogGroupARN: String?
        public let gatewayARN: String
        /// Specifies the size of the gateway's metadata cache. This setting impacts gateway performance and hardware recommendations. For more information, see Performance guidance for gateways with multiple file shares in the Amazon S3 File Gateway User Guide.
        public let gatewayCapacity: GatewayCapacity?
        public let gatewayName: String?
        /// A value that indicates the time zone of the gateway.
        public let gatewayTimezone: String?

        @inlinable
        public init(cloudWatchLogGroupARN: String? = nil, gatewayARN: String, gatewayCapacity: GatewayCapacity? = nil, gatewayName: String? = nil, gatewayTimezone: String? = nil) {
            self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
            self.gatewayARN = gatewayARN
            self.gatewayCapacity = gatewayCapacity
            self.gatewayName = gatewayName
            self.gatewayTimezone = gatewayTimezone
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupARN, name: "cloudWatchLogGroupARN", parent: name, max: 562)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 255)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 2)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[ -\\.0-\\[\\]-~]*[!-\\.0-\\[\\]-~][ -\\.0-\\[\\]-~]*$")
            try self.validate(self.gatewayTimezone, name: "gatewayTimezone", parent: name, max: 10)
            try self.validate(self.gatewayTimezone, name: "gatewayTimezone", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
            case gatewayARN = "GatewayARN"
            case gatewayCapacity = "GatewayCapacity"
            case gatewayName = "GatewayName"
            case gatewayTimezone = "GatewayTimezone"
        }
    }

    public struct UpdateGatewayInformationOutput: AWSDecodableShape {
        public let gatewayARN: String?
        /// The name you configured for your gateway.
        public let gatewayName: String?

        @inlinable
        public init(gatewayARN: String? = nil, gatewayName: String? = nil) {
            self.gatewayARN = gatewayARN
            self.gatewayName = gatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case gatewayName = "GatewayName"
        }
    }

    public struct UpdateGatewaySoftwareNowInput: AWSEncodableShape {
        public let gatewayARN: String

        @inlinable
        public init(gatewayARN: String) {
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateGatewaySoftwareNowOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateMaintenanceStartTimeInput: AWSEncodableShape {
        /// The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month. It is not possible to set the maintenance schedule to start on days 29 through 31.
        public let dayOfMonth: Int?
        /// The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 represents Saturday.
        public let dayOfWeek: Int?
        public let gatewayARN: String
        /// The hour component of the maintenance start time represented as hh, where hh is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
        public let hourOfDay: Int?
        /// The minute component of the maintenance start time represented as mm, where mm is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
        public let minuteOfHour: Int?
        /// A set of variables indicating the software update preferences for the gateway. Includes AutomaticUpdatePolicy field with the following inputs:  ALL_VERSIONS - Enables regular gateway maintenance updates.  EMERGENCY_VERSIONS_ONLY - Disables regular gateway maintenance updates. The gateway will still receive emergency version updates on rare occasions if necessary to remedy highly critical security or durability issues. You will be notified before an emergency version update is applied. These updates are applied during your gateway's scheduled maintenance window.
        public let softwareUpdatePreferences: SoftwareUpdatePreferences?

        @inlinable
        public init(dayOfMonth: Int? = nil, dayOfWeek: Int? = nil, gatewayARN: String, hourOfDay: Int? = nil, minuteOfHour: Int? = nil, softwareUpdatePreferences: SoftwareUpdatePreferences? = nil) {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.gatewayARN = gatewayARN
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
            self.softwareUpdatePreferences = softwareUpdatePreferences
        }

        public func validate(name: String) throws {
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, max: 28)
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, min: 1)
            try self.validate(self.dayOfWeek, name: "dayOfWeek", parent: name, max: 6)
            try self.validate(self.dayOfWeek, name: "dayOfWeek", parent: name, min: 0)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.validate(self.hourOfDay, name: "hourOfDay", parent: name, max: 23)
            try self.validate(self.hourOfDay, name: "hourOfDay", parent: name, min: 0)
            try self.validate(self.minuteOfHour, name: "minuteOfHour", parent: name, max: 59)
            try self.validate(self.minuteOfHour, name: "minuteOfHour", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfMonth = "DayOfMonth"
            case dayOfWeek = "DayOfWeek"
            case gatewayARN = "GatewayARN"
            case hourOfDay = "HourOfDay"
            case minuteOfHour = "MinuteOfHour"
            case softwareUpdatePreferences = "SoftwareUpdatePreferences"
        }
    }

    public struct UpdateMaintenanceStartTimeOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateNFSFileShareInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public let auditDestinationARN: String?
        /// Specifies refresh cache information for the file share.
        public let cacheAttributes: CacheAttributes?
        /// The list of clients that are allowed to access the S3 File Gateway. The list must contain either valid IP addresses or valid CIDR blocks.
        public let clientList: [String]?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public let defaultStorageClass: String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public let encryptionType: EncryptionType?
        /// The Amazon Resource Name (ARN) of the file share to be updated.
        public let fileShareARN: String
        /// The name of the file share. Optional.   FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used. A valid NFS file share name can only contain the following characters: a-z, A-Z, 0-9, -, ., and _.
        public let fileShareName: String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public let guessMIMETypeEnabled: Bool?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.  Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public let kmsKey: String?
        /// The default values for the file share. Optional.
        public let nfsFileShareDefaults: NFSFileShareDefaults?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period.   SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications.  The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60.  {\"Upload\": {\"SettlingTimeInSeconds\": 60}}  The following example sets NotificationPolicy off.  {}
        public let notificationPolicy: String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
        public let objectACL: ObjectACL?
        /// A value that sets the write status of a file share. Set this value to true to set the write status to read-only, otherwise set to false. Valid Values: true | false
        public let readOnly: Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data.   RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration.  Valid Values: true | false
        public let requesterPays: Bool?
        /// The user mapped to anonymous user. Valid values are the following:    RootSquash: Only root is mapped to anonymous user.    NoSquash: No one is mapped to anonymous user.    AllSquash: Everyone is mapped to anonymous user.
        public let squash: String?

        @inlinable
        public init(auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, clientList: [String]? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String, fileShareName: String? = nil, guessMIMETypeEnabled: Bool? = nil, kmsKey: String? = nil, nfsFileShareDefaults: NFSFileShareDefaults? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, squash: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareName = fileShareName
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = nil
            self.kmsKey = kmsKey
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.squash = squash
        }

        @available(*, deprecated, message: "Members kmsEncrypted have been deprecated")
        @inlinable
        public init(auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, clientList: [String]? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String, fileShareName: String? = nil, guessMIMETypeEnabled: Bool? = nil, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, nfsFileShareDefaults: NFSFileShareDefaults? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, squash: String? = nil) {
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.clientList = clientList
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareName = fileShareName
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.nfsFileShareDefaults = nfsFileShareDefaults
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.squash = squash
        }

        public func validate(name: String) throws {
            try self.validate(self.auditDestinationARN, name: "auditDestinationARN", parent: name, max: 1024)
            try self.clientList?.forEach {
                try validate($0, name: "clientList[]", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))?$")
            }
            try self.validate(self.clientList, name: "clientList", parent: name, max: 100)
            try self.validate(self.clientList, name: "clientList", parent: name, min: 1)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, max: 50)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, min: 5)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, max: 255)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.nfsFileShareDefaults?.validate(name: "\(name).nfsFileShareDefaults")
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, max: 100)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, min: 2)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, pattern: "^\\{[\\w\\s:\\{\\}\\[\\]\"]*}$")
            try self.validate(self.squash, name: "squash", parent: name, max: 15)
            try self.validate(self.squash, name: "squash", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case auditDestinationARN = "AuditDestinationARN"
            case cacheAttributes = "CacheAttributes"
            case clientList = "ClientList"
            case defaultStorageClass = "DefaultStorageClass"
            case encryptionType = "EncryptionType"
            case fileShareARN = "FileShareARN"
            case fileShareName = "FileShareName"
            case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case nfsFileShareDefaults = "NFSFileShareDefaults"
            case notificationPolicy = "NotificationPolicy"
            case objectACL = "ObjectACL"
            case readOnly = "ReadOnly"
            case requesterPays = "RequesterPays"
            case squash = "Squash"
        }
    }

    public struct UpdateNFSFileShareOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated file share.
        public let fileShareARN: String?

        @inlinable
        public init(fileShareARN: String? = nil) {
            self.fileShareARN = fileShareARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
        }
    }

    public struct UpdateSMBFileShareInput: AWSEncodableShape {
        /// The files and folders on this share will only be visible to users with read access.
        public let accessBasedEnumeration: Bool?
        /// A list of users or groups in the Active Directory that have administrator rights to the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let adminUserList: [String]?
        /// The Amazon Resource Name (ARN) of the storage used for audit logs.
        public let auditDestinationARN: String?
        /// Specifies refresh cache information for the file share.
        public let cacheAttributes: CacheAttributes?
        /// The case of an object name in an Amazon S3 bucket. For ClientSpecified, the client determines the case sensitivity. For CaseSensitive, the gateway determines the case sensitivity. The default value is ClientSpecified.
        public let caseSensitivity: CaseSensitivity?
        /// The default storage class for objects put into an Amazon S3 bucket by the S3 File Gateway. The default value is S3_STANDARD. Optional. Valid Values: S3_STANDARD | S3_INTELLIGENT_TIERING | S3_STANDARD_IA | S3_ONEZONE_IA
        public let defaultStorageClass: String?
        /// A value that specifies the type of server-side encryption that the file share will use for the data that it stores in Amazon S3.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.
        public let encryptionType: EncryptionType?
        /// The Amazon Resource Name (ARN) of the SMB file share that you want to update.
        public let fileShareARN: String
        /// The name of the file share. Optional.   FileShareName must be set if an S3 prefix name is set in LocationARN, or if an access point or access point alias is used. A valid SMB file share name cannot contain the following characters: [,],#,;,,>,:,",\,/,|,?,*,+, or ASCII control characters 1-31.
        public let fileShareName: String?
        /// A value that enables guessing of the MIME type for uploaded objects based on file extensions. Set this value to true to enable MIME type guessing, otherwise set to false. The default value is true. Valid Values: true | false
        public let guessMIMETypeEnabled: Bool?
        /// A list of users or groups in the Active Directory that are not allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let invalidUserList: [String]?
        /// Optional. Set to true to use Amazon S3 server-side encryption with your own KMS key (SSE-KMS), or false to use a key managed by Amazon S3 (SSE-S3). To use dual-layer encryption (DSSE-KMS), set the EncryptionType parameter instead.  We recommend using EncryptionType instead of KMSEncrypted to set the file share encryption method. You do not need to provide values for both parameters. If values for both parameters exist in the same request, then the specified encryption methods must not conflict. For example, if EncryptionType is SseS3, then KMSEncrypted must be false. If EncryptionType is SseKms or DsseKms, then KMSEncrypted must be true.  Valid Values: true | false
        public let kmsEncrypted: Bool?
        /// Optional. The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value must be set if KMSEncrypted is true, or if EncryptionType is SseKms or DsseKms.
        public let kmsKey: String?
        /// The notification policy of the file share. SettlingTimeInSeconds controls the number of seconds to wait after the last point in time a client wrote to a file before generating an ObjectUploaded notification. Because clients can make many small writes to files, it's best to set this parameter for as long as possible to avoid generating multiple notifications for the same file in a small time period.   SettlingTimeInSeconds has no effect on the timing of the object uploading to Amazon S3, only the timing of the notification. This setting is not meant to specify an exact time at which the notification will be sent. In some cases, the gateway might require more than the specified delay time to generate and send notifications.  The following example sets NotificationPolicy on with SettlingTimeInSeconds set to 60.  {\"Upload\": {\"SettlingTimeInSeconds\": 60}}  The following example sets NotificationPolicy off.  {}
        public let notificationPolicy: String?
        /// A value that sets the access control list (ACL) permission for objects in the S3 bucket that a S3 File Gateway puts objects into. The default value is private.
        public let objectACL: ObjectACL?
        /// Specifies whether opportunistic locking is enabled for the SMB file share.  Enabling opportunistic locking on case-sensitive shares is not recommended for workloads that involve access to files with the same name in different case.  Valid Values: true | false
        public let oplocksEnabled: Bool?
        /// A value that sets the write status of a file share. Set this value to true to set write status to read-only, otherwise set to false. Valid Values: true | false
        public let readOnly: Bool?
        /// A value that sets who pays the cost of the request and the cost associated with data download from the S3 bucket. If this value is set to true, the requester pays the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays the cost of storing data.   RequesterPays is a configuration for the S3 bucket that backs the file share, so make sure that the configuration on the file share is the same as the S3 bucket configuration.  Valid Values: true | false
        public let requesterPays: Bool?
        /// Set this value to true to enable access control list (ACL) on the SMB file share. Set it to false to map file and directory permissions to the POSIX permissions. For more information, see Using Windows ACLs to limit SMB file share access in the Amazon S3 File Gateway User Guide. Valid Values: true | false
        public let smbaclEnabled: Bool?
        /// A list of users or groups in the Active Directory that are allowed to access the file share. A group must be prefixed with the @ character. Acceptable formats include: DOMAIN\User1, user1, @group1, and @DOMAIN\group1. Can only be set if Authentication is set to ActiveDirectory.
        public let validUserList: [String]?

        @inlinable
        public init(accessBasedEnumeration: Bool? = nil, adminUserList: [String]? = nil, auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, caseSensitivity: CaseSensitivity? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String, fileShareName: String? = nil, guessMIMETypeEnabled: Bool? = nil, invalidUserList: [String]? = nil, kmsKey: String? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, oplocksEnabled: Bool? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, smbaclEnabled: Bool? = nil, validUserList: [String]? = nil) {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareName = fileShareName
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = nil
            self.kmsKey = kmsKey
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.smbaclEnabled = smbaclEnabled
            self.validUserList = validUserList
        }

        @available(*, deprecated, message: "Members kmsEncrypted have been deprecated")
        @inlinable
        public init(accessBasedEnumeration: Bool? = nil, adminUserList: [String]? = nil, auditDestinationARN: String? = nil, cacheAttributes: CacheAttributes? = nil, caseSensitivity: CaseSensitivity? = nil, defaultStorageClass: String? = nil, encryptionType: EncryptionType? = nil, fileShareARN: String, fileShareName: String? = nil, guessMIMETypeEnabled: Bool? = nil, invalidUserList: [String]? = nil, kmsEncrypted: Bool? = nil, kmsKey: String? = nil, notificationPolicy: String? = nil, objectACL: ObjectACL? = nil, oplocksEnabled: Bool? = nil, readOnly: Bool? = nil, requesterPays: Bool? = nil, smbaclEnabled: Bool? = nil, validUserList: [String]? = nil) {
            self.accessBasedEnumeration = accessBasedEnumeration
            self.adminUserList = adminUserList
            self.auditDestinationARN = auditDestinationARN
            self.cacheAttributes = cacheAttributes
            self.caseSensitivity = caseSensitivity
            self.defaultStorageClass = defaultStorageClass
            self.encryptionType = encryptionType
            self.fileShareARN = fileShareARN
            self.fileShareName = fileShareName
            self.guessMIMETypeEnabled = guessMIMETypeEnabled
            self.invalidUserList = invalidUserList
            self.kmsEncrypted = kmsEncrypted
            self.kmsKey = kmsKey
            self.notificationPolicy = notificationPolicy
            self.objectACL = objectACL
            self.oplocksEnabled = oplocksEnabled
            self.readOnly = readOnly
            self.requesterPays = requesterPays
            self.smbaclEnabled = smbaclEnabled
            self.validUserList = validUserList
        }

        public func validate(name: String) throws {
            try self.adminUserList?.forEach {
                try validate($0, name: "adminUserList[]", parent: name, max: 64)
                try validate($0, name: "adminUserList[]", parent: name, min: 1)
            }
            try self.validate(self.adminUserList, name: "adminUserList", parent: name, max: 100)
            try self.validate(self.auditDestinationARN, name: "auditDestinationARN", parent: name, max: 1024)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, max: 50)
            try self.validate(self.defaultStorageClass, name: "defaultStorageClass", parent: name, min: 5)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, max: 500)
            try self.validate(self.fileShareARN, name: "fileShareARN", parent: name, min: 50)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, max: 255)
            try self.validate(self.fileShareName, name: "fileShareName", parent: name, min: 1)
            try self.invalidUserList?.forEach {
                try validate($0, name: "invalidUserList[]", parent: name, max: 64)
                try validate($0, name: "invalidUserList[]", parent: name, min: 1)
            }
            try self.validate(self.invalidUserList, name: "invalidUserList", parent: name, max: 100)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 7)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^(^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):kms:([a-zA-Z0-9-]+):([0-9]+):(key|alias)/(\\S+)$)|(^alias/(\\S+)$)$")
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, max: 100)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, min: 2)
            try self.validate(self.notificationPolicy, name: "notificationPolicy", parent: name, pattern: "^\\{[\\w\\s:\\{\\}\\[\\]\"]*}$")
            try self.validUserList?.forEach {
                try validate($0, name: "validUserList[]", parent: name, max: 64)
                try validate($0, name: "validUserList[]", parent: name, min: 1)
            }
            try self.validate(self.validUserList, name: "validUserList", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case accessBasedEnumeration = "AccessBasedEnumeration"
            case adminUserList = "AdminUserList"
            case auditDestinationARN = "AuditDestinationARN"
            case cacheAttributes = "CacheAttributes"
            case caseSensitivity = "CaseSensitivity"
            case defaultStorageClass = "DefaultStorageClass"
            case encryptionType = "EncryptionType"
            case fileShareARN = "FileShareARN"
            case fileShareName = "FileShareName"
            case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
            case invalidUserList = "InvalidUserList"
            case kmsEncrypted = "KMSEncrypted"
            case kmsKey = "KMSKey"
            case notificationPolicy = "NotificationPolicy"
            case objectACL = "ObjectACL"
            case oplocksEnabled = "OplocksEnabled"
            case readOnly = "ReadOnly"
            case requesterPays = "RequesterPays"
            case smbaclEnabled = "SMBACLEnabled"
            case validUserList = "ValidUserList"
        }
    }

    public struct UpdateSMBFileShareOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated SMB file share.
        public let fileShareARN: String?

        @inlinable
        public init(fileShareARN: String? = nil) {
            self.fileShareARN = fileShareARN
        }

        private enum CodingKeys: String, CodingKey {
            case fileShareARN = "FileShareARN"
        }
    }

    public struct UpdateSMBFileShareVisibilityInput: AWSEncodableShape {
        /// The shares on this gateway appear when listing shares.
        public let fileSharesVisible: Bool
        public let gatewayARN: String

        @inlinable
        public init(fileSharesVisible: Bool, gatewayARN: String) {
            self.fileSharesVisible = fileSharesVisible
            self.gatewayARN = gatewayARN
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case fileSharesVisible = "FileSharesVisible"
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateSMBFileShareVisibilityOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateSMBLocalGroupsInput: AWSEncodableShape {
        public let gatewayARN: String
        /// A list of Active Directory users and groups that you want to grant special permissions for SMB file shares on the gateway.
        public let smbLocalGroups: SMBLocalGroups

        @inlinable
        public init(gatewayARN: String, smbLocalGroups: SMBLocalGroups) {
            self.gatewayARN = gatewayARN
            self.smbLocalGroups = smbLocalGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
            try self.smbLocalGroups.validate(name: "\(name).smbLocalGroups")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case smbLocalGroups = "SMBLocalGroups"
        }
    }

    public struct UpdateSMBLocalGroupsOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateSMBSecurityStrategyInput: AWSEncodableShape {
        public let gatewayARN: String
        /// Specifies the type of security strategy.  ClientSpecified: If you choose this option, requests are established based on what is negotiated by the client. This option is recommended when you want to maximize compatibility across different clients in your environment. Supported only for S3 File Gateway.  MandatorySigning: If you choose this option, File Gateway only allows connections from SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on Microsoft Windows Vista, Windows Server 2008 or newer.  MandatoryEncryption: If you choose this option, File Gateway only allows connections from SMBv3 clients that have encryption enabled. This option is recommended for environments that handle sensitive data. This option works with SMB clients on Microsoft Windows 8, Windows Server 2012 or newer.  MandatoryEncryptionNoAes128: If you choose this option, File Gateway only allows connections from SMBv3 clients that use 256-bit AES encryption algorithms. 128-bit algorithms are not allowed. This option is recommended for environments that handle sensitive data. It works with SMB clients on Microsoft Windows 8, Windows Server 2012, or later.
        public let smbSecurityStrategy: SMBSecurityStrategy

        @inlinable
        public init(gatewayARN: String, smbSecurityStrategy: SMBSecurityStrategy) {
            self.gatewayARN = gatewayARN
            self.smbSecurityStrategy = smbSecurityStrategy
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, max: 500)
            try self.validate(self.gatewayARN, name: "gatewayARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case smbSecurityStrategy = "SMBSecurityStrategy"
        }
    }

    public struct UpdateSMBSecurityStrategyOutput: AWSDecodableShape {
        public let gatewayARN: String?

        @inlinable
        public init(gatewayARN: String? = nil) {
            self.gatewayARN = gatewayARN
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
        }
    }

    public struct UpdateSnapshotScheduleInput: AWSEncodableShape {
        /// Optional description of the snapshot that overwrites the existing description.
        public let description: String?
        /// Frequency of snapshots. Specify the number of hours between snapshots.
        public let recurrenceInHours: Int
        /// The hour of the day at which the snapshot schedule begins represented as hh, where hh is the hour (0 to 23). The hour of the day is in the time zone of the gateway.
        public let startAt: Int
        /// A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value pair.  Valid characters for key and value are letters, spaces, and numbers representable in UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key is 128 characters, and the maximum length for a tag's value is 256.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes operation to return a list of gateway volumes.
        public let volumeARN: String

        @inlinable
        public init(description: String? = nil, recurrenceInHours: Int, startAt: Int, tags: [Tag]? = nil, volumeARN: String) {
            self.description = description
            self.recurrenceInHours = recurrenceInHours
            self.startAt = startAt
            self.tags = tags
            self.volumeARN = volumeARN
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.recurrenceInHours, name: "recurrenceInHours", parent: name, max: 24)
            try self.validate(self.recurrenceInHours, name: "recurrenceInHours", parent: name, min: 1)
            try self.validate(self.startAt, name: "startAt", parent: name, max: 23)
            try self.validate(self.startAt, name: "startAt", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, max: 500)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, min: 50)
            try self.validate(self.volumeARN, name: "volumeARN", parent: name, pattern: "^arn:(aws(|-cn|-us-gov|-iso[A-Za-z0-9_-]*)):storagegateway:[a-z\\-0-9]+:[0-9]+:gateway\\/(.+)\\/volume\\/vol-(\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case recurrenceInHours = "RecurrenceInHours"
            case startAt = "StartAt"
            case tags = "Tags"
            case volumeARN = "VolumeARN"
        }
    }

    public struct UpdateSnapshotScheduleOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the volume. Use the ListVolumes operation to return a list of gateway volumes.
        public let volumeARN: String?

        @inlinable
        public init(volumeARN: String? = nil) {
            self.volumeARN = volumeARN
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
        }
    }

    public struct UpdateVTLDeviceTypeInput: AWSEncodableShape {
        /// The type of medium changer you want to select. Valid Values: STK-L700 | AWS-Gateway-VTL | IBM-03584L32-0402
        public let deviceType: String
        /// The Amazon Resource Name (ARN) of the medium changer you want to select.
        public let vtlDeviceARN: String

        @inlinable
        public init(deviceType: String, vtlDeviceARN: String) {
            self.deviceType = deviceType
            self.vtlDeviceARN = vtlDeviceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceType, name: "deviceType", parent: name, max: 50)
            try self.validate(self.deviceType, name: "deviceType", parent: name, min: 2)
            try self.validate(self.vtlDeviceARN, name: "vtlDeviceARN", parent: name, max: 500)
            try self.validate(self.vtlDeviceARN, name: "vtlDeviceARN", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceType = "DeviceType"
            case vtlDeviceARN = "VTLDeviceARN"
        }
    }

    public struct UpdateVTLDeviceTypeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the medium changer you have selected.
        public let vtlDeviceARN: String?

        @inlinable
        public init(vtlDeviceARN: String? = nil) {
            self.vtlDeviceARN = vtlDeviceARN
        }

        private enum CodingKeys: String, CodingKey {
            case vtlDeviceARN = "VTLDeviceARN"
        }
    }

    public struct VTLDevice: AWSDecodableShape {
        /// A list of iSCSI information about a VTL device.
        public let deviceiSCSIAttributes: DeviceiSCSIAttributes?
        /// Specifies the unique Amazon Resource Name (ARN) of the device (tape drive or media changer).
        public let vtlDeviceARN: String?
        /// Specifies the model number of device that the VTL device emulates.
        public let vtlDeviceProductIdentifier: String?
        /// Specifies the type of device that the VTL device emulates.
        public let vtlDeviceType: String?
        /// Specifies the vendor of the device that the VTL device object emulates.
        public let vtlDeviceVendor: String?

        @inlinable
        public init(deviceiSCSIAttributes: DeviceiSCSIAttributes? = nil, vtlDeviceARN: String? = nil, vtlDeviceProductIdentifier: String? = nil, vtlDeviceType: String? = nil, vtlDeviceVendor: String? = nil) {
            self.deviceiSCSIAttributes = deviceiSCSIAttributes
            self.vtlDeviceARN = vtlDeviceARN
            self.vtlDeviceProductIdentifier = vtlDeviceProductIdentifier
            self.vtlDeviceType = vtlDeviceType
            self.vtlDeviceVendor = vtlDeviceVendor
        }

        private enum CodingKeys: String, CodingKey {
            case deviceiSCSIAttributes = "DeviceiSCSIAttributes"
            case vtlDeviceARN = "VTLDeviceARN"
            case vtlDeviceProductIdentifier = "VTLDeviceProductIdentifier"
            case vtlDeviceType = "VTLDeviceType"
            case vtlDeviceVendor = "VTLDeviceVendor"
        }
    }

    public struct VolumeInfo: AWSDecodableShape {
        public let gatewayARN: String?
        /// The unique identifier assigned to your gateway during activation. This ID becomes part of the gateway Amazon Resource Name (ARN), which you use as input for other operations. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public let gatewayId: String?
        /// The Amazon Resource Name (ARN) for the storage volume. For example, the following is a valid ARN:  arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/volume/vol-1122AABB  Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public let volumeARN: String?
        /// One of the VolumeStatus values that indicates the state of the storage volume.
        public let volumeAttachmentStatus: String?
        /// The unique identifier assigned to the volume. This ID becomes part of the volume Amazon Resource Name (ARN), which you use as input for other operations. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public let volumeId: String?
        /// The size of the volume in bytes. Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).
        public let volumeSizeInBytes: Int64?
        /// One of the VolumeType enumeration values describing the type of the volume.
        public let volumeType: String?

        @inlinable
        public init(gatewayARN: String? = nil, gatewayId: String? = nil, volumeARN: String? = nil, volumeAttachmentStatus: String? = nil, volumeId: String? = nil, volumeSizeInBytes: Int64? = nil, volumeType: String? = nil) {
            self.gatewayARN = gatewayARN
            self.gatewayId = gatewayId
            self.volumeARN = volumeARN
            self.volumeAttachmentStatus = volumeAttachmentStatus
            self.volumeId = volumeId
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayARN = "GatewayARN"
            case gatewayId = "GatewayId"
            case volumeARN = "VolumeARN"
            case volumeAttachmentStatus = "VolumeAttachmentStatus"
            case volumeId = "VolumeId"
            case volumeSizeInBytes = "VolumeSizeInBytes"
            case volumeType = "VolumeType"
        }
    }

    public struct VolumeRecoveryPointInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the volume target.
        public let volumeARN: String?
        /// The time the recovery point was taken.
        public let volumeRecoveryPointTime: String?
        /// The size of the volume in bytes.
        public let volumeSizeInBytes: Int64?
        /// The size of the data stored on the volume in bytes.  This value is not available for volumes created prior to May 13, 2015, until you store data on the volume.
        public let volumeUsageInBytes: Int64?

        @inlinable
        public init(volumeARN: String? = nil, volumeRecoveryPointTime: String? = nil, volumeSizeInBytes: Int64? = nil, volumeUsageInBytes: Int64? = nil) {
            self.volumeARN = volumeARN
            self.volumeRecoveryPointTime = volumeRecoveryPointTime
            self.volumeSizeInBytes = volumeSizeInBytes
            self.volumeUsageInBytes = volumeUsageInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case volumeARN = "VolumeARN"
            case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
            case volumeSizeInBytes = "VolumeSizeInBytes"
            case volumeUsageInBytes = "VolumeUsageInBytes"
        }
    }

    public struct VolumeiSCSIAttributes: AWSDecodableShape {
        /// Indicates whether mutual CHAP is enabled for the iSCSI target.
        public let chapEnabled: Bool?
        /// The logical disk number.
        public let lunNumber: Int?
        /// The network interface identifier.
        public let networkInterfaceId: String?
        /// The port used to communicate with iSCSI targets.
        public let networkInterfacePort: Int?
        /// The Amazon Resource Name (ARN) of the volume target.
        public let targetARN: String?

        @inlinable
        public init(chapEnabled: Bool? = nil, lunNumber: Int? = nil, networkInterfaceId: String? = nil, networkInterfacePort: Int? = nil, targetARN: String? = nil) {
            self.chapEnabled = chapEnabled
            self.lunNumber = lunNumber
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfacePort = networkInterfacePort
            self.targetARN = targetARN
        }

        private enum CodingKeys: String, CodingKey {
            case chapEnabled = "ChapEnabled"
            case lunNumber = "LunNumber"
            case networkInterfaceId = "NetworkInterfaceId"
            case networkInterfacePort = "NetworkInterfacePort"
            case targetARN = "TargetARN"
        }
    }
}

// MARK: - Errors

/// Error enum for StorageGateway
public struct StorageGatewayErrorType: AWSErrorType {
    enum Code: String {
        case internalServerError = "InternalServerError"
        case invalidGatewayRequestException = "InvalidGatewayRequestException"
        case serviceUnavailableError = "ServiceUnavailableError"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize StorageGateway
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An internal server error has occurred during the request. For more information, see the error and message fields.
    public static var internalServerError: Self { .init(.internalServerError) }
    /// An exception occurred because an invalid gateway request was issued to the service. For more information, see the error and message fields.
    public static var invalidGatewayRequestException: Self { .init(.invalidGatewayRequestException) }
    /// An internal server error has occurred because the service is unavailable. For more information, see the error and message fields.
    public static var serviceUnavailableError: Self { .init(.serviceUnavailableError) }
}

extension StorageGatewayErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "InternalServerError": StorageGateway.InternalServerError.self,
        "InvalidGatewayRequestException": StorageGateway.InvalidGatewayRequestException.self,
        "ServiceUnavailableError": StorageGateway.ServiceUnavailableError.self
    ]
}

extension StorageGatewayErrorType: Equatable {
    public static func == (lhs: StorageGatewayErrorType, rhs: StorageGatewayErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension StorageGatewayErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
