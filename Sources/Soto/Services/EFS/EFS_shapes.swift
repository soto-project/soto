//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension EFS {
    // MARK: Enums

    public enum DeletionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allConfigurations = "ALL_CONFIGURATIONS"
        case localConfigurationOnly = "LOCAL_CONFIGURATION_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum LifeCycleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "available"
        case creating = "creating"
        case deleted = "deleted"
        case deleting = "deleting"
        case error = "error"
        case updating = "updating"
        public var description: String { return self.rawValue }
    }

    public enum PerformanceMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case generalPurpose = "generalPurpose"
        case maxIo = "maxIO"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationOverwriteProtection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case replicating = "REPLICATING"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case enabled = "ENABLED"
        case enabling = "ENABLING"
        case error = "ERROR"
        case paused = "PAUSED"
        case pausing = "PAUSING"
        public var description: String { return self.rawValue }
    }

    public enum Resource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fileSystem = "FILE_SYSTEM"
        case mountTarget = "MOUNT_TARGET"
        public var description: String { return self.rawValue }
    }

    public enum ResourceIdType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case longId = "LONG_ID"
        case shortId = "SHORT_ID"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case disabling = "DISABLING"
        case enabled = "ENABLED"
        case enabling = "ENABLING"
        public var description: String { return self.rawValue }
    }

    public enum ThroughputMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bursting = "bursting"
        case elastic = "elastic"
        case provisioned = "provisioned"
        public var description: String { return self.rawValue }
    }

    public enum TransitionToArchiveRules: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after14Days = "AFTER_14_DAYS"
        case after180Days = "AFTER_180_DAYS"
        case after1Day = "AFTER_1_DAY"
        case after270Days = "AFTER_270_DAYS"
        case after30Days = "AFTER_30_DAYS"
        case after365Days = "AFTER_365_DAYS"
        case after60Days = "AFTER_60_DAYS"
        case after7Days = "AFTER_7_DAYS"
        case after90Days = "AFTER_90_DAYS"
        public var description: String { return self.rawValue }
    }

    public enum TransitionToIARules: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after14Days = "AFTER_14_DAYS"
        case after180Days = "AFTER_180_DAYS"
        case after1Day = "AFTER_1_DAY"
        case after270Days = "AFTER_270_DAYS"
        case after30Days = "AFTER_30_DAYS"
        case after365Days = "AFTER_365_DAYS"
        case after60Days = "AFTER_60_DAYS"
        case after7Days = "AFTER_7_DAYS"
        case after90Days = "AFTER_90_DAYS"
        public var description: String { return self.rawValue }
    }

    public enum TransitionToPrimaryStorageClassRules: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after1Access = "AFTER_1_ACCESS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPointAlreadyExists: AWSErrorShape {
        public let accessPointId: String
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(accessPointId: String, errorCode: String, message: String? = nil) {
            self.accessPointId = accessPointId
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointId = "AccessPointId"
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AccessPointDescription: AWSDecodableShape {
        /// The  unique Amazon Resource Name (ARN) associated with the access point.
        public let accessPointArn: String?
        /// The ID of the access point, assigned by Amazon EFS.
        public let accessPointId: String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public let clientToken: String?
        /// The ID of the EFS file system that the access point applies to.
        public let fileSystemId: String?
        /// Identifies the lifecycle phase of the access point.
        public let lifeCycleState: LifeCycleState?
        /// The name of the access point. This is the value of the Name tag.
        public let name: String?
        /// Identifies the Amazon Web Services account that owns the access point resource.
        public let ownerId: String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by NFS clients using the access point.
        public let posixUser: PosixUser?
        /// The directory on the EFS file system that the access point exposes as the root directory to NFS clients using the access point.
        public let rootDirectory: RootDirectory?
        /// The tags associated with the access point, presented as an array of Tag objects.
        public let tags: [Tag]?

        @inlinable
        public init(accessPointArn: String? = nil, accessPointId: String? = nil, clientToken: String? = nil, fileSystemId: String? = nil, lifeCycleState: LifeCycleState? = nil, name: String? = nil, ownerId: String? = nil, posixUser: PosixUser? = nil, rootDirectory: RootDirectory? = nil, tags: [Tag]? = nil) {
            self.accessPointArn = accessPointArn
            self.accessPointId = accessPointId
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.lifeCycleState = lifeCycleState
            self.name = name
            self.ownerId = ownerId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointArn = "AccessPointArn"
            case accessPointId = "AccessPointId"
            case clientToken = "ClientToken"
            case fileSystemId = "FileSystemId"
            case lifeCycleState = "LifeCycleState"
            case name = "Name"
            case ownerId = "OwnerId"
            case posixUser = "PosixUser"
            case rootDirectory = "RootDirectory"
            case tags = "Tags"
        }
    }

    public struct AccessPointLimitExceeded: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AccessPointNotFound: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AvailabilityZonesMismatch: AWSErrorShape {
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct BackupPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Describes the status of the file system's backup policy.     ENABLED – EFS is automatically backing up the file system.     ENABLING – EFS is turning on automatic backups for the file system.     DISABLED – Automatic back ups are turned off for the file system.     DISABLING – EFS is turning off automatic backups for the file system.
        public let status: Status

        @inlinable
        public init(status: Status) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct BackupPolicyDescription: AWSDecodableShape {
        /// Describes the file system's backup policy, indicating whether automatic backups are turned on or off.
        public let backupPolicy: BackupPolicy?

        @inlinable
        public init(backupPolicy: BackupPolicy? = nil) {
            self.backupPolicy = backupPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case backupPolicy = "BackupPolicy"
        }
    }

    public struct BadRequest: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct CreateAccessPointRequest: AWSEncodableShape {
        /// A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.
        public let clientToken: String
        /// The ID of the EFS file system that the access point provides access to.
        public let fileSystemId: String
        /// The operating system user and group applied to all file system requests made using the access point.
        public let posixUser: PosixUser?
        /// Specifies the directory on the EFS file system that the access point exposes as the root directory of your file system to NFS clients using the access point. The clients using the access point can only access the root directory and below. If the RootDirectory > Path specified does not exist, Amazon EFS creates it and applies the CreationInfo settings when a client connects to an access point. When specifying a RootDirectory, you must provide the Path, and the CreationInfo. Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.  If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount  using the access point will fail.
        public let rootDirectory: RootDirectory?
        /// Creates tags associated with the access point. Each tag is a key-value pair, each key must be unique. For more  information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String = CreateAccessPointRequest.idempotencyToken(), fileSystemId: String, posixUser: PosixUser? = nil, rootDirectory: RootDirectory? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^.+$")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.posixUser?.validate(name: "\(name).posixUser")
            try self.rootDirectory?.validate(name: "\(name).rootDirectory")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case fileSystemId = "FileSystemId"
            case posixUser = "PosixUser"
            case rootDirectory = "RootDirectory"
            case tags = "Tags"
        }
    }

    public struct CreateFileSystemRequest: AWSEncodableShape {
        /// For One Zone file systems, specify the Amazon Web Services Availability Zone in which to create the file system. Use the format us-east-1a to specify the  Availability Zone. For more information about One Zone file systems, see EFS file system types in the Amazon EFS User Guide.  One Zone file systems are not available in all Availability Zones in Amazon Web Services Regions where Amazon EFS is available.
        public let availabilityZoneName: String?
        /// Specifies whether automatic backups are enabled on the file system that you are creating. Set the value to true to enable automatic backups. If you are creating a One Zone file system, automatic backups are enabled by default. For more information, see Automatic backups in the Amazon EFS User Guide. Default is false. However, if you specify an AvailabilityZoneName,  the default is true.  Backup is not available in all Amazon Web Services Regions where Amazon EFS is available.
        public let backup: Bool?
        /// A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent creation.
        public let creationToken: String
        /// A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying an existing Key Management Service key (KMS key). If you don't specify a KMS key, then the default KMS key for Amazon EFS, /aws/elasticfilesystem, is used to protect the encrypted file system.
        public let encrypted: Bool?
        /// The ID of the KMS key that you want to use to protect the encrypted file system. This parameter is required only if you want to use a non-default KMS key. If this parameter is not specified, the default KMS key for Amazon EFS is used. You can specify a KMS key ID using the following formats:   Key ID - A unique identifier of the key, for example 1234abcd-12ab-34cd-56ef-1234567890ab.   ARN - An Amazon Resource Name (ARN) for the key, for example arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.   Key alias - A previously created display name for a key, for example alias/projectKey1.   Key alias ARN - An ARN for a key alias, for example arn:aws:kms:us-west-2:444455556666:alias/projectKey1.   If you use KmsKeyId, you must set the CreateFileSystemRequest$Encrypted  parameter to true.  EFS accepts only symmetric KMS keys. You cannot use asymmetric  KMS keys with Amazon EFS file systems.
        public let kmsKeyId: String?
        /// The performance mode of the file system. We recommend generalPurpose performance mode for all file systems. File systems using the maxIO performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created. The maxIO mode is not supported on One Zone file systems.  Due to the higher per-operation latencies with Max I/O, we recommend using General Purpose performance mode for all file systems.  Default is generalPurpose.
        public let performanceMode: PerformanceMode?
        /// The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ThroughputMode is set to provisioned. Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact Amazon Web Services Support. For more information, see Amazon EFS quotas that you can increase in the Amazon EFS User Guide.
        public let provisionedThroughputInMibps: Double?
        /// Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a "Key":"Name","Value":"{value}" key-value pair. Each key must be unique. For more  information, see Tagging Amazon Web Services resources in the Amazon Web Services General Reference Guide.
        public let tags: [Tag]?
        /// Specifies the throughput mode for the file system. The mode can be bursting, provisioned, or elastic. If you set ThroughputMode to provisioned, you must also set a value for ProvisionedThroughputInMibps. After you create the file system, you can decrease your file system's Provisioned throughput or change between the throughput modes, with certain time restrictions. For more information, see Specifying throughput with provisioned mode in the Amazon EFS User Guide.  Default is bursting.
        public let throughputMode: ThroughputMode?

        @inlinable
        public init(availabilityZoneName: String? = nil, backup: Bool? = nil, creationToken: String = CreateFileSystemRequest.idempotencyToken(), encrypted: Bool? = nil, kmsKeyId: String? = nil, performanceMode: PerformanceMode? = nil, provisionedThroughputInMibps: Double? = nil, tags: [Tag]? = nil, throughputMode: ThroughputMode? = nil) {
            self.availabilityZoneName = availabilityZoneName
            self.backup = backup
            self.creationToken = creationToken
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.performanceMode = performanceMode
            self.provisionedThroughputInMibps = provisionedThroughputInMibps
            self.tags = tags
            self.throughputMode = throughputMode
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZoneName, name: "availabilityZoneName", parent: name, max: 64)
            try self.validate(self.availabilityZoneName, name: "availabilityZoneName", parent: name, min: 1)
            try self.validate(self.availabilityZoneName, name: "availabilityZoneName", parent: name, pattern: "^.+$")
            try self.validate(self.creationToken, name: "creationToken", parent: name, max: 64)
            try self.validate(self.creationToken, name: "creationToken", parent: name, min: 1)
            try self.validate(self.creationToken, name: "creationToken", parent: name, pattern: "^.+$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|mrk-[0-9a-f]{32}|alias/[a-zA-Z0-9/_-]+|(arn:aws[-a-z]*:kms:[a-z0-9-]+:\\d{12}:((key/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})|(key/mrk-[0-9a-f]{32})|(alias/[a-zA-Z0-9/_-]+))))$")
            try self.validate(self.provisionedThroughputInMibps, name: "provisionedThroughputInMibps", parent: name, min: 1.0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneName = "AvailabilityZoneName"
            case backup = "Backup"
            case creationToken = "CreationToken"
            case encrypted = "Encrypted"
            case kmsKeyId = "KmsKeyId"
            case performanceMode = "PerformanceMode"
            case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
            case tags = "Tags"
            case throughputMode = "ThroughputMode"
        }
    }

    public struct CreateMountTargetRequest: AWSEncodableShape {
        /// The ID of the file system for which to create the mount target.
        public let fileSystemId: String
        /// Valid IPv4 address within the address range of the specified subnet.
        public let ipAddress: String?
        /// Up to five VPC security group IDs, of the form sg-xxxxxxxx. These must be for the same VPC as subnet specified.
        public let securityGroups: [String]?
        /// The ID of the subnet to add the mount target in. For One Zone  file systems, use the subnet that is associated with the file system's Availability Zone.
        public let subnetId: String

        @inlinable
        public init(fileSystemId: String, ipAddress: String? = nil, securityGroups: [String]? = nil, subnetId: String) {
            self.fileSystemId = fileSystemId
            self.ipAddress = ipAddress
            self.securityGroups = securityGroups
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, max: 15)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, min: 7)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, max: 43)
                try validate($0, name: "securityGroups[]", parent: name, min: 11)
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^sg-[0-9a-f]{8,40}$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 100)
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 47)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 15)
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "^subnet-[0-9a-f]{8,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "FileSystemId"
            case ipAddress = "IpAddress"
            case securityGroups = "SecurityGroups"
            case subnetId = "SubnetId"
        }
    }

    public struct CreateReplicationConfigurationRequest: AWSEncodableShape {
        /// An array of destination configuration objects. Only one destination configuration object is supported.
        public let destinations: [DestinationToCreate]
        /// Specifies the Amazon EFS file system that you want to replicate. This file system cannot already be  a source or destination file system in another replication configuration.
        public let sourceFileSystemId: String

        @inlinable
        public init(destinations: [DestinationToCreate], sourceFileSystemId: String) {
            self.destinations = destinations
            self.sourceFileSystemId = sourceFileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destinations, forKey: .destinations)
            request.encodePath(self.sourceFileSystemId, key: "SourceFileSystemId")
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.sourceFileSystemId, name: "sourceFileSystemId", parent: name, max: 128)
            try self.validate(self.sourceFileSystemId, name: "sourceFileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "Destinations"
        }
    }

    public struct CreateTagsRequest: AWSEncodableShape {
        /// The ID of the file system whose tags you want to modify (String). This operation modifies the tags only, not the file system.
        public let fileSystemId: String
        /// An array of Tag objects to add. Each Tag object is a key-value pair.
        public let tags: [Tag]

        @inlinable
        public init(fileSystemId: String, tags: [Tag]) {
            self.fileSystemId = fileSystemId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct CreationInfo: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
        public let ownerGid: Int64
        /// Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
        public let ownerUid: Int64
        /// Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
        public let permissions: String

        @inlinable
        public init(ownerGid: Int64, ownerUid: Int64, permissions: String) {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerGid, name: "ownerGid", parent: name, max: 4294967295)
            try self.validate(self.ownerGid, name: "ownerGid", parent: name, min: 0)
            try self.validate(self.ownerUid, name: "ownerUid", parent: name, max: 4294967295)
            try self.validate(self.ownerUid, name: "ownerUid", parent: name, min: 0)
            try self.validate(self.permissions, name: "permissions", parent: name, max: 4)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 3)
            try self.validate(self.permissions, name: "permissions", parent: name, pattern: "^[0-7]{3,4}$")
        }

        private enum CodingKeys: String, CodingKey {
            case ownerGid = "OwnerGid"
            case ownerUid = "OwnerUid"
            case permissions = "Permissions"
        }
    }

    public struct DeleteAccessPointRequest: AWSEncodableShape {
        /// The ID of the access point that you want to delete.
        public let accessPointId: String

        @inlinable
        public init(accessPointId: String) {
            self.accessPointId = accessPointId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPointId, key: "AccessPointId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, max: 128)
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}|fsap-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFileSystemPolicyRequest: AWSEncodableShape {
        /// Specifies the EFS file system for which to delete the FileSystemPolicy.
        public let fileSystemId: String

        @inlinable
        public init(fileSystemId: String) {
            self.fileSystemId = fileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFileSystemRequest: AWSEncodableShape {
        /// The ID of the file system you want to delete.
        public let fileSystemId: String

        @inlinable
        public init(fileSystemId: String) {
            self.fileSystemId = fileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMountTargetRequest: AWSEncodableShape {
        /// The ID of the mount target to delete (String).
        public let mountTargetId: String

        @inlinable
        public init(mountTargetId: String) {
            self.mountTargetId = mountTargetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mountTargetId, key: "MountTargetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, max: 45)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, min: 13)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, pattern: "^fsmt-[0-9a-f]{8,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReplicationConfigurationRequest: AWSEncodableShape {
        /// When replicating across Amazon Web Services accounts or across Amazon Web Services Regions,  Amazon EFS deletes the replication configuration from both the source  and destination account or Region (ALL_CONFIGURATIONS) by default.  If there's a configuration or permissions issue that prevents Amazon EFS from deleting the  replication configuration from both sides, you can use the LOCAL_CONFIGURATION_ONLY mode to delete the replication configuration from only the local side (the account or Region from which the delete is performed).   Only use the LOCAL_CONFIGURATION_ONLY mode in the case that Amazon EFS is unable to delete the replication configuration in both the source and destination account or Region.  Deleting the local configuration  leaves the configuration in the other account or Region unrecoverable. Additionally, do not use this mode for same-account, same-region replication as doing so results in a  BadRequest exception error.
        public let deletionMode: DeletionMode?
        /// The ID of the source file system in the replication configuration.
        public let sourceFileSystemId: String

        @inlinable
        public init(deletionMode: DeletionMode? = nil, sourceFileSystemId: String) {
            self.deletionMode = deletionMode
            self.sourceFileSystemId = sourceFileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deletionMode, key: "deletionMode")
            request.encodePath(self.sourceFileSystemId, key: "SourceFileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceFileSystemId, name: "sourceFileSystemId", parent: name, max: 128)
            try self.validate(self.sourceFileSystemId, name: "sourceFileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTagsRequest: AWSEncodableShape {
        /// The ID of the file system whose tags you want to delete (String).
        public let fileSystemId: String
        /// A list of tag keys to delete.
        public let tagKeys: [String]

        @inlinable
        public init(fileSystemId: String, tagKeys: [String]) {
            self.fileSystemId = fileSystemId
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?![aA]{1}[wW]{1}[sS]{1}:)([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
        }
    }

    public struct DependencyTimeout: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct DescribeAccessPointsRequest: AWSEncodableShape {
        /// (Optional) Specifies an EFS access point to describe in the response; mutually exclusive with FileSystemId.
        public let accessPointId: String?
        /// (Optional) If you provide a FileSystemId, EFS returns all access points for that file system; mutually exclusive with AccessPointId.
        public let fileSystemId: String?
        /// (Optional) When retrieving all access points for a file system, you can optionally specify the MaxItems parameter to limit the number of objects returned in a response.   The default value is 100.
        public let maxResults: Int?
        ///  NextToken is present if the response is paginated. You can use  NextMarker in the subsequent request to fetch the next page of access point descriptions.
        public let nextToken: String?

        @inlinable
        public init(accessPointId: String? = nil, fileSystemId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accessPointId = accessPointId
            self.fileSystemId = fileSystemId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accessPointId, key: "AccessPointId")
            request.encodeQuery(self.fileSystemId, key: "FileSystemId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, max: 128)
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}|fsap-[0-9a-f]{8,40})$")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccessPointsResponse: AWSDecodableShape {
        /// An array of access point descriptions.
        public let accessPoints: [AccessPointDescription]?
        /// Present if there are more access points than returned in the response.  You can use the NextMarker in the subsequent request to fetch the additional descriptions.
        public let nextToken: String?

        @inlinable
        public init(accessPoints: [AccessPointDescription]? = nil, nextToken: String? = nil) {
            self.accessPoints = accessPoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountPreferencesRequest: AWSEncodableShape {
        /// (Optional) When retrieving account preferences, you can optionally specify the MaxItems parameter to limit the number of objects returned in a response.   The default value is 100.
        public let maxResults: Int?
        /// (Optional) You can use NextToken in a subsequent request to fetch the next page of  Amazon Web Services account preferences if the response payload was paginated.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountPreferencesResponse: AWSDecodableShape {
        /// Present if there are more records than returned in the response.  You can use the NextToken in the subsequent request to fetch the additional descriptions.
        public let nextToken: String?
        /// Describes the resource ID preference setting for the Amazon Web Services account associated with the user making the request, in the current Amazon Web Services Region.
        public let resourceIdPreference: ResourceIdPreference?

        @inlinable
        public init(nextToken: String? = nil, resourceIdPreference: ResourceIdPreference? = nil) {
            self.nextToken = nextToken
            self.resourceIdPreference = resourceIdPreference
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceIdPreference = "ResourceIdPreference"
        }
    }

    public struct DescribeBackupPolicyRequest: AWSEncodableShape {
        /// Specifies which EFS file system for which to retrieve the BackupPolicy.
        public let fileSystemId: String

        @inlinable
        public init(fileSystemId: String) {
            self.fileSystemId = fileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFileSystemPolicyRequest: AWSEncodableShape {
        /// Specifies which EFS file system to retrieve the FileSystemPolicy for.
        public let fileSystemId: String

        @inlinable
        public init(fileSystemId: String) {
            self.fileSystemId = fileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFileSystemsRequest: AWSEncodableShape {
        /// (Optional) Restricts the list to the file system with this creation token (String). You specify a creation token when you create an Amazon EFS file system.
        public let creationToken: String?
        /// (Optional) ID of the file system whose description you want to retrieve (String).
        public let fileSystemId: String?
        /// (Optional) Opaque pagination token returned from a previous DescribeFileSystems operation (String). If present, specifies to continue the list from where the returning call had left off.
        public let marker: String?
        /// (Optional) Specifies the maximum number of file systems to return in the response (integer). This number is automatically set to 100. The response is paginated at 100 per page if you have more than 100 file systems.
        public let maxItems: Int?

        @inlinable
        public init(creationToken: String? = nil, fileSystemId: String? = nil, marker: String? = nil, maxItems: Int? = nil) {
            self.creationToken = creationToken
            self.fileSystemId = fileSystemId
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.creationToken, key: "CreationToken")
            request.encodeQuery(self.fileSystemId, key: "FileSystemId")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.creationToken, name: "creationToken", parent: name, max: 64)
            try self.validate(self.creationToken, name: "creationToken", parent: name, min: 1)
            try self.validate(self.creationToken, name: "creationToken", parent: name, pattern: "^.+$")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.marker, name: "marker", parent: name, max: 128)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^.+$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFileSystemsResponse: AWSDecodableShape {
        /// An array of file system descriptions.
        public let fileSystems: [FileSystemDescription]?
        /// Present if provided by caller in the request (String).
        public let marker: String?
        /// Present if there are more file systems than returned in the response (String). You can use the NextMarker in the subsequent request to fetch the descriptions.
        public let nextMarker: String?

        @inlinable
        public init(fileSystems: [FileSystemDescription]? = nil, marker: String? = nil, nextMarker: String? = nil) {
            self.fileSystems = fileSystems
            self.marker = marker
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystems = "FileSystems"
            case marker = "Marker"
            case nextMarker = "NextMarker"
        }
    }

    public struct DescribeLifecycleConfigurationRequest: AWSEncodableShape {
        /// The ID of the file system whose LifecycleConfiguration object you want to retrieve (String).
        public let fileSystemId: String

        @inlinable
        public init(fileSystemId: String) {
            self.fileSystemId = fileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMountTargetSecurityGroupsRequest: AWSEncodableShape {
        /// The ID of the mount target whose security groups you want to retrieve.
        public let mountTargetId: String

        @inlinable
        public init(mountTargetId: String) {
            self.mountTargetId = mountTargetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mountTargetId, key: "MountTargetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, max: 45)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, min: 13)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, pattern: "^fsmt-[0-9a-f]{8,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMountTargetSecurityGroupsResponse: AWSDecodableShape {
        /// An array of security groups.
        public let securityGroups: [String]

        @inlinable
        public init(securityGroups: [String]) {
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "SecurityGroups"
        }
    }

    public struct DescribeMountTargetsRequest: AWSEncodableShape {
        /// (Optional) The ID of the access point whose mount targets that you want to list. It must be included in your request if a FileSystemId or MountTargetId is not included in your request. Accepts either an access point ID or ARN as input.
        public let accessPointId: String?
        /// (Optional) ID of the file system whose mount targets you want to list (String). It must be included in your request if an AccessPointId or MountTargetId is not included. Accepts either a file system ID or ARN as input.
        public let fileSystemId: String?
        /// (Optional) Opaque pagination token returned from a previous DescribeMountTargets operation (String). If present, it specifies to continue the list from where the previous returning call left off.
        public let marker: String?
        /// (Optional) Maximum number of mount targets to return in the response. Currently, this number is automatically set to 10, and other values are ignored. The response is paginated at 100 per page if you have more than 100 mount targets.
        public let maxItems: Int?
        /// (Optional) ID of the mount target that you want to have described (String). It must be included in your request if FileSystemId is not included. Accepts either a mount target ID or ARN as input.
        public let mountTargetId: String?

        @inlinable
        public init(accessPointId: String? = nil, fileSystemId: String? = nil, marker: String? = nil, maxItems: Int? = nil, mountTargetId: String? = nil) {
            self.accessPointId = accessPointId
            self.fileSystemId = fileSystemId
            self.marker = marker
            self.maxItems = maxItems
            self.mountTargetId = mountTargetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accessPointId, key: "AccessPointId")
            request.encodeQuery(self.fileSystemId, key: "FileSystemId")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
            request.encodeQuery(self.mountTargetId, key: "MountTargetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, max: 128)
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}|fsap-[0-9a-f]{8,40})$")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.marker, name: "marker", parent: name, max: 128)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^.+$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, max: 45)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, min: 13)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, pattern: "^fsmt-[0-9a-f]{8,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMountTargetsResponse: AWSDecodableShape {
        /// If the request included the Marker, the response returns that value in this field.
        public let marker: String?
        /// Returns the file system's mount targets as an array of MountTargetDescription objects.
        public let mountTargets: [MountTargetDescription]?
        /// If a value is present, there are more mount targets to return. In a subsequent request, you can provide Marker in your request with this value to retrieve the next set of mount targets.
        public let nextMarker: String?

        @inlinable
        public init(marker: String? = nil, mountTargets: [MountTargetDescription]? = nil, nextMarker: String? = nil) {
            self.marker = marker
            self.mountTargets = mountTargets
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case mountTargets = "MountTargets"
            case nextMarker = "NextMarker"
        }
    }

    public struct DescribeReplicationConfigurationsRequest: AWSEncodableShape {
        /// You can retrieve the replication configuration for a specific file system by providing its file system ID. For cross-account,cross-region replication, an account can only describe the replication configuration for a file system in its own Region.
        public let fileSystemId: String?
        /// (Optional) To limit the number of objects returned in a response, you can specify the MaxItems parameter. The default value is 100.
        public let maxResults: Int?
        ///  NextToken is present if the response is paginated. You can use NextToken in a subsequent request to fetch the next page of output.
        public let nextToken: String?

        @inlinable
        public init(fileSystemId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.fileSystemId = fileSystemId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.fileSystemId, key: "FileSystemId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReplicationConfigurationsResponse: AWSDecodableShape {
        /// You can use the NextToken from the previous response in a subsequent  request to fetch the additional descriptions.
        public let nextToken: String?
        /// The collection of replication configurations that is returned.
        public let replications: [ReplicationConfigurationDescription]?

        @inlinable
        public init(nextToken: String? = nil, replications: [ReplicationConfigurationDescription]? = nil) {
            self.nextToken = nextToken
            self.replications = replications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case replications = "Replications"
        }
    }

    public struct DescribeTagsRequest: AWSEncodableShape {
        /// The ID of the file system whose tag set you want to retrieve.
        public let fileSystemId: String
        /// (Optional) An opaque pagination token returned from a previous DescribeTags operation (String). If present, it specifies to continue the list from where the previous call left off.
        public let marker: String?
        /// (Optional) The maximum number of file system tags to return in the response. Currently, this number is automatically set to 100, and other values are ignored. The response is paginated at 100 per page if you have more than 100 tags.
        public let maxItems: Int?

        @inlinable
        public init(fileSystemId: String, marker: String? = nil, maxItems: Int? = nil) {
            self.fileSystemId = fileSystemId
            self.marker = marker
            self.maxItems = maxItems
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            request.encodeQuery(self.marker, key: "Marker")
            request.encodeQuery(self.maxItems, key: "MaxItems")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.marker, name: "marker", parent: name, max: 128)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^.+$")
            try self.validate(self.maxItems, name: "maxItems", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTagsResponse: AWSDecodableShape {
        /// If the request included a Marker, the response returns that value in this field.
        public let marker: String?
        /// If a value is present, there are more tags to return. In a subsequent request, you can provide the value of NextMarker as the value of the Marker parameter in your next request to retrieve the next set of tags.
        public let nextMarker: String?
        /// Returns tags associated with the file system as an array of Tag objects.
        public let tags: [Tag]

        @inlinable
        public init(marker: String? = nil, nextMarker: String? = nil, tags: [Tag]) {
            self.marker = marker
            self.nextMarker = nextMarker
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case nextMarker = "NextMarker"
            case tags = "Tags"
        }
    }

    public struct Destination: AWSDecodableShape {
        /// The ID of the destination Amazon EFS file system.
        public let fileSystemId: String
        /// The time when the most recent sync was successfully completed on the destination file system. Any changes to data on the source file system that occurred before this time have been successfully replicated to the destination file system. Any changes that occurred after this time might not be fully replicated.
        public let lastReplicatedTimestamp: Date?
        /// ID of the Amazon Web Services account in which the destination file system resides.
        public let ownerId: String?
        /// The Amazon Web Services Region in which the destination file system is located.
        public let region: String
        /// Amazon Resource Name (ARN) of the IAM role in the source account that allows Amazon EFS to perform replication on its behalf. This is optional for same-account  replication and required for cross-account replication.
        public let roleArn: String?
        /// Describes the status of the replication configuration. For more information  about replication status, see Viewing replication details in the Amazon EFS User Guide.
        public let status: ReplicationStatus
        /// Message that provides details about the PAUSED or ERRROR state  of the replication destination configuration. For more information  about replication status messages, see Viewing replication details in the Amazon EFS User Guide.
        public let statusMessage: String?

        @inlinable
        public init(fileSystemId: String, lastReplicatedTimestamp: Date? = nil, ownerId: String? = nil, region: String, roleArn: String? = nil, status: ReplicationStatus, statusMessage: String? = nil) {
            self.fileSystemId = fileSystemId
            self.lastReplicatedTimestamp = lastReplicatedTimestamp
            self.ownerId = ownerId
            self.region = region
            self.roleArn = roleArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "FileSystemId"
            case lastReplicatedTimestamp = "LastReplicatedTimestamp"
            case ownerId = "OwnerId"
            case region = "Region"
            case roleArn = "RoleArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DestinationToCreate: AWSEncodableShape {
        /// To create a file system that uses One Zone storage, specify the name of the Availability Zone in which to create the destination file system.
        public let availabilityZoneName: String?
        /// The ID or ARN of the file system to use for the destination.  For cross-account replication, this must be an  ARN. The file system's  replication overwrite replication must be disabled. If no ID or ARN is  specified, then a new file system is created.
        public let fileSystemId: String?
        /// Specify the Key Management Service (KMS) key that you want to use to encrypt the destination file system. If you do not specify a KMS key, Amazon EFS uses your default KMS key for Amazon EFS, /aws/elasticfilesystem. This ID can be in one of the following formats:   Key ID - The unique identifier of the key, for example 1234abcd-12ab-34cd-56ef-1234567890ab.   ARN - The ARN for the key, for example arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.   Key alias - A previously created display name for a key, for example alias/projectKey1.   Key alias ARN - The ARN for a key alias, for example arn:aws:kms:us-west-2:444455556666:alias/projectKey1.
        public let kmsKeyId: String?
        /// To create a file system that uses Regional storage, specify the Amazon Web Services Region in which to create the destination file system. The Region must be enabled for the Amazon Web Services account that owns the source file system. For more information, see Managing Amazon Web Services Regions in the Amazon Web Services General Reference Reference Guide.
        public let region: String?
        /// Amazon Resource Name (ARN) of the IAM role in the source account that allows Amazon EFS to perform replication on its behalf. This is optional for same-account  replication and required for cross-account replication.
        public let roleArn: String?

        @inlinable
        public init(availabilityZoneName: String? = nil, fileSystemId: String? = nil, kmsKeyId: String? = nil, region: String? = nil, roleArn: String? = nil) {
            self.availabilityZoneName = availabilityZoneName
            self.fileSystemId = fileSystemId
            self.kmsKeyId = kmsKeyId
            self.region = region
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZoneName, name: "availabilityZoneName", parent: name, max: 64)
            try self.validate(self.availabilityZoneName, name: "availabilityZoneName", parent: name, min: 1)
            try self.validate(self.availabilityZoneName, name: "availabilityZoneName", parent: name, pattern: "^.+$")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|mrk-[0-9a-f]{32}|alias/[a-zA-Z0-9/_-]+|(arn:aws[-a-z]*:kms:[a-z0-9-]+:\\d{12}:((key/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})|(key/mrk-[0-9a-f]{32})|(alias/[a-zA-Z0-9/_-]+))))$")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-{0,1}[0-9]{0,1}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneName = "AvailabilityZoneName"
            case fileSystemId = "FileSystemId"
            case kmsKeyId = "KmsKeyId"
            case region = "Region"
            case roleArn = "RoleArn"
        }
    }

    public struct FileSystemAlreadyExists: AWSErrorShape {
        public let errorCode: String
        public let fileSystemId: String
        public let message: String?

        @inlinable
        public init(errorCode: String, fileSystemId: String, message: String? = nil) {
            self.errorCode = errorCode
            self.fileSystemId = fileSystemId
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case fileSystemId = "FileSystemId"
            case message = "Message"
        }
    }

    public struct FileSystemDescription: AWSDecodableShape {
        /// The unique and consistent identifier of the Availability Zone in which the file system is located, and is valid only for One Zone file systems. For example, use1-az1 is an Availability Zone ID for the us-east-1 Amazon Web Services Region, and it has the same location in every Amazon Web Services account.
        public let availabilityZoneId: String?
        /// Describes the Amazon Web Services Availability Zone in which the file system is located, and is valid only for One Zone file systems. For more information, see Using EFS storage classes in the Amazon EFS User Guide.
        public let availabilityZoneName: String?
        /// The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z).
        public let creationTime: Date
        /// The opaque string specified in the request.
        public let creationToken: String
        /// A Boolean value that, if true, indicates that the file system is encrypted.
        public let encrypted: Bool?
        /// The Amazon Resource Name (ARN) for the EFS file system, in the format arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id . Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
        public let fileSystemArn: String?
        /// The ID of the file system, assigned by Amazon EFS.
        public let fileSystemId: String
        /// Describes the protection on the file system.
        public let fileSystemProtection: FileSystemProtectionDescription?
        /// The ID of an KMS key used to protect the encrypted file system.
        public let kmsKeyId: String?
        /// The lifecycle phase of the file system.
        public let lifeCycleState: LifeCycleState
        /// You can add tags to a file system, including a Name tag. For more information, see CreateFileSystem. If the file system has a Name tag, Amazon EFS returns the value in this field.
        public let name: String?
        /// The current number of mount targets that the file system has. For more information, see CreateMountTarget.
        public let numberOfMountTargets: Int
        /// The Amazon Web Services account that created the file system.
        public let ownerId: String
        /// The performance mode of the file system.
        public let performanceMode: PerformanceMode
        /// The amount of provisioned throughput, measured in MiBps, for the file system. Valid for file systems using ThroughputMode set to provisioned.
        public let provisionedThroughputInMibps: Double?
        /// The latest known metered size (in bytes) of data stored in the file system, in its Value field, and the time at which that size was determined in its Timestamp field. The Timestamp value is the integer number of seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent the size of a consistent snapshot of the file system, but it is eventually consistent when there are no writes to the file system. That is, SizeInBytes represents actual size only if the file system is not modified for a period longer than a couple of hours. Otherwise, the value is not the exact size that the file system was at any point in time.
        public let sizeInBytes: FileSystemSize
        /// The tags associated with the file system, presented as an array of Tag objects.
        public let tags: [Tag]
        /// Displays the file system's throughput mode. For more information, see  Throughput modes  in the Amazon EFS User Guide.
        public let throughputMode: ThroughputMode?

        @inlinable
        public init(availabilityZoneId: String? = nil, availabilityZoneName: String? = nil, creationTime: Date, creationToken: String, encrypted: Bool? = nil, fileSystemArn: String? = nil, fileSystemId: String, fileSystemProtection: FileSystemProtectionDescription? = nil, kmsKeyId: String? = nil, lifeCycleState: LifeCycleState, name: String? = nil, numberOfMountTargets: Int, ownerId: String, performanceMode: PerformanceMode, provisionedThroughputInMibps: Double? = nil, sizeInBytes: FileSystemSize, tags: [Tag], throughputMode: ThroughputMode? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.availabilityZoneName = availabilityZoneName
            self.creationTime = creationTime
            self.creationToken = creationToken
            self.encrypted = encrypted
            self.fileSystemArn = fileSystemArn
            self.fileSystemId = fileSystemId
            self.fileSystemProtection = fileSystemProtection
            self.kmsKeyId = kmsKeyId
            self.lifeCycleState = lifeCycleState
            self.name = name
            self.numberOfMountTargets = numberOfMountTargets
            self.ownerId = ownerId
            self.performanceMode = performanceMode
            self.provisionedThroughputInMibps = provisionedThroughputInMibps
            self.sizeInBytes = sizeInBytes
            self.tags = tags
            self.throughputMode = throughputMode
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "AvailabilityZoneId"
            case availabilityZoneName = "AvailabilityZoneName"
            case creationTime = "CreationTime"
            case creationToken = "CreationToken"
            case encrypted = "Encrypted"
            case fileSystemArn = "FileSystemArn"
            case fileSystemId = "FileSystemId"
            case fileSystemProtection = "FileSystemProtection"
            case kmsKeyId = "KmsKeyId"
            case lifeCycleState = "LifeCycleState"
            case name = "Name"
            case numberOfMountTargets = "NumberOfMountTargets"
            case ownerId = "OwnerId"
            case performanceMode = "PerformanceMode"
            case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
            case sizeInBytes = "SizeInBytes"
            case tags = "Tags"
            case throughputMode = "ThroughputMode"
        }
    }

    public struct FileSystemInUse: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct FileSystemLimitExceeded: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct FileSystemNotFound: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct FileSystemPolicyDescription: AWSDecodableShape {
        /// Specifies the EFS file system to which the FileSystemPolicy applies.
        public let fileSystemId: String?
        /// The JSON formatted FileSystemPolicy for the EFS file system.
        public let policy: String?

        @inlinable
        public init(fileSystemId: String? = nil, policy: String? = nil) {
            self.fileSystemId = fileSystemId
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "FileSystemId"
            case policy = "Policy"
        }
    }

    public struct FileSystemProtectionDescription: AWSDecodableShape {
        /// The status of the file system's replication overwrite protection.    ENABLED – The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ENABLED by default.     DISABLED – The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication.    REPLICATING – The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication.   If the replication configuration is deleted, the file system's replication overwrite protection is re-enabled, the file system becomes writeable.
        public let replicationOverwriteProtection: ReplicationOverwriteProtection?

        @inlinable
        public init(replicationOverwriteProtection: ReplicationOverwriteProtection? = nil) {
            self.replicationOverwriteProtection = replicationOverwriteProtection
        }

        private enum CodingKeys: String, CodingKey {
            case replicationOverwriteProtection = "ReplicationOverwriteProtection"
        }
    }

    public struct FileSystemSize: AWSDecodableShape {
        /// The time at which the size of data, returned in the Value field, was determined. The value is the integer number of seconds since 1970-01-01T00:00:00Z.
        public let timestamp: Date?
        /// The latest known metered size (in bytes) of data stored in the file system.
        public let value: Int64
        /// The latest known metered size (in bytes) of data stored in the Archive storage class.
        public let valueInArchive: Int64?
        /// The latest known metered size (in bytes) of data stored in the Infrequent Access storage class.
        public let valueInIA: Int64?
        /// The latest known metered size (in bytes) of data stored in the Standard storage class.
        public let valueInStandard: Int64?

        @inlinable
        public init(timestamp: Date? = nil, value: Int64, valueInArchive: Int64? = nil, valueInIA: Int64? = nil, valueInStandard: Int64? = nil) {
            self.timestamp = timestamp
            self.value = value
            self.valueInArchive = valueInArchive
            self.valueInIA = valueInIA
            self.valueInStandard = valueInStandard
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case value = "Value"
            case valueInArchive = "ValueInArchive"
            case valueInIA = "ValueInIA"
            case valueInStandard = "ValueInStandard"
        }
    }

    public struct IncorrectFileSystemLifeCycleState: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct IncorrectMountTargetState: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct InsufficientThroughputCapacity: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct InternalServerError: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct InvalidPolicyException: AWSErrorShape {
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct IpAddressInUse: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct LifecycleConfigurationDescription: AWSDecodableShape {
        /// An array of lifecycle management policies. EFS supports a maximum of one policy per file system.
        public let lifecyclePolicies: [LifecyclePolicy]?

        @inlinable
        public init(lifecyclePolicies: [LifecyclePolicy]? = nil) {
            self.lifecyclePolicies = lifecyclePolicies
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicies = "LifecyclePolicies"
        }
    }

    public struct LifecyclePolicy: AWSEncodableShape & AWSDecodableShape {
        /// The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        public let transitionToArchive: TransitionToArchiveRules?
        /// The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Infrequent Access (IA) storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        public let transitionToIA: TransitionToIARules?
        /// Whether to move files back to primary (Standard) storage after they are accessed in IA or Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        public let transitionToPrimaryStorageClass: TransitionToPrimaryStorageClassRules?

        @inlinable
        public init(transitionToArchive: TransitionToArchiveRules? = nil, transitionToIA: TransitionToIARules? = nil, transitionToPrimaryStorageClass: TransitionToPrimaryStorageClassRules? = nil) {
            self.transitionToArchive = transitionToArchive
            self.transitionToIA = transitionToIA
            self.transitionToPrimaryStorageClass = transitionToPrimaryStorageClass
        }

        private enum CodingKeys: String, CodingKey {
            case transitionToArchive = "TransitionToArchive"
            case transitionToIA = "TransitionToIA"
            case transitionToPrimaryStorageClass = "TransitionToPrimaryStorageClass"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// (Optional) Specifies the maximum number of tag objects to return in the response. The default value is 100.
        public let maxResults: Int?
        /// (Optional) You can use NextToken in a subsequent request to fetch the next page of access point descriptions if the response payload was paginated.
        public let nextToken: String?
        /// Specifies the EFS resource you want to retrieve tags for. You can retrieve tags for EFS file systems and access points using this API endpoint.
        public let resourceId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:(access-point/fsap|file-system/fs)-[0-9a-f]{8,40}|fs(ap)?-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  NextToken is present if the response payload is paginated. You can use NextToken in a subsequent request to fetch the next page of access point descriptions.
        public let nextToken: String?
        /// An array of the tags for the specified EFS resource.
        public let tags: [Tag]?

        @inlinable
        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ModifyMountTargetSecurityGroupsRequest: AWSEncodableShape {
        /// The ID of the mount target whose security groups you want to modify.
        public let mountTargetId: String
        /// An array of up to five VPC security group IDs.
        public let securityGroups: [String]?

        @inlinable
        public init(mountTargetId: String, securityGroups: [String]? = nil) {
            self.mountTargetId = mountTargetId
            self.securityGroups = securityGroups
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mountTargetId, key: "MountTargetId")
            try container.encodeIfPresent(self.securityGroups, forKey: .securityGroups)
        }

        public func validate(name: String) throws {
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, max: 45)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, min: 13)
            try self.validate(self.mountTargetId, name: "mountTargetId", parent: name, pattern: "^fsmt-[0-9a-f]{8,40}$")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, max: 43)
                try validate($0, name: "securityGroups[]", parent: name, min: 11)
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^sg-[0-9a-f]{8,40}$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "SecurityGroups"
        }
    }

    public struct MountTargetConflict: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct MountTargetDescription: AWSDecodableShape {
        /// The unique and consistent identifier of the Availability Zone that the mount target resides in.  For example, use1-az1 is an AZ ID for the us-east-1 Region and it has the same location in every Amazon Web Services account.
        public let availabilityZoneId: String?
        /// The name of the Availability Zone in which the mount target is located. Availability Zones are  independently mapped to names for each Amazon Web Services account. For example, the Availability Zone  us-east-1a for your Amazon Web Services account might not be the same location as us-east-1a for another Amazon Web Services account.
        public let availabilityZoneName: String?
        /// The ID of the file system for which the mount target is intended.
        public let fileSystemId: String
        /// Address at which the file system can be mounted by using the mount target.
        public let ipAddress: String?
        /// Lifecycle state of the mount target.
        public let lifeCycleState: LifeCycleState
        /// System-assigned mount target ID.
        public let mountTargetId: String
        /// The ID of the network interface that Amazon EFS created when it created the mount target.
        public let networkInterfaceId: String?
        /// Amazon Web Services account ID that owns the resource.
        public let ownerId: String?
        /// The ID of the mount target's subnet.
        public let subnetId: String
        /// The virtual private cloud (VPC) ID that the mount target is configured in.
        public let vpcId: String?

        @inlinable
        public init(availabilityZoneId: String? = nil, availabilityZoneName: String? = nil, fileSystemId: String, ipAddress: String? = nil, lifeCycleState: LifeCycleState, mountTargetId: String, networkInterfaceId: String? = nil, ownerId: String? = nil, subnetId: String, vpcId: String? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.availabilityZoneName = availabilityZoneName
            self.fileSystemId = fileSystemId
            self.ipAddress = ipAddress
            self.lifeCycleState = lifeCycleState
            self.mountTargetId = mountTargetId
            self.networkInterfaceId = networkInterfaceId
            self.ownerId = ownerId
            self.subnetId = subnetId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "AvailabilityZoneId"
            case availabilityZoneName = "AvailabilityZoneName"
            case fileSystemId = "FileSystemId"
            case ipAddress = "IpAddress"
            case lifeCycleState = "LifeCycleState"
            case mountTargetId = "MountTargetId"
            case networkInterfaceId = "NetworkInterfaceId"
            case ownerId = "OwnerId"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
        }
    }

    public struct MountTargetNotFound: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct NetworkInterfaceLimitExceeded: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct NoFreeAddressesInSubnet: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct PolicyNotFound: AWSErrorShape {
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct PosixUser: AWSEncodableShape & AWSDecodableShape {
        /// The POSIX group ID used for all file system operations using this access point.
        public let gid: Int64
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public let secondaryGids: [Int64]?
        /// The POSIX user ID used for all file system operations using this access point.
        public let uid: Int64

        @inlinable
        public init(gid: Int64, secondaryGids: [Int64]? = nil, uid: Int64) {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.validate(self.gid, name: "gid", parent: name, max: 4294967295)
            try self.validate(self.gid, name: "gid", parent: name, min: 0)
            try self.secondaryGids?.forEach {
                try validate($0, name: "secondaryGids[]", parent: name, max: 4294967295)
                try validate($0, name: "secondaryGids[]", parent: name, min: 0)
            }
            try self.validate(self.secondaryGids, name: "secondaryGids", parent: name, max: 16)
            try self.validate(self.uid, name: "uid", parent: name, max: 4294967295)
            try self.validate(self.uid, name: "uid", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case gid = "Gid"
            case secondaryGids = "SecondaryGids"
            case uid = "Uid"
        }
    }

    public struct PutAccountPreferencesRequest: AWSEncodableShape {
        /// Specifies the EFS resource ID preference to set for the user's Amazon Web Services account, in the current Amazon Web Services Region, either LONG_ID (17 characters), or SHORT_ID (8 characters).  Starting in October, 2021, you will receive an error when setting the account preference to SHORT_ID. Contact Amazon Web Services support if you receive an error and must use short IDs for file system and mount target resources.
        public let resourceIdType: ResourceIdType

        @inlinable
        public init(resourceIdType: ResourceIdType) {
            self.resourceIdType = resourceIdType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdType = "ResourceIdType"
        }
    }

    public struct PutAccountPreferencesResponse: AWSDecodableShape {
        public let resourceIdPreference: ResourceIdPreference?

        @inlinable
        public init(resourceIdPreference: ResourceIdPreference? = nil) {
            self.resourceIdPreference = resourceIdPreference
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdPreference = "ResourceIdPreference"
        }
    }

    public struct PutBackupPolicyRequest: AWSEncodableShape {
        /// The backup policy included in the PutBackupPolicy request.
        public let backupPolicy: BackupPolicy
        /// Specifies which EFS file system to update the backup policy for.
        public let fileSystemId: String

        @inlinable
        public init(backupPolicy: BackupPolicy, fileSystemId: String) {
            self.backupPolicy = backupPolicy
            self.fileSystemId = fileSystemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.backupPolicy, forKey: .backupPolicy)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPolicy = "BackupPolicy"
        }
    }

    public struct PutFileSystemPolicyRequest: AWSEncodableShape {
        /// (Optional) A boolean that specifies whether or not to bypass the FileSystemPolicy lockout safety check. The lockout safety check  determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future PutFileSystemPolicy requests on this file system. Set BypassPolicyLockoutSafetyCheck to True only when you intend to prevent  the IAM principal that is making the request from making subsequent PutFileSystemPolicy requests on this file system.  The default value is False.
        public let bypassPolicyLockoutSafetyCheck: Bool?
        /// The ID of the EFS file system that you want to create or update the FileSystemPolicy for.
        public let fileSystemId: String
        /// The FileSystemPolicy that you're creating. Accepts a JSON formatted policy definition. EFS file system policies have a 20,000 character limit. To find out more about the elements that make up a file system policy, see Resource-based policies within Amazon EFS.
        public let policy: String

        @inlinable
        public init(bypassPolicyLockoutSafetyCheck: Bool? = nil, fileSystemId: String, policy: String) {
            self.bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheck
            self.fileSystemId = fileSystemId
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.bypassPolicyLockoutSafetyCheck, forKey: .bypassPolicyLockoutSafetyCheck)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            try container.encode(self.policy, forKey: .policy)
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
            case policy = "Policy"
        }
    }

    public struct PutLifecycleConfigurationRequest: AWSEncodableShape {
        /// The ID of the file system for which you are creating the LifecycleConfiguration object (String).
        public let fileSystemId: String
        /// An array of LifecyclePolicy objects that define the file system's LifecycleConfiguration object. A LifecycleConfiguration object informs lifecycle management of the following:     TransitionToIA –  When to move files in the file system from primary storage (Standard storage class) into the Infrequent Access  (IA) storage.     TransitionToArchive – When to move files in the file system from their current storage class (either IA or Standard storage) into the  Archive storage. File systems cannot transition into Archive storage before transitioning into IA  storage. Therefore,   TransitionToArchive must either not be set or must be later than TransitionToIA.  The Archive storage class is available only for file systems that use the Elastic throughput mode
        /// and the General Purpose performance mode.       TransitionToPrimaryStorageClass – Whether to move files in the file system back to primary storage (Standard storage class) after they are accessed in IA or Archive storage.    When using the put-lifecycle-configuration CLI command or the PutLifecycleConfiguration API action, Amazon EFS requires that each LifecyclePolicy object have only a single transition. This means that in a request body, LifecyclePolicies must be structured as an array of LifecyclePolicy objects, one object for each storage transition. See the example requests in the following section for more information.
        public let lifecyclePolicies: [LifecyclePolicy]

        @inlinable
        public init(fileSystemId: String, lifecyclePolicies: [LifecyclePolicy]) {
            self.fileSystemId = fileSystemId
            self.lifecyclePolicies = lifecyclePolicies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            try container.encode(self.lifecyclePolicies, forKey: .lifecyclePolicies)
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.lifecyclePolicies, name: "lifecyclePolicies", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicies = "LifecyclePolicies"
        }
    }

    public struct ReplicationAlreadyExists: AWSErrorShape {
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ReplicationConfigurationDescription: AWSDecodableShape {
        /// Describes when the replication configuration was created.
        public let creationTime: Date
        /// An array of destination objects. Only one destination object is supported.
        public let destinations: [Destination]
        /// The Amazon Resource Name (ARN) of the original source EFS file system in the replication configuration.
        public let originalSourceFileSystemArn: String
        /// The Amazon Resource Name (ARN) of the current source file system in the replication configuration.
        public let sourceFileSystemArn: String
        /// The ID of the source Amazon EFS file system that is being replicated.
        public let sourceFileSystemId: String
        /// ID of the Amazon Web Services account in which the source file system resides.
        public let sourceFileSystemOwnerId: String?
        /// The Amazon Web Services Region in which the source EFS file system is located.
        public let sourceFileSystemRegion: String

        @inlinable
        public init(creationTime: Date, destinations: [Destination], originalSourceFileSystemArn: String, sourceFileSystemArn: String, sourceFileSystemId: String, sourceFileSystemOwnerId: String? = nil, sourceFileSystemRegion: String) {
            self.creationTime = creationTime
            self.destinations = destinations
            self.originalSourceFileSystemArn = originalSourceFileSystemArn
            self.sourceFileSystemArn = sourceFileSystemArn
            self.sourceFileSystemId = sourceFileSystemId
            self.sourceFileSystemOwnerId = sourceFileSystemOwnerId
            self.sourceFileSystemRegion = sourceFileSystemRegion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destinations = "Destinations"
            case originalSourceFileSystemArn = "OriginalSourceFileSystemArn"
            case sourceFileSystemArn = "SourceFileSystemArn"
            case sourceFileSystemId = "SourceFileSystemId"
            case sourceFileSystemOwnerId = "SourceFileSystemOwnerId"
            case sourceFileSystemRegion = "SourceFileSystemRegion"
        }
    }

    public struct ReplicationNotFound: AWSErrorShape {
        /// ReplicationNotFound
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ResourceIdPreference: AWSDecodableShape {
        /// Identifies the EFS resource ID preference, either LONG_ID (17 characters) or SHORT_ID (8 characters).
        public let resourceIdType: ResourceIdType?
        /// Identifies the Amazon EFS resources to which the ID preference setting applies, FILE_SYSTEM and MOUNT_TARGET.
        public let resources: [Resource]?

        @inlinable
        public init(resourceIdType: ResourceIdType? = nil, resources: [Resource]? = nil) {
            self.resourceIdType = resourceIdType
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdType = "ResourceIdType"
            case resources = "Resources"
        }
    }

    public struct RootDirectory: AWSEncodableShape & AWSDecodableShape {
        /// (Optional) Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory. If the RootDirectory > Path specified does not exist, EFS creates the root directory using the CreationInfo settings when a client connects to an access point. When specifying the CreationInfo, you must provide values for all properties.   If you do not provide CreationInfo and the specified RootDirectory > Path does not exist,  attempts to mount the file system using the access point will fail.
        public let creationInfo: CreationInfo?
        /// Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the CreationInfo.
        public let path: String?

        @inlinable
        public init(creationInfo: CreationInfo? = nil, path: String? = nil) {
            self.creationInfo = creationInfo
            self.path = path
        }

        public func validate(name: String) throws {
            try self.creationInfo?.validate(name: "\(name).creationInfo")
            try self.validate(self.path, name: "path", parent: name, max: 100)
            try self.validate(self.path, name: "path", parent: name, min: 1)
            try self.validate(self.path, name: "path", parent: name, pattern: "^(\\/|(\\/(?!\\.)+[^$#<>;`|&?{}^*/\\n]+){1,4})$")
        }

        private enum CodingKeys: String, CodingKey {
            case creationInfo = "CreationInfo"
            case path = "Path"
        }
    }

    public struct SecurityGroupLimitExceeded: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct SecurityGroupNotFound: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct SubnetNotFound: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key (String). The key can't start with aws:.
        public let key: String
        /// The value of the tag key.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?![aA]{1}[wW]{1}[sS]{1}:)([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ID specifying the EFS resource that you want to create a tag for.
        public let resourceId: String
        /// An array of Tag objects to add. Each Tag object is a key-value pair.
        public let tags: [Tag]

        @inlinable
        public init(resourceId: String, tags: [Tag]) {
            self.resourceId = resourceId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceId, key: "ResourceId")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:(access-point/fsap|file-system/fs)-[0-9a-f]{8,40}|fs(ap)?-[0-9a-f]{8,40})$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let errorCode: String?
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct ThroughputLimitExceeded: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct TooManyRequests: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct UnsupportedAvailabilityZone: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Specifies the EFS resource that you want to remove tags from.
        public let resourceId: String
        /// The keys of the key-value tag pairs that you want to remove from the specified EFS resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceId: String, tagKeys: [String]) {
            self.resourceId = resourceId
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceId, key: "ResourceId")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:(access-point/fsap|file-system/fs)-[0-9a-f]{8,40}|fs(ap)?-[0-9a-f]{8,40})$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?![aA]{1}[wW]{1}[sS]{1}:)([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateFileSystemProtectionRequest: AWSEncodableShape {
        /// The ID of the file system to update.
        public let fileSystemId: String
        /// The status of the file system's replication overwrite protection.    ENABLED – The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ENABLED by default.     DISABLED – The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication.    REPLICATING – The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication.   If the replication configuration is deleted, the file system's replication overwrite protection is re-enabled and the file system becomes writeable.
        public let replicationOverwriteProtection: ReplicationOverwriteProtection?

        @inlinable
        public init(fileSystemId: String, replicationOverwriteProtection: ReplicationOverwriteProtection? = nil) {
            self.fileSystemId = fileSystemId
            self.replicationOverwriteProtection = replicationOverwriteProtection
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            try container.encodeIfPresent(self.replicationOverwriteProtection, forKey: .replicationOverwriteProtection)
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationOverwriteProtection = "ReplicationOverwriteProtection"
        }
    }

    public struct UpdateFileSystemRequest: AWSEncodableShape {
        /// The ID of the file system that you want to update.
        public let fileSystemId: String
        /// (Optional) The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ThroughputMode is set to provisioned. Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact Amazon Web Services Support. For more information, see Amazon EFS quotas that you can increase in the Amazon EFS User Guide.
        public let provisionedThroughputInMibps: Double?
        /// (Optional) Updates the file system's throughput mode. If you're not updating your throughput mode, you don't need to provide this value in your request. If you are changing the ThroughputMode to provisioned,  you must also set a value for ProvisionedThroughputInMibps.
        public let throughputMode: ThroughputMode?

        @inlinable
        public init(fileSystemId: String, provisionedThroughputInMibps: Double? = nil, throughputMode: ThroughputMode? = nil) {
            self.fileSystemId = fileSystemId
            self.provisionedThroughputInMibps = provisionedThroughputInMibps
            self.throughputMode = throughputMode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileSystemId, key: "FileSystemId")
            try container.encodeIfPresent(self.provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
            try container.encodeIfPresent(self.throughputMode, forKey: .throughputMode)
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, max: 128)
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$")
            try self.validate(self.provisionedThroughputInMibps, name: "provisionedThroughputInMibps", parent: name, min: 1.0)
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
            case throughputMode = "ThroughputMode"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let errorCode: String
        public let message: String?

        @inlinable
        public init(errorCode: String, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }
}

// MARK: - Errors

/// Error enum for EFS
public struct EFSErrorType: AWSErrorType {
    enum Code: String {
        case accessPointAlreadyExists = "AccessPointAlreadyExists"
        case accessPointLimitExceeded = "AccessPointLimitExceeded"
        case accessPointNotFound = "AccessPointNotFound"
        case availabilityZonesMismatch = "AvailabilityZonesMismatch"
        case badRequest = "BadRequest"
        case conflictException = "ConflictException"
        case dependencyTimeout = "DependencyTimeout"
        case fileSystemAlreadyExists = "FileSystemAlreadyExists"
        case fileSystemInUse = "FileSystemInUse"
        case fileSystemLimitExceeded = "FileSystemLimitExceeded"
        case fileSystemNotFound = "FileSystemNotFound"
        case incorrectFileSystemLifeCycleState = "IncorrectFileSystemLifeCycleState"
        case incorrectMountTargetState = "IncorrectMountTargetState"
        case insufficientThroughputCapacity = "InsufficientThroughputCapacity"
        case internalServerError = "InternalServerError"
        case invalidPolicyException = "InvalidPolicyException"
        case ipAddressInUse = "IpAddressInUse"
        case mountTargetConflict = "MountTargetConflict"
        case mountTargetNotFound = "MountTargetNotFound"
        case networkInterfaceLimitExceeded = "NetworkInterfaceLimitExceeded"
        case noFreeAddressesInSubnet = "NoFreeAddressesInSubnet"
        case policyNotFound = "PolicyNotFound"
        case replicationAlreadyExists = "ReplicationAlreadyExists"
        case replicationNotFound = "ReplicationNotFound"
        case securityGroupLimitExceeded = "SecurityGroupLimitExceeded"
        case securityGroupNotFound = "SecurityGroupNotFound"
        case subnetNotFound = "SubnetNotFound"
        case throttlingException = "ThrottlingException"
        case throughputLimitExceeded = "ThroughputLimitExceeded"
        case tooManyRequests = "TooManyRequests"
        case unsupportedAvailabilityZone = "UnsupportedAvailabilityZone"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize EFS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Returned if the access point that you are trying to create already exists, with the creation token you provided in the request.
    public static var accessPointAlreadyExists: Self { .init(.accessPointAlreadyExists) }
    /// Returned if the Amazon Web Services account has already created the maximum number of access points allowed per file system. For more informaton, see https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region.
    public static var accessPointLimitExceeded: Self { .init(.accessPointLimitExceeded) }
    /// Returned if the specified AccessPointId value doesn't exist in the requester's Amazon Web Services account.
    public static var accessPointNotFound: Self { .init(.accessPointNotFound) }
    /// Returned if the Availability Zone that was specified for a mount target is  different from the Availability Zone that was specified for One Zone storage. For more information, see Regional and One Zone storage redundancy.
    public static var availabilityZonesMismatch: Self { .init(.availabilityZonesMismatch) }
    /// Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.
    public static var badRequest: Self { .init(.badRequest) }
    /// Returned if the source file system in a replication is encrypted but the destination file system is unencrypted.
    public static var conflictException: Self { .init(.conflictException) }
    /// The service timed out trying to fulfill the request, and the client should try the call again.
    public static var dependencyTimeout: Self { .init(.dependencyTimeout) }
    /// Returned if the file system you are trying to create already exists, with the creation token you provided.
    public static var fileSystemAlreadyExists: Self { .init(.fileSystemAlreadyExists) }
    /// Returned if a file system has mount targets.
    public static var fileSystemInUse: Self { .init(.fileSystemInUse) }
    /// Returned if the Amazon Web Services account has already created the maximum number of file systems allowed per account.
    public static var fileSystemLimitExceeded: Self { .init(.fileSystemLimitExceeded) }
    /// Returned if the specified FileSystemId value doesn't exist in the requester's Amazon Web Services account.
    public static var fileSystemNotFound: Self { .init(.fileSystemNotFound) }
    /// Returned if the file system's lifecycle state is not "available".
    public static var incorrectFileSystemLifeCycleState: Self { .init(.incorrectFileSystemLifeCycleState) }
    /// Returned if the mount target is not in the correct state for the operation.
    public static var incorrectMountTargetState: Self { .init(.incorrectMountTargetState) }
    /// Returned if there's not enough capacity to provision additional throughput. This value might be returned when you try to create a file system in provisioned throughput mode, when you attempt to increase the provisioned throughput of an existing file system, or when you attempt to change an existing file system from Bursting Throughput to Provisioned Throughput mode. Try again later.
    public static var insufficientThroughputCapacity: Self { .init(.insufficientThroughputCapacity) }
    /// Returned if an error occurred on the server side.
    public static var internalServerError: Self { .init(.internalServerError) }
    /// Returned if the FileSystemPolicy is malformed or contains an error such as a parameter value that is not valid or a missing required parameter. Returned in the case of a policy lockout safety check error.
    public static var invalidPolicyException: Self { .init(.invalidPolicyException) }
    /// Returned if the request specified an IpAddress that is already in use in the subnet.
    public static var ipAddressInUse: Self { .init(.ipAddressInUse) }
    /// Returned if the mount target would violate one of the specified restrictions based on the file system's existing mount targets.
    public static var mountTargetConflict: Self { .init(.mountTargetConflict) }
    /// Returned if there is no mount target with the specified ID found in the caller's Amazon Web Services account.
    public static var mountTargetNotFound: Self { .init(.mountTargetNotFound) }
    /// The calling account has reached the limit for elastic network interfaces for the specific Amazon Web Services Region. Either delete some network interfaces or request that the account quota be raised. For more information, see Amazon VPC Quotas in the Amazon VPC User Guide (see the Network interfaces per Region entry in the Network interfaces table).
    public static var networkInterfaceLimitExceeded: Self { .init(.networkInterfaceLimitExceeded) }
    /// Returned if IpAddress was not specified in the request and there are no free IP addresses in the subnet.
    public static var noFreeAddressesInSubnet: Self { .init(.noFreeAddressesInSubnet) }
    /// Returned if the default file system policy is in effect for the EFS file system specified.
    public static var policyNotFound: Self { .init(.policyNotFound) }
    /// Returned if the file system is already included in a replication configuration.>
    public static var replicationAlreadyExists: Self { .init(.replicationAlreadyExists) }
    /// Returned if the specified file system does not have a replication configuration.
    public static var replicationNotFound: Self { .init(.replicationNotFound) }
    /// Returned if the size of SecurityGroups specified in the request is greater than five.
    public static var securityGroupLimitExceeded: Self { .init(.securityGroupLimitExceeded) }
    /// Returned if one of the specified security groups doesn't exist in the subnet's virtual private cloud (VPC).
    public static var securityGroupNotFound: Self { .init(.securityGroupNotFound) }
    /// Returned if there is no subnet with ID SubnetId provided in the request.
    public static var subnetNotFound: Self { .init(.subnetNotFound) }
    /// Returned when the CreateAccessPoint API action is called too quickly and  the number of Access Points on the file system is nearing the  limit of 120.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Returned if the throughput mode or amount of provisioned throughput can't be changed because the throughput limit of 1024 MiB/s has been reached.
    public static var throughputLimitExceeded: Self { .init(.throughputLimitExceeded) }
    /// Returned if you don’t wait at least 24 hours before either changing the throughput mode, or decreasing the Provisioned Throughput value.
    public static var tooManyRequests: Self { .init(.tooManyRequests) }
    /// Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.
    public static var unsupportedAvailabilityZone: Self { .init(.unsupportedAvailabilityZone) }
    /// Returned if the Backup service is not available in the Amazon Web Services Region in which the request was made.
    public static var validationException: Self { .init(.validationException) }
}

extension EFSErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessPointAlreadyExists": EFS.AccessPointAlreadyExists.self,
        "AccessPointLimitExceeded": EFS.AccessPointLimitExceeded.self,
        "AccessPointNotFound": EFS.AccessPointNotFound.self,
        "AvailabilityZonesMismatch": EFS.AvailabilityZonesMismatch.self,
        "BadRequest": EFS.BadRequest.self,
        "ConflictException": EFS.ConflictException.self,
        "DependencyTimeout": EFS.DependencyTimeout.self,
        "FileSystemAlreadyExists": EFS.FileSystemAlreadyExists.self,
        "FileSystemInUse": EFS.FileSystemInUse.self,
        "FileSystemLimitExceeded": EFS.FileSystemLimitExceeded.self,
        "FileSystemNotFound": EFS.FileSystemNotFound.self,
        "IncorrectFileSystemLifeCycleState": EFS.IncorrectFileSystemLifeCycleState.self,
        "IncorrectMountTargetState": EFS.IncorrectMountTargetState.self,
        "InsufficientThroughputCapacity": EFS.InsufficientThroughputCapacity.self,
        "InternalServerError": EFS.InternalServerError.self,
        "InvalidPolicyException": EFS.InvalidPolicyException.self,
        "IpAddressInUse": EFS.IpAddressInUse.self,
        "MountTargetConflict": EFS.MountTargetConflict.self,
        "MountTargetNotFound": EFS.MountTargetNotFound.self,
        "NetworkInterfaceLimitExceeded": EFS.NetworkInterfaceLimitExceeded.self,
        "NoFreeAddressesInSubnet": EFS.NoFreeAddressesInSubnet.self,
        "PolicyNotFound": EFS.PolicyNotFound.self,
        "ReplicationAlreadyExists": EFS.ReplicationAlreadyExists.self,
        "ReplicationNotFound": EFS.ReplicationNotFound.self,
        "SecurityGroupLimitExceeded": EFS.SecurityGroupLimitExceeded.self,
        "SecurityGroupNotFound": EFS.SecurityGroupNotFound.self,
        "SubnetNotFound": EFS.SubnetNotFound.self,
        "ThrottlingException": EFS.ThrottlingException.self,
        "ThroughputLimitExceeded": EFS.ThroughputLimitExceeded.self,
        "TooManyRequests": EFS.TooManyRequests.self,
        "UnsupportedAvailabilityZone": EFS.UnsupportedAvailabilityZone.self,
        "ValidationException": EFS.ValidationException.self
    ]
}

extension EFSErrorType: Equatable {
    public static func == (lhs: EFSErrorType, rhs: EFSErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension EFSErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
