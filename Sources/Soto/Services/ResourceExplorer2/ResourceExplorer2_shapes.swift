//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ResourceExplorer2 {
    // MARK: Enums

    public enum AWSServiceAccessStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum IndexState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Index is active.
        case active = "ACTIVE"
        /// Resource Explorer is creating the index.
        case creating = "CREATING"
        /// Resource Explorer successfully deleted the index.
        case deleted = "DELETED"
        /// Resource Explorer is deleting the index.
        case deleting = "DELETING"
        /// Resource Explorer is switching the index type between local and aggregator.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum IndexType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// aggregator index
        case aggregator = "AGGREGATOR"
        /// local index
        case local = "LOCAL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateDefaultViewInput: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the view to set as the default for the Amazon Web Services Region and Amazon Web Services account in which you call this operation. The specified view must already exist in the called Region.
        public let viewArn: String

        public init(viewArn: String) {
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case viewArn = "ViewArn"
        }
    }

    public struct AssociateDefaultViewOutput: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the view that the operation set as the default for queries made in the Amazon Web Services Region and Amazon Web Services account in which you called this operation.
        public let viewArn: String?

        public init(viewArn: String? = nil) {
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case viewArn = "ViewArn"
        }
    }

    public struct BatchGetViewError: AWSDecodableShape {
        /// The description of the error for the specified view.
        public let errorMessage: String
        /// The Amazon resource name (ARN) of the view for which Resource Explorer failed to retrieve details.
        public let viewArn: String

        public init(errorMessage: String, viewArn: String) {
            self.errorMessage = errorMessage
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case viewArn = "ViewArn"
        }
    }

    public struct BatchGetViewInput: AWSEncodableShape {
        /// A list of Amazon resource names (ARNs) that identify the views you want details for.
        public let viewArns: [String]?

        public init(viewArns: [String]? = nil) {
            self.viewArns = viewArns
        }

        private enum CodingKeys: String, CodingKey {
            case viewArns = "ViewArns"
        }
    }

    public struct BatchGetViewOutput: AWSDecodableShape {
        /// If any of the specified ARNs result in an error, then this structure describes the error.
        public let errors: [BatchGetViewError]?
        /// A structure with a list of objects with details for each of the specified views.
        public let views: [View]?

        public init(errors: [BatchGetViewError]? = nil, views: [View]? = nil) {
            self.errors = errors
            self.views = views
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case views = "Views"
        }
    }

    public struct CreateIndexInput: AWSEncodableShape {
        /// This value helps ensure idempotency. Resource Explorer uses this value to prevent the accidental creation of duplicate versions. We recommend that you generate a UUID-type value to ensure the uniqueness of your index.
        public let clientToken: String?
        /// The specified tags are attached only to the index created in this Amazon Web Services Region. The tags aren't attached to any of the resources listed in the index.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateIndexInput.idempotencyToken(), tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateIndexOutput: AWSDecodableShape {
        /// The ARN of the new local index for the Region. You can reference this ARN in IAM permission policies to authorize the following operations: DeleteIndex | GetIndex | UpdateIndexType | CreateView
        public let arn: String?
        /// The date and timestamp when the index was created.
        public let createdAt: Date?
        /// Indicates the current state of the index. You can check for changes to the state for asynchronous operations by calling the GetIndex operation.  The state can remain in the CREATING or UPDATING state for several hours as Resource Explorer discovers the information about your resources and populates the index.
        public let state: IndexState?

        public init(arn: String? = nil, createdAt: Date? = nil, state: IndexState? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case state = "State"
        }
    }

    public struct CreateViewInput: AWSEncodableShape {
        /// This value helps ensure idempotency. Resource Explorer uses this value to prevent the accidental creation of duplicate versions. We recommend that you generate a UUID-type value to ensure the uniqueness of your views.
        public let clientToken: String?
        /// An array of strings that specify which resources are included in the results of  queries made using this view. When you use this view in a Search  operation, the filter string is combined with the search's QueryString  parameter using a logical AND operator. For information about the supported syntax, see Search query reference for Resource Explorer in the Amazon Web Services Resource Explorer User Guide.  This query string in the context of this operation supports only filter prefixes with optional operators. It doesn't support free-form text. For example, the  string region:us* service:ec2 -tag:stage=prod includes all Amazon EC2  resources in any Amazon Web Services Region that begins with the letters us and is not tagged with a key Stage that has the value prod.
        public let filters: SearchFilter?
        /// Specifies optional fields that you want included in search results from this view. It is a list of objects that each describe a field to include. The default is an empty list, with no optional fields included in the results.
        public let includedProperties: [IncludedProperty]?
        /// The root ARN of the account, an organizational unit (OU), or an organization ARN. If left empty, the default is account.
        public let scope: String?
        /// Tag key and value pairs that are attached to the view.
        public let tags: [String: String]?
        /// The name of the new view. This name appears in the list of views in Resource Explorer. The name must be no more than 64 characters long, and can include letters, digits, and the dash (-) character. The name must be unique within its Amazon Web Services Region.
        public let viewName: String

        public init(clientToken: String? = CreateViewInput.idempotencyToken(), filters: SearchFilter? = nil, includedProperties: [IncludedProperty]? = nil, scope: String? = nil, tags: [String: String]? = nil, viewName: String) {
            self.clientToken = clientToken
            self.filters = filters
            self.includedProperties = includedProperties
            self.scope = scope
            self.tags = tags
            self.viewName = viewName
        }

        public func validate(name: String) throws {
            try self.validate(self.viewName, name: "viewName", parent: name, pattern: "^[a-zA-Z0-9\\-]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case filters = "Filters"
            case includedProperties = "IncludedProperties"
            case scope = "Scope"
            case tags = "Tags"
            case viewName = "ViewName"
        }
    }

    public struct CreateViewOutput: AWSDecodableShape {
        /// A structure that contains the details about the new view.
        public let view: View?

        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct DeleteIndexInput: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the index that you want to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeleteIndexOutput: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the index that you successfully started the deletion process.  This operation is asynchronous. To check its status, call the GetIndex operation.
        public let arn: String?
        /// The date and time when you last updated this index.
        public let lastUpdatedAt: Date?
        /// Indicates the current state of the index.
        public let state: IndexState?

        public init(arn: String? = nil, lastUpdatedAt: Date? = nil, state: IndexState? = nil) {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case lastUpdatedAt = "LastUpdatedAt"
            case state = "State"
        }
    }

    public struct DeleteViewInput: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the view that you want to delete.
        public let viewArn: String

        public init(viewArn: String) {
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case viewArn = "ViewArn"
        }
    }

    public struct DeleteViewOutput: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the view that you successfully deleted.
        public let viewArn: String?

        public init(viewArn: String? = nil) {
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case viewArn = "ViewArn"
        }
    }

    public struct GetAccountLevelServiceConfigurationOutput: AWSDecodableShape {
        /// Details about the organization, and whether configuration is ENABLED or DISABLED.
        public let orgConfiguration: OrgConfiguration?

        public init(orgConfiguration: OrgConfiguration? = nil) {
            self.orgConfiguration = orgConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case orgConfiguration = "OrgConfiguration"
        }
    }

    public struct GetDefaultViewOutput: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the view that is the current default for the Amazon Web Services Region in which you called this operation.
        public let viewArn: String?

        public init(viewArn: String? = nil) {
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case viewArn = "ViewArn"
        }
    }

    public struct GetIndexOutput: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the index.
        public let arn: String?
        /// The date and time when the index was originally created.
        public let createdAt: Date?
        /// The date and time when the index was last updated.
        public let lastUpdatedAt: Date?
        /// This response value is present only if this index is Type=AGGREGATOR. A list of the Amazon Web Services Regions that replicate their content to the index in this Region.
        public let replicatingFrom: [String]?
        /// This response value is present only if this index is Type=LOCAL. The Amazon Web Services Region that contains the aggregator index, if one exists. If an aggregator index does exist then the Region in which you called this operation replicates its index information to the Region specified in this response value.
        public let replicatingTo: [String]?
        /// The current state of the index in this Amazon Web Services Region.
        public let state: IndexState?
        /// Tag key and value pairs that are attached to the index.
        public let tags: [String: String]?
        /// The type of the index in this Region. For information about the aggregator index and how it differs from a local index, see Turning on cross-Region search by creating an aggregator index.
        public let type: IndexType?

        public init(arn: String? = nil, createdAt: Date? = nil, lastUpdatedAt: Date? = nil, replicatingFrom: [String]? = nil, replicatingTo: [String]? = nil, state: IndexState? = nil, tags: [String: String]? = nil, type: IndexType? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.replicatingFrom = replicatingFrom
            self.replicatingTo = replicatingTo
            self.state = state
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case lastUpdatedAt = "LastUpdatedAt"
            case replicatingFrom = "ReplicatingFrom"
            case replicatingTo = "ReplicatingTo"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct GetViewInput: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the view that you want information about.
        public let viewArn: String

        public init(viewArn: String) {
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case viewArn = "ViewArn"
        }
    }

    public struct GetViewOutput: AWSDecodableShape {
        /// Tag key and value pairs that are attached to the view.
        public let tags: [String: String]?
        /// A structure that contains the details for the requested view.
        public let view: View?

        public init(tags: [String: String]? = nil, view: View? = nil) {
            self.tags = tags
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case view = "View"
        }
    }

    public struct IncludedProperty: AWSEncodableShape & AWSDecodableShape {
        /// The name of the property that is included in this view. You can specify the following property names for this field:    Tags
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Index: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the index.
        public let arn: String?
        /// The Amazon Web Services Region in which the index exists.
        public let region: String?
        /// The type of index. It can be one of the following values:    LOCAL – The index contains information about resources from only the same Amazon Web Services Region.    AGGREGATOR – Resource Explorer replicates copies of the indexed information about resources in all other Amazon Web Services Regions to the aggregator index. This lets search results in the Region with the aggregator index to include resources from all Regions in the account where Resource Explorer is turned on.
        public let type: IndexType?

        public init(arn: String? = nil, region: String? = nil, type: IndexType? = nil) {
            self.arn = arn
            self.region = region
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case region = "Region"
            case type = "Type"
        }
    }

    public struct ListIndexesForMembersInput: AWSEncodableShape {
        /// The account IDs will limit the output to only indexes from these accounts.
        public let accountIdList: [String]
        /// The maximum number of results that you want included on each page of the  response. If you do not include this parameter, it defaults to a value appropriate to the  operation. If additional items exist beyond those included in the current response, the  NextToken response element is present and has a value (is not null). Include that  value as the NextToken request parameter in the next call to the operation to get  the next part of the results.  An API operation can return fewer results than the maximum even when there are  more results available. You should check NextToken after every operation to ensure  that you receive all of the results.
        public let maxResults: Int?
        /// The parameter for receiving additional results if you receive a  NextToken response in a previous request. A NextToken response  indicates that more output is available. Set this parameter to the value of the previous  call's NextToken response to indicate where the output should continue  from. The pagination tokens expire after 24 hours.
        public let nextToken: String?

        public init(accountIdList: [String], maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountIdList = accountIdList
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.accountIdList.forEach {
                try validate($0, name: "accountIdList[]", parent: name, max: 2048)
                try validate($0, name: "accountIdList[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIdList = "AccountIdList"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListIndexesForMembersOutput: AWSDecodableShape {
        /// A structure that contains the details and status of each index.
        public let indexes: [MemberIndex]?
        /// If present, indicates that more output is available than is  included in the current response. Use this value in the NextToken request parameter  in a subsequent call to the operation to get the next part of the output. You should repeat this  until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
        public let nextToken: String?

        public init(indexes: [MemberIndex]? = nil, nextToken: String? = nil) {
            self.indexes = indexes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case indexes = "Indexes"
            case nextToken = "NextToken"
        }
    }

    public struct ListIndexesInput: AWSEncodableShape {
        /// The maximum number of results that you want included on each page of the  response. If you do not include this parameter, it defaults to a value appropriate to the  operation. If additional items exist beyond those included in the current response, the  NextToken response element is present and has a value (is not null). Include that  value as the NextToken request parameter in the next call to the operation to get  the next part of the results.  An API operation can return fewer results than the maximum even when there are  more results available. You should check NextToken after every operation to ensure  that you receive all of the results.
        public let maxResults: Int?
        /// The parameter for receiving additional results if you receive a  NextToken response in a previous request. A NextToken response  indicates that more output is available. Set this parameter to the value of the previous  call's NextToken response to indicate where the output should continue  from. The pagination tokens expire after 24 hours.
        public let nextToken: String?
        /// If specified, limits the response to only information about the index in the specified list of Amazon Web Services Regions.
        public let regions: [String]?
        /// If specified, limits the output to only indexes of the specified Type, either LOCAL or AGGREGATOR. Use this option to discover the aggregator index for your account.
        public let type: IndexType?

        public init(maxResults: Int? = nil, nextToken: String? = nil, regions: [String]? = nil, type: IndexType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.regions = regions
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case regions = "Regions"
            case type = "Type"
        }
    }

    public struct ListIndexesOutput: AWSDecodableShape {
        /// A structure that contains the details and status of each index.
        public let indexes: [Index]?
        /// If present, indicates that more output is available than is  included in the current response. Use this value in the NextToken request parameter  in a subsequent call to the operation to get the next part of the output. You should repeat this  until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
        public let nextToken: String?

        public init(indexes: [Index]? = nil, nextToken: String? = nil) {
            self.indexes = indexes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case indexes = "Indexes"
            case nextToken = "NextToken"
        }
    }

    public struct ListSupportedResourceTypesInput: AWSEncodableShape {
        /// The maximum number of results that you want included on each page of the  response. If you do not include this parameter, it defaults to a value appropriate to the  operation. If additional items exist beyond those included in the current response, the  NextToken response element is present and has a value (is not null). Include that  value as the NextToken request parameter in the next call to the operation to get  the next part of the results.  An API operation can return fewer results than the maximum even when there are  more results available. You should check NextToken after every operation to ensure  that you receive all of the results.
        public let maxResults: Int?
        /// The parameter for receiving additional results if you receive a  NextToken response in a previous request. A NextToken response  indicates that more output is available. Set this parameter to the value of the previous  call's NextToken response to indicate where the output should continue  from. The pagination tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListSupportedResourceTypesOutput: AWSDecodableShape {
        /// If present, indicates that more output is available than is  included in the current response. Use this value in the NextToken request parameter  in a subsequent call to the operation to get the next part of the output. You should repeat this  until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
        public let nextToken: String?
        /// The list of resource types supported by Resource Explorer.
        public let resourceTypes: [SupportedResourceType]?

        public init(nextToken: String? = nil, resourceTypes: [SupportedResourceType]? = nil) {
            self.nextToken = nextToken
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the view or index that you want to attach tags to.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The tag key and value pairs that you want to attach to the specified view or index.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListViewsInput: AWSEncodableShape {
        /// The maximum number of results that you want included on each page of the  response. If you do not include this parameter, it defaults to a value appropriate to the  operation. If additional items exist beyond those included in the current response, the  NextToken response element is present and has a value (is not null). Include that  value as the NextToken request parameter in the next call to the operation to get  the next part of the results.  An API operation can return fewer results than the maximum even when there are  more results available. You should check NextToken after every operation to ensure  that you receive all of the results.
        public let maxResults: Int?
        /// The parameter for receiving additional results if you receive a  NextToken response in a previous request. A NextToken response  indicates that more output is available. Set this parameter to the value of the previous  call's NextToken response to indicate where the output should continue  from. The pagination tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListViewsOutput: AWSDecodableShape {
        /// If present, indicates that more output is available than is  included in the current response. Use this value in the NextToken request parameter  in a subsequent call to the operation to get the next part of the output. You should repeat this  until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
        public let nextToken: String?
        /// The list of views available in the Amazon Web Services Region in which you called this operation.
        public let views: [String]?

        public init(nextToken: String? = nil, views: [String]? = nil) {
            self.nextToken = nextToken
            self.views = views
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case views = "Views"
        }
    }

    public struct MemberIndex: AWSDecodableShape {
        /// The account ID for the index.
        public let accountId: String?
        /// The Amazon resource name (ARN) of the index.
        public let arn: String?
        /// The Amazon Web Services Region in which the index exists.
        public let region: String?
        /// The type of index. It can be one of the following values:     LOCAL – The index contains information about resources from only the same Amazon Web Services Region.    AGGREGATOR – Resource Explorer replicates copies of the indexed information about resources in all other Amazon Web Services Regions to the aggregator index. This lets search results in the Region with the aggregator index to include resources from all Regions in the account where Resource Explorer is turned on.
        public let type: IndexType?

        public init(accountId: String? = nil, arn: String? = nil, region: String? = nil, type: IndexType? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.region = region
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case arn = "Arn"
            case region = "Region"
            case type = "Type"
        }
    }

    public struct OrgConfiguration: AWSDecodableShape {
        /// This value displays whether your Amazon Web Services service access is ENABLED or DISABLED.
        public let awsServiceAccessStatus: AWSServiceAccessStatus
        /// This value shows whether or not you have a valid a service-linked role required to start the multi-account search feature.
        public let serviceLinkedRole: String?

        public init(awsServiceAccessStatus: AWSServiceAccessStatus, serviceLinkedRole: String? = nil) {
            self.awsServiceAccessStatus = awsServiceAccessStatus
            self.serviceLinkedRole = serviceLinkedRole
        }

        private enum CodingKeys: String, CodingKey {
            case awsServiceAccessStatus = "AWSServiceAccessStatus"
            case serviceLinkedRole = "ServiceLinkedRole"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the resource.
        public let arn: String?
        /// The date and time that Resource Explorer last queried this resource and updated the index with the latest information about the resource.
        public let lastReportedAt: Date?
        /// The Amazon Web Services account that owns the resource.
        public let owningAccountId: String?
        /// A structure with additional type-specific details about the resource. These properties can be added by turning on integration between Resource Explorer and other Amazon Web Services services.
        public let properties: [ResourceProperty]?
        /// The Amazon Web Services Region in which the resource was created and exists.
        public let region: String?
        /// The type of the resource.
        public let resourceType: String?
        /// The Amazon Web Service that owns the resource and is responsible for creating and updating it.
        public let service: String?

        public init(arn: String? = nil, lastReportedAt: Date? = nil, owningAccountId: String? = nil, properties: [ResourceProperty]? = nil, region: String? = nil, resourceType: String? = nil, service: String? = nil) {
            self.arn = arn
            self.lastReportedAt = lastReportedAt
            self.owningAccountId = owningAccountId
            self.properties = properties
            self.region = region
            self.resourceType = resourceType
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case lastReportedAt = "LastReportedAt"
            case owningAccountId = "OwningAccountId"
            case properties = "Properties"
            case region = "Region"
            case resourceType = "ResourceType"
            case service = "Service"
        }
    }

    public struct ResourceCount: AWSDecodableShape {
        /// Indicates whether the TotalResources value represents an exhaustive count of search results.   If True, it indicates that the search was exhaustive. Every resource that matches the query was counted.   If False, then the search reached the limit of 1,000 matching results, and stopped counting.
        public let complete: Bool?
        /// The number of resources that match the search query. This value can't exceed 1,000. If there are more than 1,000 resources that match the query, then only 1,000 are counted and the Complete field is set to false. We recommend that you refine your query to return a smaller number of results.
        public let totalResources: Int64?

        public init(complete: Bool? = nil, totalResources: Int64? = nil) {
            self.complete = complete
            self.totalResources = totalResources
        }

        private enum CodingKeys: String, CodingKey {
            case complete = "Complete"
            case totalResources = "TotalResources"
        }
    }

    public struct ResourceProperty: AWSDecodableShape {
        /// Details about this property. The content of this field is a JSON object that varies based on the resource type.
        public let data: String?
        /// The date and time that the information about this resource property was last updated.
        public let lastReportedAt: Date?
        /// The name of this property of the resource.
        public let name: String?

        public init(data: String? = nil, lastReportedAt: Date? = nil, name: String? = nil) {
            self.data = data
            self.lastReportedAt = lastReportedAt
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case lastReportedAt = "LastReportedAt"
            case name = "Name"
        }
    }

    public struct SearchFilter: AWSEncodableShape & AWSDecodableShape {
        /// The string that contains the search keywords, prefixes, and operators to control the results that can be returned by a Search operation. For more details, see Search query syntax.
        public let filterString: String

        public init(filterString: String) {
            self.filterString = filterString
        }

        private enum CodingKeys: String, CodingKey {
            case filterString = "FilterString"
        }
    }

    public struct SearchInput: AWSEncodableShape {
        /// The maximum number of results that you want included on each page of the  response. If you do not include this parameter, it defaults to a value appropriate to the  operation. If additional items exist beyond those included in the current response, the  NextToken response element is present and has a value (is not null). Include that  value as the NextToken request parameter in the next call to the operation to get  the next part of the results.  An API operation can return fewer results than the maximum even when there are  more results available. You should check NextToken after every operation to ensure  that you receive all of the results.
        public let maxResults: Int?
        /// The parameter for receiving additional results if you receive a  NextToken response in a previous request. A NextToken response  indicates that more output is available. Set this parameter to the value of the previous  call's NextToken response to indicate where the output should continue  from. The pagination tokens expire after 24 hours.
        public let nextToken: String?
        /// A string that includes keywords and filters that specify the resources that you want to include in the results. For the complete syntax supported by the QueryString parameter, see Search query syntax reference for Resource Explorer. The search is completely case insensitive. You can specify an empty string to return all results up to the limit of 1,000 total results.  The operation can return only the first 1,000 results. If the resource you want is not included, then use a different value for QueryString to refine the results.
        public let queryString: String
        /// Specifies the Amazon resource name (ARN) of the view to use for the query. If you don't specify a value for this parameter, then the operation automatically uses the default view for the Amazon Web Services Region in which you called this operation. If the Region either doesn't have a default view or if you don't have permission to use the default view, then the operation fails with a 401 Unauthorized exception.
        public let viewArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, queryString: String, viewArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryString = queryString
            self.viewArn = viewArn
        }

        public func validate(name: String) throws {
            try self.validate(self.queryString, name: "queryString", parent: name, max: 1011)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case queryString = "QueryString"
            case viewArn = "ViewArn"
        }
    }

    public struct SearchOutput: AWSDecodableShape {
        /// The number of resources that match the query.
        public let count: ResourceCount?
        /// If present, indicates that more output is available than is  included in the current response. Use this value in the NextToken request parameter  in a subsequent call to the operation to get the next part of the output. You should repeat this  until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
        public let nextToken: String?
        /// The list of structures that describe the resources that match the query.
        public let resources: [Resource]?
        /// The Amazon resource name (ARN) of the view that this operation used to perform the search.
        public let viewArn: String?

        public init(count: ResourceCount? = nil, nextToken: String? = nil, resources: [Resource]? = nil, viewArn: String? = nil) {
            self.count = count
            self.nextToken = nextToken
            self.resources = resources
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case nextToken = "NextToken"
            case resources = "Resources"
            case viewArn = "ViewArn"
        }
    }

    public struct SupportedResourceType: AWSDecodableShape {
        /// The unique identifier of the resource type.
        public let resourceType: String?
        /// The Amazon Web Service that is associated with the resource type. This is the primary service that lets you create and interact with resources of this type.
        public let service: String?

        public init(resourceType: String? = nil, service: String? = nil) {
            self.resourceType = resourceType
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case service = "Service"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the view or index that you want to attach tags to.
        public let resourceArn: String
        /// A list of tag key and value pairs that you want to attach to the specified view or index.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the view or index that you want to remove tags from.
        public let resourceArn: String
        /// A list of the keys for the tags that you want to remove from the specified view or index.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIndexTypeInput: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the index that you want to update.
        public let arn: String
        /// The type of the index. To understand the difference between LOCAL and AGGREGATOR, see Turning on cross-Region search in the Amazon Web Services Resource Explorer User Guide.
        public let type: IndexType

        public init(arn: String, type: IndexType) {
            self.arn = arn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case type = "Type"
        }
    }

    public struct UpdateIndexTypeOutput: AWSDecodableShape {
        /// The Amazon resource name (ARN) of the index that you updated.
        public let arn: String?
        /// The date and timestamp when the index was last updated.
        public let lastUpdatedAt: Date?
        /// Indicates the state of the request to update the index. This operation is asynchronous. Call the GetIndex operation to check for changes.
        public let state: IndexState?
        /// Specifies the type of the specified index after the operation completes.
        public let type: IndexType?

        public init(arn: String? = nil, lastUpdatedAt: Date? = nil, state: IndexState? = nil, type: IndexType? = nil) {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.state = state
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case lastUpdatedAt = "LastUpdatedAt"
            case state = "State"
            case type = "Type"
        }
    }

    public struct UpdateViewInput: AWSEncodableShape {
        /// An array of strings that specify which resources are included in the results of  queries made using this view. When you use this view in a Search  operation, the filter string is combined with the search's QueryString  parameter using a logical AND operator. For information about the supported syntax, see Search query reference for Resource Explorer in the Amazon Web Services Resource Explorer User Guide.  This query string in the context of this operation supports only filter prefixes with optional operators. It doesn't support free-form text. For example, the  string region:us* service:ec2 -tag:stage=prod includes all Amazon EC2  resources in any Amazon Web Services Region that begins with the letters us and is not tagged with a key Stage that has the value prod.
        public let filters: SearchFilter?
        /// Specifies optional fields that you want included in search results from this view. It is a list of objects that each describe a field to include. The default is an empty list, with no optional fields included in the results.
        public let includedProperties: [IncludedProperty]?
        /// The Amazon resource name (ARN) of the view that you want to modify.
        public let viewArn: String

        public init(filters: SearchFilter? = nil, includedProperties: [IncludedProperty]? = nil, viewArn: String) {
            self.filters = filters
            self.includedProperties = includedProperties
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case includedProperties = "IncludedProperties"
            case viewArn = "ViewArn"
        }
    }

    public struct UpdateViewOutput: AWSDecodableShape {
        /// Details about the view that you changed with this operation.
        public let view: View?

        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct View: AWSDecodableShape {
        /// An array of SearchFilter objects that specify which resources can be included in the results of queries made using this view.
        public let filters: SearchFilter?
        /// A structure that contains additional information about the view.
        public let includedProperties: [IncludedProperty]?
        /// The date and time when this view was last modified.
        public let lastUpdatedAt: Date?
        /// The Amazon Web Services account that owns this view.
        public let owner: String?
        /// An Amazon resource name (ARN) of an Amazon Web Services account, an organization, or an organizational unit (OU) that specifies whether this view includes resources from only  the specified Amazon Web Services account, all accounts in the specified organization, or all accounts in  the specified OU. If not specified, the value defaults to the Amazon Web Services account used to call this  operation.
        public let scope: String?
        /// The Amazon resource name (ARN) of the view.
        public let viewArn: String?

        public init(filters: SearchFilter? = nil, includedProperties: [IncludedProperty]? = nil, lastUpdatedAt: Date? = nil, owner: String? = nil, scope: String? = nil, viewArn: String? = nil) {
            self.filters = filters
            self.includedProperties = includedProperties
            self.lastUpdatedAt = lastUpdatedAt
            self.owner = owner
            self.scope = scope
            self.viewArn = viewArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case includedProperties = "IncludedProperties"
            case lastUpdatedAt = "LastUpdatedAt"
            case owner = "Owner"
            case scope = "Scope"
            case viewArn = "ViewArn"
        }
    }
}

// MARK: - Errors

/// Error enum for ResourceExplorer2
public struct ResourceExplorer2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ResourceExplorer2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The credentials that you used to call this operation don't have the minimum required permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// If you attempted to create a view, then the request failed because either you specified parameters that didn’t match the original request, or you attempted to create a view with a name that already exists in this Amazon Web Services Region. If you attempted to create an index, then the request failed because either you specified parameters that didn't match the original request, or an index already exists in the current Amazon Web Services Region. If you attempted to update an index type to AGGREGATOR, then the request failed because you already have an AGGREGATOR index in a different Amazon Web Services Region.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request failed because of internal service error. Try your request again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// You specified a resource that doesn't exist. Check the ID or ARN that you used to identity the resource, and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request failed because it exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request failed because you exceeded a rate limit for this operation. For more information, see Quotas for Resource Explorer.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The principal making the request isn't permitted to perform the operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// You provided an invalid value for one of the operation's parameters. Check the syntax for the operation, and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension ResourceExplorer2ErrorType: Equatable {
    public static func == (lhs: ResourceExplorer2ErrorType, rhs: ResourceExplorer2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ResourceExplorer2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
