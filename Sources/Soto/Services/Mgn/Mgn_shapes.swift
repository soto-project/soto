//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Mgn {
    // MARK: Enums

    public enum ApplicationHealthStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case error = "ERROR"
        case healthy = "HEALTHY"
        case lagging = "LAGGING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationProgressStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum BootMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case legacyBios = "LEGACY_BIOS"
        case uefi = "UEFI"
        public var description: String { return self.rawValue }
    }

    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: String, CustomStringConvertible, Codable, _SotoSendable {
        case cutover = "CUTOVER"
        case readyForCutover = "READY_FOR_CUTOVER"
        case readyForTest = "READY_FOR_TEST"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationErrorString: String, CustomStringConvertible, Codable, _SotoSendable {
        case agentNotSeen = "AGENT_NOT_SEEN"
        case failedToAttachStagingDisks = "FAILED_TO_ATTACH_STAGING_DISKS"
        case failedToAuthenticateWithService = "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
        case failedToBootReplicationServer = "FAILED_TO_BOOT_REPLICATION_SERVER"
        case failedToConnectAgentToReplicationServer = "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
        case failedToCreateSecurityGroup = "FAILED_TO_CREATE_SECURITY_GROUP"
        case failedToCreateStagingDisks = "FAILED_TO_CREATE_STAGING_DISKS"
        case failedToDownloadReplicationSoftware = "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
        case failedToLaunchReplicationServer = "FAILED_TO_LAUNCH_REPLICATION_SERVER"
        case failedToPairReplicationServerWithAgent = "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
        case failedToStartDataTransfer = "FAILED_TO_START_DATA_TRANSFER"
        case lastSnapshotJobFailed = "LAST_SNAPSHOT_JOB_FAILED"
        case notConverging = "NOT_CONVERGING"
        case snapshotsFailure = "SNAPSHOTS_FAILURE"
        case unstableNetwork = "UNSTABLE_NETWORK"
        case unsupportedVmConfiguration = "UNSUPPORTED_VM_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepName: String, CustomStringConvertible, Codable, _SotoSendable {
        case attachStagingDisks = "ATTACH_STAGING_DISKS"
        case authenticateWithService = "AUTHENTICATE_WITH_SERVICE"
        case bootReplicationServer = "BOOT_REPLICATION_SERVER"
        case connectAgentToReplicationServer = "CONNECT_AGENT_TO_REPLICATION_SERVER"
        case createSecurityGroup = "CREATE_SECURITY_GROUP"
        case createStagingDisks = "CREATE_STAGING_DISKS"
        case downloadReplicationSoftware = "DOWNLOAD_REPLICATION_SOFTWARE"
        case launchReplicationServer = "LAUNCH_REPLICATION_SERVER"
        case pairReplicationServerWithAgent = "PAIR_REPLICATION_SERVER_WITH_AGENT"
        case startDataTransfer = "START_DATA_TRANSFER"
        case wait = "WAIT"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case skipped = "SKIPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case backlog = "BACKLOG"
        case continuous = "CONTINUOUS"
        case creatingSnapshot = "CREATING_SNAPSHOT"
        case disconnected = "DISCONNECTED"
        case initialSync = "INITIAL_SYNC"
        case initiating = "INITIATING"
        case paused = "PAUSED"
        case pendingSnapshotShipping = "PENDING_SNAPSHOT_SHIPPING"
        case rescan = "RESCAN"
        case shippingSnapshot = "SHIPPING_SNAPSHOT"
        case stalled = "STALLED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum FirstBoot: String, CustomStringConvertible, Codable, _SotoSendable {
        case stopped = "STOPPED"
        case succeeded = "SUCCEEDED"
        case unknown = "UNKNOWN"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum InitiatedBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case diagnostic = "DIAGNOSTIC"
        case startCutover = "START_CUTOVER"
        case startTest = "START_TEST"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum JobLogEvent: String, CustomStringConvertible, Codable, _SotoSendable {
        case cleanupEnd = "CLEANUP_END"
        case cleanupFail = "CLEANUP_FAIL"
        case cleanupStart = "CLEANUP_START"
        case conversionEnd = "CONVERSION_END"
        case conversionFail = "CONVERSION_FAIL"
        case conversionStart = "CONVERSION_START"
        case jobCancel = "JOB_CANCEL"
        case jobEnd = "JOB_END"
        case jobStart = "JOB_START"
        case launchFailed = "LAUNCH_FAILED"
        case launchStart = "LAUNCH_START"
        case serverSkipped = "SERVER_SKIPPED"
        case snapshotEnd = "SNAPSHOT_END"
        case snapshotFail = "SNAPSHOT_FAIL"
        case snapshotStart = "SNAPSHOT_START"
        case usingPreviousSnapshot = "USING_PREVIOUS_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case pending = "PENDING"
        case started = "STARTED"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, _SotoSendable {
        case launch = "LAUNCH"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum LaunchDisposition: String, CustomStringConvertible, Codable, _SotoSendable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case launched = "LAUNCHED"
        case pending = "PENDING"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum LifeCycleState: String, CustomStringConvertible, Codable, _SotoSendable {
        case cutover = "CUTOVER"
        case cuttingOver = "CUTTING_OVER"
        case disconnected = "DISCONNECTED"
        case discovered = "DISCOVERED"
        case notReady = "NOT_READY"
        case readyForCutover = "READY_FOR_CUTOVER"
        case readyForTest = "READY_FOR_TEST"
        case stopped = "STOPPED"
        case testing = "TESTING"
        public var description: String { return self.rawValue }
    }

    public enum PostLaunchActionExecutionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum PostLaunchActionsDeploymentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case cutoverOnly = "CUTOVER_ONLY"
        case testAndCutover = "TEST_AND_CUTOVER"
        case testOnly = "TEST_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDataPlaneRouting: String, CustomStringConvertible, Codable, _SotoSendable {
        case privateIp = "PRIVATE_IP"
        case publicIp = "PUBLIC_IP"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDefaultLargeStagingDiskType: String, CustomStringConvertible, Codable, _SotoSendable {
        case gp2 = "GP2"
        case gp3 = "GP3"
        case st1 = "ST1"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationEbsEncryption: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "CUSTOM"
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "AUTO"
        case gp2 = "GP2"
        case gp3 = "GP3"
        case io1 = "IO1"
        case io2 = "IO2"
        case sc1 = "SC1"
        case st1 = "ST1"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case agentBased = "AGENT_BASED"
        case snapshotShipping = "SNAPSHOT_SHIPPING"
        public var description: String { return self.rawValue }
    }

    public enum SsmDocumentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case automation = "AUTOMATION"
        case command = "COMMAND"
        public var description: String { return self.rawValue }
    }

    public enum SsmParameterStoreParameterType: String, CustomStringConvertible, Codable, _SotoSendable {
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum TargetInstanceTypeRightSizingMethod: String, CustomStringConvertible, Codable, _SotoSendable {
        case basic = "BASIC"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum VolumeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        public var description: String { return self.rawValue }
    }

    public enum WaveHealthStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case error = "ERROR"
        case healthy = "HEALTHY"
        case lagging = "LAGGING"
        public var description: String { return self.rawValue }
    }

    public enum WaveProgressStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Application: AWSDecodableShape {
        /// Application aggregated status.
        public let applicationAggregatedStatus: ApplicationAggregatedStatus?
        /// Application ID.
        public let applicationID: String?
        /// Application ARN.
        public let arn: String?
        /// Application creation dateTime.
        public let creationDateTime: String?
        /// Application description.
        public let description: String?
        /// Application archival status.
        public let isArchived: Bool?
        /// Application last modified dateTime.
        public let lastModifiedDateTime: String?
        /// Application name.
        public let name: String?
        /// Application tags.
        public let tags: [String: String]?
        /// Application wave ID.
        public let waveID: String?

        public init(applicationAggregatedStatus: ApplicationAggregatedStatus? = nil, applicationID: String? = nil, arn: String? = nil, creationDateTime: String? = nil, description: String? = nil, isArchived: Bool? = nil, lastModifiedDateTime: String? = nil, name: String? = nil, tags: [String: String]? = nil, waveID: String? = nil) {
            self.applicationAggregatedStatus = applicationAggregatedStatus
            self.applicationID = applicationID
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveID = waveID
        }

        private enum CodingKeys: String, CodingKey {
            case applicationAggregatedStatus
            case applicationID
            case arn
            case creationDateTime
            case description
            case isArchived
            case lastModifiedDateTime
            case name
            case tags
            case waveID
        }
    }

    public struct ApplicationAggregatedStatus: AWSDecodableShape {
        /// Application aggregated status health status.
        public let healthStatus: ApplicationHealthStatus?
        /// Application aggregated status last update dateTime.
        public let lastUpdateDateTime: String?
        /// Application aggregated status progress status.
        public let progressStatus: ApplicationProgressStatus?
        /// Application aggregated status total source servers amount.
        public let totalSourceServers: Int64?

        public init(healthStatus: ApplicationHealthStatus? = nil, lastUpdateDateTime: String? = nil, progressStatus: ApplicationProgressStatus? = nil, totalSourceServers: Int64? = nil) {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.totalSourceServers = totalSourceServers
        }

        private enum CodingKeys: String, CodingKey {
            case healthStatus
            case lastUpdateDateTime
            case progressStatus
            case totalSourceServers
        }
    }

    public struct ArchiveApplicationRequest: AWSEncodableShape {
        /// Application ID.
        public let applicationID: String

        public init(applicationID: String) {
            self.applicationID = applicationID
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
        }
    }

    public struct ArchiveWaveRequest: AWSEncodableShape {
        /// Wave ID.
        public let waveID: String

        public init(waveID: String) {
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case waveID
        }
    }

    public struct AssociateApplicationsRequest: AWSEncodableShape {
        /// Application IDs list.
        public let applicationIDs: [String]
        /// Wave ID.
        public let waveID: String

        public init(applicationIDs: [String], waveID: String) {
            self.applicationIDs = applicationIDs
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.applicationIDs.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 50)
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, min: 1)
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIDs
            case waveID
        }
    }

    public struct AssociateApplicationsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateSourceServersRequest: AWSEncodableShape {
        /// Application ID.
        public let applicationID: String
        /// Source server IDs list.
        public let sourceServerIDs: [String]

        public init(applicationID: String, sourceServerIDs: [String]) {
            self.applicationID = applicationID
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 50)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
            case sourceServerIDs
        }
    }

    public struct AssociateSourceServersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CPU: AWSDecodableShape {
        /// The number of CPU cores on the source server.
        public let cores: Int64?
        /// The source server's CPU model name.
        public let modelName: String?

        public init(cores: Int64? = nil, modelName: String? = nil) {
            self.cores = cores
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case cores
            case modelName
        }
    }

    public struct ChangeServerLifeCycleStateRequest: AWSEncodableShape {
        /// The request to change the source server migration lifecycle state.
        public let lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle
        /// The request to change the source server migration lifecycle state by source server ID.
        public let sourceServerID: String

        public init(lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle, sourceServerID: String) {
            self.lifeCycle = lifeCycle
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifeCycle
            case sourceServerID
        }
    }

    public struct ChangeServerLifeCycleStateSourceServerLifecycle: AWSEncodableShape {
        /// The request to change the source server migration lifecycle state.
        public let state: ChangeServerLifeCycleStateSourceServerLifecycleState

        public init(state: ChangeServerLifeCycleStateSourceServerLifecycleState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Application description.
        public let description: String?
        /// Application name.
        public let name: String
        /// Application tags.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case tags
        }
    }

    public struct CreateLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// Associate public Ip address.
        public let associatePublicIpAddress: Bool?
        /// Launch configuration template boot mode.
        public let bootMode: BootMode?
        /// Copy private Ip.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Large volume config.
        public let largeVolumeConf: LaunchTemplateDiskConf?
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        public let licensing: Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Launch configuration template post launch actions.
        public let postLaunchActions: PostLaunchActions?
        /// Small volume config.
        public let smallVolumeConf: LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public let smallVolumeMaxSize: Int64?
        /// Request to associate tags during creation of a Launch Configuration Template.
        public let tags: [String: String]?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(associatePublicIpAddress: Bool? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, enableMapAutoTagging: Bool? = nil, largeVolumeConf: LaunchTemplateDiskConf? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, postLaunchActions: PostLaunchActions? = nil, smallVolumeConf: LaunchTemplateDiskConf? = nil, smallVolumeMaxSize: Int64? = nil, tags: [String: String]? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.largeVolumeConf?.validate(name: "\(name).largeVolumeConf")
            try self.validate(self.mapAutoTaggingMpeID, name: "mapAutoTaggingMpeID", parent: name, max: 256)
            try self.postLaunchActions?.validate(name: "\(name).postLaunchActions")
            try self.smallVolumeConf?.validate(name: "\(name).smallVolumeConf")
            try self.validate(self.smallVolumeMaxSize, name: "smallVolumeMaxSize", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress
            case bootMode
            case copyPrivateIp
            case copyTags
            case enableMapAutoTagging
            case largeVolumeConf
            case launchDisposition
            case licensing
            case mapAutoTaggingMpeID
            case postLaunchActions
            case smallVolumeConf
            case smallVolumeMaxSize
            case tags
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct CreateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
        public let associateDefaultSecurityGroup: Bool
        /// Request to configure bandwidth throttling during Replication Settings template creation.
        public let bandwidthThrottling: Int64
        /// Request to create Public IP during Replication Settings template creation.
        public let createPublicIP: Bool
        /// Request to configure  data plane routing during Replication Settings template creation.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting
        /// Request to configure the default large staging disk EBS volume type during Replication Settings template creation.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType
        /// Request to configure EBS encryption during Replication Settings template creation.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption
        /// Request to configure an EBS encryption key during Replication Settings template creation.
        public let ebsEncryptionKeyArn: String?
        /// Request to configure the Replication Server instance type during Replication Settings template creation.
        public let replicationServerInstanceType: String
        /// Request to configure the Replication Server Security group ID during Replication Settings template creation.
        public let replicationServersSecurityGroupsIDs: [String]
        /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
        public let stagingAreaSubnetId: String
        /// Request to configure Staging Area tags during Replication Settings template creation.
        public let stagingAreaTags: [String: String]
        /// Request to configure tags during Replication Settings template creation.
        public let tags: [String: String]?
        /// Request to use Dedicated Replication Servers during Replication Settings template creation.
        public let useDedicatedReplicationServer: Bool

        public init(associateDefaultSecurityGroup: Bool, bandwidthThrottling: Int64 = 0, createPublicIP: Bool, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType, ebsEncryption: ReplicationConfigurationEbsEncryption, ebsEncryptionKeyArn: String? = nil, replicationServerInstanceType: String, replicationServersSecurityGroupsIDs: [String], stagingAreaSubnetId: String, stagingAreaTags: [String: String], tags: [String: String]? = nil, useDedicatedReplicationServer: Bool) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case stagingAreaSubnetId
            case stagingAreaTags
            case tags
            case useDedicatedReplicationServer
        }
    }

    public struct CreateWaveRequest: AWSEncodableShape {
        /// Wave description.
        public let description: String?
        /// Wave name.
        public let name: String
        /// Wave tags.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case tags
        }
    }

    public struct DataReplicationError: AWSDecodableShape {
        /// Error in data replication.
        public let error: DataReplicationErrorString?
        /// Error in data replication.
        public let rawError: String?

        public init(error: DataReplicationErrorString? = nil, rawError: String? = nil) {
            self.error = error
            self.rawError = rawError
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case rawError
        }
    }

    public struct DataReplicationInfo: AWSDecodableShape {
        /// Error in obtaining data replication info.
        public let dataReplicationError: DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public let dataReplicationInitiation: DataReplicationInitiation?
        /// Request to query the data replication state.
        public let dataReplicationState: DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public let etaDateTime: String?
        /// Request to query data replication lag duration.
        public let lagDuration: String?
        /// Request to query data replication last snapshot time.
        public let lastSnapshotDateTime: String?
        /// Request to query disks replicated.
        public let replicatedDisks: [DataReplicationInfoReplicatedDisk]?

        public init(dataReplicationError: DataReplicationError? = nil, dataReplicationInitiation: DataReplicationInitiation? = nil, dataReplicationState: DataReplicationState? = nil, etaDateTime: String? = nil, lagDuration: String? = nil, lastSnapshotDateTime: String? = nil, replicatedDisks: [DataReplicationInfoReplicatedDisk]? = nil) {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.lastSnapshotDateTime = lastSnapshotDateTime
            self.replicatedDisks = replicatedDisks
        }

        private enum CodingKeys: String, CodingKey {
            case dataReplicationError
            case dataReplicationInitiation
            case dataReplicationState
            case etaDateTime
            case lagDuration
            case lastSnapshotDateTime
            case replicatedDisks
        }
    }

    public struct DataReplicationInfoReplicatedDisk: AWSDecodableShape {
        /// Request to query data replication backlog size in bytes.
        public let backloggedStorageBytes: Int64?
        /// Request to query device name.
        public let deviceName: String?
        /// Request to query amount of data replicated in bytes.
        public let replicatedStorageBytes: Int64?
        /// Request to query amount of data rescanned in bytes.
        public let rescannedStorageBytes: Int64?
        /// Request to query total amount of data replicated in bytes.
        public let totalStorageBytes: Int64?

        public init(backloggedStorageBytes: Int64? = nil, deviceName: String? = nil, replicatedStorageBytes: Int64? = nil, rescannedStorageBytes: Int64? = nil, totalStorageBytes: Int64? = nil) {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }

        private enum CodingKeys: String, CodingKey {
            case backloggedStorageBytes
            case deviceName
            case replicatedStorageBytes
            case rescannedStorageBytes
            case totalStorageBytes
        }
    }

    public struct DataReplicationInitiation: AWSDecodableShape {
        /// Request to query next data initiation date and time.
        public let nextAttemptDateTime: String?
        /// Request to query data initiation start date and time.
        public let startDateTime: String?
        /// Request to query data initiation steps.
        public let steps: [DataReplicationInitiationStep]?

        public init(nextAttemptDateTime: String? = nil, startDateTime: String? = nil, steps: [DataReplicationInitiationStep]? = nil) {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextAttemptDateTime
            case startDateTime
            case steps
        }
    }

    public struct DataReplicationInitiationStep: AWSDecodableShape {
        /// Request to query data initiation step name.
        public let name: DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public let status: DataReplicationInitiationStepStatus?

        public init(name: DataReplicationInitiationStepName? = nil, status: DataReplicationInitiationStepStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case status
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// Application ID.
        public let applicationID: String

        public init(applicationID: String) {
            self.applicationID = applicationID
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
        }
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// Request to delete Job from service by Job ID.
        public let jobID: String

        public init(jobID: String) {
            self.jobID = jobID
        }

        public func validate(name: String) throws {
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobID
        }
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// ID of resource to be deleted.
        public let launchConfigurationTemplateID: String

        public init(launchConfigurationTemplateID: String) {
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplateID
        }
    }

    public struct DeleteLaunchConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
        public let replicationConfigurationTemplateID: String

        public init(replicationConfigurationTemplateID: String) {
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigurationTemplateID
        }
    }

    public struct DeleteReplicationConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSourceServerRequest: AWSEncodableShape {
        /// Request to delete Source Server from service by Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct DeleteSourceServerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVcenterClientRequest: AWSEncodableShape {
        /// ID of resource to be deleted.
        public let vcenterClientID: String

        public init(vcenterClientID: String) {
            self.vcenterClientID = vcenterClientID
        }

        public func validate(name: String) throws {
            try self.validate(self.vcenterClientID, name: "vcenterClientID", parent: name, max: 21)
            try self.validate(self.vcenterClientID, name: "vcenterClientID", parent: name, min: 21)
            try self.validate(self.vcenterClientID, name: "vcenterClientID", parent: name, pattern: "^vcc-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case vcenterClientID
        }
    }

    public struct DeleteWaveRequest: AWSEncodableShape {
        /// Wave ID.
        public let waveID: String

        public init(waveID: String) {
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case waveID
        }
    }

    public struct DeleteWaveResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeJobLogItemsRequest: AWSEncodableShape {
        /// Request to describe Job log job ID.
        public let jobID: String
        /// Request to describe Job log item maximum results.
        public let maxResults: Int?
        /// Request to describe Job log next token.
        public let nextToken: String?

        public init(jobID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobID = jobID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case jobID
            case maxResults
            case nextToken
        }
    }

    public struct DescribeJobLogItemsResponse: AWSDecodableShape {
        /// Request to describe Job log response items.
        public let items: [JobLog]?
        /// Request to describe Job log response next token.
        public let nextToken: String?

        public init(items: [JobLog]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeJobsRequest: AWSEncodableShape {
        /// Request to describe Job log filters.
        public let filters: DescribeJobsRequestFilters?
        /// Request to describe job log items by max results.
        public let maxResults: Int?
        /// Request to describe job log items by next token.
        public let nextToken: String?

        public init(filters: DescribeJobsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct DescribeJobsRequestFilters: AWSEncodableShape {
        /// Request to describe Job log filters by date.
        public let fromDate: String?
        /// Request to describe Job log filters by job ID.
        public let jobIDs: [String]?
        /// Request to describe job log items by last date.
        public let toDate: String?

        public init(fromDate: String? = nil, jobIDs: [String]? = nil, toDate: String? = nil) {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }

        public func validate(name: String) throws {
            try self.validate(self.fromDate, name: "fromDate", parent: name, max: 32)
            try self.validate(self.fromDate, name: "fromDate", parent: name, min: 19)
            try self.validate(self.fromDate, name: "fromDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
            try self.jobIDs?.forEach {
                try validate($0, name: "jobIDs[]", parent: name, max: 24)
                try validate($0, name: "jobIDs[]", parent: name, min: 24)
                try validate($0, name: "jobIDs[]", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.jobIDs, name: "jobIDs", parent: name, max: 1000)
            try self.validate(self.toDate, name: "toDate", parent: name, max: 32)
            try self.validate(self.toDate, name: "toDate", parent: name, min: 19)
            try self.validate(self.toDate, name: "toDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case fromDate
            case jobIDs
            case toDate
        }
    }

    public struct DescribeJobsResponse: AWSDecodableShape {
        /// Request to describe Job log items.
        public let items: [Job]?
        /// Request to describe Job response by next token.
        public let nextToken: String?

        public init(items: [Job]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeLaunchConfigurationTemplatesRequest: AWSEncodableShape {
        /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
        public let launchConfigurationTemplateIDs: [String]?
        /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
        public let maxResults: Int?
        /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
        public let nextToken: String?

        public init(launchConfigurationTemplateIDs: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.launchConfigurationTemplateIDs?.forEach {
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.launchConfigurationTemplateIDs, name: "launchConfigurationTemplateIDs", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplateIDs
            case maxResults
            case nextToken
        }
    }

    public struct DescribeLaunchConfigurationTemplatesResponse: AWSDecodableShape {
        /// List of items returned by DescribeLaunchConfigurationTemplates.
        public let items: [LaunchConfigurationTemplate]?
        /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
        public let nextToken: String?

        public init(items: [LaunchConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeReplicationConfigurationTemplatesRequest: AWSEncodableShape {
        /// Request to describe Replication Configuration template by max results.
        public let maxResults: Int?
        /// Request to describe Replication Configuration template by next token.
        public let nextToken: String?
        /// Request to describe Replication Configuration template by template IDs.
        public let replicationConfigurationTemplateIDs: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationConfigurationTemplateIDs: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.replicationConfigurationTemplateIDs?.forEach {
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.replicationConfigurationTemplateIDs, name: "replicationConfigurationTemplateIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case replicationConfigurationTemplateIDs
        }
    }

    public struct DescribeReplicationConfigurationTemplatesResponse: AWSDecodableShape {
        /// Request to describe Replication Configuration template by items.
        public let items: [ReplicationConfigurationTemplate]?
        /// Request to describe Replication Configuration template by next token.
        public let nextToken: String?

        public init(items: [ReplicationConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeSourceServersRequest: AWSEncodableShape {
        /// Request to filter Source Servers list.
        public let filters: DescribeSourceServersRequestFilters?
        /// Request to filter Source Servers list by maximum results.
        public let maxResults: Int?
        /// Request to filter Source Servers list by next token.
        public let nextToken: String?

        public init(filters: DescribeSourceServersRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct DescribeSourceServersRequestFilters: AWSEncodableShape {
        /// Request to filter Source Servers list by application IDs.
        public let applicationIDs: [String]?
        /// Request to filter Source Servers list by archived.
        public let isArchived: Bool?
        /// Request to filter Source Servers list by life cycle states.
        public let lifeCycleStates: [LifeCycleState]?
        /// Request to filter Source Servers list by replication type.
        public let replicationTypes: [ReplicationType]?
        /// Request to filter Source Servers list by Source Server ID.
        public let sourceServerIDs: [String]?

        public init(applicationIDs: [String]? = nil, isArchived: Bool? = nil, lifeCycleStates: [LifeCycleState]? = nil, replicationTypes: [ReplicationType]? = nil, sourceServerIDs: [String]? = nil) {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.lifeCycleStates = lifeCycleStates
            self.replicationTypes = replicationTypes
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.applicationIDs?.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 200)
            try self.validate(self.lifeCycleStates, name: "lifeCycleStates", parent: name, max: 10)
            try self.validate(self.replicationTypes, name: "replicationTypes", parent: name, max: 2)
            try self.sourceServerIDs?.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIDs
            case isArchived
            case lifeCycleStates
            case replicationTypes
            case sourceServerIDs
        }
    }

    public struct DescribeSourceServersResponse: AWSDecodableShape {
        /// Request to filter Source Servers list by item.
        public let items: [SourceServer]?
        /// Request to filter Source Servers next token.
        public let nextToken: String?

        public init(items: [SourceServer]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeVcenterClientsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Maximum results to be returned in DescribeVcenterClients.
        public let maxResults: Int?
        /// Next pagination token to be provided for DescribeVcenterClients.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVcenterClientsResponse: AWSDecodableShape {
        /// List of items returned by DescribeVcenterClients.
        public let items: [VcenterClient]?
        /// Next pagination token returned from DescribeVcenterClients.
        public let nextToken: String?

        public init(items: [VcenterClient]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DisassociateApplicationsRequest: AWSEncodableShape {
        /// Application IDs list.
        public let applicationIDs: [String]
        /// Wave ID.
        public let waveID: String

        public init(applicationIDs: [String], waveID: String) {
            self.applicationIDs = applicationIDs
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.applicationIDs.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 50)
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, min: 1)
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIDs
            case waveID
        }
    }

    public struct DisassociateApplicationsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateSourceServersRequest: AWSEncodableShape {
        /// Application ID.
        public let applicationID: String
        /// Source server IDs list.
        public let sourceServerIDs: [String]

        public init(applicationID: String, sourceServerIDs: [String]) {
            self.applicationID = applicationID
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 50)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
            case sourceServerIDs
        }
    }

    public struct DisassociateSourceServersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisconnectFromServiceRequest: AWSEncodableShape {
        /// Request to disconnect Source Server from service by Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct Disk: AWSDecodableShape {
        /// The amount of storage on the disk in bytes.
        public let bytes: Int64?
        /// The disk or device name.
        public let deviceName: String?

        public init(bytes: Int64? = nil, deviceName: String? = nil) {
            self.bytes = bytes
            self.deviceName = deviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bytes
            case deviceName
        }
    }

    public struct FinalizeCutoverRequest: AWSEncodableShape {
        /// Request to finalize Cutover by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct GetLaunchConfigurationRequest: AWSEncodableShape {
        /// Request to get Launch Configuration information by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct GetReplicationConfigurationRequest: AWSEncodableShape {
        /// Request to get Replication Configuration by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct IdentificationHints: AWSDecodableShape {
        /// AWS Instance ID identification hint.
        public let awsInstanceID: String?
        /// FQDN address identification hint.
        public let fqdn: String?
        /// Hostname identification hint.
        public let hostname: String?
        /// vCenter VM path identification hint.
        public let vmPath: String?
        /// vmWare UUID identification hint.
        public let vmWareUuid: String?

        public init(awsInstanceID: String? = nil, fqdn: String? = nil, hostname: String? = nil, vmPath: String? = nil, vmWareUuid: String? = nil) {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmPath = vmPath
            self.vmWareUuid = vmWareUuid
        }

        private enum CodingKeys: String, CodingKey {
            case awsInstanceID
            case fqdn
            case hostname
            case vmPath
            case vmWareUuid
        }
    }

    public struct InitializeServiceRequest: AWSEncodableShape {
        public init() {}
    }

    public struct InitializeServiceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Job: AWSDecodableShape {
        /// the ARN of the specific Job.
        public let arn: String?
        /// Job creation time.
        public let creationDateTime: String?
        /// Job end time.
        public let endDateTime: String?
        /// Job initiated by field.
        public let initiatedBy: InitiatedBy?
        /// Job ID.
        public let jobID: String
        /// Servers participating in a specific Job.
        public let participatingServers: [ParticipatingServer]?
        /// Job status.
        public let status: JobStatus?
        /// Tags associated with specific Job.
        public let tags: [String: String]?
        /// Job type.
        public let type: JobType?

        public init(arn: String? = nil, creationDateTime: String? = nil, endDateTime: String? = nil, initiatedBy: InitiatedBy? = nil, jobID: String, participatingServers: [ParticipatingServer]? = nil, status: JobStatus? = nil, tags: [String: String]? = nil, type: JobType? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case endDateTime
            case initiatedBy
            case jobID
            case participatingServers
            case status
            case tags
            case type
        }
    }

    public struct JobLog: AWSDecodableShape {
        /// Job log event.
        public let event: JobLogEvent?
        /// Job event data
        public let eventData: JobLogEventData?
        /// Job log event date and time.
        public let logDateTime: String?

        public init(event: JobLogEvent? = nil, eventData: JobLogEventData? = nil, logDateTime: String? = nil) {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case event
            case eventData
            case logDateTime
        }
    }

    public struct JobLogEventData: AWSDecodableShape {
        /// Job Event conversion Server ID.
        public let conversionServerID: String?
        /// Job error.
        public let rawError: String?
        /// Job Event Source Server ID.
        public let sourceServerID: String?
        /// Job Event Target instance ID.
        public let targetInstanceID: String?

        public init(conversionServerID: String? = nil, rawError: String? = nil, sourceServerID: String? = nil, targetInstanceID: String? = nil) {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }

        private enum CodingKeys: String, CodingKey {
            case conversionServerID
            case rawError
            case sourceServerID
            case targetInstanceID
        }
    }

    public struct JobPostLaunchActionsLaunchStatus: AWSDecodableShape {
        /// AWS Systems Manager Document's execution ID of the of the Job Post Launch Actions.
        public let executionID: String?
        /// AWS Systems Manager Document's execution status.
        public let executionStatus: PostLaunchActionExecutionStatus?
        /// AWS Systems Manager Document's failure reason.
        public let failureReason: String?
        /// AWS Systems Manager's Document of the of the Job Post Launch Actions.
        public let ssmDocument: SsmDocument?
        /// AWS Systems Manager Document type.
        public let ssmDocumentType: SsmDocumentType?

        public init(executionID: String? = nil, executionStatus: PostLaunchActionExecutionStatus? = nil, failureReason: String? = nil, ssmDocument: SsmDocument? = nil, ssmDocumentType: SsmDocumentType? = nil) {
            self.executionID = executionID
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.ssmDocument = ssmDocument
            self.ssmDocumentType = ssmDocumentType
        }

        private enum CodingKeys: String, CodingKey {
            case executionID
            case executionStatus
            case failureReason
            case ssmDocument
            case ssmDocumentType
        }
    }

    public struct LaunchConfiguration: AWSDecodableShape {
        /// Launch configuration boot mode.
        public let bootMode: BootMode?
        /// Copy Private IP during Launch Configuration.
        public let copyPrivateIp: Bool?
        /// Copy Tags during Launch Configuration.
        public let copyTags: Bool?
        /// Launch configuration EC2 Launch template ID.
        public let ec2LaunchTemplateID: String?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Launch disposition for launch configuration.
        public let launchDisposition: LaunchDisposition?
        /// Launch configuration OS licensing.
        public let licensing: Licensing?
        /// Map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Launch configuration name.
        public let name: String?
        public let postLaunchActions: PostLaunchActions?
        /// Launch configuration Source Server ID.
        public let sourceServerID: String?
        /// Launch configuration Target instance type right sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, ec2LaunchTemplateID: String? = nil, enableMapAutoTagging: Bool? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, name: String? = nil, postLaunchActions: PostLaunchActions? = nil, sourceServerID: String? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.name = name
            self.postLaunchActions = postLaunchActions
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case bootMode
            case copyPrivateIp
            case copyTags
            case ec2LaunchTemplateID
            case enableMapAutoTagging
            case launchDisposition
            case licensing
            case mapAutoTaggingMpeID
            case name
            case postLaunchActions
            case sourceServerID
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct LaunchConfigurationTemplate: AWSDecodableShape {
        /// ARN of the Launch Configuration Template.
        public let arn: String?
        /// Associate public Ip address.
        public let associatePublicIpAddress: Bool?
        /// Launch configuration template boot mode.
        public let bootMode: BootMode?
        /// Copy private Ip.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// EC2 launch template ID.
        public let ec2LaunchTemplateID: String?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Large volume config.
        public let largeVolumeConf: LaunchTemplateDiskConf?
        /// ID of the Launch Configuration Template.
        public let launchConfigurationTemplateID: String
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        public let licensing: Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Post Launch Actions of the Launch Configuration Template.
        public let postLaunchActions: PostLaunchActions?
        /// Small volume config.
        public let smallVolumeConf: LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public let smallVolumeMaxSize: Int64?
        /// Tags of the Launch Configuration Template.
        public let tags: [String: String]?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(arn: String? = nil, associatePublicIpAddress: Bool? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, ec2LaunchTemplateID: String? = nil, enableMapAutoTagging: Bool? = nil, largeVolumeConf: LaunchTemplateDiskConf? = nil, launchConfigurationTemplateID: String, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, postLaunchActions: PostLaunchActions? = nil, smallVolumeConf: LaunchTemplateDiskConf? = nil, smallVolumeMaxSize: Int64? = nil, tags: [String: String]? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.arn = arn
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case associatePublicIpAddress
            case bootMode
            case copyPrivateIp
            case copyTags
            case ec2LaunchTemplateID
            case enableMapAutoTagging
            case largeVolumeConf
            case launchConfigurationTemplateID
            case launchDisposition
            case licensing
            case mapAutoTaggingMpeID
            case postLaunchActions
            case smallVolumeConf
            case smallVolumeMaxSize
            case tags
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct LaunchTemplateDiskConf: AWSEncodableShape & AWSDecodableShape {
        /// Launch template disk iops configuration.
        public let iops: Int64?
        /// Launch template disk throughput configuration.
        public let throughput: Int64?
        /// Launch template disk volume type configuration.
        public let volumeType: VolumeType?

        public init(iops: Int64? = nil, throughput: Int64? = nil, volumeType: VolumeType? = nil) {
            self.iops = iops
            self.throughput = throughput
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case iops
            case throughput
            case volumeType
        }
    }

    public struct LaunchedInstance: AWSDecodableShape {
        /// Launched instance EC2 ID.
        public let ec2InstanceID: String?
        /// Launched instance first boot.
        public let firstBoot: FirstBoot?
        /// Launched instance Job ID.
        public let jobID: String?

        public init(ec2InstanceID: String? = nil, firstBoot: FirstBoot? = nil, jobID: String? = nil) {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceID
            case firstBoot
            case jobID
        }
    }

    public struct Licensing: AWSEncodableShape & AWSDecodableShape {
        /// Configure BYOL OS licensing.
        public let osByol: Bool?

        public init(osByol: Bool? = nil) {
            self.osByol = osByol
        }

        private enum CodingKeys: String, CodingKey {
            case osByol
        }
    }

    public struct LifeCycle: AWSDecodableShape {
        /// Lifecycle added to service data and time.
        public let addedToServiceDateTime: String?
        /// Lifecycle elapsed time and duration.
        public let elapsedReplicationDuration: String?
        /// Lifecycle replication initiation date and time.
        public let firstByteDateTime: String?
        /// Lifecycle last Cutover.
        public let lastCutover: LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public let lastSeenByServiceDateTime: String?
        /// Lifecycle last Test.
        public let lastTest: LifeCycleLastTest?
        /// Lifecycle state.
        public let state: LifeCycleState?

        public init(addedToServiceDateTime: String? = nil, elapsedReplicationDuration: String? = nil, firstByteDateTime: String? = nil, lastCutover: LifeCycleLastCutover? = nil, lastSeenByServiceDateTime: String? = nil, lastTest: LifeCycleLastTest? = nil, state: LifeCycleState? = nil) {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case addedToServiceDateTime
            case elapsedReplicationDuration
            case firstByteDateTime
            case lastCutover
            case lastSeenByServiceDateTime
            case lastTest
            case state
        }
    }

    public struct LifeCycleLastCutover: AWSDecodableShape {
        /// Lifecycle Cutover finalized date and time.
        public let finalized: LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public let initiated: LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public let reverted: LifeCycleLastCutoverReverted?

        public init(finalized: LifeCycleLastCutoverFinalized? = nil, initiated: LifeCycleLastCutoverInitiated? = nil, reverted: LifeCycleLastCutoverReverted? = nil) {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }

        private enum CodingKeys: String, CodingKey {
            case finalized
            case initiated
            case reverted
        }
    }

    public struct LifeCycleLastCutoverFinalized: AWSDecodableShape {
        /// Lifecycle Cutover finalized date and time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct LifeCycleLastCutoverInitiated: AWSDecodableShape {
        public let apiCallDateTime: String?
        /// Lifecycle last Cutover initiated by Job ID.
        public let jobID: String?

        public init(apiCallDateTime: String? = nil, jobID: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
            case jobID
        }
    }

    public struct LifeCycleLastCutoverReverted: AWSDecodableShape {
        /// Lifecycle last Cutover reverted API call date time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct LifeCycleLastTest: AWSDecodableShape {
        /// Lifecycle last Test finalized.
        public let finalized: LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public let initiated: LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public let reverted: LifeCycleLastTestReverted?

        public init(finalized: LifeCycleLastTestFinalized? = nil, initiated: LifeCycleLastTestInitiated? = nil, reverted: LifeCycleLastTestReverted? = nil) {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }

        private enum CodingKeys: String, CodingKey {
            case finalized
            case initiated
            case reverted
        }
    }

    public struct LifeCycleLastTestFinalized: AWSDecodableShape {
        /// Lifecycle Test failed API call date and time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct LifeCycleLastTestInitiated: AWSDecodableShape {
        /// Lifecycle last Test initiated API call date and time.
        public let apiCallDateTime: String?
        /// Lifecycle last Test initiated Job ID.
        public let jobID: String?

        public init(apiCallDateTime: String? = nil, jobID: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
            case jobID
        }
    }

    public struct LifeCycleLastTestReverted: AWSDecodableShape {
        /// Lifecycle last Test reverted API call date and time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// Applications list filters.
        public let filters: ListApplicationsRequestFilters?
        /// Maximum results to return when listing applications.
        public let maxResults: Int?
        /// Request next token.
        public let nextToken: String?

        public init(filters: ListApplicationsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListApplicationsRequestFilters: AWSEncodableShape {
        /// Filter applications list by application ID.
        public let applicationIDs: [String]?
        /// Filter applications list by archival status.
        public let isArchived: Bool?
        /// Filter applications list by wave ID.
        public let waveIDs: [String]?

        public init(applicationIDs: [String]? = nil, isArchived: Bool? = nil, waveIDs: [String]? = nil) {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }

        public func validate(name: String) throws {
            try self.applicationIDs?.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 200)
            try self.waveIDs?.forEach {
                try validate($0, name: "waveIDs[]", parent: name, max: 22)
                try validate($0, name: "waveIDs[]", parent: name, min: 22)
                try validate($0, name: "waveIDs[]", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.waveIDs, name: "waveIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIDs
            case isArchived
            case waveIDs
        }
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// Applications list.
        public let items: [Application]?
        /// Response next token.
        public let nextToken: String?

        public init(items: [Application]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListSourceServerActionsRequest: AWSEncodableShape {
        /// Filters to apply when listing source server post migration custom actions.
        public let filters: SourceServerActionsRequestFilters?
        /// Maximum amount of items to return when listing source server post migration custom actions.
        public let maxResults: Int?
        /// Next token to use when listing source server post migration custom actions.
        public let nextToken: String?
        /// Source server ID.
        public let sourceServerID: String

        public init(filters: SourceServerActionsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, sourceServerID: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
            case sourceServerID
        }
    }

    public struct ListSourceServerActionsResponse: AWSDecodableShape {
        /// List of source server post migration custom actions.
        public let items: [SourceServerActionDocument]?
        /// Next token returned when listing source server post migration custom actions.
        public let nextToken: String?

        public init(items: [SourceServerActionDocument]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// List tags for resource request by ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// List tags for resource response.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListTemplateActionsRequest: AWSEncodableShape {
        /// Filters to apply when listing template post migration custom actions.
        public let filters: TemplateActionsRequestFilters?
        /// Launch configuration template ID.
        public let launchConfigurationTemplateID: String
        /// Maximum amount of items to return when listing template post migration custom actions.
        public let maxResults: Int?
        /// Next token to use when listing template post migration custom actions.
        public let nextToken: String?

        public init(filters: TemplateActionsRequestFilters? = nil, launchConfigurationTemplateID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case launchConfigurationTemplateID
            case maxResults
            case nextToken
        }
    }

    public struct ListTemplateActionsResponse: AWSDecodableShape {
        /// List of template post migration custom actions.
        public let items: [TemplateActionDocument]?
        /// Next token returned when listing template post migration custom actions.
        public let nextToken: String?

        public init(items: [TemplateActionDocument]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListWavesRequest: AWSEncodableShape {
        /// Waves list filters.
        public let filters: ListWavesRequestFilters?
        /// Maximum results to return when listing waves.
        public let maxResults: Int?
        /// Request next token.
        public let nextToken: String?

        public init(filters: ListWavesRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListWavesRequestFilters: AWSEncodableShape {
        /// Filter waves list by archival status.
        public let isArchived: Bool?
        /// Filter waves list by wave ID.
        public let waveIDs: [String]?

        public init(isArchived: Bool? = nil, waveIDs: [String]? = nil) {
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }

        public func validate(name: String) throws {
            try self.waveIDs?.forEach {
                try validate($0, name: "waveIDs[]", parent: name, max: 22)
                try validate($0, name: "waveIDs[]", parent: name, min: 22)
                try validate($0, name: "waveIDs[]", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.waveIDs, name: "waveIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case isArchived
            case waveIDs
        }
    }

    public struct ListWavesResponse: AWSDecodableShape {
        /// Waves list.
        public let items: [Wave]?
        /// Response next token.
        public let nextToken: String?

        public init(items: [Wave]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct MarkAsArchivedRequest: AWSEncodableShape {
        /// Mark as archived by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// Network interface IPs.
        public let ips: [String]?
        /// Network interface primary IP.
        public let isPrimary: Bool?
        /// Network interface Mac address.
        public let macAddress: String?

        public init(ips: [String]? = nil, isPrimary: Bool? = nil, macAddress: String? = nil) {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ips
            case isPrimary
            case macAddress
        }
    }

    public struct OS: AWSDecodableShape {
        /// OS full string.
        public let fullString: String?

        public init(fullString: String? = nil) {
            self.fullString = fullString
        }

        private enum CodingKeys: String, CodingKey {
            case fullString
        }
    }

    public struct ParticipatingServer: AWSDecodableShape {
        /// Participating server's launched ec2 instance ID.
        public let launchedEc2InstanceID: String?
        /// Participating server launch status.
        public let launchStatus: LaunchStatus?
        /// Participating server's Post Launch Actions Status.
        public let postLaunchActionsStatus: PostLaunchActionsStatus?
        /// Participating server Source Server ID.
        public let sourceServerID: String

        public init(launchedEc2InstanceID: String? = nil, launchStatus: LaunchStatus? = nil, postLaunchActionsStatus: PostLaunchActionsStatus? = nil, sourceServerID: String) {
            self.launchedEc2InstanceID = launchedEc2InstanceID
            self.launchStatus = launchStatus
            self.postLaunchActionsStatus = postLaunchActionsStatus
            self.sourceServerID = sourceServerID
        }

        private enum CodingKeys: String, CodingKey {
            case launchedEc2InstanceID
            case launchStatus
            case postLaunchActionsStatus
            case sourceServerID
        }
    }

    public struct PostLaunchActions: AWSEncodableShape & AWSDecodableShape {
        /// AWS Systems Manager Command's CloudWatch log group name.
        public let cloudWatchLogGroupName: String?
        /// Deployment type in which AWS Systems Manager Documents will be executed.
        public let deployment: PostLaunchActionsDeploymentType?
        /// AWS Systems Manager Command's logs S3 log bucket.
        public let s3LogBucket: String?
        /// AWS Systems Manager Command's logs S3 output key prefix.
        public let s3OutputKeyPrefix: String?
        /// AWS Systems Manager Documents.
        public let ssmDocuments: [SsmDocument]?

        public init(cloudWatchLogGroupName: String? = nil, deployment: PostLaunchActionsDeploymentType? = nil, s3LogBucket: String? = nil, s3OutputKeyPrefix: String? = nil, ssmDocuments: [SsmDocument]? = nil) {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.deployment = deployment
            self.s3LogBucket = s3LogBucket
            self.s3OutputKeyPrefix = s3OutputKeyPrefix
            self.ssmDocuments = ssmDocuments
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, max: 512)
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, min: 1)
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, pattern: "^[\\.\\-_/#A-Za-z0-9]+$")
            try self.validate(self.s3LogBucket, name: "s3LogBucket", parent: name, max: 63)
            try self.validate(self.s3LogBucket, name: "s3LogBucket", parent: name, min: 3)
            try self.validate(self.s3OutputKeyPrefix, name: "s3OutputKeyPrefix", parent: name, max: 256)
            try self.ssmDocuments?.forEach {
                try $0.validate(name: "\(name).ssmDocuments[]")
            }
            try self.validate(self.ssmDocuments, name: "ssmDocuments", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupName
            case deployment
            case s3LogBucket
            case s3OutputKeyPrefix
            case ssmDocuments
        }
    }

    public struct PostLaunchActionsStatus: AWSDecodableShape {
        /// List of Post Launch Action status.
        public let postLaunchActionsLaunchStatusList: [JobPostLaunchActionsLaunchStatus]?
        /// Time where the AWS Systems Manager was detected as running on the Test or Cutover instance.
        public let ssmAgentDiscoveryDatetime: String?

        public init(postLaunchActionsLaunchStatusList: [JobPostLaunchActionsLaunchStatus]? = nil, ssmAgentDiscoveryDatetime: String? = nil) {
            self.postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }

        private enum CodingKeys: String, CodingKey {
            case postLaunchActionsLaunchStatusList
            case ssmAgentDiscoveryDatetime
        }
    }

    public struct PutSourceServerActionRequest: AWSEncodableShape {
        /// Source server post migration custom action ID.
        public let actionID: String
        /// Source server post migration custom action name.
        public let actionName: String
        /// Source server post migration custom action active status.
        public let active: Bool?
        /// Source server post migration custom action document identifier.
        public let documentIdentifier: String
        /// Source server post migration custom action document version.
        public let documentVersion: String?
        /// Source server post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Source server post migration custom action order.
        public let order: Int
        /// Source server post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Source server ID.
        public let sourceServerID: String
        /// Source server post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        public init(actionID: String, actionName: String, active: Bool? = nil, documentIdentifier: String, documentVersion: String? = nil, mustSucceedForCutover: Bool? = nil, order: Int = 0, parameters: [String: [SsmParameterStoreParameter]]? = nil, sourceServerID: String, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.sourceServerID = sourceServerID
            self.timeoutSeconds = timeoutSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.actionName, name: "actionName", parent: name, max: 256)
            try self.validate(self.actionName, name: "actionName", parent: name, min: 1)
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.validate(self.documentIdentifier, name: "documentIdentifier", parent: name, max: 256)
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, pattern: "^(\\$DEFAULT|\\$LATEST|[0-9]+)$")
            try self.validate(self.order, name: "order", parent: name, max: 10000)
            try self.validate(self.order, name: "order", parent: name, min: 1001)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            try self.validate(self.timeoutSeconds, name: "timeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionID
            case actionName
            case active
            case documentIdentifier
            case documentVersion
            case mustSucceedForCutover
            case order
            case parameters
            case sourceServerID
            case timeoutSeconds
        }
    }

    public struct PutTemplateActionRequest: AWSEncodableShape {
        /// Template post migration custom action ID.
        public let actionID: String
        /// Template post migration custom action name.
        public let actionName: String
        /// Template post migration custom action active status.
        public let active: Bool?
        /// Template post migration custom action document identifier.
        public let documentIdentifier: String
        /// Template post migration custom action document version.
        public let documentVersion: String?
        /// Launch configuration template ID.
        public let launchConfigurationTemplateID: String
        /// Template post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Operating system eligible for this template post migration custom action.
        public let operatingSystem: String?
        /// Template post migration custom action order.
        public let order: Int
        /// Template post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        public init(actionID: String, actionName: String, active: Bool? = nil, documentIdentifier: String, documentVersion: String? = nil, launchConfigurationTemplateID: String, mustSucceedForCutover: Bool? = nil, operatingSystem: String? = nil, order: Int = 0, parameters: [String: [SsmParameterStoreParameter]]? = nil, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.actionName, name: "actionName", parent: name, max: 256)
            try self.validate(self.documentIdentifier, name: "documentIdentifier", parent: name, max: 256)
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, pattern: "^(\\$DEFAULT|\\$LATEST|[0-9]+)$")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            try self.validate(self.operatingSystem, name: "operatingSystem", parent: name, pattern: "^(linux|windows)$")
            try self.validate(self.order, name: "order", parent: name, max: 10000)
            try self.validate(self.order, name: "order", parent: name, min: 1001)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.timeoutSeconds, name: "timeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionID
            case actionName
            case active
            case documentIdentifier
            case documentVersion
            case launchConfigurationTemplateID
            case mustSucceedForCutover
            case operatingSystem
            case order
            case parameters
            case timeoutSeconds
        }
    }

    public struct RemoveSourceServerActionRequest: AWSEncodableShape {
        /// Source server post migration custom action ID to remove.
        public let actionID: String
        /// Source server ID of the post migration custom action to remove.
        public let sourceServerID: String

        public init(actionID: String, sourceServerID: String) {
            self.actionID = actionID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionID
            case sourceServerID
        }
    }

    public struct RemoveSourceServerActionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RemoveTemplateActionRequest: AWSEncodableShape {
        /// Template post migration custom action ID to remove.
        public let actionID: String
        /// Launch configuration template ID of the post migration custom action to remove.
        public let launchConfigurationTemplateID: String

        public init(actionID: String, launchConfigurationTemplateID: String) {
            self.actionID = actionID
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionID
            case launchConfigurationTemplateID
        }
    }

    public struct RemoveTemplateActionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReplicationConfiguration: AWSDecodableShape {
        /// Replication Configuration associate default Application Migration Service Security Group.
        public let associateDefaultSecurityGroup: Bool?
        /// Replication Configuration set bandwidth throttling.
        public let bandwidthThrottling: Int64?
        /// Replication Configuration create Public IP.
        public let createPublicIP: Bool?
        /// Replication Configuration data plane routing.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration use default large Staging Disks.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration EBS encryption.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Replication Configuration EBS encryption key ARN.
        public let ebsEncryptionKeyArn: String?
        /// Replication Configuration name.
        public let name: String?
        /// Replication Configuration replicated disks.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// Replication Configuration Replication Server instance type.
        public let replicationServerInstanceType: String?
        /// Replication Configuration Replication Server Security Group IDs.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Replication Configuration Source Server ID.
        public let sourceServerID: String?
        /// Replication Configuration Staging Area subnet ID.
        public let stagingAreaSubnetId: String?
        /// Replication Configuration Staging Area tags.
        public let stagingAreaTags: [String: String]?
        /// Replication Configuration use Dedicated Replication Server.
        public let useDedicatedReplicationServer: Bool?

        public init(associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case name
            case replicatedDisks
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case sourceServerID
            case stagingAreaSubnetId
            case stagingAreaTags
            case useDedicatedReplicationServer
        }
    }

    public struct ReplicationConfigurationReplicatedDisk: AWSEncodableShape & AWSDecodableShape {
        /// Replication Configuration replicated disk device name.
        public let deviceName: String?
        /// Replication Configuration replicated disk IOPs.
        public let iops: Int64?
        /// Replication Configuration replicated disk boot disk.
        public let isBootDisk: Bool?
        /// Replication Configuration replicated disk staging disk type.
        public let stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// Replication Configuration replicated disk throughput.
        public let throughput: Int64?

        public init(deviceName: String? = nil, iops: Int64? = nil, isBootDisk: Bool? = nil, stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType? = nil, throughput: Int64? = nil) {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 256)
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName
            case iops
            case isBootDisk
            case stagingDiskType
            case throughput
        }
    }

    public struct ReplicationConfigurationTemplate: AWSDecodableShape {
        /// Replication Configuration template ARN.
        public let arn: String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public let associateDefaultSecurityGroup: Bool?
        /// Replication Configuration template bandwidth throttling.
        public let bandwidthThrottling: Int64?
        /// Replication Configuration template create Public IP.
        public let createPublicIP: Bool?
        /// Replication Configuration template data plane routing.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use default large Staging Disk type.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public let ebsEncryptionKeyArn: String?
        /// Replication Configuration template ID.
        public let replicationConfigurationTemplateID: String
        /// Replication Configuration template server instance type.
        public let replicationServerInstanceType: String?
        /// Replication Configuration template server Security Groups IDs.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Replication Configuration template Staging Area subnet ID.
        public let stagingAreaSubnetId: String?
        /// Replication Configuration template Staging Area Tags.
        public let stagingAreaTags: [String: String]?
        /// Replication Configuration template Tags.
        public let tags: [String: String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public let useDedicatedReplicationServer: Bool?

        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, tags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case replicationConfigurationTemplateID
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case stagingAreaSubnetId
            case stagingAreaTags
            case tags
            case useDedicatedReplicationServer
        }
    }

    public struct RetryDataReplicationRequest: AWSEncodableShape {
        /// Retry data replication for Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct SourceProperties: AWSDecodableShape {
        /// Source Server CPUs.
        public let cpus: [CPU]?
        /// Source Server disks.
        public let disks: [Disk]?
        /// Source server identification hints.
        public let identificationHints: IdentificationHints?
        /// Source server last update date and time.
        public let lastUpdatedDateTime: String?
        /// Source server network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// Source server OS.
        public let os: OS?
        /// Source server RAM in bytes.
        public let ramBytes: Int64?
        /// Source server recommended instance type.
        public let recommendedInstanceType: String?

        public init(cpus: [CPU]? = nil, disks: [Disk]? = nil, identificationHints: IdentificationHints? = nil, lastUpdatedDateTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, os: OS? = nil, ramBytes: Int64? = nil, recommendedInstanceType: String? = nil) {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case cpus
            case disks
            case identificationHints
            case lastUpdatedDateTime
            case networkInterfaces
            case os
            case ramBytes
            case recommendedInstanceType
        }
    }

    public struct SourceServer: AWSDecodableShape {
        /// Source server application ID.
        public let applicationID: String?
        /// Source server ARN.
        public let arn: String?
        /// Source server data replication info.
        public let dataReplicationInfo: DataReplicationInfo?
        /// Source server archived status.
        public let isArchived: Bool?
        /// Source server launched instance.
        public let launchedInstance: LaunchedInstance?
        /// Source server lifecycle state.
        public let lifeCycle: LifeCycle?
        /// Source server replication type.
        public let replicationType: ReplicationType?
        /// Source server properties.
        public let sourceProperties: SourceProperties?
        /// Source server ID.
        public let sourceServerID: String?
        /// Source server Tags.
        public let tags: [String: String]?
        /// Source server vCenter client id.
        public let vcenterClientID: String?

        public init(applicationID: String? = nil, arn: String? = nil, dataReplicationInfo: DataReplicationInfo? = nil, isArchived: Bool? = nil, launchedInstance: LaunchedInstance? = nil, lifeCycle: LifeCycle? = nil, replicationType: ReplicationType? = nil, sourceProperties: SourceProperties? = nil, sourceServerID: String? = nil, tags: [String: String]? = nil, vcenterClientID: String? = nil) {
            self.applicationID = applicationID
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.replicationType = replicationType
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
            self.vcenterClientID = vcenterClientID
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
            case arn
            case dataReplicationInfo
            case isArchived
            case launchedInstance
            case lifeCycle
            case replicationType
            case sourceProperties
            case sourceServerID
            case tags
            case vcenterClientID
        }
    }

    public struct SourceServerActionDocument: AWSDecodableShape {
        /// Source server post migration custom action ID.
        public let actionID: String?
        /// Source server post migration custom action name.
        public let actionName: String?
        /// Source server post migration custom action active status.
        public let active: Bool?
        /// Source server post migration custom action document identifier.
        public let documentIdentifier: String?
        /// Source server post migration custom action document version.
        public let documentVersion: String?
        /// Source server post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Source server post migration custom action order.
        public let order: Int?
        /// Source server post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Source server post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        public init(actionID: String? = nil, actionName: String? = nil, active: Bool? = nil, documentIdentifier: String? = nil, documentVersion: String? = nil, mustSucceedForCutover: Bool? = nil, order: Int? = nil, parameters: [String: [SsmParameterStoreParameter]]? = nil, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case actionID
            case actionName
            case active
            case documentIdentifier
            case documentVersion
            case mustSucceedForCutover
            case order
            case parameters
            case timeoutSeconds
        }
    }

    public struct SourceServerActionsRequestFilters: AWSEncodableShape {
        /// Action IDs to filter source server post migration custom actions by.
        public let actionIDs: [String]?

        public init(actionIDs: [String]? = nil) {
            self.actionIDs = actionIDs
        }

        public func validate(name: String) throws {
            try self.actionIDs?.forEach {
                try validate($0, name: "actionIDs[]", parent: name, max: 64)
                try validate($0, name: "actionIDs[]", parent: name, min: 1)
                try validate($0, name: "actionIDs[]", parent: name, pattern: "[0-9a-zA-Z]$")
            }
            try self.validate(self.actionIDs, name: "actionIDs", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case actionIDs
        }
    }

    public struct SsmDocument: AWSEncodableShape & AWSDecodableShape {
        /// User-friendly name for the AWS Systems Manager Document.
        public let actionName: String
        /// If true, Cutover will not be enabled if the document has failed.
        public let mustSucceedForCutover: Bool?
        /// AWS Systems Manager Document parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// AWS Systems Manager Document name or full ARN.
        public let ssmDocumentName: String
        /// AWS Systems Manager Document timeout seconds.
        public let timeoutSeconds: Int?

        public init(actionName: String, mustSucceedForCutover: Bool? = nil, parameters: [String: [SsmParameterStoreParameter]]? = nil, ssmDocumentName: String, timeoutSeconds: Int? = nil) {
            self.actionName = actionName
            self.mustSucceedForCutover = mustSucceedForCutover
            self.parameters = parameters
            self.ssmDocumentName = ssmDocumentName
            self.timeoutSeconds = timeoutSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.actionName, name: "actionName", parent: name, max: 256)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.ssmDocumentName, name: "ssmDocumentName", parent: name, max: 172)
            try self.validate(self.ssmDocumentName, name: "ssmDocumentName", parent: name, min: 3)
            try self.validate(self.ssmDocumentName, name: "ssmDocumentName", parent: name, pattern: "^([A-Za-z0-9/:_\\.-])+$")
            try self.validate(self.timeoutSeconds, name: "timeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionName
            case mustSucceedForCutover
            case parameters
            case ssmDocumentName
            case timeoutSeconds
        }
    }

    public struct SsmParameterStoreParameter: AWSEncodableShape & AWSDecodableShape {
        /// AWS Systems Manager Parameter Store parameter name.
        public let parameterName: String
        /// AWS Systems Manager Parameter Store parameter type.
        public let parameterType: SsmParameterStoreParameterType

        public init(parameterName: String, parameterType: SsmParameterStoreParameterType) {
            self.parameterName = parameterName
            self.parameterType = parameterType
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 1011)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^([A-Za-z0-9_\\.-])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName
            case parameterType
        }
    }

    public struct StartCutoverRequest: AWSEncodableShape {
        /// Start Cutover by Source Server IDs.
        public let sourceServerIDs: [String]
        /// Start Cutover by Tags.
        public let tags: [String: String]?

        public init(sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerIDs
            case tags
        }
    }

    public struct StartCutoverResponse: AWSDecodableShape {
        /// Start Cutover Job response.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct StartReplicationRequest: AWSEncodableShape {
        /// ID of source server on which to start replication.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct StartTestRequest: AWSEncodableShape {
        /// Start Test for Source Server IDs.
        public let sourceServerIDs: [String]
        /// Start Test by Tags.
        public let tags: [String: String]?

        public init(sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerIDs
            case tags
        }
    }

    public struct StartTestResponse: AWSDecodableShape {
        /// Start Test Job response.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// Tag resource by ARN.
        public let resourceArn: String
        /// Tag resource by Tags.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TemplateActionDocument: AWSDecodableShape {
        /// Template post migration custom action ID.
        public let actionID: String?
        /// Template post migration custom action name.
        public let actionName: String?
        /// Template post migration custom action active status.
        public let active: Bool?
        /// Template post migration custom action document identifier.
        public let documentIdentifier: String?
        /// Template post migration custom action document version.
        public let documentVersion: String?
        /// Template post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Operating system eligible for this template post migration custom action.
        public let operatingSystem: String?
        /// Template post migration custom action order.
        public let order: Int?
        /// Template post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        public init(actionID: String? = nil, actionName: String? = nil, active: Bool? = nil, documentIdentifier: String? = nil, documentVersion: String? = nil, mustSucceedForCutover: Bool? = nil, operatingSystem: String? = nil, order: Int? = nil, parameters: [String: [SsmParameterStoreParameter]]? = nil, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case actionID
            case actionName
            case active
            case documentIdentifier
            case documentVersion
            case mustSucceedForCutover
            case operatingSystem
            case order
            case parameters
            case timeoutSeconds
        }
    }

    public struct TemplateActionsRequestFilters: AWSEncodableShape {
        /// Action IDs to filter template post migration custom actions by.
        public let actionIDs: [String]?

        public init(actionIDs: [String]? = nil) {
            self.actionIDs = actionIDs
        }

        public func validate(name: String) throws {
            try self.actionIDs?.forEach {
                try validate($0, name: "actionIDs[]", parent: name, max: 64)
                try validate($0, name: "actionIDs[]", parent: name, min: 1)
                try validate($0, name: "actionIDs[]", parent: name, pattern: "[0-9a-zA-Z]$")
            }
            try self.validate(self.actionIDs, name: "actionIDs", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case actionIDs
        }
    }

    public struct TerminateTargetInstancesRequest: AWSEncodableShape {
        /// Terminate Target instance by Source Server IDs.
        public let sourceServerIDs: [String]
        /// Terminate Target instance by Tags.
        public let tags: [String: String]?

        public init(sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerIDs
            case tags
        }
    }

    public struct TerminateTargetInstancesResponse: AWSDecodableShape {
        /// Terminate Target instance Job response.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct UnarchiveApplicationRequest: AWSEncodableShape {
        /// Application ID.
        public let applicationID: String

        public init(applicationID: String) {
            self.applicationID = applicationID
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
        }
    }

    public struct UnarchiveWaveRequest: AWSEncodableShape {
        /// Wave ID.
        public let waveID: String

        public init(waveID: String) {
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case waveID
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// Untag resource by ARN.
        public let resourceArn: String
        /// Untag resource by Keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// Application ID.
        public let applicationID: String
        /// Application description.
        public let description: String?
        /// Application name.
        public let name: String?

        public init(applicationID: String, description: String? = nil, name: String? = nil) {
            self.applicationID = applicationID
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID
            case description
            case name
        }
    }

    public struct UpdateLaunchConfigurationRequest: AWSEncodableShape {
        /// Update Launch configuration boot mode request.
        public let bootMode: BootMode?
        /// Update Launch configuration copy Private IP request.
        public let copyPrivateIp: Bool?
        /// Update Launch configuration copy Tags request.
        public let copyTags: Bool?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Update Launch configuration launch disposition request.
        public let launchDisposition: LaunchDisposition?
        /// Update Launch configuration licensing request.
        public let licensing: Licensing?
        /// Launch configuration map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Update Launch configuration name request.
        public let name: String?
        public let postLaunchActions: PostLaunchActions?
        /// Update Launch configuration by Source Server ID request.
        public let sourceServerID: String
        /// Update Launch configuration Target instance right sizing request.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, enableMapAutoTagging: Bool? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, name: String? = nil, postLaunchActions: PostLaunchActions? = nil, sourceServerID: String, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.enableMapAutoTagging = enableMapAutoTagging
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.name = name
            self.postLaunchActions = postLaunchActions
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.mapAutoTaggingMpeID, name: "mapAutoTaggingMpeID", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.postLaunchActions?.validate(name: "\(name).postLaunchActions")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bootMode
            case copyPrivateIp
            case copyTags
            case enableMapAutoTagging
            case launchDisposition
            case licensing
            case mapAutoTaggingMpeID
            case name
            case postLaunchActions
            case sourceServerID
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct UpdateLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// Associate public Ip address.
        public let associatePublicIpAddress: Bool?
        /// Launch configuration template boot mode.
        public let bootMode: BootMode?
        /// Copy private Ip.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Large volume config.
        public let largeVolumeConf: LaunchTemplateDiskConf?
        /// Launch Configuration Template ID.
        public let launchConfigurationTemplateID: String
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        public let licensing: Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Post Launch Action to execute on the Test or Cutover instance.
        public let postLaunchActions: PostLaunchActions?
        /// Small volume config.
        public let smallVolumeConf: LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public let smallVolumeMaxSize: Int64?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(associatePublicIpAddress: Bool? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, enableMapAutoTagging: Bool? = nil, largeVolumeConf: LaunchTemplateDiskConf? = nil, launchConfigurationTemplateID: String, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, postLaunchActions: PostLaunchActions? = nil, smallVolumeConf: LaunchTemplateDiskConf? = nil, smallVolumeMaxSize: Int64? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.largeVolumeConf?.validate(name: "\(name).largeVolumeConf")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            try self.validate(self.mapAutoTaggingMpeID, name: "mapAutoTaggingMpeID", parent: name, max: 256)
            try self.postLaunchActions?.validate(name: "\(name).postLaunchActions")
            try self.smallVolumeConf?.validate(name: "\(name).smallVolumeConf")
            try self.validate(self.smallVolumeMaxSize, name: "smallVolumeMaxSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress
            case bootMode
            case copyPrivateIp
            case copyTags
            case enableMapAutoTagging
            case largeVolumeConf
            case launchConfigurationTemplateID
            case launchDisposition
            case licensing
            case mapAutoTaggingMpeID
            case postLaunchActions
            case smallVolumeConf
            case smallVolumeMaxSize
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct UpdateReplicationConfigurationRequest: AWSEncodableShape {
        /// Update replication configuration associate default Application Migration Service Security group request.
        public let associateDefaultSecurityGroup: Bool?
        /// Update replication configuration bandwidth throttling request.
        public let bandwidthThrottling: Int64?
        /// Update replication configuration create Public IP request.
        public let createPublicIP: Bool?
        /// Update replication configuration data plane routing request.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Update replication configuration use default large Staging Disk type request.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Update replication configuration EBS encryption request.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Update replication configuration EBS encryption key ARN request.
        public let ebsEncryptionKeyArn: String?
        /// Update replication configuration name request.
        public let name: String?
        /// Update replication configuration replicated disks request.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// Update replication configuration Replication Server instance type request.
        public let replicationServerInstanceType: String?
        /// Update replication configuration Replication Server Security Groups IDs request.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Update replication configuration Source Server ID request.
        public let sourceServerID: String
        /// Update replication configuration Staging Area subnet request.
        public let stagingAreaSubnetId: String?
        /// Update replication configuration Staging Area Tags request.
        public let stagingAreaTags: [String: String]?
        /// Update replication configuration use dedicated Replication Server request.
        public let useDedicatedReplicationServer: Bool?

        public init(associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.replicatedDisks?.forEach {
                try $0.validate(name: "\(name).replicatedDisks[]")
            }
            try self.validate(self.replicatedDisks, name: "replicatedDisks", parent: name, max: 60)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case name
            case replicatedDisks
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case sourceServerID
            case stagingAreaSubnetId
            case stagingAreaTags
            case useDedicatedReplicationServer
        }
    }

    public struct UpdateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Update replication configuration template ARN request.
        public let arn: String?
        /// Update replication configuration template associate default Application Migration Service Security group request.
        public let associateDefaultSecurityGroup: Bool?
        /// Update replication configuration template bandwidth throttling request.
        public let bandwidthThrottling: Int64?
        /// Update replication configuration template create Public IP request.
        public let createPublicIP: Bool?
        /// Update replication configuration template data plane routing request.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Update replication configuration template use default large Staging Disk type request.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Update replication configuration template EBS encryption request.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Update replication configuration template EBS encryption key ARN request.
        public let ebsEncryptionKeyArn: String?
        /// Update replication configuration template template ID request.
        public let replicationConfigurationTemplateID: String
        /// Update replication configuration template Replication Server instance type request.
        public let replicationServerInstanceType: String?
        /// Update replication configuration template Replication Server Security groups IDs request.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Update replication configuration template Staging Area subnet ID request.
        public let stagingAreaSubnetId: String?
        /// Update replication configuration template Staging Area Tags request.
        public let stagingAreaTags: [String: String]?
        /// Update replication configuration template use dedicated Replication Server request.
        public let useDedicatedReplicationServer: Bool?

        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case replicationConfigurationTemplateID
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case stagingAreaSubnetId
            case stagingAreaTags
            case useDedicatedReplicationServer
        }
    }

    public struct UpdateSourceServerReplicationTypeRequest: AWSEncodableShape {
        /// Replication type to which to update source server.
        public let replicationType: ReplicationType
        /// ID of source server on which to update replication type.
        public let sourceServerID: String

        public init(replicationType: ReplicationType, sourceServerID: String) {
            self.replicationType = replicationType
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationType
            case sourceServerID
        }
    }

    public struct UpdateWaveRequest: AWSEncodableShape {
        /// Wave description.
        public let description: String?
        /// Wave name.
        public let name: String?
        /// Wave ID.
        public let waveID: String

        public init(description: String? = nil, name: String? = nil, waveID: String) {
            self.description = description
            self.name = name
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case waveID
        }
    }

    public struct VcenterClient: AWSDecodableShape {
        /// Arn of vCenter client.
        public let arn: String?
        /// Datacenter name of vCenter client.
        public let datacenterName: String?
        /// Hostname of vCenter client .
        public let hostname: String?
        /// Last seen time of vCenter client.
        public let lastSeenDatetime: String?
        /// Tags for Source Server of vCenter client.
        public let sourceServerTags: [String: String]?
        /// Tags for vCenter client.
        public let tags: [String: String]?
        /// ID of vCenter client.
        public let vcenterClientID: String?
        /// Vcenter UUID of vCenter client.
        public let vcenterUUID: String?

        public init(arn: String? = nil, datacenterName: String? = nil, hostname: String? = nil, lastSeenDatetime: String? = nil, sourceServerTags: [String: String]? = nil, tags: [String: String]? = nil, vcenterClientID: String? = nil, vcenterUUID: String? = nil) {
            self.arn = arn
            self.datacenterName = datacenterName
            self.hostname = hostname
            self.lastSeenDatetime = lastSeenDatetime
            self.sourceServerTags = sourceServerTags
            self.tags = tags
            self.vcenterClientID = vcenterClientID
            self.vcenterUUID = vcenterUUID
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case datacenterName
            case hostname
            case lastSeenDatetime
            case sourceServerTags
            case tags
            case vcenterClientID
            case vcenterUUID
        }
    }

    public struct Wave: AWSDecodableShape {
        /// Wave ARN.
        public let arn: String?
        /// Wave creation dateTime.
        public let creationDateTime: String?
        /// Wave description.
        public let description: String?
        /// Wave archival status.
        public let isArchived: Bool?
        /// Wave last modified dateTime.
        public let lastModifiedDateTime: String?
        /// Wave name.
        public let name: String?
        /// Wave tags.
        public let tags: [String: String]?
        /// Wave aggregated status.
        public let waveAggregatedStatus: WaveAggregatedStatus?
        /// Wave ID.
        public let waveID: String?

        public init(arn: String? = nil, creationDateTime: String? = nil, description: String? = nil, isArchived: Bool? = nil, lastModifiedDateTime: String? = nil, name: String? = nil, tags: [String: String]? = nil, waveAggregatedStatus: WaveAggregatedStatus? = nil, waveID: String? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveAggregatedStatus = waveAggregatedStatus
            self.waveID = waveID
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case isArchived
            case lastModifiedDateTime
            case name
            case tags
            case waveAggregatedStatus
            case waveID
        }
    }

    public struct WaveAggregatedStatus: AWSDecodableShape {
        /// Wave aggregated status health status.
        public let healthStatus: WaveHealthStatus?
        /// Wave aggregated status last update dateTime.
        public let lastUpdateDateTime: String?
        /// Wave aggregated status progress status.
        public let progressStatus: WaveProgressStatus?
        /// DateTime marking when the first source server in the wave started replication.
        public let replicationStartedDateTime: String?
        /// Wave aggregated status total applications amount.
        public let totalApplications: Int64?

        public init(healthStatus: WaveHealthStatus? = nil, lastUpdateDateTime: String? = nil, progressStatus: WaveProgressStatus? = nil, replicationStartedDateTime: String? = nil, totalApplications: Int64? = nil) {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.replicationStartedDateTime = replicationStartedDateTime
            self.totalApplications = totalApplications
        }

        private enum CodingKeys: String, CodingKey {
            case healthStatus
            case lastUpdateDateTime
            case progressStatus
            case replicationStartedDateTime
            case totalApplications
        }
    }
}

// MARK: - Errors

/// Error enum for Mgn
public struct MgnErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case uninitializedAccountException = "UninitializedAccountException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Mgn
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Operating denied due to a file permission or access check error.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be completed due to a conflict with the current state of the target resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The server encountered an unexpected condition that prevented it from fulfilling the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Resource not found exception.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request could not be completed because its exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Reached throttling quota exception.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Uninitialized account exception.
    public static var uninitializedAccountException: Self { .init(.uninitializedAccountException) }
    /// Validate exception.
    public static var validationException: Self { .init(.validationException) }
}

extension MgnErrorType: Equatable {
    public static func == (lhs: MgnErrorType, rhs: MgnErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MgnErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
