//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Mgn {
    // MARK: Enums

    public enum ActionCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backup = "BACKUP"
        case configuration = "CONFIGURATION"
        case disasterRecovery = "DISASTER_RECOVERY"
        case licenseAndSubscription = "LICENSE_AND_SUBSCRIPTION"
        case networking = "NETWORKING"
        case observability = "OBSERVABILITY"
        case operatingSystem = "OPERATING_SYSTEM"
        case other = "OTHER"
        case refactoring = "REFACTORING"
        case security = "SECURITY"
        case validation = "VALIDATION"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationHealthStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case healthy = "HEALTHY"
        case lagging = "LAGGING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationProgressStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum BootMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case legacyBios = "LEGACY_BIOS"
        case uefi = "UEFI"
        case useSource = "USE_SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cutover = "CUTOVER"
        case readyForCutover = "READY_FOR_CUTOVER"
        case readyForTest = "READY_FOR_TEST"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationErrorString: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentNotSeen = "AGENT_NOT_SEEN"
        case failedToAttachStagingDisks = "FAILED_TO_ATTACH_STAGING_DISKS"
        case failedToAuthenticateWithService = "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
        case failedToBootReplicationServer = "FAILED_TO_BOOT_REPLICATION_SERVER"
        case failedToConnectAgentToReplicationServer = "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
        case failedToCreateSecurityGroup = "FAILED_TO_CREATE_SECURITY_GROUP"
        case failedToCreateStagingDisks = "FAILED_TO_CREATE_STAGING_DISKS"
        case failedToDownloadReplicationSoftware = "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
        case failedToLaunchReplicationServer = "FAILED_TO_LAUNCH_REPLICATION_SERVER"
        case failedToPairReplicationServerWithAgent = "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
        case failedToStartDataTransfer = "FAILED_TO_START_DATA_TRANSFER"
        case lastSnapshotJobFailed = "LAST_SNAPSHOT_JOB_FAILED"
        case notConverging = "NOT_CONVERGING"
        case snapshotsFailure = "SNAPSHOTS_FAILURE"
        case unstableNetwork = "UNSTABLE_NETWORK"
        case unsupportedVmConfiguration = "UNSUPPORTED_VM_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachStagingDisks = "ATTACH_STAGING_DISKS"
        case authenticateWithService = "AUTHENTICATE_WITH_SERVICE"
        case bootReplicationServer = "BOOT_REPLICATION_SERVER"
        case connectAgentToReplicationServer = "CONNECT_AGENT_TO_REPLICATION_SERVER"
        case createSecurityGroup = "CREATE_SECURITY_GROUP"
        case createStagingDisks = "CREATE_STAGING_DISKS"
        case downloadReplicationSoftware = "DOWNLOAD_REPLICATION_SOFTWARE"
        case launchReplicationServer = "LAUNCH_REPLICATION_SERVER"
        case pairReplicationServerWithAgent = "PAIR_REPLICATION_SERVER_WITH_AGENT"
        case startDataTransfer = "START_DATA_TRANSFER"
        case wait = "WAIT"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case skipped = "SKIPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backlog = "BACKLOG"
        case continuous = "CONTINUOUS"
        case creatingSnapshot = "CREATING_SNAPSHOT"
        case disconnected = "DISCONNECTED"
        case initialSync = "INITIAL_SYNC"
        case initiating = "INITIATING"
        case paused = "PAUSED"
        case pendingSnapshotShipping = "PENDING_SNAPSHOT_SHIPPING"
        case rescan = "RESCAN"
        case shippingSnapshot = "SHIPPING_SNAPSHOT"
        case stalled = "STALLED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum ExportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case started = "STARTED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum FirstBoot: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case stopped = "STOPPED"
        case succeeded = "SUCCEEDED"
        case unknown = "UNKNOWN"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum ImportErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case processingError = "PROCESSING_ERROR"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ImportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case started = "STARTED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum InitiatedBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case diagnostic = "DIAGNOSTIC"
        case startCutover = "START_CUTOVER"
        case startTest = "START_TEST"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum JobLogEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cleanupEnd = "CLEANUP_END"
        case cleanupFail = "CLEANUP_FAIL"
        case cleanupStart = "CLEANUP_START"
        case conversionEnd = "CONVERSION_END"
        case conversionFail = "CONVERSION_FAIL"
        case conversionStart = "CONVERSION_START"
        case jobCancel = "JOB_CANCEL"
        case jobEnd = "JOB_END"
        case jobStart = "JOB_START"
        case launchFailed = "LAUNCH_FAILED"
        case launchStart = "LAUNCH_START"
        case serverSkipped = "SERVER_SKIPPED"
        case snapshotEnd = "SNAPSHOT_END"
        case snapshotFail = "SNAPSHOT_FAIL"
        case snapshotStart = "SNAPSHOT_START"
        case usingPreviousSnapshot = "USING_PREVIOUS_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case pending = "PENDING"
        case started = "STARTED"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case launch = "LAUNCH"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum LaunchDisposition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case launched = "LAUNCHED"
        case pending = "PENDING"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum LifeCycleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cutover = "CUTOVER"
        case cuttingOver = "CUTTING_OVER"
        case disconnected = "DISCONNECTED"
        case discovered = "DISCOVERED"
        case notReady = "NOT_READY"
        case pendingInstallation = "PENDING_INSTALLATION"
        case readyForCutover = "READY_FOR_CUTOVER"
        case readyForTest = "READY_FOR_TEST"
        case stopped = "STOPPED"
        case testing = "TESTING"
        public var description: String { return self.rawValue }
    }

    public enum PostLaunchActionExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum PostLaunchActionsDeploymentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cutoverOnly = "CUTOVER_ONLY"
        case testAndCutover = "TEST_AND_CUTOVER"
        case testOnly = "TEST_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDataPlaneRouting: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case privateIp = "PRIVATE_IP"
        case publicIp = "PUBLIC_IP"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDefaultLargeStagingDiskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gp2 = "GP2"
        case gp3 = "GP3"
        case st1 = "ST1"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationEbsEncryption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case gp2 = "GP2"
        case gp3 = "GP3"
        case io1 = "IO1"
        case io2 = "IO2"
        case sc1 = "SC1"
        case st1 = "ST1"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentBased = "AGENT_BASED"
        case snapshotShipping = "SNAPSHOT_SHIPPING"
        public var description: String { return self.rawValue }
    }

    public enum SsmDocumentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automation = "AUTOMATION"
        case command = "COMMAND"
        public var description: String { return self.rawValue }
    }

    public enum SsmParameterStoreParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum TargetInstanceTypeRightSizingMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum VolumeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gp2 = "gp2"
        case gp3 = "gp3"
        case io1 = "io1"
        case io2 = "io2"
        case sc1 = "sc1"
        case st1 = "st1"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public enum WaveHealthStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case healthy = "HEALTHY"
        case lagging = "LAGGING"
        public var description: String { return self.rawValue }
    }

    public enum WaveProgressStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct Application: AWSDecodableShape {
        /// Application aggregated status.
        public let applicationAggregatedStatus: ApplicationAggregatedStatus?
        /// Application ID.
        public let applicationID: String?
        /// Application ARN.
        public let arn: String?
        /// Application creation dateTime.
        public let creationDateTime: String?
        /// Application description.
        public let description: String?
        /// Application archival status.
        public let isArchived: Bool?
        /// Application last modified dateTime.
        public let lastModifiedDateTime: String?
        /// Application name.
        public let name: String?
        /// Application tags.
        public let tags: [String: String]?
        /// Application wave ID.
        public let waveID: String?

        @inlinable
        public init(applicationAggregatedStatus: ApplicationAggregatedStatus? = nil, applicationID: String? = nil, arn: String? = nil, creationDateTime: String? = nil, description: String? = nil, isArchived: Bool? = nil, lastModifiedDateTime: String? = nil, name: String? = nil, tags: [String: String]? = nil, waveID: String? = nil) {
            self.applicationAggregatedStatus = applicationAggregatedStatus
            self.applicationID = applicationID
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveID = waveID
        }

        private enum CodingKeys: String, CodingKey {
            case applicationAggregatedStatus = "applicationAggregatedStatus"
            case applicationID = "applicationID"
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case isArchived = "isArchived"
            case lastModifiedDateTime = "lastModifiedDateTime"
            case name = "name"
            case tags = "tags"
            case waveID = "waveID"
        }
    }

    public struct ApplicationAggregatedStatus: AWSDecodableShape {
        /// Application aggregated status health status.
        public let healthStatus: ApplicationHealthStatus?
        /// Application aggregated status last update dateTime.
        public let lastUpdateDateTime: String?
        /// Application aggregated status progress status.
        public let progressStatus: ApplicationProgressStatus?
        /// Application aggregated status total source servers amount.
        public let totalSourceServers: Int64?

        @inlinable
        public init(healthStatus: ApplicationHealthStatus? = nil, lastUpdateDateTime: String? = nil, progressStatus: ApplicationProgressStatus? = nil, totalSourceServers: Int64? = nil) {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.totalSourceServers = totalSourceServers
        }

        private enum CodingKeys: String, CodingKey {
            case healthStatus = "healthStatus"
            case lastUpdateDateTime = "lastUpdateDateTime"
            case progressStatus = "progressStatus"
            case totalSourceServers = "totalSourceServers"
        }
    }

    public struct ArchiveApplicationRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application ID.
        public let applicationID: String

        @inlinable
        public init(accountID: String? = nil, applicationID: String) {
            self.accountID = accountID
            self.applicationID = applicationID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
        }
    }

    public struct ArchiveWaveRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Wave ID.
        public let waveID: String

        @inlinable
        public init(accountID: String? = nil, waveID: String) {
            self.accountID = accountID
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case waveID = "waveID"
        }
    }

    public struct AssociateApplicationsRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application IDs list.
        public let applicationIDs: [String]
        /// Wave ID.
        public let waveID: String

        @inlinable
        public init(accountID: String? = nil, applicationIDs: [String], waveID: String) {
            self.accountID = accountID
            self.applicationIDs = applicationIDs
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.applicationIDs.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 50)
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, min: 1)
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationIDs = "applicationIDs"
            case waveID = "waveID"
        }
    }

    public struct AssociateApplicationsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateSourceServersRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application ID.
        public let applicationID: String
        /// Source server IDs list.
        public let sourceServerIDs: [String]

        @inlinable
        public init(accountID: String? = nil, applicationID: String, sourceServerIDs: [String]) {
            self.accountID = accountID
            self.applicationID = applicationID
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 50)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
            case sourceServerIDs = "sourceServerIDs"
        }
    }

    public struct AssociateSourceServersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CPU: AWSDecodableShape {
        /// The number of CPU cores on the source server.
        public let cores: Int64?
        /// The source server's CPU model name.
        public let modelName: String?

        @inlinable
        public init(cores: Int64? = nil, modelName: String? = nil) {
            self.cores = cores
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case cores = "cores"
            case modelName = "modelName"
        }
    }

    public struct ChangeServerLifeCycleStateRequest: AWSEncodableShape {
        /// The request to change the source server migration account ID.
        public let accountID: String?
        /// The request to change the source server migration lifecycle state.
        public let lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle
        /// The request to change the source server migration lifecycle state by source server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle, sourceServerID: String) {
            self.accountID = accountID
            self.lifeCycle = lifeCycle
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case lifeCycle = "lifeCycle"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct ChangeServerLifeCycleStateSourceServerLifecycle: AWSEncodableShape {
        /// The request to change the source server migration lifecycle state.
        public let state: ChangeServerLifeCycleStateSourceServerLifecycleState

        @inlinable
        public init(state: ChangeServerLifeCycleStateSourceServerLifecycleState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let code: String?
        /// Conflict Exception specific errors.
        public let errors: [ErrorDetails]?
        public let message: String?
        /// A conflict occurred when prompting for the Resource ID.
        public let resourceId: String?
        /// A conflict occurred when prompting for resource type.
        public let resourceType: String?

        @inlinable
        public init(code: String? = nil, errors: [ErrorDetails]? = nil, message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.code = code
            self.errors = errors
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case errors = "errors"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct Connector: AWSDecodableShape {
        /// Connector arn.
        public let arn: String?
        /// Connector ID.
        public let connectorID: String?
        /// Connector name.
        public let name: String?
        /// Connector SSM command config.
        public let ssmCommandConfig: ConnectorSsmCommandConfig?
        /// Connector SSM instance ID.
        public let ssmInstanceID: String?
        /// Connector tags.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, connectorID: String? = nil, name: String? = nil, ssmCommandConfig: ConnectorSsmCommandConfig? = nil, ssmInstanceID: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.connectorID = connectorID
            self.name = name
            self.ssmCommandConfig = ssmCommandConfig
            self.ssmInstanceID = ssmInstanceID
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case connectorID = "connectorID"
            case name = "name"
            case ssmCommandConfig = "ssmCommandConfig"
            case ssmInstanceID = "ssmInstanceID"
            case tags = "tags"
        }
    }

    public struct ConnectorSsmCommandConfig: AWSEncodableShape & AWSDecodableShape {
        /// Connector SSM command config CloudWatch log group name.
        public let cloudWatchLogGroupName: String?
        /// Connector SSM command config CloudWatch output enabled.
        public let cloudWatchOutputEnabled: Bool
        /// Connector SSM command config output S3 bucket name.
        public let outputS3BucketName: String?
        /// Connector SSM command config S3 output enabled.
        public let s3OutputEnabled: Bool

        @inlinable
        public init(cloudWatchLogGroupName: String? = nil, cloudWatchOutputEnabled: Bool, outputS3BucketName: String? = nil, s3OutputEnabled: Bool) {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
            self.outputS3BucketName = outputS3BucketName
            self.s3OutputEnabled = s3OutputEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, max: 512)
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, min: 1)
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, pattern: "^[\\.\\-_/#A-Za-z0-9]+$")
            try self.validate(self.outputS3BucketName, name: "outputS3BucketName", parent: name, pattern: "^[a-zA-Z0-9.\\-_]{1,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupName = "cloudWatchLogGroupName"
            case cloudWatchOutputEnabled = "cloudWatchOutputEnabled"
            case outputS3BucketName = "outputS3BucketName"
            case s3OutputEnabled = "s3OutputEnabled"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application description.
        public let description: String?
        /// Application name.
        public let name: String
        /// Application tags.
        public let tags: [String: String]?

        @inlinable
        public init(accountID: String? = nil, description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.accountID = accountID
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateConnectorRequest: AWSEncodableShape {
        /// Create Connector request name.
        public let name: String
        /// Create Connector request SSM command config.
        public let ssmCommandConfig: ConnectorSsmCommandConfig?
        /// Create Connector request SSM instance ID.
        public let ssmInstanceID: String
        /// Create Connector request tags.
        public let tags: [String: String]?

        @inlinable
        public init(name: String, ssmCommandConfig: ConnectorSsmCommandConfig? = nil, ssmInstanceID: String, tags: [String: String]? = nil) {
            self.name = name
            self.ssmCommandConfig = ssmCommandConfig
            self.ssmInstanceID = ssmInstanceID
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.ssmCommandConfig?.validate(name: "\(name).ssmCommandConfig")
            try self.validate(self.ssmInstanceID, name: "ssmInstanceID", parent: name, max: 20)
            try self.validate(self.ssmInstanceID, name: "ssmInstanceID", parent: name, min: 19)
            try self.validate(self.ssmInstanceID, name: "ssmInstanceID", parent: name, pattern: "(^i-[0-9a-zA-Z]{17}$)|(^mi-[0-9a-zA-Z]{17}$)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case ssmCommandConfig = "ssmCommandConfig"
            case ssmInstanceID = "ssmInstanceID"
            case tags = "tags"
        }
    }

    public struct CreateLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// Associate public Ip address.
        public let associatePublicIpAddress: Bool?
        /// Launch configuration template boot mode.
        public let bootMode: BootMode?
        /// Copy private Ip.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Large volume config.
        public let largeVolumeConf: LaunchTemplateDiskConf?
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        public let licensing: Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Launch configuration template post launch actions.
        public let postLaunchActions: PostLaunchActions?
        /// Small volume config.
        public let smallVolumeConf: LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public let smallVolumeMaxSize: Int64?
        /// Request to associate tags during creation of a Launch Configuration Template.
        public let tags: [String: String]?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        @inlinable
        public init(associatePublicIpAddress: Bool? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, enableMapAutoTagging: Bool? = nil, largeVolumeConf: LaunchTemplateDiskConf? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, postLaunchActions: PostLaunchActions? = nil, smallVolumeConf: LaunchTemplateDiskConf? = nil, smallVolumeMaxSize: Int64? = nil, tags: [String: String]? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.largeVolumeConf?.validate(name: "\(name).largeVolumeConf")
            try self.validate(self.mapAutoTaggingMpeID, name: "mapAutoTaggingMpeID", parent: name, max: 256)
            try self.postLaunchActions?.validate(name: "\(name).postLaunchActions")
            try self.smallVolumeConf?.validate(name: "\(name).smallVolumeConf")
            try self.validate(self.smallVolumeMaxSize, name: "smallVolumeMaxSize", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress = "associatePublicIpAddress"
            case bootMode = "bootMode"
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case enableMapAutoTagging = "enableMapAutoTagging"
            case largeVolumeConf = "largeVolumeConf"
            case launchDisposition = "launchDisposition"
            case licensing = "licensing"
            case mapAutoTaggingMpeID = "mapAutoTaggingMpeID"
            case postLaunchActions = "postLaunchActions"
            case smallVolumeConf = "smallVolumeConf"
            case smallVolumeMaxSize = "smallVolumeMaxSize"
            case tags = "tags"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct CreateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
        public let associateDefaultSecurityGroup: Bool
        /// Request to configure bandwidth throttling during Replication Settings template creation.
        public let bandwidthThrottling: Int64
        /// Request to create Public IP during Replication Settings template creation.
        public let createPublicIP: Bool
        /// Request to configure  data plane routing during Replication Settings template creation.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting
        /// Request to configure the default large staging disk EBS volume type during Replication Settings template creation.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType
        /// Request to configure EBS encryption during Replication Settings template creation.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption
        /// Request to configure an EBS encryption key during Replication Settings template creation.
        public let ebsEncryptionKeyArn: String?
        /// Request to configure the Replication Server instance type during Replication Settings template creation.
        public let replicationServerInstanceType: String
        /// Request to configure the Replication Server Security group ID during Replication Settings template creation.
        public let replicationServersSecurityGroupsIDs: [String]
        /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
        public let stagingAreaSubnetId: String
        /// Request to configure Staging Area tags during Replication Settings template creation.
        public let stagingAreaTags: [String: String]
        /// Request to configure tags during Replication Settings template creation.
        public let tags: [String: String]?
        /// Request to use Dedicated Replication Servers during Replication Settings template creation.
        public let useDedicatedReplicationServer: Bool
        /// Request to use Fips Endpoint during Replication Settings template creation.
        public let useFipsEndpoint: Bool?

        @inlinable
        public init(associateDefaultSecurityGroup: Bool, bandwidthThrottling: Int64 = 0, createPublicIP: Bool, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType, ebsEncryption: ReplicationConfigurationEbsEncryption, ebsEncryptionKeyArn: String? = nil, replicationServerInstanceType: String, replicationServersSecurityGroupsIDs: [String], stagingAreaSubnetId: String, stagingAreaTags: [String: String], tags: [String: String]? = nil, useDedicatedReplicationServer: Bool, useFipsEndpoint: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, max: 10000)
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.stagingAreaTags, name: "stagingAreaTags", parent: name, max: 50)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case tags = "tags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
            case useFipsEndpoint = "useFipsEndpoint"
        }
    }

    public struct CreateWaveRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Wave description.
        public let description: String?
        /// Wave name.
        public let name: String
        /// Wave tags.
        public let tags: [String: String]?

        @inlinable
        public init(accountID: String? = nil, description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.accountID = accountID
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct DataReplicationError: AWSDecodableShape {
        /// Error in data replication.
        public let error: DataReplicationErrorString?
        /// Error in data replication.
        public let rawError: String?

        @inlinable
        public init(error: DataReplicationErrorString? = nil, rawError: String? = nil) {
            self.error = error
            self.rawError = rawError
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case rawError = "rawError"
        }
    }

    public struct DataReplicationInfo: AWSDecodableShape {
        /// Error in obtaining data replication info.
        public let dataReplicationError: DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public let dataReplicationInitiation: DataReplicationInitiation?
        /// Request to query the data replication state.
        public let dataReplicationState: DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public let etaDateTime: String?
        /// Request to query data replication lag duration.
        public let lagDuration: String?
        /// Request to query data replication last snapshot time.
        public let lastSnapshotDateTime: String?
        /// Request to query disks replicated.
        public let replicatedDisks: [DataReplicationInfoReplicatedDisk]?

        @inlinable
        public init(dataReplicationError: DataReplicationError? = nil, dataReplicationInitiation: DataReplicationInitiation? = nil, dataReplicationState: DataReplicationState? = nil, etaDateTime: String? = nil, lagDuration: String? = nil, lastSnapshotDateTime: String? = nil, replicatedDisks: [DataReplicationInfoReplicatedDisk]? = nil) {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.lastSnapshotDateTime = lastSnapshotDateTime
            self.replicatedDisks = replicatedDisks
        }

        private enum CodingKeys: String, CodingKey {
            case dataReplicationError = "dataReplicationError"
            case dataReplicationInitiation = "dataReplicationInitiation"
            case dataReplicationState = "dataReplicationState"
            case etaDateTime = "etaDateTime"
            case lagDuration = "lagDuration"
            case lastSnapshotDateTime = "lastSnapshotDateTime"
            case replicatedDisks = "replicatedDisks"
        }
    }

    public struct DataReplicationInfoReplicatedDisk: AWSDecodableShape {
        /// Request to query data replication backlog size in bytes.
        public let backloggedStorageBytes: Int64?
        /// Request to query device name.
        public let deviceName: String?
        /// Request to query amount of data replicated in bytes.
        public let replicatedStorageBytes: Int64?
        /// Request to query amount of data rescanned in bytes.
        public let rescannedStorageBytes: Int64?
        /// Request to query total amount of data replicated in bytes.
        public let totalStorageBytes: Int64?

        @inlinable
        public init(backloggedStorageBytes: Int64? = nil, deviceName: String? = nil, replicatedStorageBytes: Int64? = nil, rescannedStorageBytes: Int64? = nil, totalStorageBytes: Int64? = nil) {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }

        private enum CodingKeys: String, CodingKey {
            case backloggedStorageBytes = "backloggedStorageBytes"
            case deviceName = "deviceName"
            case replicatedStorageBytes = "replicatedStorageBytes"
            case rescannedStorageBytes = "rescannedStorageBytes"
            case totalStorageBytes = "totalStorageBytes"
        }
    }

    public struct DataReplicationInitiation: AWSDecodableShape {
        /// Request to query next data initiation date and time.
        public let nextAttemptDateTime: String?
        /// Request to query data initiation start date and time.
        public let startDateTime: String?
        /// Request to query data initiation steps.
        public let steps: [DataReplicationInitiationStep]?

        @inlinable
        public init(nextAttemptDateTime: String? = nil, startDateTime: String? = nil, steps: [DataReplicationInitiationStep]? = nil) {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextAttemptDateTime = "nextAttemptDateTime"
            case startDateTime = "startDateTime"
            case steps = "steps"
        }
    }

    public struct DataReplicationInitiationStep: AWSDecodableShape {
        /// Request to query data initiation step name.
        public let name: DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public let status: DataReplicationInitiationStepStatus?

        @inlinable
        public init(name: DataReplicationInitiationStepName? = nil, status: DataReplicationInitiationStepStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application ID.
        public let applicationID: String

        @inlinable
        public init(accountID: String? = nil, applicationID: String) {
            self.accountID = accountID
            self.applicationID = applicationID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
        }
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConnectorRequest: AWSEncodableShape {
        /// Delete Connector request connector ID.
        public let connectorID: String

        @inlinable
        public init(connectorID: String) {
            self.connectorID = connectorID
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorID, name: "connectorID", parent: name, max: 27)
            try self.validate(self.connectorID, name: "connectorID", parent: name, min: 27)
            try self.validate(self.connectorID, name: "connectorID", parent: name, pattern: "^connector-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorID = "connectorID"
        }
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// Request to delete Job from service by Account ID.
        public let accountID: String?
        /// Request to delete Job from service by Job ID.
        public let jobID: String

        @inlinable
        public init(accountID: String? = nil, jobID: String) {
            self.accountID = accountID
            self.jobID = jobID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case jobID = "jobID"
        }
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// ID of resource to be deleted.
        public let launchConfigurationTemplateID: String

        @inlinable
        public init(launchConfigurationTemplateID: String) {
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
        }
    }

    public struct DeleteLaunchConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
        public let replicationConfigurationTemplateID: String

        @inlinable
        public init(replicationConfigurationTemplateID: String) {
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigurationTemplateID = "replicationConfigurationTemplateID"
        }
    }

    public struct DeleteReplicationConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSourceServerRequest: AWSEncodableShape {
        /// Request to delete Source Server from service by Account ID.
        public let accountID: String?
        /// Request to delete Source Server from service by Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct DeleteSourceServerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVcenterClientRequest: AWSEncodableShape {
        /// ID of resource to be deleted.
        public let vcenterClientID: String

        @inlinable
        public init(vcenterClientID: String) {
            self.vcenterClientID = vcenterClientID
        }

        public func validate(name: String) throws {
            try self.validate(self.vcenterClientID, name: "vcenterClientID", parent: name, max: 21)
            try self.validate(self.vcenterClientID, name: "vcenterClientID", parent: name, min: 21)
            try self.validate(self.vcenterClientID, name: "vcenterClientID", parent: name, pattern: "^vcc-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case vcenterClientID = "vcenterClientID"
        }
    }

    public struct DeleteWaveRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Wave ID.
        public let waveID: String

        @inlinable
        public init(accountID: String? = nil, waveID: String) {
            self.accountID = accountID
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case waveID = "waveID"
        }
    }

    public struct DeleteWaveResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeJobLogItemsRequest: AWSEncodableShape {
        /// Request to describe Job log Account ID.
        public let accountID: String?
        /// Request to describe Job log job ID.
        public let jobID: String
        /// Request to describe Job log item maximum results.
        public let maxResults: Int?
        /// Request to describe Job log next token.
        public let nextToken: String?

        @inlinable
        public init(accountID: String? = nil, jobID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountID = accountID
            self.jobID = jobID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case jobID = "jobID"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeJobLogItemsResponse: AWSDecodableShape {
        /// Request to describe Job log response items.
        public let items: [JobLog]?
        /// Request to describe Job log response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [JobLog]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeJobsRequest: AWSEncodableShape {
        /// Request to describe job log items by Account ID.
        public let accountID: String?
        /// Request to describe Job log filters.
        public let filters: DescribeJobsRequestFilters?
        /// Request to describe job log items by max results.
        public let maxResults: Int?
        /// Request to describe job log items by next token.
        public let nextToken: String?

        @inlinable
        public init(accountID: String? = nil, filters: DescribeJobsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountID = accountID
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeJobsRequestFilters: AWSEncodableShape {
        /// Request to describe Job log filters by date.
        public let fromDate: String?
        /// Request to describe Job log filters by job ID.
        public let jobIDs: [String]?
        /// Request to describe job log items by last date.
        public let toDate: String?

        @inlinable
        public init(fromDate: String? = nil, jobIDs: [String]? = nil, toDate: String? = nil) {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }

        public func validate(name: String) throws {
            try self.validate(self.fromDate, name: "fromDate", parent: name, max: 32)
            try self.validate(self.fromDate, name: "fromDate", parent: name, min: 19)
            try self.validate(self.fromDate, name: "fromDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
            try self.jobIDs?.forEach {
                try validate($0, name: "jobIDs[]", parent: name, max: 24)
                try validate($0, name: "jobIDs[]", parent: name, min: 24)
                try validate($0, name: "jobIDs[]", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.jobIDs, name: "jobIDs", parent: name, max: 1000)
            try self.validate(self.toDate, name: "toDate", parent: name, max: 32)
            try self.validate(self.toDate, name: "toDate", parent: name, min: 19)
            try self.validate(self.toDate, name: "toDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case fromDate = "fromDate"
            case jobIDs = "jobIDs"
            case toDate = "toDate"
        }
    }

    public struct DescribeJobsResponse: AWSDecodableShape {
        /// Request to describe Job log items.
        public let items: [Job]?
        /// Request to describe Job response by next token.
        public let nextToken: String?

        @inlinable
        public init(items: [Job]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeLaunchConfigurationTemplatesRequest: AWSEncodableShape {
        /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
        public let launchConfigurationTemplateIDs: [String]?
        /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
        public let maxResults: Int?
        /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
        public let nextToken: String?

        @inlinable
        public init(launchConfigurationTemplateIDs: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.launchConfigurationTemplateIDs?.forEach {
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "launchConfigurationTemplateIDs[]", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.launchConfigurationTemplateIDs, name: "launchConfigurationTemplateIDs", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case launchConfigurationTemplateIDs = "launchConfigurationTemplateIDs"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeLaunchConfigurationTemplatesResponse: AWSDecodableShape {
        /// List of items returned by DescribeLaunchConfigurationTemplates.
        public let items: [LaunchConfigurationTemplate]?
        /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
        public let nextToken: String?

        @inlinable
        public init(items: [LaunchConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeReplicationConfigurationTemplatesRequest: AWSEncodableShape {
        /// Request to describe Replication Configuration template by max results.
        public let maxResults: Int?
        /// Request to describe Replication Configuration template by next token.
        public let nextToken: String?
        /// Request to describe Replication Configuration template by template IDs.
        public let replicationConfigurationTemplateIDs: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationConfigurationTemplateIDs: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.replicationConfigurationTemplateIDs?.forEach {
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.replicationConfigurationTemplateIDs, name: "replicationConfigurationTemplateIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case replicationConfigurationTemplateIDs = "replicationConfigurationTemplateIDs"
        }
    }

    public struct DescribeReplicationConfigurationTemplatesResponse: AWSDecodableShape {
        /// Request to describe Replication Configuration template by items.
        public let items: [ReplicationConfigurationTemplate]?
        /// Request to describe Replication Configuration template by next token.
        public let nextToken: String?

        @inlinable
        public init(items: [ReplicationConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeSourceServersRequest: AWSEncodableShape {
        /// Request to filter Source Servers list by Accoun ID.
        public let accountID: String?
        /// Request to filter Source Servers list.
        public let filters: DescribeSourceServersRequestFilters?
        /// Request to filter Source Servers list by maximum results.
        public let maxResults: Int?
        /// Request to filter Source Servers list by next token.
        public let nextToken: String?

        @inlinable
        public init(accountID: String? = nil, filters: DescribeSourceServersRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountID = accountID
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeSourceServersRequestFilters: AWSEncodableShape {
        /// Request to filter Source Servers list by application IDs.
        public let applicationIDs: [String]?
        /// Request to filter Source Servers list by archived.
        public let isArchived: Bool?
        /// Request to filter Source Servers list by life cycle states.
        public let lifeCycleStates: [LifeCycleState]?
        /// Request to filter Source Servers list by replication type.
        public let replicationTypes: [ReplicationType]?
        /// Request to filter Source Servers list by Source Server ID.
        public let sourceServerIDs: [String]?

        @inlinable
        public init(applicationIDs: [String]? = nil, isArchived: Bool? = nil, lifeCycleStates: [LifeCycleState]? = nil, replicationTypes: [ReplicationType]? = nil, sourceServerIDs: [String]? = nil) {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.lifeCycleStates = lifeCycleStates
            self.replicationTypes = replicationTypes
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.applicationIDs?.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 200)
            try self.validate(self.lifeCycleStates, name: "lifeCycleStates", parent: name, max: 10)
            try self.validate(self.replicationTypes, name: "replicationTypes", parent: name, max: 2)
            try self.sourceServerIDs?.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIDs = "applicationIDs"
            case isArchived = "isArchived"
            case lifeCycleStates = "lifeCycleStates"
            case replicationTypes = "replicationTypes"
            case sourceServerIDs = "sourceServerIDs"
        }
    }

    public struct DescribeSourceServersResponse: AWSDecodableShape {
        /// Request to filter Source Servers list by item.
        public let items: [SourceServer]?
        /// Request to filter Source Servers next token.
        public let nextToken: String?

        @inlinable
        public init(items: [SourceServer]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeVcenterClientsRequest: AWSEncodableShape {
        /// Maximum results to be returned in DescribeVcenterClients.
        public let maxResults: Int?
        /// Next pagination token to be provided for DescribeVcenterClients.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVcenterClientsResponse: AWSDecodableShape {
        /// List of items returned by DescribeVcenterClients.
        public let items: [VcenterClient]?
        /// Next pagination token returned from DescribeVcenterClients.
        public let nextToken: String?

        @inlinable
        public init(items: [VcenterClient]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct DisassociateApplicationsRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application IDs list.
        public let applicationIDs: [String]
        /// Wave ID.
        public let waveID: String

        @inlinable
        public init(accountID: String? = nil, applicationIDs: [String], waveID: String) {
            self.accountID = accountID
            self.applicationIDs = applicationIDs
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.applicationIDs.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 50)
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, min: 1)
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationIDs = "applicationIDs"
            case waveID = "waveID"
        }
    }

    public struct DisassociateApplicationsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateSourceServersRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application ID.
        public let applicationID: String
        /// Source server IDs list.
        public let sourceServerIDs: [String]

        @inlinable
        public init(accountID: String? = nil, applicationID: String, sourceServerIDs: [String]) {
            self.accountID = accountID
            self.applicationID = applicationID
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 50)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
            case sourceServerIDs = "sourceServerIDs"
        }
    }

    public struct DisassociateSourceServersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisconnectFromServiceRequest: AWSEncodableShape {
        /// Request to disconnect Source Server from service by Account ID.
        public let accountID: String?
        /// Request to disconnect Source Server from service by Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct Disk: AWSDecodableShape {
        /// The amount of storage on the disk in bytes.
        public let bytes: Int64?
        /// The disk or device name.
        public let deviceName: String?

        @inlinable
        public init(bytes: Int64? = nil, deviceName: String? = nil) {
            self.bytes = bytes
            self.deviceName = deviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case deviceName = "deviceName"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// Error details code.
        public let code: String?
        /// Error details message.
        public let message: String?
        /// Error details resourceId.
        public let resourceId: String?
        /// Error details resourceType.
        public let resourceType: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.code = code
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ExportErrorData: AWSDecodableShape {
        /// Export errors data raw error.
        public let rawError: String?

        @inlinable
        public init(rawError: String? = nil) {
            self.rawError = rawError
        }

        private enum CodingKeys: String, CodingKey {
            case rawError = "rawError"
        }
    }

    public struct ExportTask: AWSDecodableShape {
        /// Export task creation datetime.
        public let creationDateTime: String?
        /// Export task end datetime.
        public let endDateTime: String?
        /// Export task id.
        public let exportID: String?
        /// Export task progress percentage.
        public let progressPercentage: Float?
        /// Export task s3 bucket.
        public let s3Bucket: String?
        /// Export task s3 bucket owner.
        public let s3BucketOwner: String?
        /// Export task s3 key.
        public let s3Key: String?
        /// Export task status.
        public let status: ExportStatus?
        /// Export task summary.
        public let summary: ExportTaskSummary?

        @inlinable
        public init(creationDateTime: String? = nil, endDateTime: String? = nil, exportID: String? = nil, progressPercentage: Float? = nil, s3Bucket: String? = nil, s3BucketOwner: String? = nil, s3Key: String? = nil, status: ExportStatus? = nil, summary: ExportTaskSummary? = nil) {
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.exportID = exportID
            self.progressPercentage = progressPercentage
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
            self.status = status
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case endDateTime = "endDateTime"
            case exportID = "exportID"
            case progressPercentage = "progressPercentage"
            case s3Bucket = "s3Bucket"
            case s3BucketOwner = "s3BucketOwner"
            case s3Key = "s3Key"
            case status = "status"
            case summary = "summary"
        }
    }

    public struct ExportTaskError: AWSDecodableShape {
        /// Export task error data.
        public let errorData: ExportErrorData?
        /// Export task error datetime.
        public let errorDateTime: String?

        @inlinable
        public init(errorData: ExportErrorData? = nil, errorDateTime: String? = nil) {
            self.errorData = errorData
            self.errorDateTime = errorDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorData = "errorData"
            case errorDateTime = "errorDateTime"
        }
    }

    public struct ExportTaskSummary: AWSDecodableShape {
        /// Export task summary applications count.
        public let applicationsCount: Int64?
        /// Export task summary servers count.
        public let serversCount: Int64?
        /// Export task summary waves count.
        public let wavesCount: Int64?

        @inlinable
        public init(applicationsCount: Int64? = nil, serversCount: Int64? = nil, wavesCount: Int64? = nil) {
            self.applicationsCount = applicationsCount
            self.serversCount = serversCount
            self.wavesCount = wavesCount
        }

        private enum CodingKeys: String, CodingKey {
            case applicationsCount = "applicationsCount"
            case serversCount = "serversCount"
            case wavesCount = "wavesCount"
        }
    }

    public struct FinalizeCutoverRequest: AWSEncodableShape {
        /// Request to finalize Cutover by Source Account ID.
        public let accountID: String?
        /// Request to finalize Cutover by Source Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct GetLaunchConfigurationRequest: AWSEncodableShape {
        /// Request to get Launch Configuration information by Account ID.
        public let accountID: String?
        /// Request to get Launch Configuration information by Source Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct GetReplicationConfigurationRequest: AWSEncodableShape {
        /// Request to get Replication Configuration by Account ID.
        public let accountID: String?
        /// Request to get Replication Configuration by Source Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct IdentificationHints: AWSDecodableShape {
        /// AWS Instance ID identification hint.
        public let awsInstanceID: String?
        /// FQDN address identification hint.
        public let fqdn: String?
        /// Hostname identification hint.
        public let hostname: String?
        /// vCenter VM path identification hint.
        public let vmPath: String?
        /// vmWare UUID identification hint.
        public let vmWareUuid: String?

        @inlinable
        public init(awsInstanceID: String? = nil, fqdn: String? = nil, hostname: String? = nil, vmPath: String? = nil, vmWareUuid: String? = nil) {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmPath = vmPath
            self.vmWareUuid = vmWareUuid
        }

        private enum CodingKeys: String, CodingKey {
            case awsInstanceID = "awsInstanceID"
            case fqdn = "fqdn"
            case hostname = "hostname"
            case vmPath = "vmPath"
            case vmWareUuid = "vmWareUuid"
        }
    }

    public struct ImportErrorData: AWSDecodableShape {
        /// Import error data source account ID.
        public let accountID: String?
        /// Import error data application ID.
        public let applicationID: String?
        /// Import error data ec2 LaunchTemplate ID.
        public let ec2LaunchTemplateID: String?
        /// Import error data raw error.
        public let rawError: String?
        /// Import error data row number.
        public let rowNumber: Int64?
        /// Import error data source server ID.
        public let sourceServerID: String?
        /// Import error data wave id.
        public let waveID: String?

        @inlinable
        public init(accountID: String? = nil, applicationID: String? = nil, ec2LaunchTemplateID: String? = nil, rawError: String? = nil, rowNumber: Int64? = nil, sourceServerID: String? = nil, waveID: String? = nil) {
            self.accountID = accountID
            self.applicationID = applicationID
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.rawError = rawError
            self.rowNumber = rowNumber
            self.sourceServerID = sourceServerID
            self.waveID = waveID
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
            case ec2LaunchTemplateID = "ec2LaunchTemplateID"
            case rawError = "rawError"
            case rowNumber = "rowNumber"
            case sourceServerID = "sourceServerID"
            case waveID = "waveID"
        }
    }

    public struct ImportTask: AWSDecodableShape {
        /// Import task creation datetime.
        public let creationDateTime: String?
        /// Import task end datetime.
        public let endDateTime: String?
        /// Import task id.
        public let importID: String?
        /// Import task progress percentage.
        public let progressPercentage: Float?
        /// Import task s3 bucket source.
        public let s3BucketSource: S3BucketSource?
        /// Import task status.
        public let status: ImportStatus?
        /// Import task summary.
        public let summary: ImportTaskSummary?

        @inlinable
        public init(creationDateTime: String? = nil, endDateTime: String? = nil, importID: String? = nil, progressPercentage: Float? = nil, s3BucketSource: S3BucketSource? = nil, status: ImportStatus? = nil, summary: ImportTaskSummary? = nil) {
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.importID = importID
            self.progressPercentage = progressPercentage
            self.s3BucketSource = s3BucketSource
            self.status = status
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case endDateTime = "endDateTime"
            case importID = "importID"
            case progressPercentage = "progressPercentage"
            case s3BucketSource = "s3BucketSource"
            case status = "status"
            case summary = "summary"
        }
    }

    public struct ImportTaskError: AWSDecodableShape {
        /// Import task error data.
        public let errorData: ImportErrorData?
        /// Import task error datetime.
        public let errorDateTime: String?
        /// Import task error type.
        public let errorType: ImportErrorType?

        @inlinable
        public init(errorData: ImportErrorData? = nil, errorDateTime: String? = nil, errorType: ImportErrorType? = nil) {
            self.errorData = errorData
            self.errorDateTime = errorDateTime
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorData = "errorData"
            case errorDateTime = "errorDateTime"
            case errorType = "errorType"
        }
    }

    public struct ImportTaskSummary: AWSDecodableShape {
        /// Import task summary applications.
        public let applications: ImportTaskSummaryApplications?
        /// Import task summary servers.
        public let servers: ImportTaskSummaryServers?
        /// Import task summary waves.
        public let waves: ImportTaskSummaryWaves?

        @inlinable
        public init(applications: ImportTaskSummaryApplications? = nil, servers: ImportTaskSummaryServers? = nil, waves: ImportTaskSummaryWaves? = nil) {
            self.applications = applications
            self.servers = servers
            self.waves = waves
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "applications"
            case servers = "servers"
            case waves = "waves"
        }
    }

    public struct ImportTaskSummaryApplications: AWSDecodableShape {
        /// Import task summary applications created count.
        public let createdCount: Int64?
        /// Import task summary applications modified count.
        public let modifiedCount: Int64?

        @inlinable
        public init(createdCount: Int64? = nil, modifiedCount: Int64? = nil) {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }

        private enum CodingKeys: String, CodingKey {
            case createdCount = "createdCount"
            case modifiedCount = "modifiedCount"
        }
    }

    public struct ImportTaskSummaryServers: AWSDecodableShape {
        /// Import task summary servers created count.
        public let createdCount: Int64?
        /// Import task summary servers modified count.
        public let modifiedCount: Int64?

        @inlinable
        public init(createdCount: Int64? = nil, modifiedCount: Int64? = nil) {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }

        private enum CodingKeys: String, CodingKey {
            case createdCount = "createdCount"
            case modifiedCount = "modifiedCount"
        }
    }

    public struct ImportTaskSummaryWaves: AWSDecodableShape {
        /// Import task summery waves created count.
        public let createdCount: Int64?
        /// Import task summery waves modified count.
        public let modifiedCount: Int64?

        @inlinable
        public init(createdCount: Int64? = nil, modifiedCount: Int64? = nil) {
            self.createdCount = createdCount
            self.modifiedCount = modifiedCount
        }

        private enum CodingKeys: String, CodingKey {
            case createdCount = "createdCount"
            case modifiedCount = "modifiedCount"
        }
    }

    public struct InitializeServiceRequest: AWSEncodableShape {
        public init() {}
    }

    public struct InitializeServiceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The server encountered an unexpected condition that prevented it from fulfilling the request. The request will be retried again after x seconds.
        public let retryAfterSeconds: Int64?

        @inlinable
        public init(message: String, retryAfterSeconds: Int64? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int64.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Job: AWSDecodableShape {
        /// the ARN of the specific Job.
        public let arn: String?
        /// Job creation time.
        public let creationDateTime: String?
        /// Job end time.
        public let endDateTime: String?
        /// Job initiated by field.
        public let initiatedBy: InitiatedBy?
        /// Job ID.
        public let jobID: String
        /// Servers participating in a specific Job.
        public let participatingServers: [ParticipatingServer]?
        /// Job status.
        public let status: JobStatus?
        /// Tags associated with specific Job.
        public let tags: [String: String]?
        /// Job type.
        public let type: JobType?

        @inlinable
        public init(arn: String? = nil, creationDateTime: String? = nil, endDateTime: String? = nil, initiatedBy: InitiatedBy? = nil, jobID: String, participatingServers: [ParticipatingServer]? = nil, status: JobStatus? = nil, tags: [String: String]? = nil, type: JobType? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case endDateTime = "endDateTime"
            case initiatedBy = "initiatedBy"
            case jobID = "jobID"
            case participatingServers = "participatingServers"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct JobLog: AWSDecodableShape {
        /// Job log event.
        public let event: JobLogEvent?
        /// Job event data
        public let eventData: JobLogEventData?
        /// Job log event date and time.
        public let logDateTime: String?

        @inlinable
        public init(event: JobLogEvent? = nil, eventData: JobLogEventData? = nil, logDateTime: String? = nil) {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case eventData = "eventData"
            case logDateTime = "logDateTime"
        }
    }

    public struct JobLogEventData: AWSDecodableShape {
        /// Job Event conversion Server ID.
        public let conversionServerID: String?
        /// Job error.
        public let rawError: String?
        /// Job Event Source Server ID.
        public let sourceServerID: String?
        /// Job Event Target instance ID.
        public let targetInstanceID: String?

        @inlinable
        public init(conversionServerID: String? = nil, rawError: String? = nil, sourceServerID: String? = nil, targetInstanceID: String? = nil) {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }

        private enum CodingKeys: String, CodingKey {
            case conversionServerID = "conversionServerID"
            case rawError = "rawError"
            case sourceServerID = "sourceServerID"
            case targetInstanceID = "targetInstanceID"
        }
    }

    public struct JobPostLaunchActionsLaunchStatus: AWSDecodableShape {
        /// AWS Systems Manager Document's execution ID of the of the Job Post Launch Actions.
        public let executionID: String?
        /// AWS Systems Manager Document's execution status.
        public let executionStatus: PostLaunchActionExecutionStatus?
        /// AWS Systems Manager Document's failure reason.
        public let failureReason: String?
        /// AWS Systems Manager's Document of the of the Job Post Launch Actions.
        public let ssmDocument: SsmDocument?
        /// AWS Systems Manager Document type.
        public let ssmDocumentType: SsmDocumentType?

        @inlinable
        public init(executionID: String? = nil, executionStatus: PostLaunchActionExecutionStatus? = nil, failureReason: String? = nil, ssmDocument: SsmDocument? = nil, ssmDocumentType: SsmDocumentType? = nil) {
            self.executionID = executionID
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.ssmDocument = ssmDocument
            self.ssmDocumentType = ssmDocumentType
        }

        private enum CodingKeys: String, CodingKey {
            case executionID = "executionID"
            case executionStatus = "executionStatus"
            case failureReason = "failureReason"
            case ssmDocument = "ssmDocument"
            case ssmDocumentType = "ssmDocumentType"
        }
    }

    public struct LaunchConfiguration: AWSDecodableShape {
        /// Launch configuration boot mode.
        public let bootMode: BootMode?
        /// Copy Private IP during Launch Configuration.
        public let copyPrivateIp: Bool?
        /// Copy Tags during Launch Configuration.
        public let copyTags: Bool?
        /// Launch configuration EC2 Launch template ID.
        public let ec2LaunchTemplateID: String?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Launch disposition for launch configuration.
        public let launchDisposition: LaunchDisposition?
        /// Launch configuration OS licensing.
        public let licensing: Licensing?
        /// Map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Launch configuration name.
        public let name: String?
        public let postLaunchActions: PostLaunchActions?
        /// Launch configuration Source Server ID.
        public let sourceServerID: String?
        /// Launch configuration Target instance type right sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        @inlinable
        public init(bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, ec2LaunchTemplateID: String? = nil, enableMapAutoTagging: Bool? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, name: String? = nil, postLaunchActions: PostLaunchActions? = nil, sourceServerID: String? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.name = name
            self.postLaunchActions = postLaunchActions
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case bootMode = "bootMode"
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case ec2LaunchTemplateID = "ec2LaunchTemplateID"
            case enableMapAutoTagging = "enableMapAutoTagging"
            case launchDisposition = "launchDisposition"
            case licensing = "licensing"
            case mapAutoTaggingMpeID = "mapAutoTaggingMpeID"
            case name = "name"
            case postLaunchActions = "postLaunchActions"
            case sourceServerID = "sourceServerID"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct LaunchConfigurationTemplate: AWSDecodableShape {
        /// ARN of the Launch Configuration Template.
        public let arn: String?
        /// Associate public Ip address.
        public let associatePublicIpAddress: Bool?
        /// Launch configuration template boot mode.
        public let bootMode: BootMode?
        /// Copy private Ip.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// EC2 launch template ID.
        public let ec2LaunchTemplateID: String?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Large volume config.
        public let largeVolumeConf: LaunchTemplateDiskConf?
        /// ID of the Launch Configuration Template.
        public let launchConfigurationTemplateID: String
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        public let licensing: Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Post Launch Actions of the Launch Configuration Template.
        public let postLaunchActions: PostLaunchActions?
        /// Small volume config.
        public let smallVolumeConf: LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public let smallVolumeMaxSize: Int64?
        /// Tags of the Launch Configuration Template.
        public let tags: [String: String]?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        @inlinable
        public init(arn: String? = nil, associatePublicIpAddress: Bool? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, ec2LaunchTemplateID: String? = nil, enableMapAutoTagging: Bool? = nil, largeVolumeConf: LaunchTemplateDiskConf? = nil, launchConfigurationTemplateID: String, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, postLaunchActions: PostLaunchActions? = nil, smallVolumeConf: LaunchTemplateDiskConf? = nil, smallVolumeMaxSize: Int64? = nil, tags: [String: String]? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.arn = arn
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associatePublicIpAddress = "associatePublicIpAddress"
            case bootMode = "bootMode"
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case ec2LaunchTemplateID = "ec2LaunchTemplateID"
            case enableMapAutoTagging = "enableMapAutoTagging"
            case largeVolumeConf = "largeVolumeConf"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
            case launchDisposition = "launchDisposition"
            case licensing = "licensing"
            case mapAutoTaggingMpeID = "mapAutoTaggingMpeID"
            case postLaunchActions = "postLaunchActions"
            case smallVolumeConf = "smallVolumeConf"
            case smallVolumeMaxSize = "smallVolumeMaxSize"
            case tags = "tags"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct LaunchTemplateDiskConf: AWSEncodableShape & AWSDecodableShape {
        /// Launch template disk iops configuration.
        public let iops: Int64?
        /// Launch template disk throughput configuration.
        public let throughput: Int64?
        /// Launch template disk volume type configuration.
        public let volumeType: VolumeType?

        @inlinable
        public init(iops: Int64? = nil, throughput: Int64? = nil, volumeType: VolumeType? = nil) {
            self.iops = iops
            self.throughput = throughput
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 64000)
            try self.validate(self.iops, name: "iops", parent: name, min: 100)
            try self.validate(self.throughput, name: "throughput", parent: name, max: 1000)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 125)
        }

        private enum CodingKeys: String, CodingKey {
            case iops = "iops"
            case throughput = "throughput"
            case volumeType = "volumeType"
        }
    }

    public struct LaunchedInstance: AWSDecodableShape {
        /// Launched instance EC2 ID.
        public let ec2InstanceID: String?
        /// Launched instance first boot.
        public let firstBoot: FirstBoot?
        /// Launched instance Job ID.
        public let jobID: String?

        @inlinable
        public init(ec2InstanceID: String? = nil, firstBoot: FirstBoot? = nil, jobID: String? = nil) {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceID = "ec2InstanceID"
            case firstBoot = "firstBoot"
            case jobID = "jobID"
        }
    }

    public struct Licensing: AWSEncodableShape & AWSDecodableShape {
        /// Configure BYOL OS licensing.
        public let osByol: Bool?

        @inlinable
        public init(osByol: Bool? = nil) {
            self.osByol = osByol
        }

        private enum CodingKeys: String, CodingKey {
            case osByol = "osByol"
        }
    }

    public struct LifeCycle: AWSDecodableShape {
        /// Lifecycle added to service data and time.
        public let addedToServiceDateTime: String?
        /// Lifecycle elapsed time and duration.
        public let elapsedReplicationDuration: String?
        /// Lifecycle replication initiation date and time.
        public let firstByteDateTime: String?
        /// Lifecycle last Cutover.
        public let lastCutover: LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public let lastSeenByServiceDateTime: String?
        /// Lifecycle last Test.
        public let lastTest: LifeCycleLastTest?
        /// Lifecycle state.
        public let state: LifeCycleState?

        @inlinable
        public init(addedToServiceDateTime: String? = nil, elapsedReplicationDuration: String? = nil, firstByteDateTime: String? = nil, lastCutover: LifeCycleLastCutover? = nil, lastSeenByServiceDateTime: String? = nil, lastTest: LifeCycleLastTest? = nil, state: LifeCycleState? = nil) {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case addedToServiceDateTime = "addedToServiceDateTime"
            case elapsedReplicationDuration = "elapsedReplicationDuration"
            case firstByteDateTime = "firstByteDateTime"
            case lastCutover = "lastCutover"
            case lastSeenByServiceDateTime = "lastSeenByServiceDateTime"
            case lastTest = "lastTest"
            case state = "state"
        }
    }

    public struct LifeCycleLastCutover: AWSDecodableShape {
        /// Lifecycle Cutover finalized date and time.
        public let finalized: LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public let initiated: LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public let reverted: LifeCycleLastCutoverReverted?

        @inlinable
        public init(finalized: LifeCycleLastCutoverFinalized? = nil, initiated: LifeCycleLastCutoverInitiated? = nil, reverted: LifeCycleLastCutoverReverted? = nil) {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }

        private enum CodingKeys: String, CodingKey {
            case finalized = "finalized"
            case initiated = "initiated"
            case reverted = "reverted"
        }
    }

    public struct LifeCycleLastCutoverFinalized: AWSDecodableShape {
        /// Lifecycle Cutover finalized date and time.
        public let apiCallDateTime: String?

        @inlinable
        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
        }
    }

    public struct LifeCycleLastCutoverInitiated: AWSDecodableShape {
        public let apiCallDateTime: String?
        /// Lifecycle last Cutover initiated by Job ID.
        public let jobID: String?

        @inlinable
        public init(apiCallDateTime: String? = nil, jobID: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
            case jobID = "jobID"
        }
    }

    public struct LifeCycleLastCutoverReverted: AWSDecodableShape {
        /// Lifecycle last Cutover reverted API call date time.
        public let apiCallDateTime: String?

        @inlinable
        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
        }
    }

    public struct LifeCycleLastTest: AWSDecodableShape {
        /// Lifecycle last Test finalized.
        public let finalized: LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public let initiated: LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public let reverted: LifeCycleLastTestReverted?

        @inlinable
        public init(finalized: LifeCycleLastTestFinalized? = nil, initiated: LifeCycleLastTestInitiated? = nil, reverted: LifeCycleLastTestReverted? = nil) {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }

        private enum CodingKeys: String, CodingKey {
            case finalized = "finalized"
            case initiated = "initiated"
            case reverted = "reverted"
        }
    }

    public struct LifeCycleLastTestFinalized: AWSDecodableShape {
        /// Lifecycle Test failed API call date and time.
        public let apiCallDateTime: String?

        @inlinable
        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
        }
    }

    public struct LifeCycleLastTestInitiated: AWSDecodableShape {
        /// Lifecycle last Test initiated API call date and time.
        public let apiCallDateTime: String?
        /// Lifecycle last Test initiated Job ID.
        public let jobID: String?

        @inlinable
        public init(apiCallDateTime: String? = nil, jobID: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
            case jobID = "jobID"
        }
    }

    public struct LifeCycleLastTestReverted: AWSDecodableShape {
        /// Lifecycle last Test reverted API call date and time.
        public let apiCallDateTime: String?

        @inlinable
        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime = "apiCallDateTime"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// Applications list Account ID.
        public let accountID: String?
        /// Applications list filters.
        public let filters: ListApplicationsRequestFilters?
        /// Maximum results to return when listing applications.
        public let maxResults: Int?
        /// Request next token.
        public let nextToken: String?

        @inlinable
        public init(accountID: String? = nil, filters: ListApplicationsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountID = accountID
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListApplicationsRequestFilters: AWSEncodableShape {
        /// Filter applications list by application ID.
        public let applicationIDs: [String]?
        /// Filter applications list by archival status.
        public let isArchived: Bool?
        /// Filter applications list by wave ID.
        public let waveIDs: [String]?

        @inlinable
        public init(applicationIDs: [String]? = nil, isArchived: Bool? = nil, waveIDs: [String]? = nil) {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }

        public func validate(name: String) throws {
            try self.applicationIDs?.forEach {
                try validate($0, name: "applicationIDs[]", parent: name, max: 21)
                try validate($0, name: "applicationIDs[]", parent: name, min: 21)
                try validate($0, name: "applicationIDs[]", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.applicationIDs, name: "applicationIDs", parent: name, max: 200)
            try self.waveIDs?.forEach {
                try validate($0, name: "waveIDs[]", parent: name, max: 22)
                try validate($0, name: "waveIDs[]", parent: name, min: 22)
                try validate($0, name: "waveIDs[]", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.waveIDs, name: "waveIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIDs = "applicationIDs"
            case isArchived = "isArchived"
            case waveIDs = "waveIDs"
        }
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// Applications list.
        public let items: [Application]?
        /// Response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [Application]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectorsRequest: AWSEncodableShape {
        /// List Connectors Request filters.
        public let filters: ListConnectorsRequestFilters?
        /// List Connectors Request max results.
        public let maxResults: Int?
        /// List Connectors Request next token.
        public let nextToken: String?

        @inlinable
        public init(filters: ListConnectorsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectorsRequestFilters: AWSEncodableShape {
        /// List Connectors Request Filters connector IDs.
        public let connectorIDs: [String]?

        @inlinable
        public init(connectorIDs: [String]? = nil) {
            self.connectorIDs = connectorIDs
        }

        public func validate(name: String) throws {
            try self.connectorIDs?.forEach {
                try validate($0, name: "connectorIDs[]", parent: name, max: 27)
                try validate($0, name: "connectorIDs[]", parent: name, min: 27)
                try validate($0, name: "connectorIDs[]", parent: name, pattern: "^connector-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.connectorIDs, name: "connectorIDs", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case connectorIDs = "connectorIDs"
        }
    }

    public struct ListConnectorsResponse: AWSDecodableShape {
        /// List connectors response items.
        public let items: [Connector]?
        /// List connectors response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [Connector]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListExportErrorsRequest: AWSEncodableShape {
        /// List export errors request export id.
        public let exportID: String
        /// List export errors request max results.
        public let maxResults: Int?
        /// List export errors request next token.
        public let nextToken: String?

        @inlinable
        public init(exportID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.exportID = exportID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.exportID, name: "exportID", parent: name, max: 24)
            try self.validate(self.exportID, name: "exportID", parent: name, min: 24)
            try self.validate(self.exportID, name: "exportID", parent: name, pattern: "^export-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case exportID = "exportID"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListExportErrorsResponse: AWSDecodableShape {
        /// List export errors response items.
        public let items: [ExportTaskError]?
        /// List export errors response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [ExportTaskError]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListExportsRequest: AWSEncodableShape {
        public let filters: ListExportsRequestFilters?
        /// List export request max results.
        public let maxResults: Int?
        /// List export request next token.
        public let nextToken: String?

        @inlinable
        public init(filters: ListExportsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListExportsRequestFilters: AWSEncodableShape {
        /// List exports request filters export ids.
        public let exportIDs: [String]?

        @inlinable
        public init(exportIDs: [String]? = nil) {
            self.exportIDs = exportIDs
        }

        public func validate(name: String) throws {
            try self.exportIDs?.forEach {
                try validate($0, name: "exportIDs[]", parent: name, max: 24)
                try validate($0, name: "exportIDs[]", parent: name, min: 24)
                try validate($0, name: "exportIDs[]", parent: name, pattern: "^export-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.exportIDs, name: "exportIDs", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case exportIDs = "exportIDs"
        }
    }

    public struct ListExportsResponse: AWSDecodableShape {
        /// List export response items.
        public let items: [ExportTask]?
        /// List export response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [ExportTask]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportErrorsRequest: AWSEncodableShape {
        /// List import errors request import id.
        public let importID: String
        /// List import errors request max results.
        public let maxResults: Int?
        /// List import errors request next token.
        public let nextToken: String?

        @inlinable
        public init(importID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.importID = importID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.importID, name: "importID", parent: name, max: 24)
            try self.validate(self.importID, name: "importID", parent: name, min: 24)
            try self.validate(self.importID, name: "importID", parent: name, pattern: "^import-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case importID = "importID"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportErrorsResponse: AWSDecodableShape {
        /// List imports errors response items.
        public let items: [ImportTaskError]?
        /// List imports errors response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [ImportTaskError]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportsRequest: AWSEncodableShape {
        /// List imports request filters.
        public let filters: ListImportsRequestFilters?
        /// List imports request max results.
        public let maxResults: Int?
        /// List imports request next token.
        public let nextToken: String?

        @inlinable
        public init(filters: ListImportsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportsRequestFilters: AWSEncodableShape {
        /// List imports request filters import IDs.
        public let importIDs: [String]?

        @inlinable
        public init(importIDs: [String]? = nil) {
            self.importIDs = importIDs
        }

        public func validate(name: String) throws {
            try self.importIDs?.forEach {
                try validate($0, name: "importIDs[]", parent: name, max: 24)
                try validate($0, name: "importIDs[]", parent: name, min: 24)
                try validate($0, name: "importIDs[]", parent: name, pattern: "^import-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.importIDs, name: "importIDs", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case importIDs = "importIDs"
        }
    }

    public struct ListImportsResponse: AWSDecodableShape {
        /// List import response items.
        public let items: [ImportTask]?
        /// List import response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [ImportTask]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedAccountsRequest: AWSEncodableShape {
        /// List managed accounts request max results.
        public let maxResults: Int?
        /// List managed accounts request next token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedAccountsResponse: AWSDecodableShape {
        /// List managed accounts response items.
        public let items: [ManagedAccount]
        /// List managed accounts response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [ManagedAccount], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSourceServerActionsRequest: AWSEncodableShape {
        /// Account ID to return when listing source server post migration custom actions.
        public let accountID: String?
        /// Filters to apply when listing source server post migration custom actions.
        public let filters: SourceServerActionsRequestFilters?
        /// Maximum amount of items to return when listing source server post migration custom actions.
        public let maxResults: Int?
        /// Next token to use when listing source server post migration custom actions.
        public let nextToken: String?
        /// Source server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, filters: SourceServerActionsRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct ListSourceServerActionsResponse: AWSDecodableShape {
        /// List of source server post migration custom actions.
        public let items: [SourceServerActionDocument]?
        /// Next token returned when listing source server post migration custom actions.
        public let nextToken: String?

        @inlinable
        public init(items: [SourceServerActionDocument]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// List tags for resource request by ARN.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// List tags for resource response.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTemplateActionsRequest: AWSEncodableShape {
        /// Filters to apply when listing template post migration custom actions.
        public let filters: TemplateActionsRequestFilters?
        /// Launch configuration template ID.
        public let launchConfigurationTemplateID: String
        /// Maximum amount of items to return when listing template post migration custom actions.
        public let maxResults: Int?
        /// Next token to use when listing template post migration custom actions.
        public let nextToken: String?

        @inlinable
        public init(filters: TemplateActionsRequestFilters? = nil, launchConfigurationTemplateID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListTemplateActionsResponse: AWSDecodableShape {
        /// List of template post migration custom actions.
        public let items: [TemplateActionDocument]?
        /// Next token returned when listing template post migration custom actions.
        public let nextToken: String?

        @inlinable
        public init(items: [TemplateActionDocument]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListWavesRequest: AWSEncodableShape {
        /// Request account ID.
        public let accountID: String?
        /// Waves list filters.
        public let filters: ListWavesRequestFilters?
        /// Maximum results to return when listing waves.
        public let maxResults: Int?
        /// Request next token.
        public let nextToken: String?

        @inlinable
        public init(accountID: String? = nil, filters: ListWavesRequestFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountID = accountID
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWavesRequestFilters: AWSEncodableShape {
        /// Filter waves list by archival status.
        public let isArchived: Bool?
        /// Filter waves list by wave ID.
        public let waveIDs: [String]?

        @inlinable
        public init(isArchived: Bool? = nil, waveIDs: [String]? = nil) {
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }

        public func validate(name: String) throws {
            try self.waveIDs?.forEach {
                try validate($0, name: "waveIDs[]", parent: name, max: 22)
                try validate($0, name: "waveIDs[]", parent: name, min: 22)
                try validate($0, name: "waveIDs[]", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.waveIDs, name: "waveIDs", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case isArchived = "isArchived"
            case waveIDs = "waveIDs"
        }
    }

    public struct ListWavesResponse: AWSDecodableShape {
        /// Waves list.
        public let items: [Wave]?
        /// Response next token.
        public let nextToken: String?

        @inlinable
        public init(items: [Wave]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ManagedAccount: AWSDecodableShape {
        /// Managed account, account ID.
        public let accountId: String?

        @inlinable
        public init(accountId: String? = nil) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct MarkAsArchivedRequest: AWSEncodableShape {
        /// Mark as archived by Account ID.
        public let accountID: String?
        /// Mark as archived by Source Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// Network interface IPs.
        public let ips: [String]?
        /// Network interface primary IP.
        public let isPrimary: Bool?
        /// Network interface Mac address.
        public let macAddress: String?

        @inlinable
        public init(ips: [String]? = nil, isPrimary: Bool? = nil, macAddress: String? = nil) {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ips = "ips"
            case isPrimary = "isPrimary"
            case macAddress = "macAddress"
        }
    }

    public struct OS: AWSDecodableShape {
        /// OS full string.
        public let fullString: String?

        @inlinable
        public init(fullString: String? = nil) {
            self.fullString = fullString
        }

        private enum CodingKeys: String, CodingKey {
            case fullString = "fullString"
        }
    }

    public struct ParticipatingServer: AWSDecodableShape {
        /// Participating server's launched ec2 instance ID.
        public let launchedEc2InstanceID: String?
        /// Participating server launch status.
        public let launchStatus: LaunchStatus?
        /// Participating server's Post Launch Actions Status.
        public let postLaunchActionsStatus: PostLaunchActionsStatus?
        /// Participating server Source Server ID.
        public let sourceServerID: String

        @inlinable
        public init(launchedEc2InstanceID: String? = nil, launchStatus: LaunchStatus? = nil, postLaunchActionsStatus: PostLaunchActionsStatus? = nil, sourceServerID: String) {
            self.launchedEc2InstanceID = launchedEc2InstanceID
            self.launchStatus = launchStatus
            self.postLaunchActionsStatus = postLaunchActionsStatus
            self.sourceServerID = sourceServerID
        }

        private enum CodingKeys: String, CodingKey {
            case launchedEc2InstanceID = "launchedEc2InstanceID"
            case launchStatus = "launchStatus"
            case postLaunchActionsStatus = "postLaunchActionsStatus"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct PauseReplicationRequest: AWSEncodableShape {
        /// Pause Replication Request account ID.
        public let accountID: String?
        /// Pause Replication Request source server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct PostLaunchActions: AWSEncodableShape & AWSDecodableShape {
        /// AWS Systems Manager Command's CloudWatch log group name.
        public let cloudWatchLogGroupName: String?
        /// Deployment type in which AWS Systems Manager Documents will be executed.
        public let deployment: PostLaunchActionsDeploymentType?
        /// AWS Systems Manager Command's logs S3 log bucket.
        public let s3LogBucket: String?
        /// AWS Systems Manager Command's logs S3 output key prefix.
        public let s3OutputKeyPrefix: String?
        /// AWS Systems Manager Documents.
        public let ssmDocuments: [SsmDocument]?

        @inlinable
        public init(cloudWatchLogGroupName: String? = nil, deployment: PostLaunchActionsDeploymentType? = nil, s3LogBucket: String? = nil, s3OutputKeyPrefix: String? = nil, ssmDocuments: [SsmDocument]? = nil) {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.deployment = deployment
            self.s3LogBucket = s3LogBucket
            self.s3OutputKeyPrefix = s3OutputKeyPrefix
            self.ssmDocuments = ssmDocuments
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, max: 512)
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, min: 1)
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, pattern: "^[\\.\\-_/#A-Za-z0-9]+$")
            try self.validate(self.s3LogBucket, name: "s3LogBucket", parent: name, max: 63)
            try self.validate(self.s3LogBucket, name: "s3LogBucket", parent: name, min: 3)
            try self.validate(self.s3OutputKeyPrefix, name: "s3OutputKeyPrefix", parent: name, max: 256)
            try self.ssmDocuments?.forEach {
                try $0.validate(name: "\(name).ssmDocuments[]")
            }
            try self.validate(self.ssmDocuments, name: "ssmDocuments", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupName = "cloudWatchLogGroupName"
            case deployment = "deployment"
            case s3LogBucket = "s3LogBucket"
            case s3OutputKeyPrefix = "s3OutputKeyPrefix"
            case ssmDocuments = "ssmDocuments"
        }
    }

    public struct PostLaunchActionsStatus: AWSDecodableShape {
        /// List of Post Launch Action status.
        public let postLaunchActionsLaunchStatusList: [JobPostLaunchActionsLaunchStatus]?
        /// Time where the AWS Systems Manager was detected as running on the Test or Cutover instance.
        public let ssmAgentDiscoveryDatetime: String?

        @inlinable
        public init(postLaunchActionsLaunchStatusList: [JobPostLaunchActionsLaunchStatus]? = nil, ssmAgentDiscoveryDatetime: String? = nil) {
            self.postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }

        private enum CodingKeys: String, CodingKey {
            case postLaunchActionsLaunchStatusList = "postLaunchActionsLaunchStatusList"
            case ssmAgentDiscoveryDatetime = "ssmAgentDiscoveryDatetime"
        }
    }

    public struct PutSourceServerActionRequest: AWSEncodableShape {
        /// Source server post migration custom account ID.
        public let accountID: String?
        /// Source server post migration custom action ID.
        public let actionID: String
        /// Source server post migration custom action name.
        public let actionName: String
        /// Source server post migration custom action active status.
        public let active: Bool?
        /// Source server post migration custom action category.
        public let category: ActionCategory?
        /// Source server post migration custom action description.
        public let description: String?
        /// Source server post migration custom action document identifier.
        public let documentIdentifier: String
        /// Source server post migration custom action document version.
        public let documentVersion: String?
        /// Source server post migration custom action external parameters.
        public let externalParameters: [String: SsmExternalParameter]?
        /// Source server post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Source server post migration custom action order.
        public let order: Int
        /// Source server post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Source server ID.
        public let sourceServerID: String
        /// Source server post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        @inlinable
        public init(accountID: String? = nil, actionID: String, actionName: String, active: Bool? = nil, category: ActionCategory? = nil, description: String? = nil, documentIdentifier: String, documentVersion: String? = nil, externalParameters: [String: SsmExternalParameter]? = nil, mustSucceedForCutover: Bool? = nil, order: Int, parameters: [String: [SsmParameterStoreParameter]]? = nil, sourceServerID: String, timeoutSeconds: Int? = nil) {
            self.accountID = accountID
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.sourceServerID = sourceServerID
            self.timeoutSeconds = timeoutSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.actionName, name: "actionName", parent: name, max: 256)
            try self.validate(self.actionName, name: "actionName", parent: name, min: 1)
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9a-zA-Z ():/.,'-_#*;\n]*$")
            try self.validate(self.documentIdentifier, name: "documentIdentifier", parent: name, max: 256)
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, pattern: "^(\\$DEFAULT|\\$LATEST|[0-9]+)$")
            try self.externalParameters?.forEach {
                try validate($0.key, name: "externalParameters.key", parent: name, max: 1011)
                try validate($0.key, name: "externalParameters.key", parent: name, min: 1)
                try validate($0.key, name: "externalParameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try $0.value.validate(name: "\(name).externalParameters[\"\($0.key)\"]")
            }
            try self.validate(self.externalParameters, name: "externalParameters", parent: name, max: 20)
            try self.validate(self.order, name: "order", parent: name, max: 10000)
            try self.validate(self.order, name: "order", parent: name, min: 1001)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            try self.validate(self.timeoutSeconds, name: "timeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case actionID = "actionID"
            case actionName = "actionName"
            case active = "active"
            case category = "category"
            case description = "description"
            case documentIdentifier = "documentIdentifier"
            case documentVersion = "documentVersion"
            case externalParameters = "externalParameters"
            case mustSucceedForCutover = "mustSucceedForCutover"
            case order = "order"
            case parameters = "parameters"
            case sourceServerID = "sourceServerID"
            case timeoutSeconds = "timeoutSeconds"
        }
    }

    public struct PutTemplateActionRequest: AWSEncodableShape {
        /// Template post migration custom action ID.
        public let actionID: String
        /// Template post migration custom action name.
        public let actionName: String
        /// Template post migration custom action active status.
        public let active: Bool?
        /// Template post migration custom action category.
        public let category: ActionCategory?
        /// Template post migration custom action description.
        public let description: String?
        /// Template post migration custom action document identifier.
        public let documentIdentifier: String
        /// Template post migration custom action document version.
        public let documentVersion: String?
        /// Template post migration custom action external parameters.
        public let externalParameters: [String: SsmExternalParameter]?
        /// Launch configuration template ID.
        public let launchConfigurationTemplateID: String
        /// Template post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Operating system eligible for this template post migration custom action.
        public let operatingSystem: String?
        /// Template post migration custom action order.
        public let order: Int
        /// Template post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        @inlinable
        public init(actionID: String, actionName: String, active: Bool? = nil, category: ActionCategory? = nil, description: String? = nil, documentIdentifier: String, documentVersion: String? = nil, externalParameters: [String: SsmExternalParameter]? = nil, launchConfigurationTemplateID: String, mustSucceedForCutover: Bool? = nil, operatingSystem: String? = nil, order: Int, parameters: [String: [SsmParameterStoreParameter]]? = nil, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.actionName, name: "actionName", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9a-zA-Z ():/.,'-_#*;\n]*$")
            try self.validate(self.documentIdentifier, name: "documentIdentifier", parent: name, max: 256)
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, pattern: "^(\\$DEFAULT|\\$LATEST|[0-9]+)$")
            try self.externalParameters?.forEach {
                try validate($0.key, name: "externalParameters.key", parent: name, max: 1011)
                try validate($0.key, name: "externalParameters.key", parent: name, min: 1)
                try validate($0.key, name: "externalParameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try $0.value.validate(name: "\(name).externalParameters[\"\($0.key)\"]")
            }
            try self.validate(self.externalParameters, name: "externalParameters", parent: name, max: 20)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            try self.validate(self.operatingSystem, name: "operatingSystem", parent: name, pattern: "^(linux|windows)$")
            try self.validate(self.order, name: "order", parent: name, max: 10000)
            try self.validate(self.order, name: "order", parent: name, min: 1001)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.timeoutSeconds, name: "timeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionID = "actionID"
            case actionName = "actionName"
            case active = "active"
            case category = "category"
            case description = "description"
            case documentIdentifier = "documentIdentifier"
            case documentVersion = "documentVersion"
            case externalParameters = "externalParameters"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
            case mustSucceedForCutover = "mustSucceedForCutover"
            case operatingSystem = "operatingSystem"
            case order = "order"
            case parameters = "parameters"
            case timeoutSeconds = "timeoutSeconds"
        }
    }

    public struct RemoveSourceServerActionRequest: AWSEncodableShape {
        /// Source server post migration account ID.
        public let accountID: String?
        /// Source server post migration custom action ID to remove.
        public let actionID: String
        /// Source server ID of the post migration custom action to remove.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, actionID: String, sourceServerID: String) {
            self.accountID = accountID
            self.actionID = actionID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case actionID = "actionID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct RemoveSourceServerActionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RemoveTemplateActionRequest: AWSEncodableShape {
        /// Template post migration custom action ID to remove.
        public let actionID: String
        /// Launch configuration template ID of the post migration custom action to remove.
        public let launchConfigurationTemplateID: String

        @inlinable
        public init(actionID: String, launchConfigurationTemplateID: String) {
            self.actionID = actionID
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.actionID, name: "actionID", parent: name, max: 64)
            try self.validate(self.actionID, name: "actionID", parent: name, min: 1)
            try self.validate(self.actionID, name: "actionID", parent: name, pattern: "[0-9a-zA-Z]$")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionID = "actionID"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
        }
    }

    public struct RemoveTemplateActionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReplicationConfiguration: AWSDecodableShape {
        /// Replication Configuration associate default Application Migration Service Security Group.
        public let associateDefaultSecurityGroup: Bool?
        /// Replication Configuration set bandwidth throttling.
        public let bandwidthThrottling: Int64?
        /// Replication Configuration create Public IP.
        public let createPublicIP: Bool?
        /// Replication Configuration data plane routing.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration use default large Staging Disks.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration EBS encryption.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Replication Configuration EBS encryption key ARN.
        public let ebsEncryptionKeyArn: String?
        /// Replication Configuration name.
        public let name: String?
        /// Replication Configuration replicated disks.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// Replication Configuration Replication Server instance type.
        public let replicationServerInstanceType: String?
        /// Replication Configuration Replication Server Security Group IDs.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Replication Configuration Source Server ID.
        public let sourceServerID: String?
        /// Replication Configuration Staging Area subnet ID.
        public let stagingAreaSubnetId: String?
        /// Replication Configuration Staging Area tags.
        public let stagingAreaTags: [String: String]?
        /// Replication Configuration use Dedicated Replication Server.
        public let useDedicatedReplicationServer: Bool?
        /// Replication Configuration use Fips Endpoint.
        public let useFipsEndpoint: Bool?

        @inlinable
        public init(associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil, useFipsEndpoint: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case name = "name"
            case replicatedDisks = "replicatedDisks"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case sourceServerID = "sourceServerID"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
            case useFipsEndpoint = "useFipsEndpoint"
        }
    }

    public struct ReplicationConfigurationReplicatedDisk: AWSEncodableShape & AWSDecodableShape {
        /// Replication Configuration replicated disk device name.
        public let deviceName: String?
        /// Replication Configuration replicated disk IOPs.
        public let iops: Int64?
        /// Replication Configuration replicated disk boot disk.
        public let isBootDisk: Bool?
        /// Replication Configuration replicated disk staging disk type.
        public let stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// Replication Configuration replicated disk throughput.
        public let throughput: Int64?

        @inlinable
        public init(deviceName: String? = nil, iops: Int64? = nil, isBootDisk: Bool? = nil, stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType? = nil, throughput: Int64? = nil) {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 256)
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "deviceName"
            case iops = "iops"
            case isBootDisk = "isBootDisk"
            case stagingDiskType = "stagingDiskType"
            case throughput = "throughput"
        }
    }

    public struct ReplicationConfigurationTemplate: AWSDecodableShape {
        /// Replication Configuration template ARN.
        public let arn: String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public let associateDefaultSecurityGroup: Bool?
        /// Replication Configuration template bandwidth throttling.
        public let bandwidthThrottling: Int64?
        /// Replication Configuration template create Public IP.
        public let createPublicIP: Bool?
        /// Replication Configuration template data plane routing.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use default large Staging Disk type.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public let ebsEncryptionKeyArn: String?
        /// Replication Configuration template ID.
        public let replicationConfigurationTemplateID: String
        /// Replication Configuration template server instance type.
        public let replicationServerInstanceType: String?
        /// Replication Configuration template server Security Groups IDs.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Replication Configuration template Staging Area subnet ID.
        public let stagingAreaSubnetId: String?
        /// Replication Configuration template Staging Area Tags.
        public let stagingAreaTags: [String: String]?
        /// Replication Configuration template Tags.
        public let tags: [String: String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public let useDedicatedReplicationServer: Bool?
        /// Replication Configuration template use Fips Endpoint.
        public let useFipsEndpoint: Bool?

        @inlinable
        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, tags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil, useFipsEndpoint: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case replicationConfigurationTemplateID = "replicationConfigurationTemplateID"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case tags = "tags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
            case useFipsEndpoint = "useFipsEndpoint"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let code: String?
        public let message: String?
        /// Resource ID not found error.
        public let resourceId: String?
        /// Resource type not found error.
        public let resourceType: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.code = code
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ResumeReplicationRequest: AWSEncodableShape {
        /// Resume Replication Request account ID.
        public let accountID: String?
        /// Resume Replication Request source server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct RetryDataReplicationRequest: AWSEncodableShape {
        /// Retry data replication for Account ID.
        public let accountID: String?
        /// Retry data replication for Source Server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct S3BucketSource: AWSEncodableShape & AWSDecodableShape {
        /// S3 bucket source s3 bucket.
        public let s3Bucket: String
        /// S3 bucket source s3 bucket owner.
        public let s3BucketOwner: String?
        /// S3 bucket source s3 key.
        public let s3Key: String

        @inlinable
        public init(s3Bucket: String, s3BucketOwner: String? = nil, s3Key: String) {
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-zA-Z0-9.\\-_]{1,255}$")
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, max: 12)
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, min: 12)
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: "^[^\\x00]{1,1020}\\.csv$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3BucketOwner = "s3BucketOwner"
            case s3Key = "s3Key"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let code: String?
        public let message: String?
        /// Exceeded the service quota code.
        public let quotaCode: String?
        /// Exceeded the service quota value.
        public let quotaValue: Int?
        /// Exceeded the service quota resource ID.
        public let resourceId: String?
        /// Exceeded the service quota resource type.
        public let resourceType: String?
        /// Exceeded the service quota service code.
        public let serviceCode: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, quotaCode: String? = nil, quotaValue: Int? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String? = nil) {
            self.code = code
            self.message = message
            self.quotaCode = quotaCode
            self.quotaValue = quotaValue
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case quotaCode = "quotaCode"
            case quotaValue = "quotaValue"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct SourceProperties: AWSDecodableShape {
        /// Source Server CPUs.
        public let cpus: [CPU]?
        /// Source Server disks.
        public let disks: [Disk]?
        /// Source server identification hints.
        public let identificationHints: IdentificationHints?
        /// Source server last update date and time.
        public let lastUpdatedDateTime: String?
        /// Source server network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// Source server OS.
        public let os: OS?
        /// Source server RAM in bytes.
        public let ramBytes: Int64?
        /// Source server recommended instance type.
        public let recommendedInstanceType: String?

        @inlinable
        public init(cpus: [CPU]? = nil, disks: [Disk]? = nil, identificationHints: IdentificationHints? = nil, lastUpdatedDateTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, os: OS? = nil, ramBytes: Int64? = nil, recommendedInstanceType: String? = nil) {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case cpus = "cpus"
            case disks = "disks"
            case identificationHints = "identificationHints"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case networkInterfaces = "networkInterfaces"
            case os = "os"
            case ramBytes = "ramBytes"
            case recommendedInstanceType = "recommendedInstanceType"
        }
    }

    public struct SourceServer: AWSDecodableShape {
        /// Source server application ID.
        public let applicationID: String?
        /// Source server ARN.
        public let arn: String?
        /// Source Server connector action.
        public let connectorAction: SourceServerConnectorAction?
        /// Source server data replication info.
        public let dataReplicationInfo: DataReplicationInfo?
        /// Source server fqdn for action framework.
        public let fqdnForActionFramework: String?
        /// Source server archived status.
        public let isArchived: Bool?
        /// Source server launched instance.
        public let launchedInstance: LaunchedInstance?
        /// Source server lifecycle state.
        public let lifeCycle: LifeCycle?
        /// Source server replication type.
        public let replicationType: ReplicationType?
        /// Source server properties.
        public let sourceProperties: SourceProperties?
        /// Source server ID.
        public let sourceServerID: String?
        /// Source server Tags.
        public let tags: [String: String]?
        /// Source server user provided ID.
        public let userProvidedID: String?
        /// Source server vCenter client id.
        public let vcenterClientID: String?

        @inlinable
        public init(applicationID: String? = nil, arn: String? = nil, connectorAction: SourceServerConnectorAction? = nil, dataReplicationInfo: DataReplicationInfo? = nil, fqdnForActionFramework: String? = nil, isArchived: Bool? = nil, launchedInstance: LaunchedInstance? = nil, lifeCycle: LifeCycle? = nil, replicationType: ReplicationType? = nil, sourceProperties: SourceProperties? = nil, sourceServerID: String? = nil, tags: [String: String]? = nil, userProvidedID: String? = nil, vcenterClientID: String? = nil) {
            self.applicationID = applicationID
            self.arn = arn
            self.connectorAction = connectorAction
            self.dataReplicationInfo = dataReplicationInfo
            self.fqdnForActionFramework = fqdnForActionFramework
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.replicationType = replicationType
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
            self.userProvidedID = userProvidedID
            self.vcenterClientID = vcenterClientID
        }

        private enum CodingKeys: String, CodingKey {
            case applicationID = "applicationID"
            case arn = "arn"
            case connectorAction = "connectorAction"
            case dataReplicationInfo = "dataReplicationInfo"
            case fqdnForActionFramework = "fqdnForActionFramework"
            case isArchived = "isArchived"
            case launchedInstance = "launchedInstance"
            case lifeCycle = "lifeCycle"
            case replicationType = "replicationType"
            case sourceProperties = "sourceProperties"
            case sourceServerID = "sourceServerID"
            case tags = "tags"
            case userProvidedID = "userProvidedID"
            case vcenterClientID = "vcenterClientID"
        }
    }

    public struct SourceServerActionDocument: AWSDecodableShape {
        /// Source server post migration custom action ID.
        public let actionID: String?
        /// Source server post migration custom action name.
        public let actionName: String?
        /// Source server post migration custom action active status.
        public let active: Bool?
        /// Source server post migration custom action category.
        public let category: ActionCategory?
        /// Source server post migration custom action description.
        public let description: String?
        /// Source server post migration custom action document identifier.
        public let documentIdentifier: String?
        /// Source server post migration custom action document version.
        public let documentVersion: String?
        /// Source server post migration custom action external parameters.
        public let externalParameters: [String: SsmExternalParameter]?
        /// Source server post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Source server post migration custom action order.
        public let order: Int?
        /// Source server post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Source server post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        @inlinable
        public init(actionID: String? = nil, actionName: String? = nil, active: Bool? = nil, category: ActionCategory? = nil, description: String? = nil, documentIdentifier: String? = nil, documentVersion: String? = nil, externalParameters: [String: SsmExternalParameter]? = nil, mustSucceedForCutover: Bool? = nil, order: Int? = nil, parameters: [String: [SsmParameterStoreParameter]]? = nil, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case actionID = "actionID"
            case actionName = "actionName"
            case active = "active"
            case category = "category"
            case description = "description"
            case documentIdentifier = "documentIdentifier"
            case documentVersion = "documentVersion"
            case externalParameters = "externalParameters"
            case mustSucceedForCutover = "mustSucceedForCutover"
            case order = "order"
            case parameters = "parameters"
            case timeoutSeconds = "timeoutSeconds"
        }
    }

    public struct SourceServerActionsRequestFilters: AWSEncodableShape {
        /// Action IDs to filter source server post migration custom actions by.
        public let actionIDs: [String]?

        @inlinable
        public init(actionIDs: [String]? = nil) {
            self.actionIDs = actionIDs
        }

        public func validate(name: String) throws {
            try self.actionIDs?.forEach {
                try validate($0, name: "actionIDs[]", parent: name, max: 64)
                try validate($0, name: "actionIDs[]", parent: name, min: 1)
                try validate($0, name: "actionIDs[]", parent: name, pattern: "[0-9a-zA-Z]$")
            }
            try self.validate(self.actionIDs, name: "actionIDs", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case actionIDs = "actionIDs"
        }
    }

    public struct SourceServerConnectorAction: AWSEncodableShape & AWSDecodableShape {
        /// Source Server connector action connector arn.
        public let connectorArn: String?
        /// Source Server connector action credentials secret arn.
        public let credentialsSecretArn: String?

        @inlinable
        public init(connectorArn: String? = nil, credentialsSecretArn: String? = nil) {
            self.connectorArn = connectorArn
            self.credentialsSecretArn = credentialsSecretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorArn, name: "connectorArn", parent: name, max: 100)
            try self.validate(self.connectorArn, name: "connectorArn", parent: name, min: 27)
            try self.validate(self.connectorArn, name: "connectorArn", parent: name, pattern: "^arn:[\\w-]+:mgn:([a-z]{2}-(gov-)?[a-z]+-\\d{1})?:(\\d{12})?:connector\\/(connector-[0-9a-zA-Z]{17})$")
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, max: 100)
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, min: 20)
            try self.validate(self.credentialsSecretArn, name: "credentialsSecretArn", parent: name, pattern: "^arn:[\\w-]+:secretsmanager:([a-z]{2}-(gov-)?[a-z]+-\\d{1})?:(\\d{12})?:secret:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "connectorArn"
            case credentialsSecretArn = "credentialsSecretArn"
        }
    }

    public struct SsmDocument: AWSEncodableShape & AWSDecodableShape {
        /// User-friendly name for the AWS Systems Manager Document.
        public let actionName: String
        /// AWS Systems Manager Document external parameters.
        public let externalParameters: [String: SsmExternalParameter]?
        /// If true, Cutover will not be enabled if the document has failed.
        public let mustSucceedForCutover: Bool?
        /// AWS Systems Manager Document parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// AWS Systems Manager Document name or full ARN.
        public let ssmDocumentName: String
        /// AWS Systems Manager Document timeout seconds.
        public let timeoutSeconds: Int?

        @inlinable
        public init(actionName: String, externalParameters: [String: SsmExternalParameter]? = nil, mustSucceedForCutover: Bool? = nil, parameters: [String: [SsmParameterStoreParameter]]? = nil, ssmDocumentName: String, timeoutSeconds: Int? = nil) {
            self.actionName = actionName
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.parameters = parameters
            self.ssmDocumentName = ssmDocumentName
            self.timeoutSeconds = timeoutSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.actionName, name: "actionName", parent: name, max: 256)
            try self.externalParameters?.forEach {
                try validate($0.key, name: "externalParameters.key", parent: name, max: 1011)
                try validate($0.key, name: "externalParameters.key", parent: name, min: 1)
                try validate($0.key, name: "externalParameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try $0.value.validate(name: "\(name).externalParameters[\"\($0.key)\"]")
            }
            try self.validate(self.externalParameters, name: "externalParameters", parent: name, max: 20)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 1011)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^([A-Za-z0-9])+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 20)
            try self.validate(self.ssmDocumentName, name: "ssmDocumentName", parent: name, max: 172)
            try self.validate(self.ssmDocumentName, name: "ssmDocumentName", parent: name, min: 3)
            try self.validate(self.ssmDocumentName, name: "ssmDocumentName", parent: name, pattern: "^([A-Za-z0-9/:_\\.-])+$")
            try self.validate(self.timeoutSeconds, name: "timeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionName = "actionName"
            case externalParameters = "externalParameters"
            case mustSucceedForCutover = "mustSucceedForCutover"
            case parameters = "parameters"
            case ssmDocumentName = "ssmDocumentName"
            case timeoutSeconds = "timeoutSeconds"
        }
    }

    public struct SsmParameterStoreParameter: AWSEncodableShape & AWSDecodableShape {
        /// AWS Systems Manager Parameter Store parameter name.
        public let parameterName: String
        /// AWS Systems Manager Parameter Store parameter type.
        public let parameterType: SsmParameterStoreParameterType

        @inlinable
        public init(parameterName: String, parameterType: SsmParameterStoreParameterType) {
            self.parameterName = parameterName
            self.parameterType = parameterType
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 1011)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^([A-Za-z0-9_\\.-])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName = "parameterName"
            case parameterType = "parameterType"
        }
    }

    public struct StartCutoverRequest: AWSEncodableShape {
        /// Start Cutover by Account IDs
        public let accountID: String?
        /// Start Cutover by Source Server IDs.
        public let sourceServerIDs: [String]
        /// Start Cutover by Tags.
        public let tags: [String: String]?

        @inlinable
        public init(accountID: String? = nil, sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.accountID = accountID
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerIDs = "sourceServerIDs"
            case tags = "tags"
        }
    }

    public struct StartCutoverResponse: AWSDecodableShape {
        /// Start Cutover Job response.
        public let job: Job?

        @inlinable
        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct StartExportRequest: AWSEncodableShape {
        /// Start export request s3 bucket.
        public let s3Bucket: String
        /// Start export request s3 bucket owner.
        public let s3BucketOwner: String?
        /// Start export request s3key.
        public let s3Key: String

        @inlinable
        public init(s3Bucket: String, s3BucketOwner: String? = nil, s3Key: String) {
            self.s3Bucket = s3Bucket
            self.s3BucketOwner = s3BucketOwner
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-zA-Z0-9.\\-_]{1,255}$")
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, max: 12)
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, min: 12)
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: "^[^\\x00]{1,1020}\\.csv$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3BucketOwner = "s3BucketOwner"
            case s3Key = "s3Key"
        }
    }

    public struct StartExportResponse: AWSDecodableShape {
        /// Start export response export task.
        public let exportTask: ExportTask?

        @inlinable
        public init(exportTask: ExportTask? = nil) {
            self.exportTask = exportTask
        }

        private enum CodingKeys: String, CodingKey {
            case exportTask = "exportTask"
        }
    }

    public struct StartImportRequest: AWSEncodableShape {
        /// Start import request client token.
        public let clientToken: String?
        /// Start import request s3 bucket source.
        public let s3BucketSource: S3BucketSource

        @inlinable
        public init(clientToken: String? = StartImportRequest.idempotencyToken(), s3BucketSource: S3BucketSource) {
            self.clientToken = clientToken
            self.s3BucketSource = s3BucketSource
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.s3BucketSource.validate(name: "\(name).s3BucketSource")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case s3BucketSource = "s3BucketSource"
        }
    }

    public struct StartImportResponse: AWSDecodableShape {
        /// Start import response import task.
        public let importTask: ImportTask?

        @inlinable
        public init(importTask: ImportTask? = nil) {
            self.importTask = importTask
        }

        private enum CodingKeys: String, CodingKey {
            case importTask = "importTask"
        }
    }

    public struct StartReplicationRequest: AWSEncodableShape {
        /// Account ID on which to start replication.
        public let accountID: String?
        /// ID of source server on which to start replication.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct StartTestRequest: AWSEncodableShape {
        /// Start Test for Account ID.
        public let accountID: String?
        /// Start Test for Source Server IDs.
        public let sourceServerIDs: [String]
        /// Start Test by Tags.
        public let tags: [String: String]?

        @inlinable
        public init(accountID: String? = nil, sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.accountID = accountID
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerIDs = "sourceServerIDs"
            case tags = "tags"
        }
    }

    public struct StartTestResponse: AWSDecodableShape {
        /// Start Test Job response.
        public let job: Job?

        @inlinable
        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct StopReplicationRequest: AWSEncodableShape {
        /// Stop Replication Request account ID.
        public let accountID: String?
        /// Stop Replication Request source server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Tag resource by ARN.
        public let resourceArn: String
        /// Tag resource by Tags.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TemplateActionDocument: AWSDecodableShape {
        /// Template post migration custom action ID.
        public let actionID: String?
        /// Template post migration custom action name.
        public let actionName: String?
        /// Template post migration custom action active status.
        public let active: Bool?
        /// Template post migration custom action category.
        public let category: ActionCategory?
        /// Template post migration custom action description.
        public let description: String?
        /// Template post migration custom action document identifier.
        public let documentIdentifier: String?
        /// Template post migration custom action document version.
        public let documentVersion: String?
        /// Template post migration custom action external parameters.
        public let externalParameters: [String: SsmExternalParameter]?
        /// Template post migration custom action must succeed for cutover.
        public let mustSucceedForCutover: Bool?
        /// Operating system eligible for this template post migration custom action.
        public let operatingSystem: String?
        /// Template post migration custom action order.
        public let order: Int?
        /// Template post migration custom action parameters.
        public let parameters: [String: [SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public let timeoutSeconds: Int?

        @inlinable
        public init(actionID: String? = nil, actionName: String? = nil, active: Bool? = nil, category: ActionCategory? = nil, description: String? = nil, documentIdentifier: String? = nil, documentVersion: String? = nil, externalParameters: [String: SsmExternalParameter]? = nil, mustSucceedForCutover: Bool? = nil, operatingSystem: String? = nil, order: Int? = nil, parameters: [String: [SsmParameterStoreParameter]]? = nil, timeoutSeconds: Int? = nil) {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.category = category
            self.description = description
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.externalParameters = externalParameters
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case actionID = "actionID"
            case actionName = "actionName"
            case active = "active"
            case category = "category"
            case description = "description"
            case documentIdentifier = "documentIdentifier"
            case documentVersion = "documentVersion"
            case externalParameters = "externalParameters"
            case mustSucceedForCutover = "mustSucceedForCutover"
            case operatingSystem = "operatingSystem"
            case order = "order"
            case parameters = "parameters"
            case timeoutSeconds = "timeoutSeconds"
        }
    }

    public struct TemplateActionsRequestFilters: AWSEncodableShape {
        /// Action IDs to filter template post migration custom actions by.
        public let actionIDs: [String]?

        @inlinable
        public init(actionIDs: [String]? = nil) {
            self.actionIDs = actionIDs
        }

        public func validate(name: String) throws {
            try self.actionIDs?.forEach {
                try validate($0, name: "actionIDs[]", parent: name, max: 64)
                try validate($0, name: "actionIDs[]", parent: name, min: 1)
                try validate($0, name: "actionIDs[]", parent: name, pattern: "[0-9a-zA-Z]$")
            }
            try self.validate(self.actionIDs, name: "actionIDs", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case actionIDs = "actionIDs"
        }
    }

    public struct TerminateTargetInstancesRequest: AWSEncodableShape {
        /// Terminate Target instance by Account ID
        public let accountID: String?
        /// Terminate Target instance by Source Server IDs.
        public let sourceServerIDs: [String]
        /// Terminate Target instance by Tags.
        public let tags: [String: String]?

        @inlinable
        public init(accountID: String? = nil, sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.accountID = accountID
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case sourceServerIDs = "sourceServerIDs"
            case tags = "tags"
        }
    }

    public struct TerminateTargetInstancesResponse: AWSDecodableShape {
        /// Terminate Target instance Job response.
        public let job: Job?

        @inlinable
        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// Reached throttling quota exception.
        public let quotaCode: String?
        /// Reached throttling quota exception will retry after x seconds.
        public let retryAfterSeconds: String?
        /// Reached throttling quota exception service code.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(String.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UnarchiveApplicationRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application ID.
        public let applicationID: String

        @inlinable
        public init(accountID: String? = nil, applicationID: String) {
            self.accountID = accountID
            self.applicationID = applicationID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
        }
    }

    public struct UnarchiveWaveRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Wave ID.
        public let waveID: String

        @inlinable
        public init(accountID: String? = nil, waveID: String) {
            self.accountID = accountID
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case waveID = "waveID"
        }
    }

    public struct UninitializedAccountException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Untag resource by ARN.
        public let resourceArn: String
        /// Untag resource by Keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Application ID.
        public let applicationID: String
        /// Application description.
        public let description: String?
        /// Application name.
        public let name: String?

        @inlinable
        public init(accountID: String? = nil, applicationID: String, description: String? = nil, name: String? = nil) {
            self.accountID = accountID
            self.applicationID = applicationID
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.applicationID, name: "applicationID", parent: name, max: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, min: 21)
            try self.validate(self.applicationID, name: "applicationID", parent: name, pattern: "^app-[0-9a-zA-Z]{17}$")
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case applicationID = "applicationID"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateConnectorRequest: AWSEncodableShape {
        /// Update Connector request connector ID.
        public let connectorID: String
        /// Update Connector request name.
        public let name: String?
        /// Update Connector request SSM command config.
        public let ssmCommandConfig: ConnectorSsmCommandConfig?

        @inlinable
        public init(connectorID: String, name: String? = nil, ssmCommandConfig: ConnectorSsmCommandConfig? = nil) {
            self.connectorID = connectorID
            self.name = name
            self.ssmCommandConfig = ssmCommandConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorID, name: "connectorID", parent: name, max: 27)
            try self.validate(self.connectorID, name: "connectorID", parent: name, min: 27)
            try self.validate(self.connectorID, name: "connectorID", parent: name, pattern: "^connector-[0-9a-zA-Z]{17}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.ssmCommandConfig?.validate(name: "\(name).ssmCommandConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorID = "connectorID"
            case name = "name"
            case ssmCommandConfig = "ssmCommandConfig"
        }
    }

    public struct UpdateLaunchConfigurationRequest: AWSEncodableShape {
        /// Update Launch configuration Account ID.
        public let accountID: String?
        /// Update Launch configuration boot mode request.
        public let bootMode: BootMode?
        /// Update Launch configuration copy Private IP request.
        public let copyPrivateIp: Bool?
        /// Update Launch configuration copy Tags request.
        public let copyTags: Bool?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Update Launch configuration launch disposition request.
        public let launchDisposition: LaunchDisposition?
        /// Update Launch configuration licensing request.
        public let licensing: Licensing?
        /// Launch configuration map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Update Launch configuration name request.
        public let name: String?
        public let postLaunchActions: PostLaunchActions?
        /// Update Launch configuration by Source Server ID request.
        public let sourceServerID: String
        /// Update Launch configuration Target instance right sizing request.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        @inlinable
        public init(accountID: String? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, enableMapAutoTagging: Bool? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, name: String? = nil, postLaunchActions: PostLaunchActions? = nil, sourceServerID: String, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.accountID = accountID
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.enableMapAutoTagging = enableMapAutoTagging
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.name = name
            self.postLaunchActions = postLaunchActions
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.mapAutoTaggingMpeID, name: "mapAutoTaggingMpeID", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.postLaunchActions?.validate(name: "\(name).postLaunchActions")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case bootMode = "bootMode"
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case enableMapAutoTagging = "enableMapAutoTagging"
            case launchDisposition = "launchDisposition"
            case licensing = "licensing"
            case mapAutoTaggingMpeID = "mapAutoTaggingMpeID"
            case name = "name"
            case postLaunchActions = "postLaunchActions"
            case sourceServerID = "sourceServerID"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct UpdateLaunchConfigurationTemplateRequest: AWSEncodableShape {
        /// Associate public Ip address.
        public let associatePublicIpAddress: Bool?
        /// Launch configuration template boot mode.
        public let bootMode: BootMode?
        /// Copy private Ip.
        public let copyPrivateIp: Bool?
        /// Copy tags.
        public let copyTags: Bool?
        /// Enable map auto tagging.
        public let enableMapAutoTagging: Bool?
        /// Large volume config.
        public let largeVolumeConf: LaunchTemplateDiskConf?
        /// Launch Configuration Template ID.
        public let launchConfigurationTemplateID: String
        /// Launch disposition.
        public let launchDisposition: LaunchDisposition?
        public let licensing: Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public let mapAutoTaggingMpeID: String?
        /// Post Launch Action to execute on the Test or Cutover instance.
        public let postLaunchActions: PostLaunchActions?
        /// Small volume config.
        public let smallVolumeConf: LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public let smallVolumeMaxSize: Int64?
        /// Target instance type right-sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        @inlinable
        public init(associatePublicIpAddress: Bool? = nil, bootMode: BootMode? = nil, copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, enableMapAutoTagging: Bool? = nil, largeVolumeConf: LaunchTemplateDiskConf? = nil, launchConfigurationTemplateID: String, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, mapAutoTaggingMpeID: String? = nil, postLaunchActions: PostLaunchActions? = nil, smallVolumeConf: LaunchTemplateDiskConf? = nil, smallVolumeMaxSize: Int64? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.largeVolumeConf?.validate(name: "\(name).largeVolumeConf")
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.launchConfigurationTemplateID, name: "launchConfigurationTemplateID", parent: name, pattern: "^lct-[0-9a-zA-Z]{17}$")
            try self.validate(self.mapAutoTaggingMpeID, name: "mapAutoTaggingMpeID", parent: name, max: 256)
            try self.postLaunchActions?.validate(name: "\(name).postLaunchActions")
            try self.smallVolumeConf?.validate(name: "\(name).smallVolumeConf")
            try self.validate(self.smallVolumeMaxSize, name: "smallVolumeMaxSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress = "associatePublicIpAddress"
            case bootMode = "bootMode"
            case copyPrivateIp = "copyPrivateIp"
            case copyTags = "copyTags"
            case enableMapAutoTagging = "enableMapAutoTagging"
            case largeVolumeConf = "largeVolumeConf"
            case launchConfigurationTemplateID = "launchConfigurationTemplateID"
            case launchDisposition = "launchDisposition"
            case licensing = "licensing"
            case mapAutoTaggingMpeID = "mapAutoTaggingMpeID"
            case postLaunchActions = "postLaunchActions"
            case smallVolumeConf = "smallVolumeConf"
            case smallVolumeMaxSize = "smallVolumeMaxSize"
            case targetInstanceTypeRightSizingMethod = "targetInstanceTypeRightSizingMethod"
        }
    }

    public struct UpdateReplicationConfigurationRequest: AWSEncodableShape {
        /// Update replication configuration Account ID request.
        public let accountID: String?
        /// Update replication configuration associate default Application Migration Service Security group request.
        public let associateDefaultSecurityGroup: Bool?
        /// Update replication configuration bandwidth throttling request.
        public let bandwidthThrottling: Int64?
        /// Update replication configuration create Public IP request.
        public let createPublicIP: Bool?
        /// Update replication configuration data plane routing request.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Update replication configuration use default large Staging Disk type request.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Update replication configuration EBS encryption request.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Update replication configuration EBS encryption key ARN request.
        public let ebsEncryptionKeyArn: String?
        /// Update replication configuration name request.
        public let name: String?
        /// Update replication configuration replicated disks request.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// Update replication configuration Replication Server instance type request.
        public let replicationServerInstanceType: String?
        /// Update replication configuration Replication Server Security Groups IDs request.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Update replication configuration Source Server ID request.
        public let sourceServerID: String
        /// Update replication configuration Staging Area subnet request.
        public let stagingAreaSubnetId: String?
        /// Update replication configuration Staging Area Tags request.
        public let stagingAreaTags: [String: String]?
        /// Update replication configuration use dedicated Replication Server request.
        public let useDedicatedReplicationServer: Bool?
        /// Update replication configuration use Fips Endpoint.
        public let useFipsEndpoint: Bool?

        @inlinable
        public init(accountID: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil, useFipsEndpoint: Bool? = nil) {
            self.accountID = accountID
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, max: 10000)
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.replicatedDisks?.forEach {
                try $0.validate(name: "\(name).replicatedDisks[]")
            }
            try self.validate(self.replicatedDisks, name: "replicatedDisks", parent: name, max: 60)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.stagingAreaTags, name: "stagingAreaTags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case name = "name"
            case replicatedDisks = "replicatedDisks"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case sourceServerID = "sourceServerID"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
            case useFipsEndpoint = "useFipsEndpoint"
        }
    }

    public struct UpdateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Update replication configuration template ARN request.
        public let arn: String?
        /// Update replication configuration template associate default Application Migration Service Security group request.
        public let associateDefaultSecurityGroup: Bool?
        /// Update replication configuration template bandwidth throttling request.
        public let bandwidthThrottling: Int64?
        /// Update replication configuration template create Public IP request.
        public let createPublicIP: Bool?
        /// Update replication configuration template data plane routing request.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Update replication configuration template use default large Staging Disk type request.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Update replication configuration template EBS encryption request.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Update replication configuration template EBS encryption key ARN request.
        public let ebsEncryptionKeyArn: String?
        /// Update replication configuration template template ID request.
        public let replicationConfigurationTemplateID: String
        /// Update replication configuration template Replication Server instance type request.
        public let replicationServerInstanceType: String?
        /// Update replication configuration template Replication Server Security groups IDs request.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Update replication configuration template Staging Area subnet ID request.
        public let stagingAreaSubnetId: String?
        /// Update replication configuration template Staging Area Tags request.
        public let stagingAreaTags: [String: String]?
        /// Update replication configuration template use dedicated Replication Server request.
        public let useDedicatedReplicationServer: Bool?
        /// Update replication configuration template use Fips Endpoint request.
        public let useFipsEndpoint: Bool?

        @inlinable
        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil, useFipsEndpoint: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
            self.useFipsEndpoint = useFipsEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, max: 10000)
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.stagingAreaTags, name: "stagingAreaTags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associateDefaultSecurityGroup = "associateDefaultSecurityGroup"
            case bandwidthThrottling = "bandwidthThrottling"
            case createPublicIP = "createPublicIP"
            case dataPlaneRouting = "dataPlaneRouting"
            case defaultLargeStagingDiskType = "defaultLargeStagingDiskType"
            case ebsEncryption = "ebsEncryption"
            case ebsEncryptionKeyArn = "ebsEncryptionKeyArn"
            case replicationConfigurationTemplateID = "replicationConfigurationTemplateID"
            case replicationServerInstanceType = "replicationServerInstanceType"
            case replicationServersSecurityGroupsIDs = "replicationServersSecurityGroupsIDs"
            case stagingAreaSubnetId = "stagingAreaSubnetId"
            case stagingAreaTags = "stagingAreaTags"
            case useDedicatedReplicationServer = "useDedicatedReplicationServer"
            case useFipsEndpoint = "useFipsEndpoint"
        }
    }

    public struct UpdateSourceServerReplicationTypeRequest: AWSEncodableShape {
        /// Account ID on which to update replication type.
        public let accountID: String?
        /// Replication type to which to update source server.
        public let replicationType: ReplicationType
        /// ID of source server on which to update replication type.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, replicationType: ReplicationType, sourceServerID: String) {
            self.accountID = accountID
            self.replicationType = replicationType
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case replicationType = "replicationType"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct UpdateSourceServerRequest: AWSEncodableShape {
        /// Update Source Server request account ID.
        public let accountID: String?
        /// Update Source Server request connector action.
        public let connectorAction: SourceServerConnectorAction?
        /// Update Source Server request source server ID.
        public let sourceServerID: String

        @inlinable
        public init(accountID: String? = nil, connectorAction: SourceServerConnectorAction? = nil, sourceServerID: String) {
            self.accountID = accountID
            self.connectorAction = connectorAction
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.connectorAction?.validate(name: "\(name).connectorAction")
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case connectorAction = "connectorAction"
            case sourceServerID = "sourceServerID"
        }
    }

    public struct UpdateWaveRequest: AWSEncodableShape {
        /// Account ID.
        public let accountID: String?
        /// Wave description.
        public let description: String?
        /// Wave name.
        public let name: String?
        /// Wave ID.
        public let waveID: String

        @inlinable
        public init(accountID: String? = nil, description: String? = nil, name: String? = nil, waveID: String) {
            self.accountID = accountID
            self.description = description
            self.name = name
            self.waveID = waveID
        }

        public func validate(name: String) throws {
            try self.validate(self.accountID, name: "accountID", parent: name, max: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, min: 12)
            try self.validate(self.accountID, name: "accountID", parent: name, pattern: "[0-9]{12,}")
            try self.validate(self.description, name: "description", parent: name, max: 600)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\s\\x00]( *[^\\s\\x00])*$")
            try self.validate(self.waveID, name: "waveID", parent: name, max: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, min: 22)
            try self.validate(self.waveID, name: "waveID", parent: name, pattern: "^wave-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "accountID"
            case description = "description"
            case name = "name"
            case waveID = "waveID"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let code: String?
        /// Validate exception field list.
        public let fieldList: [ValidationExceptionField]?
        public let message: String?
        /// Validate exception reason.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(code: String? = nil, fieldList: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil) {
            self.code = code
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// Validate exception field message.
        public let message: String?
        /// Validate exception field name.
        public let name: String?

        @inlinable
        public init(message: String? = nil, name: String? = nil) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VcenterClient: AWSDecodableShape {
        /// Arn of vCenter client.
        public let arn: String?
        /// Datacenter name of vCenter client.
        public let datacenterName: String?
        /// Hostname of vCenter client .
        public let hostname: String?
        /// Last seen time of vCenter client.
        public let lastSeenDatetime: String?
        /// Tags for Source Server of vCenter client.
        public let sourceServerTags: [String: String]?
        /// Tags for vCenter client.
        public let tags: [String: String]?
        /// ID of vCenter client.
        public let vcenterClientID: String?
        /// Vcenter UUID of vCenter client.
        public let vcenterUUID: String?

        @inlinable
        public init(arn: String? = nil, datacenterName: String? = nil, hostname: String? = nil, lastSeenDatetime: String? = nil, sourceServerTags: [String: String]? = nil, tags: [String: String]? = nil, vcenterClientID: String? = nil, vcenterUUID: String? = nil) {
            self.arn = arn
            self.datacenterName = datacenterName
            self.hostname = hostname
            self.lastSeenDatetime = lastSeenDatetime
            self.sourceServerTags = sourceServerTags
            self.tags = tags
            self.vcenterClientID = vcenterClientID
            self.vcenterUUID = vcenterUUID
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case datacenterName = "datacenterName"
            case hostname = "hostname"
            case lastSeenDatetime = "lastSeenDatetime"
            case sourceServerTags = "sourceServerTags"
            case tags = "tags"
            case vcenterClientID = "vcenterClientID"
            case vcenterUUID = "vcenterUUID"
        }
    }

    public struct Wave: AWSDecodableShape {
        /// Wave ARN.
        public let arn: String?
        /// Wave creation dateTime.
        public let creationDateTime: String?
        /// Wave description.
        public let description: String?
        /// Wave archival status.
        public let isArchived: Bool?
        /// Wave last modified dateTime.
        public let lastModifiedDateTime: String?
        /// Wave name.
        public let name: String?
        /// Wave tags.
        public let tags: [String: String]?
        /// Wave aggregated status.
        public let waveAggregatedStatus: WaveAggregatedStatus?
        /// Wave ID.
        public let waveID: String?

        @inlinable
        public init(arn: String? = nil, creationDateTime: String? = nil, description: String? = nil, isArchived: Bool? = nil, lastModifiedDateTime: String? = nil, name: String? = nil, tags: [String: String]? = nil, waveAggregatedStatus: WaveAggregatedStatus? = nil, waveID: String? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveAggregatedStatus = waveAggregatedStatus
            self.waveID = waveID
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case isArchived = "isArchived"
            case lastModifiedDateTime = "lastModifiedDateTime"
            case name = "name"
            case tags = "tags"
            case waveAggregatedStatus = "waveAggregatedStatus"
            case waveID = "waveID"
        }
    }

    public struct WaveAggregatedStatus: AWSDecodableShape {
        /// Wave aggregated status health status.
        public let healthStatus: WaveHealthStatus?
        /// Wave aggregated status last update dateTime.
        public let lastUpdateDateTime: String?
        /// Wave aggregated status progress status.
        public let progressStatus: WaveProgressStatus?
        /// DateTime marking when the first source server in the wave started replication.
        public let replicationStartedDateTime: String?
        /// Wave aggregated status total applications amount.
        public let totalApplications: Int64?

        @inlinable
        public init(healthStatus: WaveHealthStatus? = nil, lastUpdateDateTime: String? = nil, progressStatus: WaveProgressStatus? = nil, replicationStartedDateTime: String? = nil, totalApplications: Int64? = nil) {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.replicationStartedDateTime = replicationStartedDateTime
            self.totalApplications = totalApplications
        }

        private enum CodingKeys: String, CodingKey {
            case healthStatus = "healthStatus"
            case lastUpdateDateTime = "lastUpdateDateTime"
            case progressStatus = "progressStatus"
            case replicationStartedDateTime = "replicationStartedDateTime"
            case totalApplications = "totalApplications"
        }
    }

    public struct SsmExternalParameter: AWSEncodableShape & AWSDecodableShape {
        /// AWS Systems Manager Document external parameters dynamic path.
        public let dynamicPath: String?

        @inlinable
        public init(dynamicPath: String? = nil) {
            self.dynamicPath = dynamicPath
        }

        public func validate(name: String) throws {
            try self.validate(self.dynamicPath, name: "dynamicPath", parent: name, max: 1011)
            try self.validate(self.dynamicPath, name: "dynamicPath", parent: name, min: 1)
            try self.validate(self.dynamicPath, name: "dynamicPath", parent: name, pattern: "^[a-zA-Z0-9_]+(\\.[a-zA-Z0-9_\\[\\]]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicPath = "dynamicPath"
        }
    }
}

// MARK: - Errors

/// Error enum for Mgn
public struct MgnErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case uninitializedAccountException = "UninitializedAccountException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Mgn
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Operating denied due to a file permission or access check error.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be completed due to a conflict with the current state of the target resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The server encountered an unexpected condition that prevented it from fulfilling the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Resource not found exception.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request could not be completed because its exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Reached throttling quota exception.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Uninitialized account exception.
    public static var uninitializedAccountException: Self { .init(.uninitializedAccountException) }
    /// Validate exception.
    public static var validationException: Self { .init(.validationException) }
}

extension MgnErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": Mgn.AccessDeniedException.self,
        "ConflictException": Mgn.ConflictException.self,
        "InternalServerException": Mgn.InternalServerException.self,
        "ResourceNotFoundException": Mgn.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Mgn.ServiceQuotaExceededException.self,
        "ThrottlingException": Mgn.ThrottlingException.self,
        "UninitializedAccountException": Mgn.UninitializedAccountException.self,
        "ValidationException": Mgn.ValidationException.self
    ]
}

extension MgnErrorType: Equatable {
    public static func == (lhs: MgnErrorType, rhs: MgnErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MgnErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
