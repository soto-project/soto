//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Mgn service.
///
/// The Application Migration Service service.
public struct Mgn: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Mgn client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Mgn",
            serviceIdentifier: "mgn",
            serviceProtocol: .restjson,
            apiVersion: "2020-02-26",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: MgnErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "mgn-fips.us-east-1.amazonaws.com",
            "us-east-2": "mgn-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "mgn-fips.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "mgn-fips.us-gov-west-1.amazonaws.com",
            "us-west-1": "mgn-fips.us-west-1.amazonaws.com",
            "us-west-2": "mgn-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Archive application.
    @Sendable
    @inlinable
    public func archiveApplication(_ input: ArchiveApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Application {
        try await self.client.execute(
            operation: "ArchiveApplication", 
            path: "/ArchiveApplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Archive application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationID: Application ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func archiveApplication(
        accountID: String? = nil,
        applicationID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Application {
        let input = ArchiveApplicationRequest(
            accountID: accountID, 
            applicationID: applicationID
        )
        return try await self.archiveApplication(input, logger: logger)
    }

    /// Archive wave.
    @Sendable
    @inlinable
    public func archiveWave(_ input: ArchiveWaveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Wave {
        try await self.client.execute(
            operation: "ArchiveWave", 
            path: "/ArchiveWave", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Archive wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - waveID: Wave ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func archiveWave(
        accountID: String? = nil,
        waveID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Wave {
        let input = ArchiveWaveRequest(
            accountID: accountID, 
            waveID: waveID
        )
        return try await self.archiveWave(input, logger: logger)
    }

    /// Associate applications to wave.
    @Sendable
    @inlinable
    public func associateApplications(_ input: AssociateApplicationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateApplicationsResponse {
        try await self.client.execute(
            operation: "AssociateApplications", 
            path: "/AssociateApplications", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associate applications to wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationIDs: Application IDs list.
    ///   - waveID: Wave ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateApplications(
        accountID: String? = nil,
        applicationIDs: [String],
        waveID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateApplicationsResponse {
        let input = AssociateApplicationsRequest(
            accountID: accountID, 
            applicationIDs: applicationIDs, 
            waveID: waveID
        )
        return try await self.associateApplications(input, logger: logger)
    }

    /// Associate source servers to application.
    @Sendable
    @inlinable
    public func associateSourceServers(_ input: AssociateSourceServersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateSourceServersResponse {
        try await self.client.execute(
            operation: "AssociateSourceServers", 
            path: "/AssociateSourceServers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associate source servers to application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationID: Application ID.
    ///   - sourceServerIDs: Source server IDs list.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateSourceServers(
        accountID: String? = nil,
        applicationID: String,
        sourceServerIDs: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateSourceServersResponse {
        let input = AssociateSourceServersRequest(
            accountID: accountID, 
            applicationID: applicationID, 
            sourceServerIDs: sourceServerIDs
        )
        return try await self.associateSourceServers(input, logger: logger)
    }

    /// Allows the user to set the SourceServer.LifeCycle.state property for specific Source Server IDs to one of the following: READY_FOR_TEST or READY_FOR_CUTOVER. This command only works if the Source Server is already launchable (dataReplicationInfo.lagDuration is not null.)
    @Sendable
    @inlinable
    public func changeServerLifeCycleState(_ input: ChangeServerLifeCycleStateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "ChangeServerLifeCycleState", 
            path: "/ChangeServerLifeCycleState", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows the user to set the SourceServer.LifeCycle.state property for specific Source Server IDs to one of the following: READY_FOR_TEST or READY_FOR_CUTOVER. This command only works if the Source Server is already launchable (dataReplicationInfo.lagDuration is not null.)
    ///
    /// Parameters:
    ///   - accountID: The request to change the source server migration account ID.
    ///   - lifeCycle: The request to change the source server migration lifecycle state.
    ///   - sourceServerID: The request to change the source server migration lifecycle state by source server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func changeServerLifeCycleState(
        accountID: String? = nil,
        lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = ChangeServerLifeCycleStateRequest(
            accountID: accountID, 
            lifeCycle: lifeCycle, 
            sourceServerID: sourceServerID
        )
        return try await self.changeServerLifeCycleState(input, logger: logger)
    }

    /// Create application.
    @Sendable
    @inlinable
    public func createApplication(_ input: CreateApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Application {
        try await self.client.execute(
            operation: "CreateApplication", 
            path: "/CreateApplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - description: Application description.
    ///   - name: Application name.
    ///   - tags: Application tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func createApplication(
        accountID: String? = nil,
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Application {
        let input = CreateApplicationRequest(
            accountID: accountID, 
            description: description, 
            name: name, 
            tags: tags
        )
        return try await self.createApplication(input, logger: logger)
    }

    /// Create Connector.
    @Sendable
    @inlinable
    public func createConnector(_ input: CreateConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Connector {
        try await self.client.execute(
            operation: "CreateConnector", 
            path: "/CreateConnector", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create Connector.
    ///
    /// Parameters:
    ///   - name: Create Connector request name.
    ///   - ssmCommandConfig: Create Connector request SSM command config.
    ///   - ssmInstanceID: Create Connector request SSM instance ID.
    ///   - tags: Create Connector request tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func createConnector(
        name: String,
        ssmCommandConfig: ConnectorSsmCommandConfig? = nil,
        ssmInstanceID: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Connector {
        let input = CreateConnectorRequest(
            name: name, 
            ssmCommandConfig: ssmCommandConfig, 
            ssmInstanceID: ssmInstanceID, 
            tags: tags
        )
        return try await self.createConnector(input, logger: logger)
    }

    /// Creates a new Launch Configuration Template.
    @Sendable
    @inlinable
    public func createLaunchConfigurationTemplate(_ input: CreateLaunchConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchConfigurationTemplate {
        try await self.client.execute(
            operation: "CreateLaunchConfigurationTemplate", 
            path: "/CreateLaunchConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new Launch Configuration Template.
    ///
    /// Parameters:
    ///   - associatePublicIpAddress: Associate public Ip address.
    ///   - bootMode: Launch configuration template boot mode.
    ///   - copyPrivateIp: Copy private Ip.
    ///   - copyTags: Copy tags.
    ///   - enableMapAutoTagging: Enable map auto tagging.
    ///   - largeVolumeConf: Large volume config.
    ///   - launchDisposition: Launch disposition.
    ///   - licensing: 
    ///   - mapAutoTaggingMpeID: Launch configuration template map auto tagging MPE ID.
    ///   - postLaunchActions: Launch configuration template post launch actions.
    ///   - smallVolumeConf: Small volume config.
    ///   - smallVolumeMaxSize: Small volume maximum size.
    ///   - tags: Request to associate tags during creation of a Launch Configuration Template.
    ///   - targetInstanceTypeRightSizingMethod: Target instance type right-sizing method.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLaunchConfigurationTemplate(
        associatePublicIpAddress: Bool? = nil,
        bootMode: BootMode? = nil,
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        enableMapAutoTagging: Bool? = nil,
        largeVolumeConf: LaunchTemplateDiskConf? = nil,
        launchDisposition: LaunchDisposition? = nil,
        licensing: Licensing? = nil,
        mapAutoTaggingMpeID: String? = nil,
        postLaunchActions: PostLaunchActions? = nil,
        smallVolumeConf: LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Int64? = nil,
        tags: [String: String]? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchConfigurationTemplate {
        let input = CreateLaunchConfigurationTemplateRequest(
            associatePublicIpAddress: associatePublicIpAddress, 
            bootMode: bootMode, 
            copyPrivateIp: copyPrivateIp, 
            copyTags: copyTags, 
            enableMapAutoTagging: enableMapAutoTagging, 
            largeVolumeConf: largeVolumeConf, 
            launchDisposition: launchDisposition, 
            licensing: licensing, 
            mapAutoTaggingMpeID: mapAutoTaggingMpeID, 
            postLaunchActions: postLaunchActions, 
            smallVolumeConf: smallVolumeConf, 
            smallVolumeMaxSize: smallVolumeMaxSize, 
            tags: tags, 
            targetInstanceTypeRightSizingMethod: targetInstanceTypeRightSizingMethod
        )
        return try await self.createLaunchConfigurationTemplate(input, logger: logger)
    }

    /// Creates a new ReplicationConfigurationTemplate.
    @Sendable
    @inlinable
    public func createReplicationConfigurationTemplate(_ input: CreateReplicationConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfigurationTemplate {
        try await self.client.execute(
            operation: "CreateReplicationConfigurationTemplate", 
            path: "/CreateReplicationConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new ReplicationConfigurationTemplate.
    ///
    /// Parameters:
    ///   - associateDefaultSecurityGroup: Request to associate the default Application Migration Service Security group with the Replication Settings template.
    ///   - bandwidthThrottling: Request to configure bandwidth throttling during Replication Settings template creation.
    ///   - createPublicIP: Request to create Public IP during Replication Settings template creation.
    ///   - dataPlaneRouting: Request to configure  data plane routing during Replication Settings template creation.
    ///   - defaultLargeStagingDiskType: Request to configure the default large staging disk EBS volume type during Replication Settings template creation.
    ///   - ebsEncryption: Request to configure EBS encryption during Replication Settings template creation.
    ///   - ebsEncryptionKeyArn: Request to configure an EBS encryption key during Replication Settings template creation.
    ///   - replicationServerInstanceType: Request to configure the Replication Server instance type during Replication Settings template creation.
    ///   - replicationServersSecurityGroupsIDs: Request to configure the Replication Server Security group ID during Replication Settings template creation.
    ///   - stagingAreaSubnetId: Request to configure the Staging Area subnet ID during Replication Settings template creation.
    ///   - stagingAreaTags: Request to configure Staging Area tags during Replication Settings template creation.
    ///   - tags: Request to configure tags during Replication Settings template creation.
    ///   - useDedicatedReplicationServer: Request to use Dedicated Replication Servers during Replication Settings template creation.
    ///   - useFipsEndpoint: Request to use Fips Endpoint during Replication Settings template creation.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReplicationConfigurationTemplate(
        associateDefaultSecurityGroup: Bool,
        bandwidthThrottling: Int64 = 0,
        createPublicIP: Bool,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType,
        ebsEncryption: ReplicationConfigurationEbsEncryption,
        ebsEncryptionKeyArn: String? = nil,
        replicationServerInstanceType: String,
        replicationServersSecurityGroupsIDs: [String],
        stagingAreaSubnetId: String,
        stagingAreaTags: [String: String],
        tags: [String: String]? = nil,
        useDedicatedReplicationServer: Bool,
        useFipsEndpoint: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfigurationTemplate {
        let input = CreateReplicationConfigurationTemplateRequest(
            associateDefaultSecurityGroup: associateDefaultSecurityGroup, 
            bandwidthThrottling: bandwidthThrottling, 
            createPublicIP: createPublicIP, 
            dataPlaneRouting: dataPlaneRouting, 
            defaultLargeStagingDiskType: defaultLargeStagingDiskType, 
            ebsEncryption: ebsEncryption, 
            ebsEncryptionKeyArn: ebsEncryptionKeyArn, 
            replicationServerInstanceType: replicationServerInstanceType, 
            replicationServersSecurityGroupsIDs: replicationServersSecurityGroupsIDs, 
            stagingAreaSubnetId: stagingAreaSubnetId, 
            stagingAreaTags: stagingAreaTags, 
            tags: tags, 
            useDedicatedReplicationServer: useDedicatedReplicationServer, 
            useFipsEndpoint: useFipsEndpoint
        )
        return try await self.createReplicationConfigurationTemplate(input, logger: logger)
    }

    /// Create wave.
    @Sendable
    @inlinable
    public func createWave(_ input: CreateWaveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Wave {
        try await self.client.execute(
            operation: "CreateWave", 
            path: "/CreateWave", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - description: Wave description.
    ///   - name: Wave name.
    ///   - tags: Wave tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWave(
        accountID: String? = nil,
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Wave {
        let input = CreateWaveRequest(
            accountID: accountID, 
            description: description, 
            name: name, 
            tags: tags
        )
        return try await self.createWave(input, logger: logger)
    }

    /// Delete application.
    @Sendable
    @inlinable
    public func deleteApplication(_ input: DeleteApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteApplicationResponse {
        try await self.client.execute(
            operation: "DeleteApplication", 
            path: "/DeleteApplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationID: Application ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteApplication(
        accountID: String? = nil,
        applicationID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteApplicationResponse {
        let input = DeleteApplicationRequest(
            accountID: accountID, 
            applicationID: applicationID
        )
        return try await self.deleteApplication(input, logger: logger)
    }

    /// Delete Connector.
    @Sendable
    @inlinable
    public func deleteConnector(_ input: DeleteConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteConnector", 
            path: "/DeleteConnector", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete Connector.
    ///
    /// Parameters:
    ///   - connectorID: Delete Connector request connector ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteConnector(
        connectorID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteConnectorRequest(
            connectorID: connectorID
        )
        return try await self.deleteConnector(input, logger: logger)
    }

    /// Deletes a single Job by ID.
    @Sendable
    @inlinable
    public func deleteJob(_ input: DeleteJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteJobResponse {
        try await self.client.execute(
            operation: "DeleteJob", 
            path: "/DeleteJob", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Job by ID.
    ///
    /// Parameters:
    ///   - accountID: Request to delete Job from service by Account ID.
    ///   - jobID: Request to delete Job from service by Job ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJob(
        accountID: String? = nil,
        jobID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteJobResponse {
        let input = DeleteJobRequest(
            accountID: accountID, 
            jobID: jobID
        )
        return try await self.deleteJob(input, logger: logger)
    }

    /// Deletes a single Launch Configuration Template by ID.
    @Sendable
    @inlinable
    public func deleteLaunchConfigurationTemplate(_ input: DeleteLaunchConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLaunchConfigurationTemplateResponse {
        try await self.client.execute(
            operation: "DeleteLaunchConfigurationTemplate", 
            path: "/DeleteLaunchConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Launch Configuration Template by ID.
    ///
    /// Parameters:
    ///   - launchConfigurationTemplateID: ID of resource to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLaunchConfigurationTemplate(
        launchConfigurationTemplateID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLaunchConfigurationTemplateResponse {
        let input = DeleteLaunchConfigurationTemplateRequest(
            launchConfigurationTemplateID: launchConfigurationTemplateID
        )
        return try await self.deleteLaunchConfigurationTemplate(input, logger: logger)
    }

    /// Deletes a single Replication Configuration Template by ID
    @Sendable
    @inlinable
    public func deleteReplicationConfigurationTemplate(_ input: DeleteReplicationConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationConfigurationTemplateResponse {
        try await self.client.execute(
            operation: "DeleteReplicationConfigurationTemplate", 
            path: "/DeleteReplicationConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single Replication Configuration Template by ID
    ///
    /// Parameters:
    ///   - replicationConfigurationTemplateID: Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReplicationConfigurationTemplate(
        replicationConfigurationTemplateID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReplicationConfigurationTemplateResponse {
        let input = DeleteReplicationConfigurationTemplateRequest(
            replicationConfigurationTemplateID: replicationConfigurationTemplateID
        )
        return try await self.deleteReplicationConfigurationTemplate(input, logger: logger)
    }

    /// Deletes a single source server by ID.
    @Sendable
    @inlinable
    public func deleteSourceServer(_ input: DeleteSourceServerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSourceServerResponse {
        try await self.client.execute(
            operation: "DeleteSourceServer", 
            path: "/DeleteSourceServer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a single source server by ID.
    ///
    /// Parameters:
    ///   - accountID: Request to delete Source Server from service by Account ID.
    ///   - sourceServerID: Request to delete Source Server from service by Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSourceServer(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSourceServerResponse {
        let input = DeleteSourceServerRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.deleteSourceServer(input, logger: logger)
    }

    /// Deletes a given vCenter client by ID.
    @Sendable
    @inlinable
    public func deleteVcenterClient(_ input: DeleteVcenterClientRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteVcenterClient", 
            path: "/DeleteVcenterClient", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a given vCenter client by ID.
    ///
    /// Parameters:
    ///   - vcenterClientID: ID of resource to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVcenterClient(
        vcenterClientID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteVcenterClientRequest(
            vcenterClientID: vcenterClientID
        )
        return try await self.deleteVcenterClient(input, logger: logger)
    }

    /// Delete wave.
    @Sendable
    @inlinable
    public func deleteWave(_ input: DeleteWaveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWaveResponse {
        try await self.client.execute(
            operation: "DeleteWave", 
            path: "/DeleteWave", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - waveID: Wave ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWave(
        accountID: String? = nil,
        waveID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWaveResponse {
        let input = DeleteWaveRequest(
            accountID: accountID, 
            waveID: waveID
        )
        return try await self.deleteWave(input, logger: logger)
    }

    /// Retrieves detailed job log items with paging.
    @Sendable
    @inlinable
    public func describeJobLogItems(_ input: DescribeJobLogItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobLogItemsResponse {
        try await self.client.execute(
            operation: "DescribeJobLogItems", 
            path: "/DescribeJobLogItems", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves detailed job log items with paging.
    ///
    /// Parameters:
    ///   - accountID: Request to describe Job log Account ID.
    ///   - jobID: Request to describe Job log job ID.
    ///   - maxResults: Request to describe Job log item maximum results.
    ///   - nextToken: Request to describe Job log next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobLogItems(
        accountID: String? = nil,
        jobID: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobLogItemsResponse {
        let input = DescribeJobLogItemsRequest(
            accountID: accountID, 
            jobID: jobID, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeJobLogItems(input, logger: logger)
    }

    /// Returns a list of Jobs. Use the JobsID and fromDate and toData filters to limit which jobs are returned. The response is sorted by creationDataTime - latest date first. Jobs are normally created by the StartTest, StartCutover, and TerminateTargetInstances APIs. Jobs are also created by DiagnosticLaunch and TerminateDiagnosticInstances, which are APIs available only to *Support* and only used in response to relevant support tickets.
    @Sendable
    @inlinable
    public func describeJobs(_ input: DescribeJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobsResponse {
        try await self.client.execute(
            operation: "DescribeJobs", 
            path: "/DescribeJobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of Jobs. Use the JobsID and fromDate and toData filters to limit which jobs are returned. The response is sorted by creationDataTime - latest date first. Jobs are normally created by the StartTest, StartCutover, and TerminateTargetInstances APIs. Jobs are also created by DiagnosticLaunch and TerminateDiagnosticInstances, which are APIs available only to *Support* and only used in response to relevant support tickets.
    ///
    /// Parameters:
    ///   - accountID: Request to describe job log items by Account ID.
    ///   - filters: Request to describe Job log filters.
    ///   - maxResults: Request to describe job log items by max results.
    ///   - nextToken: Request to describe job log items by next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobs(
        accountID: String? = nil,
        filters: DescribeJobsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobsResponse {
        let input = DescribeJobsRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeJobs(input, logger: logger)
    }

    /// Lists all Launch Configuration Templates, filtered by Launch Configuration Template IDs
    @Sendable
    @inlinable
    public func describeLaunchConfigurationTemplates(_ input: DescribeLaunchConfigurationTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLaunchConfigurationTemplatesResponse {
        try await self.client.execute(
            operation: "DescribeLaunchConfigurationTemplates", 
            path: "/DescribeLaunchConfigurationTemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Launch Configuration Templates, filtered by Launch Configuration Template IDs
    ///
    /// Parameters:
    ///   - launchConfigurationTemplateIDs: Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    ///   - maxResults: Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    ///   - nextToken: Next pagination token returned from DescribeLaunchConfigurationTemplates.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLaunchConfigurationTemplates(
        launchConfigurationTemplateIDs: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLaunchConfigurationTemplatesResponse {
        let input = DescribeLaunchConfigurationTemplatesRequest(
            launchConfigurationTemplateIDs: launchConfigurationTemplateIDs, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeLaunchConfigurationTemplates(input, logger: logger)
    }

    /// Lists all ReplicationConfigurationTemplates, filtered by Source Server IDs.
    @Sendable
    @inlinable
    public func describeReplicationConfigurationTemplates(_ input: DescribeReplicationConfigurationTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationConfigurationTemplatesResponse {
        try await self.client.execute(
            operation: "DescribeReplicationConfigurationTemplates", 
            path: "/DescribeReplicationConfigurationTemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all ReplicationConfigurationTemplates, filtered by Source Server IDs.
    ///
    /// Parameters:
    ///   - maxResults: Request to describe Replication Configuration template by max results.
    ///   - nextToken: Request to describe Replication Configuration template by next token.
    ///   - replicationConfigurationTemplateIDs: Request to describe Replication Configuration template by template IDs.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeReplicationConfigurationTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicationConfigurationTemplateIDs: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeReplicationConfigurationTemplatesResponse {
        let input = DescribeReplicationConfigurationTemplatesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicationConfigurationTemplateIDs: replicationConfigurationTemplateIDs
        )
        return try await self.describeReplicationConfigurationTemplates(input, logger: logger)
    }

    /// Retrieves all SourceServers or multiple SourceServers by ID.
    @Sendable
    @inlinable
    public func describeSourceServers(_ input: DescribeSourceServersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSourceServersResponse {
        try await self.client.execute(
            operation: "DescribeSourceServers", 
            path: "/DescribeSourceServers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all SourceServers or multiple SourceServers by ID.
    ///
    /// Parameters:
    ///   - accountID: Request to filter Source Servers list by Accoun ID.
    ///   - filters: Request to filter Source Servers list.
    ///   - maxResults: Request to filter Source Servers list by maximum results.
    ///   - nextToken: Request to filter Source Servers list by next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSourceServers(
        accountID: String? = nil,
        filters: DescribeSourceServersRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSourceServersResponse {
        let input = DescribeSourceServersRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeSourceServers(input, logger: logger)
    }

    /// Returns a list of the installed vCenter clients.
    @Sendable
    @inlinable
    public func describeVcenterClients(_ input: DescribeVcenterClientsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVcenterClientsResponse {
        try await self.client.execute(
            operation: "DescribeVcenterClients", 
            path: "/DescribeVcenterClients", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the installed vCenter clients.
    ///
    /// Parameters:
    ///   - maxResults: Maximum results to be returned in DescribeVcenterClients.
    ///   - nextToken: Next pagination token to be provided for DescribeVcenterClients.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVcenterClients(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVcenterClientsResponse {
        let input = DescribeVcenterClientsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeVcenterClients(input, logger: logger)
    }

    /// Disassociate applications from wave.
    @Sendable
    @inlinable
    public func disassociateApplications(_ input: DisassociateApplicationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateApplicationsResponse {
        try await self.client.execute(
            operation: "DisassociateApplications", 
            path: "/DisassociateApplications", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociate applications from wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationIDs: Application IDs list.
    ///   - waveID: Wave ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateApplications(
        accountID: String? = nil,
        applicationIDs: [String],
        waveID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateApplicationsResponse {
        let input = DisassociateApplicationsRequest(
            accountID: accountID, 
            applicationIDs: applicationIDs, 
            waveID: waveID
        )
        return try await self.disassociateApplications(input, logger: logger)
    }

    /// Disassociate source servers from application.
    @Sendable
    @inlinable
    public func disassociateSourceServers(_ input: DisassociateSourceServersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateSourceServersResponse {
        try await self.client.execute(
            operation: "DisassociateSourceServers", 
            path: "/DisassociateSourceServers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociate source servers from application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationID: Application ID.
    ///   - sourceServerIDs: Source server IDs list.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateSourceServers(
        accountID: String? = nil,
        applicationID: String,
        sourceServerIDs: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateSourceServersResponse {
        let input = DisassociateSourceServersRequest(
            accountID: accountID, 
            applicationID: applicationID, 
            sourceServerIDs: sourceServerIDs
        )
        return try await self.disassociateSourceServers(input, logger: logger)
    }

    /// Disconnects specific Source Servers from Application Migration Service. Data replication is stopped immediately. All AWS resources created by Application Migration Service for enabling the replication of these source servers will be terminated / deleted within 90 minutes. Launched Test or Cutover instances will NOT be terminated. If the agent on the source server has not been prevented from communicating with the Application Migration Service service, then it will receive a command to uninstall itself (within approximately 10 minutes). The following properties of the SourceServer will be changed immediately: dataReplicationInfo.dataReplicationState will be set to DISCONNECTED; The totalStorageBytes property for each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    @Sendable
    @inlinable
    public func disconnectFromService(_ input: DisconnectFromServiceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "DisconnectFromService", 
            path: "/DisconnectFromService", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disconnects specific Source Servers from Application Migration Service. Data replication is stopped immediately. All AWS resources created by Application Migration Service for enabling the replication of these source servers will be terminated / deleted within 90 minutes. Launched Test or Cutover instances will NOT be terminated. If the agent on the source server has not been prevented from communicating with the Application Migration Service service, then it will receive a command to uninstall itself (within approximately 10 minutes). The following properties of the SourceServer will be changed immediately: dataReplicationInfo.dataReplicationState will be set to DISCONNECTED; The totalStorageBytes property for each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    ///
    /// Parameters:
    ///   - accountID: Request to disconnect Source Server from service by Account ID.
    ///   - sourceServerID: Request to disconnect Source Server from service by Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func disconnectFromService(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = DisconnectFromServiceRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.disconnectFromService(input, logger: logger)
    }

    /// Finalizes the cutover immediately for specific Source Servers. All AWS resources created by Application Migration Service for enabling the replication of these source servers will be terminated / deleted within 90 minutes. Launched Test or Cutover instances will NOT be terminated. The AWS Replication Agent will receive a command to uninstall itself (within 10 minutes). The following properties of the SourceServer will be changed immediately: dataReplicationInfo.dataReplicationState will be changed to DISCONNECTED; The SourceServer.lifeCycle.state will be changed to CUTOVER; The totalStorageBytes property fo each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    @Sendable
    @inlinable
    public func finalizeCutover(_ input: FinalizeCutoverRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "FinalizeCutover", 
            path: "/FinalizeCutover", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Finalizes the cutover immediately for specific Source Servers. All AWS resources created by Application Migration Service for enabling the replication of these source servers will be terminated / deleted within 90 minutes. Launched Test or Cutover instances will NOT be terminated. The AWS Replication Agent will receive a command to uninstall itself (within 10 minutes). The following properties of the SourceServer will be changed immediately: dataReplicationInfo.dataReplicationState will be changed to DISCONNECTED; The SourceServer.lifeCycle.state will be changed to CUTOVER; The totalStorageBytes property fo each of dataReplicationInfo.replicatedDisks will be set to zero; dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will be nullified.
    ///
    /// Parameters:
    ///   - accountID: Request to finalize Cutover by Source Account ID.
    ///   - sourceServerID: Request to finalize Cutover by Source Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func finalizeCutover(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = FinalizeCutoverRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.finalizeCutover(input, logger: logger)
    }

    /// Lists all LaunchConfigurations available, filtered by Source Server IDs.
    @Sendable
    @inlinable
    public func getLaunchConfiguration(_ input: GetLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchConfiguration {
        try await self.client.execute(
            operation: "GetLaunchConfiguration", 
            path: "/GetLaunchConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all LaunchConfigurations available, filtered by Source Server IDs.
    ///
    /// Parameters:
    ///   - accountID: Request to get Launch Configuration information by Account ID.
    ///   - sourceServerID: Request to get Launch Configuration information by Source Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLaunchConfiguration(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchConfiguration {
        let input = GetLaunchConfigurationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.getLaunchConfiguration(input, logger: logger)
    }

    /// Lists all ReplicationConfigurations, filtered by Source Server ID.
    @Sendable
    @inlinable
    public func getReplicationConfiguration(_ input: GetReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfiguration {
        try await self.client.execute(
            operation: "GetReplicationConfiguration", 
            path: "/GetReplicationConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all ReplicationConfigurations, filtered by Source Server ID.
    ///
    /// Parameters:
    ///   - accountID: Request to get Replication Configuration by Account ID.
    ///   - sourceServerID: Request to get Replication Configuration by Source Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReplicationConfiguration(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfiguration {
        let input = GetReplicationConfigurationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.getReplicationConfiguration(input, logger: logger)
    }

    /// Initialize Application Migration Service.
    @Sendable
    @inlinable
    public func initializeService(_ input: InitializeServiceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> InitializeServiceResponse {
        try await self.client.execute(
            operation: "InitializeService", 
            path: "/InitializeService", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initialize Application Migration Service.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func initializeService(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> InitializeServiceResponse {
        let input = InitializeServiceRequest(
        )
        return try await self.initializeService(input, logger: logger)
    }

    /// Retrieves all applications or multiple applications by ID.
    @Sendable
    @inlinable
    public func listApplications(_ input: ListApplicationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApplicationsResponse {
        try await self.client.execute(
            operation: "ListApplications", 
            path: "/ListApplications", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all applications or multiple applications by ID.
    ///
    /// Parameters:
    ///   - accountID: Applications list Account ID.
    ///   - filters: Applications list filters.
    ///   - maxResults: Maximum results to return when listing applications.
    ///   - nextToken: Request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApplications(
        accountID: String? = nil,
        filters: ListApplicationsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApplicationsResponse {
        let input = ListApplicationsRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listApplications(input, logger: logger)
    }

    /// List Connectors.
    @Sendable
    @inlinable
    public func listConnectors(_ input: ListConnectorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConnectorsResponse {
        try await self.client.execute(
            operation: "ListConnectors", 
            path: "/ListConnectors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List Connectors.
    ///
    /// Parameters:
    ///   - filters: List Connectors Request filters.
    ///   - maxResults: List Connectors Request max results.
    ///   - nextToken: List Connectors Request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConnectors(
        filters: ListConnectorsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConnectorsResponse {
        let input = ListConnectorsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConnectors(input, logger: logger)
    }

    /// List export errors.
    @Sendable
    @inlinable
    public func listExportErrors(_ input: ListExportErrorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListExportErrorsResponse {
        try await self.client.execute(
            operation: "ListExportErrors", 
            path: "/ListExportErrors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List export errors.
    ///
    /// Parameters:
    ///   - exportID: List export errors request export id.
    ///   - maxResults: List export errors request max results.
    ///   - nextToken: List export errors request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listExportErrors(
        exportID: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListExportErrorsResponse {
        let input = ListExportErrorsRequest(
            exportID: exportID, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listExportErrors(input, logger: logger)
    }

    /// List exports.
    @Sendable
    @inlinable
    public func listExports(_ input: ListExportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListExportsResponse {
        try await self.client.execute(
            operation: "ListExports", 
            path: "/ListExports", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List exports.
    ///
    /// Parameters:
    ///   - filters: 
    ///   - maxResults: List export request max results.
    ///   - nextToken: List export request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listExports(
        filters: ListExportsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListExportsResponse {
        let input = ListExportsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listExports(input, logger: logger)
    }

    /// List import errors.
    @Sendable
    @inlinable
    public func listImportErrors(_ input: ListImportErrorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImportErrorsResponse {
        try await self.client.execute(
            operation: "ListImportErrors", 
            path: "/ListImportErrors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List import errors.
    ///
    /// Parameters:
    ///   - importID: List import errors request import id.
    ///   - maxResults: List import errors request max results.
    ///   - nextToken: List import errors request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listImportErrors(
        importID: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImportErrorsResponse {
        let input = ListImportErrorsRequest(
            importID: importID, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImportErrors(input, logger: logger)
    }

    /// List imports.
    @Sendable
    @inlinable
    public func listImports(_ input: ListImportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImportsResponse {
        try await self.client.execute(
            operation: "ListImports", 
            path: "/ListImports", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List imports.
    ///
    /// Parameters:
    ///   - filters: List imports request filters.
    ///   - maxResults: List imports request max results.
    ///   - nextToken: List imports request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listImports(
        filters: ListImportsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImportsResponse {
        let input = ListImportsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImports(input, logger: logger)
    }

    /// List Managed Accounts.
    @Sendable
    @inlinable
    public func listManagedAccounts(_ input: ListManagedAccountsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListManagedAccountsResponse {
        try await self.client.execute(
            operation: "ListManagedAccounts", 
            path: "/ListManagedAccounts", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List Managed Accounts.
    ///
    /// Parameters:
    ///   - maxResults: List managed accounts request max results.
    ///   - nextToken: List managed accounts request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listManagedAccounts(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListManagedAccountsResponse {
        let input = ListManagedAccountsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listManagedAccounts(input, logger: logger)
    }

    /// List source server post migration custom actions.
    @Sendable
    @inlinable
    public func listSourceServerActions(_ input: ListSourceServerActionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSourceServerActionsResponse {
        try await self.client.execute(
            operation: "ListSourceServerActions", 
            path: "/ListSourceServerActions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List source server post migration custom actions.
    ///
    /// Parameters:
    ///   - accountID: Account ID to return when listing source server post migration custom actions.
    ///   - filters: Filters to apply when listing source server post migration custom actions.
    ///   - maxResults: Maximum amount of items to return when listing source server post migration custom actions.
    ///   - nextToken: Next token to use when listing source server post migration custom actions.
    ///   - sourceServerID: Source server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSourceServerActions(
        accountID: String? = nil,
        filters: SourceServerActionsRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSourceServerActionsResponse {
        let input = ListSourceServerActionsRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sourceServerID: sourceServerID
        )
        return try await self.listSourceServerActions(input, logger: logger)
    }

    /// List all tags for your Application Migration Service resources.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all tags for your Application Migration Service resources.
    ///
    /// Parameters:
    ///   - resourceArn: List tags for resource request by ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// List template post migration custom actions.
    @Sendable
    @inlinable
    public func listTemplateActions(_ input: ListTemplateActionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTemplateActionsResponse {
        try await self.client.execute(
            operation: "ListTemplateActions", 
            path: "/ListTemplateActions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List template post migration custom actions.
    ///
    /// Parameters:
    ///   - filters: Filters to apply when listing template post migration custom actions.
    ///   - launchConfigurationTemplateID: Launch configuration template ID.
    ///   - maxResults: Maximum amount of items to return when listing template post migration custom actions.
    ///   - nextToken: Next token to use when listing template post migration custom actions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTemplateActions(
        filters: TemplateActionsRequestFilters? = nil,
        launchConfigurationTemplateID: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTemplateActionsResponse {
        let input = ListTemplateActionsRequest(
            filters: filters, 
            launchConfigurationTemplateID: launchConfigurationTemplateID, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listTemplateActions(input, logger: logger)
    }

    /// Retrieves all waves or multiple waves by ID.
    @Sendable
    @inlinable
    public func listWaves(_ input: ListWavesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWavesResponse {
        try await self.client.execute(
            operation: "ListWaves", 
            path: "/ListWaves", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all waves or multiple waves by ID.
    ///
    /// Parameters:
    ///   - accountID: Request account ID.
    ///   - filters: Waves list filters.
    ///   - maxResults: Maximum results to return when listing waves.
    ///   - nextToken: Request next token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWaves(
        accountID: String? = nil,
        filters: ListWavesRequestFilters? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWavesResponse {
        let input = ListWavesRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWaves(input, logger: logger)
    }

    /// Archives specific Source Servers by setting the SourceServer.isArchived property to true for specified SourceServers by ID. This command only works for SourceServers with a lifecycle. state which equals DISCONNECTED or CUTOVER.
    @Sendable
    @inlinable
    public func markAsArchived(_ input: MarkAsArchivedRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "MarkAsArchived", 
            path: "/MarkAsArchived", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Archives specific Source Servers by setting the SourceServer.isArchived property to true for specified SourceServers by ID. This command only works for SourceServers with a lifecycle. state which equals DISCONNECTED or CUTOVER.
    ///
    /// Parameters:
    ///   - accountID: Mark as archived by Account ID.
    ///   - sourceServerID: Mark as archived by Source Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func markAsArchived(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = MarkAsArchivedRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.markAsArchived(input, logger: logger)
    }

    /// Pause Replication.
    @Sendable
    @inlinable
    public func pauseReplication(_ input: PauseReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "PauseReplication", 
            path: "/PauseReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Pause Replication.
    ///
    /// Parameters:
    ///   - accountID: Pause Replication Request account ID.
    ///   - sourceServerID: Pause Replication Request source server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func pauseReplication(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = PauseReplicationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.pauseReplication(input, logger: logger)
    }

    /// Put source server post migration custom action.
    @Sendable
    @inlinable
    public func putSourceServerAction(_ input: PutSourceServerActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServerActionDocument {
        try await self.client.execute(
            operation: "PutSourceServerAction", 
            path: "/PutSourceServerAction", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Put source server post migration custom action.
    ///
    /// Parameters:
    ///   - accountID: Source server post migration custom account ID.
    ///   - actionID: Source server post migration custom action ID.
    ///   - actionName: Source server post migration custom action name.
    ///   - active: Source server post migration custom action active status.
    ///   - category: Source server post migration custom action category.
    ///   - description: Source server post migration custom action description.
    ///   - documentIdentifier: Source server post migration custom action document identifier.
    ///   - documentVersion: Source server post migration custom action document version.
    ///   - externalParameters: Source server post migration custom action external parameters.
    ///   - mustSucceedForCutover: Source server post migration custom action must succeed for cutover.
    ///   - order: Source server post migration custom action order.
    ///   - parameters: Source server post migration custom action parameters.
    ///   - sourceServerID: Source server ID.
    ///   - timeoutSeconds: Source server post migration custom action timeout in seconds.
    ///   - logger: Logger use during operation
    @inlinable
    public func putSourceServerAction(
        accountID: String? = nil,
        actionID: String,
        actionName: String,
        active: Bool? = nil,
        category: ActionCategory? = nil,
        description: String? = nil,
        documentIdentifier: String,
        documentVersion: String? = nil,
        externalParameters: [String: SsmExternalParameter]? = nil,
        mustSucceedForCutover: Bool? = nil,
        order: Int,
        parameters: [String: [SsmParameterStoreParameter]]? = nil,
        sourceServerID: String,
        timeoutSeconds: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServerActionDocument {
        let input = PutSourceServerActionRequest(
            accountID: accountID, 
            actionID: actionID, 
            actionName: actionName, 
            active: active, 
            category: category, 
            description: description, 
            documentIdentifier: documentIdentifier, 
            documentVersion: documentVersion, 
            externalParameters: externalParameters, 
            mustSucceedForCutover: mustSucceedForCutover, 
            order: order, 
            parameters: parameters, 
            sourceServerID: sourceServerID, 
            timeoutSeconds: timeoutSeconds
        )
        return try await self.putSourceServerAction(input, logger: logger)
    }

    /// Put template post migration custom action.
    @Sendable
    @inlinable
    public func putTemplateAction(_ input: PutTemplateActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TemplateActionDocument {
        try await self.client.execute(
            operation: "PutTemplateAction", 
            path: "/PutTemplateAction", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Put template post migration custom action.
    ///
    /// Parameters:
    ///   - actionID: Template post migration custom action ID.
    ///   - actionName: Template post migration custom action name.
    ///   - active: Template post migration custom action active status.
    ///   - category: Template post migration custom action category.
    ///   - description: Template post migration custom action description.
    ///   - documentIdentifier: Template post migration custom action document identifier.
    ///   - documentVersion: Template post migration custom action document version.
    ///   - externalParameters: Template post migration custom action external parameters.
    ///   - launchConfigurationTemplateID: Launch configuration template ID.
    ///   - mustSucceedForCutover: Template post migration custom action must succeed for cutover.
    ///   - operatingSystem: Operating system eligible for this template post migration custom action.
    ///   - order: Template post migration custom action order.
    ///   - parameters: Template post migration custom action parameters.
    ///   - timeoutSeconds: Template post migration custom action timeout in seconds.
    ///   - logger: Logger use during operation
    @inlinable
    public func putTemplateAction(
        actionID: String,
        actionName: String,
        active: Bool? = nil,
        category: ActionCategory? = nil,
        description: String? = nil,
        documentIdentifier: String,
        documentVersion: String? = nil,
        externalParameters: [String: SsmExternalParameter]? = nil,
        launchConfigurationTemplateID: String,
        mustSucceedForCutover: Bool? = nil,
        operatingSystem: String? = nil,
        order: Int,
        parameters: [String: [SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TemplateActionDocument {
        let input = PutTemplateActionRequest(
            actionID: actionID, 
            actionName: actionName, 
            active: active, 
            category: category, 
            description: description, 
            documentIdentifier: documentIdentifier, 
            documentVersion: documentVersion, 
            externalParameters: externalParameters, 
            launchConfigurationTemplateID: launchConfigurationTemplateID, 
            mustSucceedForCutover: mustSucceedForCutover, 
            operatingSystem: operatingSystem, 
            order: order, 
            parameters: parameters, 
            timeoutSeconds: timeoutSeconds
        )
        return try await self.putTemplateAction(input, logger: logger)
    }

    /// Remove source server post migration custom action.
    @Sendable
    @inlinable
    public func removeSourceServerAction(_ input: RemoveSourceServerActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveSourceServerActionResponse {
        try await self.client.execute(
            operation: "RemoveSourceServerAction", 
            path: "/RemoveSourceServerAction", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Remove source server post migration custom action.
    ///
    /// Parameters:
    ///   - accountID: Source server post migration account ID.
    ///   - actionID: Source server post migration custom action ID to remove.
    ///   - sourceServerID: Source server ID of the post migration custom action to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func removeSourceServerAction(
        accountID: String? = nil,
        actionID: String,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RemoveSourceServerActionResponse {
        let input = RemoveSourceServerActionRequest(
            accountID: accountID, 
            actionID: actionID, 
            sourceServerID: sourceServerID
        )
        return try await self.removeSourceServerAction(input, logger: logger)
    }

    /// Remove template post migration custom action.
    @Sendable
    @inlinable
    public func removeTemplateAction(_ input: RemoveTemplateActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveTemplateActionResponse {
        try await self.client.execute(
            operation: "RemoveTemplateAction", 
            path: "/RemoveTemplateAction", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Remove template post migration custom action.
    ///
    /// Parameters:
    ///   - actionID: Template post migration custom action ID to remove.
    ///   - launchConfigurationTemplateID: Launch configuration template ID of the post migration custom action to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func removeTemplateAction(
        actionID: String,
        launchConfigurationTemplateID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RemoveTemplateActionResponse {
        let input = RemoveTemplateActionRequest(
            actionID: actionID, 
            launchConfigurationTemplateID: launchConfigurationTemplateID
        )
        return try await self.removeTemplateAction(input, logger: logger)
    }

    /// Resume Replication.
    @Sendable
    @inlinable
    public func resumeReplication(_ input: ResumeReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "ResumeReplication", 
            path: "/ResumeReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Resume Replication.
    ///
    /// Parameters:
    ///   - accountID: Resume Replication Request account ID.
    ///   - sourceServerID: Resume Replication Request source server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func resumeReplication(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = ResumeReplicationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.resumeReplication(input, logger: logger)
    }

    /// Causes the data replication initiation sequence to begin immediately upon next Handshake for specified SourceServer IDs, regardless of when the previous initiation started. This command will not work if the SourceServer is not stalled or is in a DISCONNECTED or STOPPED state.
    @Sendable
    @inlinable
    public func retryDataReplication(_ input: RetryDataReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "RetryDataReplication", 
            path: "/RetryDataReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Causes the data replication initiation sequence to begin immediately upon next Handshake for specified SourceServer IDs, regardless of when the previous initiation started. This command will not work if the SourceServer is not stalled or is in a DISCONNECTED or STOPPED state.
    ///
    /// Parameters:
    ///   - accountID: Retry data replication for Account ID.
    ///   - sourceServerID: Retry data replication for Source Server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func retryDataReplication(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = RetryDataReplicationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.retryDataReplication(input, logger: logger)
    }

    /// Launches a Cutover Instance for specific Source Servers. This command starts a LAUNCH job whose initiatedBy property is StartCutover and changes the SourceServer.lifeCycle.state property to CUTTING_OVER.
    @Sendable
    @inlinable
    public func startCutover(_ input: StartCutoverRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartCutoverResponse {
        try await self.client.execute(
            operation: "StartCutover", 
            path: "/StartCutover", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Launches a Cutover Instance for specific Source Servers. This command starts a LAUNCH job whose initiatedBy property is StartCutover and changes the SourceServer.lifeCycle.state property to CUTTING_OVER.
    ///
    /// Parameters:
    ///   - accountID: Start Cutover by Account IDs
    ///   - sourceServerIDs: Start Cutover by Source Server IDs.
    ///   - tags: Start Cutover by Tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func startCutover(
        accountID: String? = nil,
        sourceServerIDs: [String],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartCutoverResponse {
        let input = StartCutoverRequest(
            accountID: accountID, 
            sourceServerIDs: sourceServerIDs, 
            tags: tags
        )
        return try await self.startCutover(input, logger: logger)
    }

    /// Start export.
    @Sendable
    @inlinable
    public func startExport(_ input: StartExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartExportResponse {
        try await self.client.execute(
            operation: "StartExport", 
            path: "/StartExport", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start export.
    ///
    /// Parameters:
    ///   - s3Bucket: Start export request s3 bucket.
    ///   - s3BucketOwner: Start export request s3 bucket owner.
    ///   - s3Key: Start export request s3key.
    ///   - logger: Logger use during operation
    @inlinable
    public func startExport(
        s3Bucket: String,
        s3BucketOwner: String? = nil,
        s3Key: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartExportResponse {
        let input = StartExportRequest(
            s3Bucket: s3Bucket, 
            s3BucketOwner: s3BucketOwner, 
            s3Key: s3Key
        )
        return try await self.startExport(input, logger: logger)
    }

    /// Start import.
    @Sendable
    @inlinable
    public func startImport(_ input: StartImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImportResponse {
        try await self.client.execute(
            operation: "StartImport", 
            path: "/StartImport", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start import.
    ///
    /// Parameters:
    ///   - clientToken: Start import request client token.
    ///   - s3BucketSource: Start import request s3 bucket source.
    ///   - logger: Logger use during operation
    @inlinable
    public func startImport(
        clientToken: String? = StartImportRequest.idempotencyToken(),
        s3BucketSource: S3BucketSource,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartImportResponse {
        let input = StartImportRequest(
            clientToken: clientToken, 
            s3BucketSource: s3BucketSource
        )
        return try await self.startImport(input, logger: logger)
    }

    /// Starts replication for SNAPSHOT_SHIPPING agents.
    @Sendable
    @inlinable
    public func startReplication(_ input: StartReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "StartReplication", 
            path: "/StartReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts replication for SNAPSHOT_SHIPPING agents.
    ///
    /// Parameters:
    ///   - accountID: Account ID on which to start replication.
    ///   - sourceServerID: ID of source server on which to start replication.
    ///   - logger: Logger use during operation
    @inlinable
    public func startReplication(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = StartReplicationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.startReplication(input, logger: logger)
    }

    /// Launches a Test Instance for specific Source Servers. This command starts a LAUNCH job whose initiatedBy property is StartTest and changes the SourceServer.lifeCycle.state property to TESTING.
    @Sendable
    @inlinable
    public func startTest(_ input: StartTestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartTestResponse {
        try await self.client.execute(
            operation: "StartTest", 
            path: "/StartTest", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Launches a Test Instance for specific Source Servers. This command starts a LAUNCH job whose initiatedBy property is StartTest and changes the SourceServer.lifeCycle.state property to TESTING.
    ///
    /// Parameters:
    ///   - accountID: Start Test for Account ID.
    ///   - sourceServerIDs: Start Test for Source Server IDs.
    ///   - tags: Start Test by Tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func startTest(
        accountID: String? = nil,
        sourceServerIDs: [String],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartTestResponse {
        let input = StartTestRequest(
            accountID: accountID, 
            sourceServerIDs: sourceServerIDs, 
            tags: tags
        )
        return try await self.startTest(input, logger: logger)
    }

    /// Stop Replication.
    @Sendable
    @inlinable
    public func stopReplication(_ input: StopReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "StopReplication", 
            path: "/StopReplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stop Replication.
    ///
    /// Parameters:
    ///   - accountID: Stop Replication Request account ID.
    ///   - sourceServerID: Stop Replication Request source server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopReplication(
        accountID: String? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = StopReplicationRequest(
            accountID: accountID, 
            sourceServerID: sourceServerID
        )
        return try await self.stopReplication(input, logger: logger)
    }

    /// Adds or overwrites only the specified tags for the specified Application Migration Service resource or resources. When you specify an existing tag key, the value is overwritten with the new value. Each resource can have a maximum of 50 tags. Each tag consists of a key and optional value.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds or overwrites only the specified tags for the specified Application Migration Service resource or resources. When you specify an existing tag key, the value is overwritten with the new value. Each resource can have a maximum of 50 tags. Each tag consists of a key and optional value.
    ///
    /// Parameters:
    ///   - resourceArn: Tag resource by ARN.
    ///   - tags: Tag resource by Tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Starts a job that terminates specific launched EC2 Test and Cutover instances. This command will not work for any Source Server with a lifecycle.state of TESTING, CUTTING_OVER, or CUTOVER.
    @Sendable
    @inlinable
    public func terminateTargetInstances(_ input: TerminateTargetInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TerminateTargetInstancesResponse {
        try await self.client.execute(
            operation: "TerminateTargetInstances", 
            path: "/TerminateTargetInstances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a job that terminates specific launched EC2 Test and Cutover instances. This command will not work for any Source Server with a lifecycle.state of TESTING, CUTTING_OVER, or CUTOVER.
    ///
    /// Parameters:
    ///   - accountID: Terminate Target instance by Account ID
    ///   - sourceServerIDs: Terminate Target instance by Source Server IDs.
    ///   - tags: Terminate Target instance by Tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func terminateTargetInstances(
        accountID: String? = nil,
        sourceServerIDs: [String],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TerminateTargetInstancesResponse {
        let input = TerminateTargetInstancesRequest(
            accountID: accountID, 
            sourceServerIDs: sourceServerIDs, 
            tags: tags
        )
        return try await self.terminateTargetInstances(input, logger: logger)
    }

    /// Unarchive application.
    @Sendable
    @inlinable
    public func unarchiveApplication(_ input: UnarchiveApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Application {
        try await self.client.execute(
            operation: "UnarchiveApplication", 
            path: "/UnarchiveApplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Unarchive application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationID: Application ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func unarchiveApplication(
        accountID: String? = nil,
        applicationID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Application {
        let input = UnarchiveApplicationRequest(
            accountID: accountID, 
            applicationID: applicationID
        )
        return try await self.unarchiveApplication(input, logger: logger)
    }

    /// Unarchive wave.
    @Sendable
    @inlinable
    public func unarchiveWave(_ input: UnarchiveWaveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Wave {
        try await self.client.execute(
            operation: "UnarchiveWave", 
            path: "/UnarchiveWave", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Unarchive wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - waveID: Wave ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func unarchiveWave(
        accountID: String? = nil,
        waveID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Wave {
        let input = UnarchiveWaveRequest(
            accountID: accountID, 
            waveID: waveID
        )
        return try await self.unarchiveWave(input, logger: logger)
    }

    /// Deletes the specified set of tags from the specified set of Application Migration Service resources.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified set of tags from the specified set of Application Migration Service resources.
    ///
    /// Parameters:
    ///   - resourceArn: Untag resource by ARN.
    ///   - tagKeys: Untag resource by Keys.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Update application.
    @Sendable
    @inlinable
    public func updateApplication(_ input: UpdateApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Application {
        try await self.client.execute(
            operation: "UpdateApplication", 
            path: "/UpdateApplication", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update application.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - applicationID: Application ID.
    ///   - description: Application description.
    ///   - name: Application name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateApplication(
        accountID: String? = nil,
        applicationID: String,
        description: String? = nil,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Application {
        let input = UpdateApplicationRequest(
            accountID: accountID, 
            applicationID: applicationID, 
            description: description, 
            name: name
        )
        return try await self.updateApplication(input, logger: logger)
    }

    /// Update Connector.
    @Sendable
    @inlinable
    public func updateConnector(_ input: UpdateConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Connector {
        try await self.client.execute(
            operation: "UpdateConnector", 
            path: "/UpdateConnector", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update Connector.
    ///
    /// Parameters:
    ///   - connectorID: Update Connector request connector ID.
    ///   - name: Update Connector request name.
    ///   - ssmCommandConfig: Update Connector request SSM command config.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConnector(
        connectorID: String,
        name: String? = nil,
        ssmCommandConfig: ConnectorSsmCommandConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Connector {
        let input = UpdateConnectorRequest(
            connectorID: connectorID, 
            name: name, 
            ssmCommandConfig: ssmCommandConfig
        )
        return try await self.updateConnector(input, logger: logger)
    }

    /// Updates multiple LaunchConfigurations by Source Server ID.  bootMode valid values are LEGACY_BIOS | UEFI
    @Sendable
    @inlinable
    public func updateLaunchConfiguration(_ input: UpdateLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchConfiguration {
        try await self.client.execute(
            operation: "UpdateLaunchConfiguration", 
            path: "/UpdateLaunchConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates multiple LaunchConfigurations by Source Server ID.  bootMode valid values are LEGACY_BIOS | UEFI
    ///
    /// Parameters:
    ///   - accountID: Update Launch configuration Account ID.
    ///   - bootMode: Update Launch configuration boot mode request.
    ///   - copyPrivateIp: Update Launch configuration copy Private IP request.
    ///   - copyTags: Update Launch configuration copy Tags request.
    ///   - enableMapAutoTagging: Enable map auto tagging.
    ///   - launchDisposition: Update Launch configuration launch disposition request.
    ///   - licensing: Update Launch configuration licensing request.
    ///   - mapAutoTaggingMpeID: Launch configuration map auto tagging MPE ID.
    ///   - name: Update Launch configuration name request.
    ///   - postLaunchActions: 
    ///   - sourceServerID: Update Launch configuration by Source Server ID request.
    ///   - targetInstanceTypeRightSizingMethod: Update Launch configuration Target instance right sizing request.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLaunchConfiguration(
        accountID: String? = nil,
        bootMode: BootMode? = nil,
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        enableMapAutoTagging: Bool? = nil,
        launchDisposition: LaunchDisposition? = nil,
        licensing: Licensing? = nil,
        mapAutoTaggingMpeID: String? = nil,
        name: String? = nil,
        postLaunchActions: PostLaunchActions? = nil,
        sourceServerID: String,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchConfiguration {
        let input = UpdateLaunchConfigurationRequest(
            accountID: accountID, 
            bootMode: bootMode, 
            copyPrivateIp: copyPrivateIp, 
            copyTags: copyTags, 
            enableMapAutoTagging: enableMapAutoTagging, 
            launchDisposition: launchDisposition, 
            licensing: licensing, 
            mapAutoTaggingMpeID: mapAutoTaggingMpeID, 
            name: name, 
            postLaunchActions: postLaunchActions, 
            sourceServerID: sourceServerID, 
            targetInstanceTypeRightSizingMethod: targetInstanceTypeRightSizingMethod
        )
        return try await self.updateLaunchConfiguration(input, logger: logger)
    }

    /// Updates an existing Launch Configuration Template by ID.
    @Sendable
    @inlinable
    public func updateLaunchConfigurationTemplate(_ input: UpdateLaunchConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchConfigurationTemplate {
        try await self.client.execute(
            operation: "UpdateLaunchConfigurationTemplate", 
            path: "/UpdateLaunchConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing Launch Configuration Template by ID.
    ///
    /// Parameters:
    ///   - associatePublicIpAddress: Associate public Ip address.
    ///   - bootMode: Launch configuration template boot mode.
    ///   - copyPrivateIp: Copy private Ip.
    ///   - copyTags: Copy tags.
    ///   - enableMapAutoTagging: Enable map auto tagging.
    ///   - largeVolumeConf: Large volume config.
    ///   - launchConfigurationTemplateID: Launch Configuration Template ID.
    ///   - launchDisposition: Launch disposition.
    ///   - licensing: 
    ///   - mapAutoTaggingMpeID: Launch configuration template map auto tagging MPE ID.
    ///   - postLaunchActions: Post Launch Action to execute on the Test or Cutover instance.
    ///   - smallVolumeConf: Small volume config.
    ///   - smallVolumeMaxSize: Small volume maximum size.
    ///   - targetInstanceTypeRightSizingMethod: Target instance type right-sizing method.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLaunchConfigurationTemplate(
        associatePublicIpAddress: Bool? = nil,
        bootMode: BootMode? = nil,
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        enableMapAutoTagging: Bool? = nil,
        largeVolumeConf: LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: String,
        launchDisposition: LaunchDisposition? = nil,
        licensing: Licensing? = nil,
        mapAutoTaggingMpeID: String? = nil,
        postLaunchActions: PostLaunchActions? = nil,
        smallVolumeConf: LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Int64? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchConfigurationTemplate {
        let input = UpdateLaunchConfigurationTemplateRequest(
            associatePublicIpAddress: associatePublicIpAddress, 
            bootMode: bootMode, 
            copyPrivateIp: copyPrivateIp, 
            copyTags: copyTags, 
            enableMapAutoTagging: enableMapAutoTagging, 
            largeVolumeConf: largeVolumeConf, 
            launchConfigurationTemplateID: launchConfigurationTemplateID, 
            launchDisposition: launchDisposition, 
            licensing: licensing, 
            mapAutoTaggingMpeID: mapAutoTaggingMpeID, 
            postLaunchActions: postLaunchActions, 
            smallVolumeConf: smallVolumeConf, 
            smallVolumeMaxSize: smallVolumeMaxSize, 
            targetInstanceTypeRightSizingMethod: targetInstanceTypeRightSizingMethod
        )
        return try await self.updateLaunchConfigurationTemplate(input, logger: logger)
    }

    /// Allows you to update multiple ReplicationConfigurations by Source Server ID.
    @Sendable
    @inlinable
    public func updateReplicationConfiguration(_ input: UpdateReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfiguration {
        try await self.client.execute(
            operation: "UpdateReplicationConfiguration", 
            path: "/UpdateReplicationConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows you to update multiple ReplicationConfigurations by Source Server ID.
    ///
    /// Parameters:
    ///   - accountID: Update replication configuration Account ID request.
    ///   - associateDefaultSecurityGroup: Update replication configuration associate default Application Migration Service Security group request.
    ///   - bandwidthThrottling: Update replication configuration bandwidth throttling request.
    ///   - createPublicIP: Update replication configuration create Public IP request.
    ///   - dataPlaneRouting: Update replication configuration data plane routing request.
    ///   - defaultLargeStagingDiskType: Update replication configuration use default large Staging Disk type request.
    ///   - ebsEncryption: Update replication configuration EBS encryption request.
    ///   - ebsEncryptionKeyArn: Update replication configuration EBS encryption key ARN request.
    ///   - name: Update replication configuration name request.
    ///   - replicatedDisks: Update replication configuration replicated disks request.
    ///   - replicationServerInstanceType: Update replication configuration Replication Server instance type request.
    ///   - replicationServersSecurityGroupsIDs: Update replication configuration Replication Server Security Groups IDs request.
    ///   - sourceServerID: Update replication configuration Source Server ID request.
    ///   - stagingAreaSubnetId: Update replication configuration Staging Area subnet request.
    ///   - stagingAreaTags: Update replication configuration Staging Area Tags request.
    ///   - useDedicatedReplicationServer: Update replication configuration use dedicated Replication Server request.
    ///   - useFipsEndpoint: Update replication configuration use Fips Endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationConfiguration(
        accountID: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int64? = nil,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        name: String? = nil,
        replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        sourceServerID: String,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String: String]? = nil,
        useDedicatedReplicationServer: Bool? = nil,
        useFipsEndpoint: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfiguration {
        let input = UpdateReplicationConfigurationRequest(
            accountID: accountID, 
            associateDefaultSecurityGroup: associateDefaultSecurityGroup, 
            bandwidthThrottling: bandwidthThrottling, 
            createPublicIP: createPublicIP, 
            dataPlaneRouting: dataPlaneRouting, 
            defaultLargeStagingDiskType: defaultLargeStagingDiskType, 
            ebsEncryption: ebsEncryption, 
            ebsEncryptionKeyArn: ebsEncryptionKeyArn, 
            name: name, 
            replicatedDisks: replicatedDisks, 
            replicationServerInstanceType: replicationServerInstanceType, 
            replicationServersSecurityGroupsIDs: replicationServersSecurityGroupsIDs, 
            sourceServerID: sourceServerID, 
            stagingAreaSubnetId: stagingAreaSubnetId, 
            stagingAreaTags: stagingAreaTags, 
            useDedicatedReplicationServer: useDedicatedReplicationServer, 
            useFipsEndpoint: useFipsEndpoint
        )
        return try await self.updateReplicationConfiguration(input, logger: logger)
    }

    /// Updates multiple ReplicationConfigurationTemplates by ID.
    @Sendable
    @inlinable
    public func updateReplicationConfigurationTemplate(_ input: UpdateReplicationConfigurationTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ReplicationConfigurationTemplate {
        try await self.client.execute(
            operation: "UpdateReplicationConfigurationTemplate", 
            path: "/UpdateReplicationConfigurationTemplate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates multiple ReplicationConfigurationTemplates by ID.
    ///
    /// Parameters:
    ///   - arn: Update replication configuration template ARN request.
    ///   - associateDefaultSecurityGroup: Update replication configuration template associate default Application Migration Service Security group request.
    ///   - bandwidthThrottling: Update replication configuration template bandwidth throttling request.
    ///   - createPublicIP: Update replication configuration template create Public IP request.
    ///   - dataPlaneRouting: Update replication configuration template data plane routing request.
    ///   - defaultLargeStagingDiskType: Update replication configuration template use default large Staging Disk type request.
    ///   - ebsEncryption: Update replication configuration template EBS encryption request.
    ///   - ebsEncryptionKeyArn: Update replication configuration template EBS encryption key ARN request.
    ///   - replicationConfigurationTemplateID: Update replication configuration template template ID request.
    ///   - replicationServerInstanceType: Update replication configuration template Replication Server instance type request.
    ///   - replicationServersSecurityGroupsIDs: Update replication configuration template Replication Server Security groups IDs request.
    ///   - stagingAreaSubnetId: Update replication configuration template Staging Area subnet ID request.
    ///   - stagingAreaTags: Update replication configuration template Staging Area Tags request.
    ///   - useDedicatedReplicationServer: Update replication configuration template use dedicated Replication Server request.
    ///   - useFipsEndpoint: Update replication configuration template use Fips Endpoint request.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationConfigurationTemplate(
        arn: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int64? = nil,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        replicationConfigurationTemplateID: String,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String: String]? = nil,
        useDedicatedReplicationServer: Bool? = nil,
        useFipsEndpoint: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ReplicationConfigurationTemplate {
        let input = UpdateReplicationConfigurationTemplateRequest(
            arn: arn, 
            associateDefaultSecurityGroup: associateDefaultSecurityGroup, 
            bandwidthThrottling: bandwidthThrottling, 
            createPublicIP: createPublicIP, 
            dataPlaneRouting: dataPlaneRouting, 
            defaultLargeStagingDiskType: defaultLargeStagingDiskType, 
            ebsEncryption: ebsEncryption, 
            ebsEncryptionKeyArn: ebsEncryptionKeyArn, 
            replicationConfigurationTemplateID: replicationConfigurationTemplateID, 
            replicationServerInstanceType: replicationServerInstanceType, 
            replicationServersSecurityGroupsIDs: replicationServersSecurityGroupsIDs, 
            stagingAreaSubnetId: stagingAreaSubnetId, 
            stagingAreaTags: stagingAreaTags, 
            useDedicatedReplicationServer: useDedicatedReplicationServer, 
            useFipsEndpoint: useFipsEndpoint
        )
        return try await self.updateReplicationConfigurationTemplate(input, logger: logger)
    }

    /// Update Source Server.
    @Sendable
    @inlinable
    public func updateSourceServer(_ input: UpdateSourceServerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "UpdateSourceServer", 
            path: "/UpdateSourceServer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update Source Server.
    ///
    /// Parameters:
    ///   - accountID: Update Source Server request account ID.
    ///   - connectorAction: Update Source Server request connector action.
    ///   - sourceServerID: Update Source Server request source server ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSourceServer(
        accountID: String? = nil,
        connectorAction: SourceServerConnectorAction? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = UpdateSourceServerRequest(
            accountID: accountID, 
            connectorAction: connectorAction, 
            sourceServerID: sourceServerID
        )
        return try await self.updateSourceServer(input, logger: logger)
    }

    /// Allows you to change between the AGENT_BASED replication type and the SNAPSHOT_SHIPPING replication type.
    @Sendable
    @inlinable
    public func updateSourceServerReplicationType(_ input: UpdateSourceServerReplicationTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SourceServer {
        try await self.client.execute(
            operation: "UpdateSourceServerReplicationType", 
            path: "/UpdateSourceServerReplicationType", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows you to change between the AGENT_BASED replication type and the SNAPSHOT_SHIPPING replication type.
    ///
    /// Parameters:
    ///   - accountID: Account ID on which to update replication type.
    ///   - replicationType: Replication type to which to update source server.
    ///   - sourceServerID: ID of source server on which to update replication type.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSourceServerReplicationType(
        accountID: String? = nil,
        replicationType: ReplicationType,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SourceServer {
        let input = UpdateSourceServerReplicationTypeRequest(
            accountID: accountID, 
            replicationType: replicationType, 
            sourceServerID: sourceServerID
        )
        return try await self.updateSourceServerReplicationType(input, logger: logger)
    }

    /// Update wave.
    @Sendable
    @inlinable
    public func updateWave(_ input: UpdateWaveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> Wave {
        try await self.client.execute(
            operation: "UpdateWave", 
            path: "/UpdateWave", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update wave.
    ///
    /// Parameters:
    ///   - accountID: Account ID.
    ///   - description: Wave description.
    ///   - name: Wave name.
    ///   - waveID: Wave ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWave(
        accountID: String? = nil,
        description: String? = nil,
        name: String? = nil,
        waveID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> Wave {
        let input = UpdateWaveRequest(
            accountID: accountID, 
            description: description, 
            name: name, 
            waveID: waveID
        )
        return try await self.updateWave(input, logger: logger)
    }
}

extension Mgn {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Mgn, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Mgn {
    /// Return PaginatorSequence for operation ``describeJobLogItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobLogItemsPaginator(
        _ input: DescribeJobLogItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeJobLogItemsRequest, DescribeJobLogItemsResponse> {
        return .init(
            input: input,
            command: self.describeJobLogItems,
            inputKey: \DescribeJobLogItemsRequest.nextToken,
            outputKey: \DescribeJobLogItemsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeJobLogItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - accountID: Request to describe Job log Account ID.
    ///   - jobID: Request to describe Job log job ID.
    ///   - maxResults: Request to describe Job log item maximum results.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobLogItemsPaginator(
        accountID: String? = nil,
        jobID: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeJobLogItemsRequest, DescribeJobLogItemsResponse> {
        let input = DescribeJobLogItemsRequest(
            accountID: accountID, 
            jobID: jobID, 
            maxResults: maxResults
        )
        return self.describeJobLogItemsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobsPaginator(
        _ input: DescribeJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeJobsRequest, DescribeJobsResponse> {
        return .init(
            input: input,
            command: self.describeJobs,
            inputKey: \DescribeJobsRequest.nextToken,
            outputKey: \DescribeJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - accountID: Request to describe job log items by Account ID.
    ///   - filters: Request to describe Job log filters.
    ///   - maxResults: Request to describe job log items by max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeJobsPaginator(
        accountID: String? = nil,
        filters: DescribeJobsRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeJobsRequest, DescribeJobsResponse> {
        let input = DescribeJobsRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.describeJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeLaunchConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeLaunchConfigurationTemplatesPaginator(
        _ input: DescribeLaunchConfigurationTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeLaunchConfigurationTemplatesRequest, DescribeLaunchConfigurationTemplatesResponse> {
        return .init(
            input: input,
            command: self.describeLaunchConfigurationTemplates,
            inputKey: \DescribeLaunchConfigurationTemplatesRequest.nextToken,
            outputKey: \DescribeLaunchConfigurationTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeLaunchConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - launchConfigurationTemplateIDs: Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    ///   - maxResults: Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeLaunchConfigurationTemplatesPaginator(
        launchConfigurationTemplateIDs: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeLaunchConfigurationTemplatesRequest, DescribeLaunchConfigurationTemplatesResponse> {
        let input = DescribeLaunchConfigurationTemplatesRequest(
            launchConfigurationTemplateIDs: launchConfigurationTemplateIDs, 
            maxResults: maxResults
        )
        return self.describeLaunchConfigurationTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeReplicationConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReplicationConfigurationTemplatesPaginator(
        _ input: DescribeReplicationConfigurationTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationConfigurationTemplatesRequest, DescribeReplicationConfigurationTemplatesResponse> {
        return .init(
            input: input,
            command: self.describeReplicationConfigurationTemplates,
            inputKey: \DescribeReplicationConfigurationTemplatesRequest.nextToken,
            outputKey: \DescribeReplicationConfigurationTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeReplicationConfigurationTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Request to describe Replication Configuration template by max results.
    ///   - replicationConfigurationTemplateIDs: Request to describe Replication Configuration template by template IDs.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReplicationConfigurationTemplatesPaginator(
        maxResults: Int? = nil,
        replicationConfigurationTemplateIDs: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeReplicationConfigurationTemplatesRequest, DescribeReplicationConfigurationTemplatesResponse> {
        let input = DescribeReplicationConfigurationTemplatesRequest(
            maxResults: maxResults, 
            replicationConfigurationTemplateIDs: replicationConfigurationTemplateIDs
        )
        return self.describeReplicationConfigurationTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeSourceServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSourceServersPaginator(
        _ input: DescribeSourceServersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeSourceServersRequest, DescribeSourceServersResponse> {
        return .init(
            input: input,
            command: self.describeSourceServers,
            inputKey: \DescribeSourceServersRequest.nextToken,
            outputKey: \DescribeSourceServersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeSourceServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - accountID: Request to filter Source Servers list by Accoun ID.
    ///   - filters: Request to filter Source Servers list.
    ///   - maxResults: Request to filter Source Servers list by maximum results.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSourceServersPaginator(
        accountID: String? = nil,
        filters: DescribeSourceServersRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeSourceServersRequest, DescribeSourceServersResponse> {
        let input = DescribeSourceServersRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.describeSourceServersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeVcenterClients(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeVcenterClientsPaginator(
        _ input: DescribeVcenterClientsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeVcenterClientsRequest, DescribeVcenterClientsResponse> {
        return .init(
            input: input,
            command: self.describeVcenterClients,
            inputKey: \DescribeVcenterClientsRequest.nextToken,
            outputKey: \DescribeVcenterClientsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeVcenterClients(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum results to be returned in DescribeVcenterClients.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeVcenterClientsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeVcenterClientsRequest, DescribeVcenterClientsResponse> {
        let input = DescribeVcenterClientsRequest(
            maxResults: maxResults
        )
        return self.describeVcenterClientsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listApplications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationsPaginator(
        _ input: ListApplicationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApplicationsRequest, ListApplicationsResponse> {
        return .init(
            input: input,
            command: self.listApplications,
            inputKey: \ListApplicationsRequest.nextToken,
            outputKey: \ListApplicationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApplications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - accountID: Applications list Account ID.
    ///   - filters: Applications list filters.
    ///   - maxResults: Maximum results to return when listing applications.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationsPaginator(
        accountID: String? = nil,
        filters: ListApplicationsRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApplicationsRequest, ListApplicationsResponse> {
        let input = ListApplicationsRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listApplicationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorsPaginator(
        _ input: ListConnectorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConnectorsRequest, ListConnectorsResponse> {
        return .init(
            input: input,
            command: self.listConnectors,
            inputKey: \ListConnectorsRequest.nextToken,
            outputKey: \ListConnectorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: List Connectors Request filters.
    ///   - maxResults: List Connectors Request max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorsPaginator(
        filters: ListConnectorsRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConnectorsRequest, ListConnectorsResponse> {
        let input = ListConnectorsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listConnectorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listExportErrors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listExportErrorsPaginator(
        _ input: ListExportErrorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListExportErrorsRequest, ListExportErrorsResponse> {
        return .init(
            input: input,
            command: self.listExportErrors,
            inputKey: \ListExportErrorsRequest.nextToken,
            outputKey: \ListExportErrorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listExportErrors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - exportID: List export errors request export id.
    ///   - maxResults: List export errors request max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listExportErrorsPaginator(
        exportID: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListExportErrorsRequest, ListExportErrorsResponse> {
        let input = ListExportErrorsRequest(
            exportID: exportID, 
            maxResults: maxResults
        )
        return self.listExportErrorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listExports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listExportsPaginator(
        _ input: ListExportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListExportsRequest, ListExportsResponse> {
        return .init(
            input: input,
            command: self.listExports,
            inputKey: \ListExportsRequest.nextToken,
            outputKey: \ListExportsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listExports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: 
    ///   - maxResults: List export request max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listExportsPaginator(
        filters: ListExportsRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListExportsRequest, ListExportsResponse> {
        let input = ListExportsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listExportsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImportErrors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportErrorsPaginator(
        _ input: ListImportErrorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImportErrorsRequest, ListImportErrorsResponse> {
        return .init(
            input: input,
            command: self.listImportErrors,
            inputKey: \ListImportErrorsRequest.nextToken,
            outputKey: \ListImportErrorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImportErrors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - importID: List import errors request import id.
    ///   - maxResults: List import errors request max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportErrorsPaginator(
        importID: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImportErrorsRequest, ListImportErrorsResponse> {
        let input = ListImportErrorsRequest(
            importID: importID, 
            maxResults: maxResults
        )
        return self.listImportErrorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportsPaginator(
        _ input: ListImportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImportsRequest, ListImportsResponse> {
        return .init(
            input: input,
            command: self.listImports,
            inputKey: \ListImportsRequest.nextToken,
            outputKey: \ListImportsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: List imports request filters.
    ///   - maxResults: List imports request max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportsPaginator(
        filters: ListImportsRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImportsRequest, ListImportsResponse> {
        let input = ListImportsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listImportsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listManagedAccounts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedAccountsPaginator(
        _ input: ListManagedAccountsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListManagedAccountsRequest, ListManagedAccountsResponse> {
        return .init(
            input: input,
            command: self.listManagedAccounts,
            inputKey: \ListManagedAccountsRequest.nextToken,
            outputKey: \ListManagedAccountsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listManagedAccounts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: List managed accounts request max results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedAccountsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListManagedAccountsRequest, ListManagedAccountsResponse> {
        let input = ListManagedAccountsRequest(
            maxResults: maxResults
        )
        return self.listManagedAccountsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSourceServerActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSourceServerActionsPaginator(
        _ input: ListSourceServerActionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSourceServerActionsRequest, ListSourceServerActionsResponse> {
        return .init(
            input: input,
            command: self.listSourceServerActions,
            inputKey: \ListSourceServerActionsRequest.nextToken,
            outputKey: \ListSourceServerActionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSourceServerActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - accountID: Account ID to return when listing source server post migration custom actions.
    ///   - filters: Filters to apply when listing source server post migration custom actions.
    ///   - maxResults: Maximum amount of items to return when listing source server post migration custom actions.
    ///   - sourceServerID: Source server ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSourceServerActionsPaginator(
        accountID: String? = nil,
        filters: SourceServerActionsRequestFilters? = nil,
        maxResults: Int? = nil,
        sourceServerID: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSourceServerActionsRequest, ListSourceServerActionsResponse> {
        let input = ListSourceServerActionsRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults, 
            sourceServerID: sourceServerID
        )
        return self.listSourceServerActionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTemplateActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTemplateActionsPaginator(
        _ input: ListTemplateActionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTemplateActionsRequest, ListTemplateActionsResponse> {
        return .init(
            input: input,
            command: self.listTemplateActions,
            inputKey: \ListTemplateActionsRequest.nextToken,
            outputKey: \ListTemplateActionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTemplateActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Filters to apply when listing template post migration custom actions.
    ///   - launchConfigurationTemplateID: Launch configuration template ID.
    ///   - maxResults: Maximum amount of items to return when listing template post migration custom actions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTemplateActionsPaginator(
        filters: TemplateActionsRequestFilters? = nil,
        launchConfigurationTemplateID: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTemplateActionsRequest, ListTemplateActionsResponse> {
        let input = ListTemplateActionsRequest(
            filters: filters, 
            launchConfigurationTemplateID: launchConfigurationTemplateID, 
            maxResults: maxResults
        )
        return self.listTemplateActionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWaves(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWavesPaginator(
        _ input: ListWavesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWavesRequest, ListWavesResponse> {
        return .init(
            input: input,
            command: self.listWaves,
            inputKey: \ListWavesRequest.nextToken,
            outputKey: \ListWavesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWaves(_:logger:)``.
    ///
    /// - Parameters:
    ///   - accountID: Request account ID.
    ///   - filters: Waves list filters.
    ///   - maxResults: Maximum results to return when listing waves.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWavesPaginator(
        accountID: String? = nil,
        filters: ListWavesRequestFilters? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWavesRequest, ListWavesResponse> {
        let input = ListWavesRequest(
            accountID: accountID, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listWavesPaginator(input, logger: logger)
    }
}

extension Mgn.DescribeJobLogItemsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.DescribeJobLogItemsRequest {
        return .init(
            accountID: self.accountID,
            jobID: self.jobID,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.DescribeJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.DescribeJobsRequest {
        return .init(
            accountID: self.accountID,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.DescribeLaunchConfigurationTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.DescribeLaunchConfigurationTemplatesRequest {
        return .init(
            launchConfigurationTemplateIDs: self.launchConfigurationTemplateIDs,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.DescribeReplicationConfigurationTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.DescribeReplicationConfigurationTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            replicationConfigurationTemplateIDs: self.replicationConfigurationTemplateIDs
        )
    }
}

extension Mgn.DescribeSourceServersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.DescribeSourceServersRequest {
        return .init(
            accountID: self.accountID,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.DescribeVcenterClientsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.DescribeVcenterClientsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListApplicationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListApplicationsRequest {
        return .init(
            accountID: self.accountID,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListConnectorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListConnectorsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListExportErrorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListExportErrorsRequest {
        return .init(
            exportID: self.exportID,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListExportsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListExportsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListImportErrorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListImportErrorsRequest {
        return .init(
            importID: self.importID,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListImportsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListImportsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListManagedAccountsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListManagedAccountsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListSourceServerActionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListSourceServerActionsRequest {
        return .init(
            accountID: self.accountID,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sourceServerID: self.sourceServerID
        )
    }
}

extension Mgn.ListTemplateActionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListTemplateActionsRequest {
        return .init(
            filters: self.filters,
            launchConfigurationTemplateID: self.launchConfigurationTemplateID,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Mgn.ListWavesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Mgn.ListWavesRequest {
        return .init(
            accountID: self.accountID,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
