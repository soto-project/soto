//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Mgn {
    // MARK: Enums

    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: String, CustomStringConvertible, Codable {
        case cutover = "CUTOVER"
        case readyForCutover = "READY_FOR_CUTOVER"
        case readyForTest = "READY_FOR_TEST"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationErrorString: String, CustomStringConvertible, Codable {
        case agentNotSeen = "AGENT_NOT_SEEN"
        case failedToAttachStagingDisks = "FAILED_TO_ATTACH_STAGING_DISKS"
        case failedToAuthenticateWithService = "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
        case failedToBootReplicationServer = "FAILED_TO_BOOT_REPLICATION_SERVER"
        case failedToConnectAgentToReplicationServer = "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
        case failedToCreateSecurityGroup = "FAILED_TO_CREATE_SECURITY_GROUP"
        case failedToCreateStagingDisks = "FAILED_TO_CREATE_STAGING_DISKS"
        case failedToDownloadReplicationSoftware = "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
        case failedToLaunchReplicationServer = "FAILED_TO_LAUNCH_REPLICATION_SERVER"
        case failedToPairReplicationServerWithAgent = "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
        case failedToStartDataTransfer = "FAILED_TO_START_DATA_TRANSFER"
        case notConverging = "NOT_CONVERGING"
        case snapshotsFailure = "SNAPSHOTS_FAILURE"
        case unstableNetwork = "UNSTABLE_NETWORK"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepName: String, CustomStringConvertible, Codable {
        case attachStagingDisks = "ATTACH_STAGING_DISKS"
        case authenticateWithService = "AUTHENTICATE_WITH_SERVICE"
        case bootReplicationServer = "BOOT_REPLICATION_SERVER"
        case connectAgentToReplicationServer = "CONNECT_AGENT_TO_REPLICATION_SERVER"
        case createSecurityGroup = "CREATE_SECURITY_GROUP"
        case createStagingDisks = "CREATE_STAGING_DISKS"
        case downloadReplicationSoftware = "DOWNLOAD_REPLICATION_SOFTWARE"
        case launchReplicationServer = "LAUNCH_REPLICATION_SERVER"
        case pairReplicationServerWithAgent = "PAIR_REPLICATION_SERVER_WITH_AGENT"
        case startDataTransfer = "START_DATA_TRANSFER"
        case wait = "WAIT"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationInitiationStepStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case skipped = "SKIPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DataReplicationState: String, CustomStringConvertible, Codable {
        case backlog = "BACKLOG"
        case continuous = "CONTINUOUS"
        case creatingSnapshot = "CREATING_SNAPSHOT"
        case disconnected = "DISCONNECTED"
        case initialSync = "INITIAL_SYNC"
        case initiating = "INITIATING"
        case paused = "PAUSED"
        case rescan = "RESCAN"
        case stalled = "STALLED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum FirstBoot: String, CustomStringConvertible, Codable {
        case stopped = "STOPPED"
        case succeeded = "SUCCEEDED"
        case unknown = "UNKNOWN"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum InitiatedBy: String, CustomStringConvertible, Codable {
        case diagnostic = "DIAGNOSTIC"
        case startCutover = "START_CUTOVER"
        case startTest = "START_TEST"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum JobLogEvent: String, CustomStringConvertible, Codable {
        case cleanupEnd = "CLEANUP_END"
        case cleanupFail = "CLEANUP_FAIL"
        case cleanupStart = "CLEANUP_START"
        case conversionEnd = "CONVERSION_END"
        case conversionFail = "CONVERSION_FAIL"
        case conversionStart = "CONVERSION_START"
        case jobCancel = "JOB_CANCEL"
        case jobEnd = "JOB_END"
        case jobStart = "JOB_START"
        case launchFailed = "LAUNCH_FAILED"
        case launchStart = "LAUNCH_START"
        case serverSkipped = "SERVER_SKIPPED"
        case snapshotEnd = "SNAPSHOT_END"
        case snapshotFail = "SNAPSHOT_FAIL"
        case snapshotStart = "SNAPSHOT_START"
        case usingPreviousSnapshot = "USING_PREVIOUS_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case pending = "PENDING"
        case started = "STARTED"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable {
        case launch = "LAUNCH"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum LaunchDisposition: String, CustomStringConvertible, Codable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case launched = "LAUNCHED"
        case pending = "PENDING"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum LifeCycleState: String, CustomStringConvertible, Codable {
        case cutover = "CUTOVER"
        case cuttingOver = "CUTTING_OVER"
        case disconnected = "DISCONNECTED"
        case notReady = "NOT_READY"
        case readyForCutover = "READY_FOR_CUTOVER"
        case readyForTest = "READY_FOR_TEST"
        case stopped = "STOPPED"
        case testing = "TESTING"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDataPlaneRouting: String, CustomStringConvertible, Codable {
        case privateIp = "PRIVATE_IP"
        case publicIp = "PUBLIC_IP"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationDefaultLargeStagingDiskType: String, CustomStringConvertible, Codable {
        case gp2 = "GP2"
        case st1 = "ST1"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationEbsEncryption: String, CustomStringConvertible, Codable {
        case custom = "CUSTOM"
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case gp2 = "GP2"
        case io1 = "IO1"
        case sc1 = "SC1"
        case st1 = "ST1"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum TargetInstanceTypeRightSizingMethod: String, CustomStringConvertible, Codable {
        case basic = "BASIC"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CPU: AWSDecodableShape {
        /// The number of CPU cores on the source server.
        public let cores: Int64?
        /// The source server's CPU model name.
        public let modelName: String?

        public init(cores: Int64? = nil, modelName: String? = nil) {
            self.cores = cores
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case cores
            case modelName
        }
    }

    public struct ChangeServerLifeCycleStateRequest: AWSEncodableShape {
        /// The request to change the source server migration lifecycle state.
        public let lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle
        /// The request to change the source server migration lifecycle state by source server ID.
        public let sourceServerID: String

        public init(lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle, sourceServerID: String) {
            self.lifeCycle = lifeCycle
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifeCycle
            case sourceServerID
        }
    }

    public struct ChangeServerLifeCycleStateSourceServerLifecycle: AWSEncodableShape {
        /// The request to change the source server migration lifecycle state.
        public let state: ChangeServerLifeCycleStateSourceServerLifecycleState

        public init(state: ChangeServerLifeCycleStateSourceServerLifecycleState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct CreateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
        public let associateDefaultSecurityGroup: Bool
        /// Request to configure bandwidth throttling during Replication Settings template creation.
        public let bandwidthThrottling: Int64
        /// Request to create Public IP during Replication Settings template creation.
        public let createPublicIP: Bool
        /// Request to configure data plane routing during Replication Settings template creation.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting
        /// Request to configure the Staging Disk EBS volume type to "gp2" during Replication Settings template creation.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType
        /// Request to configure EBS enryption during Replication Settings template creation.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption
        /// Request to configure an EBS enryption key during Replication Settings template creation.
        public let ebsEncryptionKeyArn: String?
        /// Request to configure the Replication Server instance type during Replication Settings template creation.
        public let replicationServerInstanceType: String
        /// Request to configure the Replication Server Secuirity group ID during Replication Settings template creation.
        public let replicationServersSecurityGroupsIDs: [String]
        /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
        public let stagingAreaSubnetId: String
        /// Request to configure Staiging Area tags during Replication Settings template creation.
        public let stagingAreaTags: [String: String]
        /// Request to configure tags during Replication Settings template creation.
        public let tags: [String: String]?
        /// Request to use Dedicated Replication Servers during Replication Settings template creation.
        public let useDedicatedReplicationServer: Bool

        public init(associateDefaultSecurityGroup: Bool, bandwidthThrottling: Int64, createPublicIP: Bool, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType, ebsEncryption: ReplicationConfigurationEbsEncryption, ebsEncryptionKeyArn: String? = nil, replicationServerInstanceType: String, replicationServersSecurityGroupsIDs: [String], stagingAreaSubnetId: String, stagingAreaTags: [String: String], tags: [String: String]? = nil, useDedicatedReplicationServer: Bool) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, min: 0)
            try self.replicationServersSecurityGroupsIDs.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, min: 0)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, min: 0)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, min: 0)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.key, name: "stagingAreaTags.key", parent: name, min: 0)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.key, name: "tags.key", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case stagingAreaSubnetId
            case stagingAreaTags
            case tags
            case useDedicatedReplicationServer
        }
    }

    public struct DataReplicationError: AWSDecodableShape {
        /// Error in data replication.
        public let error: DataReplicationErrorString?
        /// Error in data replication.
        public let rawError: String?

        public init(error: DataReplicationErrorString? = nil, rawError: String? = nil) {
            self.error = error
            self.rawError = rawError
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case rawError
        }
    }

    public struct DataReplicationInfo: AWSDecodableShape {
        /// Error in obtaining data replication info.
        public let dataReplicationError: DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public let dataReplicationInitiation: DataReplicationInitiation?
        /// Request to query the data replication state.
        public let dataReplicationState: DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public let etaDateTime: String?
        /// Request to query data replication lag durating.
        public let lagDuration: String?
        /// Request to query disks replicated.
        public let replicatedDisks: [DataReplicationInfoReplicatedDisk]?

        public init(dataReplicationError: DataReplicationError? = nil, dataReplicationInitiation: DataReplicationInitiation? = nil, dataReplicationState: DataReplicationState? = nil, etaDateTime: String? = nil, lagDuration: String? = nil, replicatedDisks: [DataReplicationInfoReplicatedDisk]? = nil) {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
        }

        private enum CodingKeys: String, CodingKey {
            case dataReplicationError
            case dataReplicationInitiation
            case dataReplicationState
            case etaDateTime
            case lagDuration
            case replicatedDisks
        }
    }

    public struct DataReplicationInfoReplicatedDisk: AWSDecodableShape {
        /// Request to query data replication backlog size in bytes.
        public let backloggedStorageBytes: Int64?
        /// Request to query device name.
        public let deviceName: String?
        /// Request to query amount of data replicated in bytes.
        public let replicatedStorageBytes: Int64?
        /// Request to query amount of data rescanned in bytes.
        public let rescannedStorageBytes: Int64?
        /// Request to query total amount of data replicated in bytes.
        public let totalStorageBytes: Int64?

        public init(backloggedStorageBytes: Int64? = nil, deviceName: String? = nil, replicatedStorageBytes: Int64? = nil, rescannedStorageBytes: Int64? = nil, totalStorageBytes: Int64? = nil) {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }

        private enum CodingKeys: String, CodingKey {
            case backloggedStorageBytes
            case deviceName
            case replicatedStorageBytes
            case rescannedStorageBytes
            case totalStorageBytes
        }
    }

    public struct DataReplicationInitiation: AWSDecodableShape {
        /// Request to query next data initiation date and time.
        public let nextAttemptDateTime: String?
        /// Request to query data initiation start date and time.
        public let startDateTime: String?
        /// Request to query data initiation steps.
        public let steps: [DataReplicationInitiationStep]?

        public init(nextAttemptDateTime: String? = nil, startDateTime: String? = nil, steps: [DataReplicationInitiationStep]? = nil) {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextAttemptDateTime
            case startDateTime
            case steps
        }
    }

    public struct DataReplicationInitiationStep: AWSDecodableShape {
        /// Request to query data initiation step name.
        public let name: DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public let status: DataReplicationInitiationStepStatus?

        public init(name: DataReplicationInitiationStepName? = nil, status: DataReplicationInitiationStepStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case status
        }
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// Request to delete Job from service by Job ID.
        public let jobID: String

        public init(jobID: String) {
            self.jobID = jobID
        }

        public func validate(name: String) throws {
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobID
        }
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
        public let replicationConfigurationTemplateID: String

        public init(replicationConfigurationTemplateID: String) {
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigurationTemplateID
        }
    }

    public struct DeleteReplicationConfigurationTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSourceServerRequest: AWSEncodableShape {
        /// Request to delete Source Server from service by Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct DeleteSourceServerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeJobLogItemsRequest: AWSEncodableShape {
        /// Request to describe Job log job ID.
        public let jobID: String
        /// Request to describe Job log item maximum results.
        public let maxResults: Int?
        /// Request to describe Job log next token.
        public let nextToken: String?

        public init(jobID: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobID = jobID
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobID, name: "jobID", parent: name, max: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, min: 24)
            try self.validate(self.jobID, name: "jobID", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case jobID
            case maxResults
            case nextToken
        }
    }

    public struct DescribeJobLogItemsResponse: AWSDecodableShape {
        /// Request to describe Job log response items.
        public let items: [JobLog]?
        /// Request to describe Job log response next token.
        public let nextToken: String?

        public init(items: [JobLog]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeJobsRequest: AWSEncodableShape {
        /// Request to describe Job log filters.
        public let filters: DescribeJobsRequestFilters
        /// Request to describe Job log by max results.
        public let maxResults: Int?
        /// Request to describe Job logby next token.
        public let nextToken: String?

        public init(filters: DescribeJobsRequestFilters, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct DescribeJobsRequestFilters: AWSEncodableShape {
        /// Request to describe Job log filters by date.
        public let fromDate: String?
        /// Request to describe Job log filters by job ID.
        public let jobIDs: [String]?
        /// Request to describe Job log by last date.
        public let toDate: String?

        public init(fromDate: String? = nil, jobIDs: [String]? = nil, toDate: String? = nil) {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }

        public func validate(name: String) throws {
            try self.validate(self.fromDate, name: "fromDate", parent: name, max: 32)
            try self.validate(self.fromDate, name: "fromDate", parent: name, min: 19)
            try self.validate(self.fromDate, name: "fromDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
            try self.jobIDs?.forEach {
                try validate($0, name: "jobIDs[]", parent: name, max: 24)
                try validate($0, name: "jobIDs[]", parent: name, min: 24)
                try validate($0, name: "jobIDs[]", parent: name, pattern: "^mgnjob-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.jobIDs, name: "jobIDs", parent: name, max: 1000)
            try self.validate(self.jobIDs, name: "jobIDs", parent: name, min: 0)
            try self.validate(self.toDate, name: "toDate", parent: name, max: 32)
            try self.validate(self.toDate, name: "toDate", parent: name, min: 19)
            try self.validate(self.toDate, name: "toDate", parent: name, pattern: "^[1-9][0-9]*-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case fromDate
            case jobIDs
            case toDate
        }
    }

    public struct DescribeJobsResponse: AWSDecodableShape {
        /// Request to describe Job log items.
        public let items: [Job]?
        /// Request to describe Job response by next token.
        public let nextToken: String?

        public init(items: [Job]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeReplicationConfigurationTemplatesRequest: AWSEncodableShape {
        /// Request to describe Replication Configuration template by max results.
        public let maxResults: Int?
        /// Request to describe Replication Configuration template by next token.
        public let nextToken: String?
        /// Request to describe Replication Configuration template by template IDs.
        public let replicationConfigurationTemplateIDs: [String]

        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationConfigurationTemplateIDs: [String]) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
            try self.replicationConfigurationTemplateIDs.forEach {
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, max: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, min: 21)
                try validate($0, name: "replicationConfigurationTemplateIDs[]", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.replicationConfigurationTemplateIDs, name: "replicationConfigurationTemplateIDs", parent: name, max: 200)
            try self.validate(self.replicationConfigurationTemplateIDs, name: "replicationConfigurationTemplateIDs", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case replicationConfigurationTemplateIDs
        }
    }

    public struct DescribeReplicationConfigurationTemplatesResponse: AWSDecodableShape {
        /// Request to describe Replication Configuration template by items.
        public let items: [ReplicationConfigurationTemplate]?
        /// Request to describe Replication Configuration template by next token.
        public let nextToken: String?

        public init(items: [ReplicationConfigurationTemplate]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DescribeSourceServersRequest: AWSEncodableShape {
        /// Request to filter Source Servers list.
        public let filters: DescribeSourceServersRequestFilters
        /// Request to filter Source Servers list by maximum results.
        public let maxResults: Int?
        /// Request to filter Source Servers list by next token.
        public let nextToken: String?

        public init(filters: DescribeSourceServersRequestFilters, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct DescribeSourceServersRequestFilters: AWSEncodableShape {
        /// Request to filter Source Servers list by archived.
        public let isArchived: Bool?
        /// Request to filter Source Servers list by Source Server ID.
        public let sourceServerIDs: [String]?

        public init(isArchived: Bool? = nil, sourceServerIDs: [String]? = nil) {
            self.isArchived = isArchived
            self.sourceServerIDs = sourceServerIDs
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs?.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case isArchived
            case sourceServerIDs
        }
    }

    public struct DescribeSourceServersResponse: AWSDecodableShape {
        /// Request to filter Source Servers list by item.
        public let items: [SourceServer]?
        /// Request to filter Source Servers next token.
        public let nextToken: String?

        public init(items: [SourceServer]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct DisconnectFromServiceRequest: AWSEncodableShape {
        /// Request to disconnect Source Server from service by Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct Disk: AWSDecodableShape {
        /// The amount of storage on the disk in bytes.
        public let bytes: Int64?
        /// The disk or device name.
        public let deviceName: String?

        public init(bytes: Int64? = nil, deviceName: String? = nil) {
            self.bytes = bytes
            self.deviceName = deviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bytes
            case deviceName
        }
    }

    public struct FinalizeCutoverRequest: AWSEncodableShape {
        /// Request to finalize Cutover by Soure Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct GetLaunchConfigurationRequest: AWSEncodableShape {
        /// Request to get Launch Configuration information by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct GetReplicationConfigurationRequest: AWSEncodableShape {
        /// Request to get Replication Configuaration by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct IdentificationHints: AWSDecodableShape {
        /// AWS Instance ID identification hint.
        public let awsInstanceID: String?
        /// FQDN address identification hint.
        public let fqdn: String?
        /// Hostname identification hint.
        public let hostname: String?
        /// vmWare UUID identification hint.
        public let vmWareUuid: String?

        public init(awsInstanceID: String? = nil, fqdn: String? = nil, hostname: String? = nil, vmWareUuid: String? = nil) {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmWareUuid = vmWareUuid
        }

        private enum CodingKeys: String, CodingKey {
            case awsInstanceID
            case fqdn
            case hostname
            case vmWareUuid
        }
    }

    public struct InitializeServiceRequest: AWSEncodableShape {
        public init() {}
    }

    public struct InitializeServiceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Job: AWSDecodableShape {
        /// the ARN of the specific Job.
        public let arn: String?
        /// Job creation time.
        public let creationDateTime: String?
        /// Job end time.
        public let endDateTime: String?
        /// Job initiated by field.
        public let initiatedBy: InitiatedBy?
        /// Job ID.
        public let jobID: String
        /// Servers participating in a specific Job.
        public let participatingServers: [ParticipatingServer]?
        /// Job status.
        public let status: JobStatus?
        /// Tags associated with spcific Job.
        public let tags: [String: String]?
        /// Job type.
        public let type: JobType?

        public init(arn: String? = nil, creationDateTime: String? = nil, endDateTime: String? = nil, initiatedBy: InitiatedBy? = nil, jobID: String, participatingServers: [ParticipatingServer]? = nil, status: JobStatus? = nil, tags: [String: String]? = nil, type: JobType? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case endDateTime
            case initiatedBy
            case jobID
            case participatingServers
            case status
            case tags
            case type
        }
    }

    public struct JobLog: AWSDecodableShape {
        /// Job log event.
        public let event: JobLogEvent?
        /// Job event data
        public let eventData: JobLogEventData?
        /// Job log event date and time.
        public let logDateTime: String?

        public init(event: JobLogEvent? = nil, eventData: JobLogEventData? = nil, logDateTime: String? = nil) {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case event
            case eventData
            case logDateTime
        }
    }

    public struct JobLogEventData: AWSDecodableShape {
        /// Job Event conversion Server ID.
        public let conversionServerID: String?
        /// Job error.
        public let rawError: String?
        /// Job Event Source Server ID.
        public let sourceServerID: String?
        /// Job Event Target instance ID.
        public let targetInstanceID: String?

        public init(conversionServerID: String? = nil, rawError: String? = nil, sourceServerID: String? = nil, targetInstanceID: String? = nil) {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }

        private enum CodingKeys: String, CodingKey {
            case conversionServerID
            case rawError
            case sourceServerID
            case targetInstanceID
        }
    }

    public struct LaunchConfiguration: AWSDecodableShape {
        /// Copy Private IP during Launch Configuration.
        public let copyPrivateIp: Bool?
        /// Copy Tags during Launch Configuration.
        public let copyTags: Bool?
        /// Configure EC2 lauch configuration template ID.
        public let ec2LaunchTemplateID: String?
        /// Configure launch dispostion for launch configuration.
        public let launchDisposition: LaunchDisposition?
        /// Configure launch configuration OS licensing.
        public let licensing: Licensing?
        /// Configure launch configuration name.
        public let name: String?
        /// Configure launch configuration Source Server ID.
        public let sourceServerID: String?
        /// Configure launch configuration Target instance type right sizing method.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, ec2LaunchTemplateID: String? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, name: String? = nil, sourceServerID: String? = nil, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.name = name
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case copyPrivateIp
            case copyTags
            case ec2LaunchTemplateID
            case launchDisposition
            case licensing
            case name
            case sourceServerID
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct LaunchedInstance: AWSDecodableShape {
        /// Configure launced instance EC2 ID.
        public let ec2InstanceID: String?
        /// Configure launced instance first boot.
        public let firstBoot: FirstBoot?
        /// Configure launced instance Job ID.
        public let jobID: String?

        public init(ec2InstanceID: String? = nil, firstBoot: FirstBoot? = nil, jobID: String? = nil) {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceID
            case firstBoot
            case jobID
        }
    }

    public struct Licensing: AWSEncodableShape & AWSDecodableShape {
        /// Configure BYOL OS licensing.
        public let osByol: Bool?

        public init(osByol: Bool? = nil) {
            self.osByol = osByol
        }

        private enum CodingKeys: String, CodingKey {
            case osByol
        }
    }

    public struct LifeCycle: AWSDecodableShape {
        /// Lifecycle added to service data and time.
        public let addedToServiceDateTime: String?
        /// Lifecycle elapsed time and duration.
        public let elapsedReplicationDuration: String?
        /// Lifecycle replication initiation date and time.
        public let firstByteDateTime: String?
        /// Lifecycle last Cutover.
        public let lastCutover: LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public let lastSeenByServiceDateTime: String?
        /// Lifecycle last Test.
        public let lastTest: LifeCycleLastTest?
        /// Lifecycle state.
        public let state: LifeCycleState?

        public init(addedToServiceDateTime: String? = nil, elapsedReplicationDuration: String? = nil, firstByteDateTime: String? = nil, lastCutover: LifeCycleLastCutover? = nil, lastSeenByServiceDateTime: String? = nil, lastTest: LifeCycleLastTest? = nil, state: LifeCycleState? = nil) {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case addedToServiceDateTime
            case elapsedReplicationDuration
            case firstByteDateTime
            case lastCutover
            case lastSeenByServiceDateTime
            case lastTest
            case state
        }
    }

    public struct LifeCycleLastCutover: AWSDecodableShape {
        /// Lifecycle Cutover finalized date and time.
        public let finalized: LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public let initiated: LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public let reverted: LifeCycleLastCutoverReverted?

        public init(finalized: LifeCycleLastCutoverFinalized? = nil, initiated: LifeCycleLastCutoverInitiated? = nil, reverted: LifeCycleLastCutoverReverted? = nil) {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }

        private enum CodingKeys: String, CodingKey {
            case finalized
            case initiated
            case reverted
        }
    }

    public struct LifeCycleLastCutoverFinalized: AWSDecodableShape {
        /// Lifecycle Cutover finalized date and time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct LifeCycleLastCutoverInitiated: AWSDecodableShape {
        public let apiCallDateTime: String?
        /// Lifecycle last Cutover initiated by Job ID.
        public let jobID: String?

        public init(apiCallDateTime: String? = nil, jobID: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
            case jobID
        }
    }

    public struct LifeCycleLastCutoverReverted: AWSDecodableShape {
        /// Lifecycle last Cutover reverted API call date time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct LifeCycleLastTest: AWSDecodableShape {
        /// Lifecycle last Test finlized.
        public let finalized: LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public let initiated: LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public let reverted: LifeCycleLastTestReverted?

        public init(finalized: LifeCycleLastTestFinalized? = nil, initiated: LifeCycleLastTestInitiated? = nil, reverted: LifeCycleLastTestReverted? = nil) {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }

        private enum CodingKeys: String, CodingKey {
            case finalized
            case initiated
            case reverted
        }
    }

    public struct LifeCycleLastTestFinalized: AWSDecodableShape {
        /// Lifecycle Test failed API call date and time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct LifeCycleLastTestInitiated: AWSDecodableShape {
        /// Lifecycle last Test initiated API call date and time.
        public let apiCallDateTime: String?
        /// Lifecycle last Test initiated Job ID.
        public let jobID: String?

        public init(apiCallDateTime: String? = nil, jobID: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
            case jobID
        }
    }

    public struct LifeCycleLastTestReverted: AWSDecodableShape {
        /// Lifecycle last Test reverted API call date and time.
        public let apiCallDateTime: String?

        public init(apiCallDateTime: String? = nil) {
            self.apiCallDateTime = apiCallDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case apiCallDateTime
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// List tags for resource request by ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// List tags for resource response.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MarkAsArchivedRequest: AWSEncodableShape {
        /// Mark as archived by Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// Network interface IPs.
        public let ips: [String]?
        /// Network interface primary IP.
        public let isPrimary: Bool?
        /// Network interface Mac address.
        public let macAddress: String?

        public init(ips: [String]? = nil, isPrimary: Bool? = nil, macAddress: String? = nil) {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ips
            case isPrimary
            case macAddress
        }
    }

    public struct OS: AWSDecodableShape {
        /// OS full string.
        public let fullString: String?

        public init(fullString: String? = nil) {
            self.fullString = fullString
        }

        private enum CodingKeys: String, CodingKey {
            case fullString
        }
    }

    public struct ParticipatingServer: AWSDecodableShape {
        /// Participating server launch status.
        public let launchStatus: LaunchStatus?
        /// Participating server Source Server ID.
        public let sourceServerID: String?

        public init(launchStatus: LaunchStatus? = nil, sourceServerID: String? = nil) {
            self.launchStatus = launchStatus
            self.sourceServerID = sourceServerID
        }

        private enum CodingKeys: String, CodingKey {
            case launchStatus
            case sourceServerID
        }
    }

    public struct ReplicationConfiguration: AWSDecodableShape {
        /// Replication Configuration associate default Application Migration Service Security Group.
        public let associateDefaultSecurityGroup: Bool?
        /// Replication Configuration set bandwidth throttling.
        public let bandwidthThrottling: Int64?
        /// Replication Configuration create Public IP.
        public let createPublicIP: Bool?
        /// Replication Configuration data plane routing.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration use default large Staging Disks.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration EBS encryption.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Replication Configuration EBS encryption key ARN.
        public let ebsEncryptionKeyArn: String?
        /// Replication Configuration name.
        public let name: String?
        /// Replication Configuration replicated disks.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// Replication Configuration Replication Server instance type.
        public let replicationServerInstanceType: String?
        /// Replication Configuration Replication Server Security Group IDs.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Replication Configuration Source Server ID.
        public let sourceServerID: String?
        /// Replication Configuration Staging Area subnet ID.
        public let stagingAreaSubnetId: String?
        /// Replication Configuration Staging Area tags.
        public let stagingAreaTags: [String: String]?
        /// Replication Configuration use Dedicated Replication Server.
        public let useDedicatedReplicationServer: Bool?

        public init(associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case name
            case replicatedDisks
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case sourceServerID
            case stagingAreaSubnetId
            case stagingAreaTags
            case useDedicatedReplicationServer
        }
    }

    public struct ReplicationConfigurationReplicatedDisk: AWSEncodableShape & AWSDecodableShape {
        /// Replication Configuration replicated disk device name.
        public let deviceName: String?
        /// Replication Configuration replicated disk IOPs.
        public let iops: Int64?
        /// Replication Configuration replicated disk boot disk.
        public let isBootDisk: Bool?
        /// Replication Configuration replicated disk staging disk type.
        public let stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType?

        public init(deviceName: String? = nil, iops: Int64? = nil, isBootDisk: Bool? = nil, stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType? = nil) {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 256)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 0)
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName
            case iops
            case isBootDisk
            case stagingDiskType
        }
    }

    public struct ReplicationConfigurationTemplate: AWSDecodableShape {
        /// Replication Configuration template ARN.
        public let arn: String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public let associateDefaultSecurityGroup: Bool?
        /// Replication Configuration template bandwidth throtting.
        public let bandwidthThrottling: Int64?
        /// Replication Configuration template create Public IP.
        public let createPublicIP: Bool?
        /// Replication Configuration template data plane routing.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use dedault large Staging Disk type.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public let ebsEncryptionKeyArn: String?
        /// Replication Configuration template template ID.
        public let replicationConfigurationTemplateID: String
        /// Replication Configuration template server instance type.
        public let replicationServerInstanceType: String?
        /// Replication Configuration template server Security Groups IDs.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Replication Configuration template Staging Area subnet ID.
        public let stagingAreaSubnetId: String?
        /// Replication Configuration template Staging Area Tags.
        public let stagingAreaTags: [String: String]?
        /// Replication Configuration template Tags.
        public let tags: [String: String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public let useDedicatedReplicationServer: Bool?

        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, tags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case replicationConfigurationTemplateID
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case stagingAreaSubnetId
            case stagingAreaTags
            case tags
            case useDedicatedReplicationServer
        }
    }

    public struct RetryDataReplicationRequest: AWSEncodableShape {
        /// Retry data replication for Source Server ID.
        public let sourceServerID: String

        public init(sourceServerID: String) {
            self.sourceServerID = sourceServerID
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerID
        }
    }

    public struct SourceProperties: AWSDecodableShape {
        /// Source Server CPUs.
        public let cpus: [CPU]?
        /// Source Server disks.
        public let disks: [Disk]?
        /// Source server identification hints.
        public let identificationHints: IdentificationHints?
        /// Source server last update date and time.
        public let lastUpdatedDateTime: String?
        /// Source server network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// Source server OS.
        public let os: OS?
        /// Source server RAM in bytes.
        public let ramBytes: Int64?
        /// Source server recommended instance type.
        public let recommendedInstanceType: String?

        public init(cpus: [CPU]? = nil, disks: [Disk]? = nil, identificationHints: IdentificationHints? = nil, lastUpdatedDateTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, os: OS? = nil, ramBytes: Int64? = nil, recommendedInstanceType: String? = nil) {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case cpus
            case disks
            case identificationHints
            case lastUpdatedDateTime
            case networkInterfaces
            case os
            case ramBytes
            case recommendedInstanceType
        }
    }

    public struct SourceServer: AWSDecodableShape {
        /// Source server ARN.
        public let arn: String?
        /// Source server data replication info.
        public let dataReplicationInfo: DataReplicationInfo?
        /// Source server archived status.
        public let isArchived: Bool?
        /// Source server launched instance.
        public let launchedInstance: LaunchedInstance?
        /// Source server lifecycle state.
        public let lifeCycle: LifeCycle?
        /// Source server properties.
        public let sourceProperties: SourceProperties?
        /// Source server ID.
        public let sourceServerID: String?
        /// Source server Tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, dataReplicationInfo: DataReplicationInfo? = nil, isArchived: Bool? = nil, launchedInstance: LaunchedInstance? = nil, lifeCycle: LifeCycle? = nil, sourceProperties: SourceProperties? = nil, sourceServerID: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dataReplicationInfo
            case isArchived
            case launchedInstance
            case lifeCycle
            case sourceProperties
            case sourceServerID
            case tags
        }
    }

    public struct StartCutoverRequest: AWSEncodableShape {
        /// Start Cutover by Source Server IDs.
        public let sourceServerIDs: [String]
        /// Start Cutover by Tags.
        public let tags: [String: String]?

        public init(sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.key, name: "tags.key", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerIDs
            case tags
        }
    }

    public struct StartCutoverResponse: AWSDecodableShape {
        /// Start Cutover Job response.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct StartTestRequest: AWSEncodableShape {
        /// Start Test for Source Server IDs.
        public let sourceServerIDs: [String]
        /// Start Test by Tags.
        public let tags: [String: String]?

        public init(sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.key, name: "tags.key", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerIDs
            case tags
        }
    }

    public struct StartTestResponse: AWSDecodableShape {
        /// Start Test Job response.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// Tag resource by ARN.
        public let resourceArn: String
        /// Tag resource by Tags.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.key, name: "tags.key", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TerminateTargetInstancesRequest: AWSEncodableShape {
        /// Terminate Target instance by Source Server IDs.
        public let sourceServerIDs: [String]
        /// Terminate Target instance by Tags.
        public let tags: [String: String]?

        public init(sourceServerIDs: [String], tags: [String: String]? = nil) {
            self.sourceServerIDs = sourceServerIDs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.sourceServerIDs.forEach {
                try validate($0, name: "sourceServerIDs[]", parent: name, max: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, min: 19)
                try validate($0, name: "sourceServerIDs[]", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            }
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, max: 200)
            try self.validate(self.sourceServerIDs, name: "sourceServerIDs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 256)
                try validate($0.key, name: "tags.key", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sourceServerIDs
            case tags
        }
    }

    public struct TerminateTargetInstancesResponse: AWSDecodableShape {
        /// Terminate Target instance Job response.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// Untag resource by ARN.
        public let resourceArn: String
        /// Untag resource by Keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 256)
                try validate($0, name: "tagKeys[]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateLaunchConfigurationRequest: AWSEncodableShape {
        /// Update Launch configuration copy Private IP request.
        public let copyPrivateIp: Bool?
        /// Update Launch configuration copy Tags request.
        public let copyTags: Bool?
        /// Update Launch configuration launch disposition request.
        public let launchDisposition: LaunchDisposition?
        /// Update Launch configuration licensing request.
        public let licensing: Licensing?
        /// Update Launch configuration name request.
        public let name: String?
        /// Update Launch configuration by Source Server ID request.
        public let sourceServerID: String
        /// Update Launch configuration Target instance right sizing request.
        public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

        public init(copyPrivateIp: Bool? = nil, copyTags: Bool? = nil, launchDisposition: LaunchDisposition? = nil, licensing: Licensing? = nil, name: String? = nil, sourceServerID: String, targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil) {
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.name = name
            self.sourceServerID = sourceServerID
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case copyPrivateIp
            case copyTags
            case launchDisposition
            case licensing
            case name
            case sourceServerID
            case targetInstanceTypeRightSizingMethod
        }
    }

    public struct UpdateReplicationConfigurationRequest: AWSEncodableShape {
        /// Update replication configuration associate default Application Migration Service Security group request.
        public let associateDefaultSecurityGroup: Bool?
        /// Update replication configuration bandwidth throttling request.
        public let bandwidthThrottling: Int64?
        /// Update replication configuration create Public IP request.
        public let createPublicIP: Bool?
        /// Update replication configuration data plane routing request.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Update replication configuration use default large Staging Disk type request.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Update replication configuration EBS encryption request.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Update replication configuration EBS encryption key ARN request.
        public let ebsEncryptionKeyArn: String?
        /// Update replication configuration name request.
        public let name: String?
        /// Update replication configuration replicated disks request.
        public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
        /// Update replication configuration Replication Server instance type request.
        public let replicationServerInstanceType: String?
        /// Update replication configuration Replication Server Security Groups IDs request.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Update replication configuration Source Server ID request.
        public let sourceServerID: String
        /// Update replication configuration Staging Area subnet request.
        public let stagingAreaSubnetId: String?
        /// Update replication configuration Staging Area Tags request.
        public let stagingAreaTags: [String: String]?
        /// Update replication configuration use dedicated Replication Server request.
        public let useDedicatedReplicationServer: Bool?

        public init(associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, name: String? = nil, replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, sourceServerID: String, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.name = name
            self.replicatedDisks = replicatedDisks
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.sourceServerID = sourceServerID
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.replicatedDisks?.forEach {
                try $0.validate(name: "\(name).replicatedDisks[]")
            }
            try self.validate(self.replicatedDisks, name: "replicatedDisks", parent: name, max: 60)
            try self.validate(self.replicatedDisks, name: "replicatedDisks", parent: name, min: 0)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, min: 0)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, min: 0)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, min: 0)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, max: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, min: 19)
            try self.validate(self.sourceServerID, name: "sourceServerID", parent: name, pattern: "^s-[0-9a-zA-Z]{17}$")
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, min: 0)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.key, name: "stagingAreaTags.key", parent: name, min: 0)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case name
            case replicatedDisks
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case sourceServerID
            case stagingAreaSubnetId
            case stagingAreaTags
            case useDedicatedReplicationServer
        }
    }

    public struct UpdateReplicationConfigurationTemplateRequest: AWSEncodableShape {
        /// Update replication configuration template ARN request.
        public let arn: String?
        /// Update replication configuration template associate default Application Migration Service Security group request.
        public let associateDefaultSecurityGroup: Bool?
        /// Update replication configuration template bandwidth throttling request.
        public let bandwidthThrottling: Int64?
        /// Update replication configuration template create Public IP request.
        public let createPublicIP: Bool?
        /// Update replication configuration template data plane routing request.
        public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
        /// Update replication configuration template use default large Staging Disk type request.
        public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Update replication configuration template EBS encryption request.
        public let ebsEncryption: ReplicationConfigurationEbsEncryption?
        /// Update replication configuration template EBS encryption key ARN request.
        public let ebsEncryptionKeyArn: String?
        /// Update replication configuration template template ID request.
        public let replicationConfigurationTemplateID: String
        /// Update replication configuration template Replication Server instance type request.
        public let replicationServerInstanceType: String?
        /// Update replication configuration template Replication Server Security groups IDs request.
        public let replicationServersSecurityGroupsIDs: [String]?
        /// Update replication configuration template Staging Area subnet ID request.
        public let stagingAreaSubnetId: String?
        /// Update replication configuration template Staging Area Tags request.
        public let stagingAreaTags: [String: String]?
        /// Update replication configuration template use dedicated Replication Server request.
        public let useDedicatedReplicationServer: Bool?

        public init(arn: String? = nil, associateDefaultSecurityGroup: Bool? = nil, bandwidthThrottling: Int64? = nil, createPublicIP: Bool? = nil, dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil, defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil, ebsEncryption: ReplicationConfigurationEbsEncryption? = nil, ebsEncryptionKeyArn: String? = nil, replicationConfigurationTemplateID: String, replicationServerInstanceType: String? = nil, replicationServersSecurityGroupsIDs: [String]? = nil, stagingAreaSubnetId: String? = nil, stagingAreaTags: [String: String]? = nil, useDedicatedReplicationServer: Bool? = nil) {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.bandwidthThrottling, name: "bandwidthThrottling", parent: name, min: 0)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, max: 2048)
            try self.validate(self.ebsEncryptionKeyArn, name: "ebsEncryptionKeyArn", parent: name, min: 20)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, max: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, min: 21)
            try self.validate(self.replicationConfigurationTemplateID, name: "replicationConfigurationTemplateID", parent: name, pattern: "^rct-[0-9a-zA-Z]{17}$")
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, max: 255)
            try self.validate(self.replicationServerInstanceType, name: "replicationServerInstanceType", parent: name, min: 0)
            try self.replicationServersSecurityGroupsIDs?.forEach {
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, max: 255)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, min: 0)
                try validate($0, name: "replicationServersSecurityGroupsIDs[]", parent: name, pattern: "^sg-[0-9a-fA-F]{8,}$")
            }
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, max: 32)
            try self.validate(self.replicationServersSecurityGroupsIDs, name: "replicationServersSecurityGroupsIDs", parent: name, min: 0)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, max: 255)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, min: 0)
            try self.validate(self.stagingAreaSubnetId, name: "stagingAreaSubnetId", parent: name, pattern: "^subnet-[0-9a-fA-F]{8,}$")
            try self.stagingAreaTags?.forEach {
                try validate($0.key, name: "stagingAreaTags.key", parent: name, max: 256)
                try validate($0.key, name: "stagingAreaTags.key", parent: name, min: 0)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "stagingAreaTags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case associateDefaultSecurityGroup
            case bandwidthThrottling
            case createPublicIP
            case dataPlaneRouting
            case defaultLargeStagingDiskType
            case ebsEncryption
            case ebsEncryptionKeyArn
            case replicationConfigurationTemplateID
            case replicationServerInstanceType
            case replicationServersSecurityGroupsIDs
            case stagingAreaSubnetId
            case stagingAreaTags
            case useDedicatedReplicationServer
        }
    }
}
