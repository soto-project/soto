//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Artifact {
    // MARK: Enums

    public enum AcceptanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Require explicit click-through acceptance of
        /// the Term associated with this Report.
        case explicit = "EXPLICIT"
        /// Do not require explicit click-through
        /// acceptance of the Term associated with
        /// this Report.
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum NotificationSubscriptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The account is not subscribed for notification.
        case notSubscribed = "NOT_SUBSCRIBED"
        /// The account is subscribed for notification.
        case subscribed = "SUBSCRIBED"
        public var description: String { return self.rawValue }
    }

    public enum PublishedState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The resource is published for consumption.
        case published = "PUBLISHED"
        /// The resource is not published for consumption.
        case unpublished = "UNPUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum UploadState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case fault = "FAULT"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountSettings: AWSDecodableShape {
        /// Notification subscription status of the customer.
        public let notificationSubscriptionStatus: NotificationSubscriptionStatus?

        public init(notificationSubscriptionStatus: NotificationSubscriptionStatus? = nil) {
            self.notificationSubscriptionStatus = notificationSubscriptionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case notificationSubscriptionStatus = "notificationSubscriptionStatus"
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResponse: AWSDecodableShape {
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct GetReportMetadataRequest: AWSEncodableShape {
        /// Unique resource ID for the report resource.
        public let reportId: String
        /// Version for the report resource.
        public let reportVersion: Int64?

        public init(reportId: String, reportVersion: Int64? = nil) {
            self.reportId = reportId
            self.reportVersion = reportVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.reportId, key: "reportId")
            request.encodeQuery(self.reportVersion, key: "reportVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "^report-[a-zA-Z0-9]{16}$")
            try self.validate(self.reportVersion, name: "reportVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReportMetadataResponse: AWSDecodableShape {
        /// Report resource detail.
        public let reportDetails: ReportDetail?

        public init(reportDetails: ReportDetail? = nil) {
            self.reportDetails = reportDetails
        }

        private enum CodingKeys: String, CodingKey {
            case reportDetails = "reportDetails"
        }
    }

    public struct GetReportRequest: AWSEncodableShape {
        /// Unique resource ID for the report resource.
        public let reportId: String
        /// Version for the report resource.
        public let reportVersion: Int64?
        /// Unique download token provided by GetTermForReport API.
        public let termToken: String

        public init(reportId: String, reportVersion: Int64? = nil, termToken: String) {
            self.reportId = reportId
            self.reportVersion = reportVersion
            self.termToken = termToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.reportId, key: "reportId")
            request.encodeQuery(self.reportVersion, key: "reportVersion")
            request.encodeQuery(self.termToken, key: "termToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "^report-[a-zA-Z0-9]{16}$")
            try self.validate(self.reportVersion, name: "reportVersion", parent: name, min: 1)
            try self.validate(self.termToken, name: "termToken", parent: name, max: 256)
            try self.validate(self.termToken, name: "termToken", parent: name, min: 1)
            try self.validate(self.termToken, name: "termToken", parent: name, pattern: "^[a-zA-Z0-9_\\-\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReportResponse: AWSDecodableShape {
        /// Presigned S3 url to access the report content.
        public let documentPresignedUrl: String?

        public init(documentPresignedUrl: String? = nil) {
            self.documentPresignedUrl = documentPresignedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case documentPresignedUrl = "documentPresignedUrl"
        }
    }

    public struct GetTermForReportRequest: AWSEncodableShape {
        /// Unique resource ID for the report resource.
        public let reportId: String
        /// Version for the report resource.
        public let reportVersion: Int64?

        public init(reportId: String, reportVersion: Int64? = nil) {
            self.reportId = reportId
            self.reportVersion = reportVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.reportId, key: "reportId")
            request.encodeQuery(self.reportVersion, key: "reportVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "^report-[a-zA-Z0-9]{16}$")
            try self.validate(self.reportVersion, name: "reportVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTermForReportResponse: AWSDecodableShape {
        /// Presigned S3 url to access the term content.
        public let documentPresignedUrl: String?
        /// Unique token representing this request event.
        public let termToken: String?

        public init(documentPresignedUrl: String? = nil, termToken: String? = nil) {
            self.documentPresignedUrl = documentPresignedUrl
            self.termToken = termToken
        }

        private enum CodingKeys: String, CodingKey {
            case documentPresignedUrl = "documentPresignedUrl"
            case termToken = "termToken"
        }
    }

    public struct ListReportsRequest: AWSEncodableShape {
        /// Maximum number of resources to return in the paginated response.
        public let maxResults: Int?
        /// Pagination token to request the next page of resources.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 300)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReportsResponse: AWSDecodableShape {
        /// Pagination token to request the next page of resources.
        public let nextToken: String?
        /// List of report resources.
        public let reports: [ReportSummary]?

        public init(nextToken: String? = nil, reports: [ReportSummary]? = nil) {
            self.nextToken = nextToken
            self.reports = reports
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case reports = "reports"
        }
    }

    public struct PutAccountSettingsRequest: AWSEncodableShape {
        /// Desired notification subscription status.
        public let notificationSubscriptionStatus: NotificationSubscriptionStatus?

        public init(notificationSubscriptionStatus: NotificationSubscriptionStatus? = nil) {
            self.notificationSubscriptionStatus = notificationSubscriptionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case notificationSubscriptionStatus = "notificationSubscriptionStatus"
        }
    }

    public struct PutAccountSettingsResponse: AWSDecodableShape {
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct ReportDetail: AWSDecodableShape {
        /// Acceptance type for report.
        public let acceptanceType: AcceptanceType?
        /// ARN for the report resource.
        public let arn: String?
        /// Category for the report resource.
        public let category: String?
        /// Associated company name for the report resource.
        public let companyName: String?
        /// Timestamp indicating when the report resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// Timestamp indicating when the report resource was deleted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var deletedAt: Date?
        /// Description for the report resource.
        public let description: String?
        /// Unique resource ID for the report resource.
        public let id: String?
        /// Timestamp indicating when the report resource was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedAt: Date?
        /// Name for the report resource.
        public let name: String?
        /// Timestamp indicating the report resource effective end.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodEnd: Date?
        /// Timestamp indicating the report resource effective start.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodStart: Date?
        /// Associated product name for the report resource.
        public let productName: String?
        /// Sequence number to enforce optimistic locking.
        public let sequenceNumber: Int64?
        /// Series for the report resource.
        public let series: String?
        /// Current state of the report resource
        public let state: PublishedState?
        /// The message associated with the current upload state.
        public let statusMessage: String?
        /// Unique resource ARN for term resource.
        public let termArn: String?
        /// The current state of the document upload.
        public let uploadState: UploadState?
        /// Version for the report resource.
        public let version: Int64?

        public init(acceptanceType: AcceptanceType? = nil, arn: String? = nil, category: String? = nil, companyName: String? = nil, createdAt: Date? = nil, deletedAt: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedAt: Date? = nil, name: String? = nil, periodEnd: Date? = nil, periodStart: Date? = nil, productName: String? = nil, sequenceNumber: Int64? = nil, series: String? = nil, state: PublishedState? = nil, statusMessage: String? = nil, termArn: String? = nil, uploadState: UploadState? = nil, version: Int64? = nil) {
            self.acceptanceType = acceptanceType
            self.arn = arn
            self.category = category
            self.companyName = companyName
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.description = description
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.periodEnd = periodEnd
            self.periodStart = periodStart
            self.productName = productName
            self.sequenceNumber = sequenceNumber
            self.series = series
            self.state = state
            self.statusMessage = statusMessage
            self.termArn = termArn
            self.uploadState = uploadState
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceType = "acceptanceType"
            case arn = "arn"
            case category = "category"
            case companyName = "companyName"
            case createdAt = "createdAt"
            case deletedAt = "deletedAt"
            case description = "description"
            case id = "id"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case periodEnd = "periodEnd"
            case periodStart = "periodStart"
            case productName = "productName"
            case sequenceNumber = "sequenceNumber"
            case series = "series"
            case state = "state"
            case statusMessage = "statusMessage"
            case termArn = "termArn"
            case uploadState = "uploadState"
            case version = "version"
        }
    }

    public struct ReportSummary: AWSDecodableShape {
        /// ARN for the report resource.
        public let arn: String?
        /// Category for the report resource.
        public let category: String?
        /// Associated company name for the report resource.
        public let companyName: String?
        /// Description for the report resource.
        public let description: String?
        /// Unique resource ID for the report resource.
        public let id: String?
        /// Name for the report resource.
        public let name: String?
        /// Timestamp indicating the report resource effective end.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodEnd: Date?
        /// Timestamp indicating the report resource effective start.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodStart: Date?
        /// Associated product name for the report resource.
        public let productName: String?
        /// Series for the report resource.
        public let series: String?
        /// Current state of the report resource.
        public let state: PublishedState?
        /// The message associated with the current upload state.
        public let statusMessage: String?
        /// The current state of the document upload.
        public let uploadState: UploadState?
        /// Version for the report resource.
        public let version: Int64?

        public init(arn: String? = nil, category: String? = nil, companyName: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, periodEnd: Date? = nil, periodStart: Date? = nil, productName: String? = nil, series: String? = nil, state: PublishedState? = nil, statusMessage: String? = nil, uploadState: UploadState? = nil, version: Int64? = nil) {
            self.arn = arn
            self.category = category
            self.companyName = companyName
            self.description = description
            self.id = id
            self.name = name
            self.periodEnd = periodEnd
            self.periodStart = periodStart
            self.productName = productName
            self.series = series
            self.state = state
            self.statusMessage = statusMessage
            self.uploadState = uploadState
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case category = "category"
            case companyName = "companyName"
            case description = "description"
            case id = "id"
            case name = "name"
            case periodEnd = "periodEnd"
            case periodStart = "periodStart"
            case productName = "productName"
            case series = "series"
            case state = "state"
            case statusMessage = "statusMessage"
            case uploadState = "uploadState"
            case version = "version"
        }
    }
}

// MARK: - Errors

/// Error enum for Artifact
public struct ArtifactErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Artifact
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Request to create/modify content would result in a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unknown server exception has occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Request fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension ArtifactErrorType: Equatable {
    public static func == (lhs: ArtifactErrorType, rhs: ArtifactErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ArtifactErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
