//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Artifact {
    // MARK: Enums

    public enum AcceptanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Require explicit click-through acceptance of the
        /// Term associated with this Report.
        case explicit = "EXPLICIT"
        /// Do not require explicit click-through acceptance
        /// of the Term associated with this Report
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum AgreementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case custom = "CUSTOM"
        case modified = "MODIFIED"
        public var description: String { return self.rawValue }
    }

    public enum CustomerAgreementState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case awsTerminated = "AWS_TERMINATED"
        case customerTerminated = "CUSTOMER_TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum NotificationSubscriptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notSubscribed = "NOT_SUBSCRIBED"
        case subscribed = "SUBSCRIBED"
        public var description: String { return self.rawValue }
    }

    public enum PublishedState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case published = "PUBLISHED"
        case unpublished = "UNPUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum UploadState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case fault = "FAULT"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case invalidToken = "invalidToken"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountSettings: AWSDecodableShape {
        /// Notification subscription status of the customer.
        public let notificationSubscriptionStatus: NotificationSubscriptionStatus?

        @inlinable
        public init(notificationSubscriptionStatus: NotificationSubscriptionStatus? = nil) {
            self.notificationSubscriptionStatus = notificationSubscriptionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case notificationSubscriptionStatus = "notificationSubscriptionStatus"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// Identifier of the affected resource.
        public let resourceId: String
        /// Type of the affected resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CustomerAgreementSummary: AWSDecodableShape {
        /// Terms required to accept the agreement resource.
        public let acceptanceTerms: [String]?
        /// ARN of the agreement resource the customer-agreement resource represents.
        public let agreementArn: String?
        /// ARN of the customer-agreement resource.
        public let arn: String?
        /// AWS account Id that owns the resource.
        public let awsAccountId: String?
        /// Description of the resource.
        public let description: String?
        /// Timestamp indicating when the agreement was terminated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var effectiveEnd: Date?
        /// Timestamp indicating when the agreement became effective.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var effectiveStart: Date?
        /// Identifier of the customer-agreement resource.
        public let id: String?
        /// Name of the customer-agreement resource.
        public let name: String?
        /// ARN of the organization that owns the resource.
        public let organizationArn: String?
        /// State of the resource.
        public let state: CustomerAgreementState?
        /// Terms required to terminate the customer-agreement resource.
        public let terminateTerms: [String]?
        /// Type of the customer-agreement resource.
        public let type: AgreementType?

        @inlinable
        public init(acceptanceTerms: [String]? = nil, agreementArn: String? = nil, arn: String? = nil, awsAccountId: String? = nil, description: String? = nil, effectiveEnd: Date? = nil, effectiveStart: Date? = nil, id: String? = nil, name: String? = nil, organizationArn: String? = nil, state: CustomerAgreementState? = nil, terminateTerms: [String]? = nil, type: AgreementType? = nil) {
            self.acceptanceTerms = acceptanceTerms
            self.agreementArn = agreementArn
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.description = description
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.id = id
            self.name = name
            self.organizationArn = organizationArn
            self.state = state
            self.terminateTerms = terminateTerms
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceTerms = "acceptanceTerms"
            case agreementArn = "agreementArn"
            case arn = "arn"
            case awsAccountId = "awsAccountId"
            case description = "description"
            case effectiveEnd = "effectiveEnd"
            case effectiveStart = "effectiveStart"
            case id = "id"
            case name = "name"
            case organizationArn = "organizationArn"
            case state = "state"
            case terminateTerms = "terminateTerms"
            case type = "type"
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResponse: AWSDecodableShape {
        public let accountSettings: AccountSettings?

        @inlinable
        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct GetReportMetadataRequest: AWSEncodableShape {
        /// Unique resource ID for the report resource.
        public let reportId: String
        /// Version for the report resource.
        public let reportVersion: Int64?

        @inlinable
        public init(reportId: String, reportVersion: Int64? = nil) {
            self.reportId = reportId
            self.reportVersion = reportVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.reportId, key: "reportId")
            request.encodeQuery(self.reportVersion, key: "reportVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "^report-[a-zA-Z0-9]{16}$")
            try self.validate(self.reportVersion, name: "reportVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReportMetadataResponse: AWSDecodableShape {
        /// Report resource detail.
        public let reportDetails: ReportDetail?

        @inlinable
        public init(reportDetails: ReportDetail? = nil) {
            self.reportDetails = reportDetails
        }

        private enum CodingKeys: String, CodingKey {
            case reportDetails = "reportDetails"
        }
    }

    public struct GetReportRequest: AWSEncodableShape {
        /// Unique resource ID for the report resource.
        public let reportId: String
        /// Version for the report resource.
        public let reportVersion: Int64?
        /// Unique download token provided by GetTermForReport API.
        public let termToken: String

        @inlinable
        public init(reportId: String, reportVersion: Int64? = nil, termToken: String) {
            self.reportId = reportId
            self.reportVersion = reportVersion
            self.termToken = termToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.reportId, key: "reportId")
            request.encodeQuery(self.reportVersion, key: "reportVersion")
            request.encodeQuery(self.termToken, key: "termToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "^report-[a-zA-Z0-9]{16}$")
            try self.validate(self.reportVersion, name: "reportVersion", parent: name, min: 1)
            try self.validate(self.termToken, name: "termToken", parent: name, max: 256)
            try self.validate(self.termToken, name: "termToken", parent: name, min: 1)
            try self.validate(self.termToken, name: "termToken", parent: name, pattern: "^[a-zA-Z0-9_\\-\\s]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReportResponse: AWSDecodableShape {
        /// Presigned S3 url to access the report content.
        public let documentPresignedUrl: String?

        @inlinable
        public init(documentPresignedUrl: String? = nil) {
            self.documentPresignedUrl = documentPresignedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case documentPresignedUrl = "documentPresignedUrl"
        }
    }

    public struct GetTermForReportRequest: AWSEncodableShape {
        /// Unique resource ID for the report resource.
        public let reportId: String
        /// Version for the report resource.
        public let reportVersion: Int64?

        @inlinable
        public init(reportId: String, reportVersion: Int64? = nil) {
            self.reportId = reportId
            self.reportVersion = reportVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.reportId, key: "reportId")
            request.encodeQuery(self.reportVersion, key: "reportVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "^report-[a-zA-Z0-9]{16}$")
            try self.validate(self.reportVersion, name: "reportVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTermForReportResponse: AWSDecodableShape {
        /// Presigned S3 url to access the term content.
        public let documentPresignedUrl: String?
        /// Unique token representing this request event.
        public let termToken: String?

        @inlinable
        public init(documentPresignedUrl: String? = nil, termToken: String? = nil) {
            self.documentPresignedUrl = documentPresignedUrl
            self.termToken = termToken
        }

        private enum CodingKeys: String, CodingKey {
            case documentPresignedUrl = "documentPresignedUrl"
            case termToken = "termToken"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// Number of seconds in which the caller can retry the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListCustomerAgreementsRequest: AWSEncodableShape {
        /// Maximum number of resources to return in the paginated response.
        public let maxResults: Int?
        /// Pagination token to request the next page of resources.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 300)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCustomerAgreementsResponse: AWSDecodableShape {
        /// List of customer-agreement resources.
        public let customerAgreements: [CustomerAgreementSummary]
        /// Pagination token to request the next page of resources.
        public let nextToken: String?

        @inlinable
        public init(customerAgreements: [CustomerAgreementSummary], nextToken: String? = nil) {
            self.customerAgreements = customerAgreements
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customerAgreements = "customerAgreements"
            case nextToken = "nextToken"
        }
    }

    public struct ListReportsRequest: AWSEncodableShape {
        /// Maximum number of resources to return in the paginated response.
        public let maxResults: Int?
        /// Pagination token to request the next page of resources.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 300)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReportsResponse: AWSDecodableShape {
        /// Pagination token to request the next page of resources.
        public let nextToken: String?
        /// List of report resources.
        public let reports: [ReportSummary]?

        @inlinable
        public init(nextToken: String? = nil, reports: [ReportSummary]? = nil) {
            self.nextToken = nextToken
            self.reports = reports
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case reports = "reports"
        }
    }

    public struct PutAccountSettingsRequest: AWSEncodableShape {
        /// Desired notification subscription status.
        public let notificationSubscriptionStatus: NotificationSubscriptionStatus?

        @inlinable
        public init(notificationSubscriptionStatus: NotificationSubscriptionStatus? = nil) {
            self.notificationSubscriptionStatus = notificationSubscriptionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case notificationSubscriptionStatus = "notificationSubscriptionStatus"
        }
    }

    public struct PutAccountSettingsResponse: AWSDecodableShape {
        public let accountSettings: AccountSettings?

        @inlinable
        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct ReportDetail: AWSDecodableShape {
        /// Acceptance type for report.
        public let acceptanceType: AcceptanceType?
        /// ARN for the report resource.
        public let arn: String?
        /// Category for the report resource.
        public let category: String?
        /// Associated company name for the report resource.
        public let companyName: String?
        /// Timestamp indicating when the report resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// Timestamp indicating when the report resource was deleted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var deletedAt: Date?
        /// Description for the report resource.
        public let description: String?
        /// Unique resource ID for the report resource.
        public let id: String?
        /// Timestamp indicating when the report resource was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedAt: Date?
        /// Name for the report resource.
        public let name: String?
        /// Timestamp indicating the report resource effective end.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodEnd: Date?
        /// Timestamp indicating the report resource effective start.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodStart: Date?
        /// Associated product name for the report resource.
        public let productName: String?
        /// Sequence number to enforce optimistic locking.
        public let sequenceNumber: Int64?
        /// Series for the report resource.
        public let series: String?
        /// Current state of the report resource
        public let state: PublishedState?
        /// The message associated with the current upload state.
        public let statusMessage: String?
        /// Unique resource ARN for term resource.
        public let termArn: String?
        /// The current state of the document upload.
        public let uploadState: UploadState?
        /// Version for the report resource.
        public let version: Int64?

        @inlinable
        public init(acceptanceType: AcceptanceType? = nil, arn: String? = nil, category: String? = nil, companyName: String? = nil, createdAt: Date? = nil, deletedAt: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedAt: Date? = nil, name: String? = nil, periodEnd: Date? = nil, periodStart: Date? = nil, productName: String? = nil, sequenceNumber: Int64? = nil, series: String? = nil, state: PublishedState? = nil, statusMessage: String? = nil, termArn: String? = nil, uploadState: UploadState? = nil, version: Int64? = nil) {
            self.acceptanceType = acceptanceType
            self.arn = arn
            self.category = category
            self.companyName = companyName
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.description = description
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.periodEnd = periodEnd
            self.periodStart = periodStart
            self.productName = productName
            self.sequenceNumber = sequenceNumber
            self.series = series
            self.state = state
            self.statusMessage = statusMessage
            self.termArn = termArn
            self.uploadState = uploadState
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceType = "acceptanceType"
            case arn = "arn"
            case category = "category"
            case companyName = "companyName"
            case createdAt = "createdAt"
            case deletedAt = "deletedAt"
            case description = "description"
            case id = "id"
            case lastModifiedAt = "lastModifiedAt"
            case name = "name"
            case periodEnd = "periodEnd"
            case periodStart = "periodStart"
            case productName = "productName"
            case sequenceNumber = "sequenceNumber"
            case series = "series"
            case state = "state"
            case statusMessage = "statusMessage"
            case termArn = "termArn"
            case uploadState = "uploadState"
            case version = "version"
        }
    }

    public struct ReportSummary: AWSDecodableShape {
        /// Acceptance type for report.
        public let acceptanceType: AcceptanceType?
        /// ARN for the report resource.
        public let arn: String?
        /// Category for the report resource.
        public let category: String?
        /// Associated company name for the report resource.
        public let companyName: String?
        /// Description for the report resource.
        public let description: String?
        /// Unique resource ID for the report resource.
        public let id: String?
        /// Name for the report resource.
        public let name: String?
        /// Timestamp indicating the report resource effective end.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodEnd: Date?
        /// Timestamp indicating the report resource effective start.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var periodStart: Date?
        /// Associated product name for the report resource.
        public let productName: String?
        /// Series for the report resource.
        public let series: String?
        /// Current state of the report resource.
        public let state: PublishedState?
        /// The message associated with the current upload state.
        public let statusMessage: String?
        /// The current state of the document upload.
        public let uploadState: UploadState?
        /// Version for the report resource.
        public let version: Int64?

        @inlinable
        public init(acceptanceType: AcceptanceType? = nil, arn: String? = nil, category: String? = nil, companyName: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, periodEnd: Date? = nil, periodStart: Date? = nil, productName: String? = nil, series: String? = nil, state: PublishedState? = nil, statusMessage: String? = nil, uploadState: UploadState? = nil, version: Int64? = nil) {
            self.acceptanceType = acceptanceType
            self.arn = arn
            self.category = category
            self.companyName = companyName
            self.description = description
            self.id = id
            self.name = name
            self.periodEnd = periodEnd
            self.periodStart = periodStart
            self.productName = productName
            self.series = series
            self.state = state
            self.statusMessage = statusMessage
            self.uploadState = uploadState
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceType = "acceptanceType"
            case arn = "arn"
            case category = "category"
            case companyName = "companyName"
            case description = "description"
            case id = "id"
            case name = "name"
            case periodEnd = "periodEnd"
            case periodStart = "periodStart"
            case productName = "productName"
            case series = "series"
            case state = "state"
            case statusMessage = "statusMessage"
            case uploadState = "uploadState"
            case version = "version"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// Identifier of the affected resource.
        public let resourceId: String
        /// Type of the affected resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// Code for the affected quota.
        public let quotaCode: String
        /// Identifier of the affected resource.
        public let resourceId: String
        /// Type of the affected resource.
        public let resourceType: String
        /// Code for the affected service.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// Code for the affected quota.
        public let quotaCode: String?
        /// Number of seconds in which the caller can retry the request.
        public let retryAfterSeconds: Int?
        /// Code for the affected service.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field that caused the error, if applicable.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// Reason the request failed validation.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// Message describing why the field failed validation.
        public let message: String
        /// Name of validation exception.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for Artifact
public struct ArtifactErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Artifact
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Request to create/modify content would result in a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unknown server exception has occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Request fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension ArtifactErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Artifact.ConflictException.self,
        "InternalServerException": Artifact.InternalServerException.self,
        "ResourceNotFoundException": Artifact.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Artifact.ServiceQuotaExceededException.self,
        "ThrottlingException": Artifact.ThrottlingException.self,
        "ValidationException": Artifact.ValidationException.self
    ]
}

extension ArtifactErrorType: Equatable {
    public static func == (lhs: ArtifactErrorType, rhs: ArtifactErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ArtifactErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
