//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PartnerCentralChannel {
    // MARK: Enums

    public enum AssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `internal` = "INTERNAL"
        case downstreamSeller = "DOWNSTREAM_SELLER"
        case endCustomer = "END_CUSTOMER"
        public var description: String { return self.rawValue }
    }

    public enum Coverage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case entireOrganization = "ENTIRE_ORGANIZATION"
        case managementAccountOnly = "MANAGEMENT_ACCOUNT_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum HandshakeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case canceled = "CANCELED"
        case expired = "EXPIRED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum HandshakeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case programManagementAccount = "PROGRAM_MANAGEMENT_ACCOUNT"
        case revokeServicePeriod = "REVOKE_SERVICE_PERIOD"
        case startServicePeriod = "START_SERVICE_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum ListProgramManagementAccountsSortName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case updatedAt = "UpdatedAt"
        public var description: String { return self.rawValue }
    }

    public enum ListRelationshipsSortName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case updatedAt = "UpdatedAt"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case receiver = "RECEIVER"
        case sender = "SENDER"
        public var description: String { return self.rawValue }
    }

    public enum Program: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case distribution = "DISTRIBUTION"
        case distributionSeller = "DISTRIBUTION_SELLER"
        case solutionProvider = "SOLUTION_PROVIDER"
        public var description: String { return self.rawValue }
    }

    public enum ProgramManagementAccountStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ProgramManagementAccountTypeSortName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case updatedAt = "UpdatedAt"
        public var description: String { return self.rawValue }
    }

    public enum Provider: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case distributionSeller = "DISTRIBUTION_SELLER"
        case distributor = "DISTRIBUTOR"
        public var description: String { return self.rawValue }
    }

    public enum ResaleAccountModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case distributor = "DISTRIBUTOR"
        case endCustomer = "END_CUSTOMER"
        case solutionProvider = "SOLUTION_PROVIDER"
        public var description: String { return self.rawValue }
    }

    public enum RevokeServicePeriodTypeSortName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case updatedAt = "UpdatedAt"
        public var description: String { return self.rawValue }
    }

    public enum Sector: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case commercial = "COMMERCIAL"
        case government = "GOVERNMENT"
        case governmentException = "GOVERNMENT_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum ServicePeriodType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedCommitmentPeriod = "FIXED_COMMITMENT_PERIOD"
        case minimumNoticePeriod = "MINIMUM_NOTICE_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum StartServicePeriodTypeSortName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case updatedAt = "UpdatedAt"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessValidationFailed = "BUSINESS_VALIDATION_FAILED"
        case requestValidationFailed = "REQUEST_VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ChannelHandshakePayload: AWSEncodableShape, Sendable {
        /// Payload for revoking a service period handshake.
        case revokeServicePeriodPayload(RevokeServicePeriodPayload)
        /// Payload for starting a service period handshake.
        case startServicePeriodPayload(StartServicePeriodPayload)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .revokeServicePeriodPayload(let value):
                try container.encode(value, forKey: .revokeServicePeriodPayload)
            case .startServicePeriodPayload(let value):
                try container.encode(value, forKey: .startServicePeriodPayload)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .revokeServicePeriodPayload(let value):
                try value.validate(name: "\(name).revokeServicePeriodPayload")
            case .startServicePeriodPayload(let value):
                try value.validate(name: "\(name).startServicePeriodPayload")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case revokeServicePeriodPayload = "revokeServicePeriodPayload"
            case startServicePeriodPayload = "startServicePeriodPayload"
        }
    }

    public enum HandshakeDetail: AWSDecodableShape, Sendable {
        /// Details for a program management account handshake.
        case programManagementAccountHandshakeDetail(ProgramManagementAccountHandshakeDetail)
        /// Details for a revoke service period handshake.
        case revokeServicePeriodHandshakeDetail(RevokeServicePeriodHandshakeDetail)
        /// Details for a start service period handshake.
        case startServicePeriodHandshakeDetail(StartServicePeriodHandshakeDetail)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .programManagementAccountHandshakeDetail:
                let value = try container.decode(ProgramManagementAccountHandshakeDetail.self, forKey: .programManagementAccountHandshakeDetail)
                self = .programManagementAccountHandshakeDetail(value)
            case .revokeServicePeriodHandshakeDetail:
                let value = try container.decode(RevokeServicePeriodHandshakeDetail.self, forKey: .revokeServicePeriodHandshakeDetail)
                self = .revokeServicePeriodHandshakeDetail(value)
            case .startServicePeriodHandshakeDetail:
                let value = try container.decode(StartServicePeriodHandshakeDetail.self, forKey: .startServicePeriodHandshakeDetail)
                self = .startServicePeriodHandshakeDetail(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case programManagementAccountHandshakeDetail = "programManagementAccountHandshakeDetail"
            case revokeServicePeriodHandshakeDetail = "revokeServicePeriodHandshakeDetail"
            case startServicePeriodHandshakeDetail = "startServicePeriodHandshakeDetail"
        }
    }

    public enum ListChannelHandshakesTypeFilters: AWSEncodableShape, Sendable {
        /// Filters specific to program management account handshakes.
        case programManagementAccountTypeFilters(ProgramManagementAccountTypeFilters)
        /// Filters specific to revoke service period handshakes.
        case revokeServicePeriodTypeFilters(RevokeServicePeriodTypeFilters)
        /// Filters specific to start service period handshakes.
        case startServicePeriodTypeFilters(StartServicePeriodTypeFilters)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .programManagementAccountTypeFilters(let value):
                try container.encode(value, forKey: .programManagementAccountTypeFilters)
            case .revokeServicePeriodTypeFilters(let value):
                try container.encode(value, forKey: .revokeServicePeriodTypeFilters)
            case .startServicePeriodTypeFilters(let value):
                try container.encode(value, forKey: .startServicePeriodTypeFilters)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case programManagementAccountTypeFilters = "programManagementAccountTypeFilters"
            case revokeServicePeriodTypeFilters = "revokeServicePeriodTypeFilters"
            case startServicePeriodTypeFilters = "startServicePeriodTypeFilters"
        }
    }

    public enum ListChannelHandshakesTypeSort: AWSEncodableShape, Sendable {
        /// Sorting options specific to program management account handshakes.
        case programManagementAccountTypeSort(ProgramManagementAccountTypeSort)
        /// Sorting options specific to revoke service period handshakes.
        case revokeServicePeriodTypeSort(RevokeServicePeriodTypeSort)
        /// Sorting options specific to start service period handshakes.
        case startServicePeriodTypeSort(StartServicePeriodTypeSort)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .programManagementAccountTypeSort(let value):
                try container.encode(value, forKey: .programManagementAccountTypeSort)
            case .revokeServicePeriodTypeSort(let value):
                try container.encode(value, forKey: .revokeServicePeriodTypeSort)
            case .startServicePeriodTypeSort(let value):
                try container.encode(value, forKey: .startServicePeriodTypeSort)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case programManagementAccountTypeSort = "programManagementAccountTypeSort"
            case revokeServicePeriodTypeSort = "revokeServicePeriodTypeSort"
            case startServicePeriodTypeSort = "startServicePeriodTypeSort"
        }
    }

    public enum SupportPlan: AWSEncodableShape, Sendable {
        /// Configuration for partner-led support plans.
        case partnerLedSupport(PartnerLedSupport)
        /// Configuration for resold business support plans.
        case resoldBusiness(ResoldBusiness)
        /// Configuration for resold enterprise support plans.
        case resoldEnterprise(ResoldEnterprise)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .partnerLedSupport(let value):
                try container.encode(value, forKey: .partnerLedSupport)
            case .resoldBusiness(let value):
                try container.encode(value, forKey: .resoldBusiness)
            case .resoldEnterprise(let value):
                try container.encode(value, forKey: .resoldEnterprise)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .resoldEnterprise(let value):
                try value.validate(name: "\(name).resoldEnterprise")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case partnerLedSupport = "partnerLedSupport"
            case resoldBusiness = "resoldBusiness"
            case resoldEnterprise = "resoldEnterprise"
        }
    }

    // MARK: Shapes

    public struct AcceptChannelHandshakeDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the accepted handshake.
        public let arn: String?
        /// The unique identifier of the accepted handshake.
        public let id: String?
        /// The current status of the accepted handshake.
        public let status: HandshakeStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: HandshakeStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct AcceptChannelHandshakeRequest: AWSEncodableShape {
        /// The catalog identifier for the handshake request.
        public let catalog: String
        /// The unique identifier of the channel handshake to accept.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 16)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/channel-handshake/)?ch-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case identifier = "identifier"
        }
    }

    public struct AcceptChannelHandshakeResponse: AWSDecodableShape {
        /// Details of the accepted channel handshake.
        public let channelHandshakeDetail: AcceptChannelHandshakeDetail?

        @inlinable
        public init(channelHandshakeDetail: AcceptChannelHandshakeDetail? = nil) {
            self.channelHandshakeDetail = channelHandshakeDetail
        }

        private enum CodingKeys: String, CodingKey {
            case channelHandshakeDetail = "channelHandshakeDetail"
        }
    }

    public struct AccessDeniedException: AWSErrorShape {
        /// A message describing the access denial.
        public let message: String
        /// The reason for the access denial.
        public let reason: String?

        @inlinable
        public init(message: String, reason: String? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }

    public struct CancelChannelHandshakeDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the canceled handshake.
        public let arn: String?
        /// The unique identifier of the canceled handshake.
        public let id: String?
        /// The current status of the canceled handshake.
        public let status: HandshakeStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: HandshakeStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct CancelChannelHandshakeRequest: AWSEncodableShape {
        /// The catalog identifier for the handshake request.
        public let catalog: String
        /// The unique identifier of the channel handshake to cancel.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 16)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/channel-handshake/)?ch-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case identifier = "identifier"
        }
    }

    public struct CancelChannelHandshakeResponse: AWSDecodableShape {
        /// Details of the canceled channel handshake.
        public let channelHandshakeDetail: CancelChannelHandshakeDetail?

        @inlinable
        public init(channelHandshakeDetail: CancelChannelHandshakeDetail? = nil) {
            self.channelHandshakeDetail = channelHandshakeDetail
        }

        private enum CodingKeys: String, CodingKey {
            case channelHandshakeDetail = "channelHandshakeDetail"
        }
    }

    public struct ChannelHandshakeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the handshake.
        public let arn: String?
        /// The identifier of the resource associated with the handshake.
        public let associatedResourceId: String?
        /// The catalog identifier associated with the handshake.
        public let catalog: String?
        /// The timestamp when the handshake was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// Detailed information about the handshake.
        public let detail: HandshakeDetail?
        /// The type of the handshake.
        public let handshakeType: HandshakeType?
        /// The unique identifier of the handshake.
        public let id: String?
        /// The AWS account ID of the handshake owner.
        public let ownerAccountId: String?
        /// The AWS account ID of the handshake receiver.
        public let receiverAccountId: String?
        /// The AWS account ID of the handshake sender.
        public let senderAccountId: String?
        /// The display name of the handshake sender.
        public let senderDisplayName: String?
        /// The current status of the handshake.
        public let status: HandshakeStatus?
        /// The timestamp when the handshake was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, associatedResourceId: String? = nil, catalog: String? = nil, createdAt: Date? = nil, detail: HandshakeDetail? = nil, handshakeType: HandshakeType? = nil, id: String? = nil, ownerAccountId: String? = nil, receiverAccountId: String? = nil, senderAccountId: String? = nil, senderDisplayName: String? = nil, status: HandshakeStatus? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.associatedResourceId = associatedResourceId
            self.catalog = catalog
            self.createdAt = createdAt
            self.detail = detail
            self.handshakeType = handshakeType
            self.id = id
            self.ownerAccountId = ownerAccountId
            self.receiverAccountId = receiverAccountId
            self.senderAccountId = senderAccountId
            self.senderDisplayName = senderDisplayName
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associatedResourceId = "associatedResourceId"
            case catalog = "catalog"
            case createdAt = "createdAt"
            case detail = "detail"
            case handshakeType = "handshakeType"
            case id = "id"
            case ownerAccountId = "ownerAccountId"
            case receiverAccountId = "receiverAccountId"
            case senderAccountId = "senderAccountId"
            case senderDisplayName = "senderDisplayName"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// A message describing the conflict.
        public let message: String
        /// The identifier of the resource that caused the conflict.
        public let resourceId: String
        /// The type of the resource that caused the conflict.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateChannelHandshakeDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created handshake.
        public let arn: String?
        /// The unique identifier of the created handshake.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct CreateChannelHandshakeRequest: AWSEncodableShape {
        /// The identifier of the resource associated with this handshake.
        public let associatedResourceIdentifier: String
        /// The catalog identifier for the handshake request.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The type of handshake to create (e.g., start service period, revoke service period).
        public let handshakeType: HandshakeType
        /// The payload containing specific details for the handshake type.
        public let payload: ChannelHandshakePayload?
        /// Key-value pairs to associate with the channel handshake.
        public let tags: [Tag]?

        @inlinable
        public init(associatedResourceIdentifier: String, catalog: String, clientToken: String? = CreateChannelHandshakeRequest.idempotencyToken(), handshakeType: HandshakeType, payload: ChannelHandshakePayload? = nil, tags: [Tag]? = nil) {
            self.associatedResourceIdentifier = associatedResourceIdentifier
            self.catalog = catalog
            self.clientToken = clientToken
            self.handshakeType = handshakeType
            self.payload = payload
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.associatedResourceIdentifier, name: "associatedResourceIdentifier", parent: name, max: 1011)
            try self.validate(self.associatedResourceIdentifier, name: "associatedResourceIdentifier", parent: name, min: 16)
            try self.validate(self.associatedResourceIdentifier, name: "associatedResourceIdentifier", parent: name, pattern: "^((arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/pma-[a-z0-9]{13}(/relationship/rs-[a-z0-9]{13})?)|(pma|rs)-[a-z0-9]{13})$")
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.payload?.validate(name: "\(name).payload")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceIdentifier = "associatedResourceIdentifier"
            case catalog = "catalog"
            case clientToken = "clientToken"
            case handshakeType = "handshakeType"
            case payload = "payload"
            case tags = "tags"
        }
    }

    public struct CreateChannelHandshakeResponse: AWSDecodableShape {
        /// Details of the created channel handshake.
        public let channelHandshakeDetail: CreateChannelHandshakeDetail?

        @inlinable
        public init(channelHandshakeDetail: CreateChannelHandshakeDetail? = nil) {
            self.channelHandshakeDetail = channelHandshakeDetail
        }

        private enum CodingKeys: String, CodingKey {
            case channelHandshakeDetail = "channelHandshakeDetail"
        }
    }

    public struct CreateProgramManagementAccountDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created program management account.
        public let arn: String?
        /// The unique identifier of the created program management account.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct CreateProgramManagementAccountRequest: AWSEncodableShape {
        /// The AWS account ID to associate with the program management account.
        public let accountId: String
        /// The catalog identifier for the program management account.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A human-readable name for the program management account.
        public let displayName: String
        /// The program type for the management account.
        public let program: Program
        /// Key-value pairs to associate with the program management account.
        public let tags: [Tag]?

        @inlinable
        public init(accountId: String, catalog: String, clientToken: String? = CreateProgramManagementAccountRequest.idempotencyToken(), displayName: String, program: Program, tags: [Tag]? = nil) {
            self.accountId = accountId
            self.catalog = catalog
            self.clientToken = clientToken
            self.displayName = displayName
            self.program = program
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]*$")
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 30)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case catalog = "catalog"
            case clientToken = "clientToken"
            case displayName = "displayName"
            case program = "program"
            case tags = "tags"
        }
    }

    public struct CreateProgramManagementAccountResponse: AWSDecodableShape {
        /// Details of the created program management account.
        public let programManagementAccountDetail: CreateProgramManagementAccountDetail?

        @inlinable
        public init(programManagementAccountDetail: CreateProgramManagementAccountDetail? = nil) {
            self.programManagementAccountDetail = programManagementAccountDetail
        }

        private enum CodingKeys: String, CodingKey {
            case programManagementAccountDetail = "programManagementAccountDetail"
        }
    }

    public struct CreateRelationshipDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created relationship.
        public let arn: String?
        /// The unique identifier of the created relationship.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct CreateRelationshipRequest: AWSEncodableShape {
        /// The AWS account ID to associate in this relationship.
        public let associatedAccountId: String
        /// The type of association for the relationship (e.g., reseller, distributor).
        public let associationType: AssociationType
        /// The catalog identifier for the relationship.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A human-readable name for the relationship.
        public let displayName: String
        /// The identifier of the program management account for this relationship.
        public let programManagementAccountIdentifier: String
        /// The support plan requested for this relationship.
        public let requestedSupportPlan: SupportPlan?
        /// The resale account model for the relationship.
        public let resaleAccountModel: ResaleAccountModel?
        /// The business sector for the relationship.
        public let sector: Sector
        /// Key-value pairs to associate with the relationship.
        public let tags: [Tag]?

        @inlinable
        public init(associatedAccountId: String, associationType: AssociationType, catalog: String, clientToken: String? = CreateRelationshipRequest.idempotencyToken(), displayName: String, programManagementAccountIdentifier: String, requestedSupportPlan: SupportPlan? = nil, resaleAccountModel: ResaleAccountModel? = nil, sector: Sector, tags: [Tag]? = nil) {
            self.associatedAccountId = associatedAccountId
            self.associationType = associationType
            self.catalog = catalog
            self.clientToken = clientToken
            self.displayName = displayName
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
            self.requestedSupportPlan = requestedSupportPlan
            self.resaleAccountModel = resaleAccountModel
            self.sector = sector
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.associatedAccountId, name: "associatedAccountId", parent: name, max: 12)
            try self.validate(self.associatedAccountId, name: "associatedAccountId", parent: name, min: 12)
            try self.validate(self.associatedAccountId, name: "associatedAccountId", parent: name, pattern: "^[0-9]*$")
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 30)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, max: 1011)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, min: 17)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
            try self.requestedSupportPlan?.validate(name: "\(name).requestedSupportPlan")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAccountId = "associatedAccountId"
            case associationType = "associationType"
            case catalog = "catalog"
            case clientToken = "clientToken"
            case displayName = "displayName"
            case programManagementAccountIdentifier = "programManagementAccountIdentifier"
            case requestedSupportPlan = "requestedSupportPlan"
            case resaleAccountModel = "resaleAccountModel"
            case sector = "sector"
            case tags = "tags"
        }
    }

    public struct CreateRelationshipResponse: AWSDecodableShape {
        /// Details of the created relationship.
        public let relationshipDetail: CreateRelationshipDetail?

        @inlinable
        public init(relationshipDetail: CreateRelationshipDetail? = nil) {
            self.relationshipDetail = relationshipDetail
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipDetail = "relationshipDetail"
        }
    }

    public struct DeleteProgramManagementAccountRequest: AWSEncodableShape {
        /// The catalog identifier for the program management account.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the program management account to delete.
        public let identifier: String

        @inlinable
        public init(catalog: String, clientToken: String? = DeleteProgramManagementAccountRequest.idempotencyToken(), identifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 17)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case clientToken = "clientToken"
            case identifier = "identifier"
        }
    }

    public struct DeleteProgramManagementAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRelationshipRequest: AWSEncodableShape {
        /// The catalog identifier for the relationship.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the relationship to delete.
        public let identifier: String
        /// The identifier of the program management account associated with the relationship.
        public let programManagementAccountIdentifier: String

        @inlinable
        public init(catalog: String, clientToken: String? = DeleteRelationshipRequest.idempotencyToken(), identifier: String, programManagementAccountIdentifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 16)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/pma-[a-z0-9]{13}/relationship/)?rs-[a-z0-9]{13}$")
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, max: 1011)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, min: 17)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case clientToken = "clientToken"
            case identifier = "identifier"
            case programManagementAccountIdentifier = "programManagementAccountIdentifier"
        }
    }

    public struct DeleteRelationshipResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetRelationshipRequest: AWSEncodableShape {
        /// The catalog identifier for the relationship.
        public let catalog: String
        /// The unique identifier of the relationship to retrieve.
        public let identifier: String
        /// The identifier of the program management account associated with the relationship.
        public let programManagementAccountIdentifier: String

        @inlinable
        public init(catalog: String, identifier: String, programManagementAccountIdentifier: String) {
            self.catalog = catalog
            self.identifier = identifier
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 16)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/pma-[a-z0-9]{13}/relationship/)?rs-[a-z0-9]{13}$")
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, max: 1011)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, min: 17)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case identifier = "identifier"
            case programManagementAccountIdentifier = "programManagementAccountIdentifier"
        }
    }

    public struct GetRelationshipResponse: AWSDecodableShape {
        /// Details of the requested relationship.
        public let relationshipDetail: RelationshipDetail?

        @inlinable
        public init(relationshipDetail: RelationshipDetail? = nil) {
            self.relationshipDetail = relationshipDetail
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipDetail = "relationshipDetail"
        }
    }

    public struct ListChannelHandshakesRequest: AWSEncodableShape {
        /// Filter by associated resource identifiers.
        public let associatedResourceIdentifiers: [String]?
        /// The catalog identifier to filter handshakes.
        public let catalog: String
        /// Filter results by handshake type.
        public let handshakeType: HandshakeType
        /// Type-specific filters for handshakes.
        public let handshakeTypeFilters: ListChannelHandshakesTypeFilters?
        /// Type-specific sorting options for handshakes.
        public let handshakeTypeSort: ListChannelHandshakesTypeSort?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for retrieving the next page of results.
        public let nextToken: String?
        /// Filter by participant type (sender or receiver).
        public let participantType: ParticipantType
        /// Filter results by handshake status.
        public let statuses: [HandshakeStatus]?

        @inlinable
        public init(associatedResourceIdentifiers: [String]? = nil, catalog: String, handshakeType: HandshakeType, handshakeTypeFilters: ListChannelHandshakesTypeFilters? = nil, handshakeTypeSort: ListChannelHandshakesTypeSort? = nil, maxResults: Int? = nil, nextToken: String? = nil, participantType: ParticipantType, statuses: [HandshakeStatus]? = nil) {
            self.associatedResourceIdentifiers = associatedResourceIdentifiers
            self.catalog = catalog
            self.handshakeType = handshakeType
            self.handshakeTypeFilters = handshakeTypeFilters
            self.handshakeTypeSort = handshakeTypeSort
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.participantType = participantType
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.associatedResourceIdentifiers?.forEach {
                try validate($0, name: "associatedResourceIdentifiers[]", parent: name, max: 1011)
                try validate($0, name: "associatedResourceIdentifiers[]", parent: name, min: 16)
                try validate($0, name: "associatedResourceIdentifiers[]", parent: name, pattern: "^((arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/pma-[a-z0-9]{13}(/relationship/rs-[a-z0-9]{13})?)|(pma|rs)-[a-z0-9]{13})$")
            }
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[^\\x00-\\x1F\\x7F\\x20]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceIdentifiers = "associatedResourceIdentifiers"
            case catalog = "catalog"
            case handshakeType = "handshakeType"
            case handshakeTypeFilters = "handshakeTypeFilters"
            case handshakeTypeSort = "handshakeTypeSort"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case participantType = "participantType"
            case statuses = "statuses"
        }
    }

    public struct ListChannelHandshakesResponse: AWSDecodableShape {
        /// List of channel handshakes matching the criteria.
        public let items: [ChannelHandshakeSummary]?
        /// Token for retrieving the next page of results, if available.
        public let nextToken: String?

        @inlinable
        public init(items: [ChannelHandshakeSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListProgramManagementAccountsRequest: AWSEncodableShape {
        /// Filter by AWS account IDs.
        public let accountIds: [String]?
        /// The catalog identifier to filter accounts.
        public let catalog: String
        /// Filter by display names.
        public let displayNames: [String]?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for retrieving the next page of results.
        public let nextToken: String?
        /// Filter by program types.
        public let programs: [Program]?
        /// Sorting options for the results.
        public let sort: ListProgramManagementAccountsSortBase?
        /// Filter by program management account statuses.
        public let statuses: [ProgramManagementAccountStatus]?

        @inlinable
        public init(accountIds: [String]? = nil, catalog: String, displayNames: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, programs: [Program]? = nil, sort: ListProgramManagementAccountsSortBase? = nil, statuses: [ProgramManagementAccountStatus]? = nil) {
            self.accountIds = accountIds
            self.catalog = catalog
            self.displayNames = displayNames
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.programs = programs
            self.sort = sort
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]*$")
            }
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.displayNames?.forEach {
                try validate($0, name: "displayNames[]", parent: name, max: 30)
                try validate($0, name: "displayNames[]", parent: name, min: 1)
                try validate($0, name: "displayNames[]", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[^\\x00-\\x1F\\x7F\\x20]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case catalog = "catalog"
            case displayNames = "displayNames"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case programs = "programs"
            case sort = "sort"
            case statuses = "statuses"
        }
    }

    public struct ListProgramManagementAccountsResponse: AWSDecodableShape {
        /// List of program management accounts matching the criteria.
        public let items: [ProgramManagementAccountSummary]?
        /// Token for retrieving the next page of results, if available.
        public let nextToken: String?

        @inlinable
        public init(items: [ProgramManagementAccountSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListProgramManagementAccountsSortBase: AWSEncodableShape {
        /// The field to sort by.
        public let sortBy: ListProgramManagementAccountsSortName
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder

        @inlinable
        public init(sortBy: ListProgramManagementAccountsSortName, sortOrder: SortOrder) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListRelationshipsRequest: AWSEncodableShape {
        /// Filter by associated AWS account IDs.
        public let associatedAccountIds: [String]?
        /// Filter by association types.
        public let associationTypes: [AssociationType]?
        /// The catalog identifier to filter relationships.
        public let catalog: String
        /// Filter by display names.
        public let displayNames: [String]?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for retrieving the next page of results.
        public let nextToken: String?
        /// Filter by program management account identifiers.
        public let programManagementAccountIdentifiers: [String]?
        /// Sorting options for the results.
        public let sort: ListRelationshipsSortBase?

        @inlinable
        public init(associatedAccountIds: [String]? = nil, associationTypes: [AssociationType]? = nil, catalog: String, displayNames: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, programManagementAccountIdentifiers: [String]? = nil, sort: ListRelationshipsSortBase? = nil) {
            self.associatedAccountIds = associatedAccountIds
            self.associationTypes = associationTypes
            self.catalog = catalog
            self.displayNames = displayNames
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.programManagementAccountIdentifiers = programManagementAccountIdentifiers
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.associatedAccountIds?.forEach {
                try validate($0, name: "associatedAccountIds[]", parent: name, max: 12)
                try validate($0, name: "associatedAccountIds[]", parent: name, min: 12)
                try validate($0, name: "associatedAccountIds[]", parent: name, pattern: "^[0-9]*$")
            }
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.displayNames?.forEach {
                try validate($0, name: "displayNames[]", parent: name, max: 30)
                try validate($0, name: "displayNames[]", parent: name, min: 1)
                try validate($0, name: "displayNames[]", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[^\\x00-\\x1F\\x7F\\x20]*$")
            try self.programManagementAccountIdentifiers?.forEach {
                try validate($0, name: "programManagementAccountIdentifiers[]", parent: name, max: 1011)
                try validate($0, name: "programManagementAccountIdentifiers[]", parent: name, min: 17)
                try validate($0, name: "programManagementAccountIdentifiers[]", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAccountIds = "associatedAccountIds"
            case associationTypes = "associationTypes"
            case catalog = "catalog"
            case displayNames = "displayNames"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case programManagementAccountIdentifiers = "programManagementAccountIdentifiers"
            case sort = "sort"
        }
    }

    public struct ListRelationshipsResponse: AWSDecodableShape {
        /// List of relationships matching the criteria.
        public let items: [RelationshipSummary]?
        /// Token for retrieving the next page of results, if available.
        public let nextToken: String?

        @inlinable
        public init(items: [RelationshipSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRelationshipsSortBase: AWSEncodableShape {
        /// The field to sort by.
        public let sortBy: ListRelationshipsSortName
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder

        @inlinable
        public init(sortBy: ListRelationshipsSortName, sortOrder: SortOrder) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/(program-management-account/pma-[a-z0-9]{13}(/relationship/rs-[a-z0-9]{13})?|channel-handshake/ch-[a-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Key-value pairs associated with the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PartnerLedSupport: AWSEncodableShape {
        /// The coverage level for partner-led support.
        public let coverage: Coverage
        /// The provider of the partner-led support.
        public let provider: Provider?
        /// The location of the Technical Account Manager (TAM).
        public let tamLocation: String

        @inlinable
        public init(coverage: Coverage, provider: Provider? = nil, tamLocation: String) {
            self.coverage = coverage
            self.provider = provider
            self.tamLocation = tamLocation
        }

        private enum CodingKeys: String, CodingKey {
            case coverage = "coverage"
            case provider = "provider"
            case tamLocation = "tamLocation"
        }
    }

    public struct ProgramManagementAccountHandshakeDetail: AWSDecodableShape {
        /// The program associated with the handshake.
        public let program: Program?

        @inlinable
        public init(program: Program? = nil) {
            self.program = program
        }

        private enum CodingKeys: String, CodingKey {
            case program = "program"
        }
    }

    public struct ProgramManagementAccountSummary: AWSDecodableShape {
        /// The AWS account ID associated with the program management account.
        public let accountId: String?
        /// The Amazon Resource Name (ARN) of the program management account.
        public let arn: String?
        /// The catalog identifier associated with the account.
        public let catalog: String?
        /// The timestamp when the account was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The display name of the program management account.
        public let displayName: String?
        /// The unique identifier of the program management account.
        public let id: String?
        /// The program type for the management account.
        public let program: Program?
        /// The current revision number of the program management account.
        public let revision: String?
        /// The start date of the program management account.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?
        /// The current status of the program management account.
        public let status: ProgramManagementAccountStatus?
        /// The timestamp when the account was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, catalog: String? = nil, createdAt: Date? = nil, displayName: String? = nil, id: String? = nil, program: Program? = nil, revision: String? = nil, startDate: Date? = nil, status: ProgramManagementAccountStatus? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.catalog = catalog
            self.createdAt = createdAt
            self.displayName = displayName
            self.id = id
            self.program = program
            self.revision = revision
            self.startDate = startDate
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case catalog = "catalog"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case id = "id"
            case program = "program"
            case revision = "revision"
            case startDate = "startDate"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ProgramManagementAccountTypeFilters: AWSEncodableShape {
        /// Filter by program types.
        public let programs: [Program]?

        @inlinable
        public init(programs: [Program]? = nil) {
            self.programs = programs
        }

        private enum CodingKeys: String, CodingKey {
            case programs = "programs"
        }
    }

    public struct ProgramManagementAccountTypeSort: AWSEncodableShape {
        /// The field to sort by.
        public let sortBy: ProgramManagementAccountTypeSortName
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder

        @inlinable
        public init(sortBy: ProgramManagementAccountTypeSortName, sortOrder: SortOrder) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct RejectChannelHandshakeDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rejected handshake.
        public let arn: String?
        /// The unique identifier of the rejected handshake.
        public let id: String?
        /// The current status of the rejected handshake.
        public let status: HandshakeStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: HandshakeStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct RejectChannelHandshakeRequest: AWSEncodableShape {
        /// The catalog identifier for the handshake request.
        public let catalog: String
        /// The unique identifier of the channel handshake to reject.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 16)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/channel-handshake/)?ch-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case identifier = "identifier"
        }
    }

    public struct RejectChannelHandshakeResponse: AWSDecodableShape {
        /// Details of the rejected channel handshake.
        public let channelHandshakeDetail: RejectChannelHandshakeDetail?

        @inlinable
        public init(channelHandshakeDetail: RejectChannelHandshakeDetail? = nil) {
            self.channelHandshakeDetail = channelHandshakeDetail
        }

        private enum CodingKeys: String, CodingKey {
            case channelHandshakeDetail = "channelHandshakeDetail"
        }
    }

    public struct RelationshipDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the relationship.
        public let arn: String?
        /// The AWS account ID associated in this relationship.
        public let associatedAccountId: String?
        /// The type of association for the relationship.
        public let associationType: AssociationType?
        /// The catalog identifier associated with the relationship.
        public let catalog: String?
        /// The timestamp when the relationship was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The display name of the relationship.
        public let displayName: String?
        /// The unique identifier of the relationship.
        public let id: String?
        /// The identifier of the program management account.
        public let programManagementAccountId: String?
        /// The resale account model for the relationship.
        public let resaleAccountModel: ResaleAccountModel?
        /// The current revision number of the relationship.
        public let revision: String?
        /// The business sector for the relationship.
        public let sector: Sector?
        /// The start date of the relationship.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?
        /// The timestamp when the relationship was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, associatedAccountId: String? = nil, associationType: AssociationType? = nil, catalog: String? = nil, createdAt: Date? = nil, displayName: String? = nil, id: String? = nil, programManagementAccountId: String? = nil, resaleAccountModel: ResaleAccountModel? = nil, revision: String? = nil, sector: Sector? = nil, startDate: Date? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.associatedAccountId = associatedAccountId
            self.associationType = associationType
            self.catalog = catalog
            self.createdAt = createdAt
            self.displayName = displayName
            self.id = id
            self.programManagementAccountId = programManagementAccountId
            self.resaleAccountModel = resaleAccountModel
            self.revision = revision
            self.sector = sector
            self.startDate = startDate
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associatedAccountId = "associatedAccountId"
            case associationType = "associationType"
            case catalog = "catalog"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case id = "id"
            case programManagementAccountId = "programManagementAccountId"
            case resaleAccountModel = "resaleAccountModel"
            case revision = "revision"
            case sector = "sector"
            case startDate = "startDate"
            case updatedAt = "updatedAt"
        }
    }

    public struct RelationshipSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the relationship.
        public let arn: String?
        /// The AWS account ID associated in this relationship.
        public let associatedAccountId: String?
        /// The type of association for the relationship.
        public let associationType: AssociationType?
        /// The catalog identifier associated with the relationship.
        public let catalog: String?
        /// The timestamp when the relationship was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The display name of the relationship.
        public let displayName: String?
        /// The unique identifier of the relationship.
        public let id: String?
        /// The identifier of the program management account.
        public let programManagementAccountId: String?
        /// The current revision number of the relationship.
        public let revision: String?
        /// The business sector for the relationship.
        public let sector: Sector?
        /// The start date of the relationship.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?
        /// The timestamp when the relationship was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, associatedAccountId: String? = nil, associationType: AssociationType? = nil, catalog: String? = nil, createdAt: Date? = nil, displayName: String? = nil, id: String? = nil, programManagementAccountId: String? = nil, revision: String? = nil, sector: Sector? = nil, startDate: Date? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.associatedAccountId = associatedAccountId
            self.associationType = associationType
            self.catalog = catalog
            self.createdAt = createdAt
            self.displayName = displayName
            self.id = id
            self.programManagementAccountId = programManagementAccountId
            self.revision = revision
            self.sector = sector
            self.startDate = startDate
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case associatedAccountId = "associatedAccountId"
            case associationType = "associationType"
            case catalog = "catalog"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case id = "id"
            case programManagementAccountId = "programManagementAccountId"
            case revision = "revision"
            case sector = "sector"
            case startDate = "startDate"
            case updatedAt = "updatedAt"
        }
    }

    public struct ResoldBusiness: AWSEncodableShape {
        /// The coverage level for resold business support.
        public let coverage: Coverage

        @inlinable
        public init(coverage: Coverage) {
            self.coverage = coverage
        }

        private enum CodingKeys: String, CodingKey {
            case coverage = "coverage"
        }
    }

    public struct ResoldEnterprise: AWSEncodableShape {
        /// The AWS account ID to charge for the support plan.
        public let chargeAccountId: String?
        /// The coverage level for resold enterprise support.
        public let coverage: Coverage
        /// The location of the Technical Account Manager (TAM).
        public let tamLocation: String

        @inlinable
        public init(chargeAccountId: String? = nil, coverage: Coverage, tamLocation: String) {
            self.chargeAccountId = chargeAccountId
            self.coverage = coverage
            self.tamLocation = tamLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.chargeAccountId, name: "chargeAccountId", parent: name, max: 12)
            try self.validate(self.chargeAccountId, name: "chargeAccountId", parent: name, min: 12)
            try self.validate(self.chargeAccountId, name: "chargeAccountId", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case chargeAccountId = "chargeAccountId"
            case coverage = "coverage"
            case tamLocation = "tamLocation"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// A message describing the resource not found error.
        public let message: String
        /// The identifier of the resource that was not found.
        public let resourceId: String?
        /// The type of the resource that was not found.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct RevokeServicePeriodHandshakeDetail: AWSDecodableShape {
        /// The end date of the service period being revoked.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endDate: Date?
        /// The minimum number of days notice required for revocation.
        public let minimumNoticeDays: String?
        /// A note explaining the reason for revoking the service period.
        public let note: String?
        /// The type of service period being revoked.
        public let servicePeriodType: ServicePeriodType?
        /// The start date of the service period being revoked.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?

        @inlinable
        public init(endDate: Date? = nil, minimumNoticeDays: String? = nil, note: String? = nil, servicePeriodType: ServicePeriodType? = nil, startDate: Date? = nil) {
            self.endDate = endDate
            self.minimumNoticeDays = minimumNoticeDays
            self.note = note
            self.servicePeriodType = servicePeriodType
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case minimumNoticeDays = "minimumNoticeDays"
            case note = "note"
            case servicePeriodType = "servicePeriodType"
            case startDate = "startDate"
        }
    }

    public struct RevokeServicePeriodPayload: AWSEncodableShape {
        /// A note explaining the reason for revoking the service period.
        public let note: String?
        /// The identifier of the program management account.
        public let programManagementAccountIdentifier: String

        @inlinable
        public init(note: String? = nil, programManagementAccountIdentifier: String) {
            self.note = note
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.note, name: "note", parent: name, max: 300)
            try self.validate(self.note, name: "note", parent: name, min: 1)
            try self.validate(self.note, name: "note", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, max: 1011)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, min: 17)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case note = "note"
            case programManagementAccountIdentifier = "programManagementAccountIdentifier"
        }
    }

    public struct RevokeServicePeriodTypeFilters: AWSEncodableShape {
        /// Filter by service period types.
        public let servicePeriodTypes: [ServicePeriodType]?

        @inlinable
        public init(servicePeriodTypes: [ServicePeriodType]? = nil) {
            self.servicePeriodTypes = servicePeriodTypes
        }

        private enum CodingKeys: String, CodingKey {
            case servicePeriodTypes = "servicePeriodTypes"
        }
    }

    public struct RevokeServicePeriodTypeSort: AWSEncodableShape {
        /// The field to sort by.
        public let sortBy: RevokeServicePeriodTypeSortName
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder

        @inlinable
        public init(sortBy: RevokeServicePeriodTypeSortName, sortOrder: SortOrder) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// A message describing the service quota exceeded error.
        public let message: String
        /// The code identifying the specific quota that would be exceeded.
        public let quotaCode: String
        /// The identifier of the resource that would exceed the quota.
        public let resourceId: String
        /// The type of the resource that would exceed the quota.
        public let resourceType: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct StartServicePeriodHandshakeDetail: AWSDecodableShape {
        /// The end date of the service period.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endDate: Date?
        /// The minimum number of days notice required for changes.
        public let minimumNoticeDays: String?
        /// A note providing additional information about the service period.
        public let note: String?
        /// The type of service period being started.
        public let servicePeriodType: ServicePeriodType?
        /// The start date of the service period.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startDate: Date?

        @inlinable
        public init(endDate: Date? = nil, minimumNoticeDays: String? = nil, note: String? = nil, servicePeriodType: ServicePeriodType? = nil, startDate: Date? = nil) {
            self.endDate = endDate
            self.minimumNoticeDays = minimumNoticeDays
            self.note = note
            self.servicePeriodType = servicePeriodType
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case minimumNoticeDays = "minimumNoticeDays"
            case note = "note"
            case servicePeriodType = "servicePeriodType"
            case startDate = "startDate"
        }
    }

    public struct StartServicePeriodPayload: AWSEncodableShape {
        /// The end date of the service period.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endDate: Date?
        /// The minimum number of days notice required for changes.
        public let minimumNoticeDays: String?
        /// A note providing additional information about the service period.
        public let note: String?
        /// The identifier of the program management account.
        public let programManagementAccountIdentifier: String
        /// The type of service period being started.
        public let servicePeriodType: ServicePeriodType

        @inlinable
        public init(endDate: Date? = nil, minimumNoticeDays: String? = nil, note: String? = nil, programManagementAccountIdentifier: String, servicePeriodType: ServicePeriodType) {
            self.endDate = endDate
            self.minimumNoticeDays = minimumNoticeDays
            self.note = note
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
            self.servicePeriodType = servicePeriodType
        }

        public func validate(name: String) throws {
            try self.validate(self.minimumNoticeDays, name: "minimumNoticeDays", parent: name, max: 10)
            try self.validate(self.minimumNoticeDays, name: "minimumNoticeDays", parent: name, min: 1)
            try self.validate(self.minimumNoticeDays, name: "minimumNoticeDays", parent: name, pattern: "^[0-9]*$")
            try self.validate(self.note, name: "note", parent: name, max: 300)
            try self.validate(self.note, name: "note", parent: name, min: 1)
            try self.validate(self.note, name: "note", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, max: 1011)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, min: 17)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "endDate"
            case minimumNoticeDays = "minimumNoticeDays"
            case note = "note"
            case programManagementAccountIdentifier = "programManagementAccountIdentifier"
            case servicePeriodType = "servicePeriodType"
        }
    }

    public struct StartServicePeriodTypeFilters: AWSEncodableShape {
        /// Filter by service period types.
        public let servicePeriodTypes: [ServicePeriodType]?

        @inlinable
        public init(servicePeriodTypes: [ServicePeriodType]? = nil) {
            self.servicePeriodTypes = servicePeriodTypes
        }

        private enum CodingKeys: String, CodingKey {
            case servicePeriodTypes = "servicePeriodTypes"
        }
    }

    public struct StartServicePeriodTypeSort: AWSEncodableShape {
        /// The field to sort by.
        public let sortBy: StartServicePeriodTypeSortName
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder

        @inlinable
        public init(sortBy: StartServicePeriodTypeSortName, sortOrder: SortOrder) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceArn: String
        /// Key-value pairs to associate with the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/(program-management-account/pma-[a-z0-9]{13}(/relationship/rs-[a-z0-9]{13})?|channel-handshake/ch-[a-z0-9]{13})$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        /// A message describing the throttling error.
        public let message: String
        /// The quota code associated with the throttling error.
        public let quotaCode: String?
        /// The service code associated with the throttling error.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from.
        public let resourceArn: String
        /// The keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/(program-management-account/pma-[a-z0-9]{13}(/relationship/rs-[a-z0-9]{13})?|channel-handshake/ch-[a-z0-9]{13})$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateProgramManagementAccountDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated program management account.
        public let arn: String?
        /// The updated display name of the program management account.
        public let displayName: String?
        /// The unique identifier of the updated program management account.
        public let id: String?
        /// The new revision number of the program management account.
        public let revision: String?

        @inlinable
        public init(arn: String? = nil, displayName: String? = nil, id: String? = nil, revision: String? = nil) {
            self.arn = arn
            self.displayName = displayName
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case displayName = "displayName"
            case id = "id"
            case revision = "revision"
        }
    }

    public struct UpdateProgramManagementAccountRequest: AWSEncodableShape {
        /// The catalog identifier for the program management account.
        public let catalog: String
        /// The new display name for the program management account.
        public let displayName: String?
        /// The unique identifier of the program management account to update.
        public let identifier: String
        /// The current revision number of the program management account.
        public let revision: String?

        @inlinable
        public init(catalog: String, displayName: String? = nil, identifier: String, revision: String? = nil) {
            self.catalog = catalog
            self.displayName = displayName
            self.identifier = identifier
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 30)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 17)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 10)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
            try self.validate(self.revision, name: "revision", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case displayName = "displayName"
            case identifier = "identifier"
            case revision = "revision"
        }
    }

    public struct UpdateProgramManagementAccountResponse: AWSDecodableShape {
        /// Details of the updated program management account.
        public let programManagementAccountDetail: UpdateProgramManagementAccountDetail?

        @inlinable
        public init(programManagementAccountDetail: UpdateProgramManagementAccountDetail? = nil) {
            self.programManagementAccountDetail = programManagementAccountDetail
        }

        private enum CodingKeys: String, CodingKey {
            case programManagementAccountDetail = "programManagementAccountDetail"
        }
    }

    public struct UpdateRelationshipDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated relationship.
        public let arn: String?
        /// The updated display name of the relationship.
        public let displayName: String?
        /// The unique identifier of the updated relationship.
        public let id: String?
        /// The new revision number of the relationship.
        public let revision: String?

        @inlinable
        public init(arn: String? = nil, displayName: String? = nil, id: String? = nil, revision: String? = nil) {
            self.arn = arn
            self.displayName = displayName
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case displayName = "displayName"
            case id = "id"
            case revision = "revision"
        }
    }

    public struct UpdateRelationshipRequest: AWSEncodableShape {
        /// The catalog identifier for the relationship.
        public let catalog: String
        /// The new display name for the relationship.
        public let displayName: String?
        /// The unique identifier of the relationship to update.
        public let identifier: String
        /// The identifier of the program management account associated with the relationship.
        public let programManagementAccountIdentifier: String
        /// The updated support plan for the relationship.
        public let requestedSupportPlan: SupportPlan?
        /// The current revision number of the relationship.
        public let revision: String?

        @inlinable
        public init(catalog: String, displayName: String? = nil, identifier: String, programManagementAccountIdentifier: String, requestedSupportPlan: SupportPlan? = nil, revision: String? = nil) {
            self.catalog = catalog
            self.displayName = displayName
            self.identifier = identifier
            self.programManagementAccountIdentifier = programManagementAccountIdentifier
            self.requestedSupportPlan = requestedSupportPlan
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 30)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[^\\x00-\\x1F\\x7F]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1011)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 16)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/pma-[a-z0-9]{13}/relationship/)?rs-[a-z0-9]{13}$")
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, max: 1011)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, min: 17)
            try self.validate(self.programManagementAccountIdentifier, name: "programManagementAccountIdentifier", parent: name, pattern: "^(arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[a-zA-Z]+/program-management-account/)?pma-[a-z0-9]{13}$")
            try self.requestedSupportPlan?.validate(name: "\(name).requestedSupportPlan")
            try self.validate(self.revision, name: "revision", parent: name, max: 10)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
            try self.validate(self.revision, name: "revision", parent: name, pattern: "^[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "catalog"
            case displayName = "displayName"
            case identifier = "identifier"
            case programManagementAccountIdentifier = "programManagementAccountIdentifier"
            case requestedSupportPlan = "requestedSupportPlan"
            case revision = "revision"
        }
    }

    public struct UpdateRelationshipResponse: AWSDecodableShape {
        /// Details of the updated relationship.
        public let relationshipDetail: UpdateRelationshipDetail?

        @inlinable
        public init(relationshipDetail: UpdateRelationshipDetail? = nil) {
            self.relationshipDetail = relationshipDetail
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipDetail = "relationshipDetail"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// A list of fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        /// A message describing the validation error.
        public let message: String
        /// The reason for the validation failure.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The validation error code for the field.
        public let code: String
        /// A descriptive message about the validation error.
        public let message: String
        /// The name of the field that failed validation.
        public let name: String

        @inlinable
        public init(code: String, message: String, name: String) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for PartnerCentralChannel
public struct PartnerCentralChannelErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PartnerCentralChannel
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied due to insufficient permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be completed due to a conflict with the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would exceed a service quota limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was throttled due to too many requests being sent in a short period.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request failed validation due to invalid input parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension PartnerCentralChannelErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": PartnerCentralChannel.AccessDeniedException.self,
        "ConflictException": PartnerCentralChannel.ConflictException.self,
        "ResourceNotFoundException": PartnerCentralChannel.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": PartnerCentralChannel.ServiceQuotaExceededException.self,
        "ThrottlingException": PartnerCentralChannel.ThrottlingException.self,
        "ValidationException": PartnerCentralChannel.ValidationException.self
    ]
}

extension PartnerCentralChannelErrorType: Equatable {
    public static func == (lhs: PartnerCentralChannelErrorType, rhs: PartnerCentralChannelErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PartnerCentralChannelErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
