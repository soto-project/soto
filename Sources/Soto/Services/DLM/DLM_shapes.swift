//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DLM {
    // MARK: Enums

    public enum DefaultPoliciesTypeValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case instance = "INSTANCE"
        case volume = "VOLUME"
        public var description: String { return self.rawValue }
    }

    public enum DefaultPolicyTypeValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case instance = "INSTANCE"
        case volume = "VOLUME"
        public var description: String { return self.rawValue }
    }

    public enum EventSourceValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case managedCwe = "MANAGED_CWE"
        public var description: String { return self.rawValue }
    }

    public enum EventTypeValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case shareSnapshot = "shareSnapshot"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionHandlerServiceValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsSystemsManager = "AWS_SYSTEMS_MANAGER"
        public var description: String { return self.rawValue }
    }

    public enum GettablePolicyStateValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum IntervalUnitValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hours = "HOURS"
        public var description: String { return self.rawValue }
    }

    public enum LocationValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case localZone = "LOCAL_ZONE"
        case outpostLocal = "OUTPOST_LOCAL"
        public var description: String { return self.rawValue }
    }

    public enum PolicyLanguageValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case simplified = "SIMPLIFIED"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum PolicyTypeValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebsSnapshotManagement = "EBS_SNAPSHOT_MANAGEMENT"
        case eventBasedPolicy = "EVENT_BASED_POLICY"
        case imageManagement = "IMAGE_MANAGEMENT"
        public var description: String { return self.rawValue }
    }

    public enum ResourceLocationValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case localZone = "LOCAL_ZONE"
        case outpost = "OUTPOST"
        public var description: String { return self.rawValue }
    }

    public enum ResourceTypeValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case instance = "INSTANCE"
        case volume = "VOLUME"
        public var description: String { return self.rawValue }
    }

    public enum RetentionIntervalUnitValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        case months = "MONTHS"
        case weeks = "WEEKS"
        case years = "YEARS"
        public var description: String { return self.rawValue }
    }

    public enum SettablePolicyStateValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StageValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case post = "POST"
        case pre = "PRE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The rule for copying shared snapshots across Regions.
        public let crossRegionCopy: [CrossRegionCopyAction]?
        /// A descriptive name for the action.
        public let name: String?

        @inlinable
        public init(crossRegionCopy: [CrossRegionCopyAction]? = nil, name: String? = nil) {
            self.crossRegionCopy = crossRegionCopy
            self.name = name
        }

        public func validate(name: String) throws {
            try self.crossRegionCopy?.forEach {
                try $0.validate(name: "\(name).crossRegionCopy[]")
            }
            try self.validate(self.crossRegionCopy, name: "crossRegionCopy", parent: name, max: 3)
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z _-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case crossRegionCopy = "CrossRegionCopy"
            case name = "Name"
        }
    }

    public struct ArchiveRetainRule: AWSEncodableShape & AWSDecodableShape {
        /// Information about retention period in the Amazon EBS Snapshots Archive. For more information, see
        /// 			Archive Amazon
        /// 				EBS snapshots.
        public let retentionArchiveTier: RetentionArchiveTier?

        @inlinable
        public init(retentionArchiveTier: RetentionArchiveTier? = nil) {
            self.retentionArchiveTier = retentionArchiveTier
        }

        public func validate(name: String) throws {
            try self.retentionArchiveTier?.validate(name: "\(name).retentionArchiveTier")
        }

        private enum CodingKeys: String, CodingKey {
            case retentionArchiveTier = "RetentionArchiveTier"
        }
    }

    public struct ArchiveRule: AWSEncodableShape & AWSDecodableShape {
        /// Information about the retention period for the snapshot archiving rule.
        public let retainRule: ArchiveRetainRule?

        @inlinable
        public init(retainRule: ArchiveRetainRule? = nil) {
            self.retainRule = retainRule
        }

        public func validate(name: String) throws {
            try self.retainRule?.validate(name: "\(name).retainRule")
        }

        private enum CodingKeys: String, CodingKey {
            case retainRule = "RetainRule"
        }
    }

    public struct CreateLifecyclePolicyRequest: AWSEncodableShape {
        ///  [Default policies only] Indicates whether the policy should copy tags from the source resource
        /// 			to the snapshot or AMI. If you do not specify a value, the default is false. Default: false
        public let copyTags: Bool?
        ///  [Default policies only] Specifies how often the policy should run and create snapshots or AMIs.
        /// 			The creation frequency can range from 1 to 7 days. If you do not specify a value, the
        /// 			default is 1. Default: 1
        public let createInterval: Int?
        ///  [Default policies only] Specifies destination Regions for snapshot or AMI copies. You can specify
        /// 			up to 3 destination Regions. If you do not want to create cross-Region copies, omit this
        /// 			parameter.
        public let crossRegionCopyTargets: [CrossRegionCopyTarget]?
        ///  [Default policies only] Specify the type of default policy to create.   To create a default policy for EBS snapshots, that creates snapshots of all volumes in the
        /// 					Region that do not have recent backups, specify VOLUME.   To create a default policy for EBS-backed AMIs, that creates EBS-backed
        /// 					AMIs from all instances in the Region that do not have recent backups, specify
        /// 					INSTANCE.
        public let defaultPolicy: DefaultPolicyTypeValues?
        /// A description of the lifecycle policy. The characters ^[0-9A-Za-z _-]+$ are
        /// 			supported.
        public let description: String?
        ///  [Default policies only] Specifies exclusion parameters for volumes or instances for which you
        /// 			do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs
        /// 			for target resources that match any of the specified exclusion parameters.
        public let exclusions: Exclusions?
        /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
        /// 			the lifecycle policy.
        public let executionRoleArn: String?
        ///  [Default policies only] Defines the snapshot or AMI retention behavior for the policy if the
        /// 			source volume or instance is deleted, or if the policy enters the error, disabled, or
        /// 			deleted state. By default (ExtendDeletion=false):   If a source resource is deleted, Amazon Data Lifecycle Manager will continue to delete previously
        /// 				created snapshots or AMIs, up to but not including the last one, based on the
        /// 				specified retention period. If you want Amazon Data Lifecycle Manager to delete all snapshots or AMIs,
        /// 				including the last one, specify true.   If a policy enters the error, disabled, or deleted state, Amazon Data Lifecycle Manager stops deleting
        /// 					snapshots and AMIs. If you want Amazon Data Lifecycle Manager to continue deleting snapshots or AMIs,
        /// 					including the last one, if the policy enters one of these states, specify
        /// 					true.   If you enable extended deletion (ExtendDeletion=true),
        /// 			you override both default behaviors simultaneously. If you do not specify a value, the default is false. Default: false
        public let extendDeletion: Bool?
        /// The configuration details of the lifecycle policy.  If you create a default policy, you can specify the request parameters either in
        /// 				the request body, or in the PolicyDetails request structure, but not both.
        public let policyDetails: PolicyDetails?
        ///  [Default policies only] Specifies how long the policy should retain snapshots or AMIs before
        /// 			deleting them. The retention period can range from 2 to 14 days, but it must be greater
        /// 			than the creation frequency to ensure that the policy retains at least 1 snapshot or
        /// 			AMI at any given time. If you do not specify a value, the default is 7. Default: 7
        public let retainInterval: Int?
        /// The activation state of the lifecycle policy after creation.
        public let state: SettablePolicyStateValues?
        /// The tags to apply to the lifecycle policy during creation.
        public let tags: [String: String]?

        @inlinable
        public init(copyTags: Bool? = nil, createInterval: Int? = nil, crossRegionCopyTargets: [CrossRegionCopyTarget]? = nil, defaultPolicy: DefaultPolicyTypeValues? = nil, description: String? = nil, exclusions: Exclusions? = nil, executionRoleArn: String? = nil, extendDeletion: Bool? = nil, policyDetails: PolicyDetails? = nil, retainInterval: Int? = nil, state: SettablePolicyStateValues? = nil, tags: [String: String]? = nil) {
            self.copyTags = copyTags
            self.createInterval = createInterval
            self.crossRegionCopyTargets = crossRegionCopyTargets
            self.defaultPolicy = defaultPolicy
            self.description = description
            self.exclusions = exclusions
            self.executionRoleArn = executionRoleArn
            self.extendDeletion = extendDeletion
            self.policyDetails = policyDetails
            self.retainInterval = retainInterval
            self.state = state
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.createInterval, name: "createInterval", parent: name, min: 1)
            try self.crossRegionCopyTargets?.forEach {
                try $0.validate(name: "\(name).crossRegionCopyTargets[]")
            }
            try self.validate(self.crossRegionCopyTargets, name: "crossRegionCopyTargets", parent: name, max: 3)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z _-]+$")
            try self.exclusions?.validate(name: "\(name).exclusions")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:iam::\\d+:role/")
            try self.policyDetails?.validate(name: "\(name).policyDetails")
            try self.validate(self.retainInterval, name: "retainInterval", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\p{all}]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case copyTags = "CopyTags"
            case createInterval = "CreateInterval"
            case crossRegionCopyTargets = "CrossRegionCopyTargets"
            case defaultPolicy = "DefaultPolicy"
            case description = "Description"
            case exclusions = "Exclusions"
            case executionRoleArn = "ExecutionRoleArn"
            case extendDeletion = "ExtendDeletion"
            case policyDetails = "PolicyDetails"
            case retainInterval = "RetainInterval"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CreateLifecyclePolicyResponse: AWSDecodableShape {
        /// The identifier of the lifecycle policy.
        public let policyId: String?

        @inlinable
        public init(policyId: String? = nil) {
            self.policyId = policyId
        }

        private enum CodingKeys: String, CodingKey {
            case policyId = "PolicyId"
        }
    }

    public struct CreateRule: AWSEncodableShape & AWSDecodableShape {
        /// The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1
        /// 			year. For more information, see the Cron expressions reference in
        /// 			the Amazon EventBridge User Guide.
        public let cronExpression: String?
        /// The interval between snapshots. The supported values are 1, 2, 3, 4, 6, 8, 12, and 24.
        public let interval: Int?
        /// The interval unit.
        public let intervalUnit: IntervalUnitValues?
        ///  [Custom snapshot policies only] Specifies the destination for snapshots created by the policy. The
        /// 			allowed destinations depend on the location of the targeted resources.   If the policy targets resources in a Region, then you must create snapshots
        /// 					in the same Region as the source resource.   If the policy targets resources in a Local Zone, you can create snapshots in
        /// 					the same Local Zone or in its parent Region.   If the policy targets resources on an Outpost, then you can create snapshots
        /// 					on the same Outpost or in its parent Region.   Specify one of the following values:   To create snapshots in the same Region as the source resource, specify
        /// 					CLOUD.   To create snapshots in the same Local Zone as the source resource, specify
        /// 					LOCAL_ZONE.   To create snapshots on the same Outpost as the source resource, specify
        /// 					OUTPOST_LOCAL.   Default: CLOUD
        public let location: LocationValues?
        ///  [Custom snapshot policies that target instances only] Specifies pre and/or post scripts for a snapshot lifecycle policy
        /// 			that targets instances. This is useful for creating application-consistent snapshots, or for
        /// 			performing specific administrative tasks before or after Amazon Data Lifecycle Manager initiates snapshot creation. For more information, see Automating
        /// 				application-consistent snapshots with pre and post scripts.
        public let scripts: [Script]?
        /// The time, in UTC, to start the operation. The supported format is hh:mm. The operation occurs within a one-hour window following the specified time. If you do
        /// 			not specify a time, Amazon Data Lifecycle Manager selects a time within the next 24 hours.
        public let times: [String]?

        @inlinable
        public init(cronExpression: String? = nil, interval: Int? = nil, intervalUnit: IntervalUnitValues? = nil, location: LocationValues? = nil, scripts: [Script]? = nil, times: [String]? = nil) {
            self.cronExpression = cronExpression
            self.interval = interval
            self.intervalUnit = intervalUnit
            self.location = location
            self.scripts = scripts
            self.times = times
        }

        public func validate(name: String) throws {
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, max: 106)
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, min: 17)
            try self.validate(self.cronExpression, name: "cronExpression", parent: name, pattern: "^cron\\([^\\n]{11,100}\\)$")
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
            try self.scripts?.forEach {
                try $0.validate(name: "\(name).scripts[]")
            }
            try self.validate(self.scripts, name: "scripts", parent: name, max: 1)
            try self.times?.forEach {
                try validate($0, name: "times[]", parent: name, max: 5)
                try validate($0, name: "times[]", parent: name, min: 5)
                try validate($0, name: "times[]", parent: name, pattern: "^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
            }
            try self.validate(self.times, name: "times", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpression = "CronExpression"
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
            case location = "Location"
            case scripts = "Scripts"
            case times = "Times"
        }
    }

    public struct CrossRegionCopyAction: AWSEncodableShape & AWSDecodableShape {
        /// The encryption settings for the copied snapshot.
        public let encryptionConfiguration: EncryptionConfiguration?
        public let retainRule: CrossRegionCopyRetainRule?
        /// The target Region.
        public let target: String?

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration? = nil, retainRule: CrossRegionCopyRetainRule? = nil, target: String? = nil) {
            self.encryptionConfiguration = encryptionConfiguration
            self.retainRule = retainRule
            self.target = target
        }

        public func validate(name: String) throws {
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.retainRule?.validate(name: "\(name).retainRule")
            try self.validate(self.target, name: "target", parent: name, max: 2048)
            try self.validate(self.target, name: "target", parent: name, pattern: "^[\\w:\\-\\/\\*]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "EncryptionConfiguration"
            case retainRule = "RetainRule"
            case target = "Target"
        }
    }

    public struct CrossRegionCopyDeprecateRule: AWSEncodableShape & AWSDecodableShape {
        /// The period after which to deprecate the cross-Region AMI copies. The period must be less than or
        /// 			equal to the cross-Region AMI copy retention period, and it can't be greater than 10 years. This is
        /// 			equivalent to 120 months, 520 weeks, or 3650 days.
        public let interval: Int?
        /// The unit of time in which to measure the Interval. For example,
        /// 			to deprecate a cross-Region AMI copy after 3 months, specify Interval=3 and
        /// 			IntervalUnit=MONTHS.
        public let intervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(interval: Int? = nil, intervalUnit: RetentionIntervalUnitValues? = nil) {
            self.interval = interval
            self.intervalUnit = intervalUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
        }
    }

    public struct CrossRegionCopyRetainRule: AWSEncodableShape & AWSDecodableShape {
        /// The amount of time to retain a cross-Region snapshot or AMI copy. The maximum is 100 years.
        /// 			This is equivalent to 1200 months, 5200 weeks, or 36500 days.
        public let interval: Int?
        /// The unit of time for time-based retention. For example, to retain a cross-Region copy for
        /// 			3 months, specify Interval=3 and IntervalUnit=MONTHS.
        public let intervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(interval: Int? = nil, intervalUnit: RetentionIntervalUnitValues? = nil) {
            self.interval = interval
            self.intervalUnit = intervalUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
        }
    }

    public struct CrossRegionCopyRule: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to use for EBS encryption. If this
        /// 			parameter is not specified, the default KMS key for the account is used.
        public let cmkArn: String?
        /// Indicates whether to copy all user-defined tags from the source snapshot or AMI to the
        /// 			cross-Region copy.
        public let copyTags: Bool?
        ///  [Custom AMI policies only] The AMI deprecation rule for cross-Region AMI copies created by the rule.
        public let deprecateRule: CrossRegionCopyDeprecateRule?
        /// To encrypt a copy of an unencrypted snapshot if encryption by default is not enabled,
        /// 			enable encryption using this parameter. Copies of encrypted snapshots are encrypted,
        /// 			even if this parameter is false or if encryption by default is not enabled.
        public let encrypted: Bool?
        /// The retention rule that indicates how long the cross-Region snapshot or AMI copies are
        /// 			to be retained in the destination Region.
        public let retainRule: CrossRegionCopyRetainRule?
        ///  Use this parameter for snapshot policies only. For AMI policies, use
        /// 				TargetRegion instead.   [Custom snapshot policies only] The target Region or the Amazon Resource Name (ARN) of the target Outpost for the
        /// 			snapshot copies.
        public let target: String?
        ///  Use this parameter for AMI policies only. For snapshot policies, use
        /// 				Target instead. For snapshot policies
        /// 				created before the Target parameter
        /// 				was introduced, this parameter indicates the target Region for snapshot
        /// 				copies.    [Custom AMI policies only] The target Region or the Amazon Resource Name (ARN) of the target Outpost for the
        /// 			snapshot copies.
        public let targetRegion: String?

        @inlinable
        public init(cmkArn: String? = nil, copyTags: Bool? = nil, deprecateRule: CrossRegionCopyDeprecateRule? = nil, encrypted: Bool? = nil, retainRule: CrossRegionCopyRetainRule? = nil, target: String? = nil, targetRegion: String? = nil) {
            self.cmkArn = cmkArn
            self.copyTags = copyTags
            self.deprecateRule = deprecateRule
            self.encrypted = encrypted
            self.retainRule = retainRule
            self.target = target
            self.targetRegion = targetRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.cmkArn, name: "cmkArn", parent: name, max: 2048)
            try self.validate(self.cmkArn, name: "cmkArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:kms:([a-z]+-){2,3}\\d:\\d+:key/")
            try self.deprecateRule?.validate(name: "\(name).deprecateRule")
            try self.retainRule?.validate(name: "\(name).retainRule")
            try self.validate(self.target, name: "target", parent: name, max: 2048)
            try self.validate(self.target, name: "target", parent: name, pattern: "^[\\w:\\-\\/\\*]+$")
            try self.validate(self.targetRegion, name: "targetRegion", parent: name, max: 16)
            try self.validate(self.targetRegion, name: "targetRegion", parent: name, pattern: "^([a-z]+-){2,3}\\d$")
        }

        private enum CodingKeys: String, CodingKey {
            case cmkArn = "CmkArn"
            case copyTags = "CopyTags"
            case deprecateRule = "DeprecateRule"
            case encrypted = "Encrypted"
            case retainRule = "RetainRule"
            case target = "Target"
            case targetRegion = "TargetRegion"
        }
    }

    public struct CrossRegionCopyTarget: AWSEncodableShape & AWSDecodableShape {
        /// The target Region, for example us-east-1.
        public let targetRegion: String?

        @inlinable
        public init(targetRegion: String? = nil) {
            self.targetRegion = targetRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.targetRegion, name: "targetRegion", parent: name, max: 16)
            try self.validate(self.targetRegion, name: "targetRegion", parent: name, pattern: "^([a-z]+-){2,3}\\d$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetRegion = "TargetRegion"
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSEncodableShape {
        /// The identifier of the lifecycle policy.
        public let policyId: String

        @inlinable
        public init(policyId: String) {
            self.policyId = policyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyId, key: "PolicyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyId, name: "policyId", parent: name, max: 64)
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "^policy-[a-f0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLifecyclePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeprecateRule: AWSEncodableShape & AWSDecodableShape {
        /// If the schedule has a count-based retention rule, this parameter specifies the number of oldest
        /// 			AMIs to deprecate. The count must be less than or equal to the schedule's retention count, and it
        /// 			can't be greater than 1000.
        public let count: Int?
        /// If the schedule has an age-based retention rule, this parameter specifies the period after which
        /// 			to deprecate AMIs created by the schedule. The period must be less than or equal to the schedule's
        /// 			retention period, and it can't be greater than 10 years. This is equivalent to 120 months, 520
        /// 			weeks, or 3650 days.
        public let interval: Int?
        /// The unit of time in which to measure the Interval.
        public let intervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(count: Int? = nil, interval: Int? = nil, intervalUnit: RetentionIntervalUnitValues? = nil) {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.count, name: "count", parent: name, max: 1000)
            try self.validate(self.count, name: "count", parent: name, min: 1)
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to use for EBS encryption. If
        /// 			this parameter is not specified, the default KMS key for the account is used.
        public let cmkArn: String?
        /// To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable
        /// 			encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this
        /// 			parameter is false or when encryption by default is not enabled.
        public let encrypted: Bool?

        @inlinable
        public init(cmkArn: String? = nil, encrypted: Bool? = nil) {
            self.cmkArn = cmkArn
            self.encrypted = encrypted
        }

        public func validate(name: String) throws {
            try self.validate(self.cmkArn, name: "cmkArn", parent: name, max: 2048)
            try self.validate(self.cmkArn, name: "cmkArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:kms:([a-z]+-){2,3}\\d:\\d+:key/")
        }

        private enum CodingKeys: String, CodingKey {
            case cmkArn = "CmkArn"
            case encrypted = "Encrypted"
        }
    }

    public struct EventParameters: AWSEncodableShape & AWSDecodableShape {
        /// The snapshot description that can trigger the policy. The description pattern is specified using
        /// 			a regular expression. The policy runs only if a snapshot with a description that matches the
        /// 			specified pattern is shared with your account. For example, specifying ^.*Created for policy: policy-1234567890abcdef0.*$
        /// 			configures the policy to run only if snapshots created by policy policy-1234567890abcdef0
        /// 			are shared with your account.
        public let descriptionRegex: String?
        /// The type of event. Currently, only snapshot sharing events are supported.
        public let eventType: EventTypeValues?
        /// The IDs of the Amazon Web Services accounts that can trigger policy by sharing snapshots with your account.
        /// 			The policy only runs if one of the specified Amazon Web Services accounts shares a snapshot with your account.
        public let snapshotOwner: [String]?

        @inlinable
        public init(descriptionRegex: String? = nil, eventType: EventTypeValues? = nil, snapshotOwner: [String]? = nil) {
            self.descriptionRegex = descriptionRegex
            self.eventType = eventType
            self.snapshotOwner = snapshotOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.descriptionRegex, name: "descriptionRegex", parent: name, max: 1000)
            try self.validate(self.descriptionRegex, name: "descriptionRegex", parent: name, pattern: "^[\\p{all}]*$")
            try self.snapshotOwner?.forEach {
                try validate($0, name: "snapshotOwner[]", parent: name, max: 12)
                try validate($0, name: "snapshotOwner[]", parent: name, min: 12)
                try validate($0, name: "snapshotOwner[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.snapshotOwner, name: "snapshotOwner", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case descriptionRegex = "DescriptionRegex"
            case eventType = "EventType"
            case snapshotOwner = "SnapshotOwner"
        }
    }

    public struct EventSource: AWSEncodableShape & AWSDecodableShape {
        /// Information about the event.
        public let parameters: EventParameters?
        /// The source of the event. Currently only managed CloudWatch Events rules are supported.
        public let type: EventSourceValues?

        @inlinable
        public init(parameters: EventParameters? = nil, type: EventSourceValues? = nil) {
            self.parameters = parameters
            self.type = type
        }

        public func validate(name: String) throws {
            try self.parameters?.validate(name: "\(name).parameters")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
            case type = "Type"
        }
    }

    public struct Exclusions: AWSEncodableShape & AWSDecodableShape {
        ///  [Default policies for EBS snapshots only] Indicates whether to exclude volumes that are attached to
        /// 			instances as the boot volume. If you exclude boot volumes, only volumes attached as data
        /// 			(non-boot) volumes will be backed up by the policy. To exclude boot volumes, specify
        /// 			true.
        public let excludeBootVolumes: Bool?
        ///  [Default policies for EBS-backed AMIs only] Specifies whether to exclude volumes that have specific tags.
        public let excludeTags: [Tag]?
        ///  [Default policies for EBS snapshots only] Specifies the volume types to exclude. Volumes of the specified
        /// 			types will not be targeted by the policy.
        public let excludeVolumeTypes: [String]?

        @inlinable
        public init(excludeBootVolumes: Bool? = nil, excludeTags: [Tag]? = nil, excludeVolumeTypes: [String]? = nil) {
            self.excludeBootVolumes = excludeBootVolumes
            self.excludeTags = excludeTags
            self.excludeVolumeTypes = excludeVolumeTypes
        }

        public func validate(name: String) throws {
            try self.excludeTags?.forEach {
                try $0.validate(name: "\(name).excludeTags[]")
            }
            try self.validate(self.excludeTags, name: "excludeTags", parent: name, max: 50)
            try self.validate(self.excludeVolumeTypes, name: "excludeVolumeTypes", parent: name, max: 6)
        }

        private enum CodingKeys: String, CodingKey {
            case excludeBootVolumes = "ExcludeBootVolumes"
            case excludeTags = "ExcludeTags"
            case excludeVolumeTypes = "ExcludeVolumeTypes"
        }
    }

    public struct FastRestoreRule: AWSEncodableShape & AWSDecodableShape {
        /// The Availability Zones in which to enable fast snapshot restore.
        public let availabilityZones: [String]?
        /// The number of snapshots to be enabled with fast snapshot restore.
        public let count: Int?
        /// The amount of time to enable fast snapshot restore. The maximum is 100 years. This is
        /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.
        public let interval: Int?
        /// The unit of time for enabling fast snapshot restore.
        public let intervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(availabilityZones: [String]? = nil, count: Int? = nil, interval: Int? = nil, intervalUnit: RetentionIntervalUnitValues? = nil) {
            self.availabilityZones = availabilityZones
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, max: 16)
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "^([a-z]+-){2,3}\\d[a-z]$")
            }
            try self.validate(self.availabilityZones, name: "availabilityZones", parent: name, max: 10)
            try self.validate(self.availabilityZones, name: "availabilityZones", parent: name, min: 1)
            try self.validate(self.count, name: "count", parent: name, max: 1000)
            try self.validate(self.count, name: "count", parent: name, min: 1)
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case count = "Count"
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
        }
    }

    public struct GetLifecyclePoliciesRequest: AWSEncodableShape {
        ///  [Default policies only] Specifies the type of default policy to get. Specify one of the following:    VOLUME - To get only the default policy for EBS snapshots    INSTANCE - To get only the default policy for EBS-backed AMIs    ALL - To get all default policies
        public let defaultPolicyType: DefaultPoliciesTypeValues?
        /// The identifiers of the data lifecycle policies.
        public let policyIds: [String]?
        /// The resource type.
        public let resourceTypes: [ResourceTypeValues]?
        /// The activation state.
        public let state: GettablePolicyStateValues?
        /// The tags to add to objects created by the policy. Tags are strings in the format key=value. These user-defined tags are added in addition to the Amazon Web Services-added lifecycle tags.
        public let tagsToAdd: [String]?
        /// The target tag for a policy. Tags are strings in the format key=value.
        public let targetTags: [String]?

        @inlinable
        public init(defaultPolicyType: DefaultPoliciesTypeValues? = nil, policyIds: [String]? = nil, resourceTypes: [ResourceTypeValues]? = nil, state: GettablePolicyStateValues? = nil, tagsToAdd: [String]? = nil, targetTags: [String]? = nil) {
            self.defaultPolicyType = defaultPolicyType
            self.policyIds = policyIds
            self.resourceTypes = resourceTypes
            self.state = state
            self.tagsToAdd = tagsToAdd
            self.targetTags = targetTags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.defaultPolicyType, key: "defaultPolicyType")
            request.encodeQuery(self.policyIds, key: "policyIds")
            request.encodeQuery(self.resourceTypes, key: "resourceTypes")
            request.encodeQuery(self.state, key: "state")
            request.encodeQuery(self.tagsToAdd, key: "tagsToAdd")
            request.encodeQuery(self.targetTags, key: "targetTags")
        }

        public func validate(name: String) throws {
            try self.policyIds?.forEach {
                try validate($0, name: "policyIds[]", parent: name, max: 64)
                try validate($0, name: "policyIds[]", parent: name, pattern: "^policy-[a-f0-9]+$")
            }
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
            try self.tagsToAdd?.forEach {
                try validate($0, name: "tagsToAdd[]", parent: name, max: 256)
                try validate($0, name: "tagsToAdd[]", parent: name, pattern: "^[\\p{all}]*$")
            }
            try self.validate(self.tagsToAdd, name: "tagsToAdd", parent: name, max: 50)
            try self.targetTags?.forEach {
                try validate($0, name: "targetTags[]", parent: name, max: 256)
                try validate($0, name: "targetTags[]", parent: name, pattern: "^[\\p{all}]*$")
            }
            try self.validate(self.targetTags, name: "targetTags", parent: name, max: 50)
            try self.validate(self.targetTags, name: "targetTags", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLifecyclePoliciesResponse: AWSDecodableShape {
        /// Summary information about the lifecycle policies.
        public let policies: [LifecyclePolicySummary]?

        @inlinable
        public init(policies: [LifecyclePolicySummary]? = nil) {
            self.policies = policies
        }

        private enum CodingKeys: String, CodingKey {
            case policies = "Policies"
        }
    }

    public struct GetLifecyclePolicyRequest: AWSEncodableShape {
        /// The identifier of the lifecycle policy.
        public let policyId: String

        @inlinable
        public init(policyId: String) {
            self.policyId = policyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyId, key: "PolicyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyId, name: "policyId", parent: name, max: 64)
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "^policy-[a-f0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLifecyclePolicyResponse: AWSDecodableShape {
        /// Detailed information about the lifecycle policy.
        public let policy: LifecyclePolicy?

        @inlinable
        public init(policy: LifecyclePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct InvalidRequestException: AWSErrorShape {
        public let code: String?
        public let message: String?
        /// The request included parameters that cannot be provided together.
        public let mutuallyExclusiveParameters: [String]?
        /// The request omitted one or more required parameters.
        public let requiredParameters: [String]?

        @inlinable
        public init(code: String? = nil, message: String? = nil, mutuallyExclusiveParameters: [String]? = nil, requiredParameters: [String]? = nil) {
            self.code = code
            self.message = message
            self.mutuallyExclusiveParameters = mutuallyExclusiveParameters
            self.requiredParameters = requiredParameters
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case mutuallyExclusiveParameters = "MutuallyExclusiveParameters"
            case requiredParameters = "RequiredParameters"
        }
    }

    public struct LifecyclePolicy: AWSDecodableShape {
        /// The local date and time when the lifecycle policy was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dateCreated: Date?
        /// The local date and time when the lifecycle policy was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dateModified: Date?
        /// Indicates whether the policy is a default lifecycle policy or a custom
        /// 			lifecycle policy.    true - the policy is a default policy.    false - the policy is a custom policy.
        public let defaultPolicy: Bool?
        /// The description of the lifecycle policy.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
        /// 			the lifecycle policy.
        public let executionRoleArn: String?
        /// The Amazon Resource Name (ARN) of the policy.
        public let policyArn: String?
        /// The configuration of the lifecycle policy
        public let policyDetails: PolicyDetails?
        /// The identifier of the lifecycle policy.
        public let policyId: String?
        /// The activation state of the lifecycle policy.
        public let state: GettablePolicyStateValues?
        /// The description of the status.
        public let statusMessage: String?
        /// The tags.
        public let tags: [String: String]?

        @inlinable
        public init(dateCreated: Date? = nil, dateModified: Date? = nil, defaultPolicy: Bool? = nil, description: String? = nil, executionRoleArn: String? = nil, policyArn: String? = nil, policyDetails: PolicyDetails? = nil, policyId: String? = nil, state: GettablePolicyStateValues? = nil, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.defaultPolicy = defaultPolicy
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.policyArn = policyArn
            self.policyDetails = policyDetails
            self.policyId = policyId
            self.state = state
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case defaultPolicy = "DefaultPolicy"
            case description = "Description"
            case executionRoleArn = "ExecutionRoleArn"
            case policyArn = "PolicyArn"
            case policyDetails = "PolicyDetails"
            case policyId = "PolicyId"
            case state = "State"
            case statusMessage = "StatusMessage"
            case tags = "Tags"
        }
    }

    public struct LifecyclePolicySummary: AWSDecodableShape {
        ///  [Default policies only] The type of default policy. Values include:    VOLUME - Default policy for EBS snapshots    INSTANCE - Default policy for EBS-backed AMIs
        public let defaultPolicy: Bool?
        /// The description of the lifecycle policy.
        public let description: String?
        /// The identifier of the lifecycle policy.
        public let policyId: String?
        /// The type of policy. EBS_SNAPSHOT_MANAGEMENT indicates that the policy
        /// 			manages the lifecycle of Amazon EBS snapshots. IMAGE_MANAGEMENT
        /// 			indicates that the policy manages the lifecycle of EBS-backed AMIs.
        /// 			EVENT_BASED_POLICY indicates that the policy automates cross-account
        /// 			snapshot copies for snapshots that are shared with your account.
        public let policyType: PolicyTypeValues?
        /// The activation state of the lifecycle policy.
        public let state: GettablePolicyStateValues?
        /// The tags.
        public let tags: [String: String]?

        @inlinable
        public init(defaultPolicy: Bool? = nil, description: String? = nil, policyId: String? = nil, policyType: PolicyTypeValues? = nil, state: GettablePolicyStateValues? = nil, tags: [String: String]? = nil) {
            self.defaultPolicy = defaultPolicy
            self.description = description
            self.policyId = policyId
            self.policyType = policyType
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case defaultPolicy = "DefaultPolicy"
            case description = "Description"
            case policyId = "PolicyId"
            case policyType = "PolicyType"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct LimitExceededException: AWSErrorShape {
        public let code: String?
        public let message: String?
        /// Value is the type of resource for which a limit was exceeded.
        public let resourceType: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, resourceType: String? = nil) {
            self.code = code
            self.message = message
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case resourceType = "ResourceType"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:dlm:[A-Za-z0-9_/.-]{0,63}:\\d+:policy/[0-9A-Za-z_-]{1,128}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Parameters: AWSEncodableShape & AWSDecodableShape {
        ///  [Custom snapshot policies that target instances only] Indicates whether to exclude the root volume from multi-volume
        /// 			snapshot sets. The default is false. If you specify true,
        /// 			then the root volumes attached to targeted instances will be excluded from the multi-volume
        /// 			snapshot sets created by the policy.
        public let excludeBootVolume: Bool?
        ///  [Custom snapshot policies that target instances only] The tags used to identify data (non-root) volumes to exclude from
        /// 			multi-volume snapshot sets. If you create a snapshot lifecycle policy that targets instances and you specify tags for
        /// 			this parameter, then data volumes with the specified tags that are attached to targeted
        /// 			instances will be excluded from the multi-volume snapshot sets created by the policy.
        public let excludeDataVolumeTags: [Tag]?
        ///  [Custom AMI policies only] Indicates whether targeted instances are rebooted when the lifecycle policy
        /// 			runs. true indicates that targeted instances are not rebooted when the policy
        /// 			runs. false indicates that target instances are rebooted when the policy runs.
        /// 			The default is true (instances are not rebooted).
        public let noReboot: Bool?

        @inlinable
        public init(excludeBootVolume: Bool? = nil, excludeDataVolumeTags: [Tag]? = nil, noReboot: Bool? = nil) {
            self.excludeBootVolume = excludeBootVolume
            self.excludeDataVolumeTags = excludeDataVolumeTags
            self.noReboot = noReboot
        }

        public func validate(name: String) throws {
            try self.excludeDataVolumeTags?.forEach {
                try $0.validate(name: "\(name).excludeDataVolumeTags[]")
            }
            try self.validate(self.excludeDataVolumeTags, name: "excludeDataVolumeTags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case excludeBootVolume = "ExcludeBootVolume"
            case excludeDataVolumeTags = "ExcludeDataVolumeTags"
            case noReboot = "NoReboot"
        }
    }

    public struct PolicyDetails: AWSEncodableShape & AWSDecodableShape {
        ///  [Event-based policies only]  The actions to be performed when the  event-based policy is activated. You can specify
        /// 			only one action per policy.
        public let actions: [Action]?
        ///  [Default policies only] Indicates whether the policy should copy tags from the source resource
        /// 			to the snapshot or AMI. If you do not specify a value, the default is false. Default: false
        public let copyTags: Bool?
        ///  [Default policies only] Specifies how often the policy should run and create snapshots or AMIs.
        /// 			The creation frequency can range from 1 to 7 days. If you do not specify a value, the
        /// 			default is 1. Default: 1
        public let createInterval: Int?
        ///  [Default policies only] Specifies destination Regions for snapshot or AMI copies. You can specify
        /// 			up to 3 destination Regions. If you do not want to create cross-Region copies, omit this
        /// 			parameter.
        public let crossRegionCopyTargets: [CrossRegionCopyTarget]?
        ///  [Event-based policies only]  The event that activates the event-based policy.
        public let eventSource: EventSource?
        ///  [Default policies only] Specifies exclusion parameters for volumes or instances for which you
        /// 			do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs
        /// 			for target resources that match any of the specified exclusion parameters.
        public let exclusions: Exclusions?
        ///  [Default policies only] Defines the snapshot or AMI retention behavior for the policy if the
        /// 			source volume or instance is deleted, or if the policy enters the error, disabled, or
        /// 			deleted state. By default (ExtendDeletion=false):   If a source resource is deleted, Amazon Data Lifecycle Manager will continue to delete previously
        /// 					created snapshots or AMIs, up to but not including the last one, based on the
        /// 					specified retention period. If you want Amazon Data Lifecycle Manager to delete all snapshots or AMIs,
        /// 					including the last one, specify true.   If a policy enters the error, disabled, or deleted state, Amazon Data Lifecycle Manager stops deleting
        /// 					snapshots and AMIs. If you want Amazon Data Lifecycle Manager to continue deleting snapshots or AMIs,
        /// 					including the last one, if the policy enters one of these states, specify
        /// 					true.   If you enable extended deletion (ExtendDeletion=true),
        /// 			you override both default behaviors simultaneously. If you do not specify a value, the default is false. Default: false
        public let extendDeletion: Bool?
        ///  [Custom snapshot and AMI policies only] A set of optional parameters for snapshot and AMI lifecycle policies.   If you are modifying a policy that was created or previously modified using the Amazon
        /// 				Data Lifecycle Manager console, then you must include this parameter and specify either
        /// 				the default values or the new values that you require. You can't omit this parameter or
        /// 				set its values to null.
        public let parameters: Parameters?
        /// The type of policy to create. Specify one of the following:    SIMPLIFIED To create a default policy.    STANDARD To create a custom policy.
        public let policyLanguage: PolicyLanguageValues?
        /// The type of policy. Specify EBS_SNAPSHOT_MANAGEMENT
        /// 			to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify IMAGE_MANAGEMENT
        /// 			to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify EVENT_BASED_POLICY
        /// 			to create an event-based policy that performs specific actions when a defined event occurs in your Amazon Web Services account. The default is EBS_SNAPSHOT_MANAGEMENT.
        public let policyType: PolicyTypeValues?
        ///  [Custom snapshot and AMI policies only] The location of the resources to backup.   If the source resources are located in a Region, specify CLOUD. In this case,
        /// 					the policy targets all resources of the specified type with matching target tags across all
        /// 					Availability Zones in the Region.    [Custom snapshot policies only] If the source resources are located in a Local Zone, specify LOCAL_ZONE.
        /// 					In this case, the policy targets all resources of the specified type with matching target
        /// 					tags across all Local Zones in the Region.   If the source resources are located on an Outpost in your account, specify OUTPOST.
        /// 					In this case, the policy targets all resources of the specified type with matching target
        /// 					tags across all of the Outposts in your account.
        public let resourceLocations: [ResourceLocationValues]?
        ///  [Default policies only] Specify the type of default policy to create.   To create a default policy for EBS snapshots, that creates snapshots of all volumes in the
        /// 					Region that do not have recent backups, specify VOLUME.   To create a default policy for EBS-backed AMIs, that creates EBS-backed
        /// 					AMIs from all instances in the Region that do not have recent backups, specify
        /// 					INSTANCE.
        public let resourceType: ResourceTypeValues?
        ///  [Custom snapshot policies only] The target resource type for snapshot and AMI lifecycle policies. Use VOLUME to
        /// 			create snapshots of individual volumes or use INSTANCE to create multi-volume
        /// 			snapshots from the volumes for an instance.
        public let resourceTypes: [ResourceTypeValues]?
        ///  [Default policies only] Specifies how long the policy should retain snapshots or AMIs before
        /// 			deleting them. The retention period can range from 2 to 14 days, but it must be greater
        /// 			than the creation frequency to ensure that the policy retains at least 1 snapshot or
        /// 			AMI at any given time. If you do not specify a value, the default is 7. Default: 7
        public let retainInterval: Int?
        ///  [Custom snapshot and AMI policies only] The schedules of policy-defined actions for snapshot and AMI lifecycle policies. A policy
        /// 			can have up to four schedulesone mandatory schedule and up to three optional schedules.
        public let schedules: [Schedule]?
        ///  [Custom snapshot and AMI policies only] The single tag that identifies targeted resources for this policy.
        public let targetTags: [Tag]?

        @inlinable
        public init(actions: [Action]? = nil, copyTags: Bool? = nil, createInterval: Int? = nil, crossRegionCopyTargets: [CrossRegionCopyTarget]? = nil, eventSource: EventSource? = nil, exclusions: Exclusions? = nil, extendDeletion: Bool? = nil, parameters: Parameters? = nil, policyLanguage: PolicyLanguageValues? = nil, policyType: PolicyTypeValues? = nil, resourceLocations: [ResourceLocationValues]? = nil, resourceType: ResourceTypeValues? = nil, resourceTypes: [ResourceTypeValues]? = nil, retainInterval: Int? = nil, schedules: [Schedule]? = nil, targetTags: [Tag]? = nil) {
            self.actions = actions
            self.copyTags = copyTags
            self.createInterval = createInterval
            self.crossRegionCopyTargets = crossRegionCopyTargets
            self.eventSource = eventSource
            self.exclusions = exclusions
            self.extendDeletion = extendDeletion
            self.parameters = parameters
            self.policyLanguage = policyLanguage
            self.policyType = policyType
            self.resourceLocations = resourceLocations
            self.resourceType = resourceType
            self.resourceTypes = resourceTypes
            self.retainInterval = retainInterval
            self.schedules = schedules
            self.targetTags = targetTags
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.createInterval, name: "createInterval", parent: name, min: 1)
            try self.crossRegionCopyTargets?.forEach {
                try $0.validate(name: "\(name).crossRegionCopyTargets[]")
            }
            try self.validate(self.crossRegionCopyTargets, name: "crossRegionCopyTargets", parent: name, max: 3)
            try self.eventSource?.validate(name: "\(name).eventSource")
            try self.exclusions?.validate(name: "\(name).exclusions")
            try self.parameters?.validate(name: "\(name).parameters")
            try self.validate(self.resourceLocations, name: "resourceLocations", parent: name, max: 1)
            try self.validate(self.resourceLocations, name: "resourceLocations", parent: name, min: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
            try self.validate(self.retainInterval, name: "retainInterval", parent: name, min: 1)
            try self.schedules?.forEach {
                try $0.validate(name: "\(name).schedules[]")
            }
            try self.validate(self.schedules, name: "schedules", parent: name, max: 4)
            try self.validate(self.schedules, name: "schedules", parent: name, min: 1)
            try self.targetTags?.forEach {
                try $0.validate(name: "\(name).targetTags[]")
            }
            try self.validate(self.targetTags, name: "targetTags", parent: name, max: 50)
            try self.validate(self.targetTags, name: "targetTags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case copyTags = "CopyTags"
            case createInterval = "CreateInterval"
            case crossRegionCopyTargets = "CrossRegionCopyTargets"
            case eventSource = "EventSource"
            case exclusions = "Exclusions"
            case extendDeletion = "ExtendDeletion"
            case parameters = "Parameters"
            case policyLanguage = "PolicyLanguage"
            case policyType = "PolicyType"
            case resourceLocations = "ResourceLocations"
            case resourceType = "ResourceType"
            case resourceTypes = "ResourceTypes"
            case retainInterval = "RetainInterval"
            case schedules = "Schedules"
            case targetTags = "TargetTags"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let code: String?
        public let message: String?
        /// Value is a list of resource IDs that were not found.
        public let resourceIds: [String]?
        /// Value is the type of resource that was not found.
        public let resourceType: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, resourceIds: [String]? = nil, resourceType: String? = nil) {
            self.code = code
            self.message = message
            self.resourceIds = resourceIds
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case resourceIds = "ResourceIds"
            case resourceType = "ResourceType"
        }
    }

    public struct RetainRule: AWSEncodableShape & AWSDecodableShape {
        /// The number of snapshots to retain for each volume, up to a maximum of 1000. For example if you want to
        /// 			retain a maximum of three snapshots, specify 3. When the fourth snapshot is created, the
        /// 			oldest retained snapshot is deleted, or it is moved to the archive tier if you have specified an
        /// 			ArchiveRule.
        public let count: Int?
        /// The amount of time to retain each snapshot. The maximum is 100 years. This is
        /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.
        public let interval: Int?
        /// The unit of time for time-based retention. For example, to retain snapshots for 3 months, specify
        /// 			Interval=3 and IntervalUnit=MONTHS. Once the snapshot has been retained for
        /// 			3 months, it is deleted, or it is moved to the archive tier if you have specified an
        /// 			ArchiveRule.
        public let intervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(count: Int? = nil, interval: Int? = nil, intervalUnit: RetentionIntervalUnitValues? = nil) {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.count, name: "count", parent: name, max: 1000)
            try self.validate(self.count, name: "count", parent: name, min: 0)
            try self.validate(self.interval, name: "interval", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
        }
    }

    public struct RetentionArchiveTier: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of snapshots to retain in the archive storage tier for each volume.
        /// 			The count must ensure that each snapshot remains in the archive tier for at least
        /// 		90 days. For example, if the schedule creates snapshots every 30 days, you must specify a
        /// 		count of 3 or more to ensure that each snapshot is archived for at least 90 days.
        public let count: Int?
        /// Specifies the period of time to retain snapshots in the archive tier. After this period
        /// 			expires, the snapshot is permanently deleted.
        public let interval: Int?
        /// The unit of time in which to measure the Interval. For
        /// 			example, to retain a snapshots in the archive tier for 6 months, specify Interval=6
        /// 			and IntervalUnit=MONTHS.
        public let intervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(count: Int? = nil, interval: Int? = nil, intervalUnit: RetentionIntervalUnitValues? = nil) {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.count, name: "count", parent: name, max: 1000)
            try self.validate(self.count, name: "count", parent: name, min: 1)
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case interval = "Interval"
            case intervalUnit = "IntervalUnit"
        }
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {
        ///  [Custom snapshot policies that target volumes only] The snapshot archiving rule for the schedule. When you specify an archiving
        /// 			rule, snapshots are automatically moved from the standard tier to the archive tier once the schedule's
        /// 			retention threshold is met. Snapshots are then retained in the archive tier for the archive retention
        /// 			period that you specify.  For more information about using snapshot archiving, see Considerations for
        /// 				snapshot lifecycle policies.
        public let archiveRule: ArchiveRule?
        /// Copy all user-defined tags on a source volume to snapshots of the volume created by
        /// 			this policy.
        public let copyTags: Bool?
        /// The creation rule.
        public let createRule: CreateRule?
        /// Specifies a rule for copying snapshots or AMIs across Regions.  You can't specify cross-Region copy rules for policies that create snapshots on an
        /// 				Outpost or in a Local Zone. If the policy creates snapshots in a Region, then snapshots
        /// 				can be copied to up to three Regions or Outposts.
        public let crossRegionCopyRules: [CrossRegionCopyRule]?
        ///  [Custom AMI policies only] The AMI deprecation rule for the schedule.
        public let deprecateRule: DeprecateRule?
        ///  [Custom snapshot policies only] The rule for enabling fast snapshot restore.
        public let fastRestoreRule: FastRestoreRule?
        /// The name of the schedule.
        public let name: String?
        /// The retention rule for snapshots or AMIs created by the policy.
        public let retainRule: RetainRule?
        ///  [Custom snapshot policies only] The rule for sharing snapshots with other Amazon Web Services accounts.
        public let shareRules: [ShareRule]?
        /// The tags to apply to policy-created resources. These user-defined tags are in addition
        /// 			to the Amazon Web Services-added lifecycle tags.
        public let tagsToAdd: [Tag]?
        ///  [AMI policies and snapshot policies that target instances only]
        /// 			A collection of key/value pairs with values determined dynamically when the policy is
        /// 			executed. Keys may be any valid Amazon EC2 tag key. Values must be in one of the two
        /// 			following formats: $(instance-id) or $(timestamp). Variable
        /// 			tags are only valid for EBS Snapshot Management  Instance policies.
        public let variableTags: [Tag]?

        @inlinable
        public init(archiveRule: ArchiveRule? = nil, copyTags: Bool? = nil, createRule: CreateRule? = nil, crossRegionCopyRules: [CrossRegionCopyRule]? = nil, deprecateRule: DeprecateRule? = nil, fastRestoreRule: FastRestoreRule? = nil, name: String? = nil, retainRule: RetainRule? = nil, shareRules: [ShareRule]? = nil, tagsToAdd: [Tag]? = nil, variableTags: [Tag]? = nil) {
            self.archiveRule = archiveRule
            self.copyTags = copyTags
            self.createRule = createRule
            self.crossRegionCopyRules = crossRegionCopyRules
            self.deprecateRule = deprecateRule
            self.fastRestoreRule = fastRestoreRule
            self.name = name
            self.retainRule = retainRule
            self.shareRules = shareRules
            self.tagsToAdd = tagsToAdd
            self.variableTags = variableTags
        }

        public func validate(name: String) throws {
            try self.archiveRule?.validate(name: "\(name).archiveRule")
            try self.createRule?.validate(name: "\(name).createRule")
            try self.crossRegionCopyRules?.forEach {
                try $0.validate(name: "\(name).crossRegionCopyRules[]")
            }
            try self.validate(self.crossRegionCopyRules, name: "crossRegionCopyRules", parent: name, max: 3)
            try self.deprecateRule?.validate(name: "\(name).deprecateRule")
            try self.fastRestoreRule?.validate(name: "\(name).fastRestoreRule")
            try self.validate(self.name, name: "name", parent: name, max: 120)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z _-]+$")
            try self.retainRule?.validate(name: "\(name).retainRule")
            try self.shareRules?.forEach {
                try $0.validate(name: "\(name).shareRules[]")
            }
            try self.validate(self.shareRules, name: "shareRules", parent: name, max: 1)
            try self.tagsToAdd?.forEach {
                try $0.validate(name: "\(name).tagsToAdd[]")
            }
            try self.validate(self.tagsToAdd, name: "tagsToAdd", parent: name, max: 45)
            try self.variableTags?.forEach {
                try $0.validate(name: "\(name).variableTags[]")
            }
            try self.validate(self.variableTags, name: "variableTags", parent: name, max: 45)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveRule = "ArchiveRule"
            case copyTags = "CopyTags"
            case createRule = "CreateRule"
            case crossRegionCopyRules = "CrossRegionCopyRules"
            case deprecateRule = "DeprecateRule"
            case fastRestoreRule = "FastRestoreRule"
            case name = "Name"
            case retainRule = "RetainRule"
            case shareRules = "ShareRules"
            case tagsToAdd = "TagsToAdd"
            case variableTags = "VariableTags"
        }
    }

    public struct Script: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether Amazon Data Lifecycle Manager should default to crash-consistent snapshots if the
        /// 			pre script fails.   To default to crash consistent snapshot if the pre script fails,
        /// 					specify true.   To skip the instance for snapshot creation if the pre script fails,
        /// 					specify false.   This parameter is supported only if you run a pre script. If you run a post
        /// 			script only, omit this parameter. Default: true
        public let executeOperationOnScriptFailure: Bool?
        /// The SSM document that includes the pre and/or post scripts to run.   If you are automating VSS backups, specify AWS_VSS_BACKUP.
        /// 					In this case, Amazon Data Lifecycle Manager automatically uses the AWSEC2-CreateVssSnapshot
        /// 					SSM document.   If you are automating application-consistent snapshots for SAP HANA
        /// 					workloads, specify AWSSystemsManagerSAP-CreateDLMSnapshotForSAPHANA.   If you are using a custom SSM document that you own, specify either
        /// 					the name or ARN of the SSM document. If you are using a custom SSM
        /// 					document that is shared with you, specify the ARN of the SSM document.
        public let executionHandler: String?
        /// Indicates the service used to execute the pre and/or post scripts.   If you are using custom SSM documents or automating
        /// 					application-consistent snapshots of SAP HANA workloads, specify
        /// 					AWS_SYSTEMS_MANAGER.   If you are automating VSS Backups, omit this parameter.   Default: AWS_SYSTEMS_MANAGER
        public let executionHandlerService: ExecutionHandlerServiceValues?
        /// Specifies a timeout period, in seconds, after which Amazon Data Lifecycle Manager fails the script
        /// 			run attempt if it has not completed. If a script does not complete within its
        /// 			timeout period, Amazon Data Lifecycle Manager fails the attempt. The timeout period applies to the pre
        /// 			and post scripts individually.  If you are automating VSS Backups, omit this parameter. Default: 10
        public let executionTimeout: Int?
        /// Specifies the number of times Amazon Data Lifecycle Manager should retry scripts that fail.   If the pre script fails, Amazon Data Lifecycle Manager retries the entire snapshot creation
        /// 					process, including running the pre and post scripts.   If the post script fails, Amazon Data Lifecycle Manager retries the post script only; in this
        /// 					case, the pre script will have completed and the snapshot might have
        /// 					been created.   If you do not want Amazon Data Lifecycle Manager to retry failed scripts, specify 0. Default: 0
        public let maximumRetryCount: Int?
        /// Indicate which scripts Amazon Data Lifecycle Manager should run on target instances. Pre scripts
        /// 			run before Amazon Data Lifecycle Manager initiates snapshot creation. Post scripts run after Amazon Data Lifecycle Manager
        /// 			initiates snapshot creation.   To run a pre script only, specify PRE. In this case,
        /// 					Amazon Data Lifecycle Manager calls the SSM document with the pre-script parameter
        /// 					before initiating snapshot creation.   To run a post script only, specify POST. In this case,
        /// 					Amazon Data Lifecycle Manager calls the SSM document with the post-script parameter
        /// 					after initiating snapshot creation.   To run both pre and post scripts, specify both PRE and POST. In
        /// 					this case, Amazon Data Lifecycle Manager calls the SSM document with the pre-script
        /// 					parameter before initiating snapshot creation, and then it calls the SSM
        /// 					document again with the post-script parameter after initiating
        /// 					snapshot creation.   If you are automating VSS Backups, omit this parameter. Default: PRE and POST
        public let stages: [StageValues]?

        @inlinable
        public init(executeOperationOnScriptFailure: Bool? = nil, executionHandler: String? = nil, executionHandlerService: ExecutionHandlerServiceValues? = nil, executionTimeout: Int? = nil, maximumRetryCount: Int? = nil, stages: [StageValues]? = nil) {
            self.executeOperationOnScriptFailure = executeOperationOnScriptFailure
            self.executionHandler = executionHandler
            self.executionHandlerService = executionHandlerService
            self.executionTimeout = executionTimeout
            self.maximumRetryCount = maximumRetryCount
            self.stages = stages
        }

        public func validate(name: String) throws {
            try self.validate(self.executionHandler, name: "executionHandler", parent: name, max: 200)
            try self.validate(self.executionHandler, name: "executionHandler", parent: name, pattern: "^([a-zA-Z0-9_\\-.]{3,128}|[a-zA-Z0-9_\\-.:/]{3,200}|[A-Z0-9_]+)$")
            try self.validate(self.executionTimeout, name: "executionTimeout", parent: name, max: 120)
            try self.validate(self.executionTimeout, name: "executionTimeout", parent: name, min: 10)
            try self.validate(self.maximumRetryCount, name: "maximumRetryCount", parent: name, max: 3)
            try self.validate(self.maximumRetryCount, name: "maximumRetryCount", parent: name, min: 0)
            try self.validate(self.stages, name: "stages", parent: name, max: 2)
            try self.validate(self.stages, name: "stages", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executeOperationOnScriptFailure = "ExecuteOperationOnScriptFailure"
            case executionHandler = "ExecutionHandler"
            case executionHandlerService = "ExecutionHandlerService"
            case executionTimeout = "ExecutionTimeout"
            case maximumRetryCount = "MaximumRetryCount"
            case stages = "Stages"
        }
    }

    public struct ShareRule: AWSEncodableShape & AWSDecodableShape {
        /// The IDs of the Amazon Web Services accounts with which to share the snapshots.
        public let targetAccounts: [String]?
        /// The period after which snapshots that are shared with other Amazon Web Services accounts are automatically unshared.
        public let unshareInterval: Int?
        /// The unit of time for the automatic unsharing interval.
        public let unshareIntervalUnit: RetentionIntervalUnitValues?

        @inlinable
        public init(targetAccounts: [String]? = nil, unshareInterval: Int? = nil, unshareIntervalUnit: RetentionIntervalUnitValues? = nil) {
            self.targetAccounts = targetAccounts
            self.unshareInterval = unshareInterval
            self.unshareIntervalUnit = unshareIntervalUnit
        }

        public func validate(name: String) throws {
            try self.targetAccounts?.forEach {
                try validate($0, name: "targetAccounts[]", parent: name, max: 12)
                try validate($0, name: "targetAccounts[]", parent: name, min: 12)
                try validate($0, name: "targetAccounts[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.targetAccounts, name: "targetAccounts", parent: name, min: 1)
            try self.validate(self.unshareInterval, name: "unshareInterval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetAccounts = "TargetAccounts"
            case unshareInterval = "UnshareInterval"
            case unshareIntervalUnit = "UnshareIntervalUnit"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 500)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\p{all}]*$")
            try self.validate(self.value, name: "value", parent: name, max: 500)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\p{all}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// One or more tags.
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:dlm:[A-Za-z0-9_/.-]{0,63}:\\d+:policy/[0-9A-Za-z_-]{1,128}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\p{all}]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:dlm:[A-Za-z0-9_/.-]{0,63}:\\d+:policy/[0-9A-Za-z_-]{1,128}$")
            try self.tagKeys?.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLifecyclePolicyRequest: AWSEncodableShape {
        ///  [Default policies only] Indicates whether the policy should copy tags from the source resource
        /// 			to the snapshot or AMI.
        public let copyTags: Bool?
        ///  [Default policies only] Specifies how often the policy should run and create snapshots or AMIs.
        /// 			The creation frequency can range from 1 to 7 days.
        public let createInterval: Int?
        ///  [Default policies only] Specifies destination Regions for snapshot or AMI copies. You can specify
        /// 			up to 3 destination Regions. If you do not want to create cross-Region copies, omit this
        /// 			parameter.
        public let crossRegionCopyTargets: [CrossRegionCopyTarget]?
        /// A description of the lifecycle policy.
        public let description: String?
        ///  [Default policies only] Specifies exclusion parameters for volumes or instances for which you
        /// 			do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs
        /// 			for target resources that match any of the specified exclusion parameters.
        public let exclusions: Exclusions?
        /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
        /// 			the lifecycle policy.
        public let executionRoleArn: String?
        ///  [Default policies only] Defines the snapshot or AMI retention behavior for the policy if the
        /// 			source volume or instance is deleted, or if the policy enters the error, disabled, or
        /// 			deleted state. By default (ExtendDeletion=false):   If a source resource is deleted, Amazon Data Lifecycle Manager will continue to delete previously
        /// 					created snapshots or AMIs, up to but not including the last one, based on the
        /// 					specified retention period. If you want Amazon Data Lifecycle Manager to delete all snapshots or AMIs,
        /// 					including the last one, specify true.   If a policy enters the error, disabled, or deleted state, Amazon Data Lifecycle Manager stops deleting
        /// 					snapshots and AMIs. If you want Amazon Data Lifecycle Manager to continue deleting snapshots or AMIs,
        /// 					including the last one, if the policy enters one of these states, specify
        /// 					true.   If you enable extended deletion (ExtendDeletion=true),
        /// 			you override both default behaviors simultaneously. Default: false
        public let extendDeletion: Bool?
        /// The configuration of the lifecycle policy. You cannot update the policy type or the
        /// 			resource type.
        public let policyDetails: PolicyDetails?
        /// The identifier of the lifecycle policy.
        public let policyId: String
        ///  [Default policies only] Specifies how long the policy should retain snapshots or AMIs before
        /// 			deleting them. The retention period can range from 2 to 14 days, but it must be greater
        /// 			than the creation frequency to ensure that the policy retains at least 1 snapshot or
        /// 			AMI at any given time.
        public let retainInterval: Int?
        /// The desired activation state of the lifecycle policy after creation.
        public let state: SettablePolicyStateValues?

        @inlinable
        public init(copyTags: Bool? = nil, createInterval: Int? = nil, crossRegionCopyTargets: [CrossRegionCopyTarget]? = nil, description: String? = nil, exclusions: Exclusions? = nil, executionRoleArn: String? = nil, extendDeletion: Bool? = nil, policyDetails: PolicyDetails? = nil, policyId: String, retainInterval: Int? = nil, state: SettablePolicyStateValues? = nil) {
            self.copyTags = copyTags
            self.createInterval = createInterval
            self.crossRegionCopyTargets = crossRegionCopyTargets
            self.description = description
            self.exclusions = exclusions
            self.executionRoleArn = executionRoleArn
            self.extendDeletion = extendDeletion
            self.policyDetails = policyDetails
            self.policyId = policyId
            self.retainInterval = retainInterval
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.copyTags, forKey: .copyTags)
            try container.encodeIfPresent(self.createInterval, forKey: .createInterval)
            try container.encodeIfPresent(self.crossRegionCopyTargets, forKey: .crossRegionCopyTargets)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.exclusions, forKey: .exclusions)
            try container.encodeIfPresent(self.executionRoleArn, forKey: .executionRoleArn)
            try container.encodeIfPresent(self.extendDeletion, forKey: .extendDeletion)
            try container.encodeIfPresent(self.policyDetails, forKey: .policyDetails)
            request.encodePath(self.policyId, key: "PolicyId")
            try container.encodeIfPresent(self.retainInterval, forKey: .retainInterval)
            try container.encodeIfPresent(self.state, forKey: .state)
        }

        public func validate(name: String) throws {
            try self.validate(self.createInterval, name: "createInterval", parent: name, min: 1)
            try self.crossRegionCopyTargets?.forEach {
                try $0.validate(name: "\(name).crossRegionCopyTargets[]")
            }
            try self.validate(self.crossRegionCopyTargets, name: "crossRegionCopyTargets", parent: name, max: 3)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z _-]+$")
            try self.exclusions?.validate(name: "\(name).exclusions")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[a-z]{1,3}){0,2}:iam::\\d+:role/")
            try self.policyDetails?.validate(name: "\(name).policyDetails")
            try self.validate(self.policyId, name: "policyId", parent: name, max: 64)
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "^policy-[a-f0-9]+$")
            try self.validate(self.retainInterval, name: "retainInterval", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case copyTags = "CopyTags"
            case createInterval = "CreateInterval"
            case crossRegionCopyTargets = "CrossRegionCopyTargets"
            case description = "Description"
            case exclusions = "Exclusions"
            case executionRoleArn = "ExecutionRoleArn"
            case extendDeletion = "ExtendDeletion"
            case policyDetails = "PolicyDetails"
            case retainInterval = "RetainInterval"
            case state = "State"
        }
    }

    public struct UpdateLifecyclePolicyResponse: AWSDecodableShape {
        public init() {}
    }
}

// MARK: - Errors

/// Error enum for DLM
public struct DLMErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DLM
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The service failed in an unexpected way.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Bad request. The request is missing required parameters or has invalid
    /// 			parameters.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The request failed because a limit was exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// A requested resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension DLMErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "InternalServerException": DLM.InternalServerException.self,
        "InvalidRequestException": DLM.InvalidRequestException.self,
        "LimitExceededException": DLM.LimitExceededException.self,
        "ResourceNotFoundException": DLM.ResourceNotFoundException.self
    ]
}

extension DLMErrorType: Equatable {
    public static func == (lhs: DLMErrorType, rhs: DLMErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DLMErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
