//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Backup {
    // MARK: Enums

    public enum AggregationPeriod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fourteenDays = "FOURTEEN_DAYS"
        case oneDay = "ONE_DAY"
        case sevenDays = "SEVEN_DAYS"
        public var description: String { return self.rawValue }
    }

    public enum BackupJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case aborting = "ABORTING"
        case completed = "COMPLETED"
        case created = "CREATED"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case partial = "PARTIAL"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum BackupJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case aborting = "ABORTING"
        case aggregateAll = "AGGREGATE_ALL"
        case any = "ANY"
        case completed = "COMPLETED"
        case created = "CREATED"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case partial = "PARTIAL"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum BackupVaultEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backupJobCompleted = "BACKUP_JOB_COMPLETED"
        case backupJobExpired = "BACKUP_JOB_EXPIRED"
        case backupJobFailed = "BACKUP_JOB_FAILED"
        case backupJobStarted = "BACKUP_JOB_STARTED"
        case backupJobSuccessful = "BACKUP_JOB_SUCCESSFUL"
        case backupPlanCreated = "BACKUP_PLAN_CREATED"
        case backupPlanModified = "BACKUP_PLAN_MODIFIED"
        case copyJobFailed = "COPY_JOB_FAILED"
        case copyJobStarted = "COPY_JOB_STARTED"
        case copyJobSuccessful = "COPY_JOB_SUCCESSFUL"
        case recoveryPointModified = "RECOVERY_POINT_MODIFIED"
        case restoreJobCompleted = "RESTORE_JOB_COMPLETED"
        case restoreJobFailed = "RESTORE_JOB_FAILED"
        case restoreJobStarted = "RESTORE_JOB_STARTED"
        case restoreJobSuccessful = "RESTORE_JOB_SUCCESSFUL"
        case s3BackupObjectFailed = "S3_BACKUP_OBJECT_FAILED"
        case s3RestoreObjectFailed = "S3_RESTORE_OBJECT_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ConditionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case stringequals = "STRINGEQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CopyJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case partial = "PARTIAL"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum CopyJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case aborting = "ABORTING"
        case aggregateAll = "AGGREGATE_ALL"
        case any = "ANY"
        case completed = "COMPLETED"
        case completing = "COMPLETING"
        case created = "CREATED"
        case failed = "FAILED"
        case failing = "FAILING"
        case partial = "PARTIAL"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum Index: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum IndexStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum LegalHoldStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case canceled = "CANCELED"
        case canceling = "CANCELING"
        case creating = "CREATING"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryPointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case deleting = "DELETING"
        case expired = "EXPIRED"
        case partial = "PARTIAL"
        public var description: String { return self.rawValue }
    }

    public enum RestoreDeletionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case failed = "FAILED"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum RestoreJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case aggregateAll = "AGGREGATE_ALL"
        case any = "ANY"
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum RestoreJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum RestoreTestingRecoveryPointSelectionAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case latestWithinWindow = "LATEST_WITHIN_WINDOW"
        case randomWithinWindow = "RANDOM_WITHIN_WINDOW"
        public var description: String { return self.rawValue }
    }

    public enum RestoreTestingRecoveryPointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuous = "CONTINUOUS"
        case snapshot = "SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum RestoreValidationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case successful = "SUCCESSFUL"
        case timedOut = "TIMED_OUT"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cold = "COLD"
        case deleted = "DELETED"
        case warm = "WARM"
        public var description: String { return self.rawValue }
    }

    public enum VaultState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum VaultType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backupVault = "BACKUP_VAULT"
        case logicallyAirGappedBackupVault = "LOGICALLY_AIR_GAPPED_BACKUP_VAULT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AdvancedBackupSetting: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Valid values:  Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup.  Set to "WindowsVSS":"disabled" to create a regular backup. The WindowsVSS option is not enabled by default. If you specify an invalid option, you get an InvalidParameterValueException exception. For more information about Windows VSS backups, see Creating a VSS-Enabled Windows Backup.
        public let backupOptions: [String: String]?
        /// Specifies an object containing resource type and backup options. The only supported resource type is Amazon EC2 instances with Windows Volume Shadow Copy Service (VSS). For a CloudFormation example, see the sample CloudFormation template to enable Windows VSS in the Backup User Guide. Valid values: EC2.
        public let resourceType: String?

        @inlinable
        public init(backupOptions: [String: String]? = nil, resourceType: String? = nil) {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.backupOptions?.forEach {
                try validate($0.key, name: "backupOptions.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
                try validate($0.value, name: "backupOptions[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupOptions = "BackupOptions"
            case resourceType = "ResourceType"
        }
    }

    public struct AlreadyExistsException: AWSErrorShape {
        public let arn: String?
        public let code: String?
        public let context: String?
        public let creatorRequestId: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(arn: String? = nil, code: String? = nil, context: String? = nil, creatorRequestId: String? = nil, message: String? = nil, type: String? = nil) {
            self.arn = arn
            self.code = code
            self.context = context
            self.creatorRequestId = creatorRequestId
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case code = "Code"
            case context = "Context"
            case creatorRequestId = "CreatorRequestId"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct BackupJob: AWSDecodableShape {
        /// The account ID that owns the backup job.
        public let accountId: String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String?
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. If you specify an invalid option, you get an InvalidParameterValueException exception.
        public let backupOptions: [String: String]?
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// Represents the type of backup for a backup job.
        public let backupType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public let bytesTransferred: Int64?
        /// The date and time a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The date and time a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let expectedCompletionDate: Date?
        /// Specifies the IAM role ARN used to create the target recovery point. IAM roles other than the default role must include either AWSBackup or AwsBackup in the role name. For example, arn:aws:iam::123456789012:role/AWSBackupRDSAccess. Role names without those strings lack permissions to perform backup jobs.
        public let iamRoleArn: String?
        /// The date on which the backup  job was initiated.
        public let initiationDate: Date?
        /// This is a boolean value indicating this is  a parent (composite) backup job.
        public let isParent: Bool?
        /// This parameter is the job count for the specified  message category. Example strings may include AccessDenied,  SUCCESS, AGGREGATE_ALL, and  INVALIDPARAMETERS. See  Monitoring  for a list of MessageCategory strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let messageCategory: String?
        /// This uniquely identifies a request to Backup  to back up a resource. The return will be the  parent (composite) job ID.
        public let parentJobId: String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The non-unique name of the resource that  belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startBy: Date?
        /// The current state of a backup job.
        public let state: BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public let statusMessage: String?

        @inlinable
        public init(accountId: String? = nil, backupJobId: String? = nil, backupOptions: [String: String]? = nil, backupSizeInBytes: Int64? = nil, backupType: String? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, bytesTransferred: Int64? = nil, completionDate: Date? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, expectedCompletionDate: Date? = nil, iamRoleArn: String? = nil, initiationDate: Date? = nil, isParent: Bool? = nil, messageCategory: String? = nil, parentJobId: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil, startBy: Date? = nil, state: BackupJobState? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.initiationDate = initiationDate
            self.isParent = isParent
            self.messageCategory = messageCategory
            self.parentJobId = parentJobId
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupJobId = "BackupJobId"
            case backupOptions = "BackupOptions"
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupType = "BackupType"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case bytesTransferred = "BytesTransferred"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case expectedCompletionDate = "ExpectedCompletionDate"
            case iamRoleArn = "IamRoleArn"
            case initiationDate = "InitiationDate"
            case isParent = "IsParent"
            case messageCategory = "MessageCategory"
            case parentJobId = "ParentJobId"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case startBy = "StartBy"
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct BackupJobSummary: AWSDecodableShape {
        /// The account ID that owns the jobs within the summary.
        public let accountId: String?
        /// The value as a number of jobs in a job summary.
        public let count: Int?
        /// The value of time in number format of a job end time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let endTime: Date?
        /// This parameter is the job count for the specified  message category. Example strings include AccessDenied,  Success, and InvalidParameters. See  Monitoring  for a list of MessageCategory strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let messageCategory: String?
        /// The Amazon Web Services Regions within the job summary.
        public let region: String?
        /// This value is the job count for the specified resource type.  The request GetSupportedResourceTypes returns  strings for supported resource types.
        public let resourceType: String?
        /// The value of time in number format of a job start time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startTime: Date?
        /// This value is job count for jobs  with the specified state.
        public let state: BackupJobStatus?

        @inlinable
        public init(accountId: String? = nil, count: Int? = nil, endTime: Date? = nil, messageCategory: String? = nil, region: String? = nil, resourceType: String? = nil, startTime: Date? = nil, state: BackupJobStatus? = nil) {
            self.accountId = accountId
            self.count = count
            self.endTime = endTime
            self.messageCategory = messageCategory
            self.region = region
            self.resourceType = resourceType
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case count = "Count"
            case endTime = "EndTime"
            case messageCategory = "MessageCategory"
            case region = "Region"
            case resourceType = "ResourceType"
            case startTime = "StartTime"
            case state = "State"
        }
    }

    public struct BackupPlan: AWSDecodableShape {
        /// Contains a list of BackupOptions for each resource type.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain only alphanumeric or '-_.' special characters. If this is set in the console, it can contain 1 to 50 characters; if this  is set through CLI or API, it can contain 1 to 200 characters.
        public let backupPlanName: String
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public let rules: [BackupRule]

        @inlinable
        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanName: String, rules: [BackupRule]) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanName = "BackupPlanName"
            case rules = "Rules"
        }
    }

    public struct BackupPlanInput: AWSEncodableShape {
        /// Specifies a list of BackupOptions for each resource type. These settings are only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public let backupPlanName: String
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public let rules: [BackupRuleInput]

        @inlinable
        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanName: String, rules: [BackupRuleInput]) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.advancedBackupSettings?.forEach {
                try $0.validate(name: "\(name).advancedBackupSettings[]")
            }
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanName = "BackupPlanName"
            case rules = "Rules"
        }
    }

    public struct BackupPlanTemplatesListMember: AWSDecodableShape {
        /// Uniquely identifies a stored backup plan template.
        public let backupPlanTemplateId: String?
        /// The optional display name of a backup plan template.
        public let backupPlanTemplateName: String?

        @inlinable
        public init(backupPlanTemplateId: String? = nil, backupPlanTemplateName: String? = nil) {
            self.backupPlanTemplateId = backupPlanTemplateId
            self.backupPlanTemplateName = backupPlanTemplateName
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplateId = "BackupPlanTemplateId"
            case backupPlanTemplateName = "BackupPlanTemplateName"
        }
    }

    public struct BackupPlansListMember: AWSDecodableShape {
        /// Contains a list of BackupOptions for a resource type.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The display name of a saved backup plan.
        public let backupPlanName: String?
        /// The date and time a resource backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let deletionDate: Date?
        /// The last time this backup plan was run. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastExecutionDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        @inlinable
        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, backupPlanName: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, deletionDate: Date? = nil, lastExecutionDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanName = backupPlanName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case backupPlanName = "BackupPlanName"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case deletionDate = "DeletionDate"
            case lastExecutionDate = "LastExecutionDate"
            case versionId = "VersionId"
        }
    }

    public struct BackupRule: AWSDecodableShape {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public let completionWindowMinutes: Int64?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public let copyActions: [CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public let enableContinuousBackup: Bool?
        /// IndexActions is an array you use to specify how backup data should  be indexed. eEach BackupRule can have 0 or 1 IndexAction, as each backup can have up  to one index associated with it. Within the array is ResourceType. Only one will be accepted for each BackupRule.
        public let indexActions: [IndexAction]?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Resource types that can transition to cold storage are listed in the Feature availability  by resource table. Backup ignores this expression for other resource types.
        public let lifecycle: Lifecycle?
        /// The tags that are assigned to resources that are associated with this rule when restored from backup.
        public let recoveryPointTags: [String: String]?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public let ruleId: String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public let ruleName: String
        /// A cron expression in UTC specifying when Backup initiates a backup job. For more information about Amazon Web Services cron expressions, see Schedule Expressions for Rules in the Amazon CloudWatch Events User Guide.. Two examples of Amazon Web Services cron expressions are  15 * ? * * * (take a backup every hour at 15 minutes past the hour) and 0 12 * * ? * (take a backup every day at 12 noon UTC). For a table of examples, click the preceding link and scroll down the page.
        public let scheduleExpression: String?
        /// The timezone in which the schedule expression is set. By default,  ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public let scheduleExpressionTimezone: String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.  If this value is included, it must be at least 60 minutes to avoid errors. During the start window, the backup job status remains in CREATED status until it  has successfully begun or until the start window time has run out. If within the start  window time Backup receives an error that allows the job to be retried,  Backup will automatically retry to begin the job at least every 10 minutes  until the backup  successfully begins (the job status changes to RUNNING) or until the job status  changes to EXPIRED (which is expected to occur when the start window time is over).
        public let startWindowMinutes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let targetBackupVaultName: String

        @inlinable
        public init(completionWindowMinutes: Int64? = nil, copyActions: [CopyAction]? = nil, enableContinuousBackup: Bool? = nil, indexActions: [IndexAction]? = nil, lifecycle: Lifecycle? = nil, recoveryPointTags: [String: String]? = nil, ruleId: String? = nil, ruleName: String, scheduleExpression: String? = nil, scheduleExpressionTimezone: String? = nil, startWindowMinutes: Int64? = nil, targetBackupVaultName: String) {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.indexActions = indexActions
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }

        private enum CodingKeys: String, CodingKey {
            case completionWindowMinutes = "CompletionWindowMinutes"
            case copyActions = "CopyActions"
            case enableContinuousBackup = "EnableContinuousBackup"
            case indexActions = "IndexActions"
            case lifecycle = "Lifecycle"
            case recoveryPointTags = "RecoveryPointTags"
            case ruleId = "RuleId"
            case ruleName = "RuleName"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startWindowMinutes = "StartWindowMinutes"
            case targetBackupVaultName = "TargetBackupVaultName"
        }
    }

    public struct BackupRuleInput: AWSEncodableShape {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public let completionWindowMinutes: Int64?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public let copyActions: [CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public let enableContinuousBackup: Bool?
        /// There can up to one IndexAction in each BackupRule, as each backup  can have 0 or 1 backup index associated with it. Within the array is ResourceTypes. Only 1 resource type will  be accepted for each BackupRule. Valid values:    EBS for Amazon Elastic Block Store    S3 for Amazon Simple Storage Service (Amazon S3)
        public let indexActions: [IndexAction]?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold storage. Resource types that can transition to cold storage are listed in the Feature availability  by resource table. Backup ignores this expression for other resource types. This parameter has a maximum value of 100 years (36,500 days).
        public let lifecycle: Lifecycle?
        /// The tags to assign to the resources.
        public let recoveryPointTags: [String: String]?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public let ruleName: String
        /// A CRON expression in UTC specifying when Backup initiates a backup job.
        public let scheduleExpression: String?
        /// The timezone in which the schedule expression is set. By default,  ScheduleExpressions are in UTC. You can modify this to a specified timezone.
        public let scheduleExpressionTimezone: String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.  If this value is included, it must be at least 60 minutes to avoid errors. This parameter has a maximum value of 100 years (52,560,000 minutes). During the start window, the backup job status remains in CREATED status until it  has successfully begun or until the start window time has run out. If within the start  window time Backup receives an error that allows the job to be retried,  Backup will automatically retry to begin the job at least every 10 minutes  until the backup  successfully begins (the job status changes to RUNNING) or until the job status  changes to EXPIRED (which is expected to occur when the start window time is over).
        public let startWindowMinutes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let targetBackupVaultName: String

        @inlinable
        public init(completionWindowMinutes: Int64? = nil, copyActions: [CopyAction]? = nil, enableContinuousBackup: Bool? = nil, indexActions: [IndexAction]? = nil, lifecycle: Lifecycle? = nil, recoveryPointTags: [String: String]? = nil, ruleName: String, scheduleExpression: String? = nil, scheduleExpressionTimezone: String? = nil, startWindowMinutes: Int64? = nil, targetBackupVaultName: String) {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.indexActions = indexActions
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }

        public func validate(name: String) throws {
            try self.indexActions?.forEach {
                try $0.validate(name: "\(name).indexActions[]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.targetBackupVaultName, name: "targetBackupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case completionWindowMinutes = "CompletionWindowMinutes"
            case copyActions = "CopyActions"
            case enableContinuousBackup = "EnableContinuousBackup"
            case indexActions = "IndexActions"
            case lifecycle = "Lifecycle"
            case recoveryPointTags = "RecoveryPointTags"
            case ruleName = "RuleName"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startWindowMinutes = "StartWindowMinutes"
            case targetBackupVaultName = "TargetBackupVaultName"
        }
    }

    public struct BackupSelection: AWSEncodableShape & AWSDecodableShape {
        /// The conditions that you define to assign resources to your backup plans using tags. For example,  "StringEquals": { "ConditionKey": "aws:ResourceTag/backup", "ConditionValue": "daily" }.  Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike. Condition operators are case sensitive. If you specify multiple conditions, the resources much match all conditions (AND logic).
        public let conditions: Conditions?
        /// The ARN of the IAM role that Backup uses to authenticate when backing up the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// The conditions that you define to assign resources to your backup plans using tags. For example,  "StringEquals":  { "ConditionKey": "backup", "ConditionValue": "daily"}.  ListOfTags supports only StringEquals. Condition operators are case sensitive. If you specify multiple conditions, the resources much match any of the conditions (OR logic).
        public let listOfTags: [Condition]?
        /// The Amazon Resource Names (ARNs) of the resources to exclude from a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to exclude many resources from a backup plan, consider a different resource selection strategy, such as assigning only one or a few resource types or refining your resource selection using tags.
        public let notResources: [String]?
        /// The Amazon Resource Names (ARNs) of the resources to assign to a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to assign many resources to a backup plan, consider a different resource selection strategy, such as assigning all resources of a resource type or refining your resource selection using tags. If you specify multiple ARNs, the resources much match any of the ARNs (OR logic).
        public let resources: [String]?
        /// The display name of a resource selection document. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public let selectionName: String

        @inlinable
        public init(conditions: Conditions? = nil, iamRoleArn: String, listOfTags: [Condition]? = nil, notResources: [String]? = nil, resources: [String]? = nil, selectionName: String) {
            self.conditions = conditions
            self.iamRoleArn = iamRoleArn
            self.listOfTags = listOfTags
            self.notResources = notResources
            self.resources = resources
            self.selectionName = selectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.selectionName, name: "selectionName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "Conditions"
            case iamRoleArn = "IamRoleArn"
            case listOfTags = "ListOfTags"
            case notResources = "NotResources"
            case resources = "Resources"
            case selectionName = "SelectionName"
        }
    }

    public struct BackupSelectionsListMember: AWSDecodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Uniquely identifies a request to assign a set of resources to a backup plan.
        public let selectionId: String?
        /// The display name of a resource selection document.
        public let selectionName: String?

        @inlinable
        public init(backupPlanId: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, iamRoleArn: String? = nil, selectionId: String? = nil, selectionName: String? = nil) {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.selectionId = selectionId
            self.selectionName = selectionName
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case iamRoleArn = "IamRoleArn"
            case selectionId = "SelectionId"
            case selectionName = "SelectionName"
        }
    }

    public struct BackupVaultListMember: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String?
        /// The date and time a resource backup is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// A server-side encryption key you can specify to encrypt your backups from services that support full Backup management; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab. If you specify a key, you must specify its ARN, not its alias. If you do not specify a key, Backup creates a KMS key for you by default. To learn which Backup services support full Backup management and how Backup handles encryption for backups from services that do not yet support full Backup, see  Encryption for backups in Backup
        public let encryptionKeyArn: String?
        /// The date and time when Backup Vault Lock configuration becomes immutable, meaning it cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lockDate: Date?
        /// A Boolean value that indicates whether Backup Vault Lock applies to the selected backup vault. If true, Vault Lock prevents delete and update operations on the recovery points in the selected vault.
        public let locked: Bool?
        /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public let maxRetentionDays: Int64?
        /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public let minRetentionDays: Int64?
        /// The number of recovery points that are stored in a backup vault.
        public let numberOfRecoveryPoints: Int64?
        /// The current state of the vault.
        public let vaultState: VaultState?
        /// The type of vault in which the described recovery point is stored.
        public let vaultType: VaultType?

        @inlinable
        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, encryptionKeyArn: String? = nil, lockDate: Date? = nil, locked: Bool? = nil, maxRetentionDays: Int64? = nil, minRetentionDays: Int64? = nil, numberOfRecoveryPoints: Int64? = nil, vaultState: VaultState? = nil, vaultType: VaultType? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.lockDate = lockDate
            self.locked = locked
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
            self.vaultState = vaultState
            self.vaultType = vaultType
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case encryptionKeyArn = "EncryptionKeyArn"
            case lockDate = "LockDate"
            case locked = "Locked"
            case maxRetentionDays = "MaxRetentionDays"
            case minRetentionDays = "MinRetentionDays"
            case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
            case vaultState = "VaultState"
            case vaultType = "VaultType"
        }
    }

    public struct CalculatedLifecycle: AWSDecodableShape {
        /// A timestamp that specifies when to delete a recovery point.
        public let deleteAt: Date?
        /// A timestamp that specifies when to transition a recovery point to cold storage.
        public let moveToColdStorageAt: Date?

        @inlinable
        public init(deleteAt: Date? = nil, moveToColdStorageAt: Date? = nil) {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAt = "DeleteAt"
            case moveToColdStorageAt = "MoveToColdStorageAt"
        }
    }

    public struct CancelLegalHoldInput: AWSEncodableShape {
        /// A string the describes the reason for removing the legal hold.
        public let cancelDescription: String
        /// The ID of the legal hold.
        public let legalHoldId: String
        /// The integer amount, in days, after which to remove legal hold.
        public let retainRecordInDays: Int64?

        @inlinable
        public init(cancelDescription: String, legalHoldId: String, retainRecordInDays: Int64? = nil) {
            self.cancelDescription = cancelDescription
            self.legalHoldId = legalHoldId
            self.retainRecordInDays = retainRecordInDays
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.cancelDescription, key: "cancelDescription")
            request.encodePath(self.legalHoldId, key: "LegalHoldId")
            request.encodeQuery(self.retainRecordInDays, key: "retainRecordInDays")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelLegalHoldOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        public let conditionKey: String
        /// An operation applied to a key-value pair used to assign resources to your backup plan. Condition only supports StringEquals. For more flexible assignment options, including StringLike and the ability to exclude resources from your backup plan, use Conditions (with an "s" on the end) for your  BackupSelection .
        public let conditionType: ConditionType
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        public let conditionValue: String

        @inlinable
        public init(conditionKey: String, conditionType: ConditionType, conditionValue: String) {
            self.conditionKey = conditionKey
            self.conditionType = conditionType
            self.conditionValue = conditionValue
        }

        private enum CodingKeys: String, CodingKey {
            case conditionKey = "ConditionKey"
            case conditionType = "ConditionType"
            case conditionValue = "ConditionValue"
        }
    }

    public struct ConditionParameter: AWSEncodableShape & AWSDecodableShape {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        public let conditionKey: String?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        public let conditionValue: String?

        @inlinable
        public init(conditionKey: String? = nil, conditionValue: String? = nil) {
            self.conditionKey = conditionKey
            self.conditionValue = conditionValue
        }

        private enum CodingKeys: String, CodingKey {
            case conditionKey = "ConditionKey"
            case conditionValue = "ConditionValue"
        }
    }

    public struct Conditions: AWSEncodableShape & AWSDecodableShape {
        /// Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."
        public let stringEquals: [ConditionParameter]?
        /// Filters the values of your tagged resources for matching tag values with the use of a wildcard character (*) anywhere in the string. For example, "prod*" or "*rod*" matches the tag value "production".
        public let stringLike: [ConditionParameter]?
        /// Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."
        public let stringNotEquals: [ConditionParameter]?
        /// Filters the values of your tagged resources for non-matching tag values with the use of a wildcard character (*) anywhere in the string.
        public let stringNotLike: [ConditionParameter]?

        @inlinable
        public init(stringEquals: [ConditionParameter]? = nil, stringLike: [ConditionParameter]? = nil, stringNotEquals: [ConditionParameter]? = nil, stringNotLike: [ConditionParameter]? = nil) {
            self.stringEquals = stringEquals
            self.stringLike = stringLike
            self.stringNotEquals = stringNotEquals
            self.stringNotLike = stringNotLike
        }

        private enum CodingKeys: String, CodingKey {
            case stringEquals = "StringEquals"
            case stringLike = "StringLike"
            case stringNotEquals = "StringNotEquals"
            case stringNotLike = "StringNotLike"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ControlInputParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of a parameter, for example, BackupPlanFrequency.
        public let parameterName: String?
        /// The value of parameter, for example, hourly.
        public let parameterValue: String?

        @inlinable
        public init(parameterName: String? = nil, parameterValue: String? = nil) {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName = "ParameterName"
            case parameterValue = "ParameterValue"
        }
    }

    public struct ControlScope: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the only Amazon Web Services resource that you want your control scope to contain.
        public let complianceResourceIds: [String]?
        /// Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
        public let complianceResourceTypes: [String]?
        /// The tag key-value pair applied to those Amazon Web Services resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided. The tag value is optional, but it cannot be an empty string if you are creating or editing a  framework from the console (though the value can be an empty string when included  in a CloudFormation template). The structure to assign a tag is: [{"Key":"string","Value":"string"}].
        public let tags: [String: String]?

        @inlinable
        public init(complianceResourceIds: [String]? = nil, complianceResourceTypes: [String]? = nil, tags: [String: String]? = nil) {
            self.complianceResourceIds = complianceResourceIds
            self.complianceResourceTypes = complianceResourceTypes
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceResourceIds, name: "complianceResourceIds", parent: name, max: 100)
            try self.validate(self.complianceResourceIds, name: "complianceResourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceResourceIds = "ComplianceResourceIds"
            case complianceResourceTypes = "ComplianceResourceTypes"
            case tags = "Tags"
        }
    }

    public struct CopyAction: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let destinationBackupVaultArn: String
        public let lifecycle: Lifecycle?

        @inlinable
        public init(destinationBackupVaultArn: String, lifecycle: Lifecycle? = nil) {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case lifecycle = "Lifecycle"
        }
    }

    public struct CopyJob: AWSDecodableShape {
        /// The account ID that owns the copy job.
        public let accountId: String?
        /// The size, in bytes, of a copy job.
        public let backupSizeInBytes: Int64?
        /// This returns the statistics of the included  child (nested) copy jobs.
        public let childJobsInState: [CopyJobState: Int64]?
        /// The date and time a copy job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// The identifier of a resource within a composite group, such as  nested (child) recovery point belonging to a composite (parent) stack. The  ID is transferred from  the  logical ID within a stack.
        public let compositeMemberIdentifier: String?
        /// Uniquely identifies a copy job.
        public let copyJobId: String?
        public let createdBy: RecoveryPointCreator?
        /// The date and time a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let destinationBackupVaultArn: String?
        /// An ARN that uniquely identifies a destination recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let destinationRecoveryPointArn: String?
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// This is a boolean value indicating this is  a parent (composite) copy job.
        public let isParent: Bool?
        /// This parameter is the job count for the specified  message category. Example strings may include AccessDenied,  SUCCESS, AGGREGATE_ALL, and  InvalidParameters. See  Monitoring  for a list of MessageCategory strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum
        public let messageCategory: String?
        /// The number of child (nested) copy jobs.
        public let numberOfChildJobs: Int64?
        /// This uniquely identifies a request to Backup  to copy a resource. The return will be the  parent (composite) job ID.
        public let parentJobId: String?
        /// The Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceArn: String?
        /// The non-unique name of the resource that  belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let sourceBackupVaultArn: String?
        /// An ARN that uniquely identifies a source recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let sourceRecoveryPointArn: String?
        /// The current state of a copy job.
        public let state: CopyJobState?
        /// A detailed message explaining the status of the job to copy a resource.
        public let statusMessage: String?

        @inlinable
        public init(accountId: String? = nil, backupSizeInBytes: Int64? = nil, childJobsInState: [CopyJobState: Int64]? = nil, completionDate: Date? = nil, compositeMemberIdentifier: String? = nil, copyJobId: String? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, destinationBackupVaultArn: String? = nil, destinationRecoveryPointArn: String? = nil, iamRoleArn: String? = nil, isParent: Bool? = nil, messageCategory: String? = nil, numberOfChildJobs: Int64? = nil, parentJobId: String? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, sourceRecoveryPointArn: String? = nil, state: CopyJobState? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.childJobsInState = childJobsInState
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.copyJobId = copyJobId
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.destinationRecoveryPointArn = destinationRecoveryPointArn
            self.iamRoleArn = iamRoleArn
            self.isParent = isParent
            self.messageCategory = messageCategory
            self.numberOfChildJobs = numberOfChildJobs
            self.parentJobId = parentJobId
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.sourceRecoveryPointArn = sourceRecoveryPointArn
            self.state = state
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupSizeInBytes = "BackupSizeInBytes"
            case childJobsInState = "ChildJobsInState"
            case completionDate = "CompletionDate"
            case compositeMemberIdentifier = "CompositeMemberIdentifier"
            case copyJobId = "CopyJobId"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case destinationRecoveryPointArn = "DestinationRecoveryPointArn"
            case iamRoleArn = "IamRoleArn"
            case isParent = "IsParent"
            case messageCategory = "MessageCategory"
            case numberOfChildJobs = "NumberOfChildJobs"
            case parentJobId = "ParentJobId"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case sourceRecoveryPointArn = "SourceRecoveryPointArn"
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct CopyJobSummary: AWSDecodableShape {
        /// The account ID that owns the jobs within the summary.
        public let accountId: String?
        /// The value as a number of jobs in a job summary.
        public let count: Int?
        /// The value of time in number format of a job end time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let endTime: Date?
        /// This parameter is the job count for the specified  message category. Example strings include AccessDenied,  Success, and InvalidParameters. See  Monitoring  for a list of MessageCategory strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let messageCategory: String?
        /// The Amazon Web Services Regions within the job summary.
        public let region: String?
        /// This value is the job count for the specified resource type.  The request GetSupportedResourceTypes returns  strings for supported resource types
        public let resourceType: String?
        /// The value of time in number format of a job start time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startTime: Date?
        /// This value is job count for jobs  with the specified state.
        public let state: CopyJobStatus?

        @inlinable
        public init(accountId: String? = nil, count: Int? = nil, endTime: Date? = nil, messageCategory: String? = nil, region: String? = nil, resourceType: String? = nil, startTime: Date? = nil, state: CopyJobStatus? = nil) {
            self.accountId = accountId
            self.count = count
            self.endTime = endTime
            self.messageCategory = messageCategory
            self.region = region
            self.resourceType = resourceType
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case count = "Count"
            case endTime = "EndTime"
            case messageCategory = "MessageCategory"
            case region = "Region"
            case resourceType = "ResourceType"
            case startTime = "StartTime"
            case state = "State"
        }
    }

    public struct CreateBackupPlanInput: AWSEncodableShape {
        /// The body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlanInput
        /// The tags to assign to the backup plan.
        public let backupPlanTags: [String: String]?
        /// Identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?

        @inlinable
        public init(backupPlan: BackupPlanInput, backupPlanTags: [String: String]? = nil, creatorRequestId: String? = nil) {
            self.backupPlan = backupPlan
            self.backupPlanTags = backupPlanTags
            self.creatorRequestId = creatorRequestId
        }

        public func validate(name: String) throws {
            try self.backupPlan.validate(name: "\(name).backupPlan")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
            case backupPlanTags = "BackupPlanTags"
            case creatorRequestId = "CreatorRequestId"
        }
    }

    public struct CreateBackupPlanOutput: AWSDecodableShape {
        /// The settings for a resource type. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// The ID of the backup plan.
        public let backupPlanId: String?
        /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public let versionId: String?

        @inlinable
        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, creationDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case versionId = "VersionId"
        }
    }

    public struct CreateBackupSelectionInput: AWSEncodableShape {
        /// The ID of the backup plan.
        public let backupPlanId: String
        /// The body of a request to assign a set of resources to a backup plan.
        public let backupSelection: BackupSelection
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?

        @inlinable
        public init(backupPlanId: String, backupSelection: BackupSelection, creatorRequestId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.backupSelection = backupSelection
            self.creatorRequestId = creatorRequestId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
            try container.encode(self.backupSelection, forKey: .backupSelection)
            try container.encodeIfPresent(self.creatorRequestId, forKey: .creatorRequestId)
        }

        public func validate(name: String) throws {
            try self.backupSelection.validate(name: "\(name).backupSelection")
        }

        private enum CodingKeys: String, CodingKey {
            case backupSelection = "BackupSelection"
            case creatorRequestId = "CreatorRequestId"
        }
    }

    public struct CreateBackupSelectionOutput: AWSDecodableShape {
        /// The ID of the backup plan.
        public let backupPlanId: String?
        /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String?

        @inlinable
        public init(backupPlanId: String? = nil, creationDate: Date? = nil, selectionId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.selectionId = selectionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case selectionId = "SelectionId"
        }
    }

    public struct CreateBackupVaultInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
        public let backupVaultName: String
        /// The tags to assign to the backup vault.
        public let backupVaultTags: [String: String]?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?

        @inlinable
        public init(backupVaultName: String, backupVaultTags: [String: String]? = nil, creatorRequestId: String? = nil, encryptionKeyArn: String? = nil) {
            self.backupVaultName = backupVaultName
            self.backupVaultTags = backupVaultTags
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encodeIfPresent(self.backupVaultTags, forKey: .backupVaultTags)
            try container.encodeIfPresent(self.creatorRequestId, forKey: .creatorRequestId)
            try container.encodeIfPresent(self.encryptionKeyArn, forKey: .encryptionKeyArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultTags = "BackupVaultTags"
            case creatorRequestId = "CreatorRequestId"
            case encryptionKeyArn = "EncryptionKeyArn"
        }
    }

    public struct CreateBackupVaultOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?

        @inlinable
        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
        }
    }

    public struct CreateFrameworkInput: AWSEncodableShape {
        /// The controls that make up the framework. Each control in the list has a name, input parameters, and scope.
        public let frameworkControls: [FrameworkControl]
        /// An optional description of the framework with a maximum of 1,024 characters.
        public let frameworkDescription: String?
        /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String
        /// The tags to assign to the framework.
        public let frameworkTags: [String: String]?
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?

        @inlinable
        public init(frameworkControls: [FrameworkControl], frameworkDescription: String? = nil, frameworkName: String, frameworkTags: [String: String]? = nil, idempotencyToken: String? = CreateFrameworkInput.idempotencyToken()) {
            self.frameworkControls = frameworkControls
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.frameworkTags = frameworkTags
            self.idempotencyToken = idempotencyToken
        }

        public func validate(name: String) throws {
            try self.frameworkControls.forEach {
                try $0.validate(name: "\(name).frameworkControls[]")
            }
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, max: 1024)
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, pattern: "\\S")
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkControls = "FrameworkControls"
            case frameworkDescription = "FrameworkDescription"
            case frameworkName = "FrameworkName"
            case frameworkTags = "FrameworkTags"
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct CreateFrameworkOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String?

        @inlinable
        public init(frameworkArn: String? = nil, frameworkName: String? = nil) {
            self.frameworkArn = frameworkArn
            self.frameworkName = frameworkName
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkArn = "FrameworkArn"
            case frameworkName = "FrameworkName"
        }
    }

    public struct CreateLegalHoldInput: AWSEncodableShape {
        /// The description of the legal hold.
        public let description: String
        /// This is a user-chosen string used to distinguish between otherwise identical  calls. Retrying a successful request with the  same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// The criteria to assign a set of resources, such as resource types or backup vaults.
        public let recoveryPointSelection: RecoveryPointSelection?
        /// Optional tags to include. A tag is a key-value pair you can use to manage,  filter, and search for your resources. Allowed characters include UTF-8 letters,  numbers, spaces, and the following characters: + - = . _ : /.
        public let tags: [String: String]?
        /// The title of the legal hold.
        public let title: String

        @inlinable
        public init(description: String, idempotencyToken: String? = nil, recoveryPointSelection: RecoveryPointSelection? = nil, tags: [String: String]? = nil, title: String) {
            self.description = description
            self.idempotencyToken = idempotencyToken
            self.recoveryPointSelection = recoveryPointSelection
            self.tags = tags
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case idempotencyToken = "IdempotencyToken"
            case recoveryPointSelection = "RecoveryPointSelection"
            case tags = "Tags"
            case title = "Title"
        }
    }

    public struct CreateLegalHoldOutput: AWSDecodableShape {
        /// The time when the legal hold was created.
        public let creationDate: Date?
        /// The description of the legal hold.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the legal hold.
        public let legalHoldArn: String?
        /// The ID of the legal hold.
        public let legalHoldId: String?
        /// The criteria to assign to a set of resources, such as resource types or backup vaults.
        public let recoveryPointSelection: RecoveryPointSelection?
        /// The status of the legal hold.
        public let status: LegalHoldStatus?
        /// The title of the legal hold.
        public let title: String?

        @inlinable
        public init(creationDate: Date? = nil, description: String? = nil, legalHoldArn: String? = nil, legalHoldId: String? = nil, recoveryPointSelection: RecoveryPointSelection? = nil, status: LegalHoldStatus? = nil, title: String? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.legalHoldArn = legalHoldArn
            self.legalHoldId = legalHoldId
            self.recoveryPointSelection = recoveryPointSelection
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case legalHoldArn = "LegalHoldArn"
            case legalHoldId = "LegalHoldId"
            case recoveryPointSelection = "RecoveryPointSelection"
            case status = "Status"
            case title = "Title"
        }
    }

    public struct CreateLogicallyAirGappedBackupVaultInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Logically air-gapped  backup vaults are identified by names that are unique to the account used to create  them and the Region where they are created.
        public let backupVaultName: String
        /// The tags to assign to the vault.
        public let backupVaultTags: [String: String]?
        /// The ID of the creation request. This parameter is optional. If used, this parameter must contain  1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// The maximum retention period that the vault retains its recovery points.
        public let maxRetentionDays: Int64
        /// This setting specifies the minimum retention period that the vault retains its recovery points. The minimum value accepted is 7 days.
        public let minRetentionDays: Int64

        @inlinable
        public init(backupVaultName: String, backupVaultTags: [String: String]? = nil, creatorRequestId: String? = nil, maxRetentionDays: Int64, minRetentionDays: Int64) {
            self.backupVaultName = backupVaultName
            self.backupVaultTags = backupVaultTags
            self.creatorRequestId = creatorRequestId
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encodeIfPresent(self.backupVaultTags, forKey: .backupVaultTags)
            try container.encodeIfPresent(self.creatorRequestId, forKey: .creatorRequestId)
            try container.encode(self.maxRetentionDays, forKey: .maxRetentionDays)
            try container.encode(self.minRetentionDays, forKey: .minRetentionDays)
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultTags = "BackupVaultTags"
            case creatorRequestId = "CreatorRequestId"
            case maxRetentionDays = "MaxRetentionDays"
            case minRetentionDays = "MinRetentionDays"
        }
    }

    public struct CreateLogicallyAirGappedBackupVaultOutput: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the vault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Logically air-gapped  backup vaults are identified by names that are unique to the account used to create  them and the Region where they are created.
        public let backupVaultName: String?
        /// The date and time when the vault was created. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The current state of the vault.
        public let vaultState: VaultState?

        @inlinable
        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, vaultState: VaultState? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.vaultState = vaultState
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case vaultState = "VaultState"
        }
    }

    public struct CreateReportPlanInput: AWSEncodableShape {
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public let reportDeliveryChannel: ReportDeliveryChannel
        /// An optional description of the report plan with a maximum of 1,024 characters.
        public let reportPlanDescription: String?
        /// The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let reportPlanName: String
        /// The tags to assign to the report plan.
        public let reportPlanTags: [String: String]?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT  If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public let reportSetting: ReportSetting

        @inlinable
        public init(idempotencyToken: String? = CreateReportPlanInput.idempotencyToken(), reportDeliveryChannel: ReportDeliveryChannel, reportPlanDescription: String? = nil, reportPlanName: String, reportPlanTags: [String: String]? = nil, reportSetting: ReportSetting) {
            self.idempotencyToken = idempotencyToken
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportPlanTags = reportPlanTags
            self.reportSetting = reportSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, max: 1024)
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, pattern: "\\S")
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case idempotencyToken = "IdempotencyToken"
            case reportDeliveryChannel = "ReportDeliveryChannel"
            case reportPlanDescription = "ReportPlanDescription"
            case reportPlanName = "ReportPlanName"
            case reportPlanTags = "ReportPlanTags"
            case reportSetting = "ReportSetting"
        }
    }

    public struct CreateReportPlanOutput: AWSDecodableShape {
        /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// The unique name of the report plan.
        public let reportPlanName: String?

        @inlinable
        public init(creationTime: Date? = nil, reportPlanArn: String? = nil, reportPlanName: String? = nil) {
            self.creationTime = creationTime
            self.reportPlanArn = reportPlanArn
            self.reportPlanName = reportPlanName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case reportPlanArn = "ReportPlanArn"
            case reportPlanName = "ReportPlanName"
        }
    }

    public struct CreateRestoreTestingPlanInput: AWSEncodableShape {
        /// This is a unique string that identifies the request and  allows failed requests to be retriedwithout the risk of running  the operation twice. This parameter is optional. If used, this  parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// A restore testing plan must contain a unique RestoreTestingPlanName string you create and must contain a ScheduleExpression cron. You may optionally include a StartWindowHours integer and a CreatorRequestId string. The RestoreTestingPlanName is a unique string that is the name of the restore testing plan. This cannot be changed after creation, and it must consist of only alphanumeric characters and underscores.
        public let restoreTestingPlan: RestoreTestingPlanForCreate
        /// The tags to assign to the restore testing plan.
        public let tags: [String: String]?

        @inlinable
        public init(creatorRequestId: String? = nil, restoreTestingPlan: RestoreTestingPlanForCreate, tags: [String: String]? = nil) {
            self.creatorRequestId = creatorRequestId
            self.restoreTestingPlan = restoreTestingPlan
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creatorRequestId = "CreatorRequestId"
            case restoreTestingPlan = "RestoreTestingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateRestoreTestingPlanOutput: AWSDecodableShape {
        /// The date and time a restore testing plan was created, in Unix format  and Coordinated Universal Time (UTC). The value of CreationTime  is accurate to milliseconds. For example, the value 1516925490.087 represents  Friday, January 26, 2018 12:11:30.087AM.
        public let creationTime: Date
        /// An Amazon Resource Name (ARN) that uniquely identifies the created  restore testing plan.
        public let restoreTestingPlanArn: String
        /// This unique string is the name of the restore testing plan. The name cannot be changed after creation. The name consists of only  alphanumeric characters and underscores. Maximum length is 50.
        public let restoreTestingPlanName: String

        @inlinable
        public init(creationTime: Date, restoreTestingPlanArn: String, restoreTestingPlanName: String) {
            self.creationTime = creationTime
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
            case restoreTestingPlanName = "RestoreTestingPlanName"
        }
    }

    public struct CreateRestoreTestingSelectionInput: AWSEncodableShape {
        /// This is an optional unique string that identifies the request and allows  failed requests to be retried without the risk of running the operation  twice. If used, this parameter must contain  1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// Input the restore testing plan name that was returned from the  related CreateRestoreTestingPlan request.
        public let restoreTestingPlanName: String
        /// This consists of RestoreTestingSelectionName, ProtectedResourceType, and one of the following:    ProtectedResourceArns     ProtectedResourceConditions    Each protected resource type can have one single value. A restore testing selection can include a wildcard value ("*") for ProtectedResourceArns along with ProtectedResourceConditions. Alternatively, you can include up to 30 specific protected resource ARNs in ProtectedResourceArns.
        public let restoreTestingSelection: RestoreTestingSelectionForCreate

        @inlinable
        public init(creatorRequestId: String? = nil, restoreTestingPlanName: String, restoreTestingSelection: RestoreTestingSelectionForCreate) {
            self.creatorRequestId = creatorRequestId
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelection = restoreTestingSelection
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.creatorRequestId, forKey: .creatorRequestId)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
            try container.encode(self.restoreTestingSelection, forKey: .restoreTestingSelection)
        }

        private enum CodingKeys: String, CodingKey {
            case creatorRequestId = "CreatorRequestId"
            case restoreTestingSelection = "RestoreTestingSelection"
        }
    }

    public struct CreateRestoreTestingSelectionOutput: AWSDecodableShape {
        /// The time that the resource testing selection was created.
        public let creationTime: Date
        /// The ARN of the restore testing plan with which the restore  testing selection is associated.
        public let restoreTestingPlanArn: String
        /// The name of the restore testing plan. The name cannot be changed after creation. The name consists of only  alphanumeric characters and underscores. Maximum length is 50.
        public let restoreTestingPlanName: String
        /// The name of the restore testing selection for the related restore testing plan.
        public let restoreTestingSelectionName: String

        @inlinable
        public init(creationTime: Date, restoreTestingPlanArn: String, restoreTestingPlanName: String, restoreTestingSelectionName: String) {
            self.creationTime = creationTime
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case restoreTestingSelectionName = "RestoreTestingSelectionName"
        }
    }

    public struct DateRange: AWSEncodableShape & AWSDecodableShape {
        /// This value is the beginning date, inclusive. The date and time are in Unix format and Coordinated  Universal Time (UTC), and it is accurate to milliseconds  (milliseconds are optional).
        public let fromDate: Date
        /// This value is the end date, inclusive. The date and time are in Unix format and Coordinated  Universal Time (UTC), and it is accurate to milliseconds  (milliseconds are optional).
        public let toDate: Date

        @inlinable
        public init(fromDate: Date, toDate: Date) {
            self.fromDate = fromDate
            self.toDate = toDate
        }

        private enum CodingKeys: String, CodingKey {
            case fromDate = "FromDate"
            case toDate = "ToDate"
        }
    }

    public struct DeleteBackupPlanInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String

        @inlinable
        public init(backupPlanId: String) {
            self.backupPlanId = backupPlanId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupPlanOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let deletionDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        @inlinable
        public init(backupPlanArn: String? = nil, backupPlanId: String? = nil, deletionDate: Date? = nil, versionId: String? = nil) {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.deletionDate = deletionDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case deletionDate = "DeletionDate"
            case versionId = "VersionId"
        }
    }

    public struct DeleteBackupSelectionInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String

        @inlinable
        public init(backupPlanId: String, selectionId: String) {
            self.backupPlanId = backupPlanId
            self.selectionId = selectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
            request.encodePath(self.selectionId, key: "SelectionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultAccessPolicyInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultLockConfigurationInput: AWSEncodableShape {
        /// The name of the backup vault from which to delete Backup Vault Lock.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultNotificationsInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFrameworkInput: AWSEncodableShape {
        /// The unique name of a framework.
        public let frameworkName: String

        @inlinable
        public init(frameworkName: String) {
            self.frameworkName = frameworkName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.frameworkName, key: "FrameworkName")
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRecoveryPointInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReportPlanInput: AWSEncodableShape {
        /// The unique name of a report plan.
        public let reportPlanName: String

        @inlinable
        public init(reportPlanName: String) {
            self.reportPlanName = reportPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.reportPlanName, key: "ReportPlanName")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRestoreTestingPlanInput: AWSEncodableShape {
        /// Required unique name of the restore testing plan you wish  to delete.
        public let restoreTestingPlanName: String

        @inlinable
        public init(restoreTestingPlanName: String) {
            self.restoreTestingPlanName = restoreTestingPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRestoreTestingSelectionInput: AWSEncodableShape {
        /// Required unique name of the restore testing plan that contains the  restore testing selection you wish to delete.
        public let restoreTestingPlanName: String
        /// Required unique name of the restore testing selection you  wish to delete.
        public let restoreTestingSelectionName: String

        @inlinable
        public init(restoreTestingPlanName: String, restoreTestingSelectionName: String) {
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
            request.encodePath(self.restoreTestingSelectionName, key: "RestoreTestingSelectionName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DependencyFailureException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct DescribeBackupJobInput: AWSEncodableShape {
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String

        @inlinable
        public init(backupJobId: String) {
            self.backupJobId = backupJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupJobId, key: "BackupJobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBackupJobOutput: AWSDecodableShape {
        /// Returns the account ID that owns the backup job.
        public let accountId: String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String?
        /// Represents the options specified as part of backup plan or on-demand backup job.
        public let backupOptions: [String: String]?
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// Represents the actual backup type selected for a backup job. For example, if a successful Windows Volume Shadow Copy Service (VSS) backup was taken, BackupType returns "WindowsVSS". If BackupType is empty, then the backup type was a regular backup.
        public let backupType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public let bytesTransferred: Int64?
        /// This returns the statistics of the included child (nested) backup jobs.
        public let childJobsInState: [BackupJobState: Int64]?
        /// The date and time that a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The date and time that a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let expectedCompletionDate: Date?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// The date a backup job was initiated.
        public let initiationDate: Date?
        /// This returns the boolean value that a backup job is a parent (composite) job.
        public let isParent: Bool?
        /// The job count for the specified  message category. Example strings may include AccessDenied, SUCCESS, AGGREGATE_ALL, and INVALIDPARAMETERS. View Monitoring for a list of accepted MessageCategory strings.
        public let messageCategory: String?
        /// This returns the number of child (nested) backup jobs.
        public let numberOfChildJobs: Int64?
        /// This returns the parent (composite) resource backup job ID.
        public let parentJobId: String?
        /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The non-unique name of the resource that  belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startBy: Date?
        /// The current state of a backup job.
        public let state: BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public let statusMessage: String?

        @inlinable
        public init(accountId: String? = nil, backupJobId: String? = nil, backupOptions: [String: String]? = nil, backupSizeInBytes: Int64? = nil, backupType: String? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, bytesTransferred: Int64? = nil, childJobsInState: [BackupJobState: Int64]? = nil, completionDate: Date? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, expectedCompletionDate: Date? = nil, iamRoleArn: String? = nil, initiationDate: Date? = nil, isParent: Bool? = nil, messageCategory: String? = nil, numberOfChildJobs: Int64? = nil, parentJobId: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil, startBy: Date? = nil, state: BackupJobState? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.childJobsInState = childJobsInState
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.initiationDate = initiationDate
            self.isParent = isParent
            self.messageCategory = messageCategory
            self.numberOfChildJobs = numberOfChildJobs
            self.parentJobId = parentJobId
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupJobId = "BackupJobId"
            case backupOptions = "BackupOptions"
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupType = "BackupType"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case bytesTransferred = "BytesTransferred"
            case childJobsInState = "ChildJobsInState"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case expectedCompletionDate = "ExpectedCompletionDate"
            case iamRoleArn = "IamRoleArn"
            case initiationDate = "InitiationDate"
            case isParent = "IsParent"
            case messageCategory = "MessageCategory"
            case numberOfChildJobs = "NumberOfChildJobs"
            case parentJobId = "ParentJobId"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case startBy = "StartBy"
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DescribeBackupVaultInput: AWSEncodableShape {
        /// The account ID of the specified backup vault.
        public let backupVaultAccountId: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultAccountId: String? = nil, backupVaultName: String) {
            self.backupVaultAccountId = backupVaultAccountId
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.backupVaultAccountId, key: "backupVaultAccountId")
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBackupVaultOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
        public let backupVaultName: String?
        /// The date and time that a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// The date and time when Backup Vault Lock configuration cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change any of your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lockDate: Date?
        /// A Boolean that indicates whether Backup Vault Lock is currently protecting the backup vault. True means that Vault Lock causes delete or update operations on the recovery points stored in the vault to fail.
        public let locked: Bool?
        /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public let maxRetentionDays: Int64?
        /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public let minRetentionDays: Int64?
        /// The number of recovery points that are stored in a backup vault.
        public let numberOfRecoveryPoints: Int64?
        /// The current state of the vault.->
        public let vaultState: VaultState?
        /// The type of vault described.
        public let vaultType: VaultType?

        @inlinable
        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, encryptionKeyArn: String? = nil, lockDate: Date? = nil, locked: Bool? = nil, maxRetentionDays: Int64? = nil, minRetentionDays: Int64? = nil, numberOfRecoveryPoints: Int64? = nil, vaultState: VaultState? = nil, vaultType: VaultType? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.lockDate = lockDate
            self.locked = locked
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
            self.vaultState = vaultState
            self.vaultType = vaultType
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case encryptionKeyArn = "EncryptionKeyArn"
            case lockDate = "LockDate"
            case locked = "Locked"
            case maxRetentionDays = "MaxRetentionDays"
            case minRetentionDays = "MinRetentionDays"
            case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
            case vaultState = "VaultState"
            case vaultType = "VaultType"
        }
    }

    public struct DescribeCopyJobInput: AWSEncodableShape {
        /// Uniquely identifies a copy job.
        public let copyJobId: String

        @inlinable
        public init(copyJobId: String) {
            self.copyJobId = copyJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.copyJobId, key: "CopyJobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCopyJobOutput: AWSDecodableShape {
        /// Contains detailed information about a copy job.
        public let copyJob: CopyJob?

        @inlinable
        public init(copyJob: CopyJob? = nil) {
            self.copyJob = copyJob
        }

        private enum CodingKeys: String, CodingKey {
            case copyJob = "CopyJob"
        }
    }

    public struct DescribeFrameworkInput: AWSEncodableShape {
        /// The unique name of a framework.
        public let frameworkName: String

        @inlinable
        public init(frameworkName: String) {
            self.frameworkName = frameworkName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.frameworkName, key: "FrameworkName")
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFrameworkOutput: AWSDecodableShape {
        /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
        public let creationTime: Date?
        /// The deployment status of a framework. The statuses are:  CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public let deploymentStatus: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// The controls that make up the framework. Each control in the list has a name, input parameters, and scope.
        public let frameworkControls: [FrameworkControl]?
        /// An optional description of the framework.
        public let frameworkDescription: String?
        /// The unique name of a framework.
        public let frameworkName: String?
        /// A framework consists of one or more controls. Each control governs a resource, such as backup plans, backup selections, backup vaults, or recovery points. You can also turn Config recording on or off for each resource. The statuses are:    ACTIVE when recording is turned on for all resources governed by the framework.    PARTIALLY_ACTIVE when recording is turned off for at least one resource governed by the framework.    INACTIVE when recording is turned off for all resources governed by the framework.    UNAVAILABLE when Backup is unable to validate recording status at this time.
        public let frameworkStatus: String?
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to DescribeFrameworkOutput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?

        @inlinable
        public init(creationTime: Date? = nil, deploymentStatus: String? = nil, frameworkArn: String? = nil, frameworkControls: [FrameworkControl]? = nil, frameworkDescription: String? = nil, frameworkName: String? = nil, frameworkStatus: String? = nil, idempotencyToken: String? = nil) {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkControls = frameworkControls
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.frameworkStatus = frameworkStatus
            self.idempotencyToken = idempotencyToken
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deploymentStatus = "DeploymentStatus"
            case frameworkArn = "FrameworkArn"
            case frameworkControls = "FrameworkControls"
            case frameworkDescription = "FrameworkDescription"
            case frameworkName = "FrameworkName"
            case frameworkStatus = "FrameworkStatus"
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct DescribeGlobalSettingsInput: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeGlobalSettingsOutput: AWSDecodableShape {
        /// The status of the flag isCrossAccountBackupEnabled.
        public let globalSettings: [String: String]?
        /// The date and time that the flag isCrossAccountBackupEnabled was last updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastUpdateTime: Date?

        @inlinable
        public init(globalSettings: [String: String]? = nil, lastUpdateTime: Date? = nil) {
            self.globalSettings = globalSettings
            self.lastUpdateTime = lastUpdateTime
        }

        private enum CodingKeys: String, CodingKey {
            case globalSettings = "GlobalSettings"
            case lastUpdateTime = "LastUpdateTime"
        }
    }

    public struct DescribeProtectedResourceInput: AWSEncodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProtectedResourceOutput: AWSDecodableShape {
        /// The date and time that a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastBackupTime: Date?
        /// The ARN (Amazon Resource Name) of the backup vault  that contains the most recent backup recovery point.
        public let lastBackupVaultArn: String?
        /// The ARN (Amazon Resource Name) of the most recent  recovery point.
        public let lastRecoveryPointArn: String?
        /// The time, in minutes, that the most recent restore job took to complete.
        public let latestRestoreExecutionTimeMinutes: Int64?
        /// The creation date of the most recent restore job.
        public let latestRestoreJobCreationDate: Date?
        /// The date the most recent recovery point was created.
        public let latestRestoreRecoveryPointCreationDate: Date?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The name of the resource that belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon EBS volume or an Amazon RDS database.
        public let resourceType: String?

        @inlinable
        public init(lastBackupTime: Date? = nil, lastBackupVaultArn: String? = nil, lastRecoveryPointArn: String? = nil, latestRestoreExecutionTimeMinutes: Int64? = nil, latestRestoreJobCreationDate: Date? = nil, latestRestoreRecoveryPointCreationDate: Date? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil) {
            self.lastBackupTime = lastBackupTime
            self.lastBackupVaultArn = lastBackupVaultArn
            self.lastRecoveryPointArn = lastRecoveryPointArn
            self.latestRestoreExecutionTimeMinutes = latestRestoreExecutionTimeMinutes
            self.latestRestoreJobCreationDate = latestRestoreJobCreationDate
            self.latestRestoreRecoveryPointCreationDate = latestRestoreRecoveryPointCreationDate
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case lastBackupTime = "LastBackupTime"
            case lastBackupVaultArn = "LastBackupVaultArn"
            case lastRecoveryPointArn = "LastRecoveryPointArn"
            case latestRestoreExecutionTimeMinutes = "LatestRestoreExecutionTimeMinutes"
            case latestRestoreJobCreationDate = "LatestRestoreJobCreationDate"
            case latestRestoreRecoveryPointCreationDate = "LatestRestoreRecoveryPointCreationDate"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
        }
    }

    public struct DescribeRecoveryPointInput: AWSEncodableShape {
        /// The account ID of the specified backup vault.
        public let backupVaultAccountId: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultAccountId: String? = nil, backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultAccountId = backupVaultAccountId
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.backupVaultAccountId, key: "backupVaultAccountId")
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultAccountId, name: "backupVaultAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRecoveryPointOutput: AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
        public let backupVaultName: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: CalculatedLifecycle?
        /// The date and time that a job to create a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// The identifier of a resource within a composite group, such as  nested (child) recovery point belonging to a composite (parent) stack. The  ID is transferred from the  logical ID within a stack.
        public let compositeMemberIdentifier: String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time that a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The server-side encryption key used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// This is the current status for the backup index associated with the specified recovery point. Statuses are: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE can be included in a search.
        public let indexStatus: IndexStatus?
        /// A string in the form of a detailed message explaining the status of a backup index associated with the recovery point.
        public let indexStatusMessage: String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public let isEncrypted: Bool?
        /// This returns the boolean value that a recovery point is a parent (composite) job.
        public let isParent: Bool?
        /// The date and time that a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastRestoreTime: Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups that are transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Resource types that can transition to cold storage are listed in the Feature  availability by resource table. Backup ignores this expression for other resource types.
        public let lifecycle: Lifecycle?
        /// This is an ARN that uniquely identifies a parent (composite) recovery point; for example,  arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let parentRecoveryPointArn: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The name of the resource that belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource to save as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault. If the recovery is restored to the same Amazon Web Services account or Region, this value will be null.
        public let sourceBackupVaultArn: String?
        /// A status code specifying the state of the recovery point.  PARTIAL status indicates Backup could not create the recovery point before the backup window closed. To increase your backup plan window using the API, see UpdateBackupPlan. You can also increase your backup plan window using the Console by choosing and editing your backup plan.  EXPIRED status indicates that the recovery point has exceeded its retention period, but Backup lacks permission or is otherwise unable to delete it. To manually delete these recovery points, see  Step 3: Delete the recovery points in the Clean up resources section of Getting started.  STOPPED status occurs on a continuous backup where a user has taken some  action that causes the continuous backup to be disabled. This can be caused by the removal of permissions, turning off versioning, turning off events being sent to EventBridge,  or disabling the EventBridge rules that are put in place by Backup. For  recovery points of Amazon S3, Amazon RDS, and Amazon Aurora resources, this status  occurs when the retention period of a continuous backup rule is changed. To resolve STOPPED status, ensure that all requested permissions are in place and that versioning is enabled on the S3 bucket. Once these conditions are met, the next instance of a backup rule running will result in a new continuous recovery point being created.  The recovery points with STOPPED status do not need to be deleted. For SAP HANA on Amazon EC2 STOPPED status occurs due to user action, application misconfiguration, or backup failure. To ensure that future continuous backups succeed, refer to the recovery point status and check SAP HANA for details.
        public let status: RecoveryPointStatus?
        /// A status message explaining the status of the recovery point.
        public let statusMessage: String?
        /// Specifies the storage class of the recovery point. Valid values are WARM or COLD.
        public let storageClass: StorageClass?
        /// The type of vault in which the described recovery point is stored.
        public let vaultType: VaultType?

        @inlinable
        public init(backupSizeInBytes: Int64? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, calculatedLifecycle: CalculatedLifecycle? = nil, completionDate: Date? = nil, compositeMemberIdentifier: String? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, encryptionKeyArn: String? = nil, iamRoleArn: String? = nil, indexStatus: IndexStatus? = nil, indexStatusMessage: String? = nil, isEncrypted: Bool? = nil, isParent: Bool? = nil, lastRestoreTime: Date? = nil, lifecycle: Lifecycle? = nil, parentRecoveryPointArn: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, status: RecoveryPointStatus? = nil, statusMessage: String? = nil, storageClass: StorageClass? = nil, vaultType: VaultType? = nil) {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.indexStatus = indexStatus
            self.indexStatusMessage = indexStatusMessage
            self.isEncrypted = isEncrypted
            self.isParent = isParent
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.storageClass = storageClass
            self.vaultType = vaultType
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case calculatedLifecycle = "CalculatedLifecycle"
            case completionDate = "CompletionDate"
            case compositeMemberIdentifier = "CompositeMemberIdentifier"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case iamRoleArn = "IamRoleArn"
            case indexStatus = "IndexStatus"
            case indexStatusMessage = "IndexStatusMessage"
            case isEncrypted = "IsEncrypted"
            case isParent = "IsParent"
            case lastRestoreTime = "LastRestoreTime"
            case lifecycle = "Lifecycle"
            case parentRecoveryPointArn = "ParentRecoveryPointArn"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case storageClass = "StorageClass"
            case vaultType = "VaultType"
        }
    }

    public struct DescribeRegionSettingsInput: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeRegionSettingsOutput: AWSDecodableShape {
        /// Returns whether Backup fully manages the backups for a resource type. For the benefits of full Backup management, see Full Backup  management. For a list of resource types and whether each supports full Backup management,  see the Feature availability by resource table. If "DynamoDB":false, you can enable full Backup management for DynamoDB backup by enabling  Backup's advanced DynamoDB backup features.
        public let resourceTypeManagementPreference: [String: Bool]?
        /// The services along with the opt-in preferences in the Region.
        public let resourceTypeOptInPreference: [String: Bool]?

        @inlinable
        public init(resourceTypeManagementPreference: [String: Bool]? = nil, resourceTypeOptInPreference: [String: Bool]? = nil) {
            self.resourceTypeManagementPreference = resourceTypeManagementPreference
            self.resourceTypeOptInPreference = resourceTypeOptInPreference
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
            case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
        }
    }

    public struct DescribeReportJobInput: AWSEncodableShape {
        /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
        public let reportJobId: String

        @inlinable
        public init(reportJobId: String) {
            self.reportJobId = reportJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.reportJobId, key: "ReportJobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReportJobOutput: AWSDecodableShape {
        /// The information about a report job, including its completion and creation times, report destination, unique report job ID, Amazon Resource Name (ARN), report template, status, and status message.
        public let reportJob: ReportJob?

        @inlinable
        public init(reportJob: ReportJob? = nil) {
            self.reportJob = reportJob
        }

        private enum CodingKeys: String, CodingKey {
            case reportJob = "ReportJob"
        }
    }

    public struct DescribeReportPlanInput: AWSEncodableShape {
        /// The unique name of a report plan.
        public let reportPlanName: String

        @inlinable
        public init(reportPlanName: String) {
            self.reportPlanName = reportPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.reportPlanName, key: "ReportPlanName")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReportPlanOutput: AWSDecodableShape {
        /// Returns details about the report plan that is specified by its name. These details include the report plan's Amazon Resource Name (ARN), description, settings, delivery channel, deployment status, creation time, and last attempted and successful run times.
        public let reportPlan: ReportPlan?

        @inlinable
        public init(reportPlan: ReportPlan? = nil) {
            self.reportPlan = reportPlan
        }

        private enum CodingKeys: String, CodingKey {
            case reportPlan = "ReportPlan"
        }
    }

    public struct DescribeRestoreJobInput: AWSEncodableShape {
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String

        @inlinable
        public init(restoreJobId: String) {
            self.restoreJobId = restoreJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreJobId, key: "RestoreJobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRestoreJobOutput: AWSDecodableShape {
        /// Returns the account ID that owns the restore job.
        public let accountId: String?
        /// The size, in bytes, of the restored resource.
        public let backupSizeInBytes: Int64?
        /// The date and time that a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a restore job.
        public let createdBy: RestoreJobCreator?
        /// The Amazon Resource Name (ARN) of the resource that  was created by the restore job. The format of the ARN depends on the resource type of the backed-up resource.
        public let createdResourceArn: String?
        /// The date and time that a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The status of the data generated by the restore test.
        public let deletionStatus: RestoreDeletionStatus?
        /// This describes the restore job deletion status.
        public let deletionStatusMessage: String?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public let expectedCompletionTimeMinutes: Int64?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// The creation date of the recovery point made by the specifed restore job.
        public let recoveryPointCreationDate: Date?
        /// Returns metadata associated with a restore job listed by resource type.
        public let resourceType: String?
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String?
        /// Status code specifying the state of the job that is initiated by Backup to restore a recovery point.
        public let status: RestoreJobStatus?
        /// A message showing the status of a job to restore a recovery point.
        public let statusMessage: String?
        /// The status of validation run on the indicated  restore job.
        public let validationStatus: RestoreValidationStatus?
        /// The status message.
        public let validationStatusMessage: String?

        @inlinable
        public init(accountId: String? = nil, backupSizeInBytes: Int64? = nil, completionDate: Date? = nil, createdBy: RestoreJobCreator? = nil, createdResourceArn: String? = nil, creationDate: Date? = nil, deletionStatus: RestoreDeletionStatus? = nil, deletionStatusMessage: String? = nil, expectedCompletionTimeMinutes: Int64? = nil, iamRoleArn: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, recoveryPointCreationDate: Date? = nil, resourceType: String? = nil, restoreJobId: String? = nil, status: RestoreJobStatus? = nil, statusMessage: String? = nil, validationStatus: RestoreValidationStatus? = nil, validationStatusMessage: String? = nil) {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.deletionStatus = deletionStatus
            self.deletionStatusMessage = deletionStatusMessage
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.recoveryPointCreationDate = recoveryPointCreationDate
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
            self.validationStatus = validationStatus
            self.validationStatusMessage = validationStatusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupSizeInBytes = "BackupSizeInBytes"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case createdResourceArn = "CreatedResourceArn"
            case creationDate = "CreationDate"
            case deletionStatus = "DeletionStatus"
            case deletionStatusMessage = "DeletionStatusMessage"
            case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
            case iamRoleArn = "IamRoleArn"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case recoveryPointCreationDate = "RecoveryPointCreationDate"
            case resourceType = "ResourceType"
            case restoreJobId = "RestoreJobId"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case validationStatus = "ValidationStatus"
            case validationStatusMessage = "ValidationStatusMessage"
        }
    }

    public struct DisassociateRecoveryPointFromParentInput: AWSEncodableShape {
        /// The name of a logical container where the child (nested) recovery point is stored. Backup vaults are identified by names that are unique to the account used  to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// The Amazon Resource Name (ARN) that uniquely identifies the child  (nested) recovery point; for example,  arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateRecoveryPointInput: AWSEncodableShape {
        /// The unique name of an Backup vault.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery point.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportBackupPlanTemplateInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String

        @inlinable
        public init(backupPlanId: String) {
            self.backupPlanId = backupPlanId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportBackupPlanTemplateOutput: AWSDecodableShape {
        /// The body of a backup plan template in JSON format.  This is a signed JSON document that cannot be modified before being passed to GetBackupPlanFromJSON.
        public let backupPlanTemplateJson: String?

        @inlinable
        public init(backupPlanTemplateJson: String? = nil) {
            self.backupPlanTemplateJson = backupPlanTemplateJson
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplateJson = "BackupPlanTemplateJson"
        }
    }

    public struct Framework: AWSDecodableShape {
        /// The date and time that a framework is created, in ISO 8601 representation.  The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
        public let creationTime: Date?
        /// The deployment status of a framework. The statuses are:  CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public let deploymentStatus: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// An optional description of the framework with a maximum 1,024 characters.
        public let frameworkDescription: String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String?
        /// The number of controls contained by the framework.
        public let numberOfControls: Int?

        @inlinable
        public init(creationTime: Date? = nil, deploymentStatus: String? = nil, frameworkArn: String? = nil, frameworkDescription: String? = nil, frameworkName: String? = nil, numberOfControls: Int? = nil) {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.numberOfControls = numberOfControls
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deploymentStatus = "DeploymentStatus"
            case frameworkArn = "FrameworkArn"
            case frameworkDescription = "FrameworkDescription"
            case frameworkName = "FrameworkName"
            case numberOfControls = "NumberOfControls"
        }
    }

    public struct FrameworkControl: AWSEncodableShape & AWSDecodableShape {
        /// The name/value pairs.
        public let controlInputParameters: [ControlInputParameter]?
        /// The name of a control. This name is between 1 and 256 characters.
        public let controlName: String
        /// The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. For more information, see  ControlScope.
        public let controlScope: ControlScope?

        @inlinable
        public init(controlInputParameters: [ControlInputParameter]? = nil, controlName: String, controlScope: ControlScope? = nil) {
            self.controlInputParameters = controlInputParameters
            self.controlName = controlName
            self.controlScope = controlScope
        }

        public func validate(name: String) throws {
            try self.controlScope?.validate(name: "\(name).controlScope")
        }

        private enum CodingKeys: String, CodingKey {
            case controlInputParameters = "ControlInputParameters"
            case controlName = "ControlName"
            case controlScope = "ControlScope"
        }
    }

    public struct GetBackupPlanFromJSONInput: AWSEncodableShape {
        /// A customer-supplied backup plan document in JSON format.
        public let backupPlanTemplateJson: String

        @inlinable
        public init(backupPlanTemplateJson: String) {
            self.backupPlanTemplateJson = backupPlanTemplateJson
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplateJson = "BackupPlanTemplateJson"
        }
    }

    public struct GetBackupPlanFromJSONOutput: AWSDecodableShape {
        /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlan?

        @inlinable
        public init(backupPlan: BackupPlan? = nil) {
            self.backupPlan = backupPlan
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
        }
    }

    public struct GetBackupPlanFromTemplateInput: AWSEncodableShape {
        /// Uniquely identifies a stored backup plan template.
        public let backupPlanTemplateId: String

        @inlinable
        public init(backupPlanTemplateId: String) {
            self.backupPlanTemplateId = backupPlanTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanTemplateId, key: "BackupPlanTemplateId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupPlanFromTemplateOutput: AWSDecodableShape {
        /// Returns the body of a backup plan based on the target template, including the name, rules, and backup vault of the plan.
        public let backupPlanDocument: BackupPlan?

        @inlinable
        public init(backupPlanDocument: BackupPlan? = nil) {
            self.backupPlanDocument = backupPlanDocument
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanDocument = "BackupPlanDocument"
        }
    }

    public struct GetBackupPlanInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        @inlinable
        public init(backupPlanId: String, versionId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
            request.encodeQuery(self.versionId, key: "versionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupPlanOutput: AWSDecodableShape {
        /// Contains a list of BackupOptions for each resource type. The list is populated only if the advanced option is set for the backup plan.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlan?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// The date and time that a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let deletionDate: Date?
        /// The last time this backup plan was run. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastExecutionDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        @inlinable
        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlan: BackupPlan? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, deletionDate: Date? = nil, lastExecutionDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlan = backupPlan
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlan = "BackupPlan"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case deletionDate = "DeletionDate"
            case lastExecutionDate = "LastExecutionDate"
            case versionId = "VersionId"
        }
    }

    public struct GetBackupSelectionInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String

        @inlinable
        public init(backupPlanId: String, selectionId: String) {
            self.backupPlanId = backupPlanId
            self.selectionId = selectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
            request.encodePath(self.selectionId, key: "SelectionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupSelectionOutput: AWSDecodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// Specifies the body of a request to assign a set of resources to a backup plan.
        public let backupSelection: BackupSelection?
        /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String?

        @inlinable
        public init(backupPlanId: String? = nil, backupSelection: BackupSelection? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, selectionId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.backupSelection = backupSelection
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.selectionId = selectionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanId = "BackupPlanId"
            case backupSelection = "BackupSelection"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case selectionId = "SelectionId"
        }
    }

    public struct GetBackupVaultAccessPolicyInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupVaultAccessPolicyOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
        public let backupVaultName: String?
        /// The backup vault access policy document in JSON format.
        public let policy: String?

        @inlinable
        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, policy: String? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case policy = "Policy"
        }
    }

    public struct GetBackupVaultNotificationsInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String

        @inlinable
        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupVaultNotificationsOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// An array of events that indicate the status of jobs to back up resources to the backup vault.
        public let backupVaultEvents: [BackupVaultEvent]?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
        public let backupVaultName: String?
        /// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
        public let snsTopicArn: String?

        @inlinable
        public init(backupVaultArn: String? = nil, backupVaultEvents: [BackupVaultEvent]? = nil, backupVaultName: String? = nil, snsTopicArn: String? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultEvents = backupVaultEvents
            self.backupVaultName = backupVaultName
            self.snsTopicArn = snsTopicArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultEvents = "BackupVaultEvents"
            case backupVaultName = "BackupVaultName"
            case snsTopicArn = "SNSTopicArn"
        }
    }

    public struct GetLegalHoldInput: AWSEncodableShape {
        /// The ID of the legal hold.
        public let legalHoldId: String

        @inlinable
        public init(legalHoldId: String) {
            self.legalHoldId = legalHoldId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.legalHoldId, key: "LegalHoldId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLegalHoldOutput: AWSDecodableShape {
        /// The reason for removing the legal hold.
        public let cancelDescription: String?
        /// The time when the legal hold was cancelled.
        public let cancellationDate: Date?
        /// The time when the legal hold was created.
        public let creationDate: Date?
        /// The description of the legal hold.
        public let description: String?
        /// The framework ARN for the specified legal hold. The format  of the ARN depends on the resource type.
        public let legalHoldArn: String?
        /// The ID of the legal hold.
        public let legalHoldId: String?
        /// The criteria to assign a set of resources, such as resource types or backup vaults.
        public let recoveryPointSelection: RecoveryPointSelection?
        /// The date and time until which the legal hold record is retained.
        public let retainRecordUntil: Date?
        /// The status of the legal hold.
        public let status: LegalHoldStatus?
        /// The title of the legal hold.
        public let title: String?

        @inlinable
        public init(cancelDescription: String? = nil, cancellationDate: Date? = nil, creationDate: Date? = nil, description: String? = nil, legalHoldArn: String? = nil, legalHoldId: String? = nil, recoveryPointSelection: RecoveryPointSelection? = nil, retainRecordUntil: Date? = nil, status: LegalHoldStatus? = nil, title: String? = nil) {
            self.cancelDescription = cancelDescription
            self.cancellationDate = cancellationDate
            self.creationDate = creationDate
            self.description = description
            self.legalHoldArn = legalHoldArn
            self.legalHoldId = legalHoldId
            self.recoveryPointSelection = recoveryPointSelection
            self.retainRecordUntil = retainRecordUntil
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case cancelDescription = "CancelDescription"
            case cancellationDate = "CancellationDate"
            case creationDate = "CreationDate"
            case description = "Description"
            case legalHoldArn = "LegalHoldArn"
            case legalHoldId = "LegalHoldId"
            case recoveryPointSelection = "RecoveryPointSelection"
            case retainRecordUntil = "RetainRecordUntil"
            case status = "Status"
            case title = "Title"
        }
    }

    public struct GetRecoveryPointIndexDetailsInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. Accepted characters include lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecoveryPointIndexDetailsOutput: AWSDecodableShape {
        /// An ARN that uniquely identifies the backup vault where the recovery  point index is stored. For example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The date and time that a backup index finished creation, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let indexCompletionDate: Date?
        /// The date and time that a backup index was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let indexCreationDate: Date?
        /// The date and time that a backup index was deleted, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let indexDeletionDate: Date?
        /// This is the current status for the backup index associated  with the specified recovery point. Statuses are: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE  can be included in a search.
        public let indexStatus: IndexStatus?
        /// A detailed message explaining the status of a backup index associated  with the recovery point.
        public let indexStatusMessage: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// A string of the  Amazon Resource Name (ARN) that uniquely identifies  the source resource.
        public let sourceResourceArn: String?
        /// Count of items within the backup index associated with the  recovery point.
        public let totalItemsIndexed: Int64?

        @inlinable
        public init(backupVaultArn: String? = nil, indexCompletionDate: Date? = nil, indexCreationDate: Date? = nil, indexDeletionDate: Date? = nil, indexStatus: IndexStatus? = nil, indexStatusMessage: String? = nil, recoveryPointArn: String? = nil, sourceResourceArn: String? = nil, totalItemsIndexed: Int64? = nil) {
            self.backupVaultArn = backupVaultArn
            self.indexCompletionDate = indexCompletionDate
            self.indexCreationDate = indexCreationDate
            self.indexDeletionDate = indexDeletionDate
            self.indexStatus = indexStatus
            self.indexStatusMessage = indexStatusMessage
            self.recoveryPointArn = recoveryPointArn
            self.sourceResourceArn = sourceResourceArn
            self.totalItemsIndexed = totalItemsIndexed
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case indexCompletionDate = "IndexCompletionDate"
            case indexCreationDate = "IndexCreationDate"
            case indexDeletionDate = "IndexDeletionDate"
            case indexStatus = "IndexStatus"
            case indexStatusMessage = "IndexStatusMessage"
            case recoveryPointArn = "RecoveryPointArn"
            case sourceResourceArn = "SourceResourceArn"
            case totalItemsIndexed = "TotalItemsIndexed"
        }
    }

    public struct GetRecoveryPointRestoreMetadataInput: AWSEncodableShape {
        /// The account ID of the specified backup vault.
        public let backupVaultAccountId: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultAccountId: String? = nil, backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultAccountId = backupVaultAccountId
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.backupVaultAccountId, key: "backupVaultAccountId")
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultAccountId, name: "backupVaultAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecoveryPointRestoreMetadataOutput: AWSDecodableShape {
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// The resource type of the recovery point.
        public let resourceType: String?
        /// The set of metadata key-value pairs that describe the original configuration of the backed-up resource. These values vary depending on the service that is being restored.
        public let restoreMetadata: [String: String]?

        @inlinable
        public init(backupVaultArn: String? = nil, recoveryPointArn: String? = nil, resourceType: String? = nil, restoreMetadata: [String: String]? = nil) {
            self.backupVaultArn = backupVaultArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.restoreMetadata = restoreMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceType = "ResourceType"
            case restoreMetadata = "RestoreMetadata"
        }
    }

    public struct GetRestoreJobMetadataInput: AWSEncodableShape {
        /// This is a unique identifier of a restore job within Backup.
        public let restoreJobId: String

        @inlinable
        public init(restoreJobId: String) {
            self.restoreJobId = restoreJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreJobId, key: "RestoreJobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRestoreJobMetadataOutput: AWSDecodableShape {
        /// This contains the metadata of the specified backup job.
        public let metadata: [String: String]?
        /// This is a unique identifier of a restore job within Backup.
        public let restoreJobId: String?

        @inlinable
        public init(metadata: [String: String]? = nil, restoreJobId: String? = nil) {
            self.metadata = metadata
            self.restoreJobId = restoreJobId
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case restoreJobId = "RestoreJobId"
        }
    }

    public struct GetRestoreTestingInferredMetadataInput: AWSEncodableShape {
        /// The account ID of the specified backup vault.
        public let backupVaultAccountId: String?
        /// The name of a logical container where backups are stored. Backup  vaults are identified by names that are unique to the account used to  create them and the Amazon Web ServicesRegion where they are created.  They consist of letters, numbers, and hyphens.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery  point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultAccountId: String? = nil, backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultAccountId = backupVaultAccountId
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.backupVaultAccountId, key: "BackupVaultAccountId")
            request.encodeQuery(self.backupVaultName, key: "BackupVaultName")
            request.encodeQuery(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRestoreTestingInferredMetadataOutput: AWSDecodableShape {
        /// This is a string map of the metadata inferred from the request.
        public let inferredMetadata: [String: String]

        @inlinable
        public init(inferredMetadata: [String: String]) {
            self.inferredMetadata = inferredMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case inferredMetadata = "InferredMetadata"
        }
    }

    public struct GetRestoreTestingPlanInput: AWSEncodableShape {
        /// Required unique name of the restore testing plan.
        public let restoreTestingPlanName: String

        @inlinable
        public init(restoreTestingPlanName: String) {
            self.restoreTestingPlanName = restoreTestingPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRestoreTestingPlanOutput: AWSDecodableShape {
        /// Specifies the body of a restore testing plan. Includes  RestoreTestingPlanName.
        public let restoreTestingPlan: RestoreTestingPlanForGet

        @inlinable
        public init(restoreTestingPlan: RestoreTestingPlanForGet) {
            self.restoreTestingPlan = restoreTestingPlan
        }

        private enum CodingKeys: String, CodingKey {
            case restoreTestingPlan = "RestoreTestingPlan"
        }
    }

    public struct GetRestoreTestingSelectionInput: AWSEncodableShape {
        /// Required unique name of the restore testing plan.
        public let restoreTestingPlanName: String
        /// Required unique name of the restore testing selection.
        public let restoreTestingSelectionName: String

        @inlinable
        public init(restoreTestingPlanName: String, restoreTestingSelectionName: String) {
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
            request.encodePath(self.restoreTestingSelectionName, key: "RestoreTestingSelectionName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRestoreTestingSelectionOutput: AWSDecodableShape {
        /// Unique name of the restore testing selection.
        public let restoreTestingSelection: RestoreTestingSelectionForGet

        @inlinable
        public init(restoreTestingSelection: RestoreTestingSelectionForGet) {
            self.restoreTestingSelection = restoreTestingSelection
        }

        private enum CodingKeys: String, CodingKey {
            case restoreTestingSelection = "RestoreTestingSelection"
        }
    }

    public struct GetSupportedResourceTypesOutput: AWSDecodableShape {
        /// Contains a string with the supported Amazon Web Services resource types:    Aurora for Amazon Aurora    CloudFormation for CloudFormation    DocumentDB for Amazon DocumentDB (with MongoDB compatibility)    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    FSx for Amazon FSx    Neptune for Amazon Neptune    RDS for Amazon Relational Database Service    Redshift for Amazon Redshift    S3 for Amazon Simple Storage Service (Amazon S3)    SAP HANA on Amazon EC2 for SAP HANA databases  on Amazon Elastic Compute Cloud instances    Storage Gateway for Storage Gateway    Timestream for Amazon Timestream    VirtualMachine for VMware virtual machines
        public let resourceTypes: [String]?

        @inlinable
        public init(resourceTypes: [String]? = nil) {
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct IndexAction: AWSEncodableShape & AWSDecodableShape {
        /// 0 or 1 index action will be accepted for each BackupRule. Valid values:    EBS for Amazon Elastic Block Store    S3 for Amazon Simple Storage Service (Amazon S3)
        public let resourceTypes: [String]?

        @inlinable
        public init(resourceTypes: [String]? = nil) {
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.resourceTypes?.forEach {
                try validate($0, name: "resourceTypes[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct IndexedRecoveryPoint: AWSDecodableShape {
        /// The date and time that a backup was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let backupCreationDate: Date?
        /// An ARN that uniquely identifies the backup vault where the recovery  point index is stored. For example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// This specifies the IAM role ARN used for this operation. For example, arn:aws:iam::123456789012:role/S3Access
        public let iamRoleArn: String?
        /// The date and time that a backup index was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let indexCreationDate: Date?
        /// This is the current status for the backup index associated  with the specified recovery point. Statuses are: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE  can be included in a search.
        public let indexStatus: IndexStatus?
        /// A string in the form of a detailed message explaining the status of a backup index associated  with the recovery point.
        public let indexStatusMessage: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45
        public let recoveryPointArn: String?
        /// The resource type of the indexed recovery point.    EBS for Amazon Elastic Block Store    S3 for Amazon Simple Storage Service (Amazon S3)
        public let resourceType: String?
        /// A string of the  Amazon Resource Name (ARN) that uniquely identifies  the source resource.
        public let sourceResourceArn: String?

        @inlinable
        public init(backupCreationDate: Date? = nil, backupVaultArn: String? = nil, iamRoleArn: String? = nil, indexCreationDate: Date? = nil, indexStatus: IndexStatus? = nil, indexStatusMessage: String? = nil, recoveryPointArn: String? = nil, resourceType: String? = nil, sourceResourceArn: String? = nil) {
            self.backupCreationDate = backupCreationDate
            self.backupVaultArn = backupVaultArn
            self.iamRoleArn = iamRoleArn
            self.indexCreationDate = indexCreationDate
            self.indexStatus = indexStatus
            self.indexStatusMessage = indexStatusMessage
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.sourceResourceArn = sourceResourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupCreationDate = "BackupCreationDate"
            case backupVaultArn = "BackupVaultArn"
            case iamRoleArn = "IamRoleArn"
            case indexCreationDate = "IndexCreationDate"
            case indexStatus = "IndexStatus"
            case indexStatusMessage = "IndexStatusMessage"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceType = "ResourceType"
            case sourceResourceArn = "SourceResourceArn"
        }
    }

    public struct InvalidParameterValueException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvalidRequestException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct InvalidResourceStateException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct KeyValue: AWSEncodableShape & AWSDecodableShape {
        /// The tag key (String). The key can't start with  aws:. Length Constraints: Minimum length of 1. Maximum  length of 128. Pattern: ^(?![aA]{1}[wW]{1}[sS]{1}:)([\p{L}\p{Z}\p{N}_.:/=+\-@]+)$
        public let key: String
        /// The value of the key. Length Constraints: Maximum length of 256. Pattern: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct LegalHold: AWSDecodableShape {
        /// The time when the legal hold was cancelled.
        public let cancellationDate: Date?
        /// The time when the legal hold was created.
        public let creationDate: Date?
        /// The description of a legal hold.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the legal hold; for example,  arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let legalHoldArn: String?
        /// The ID of the legal hold.
        public let legalHoldId: String?
        /// The status of the legal hold.
        public let status: LegalHoldStatus?
        /// The title of a legal hold.
        public let title: String?

        @inlinable
        public init(cancellationDate: Date? = nil, creationDate: Date? = nil, description: String? = nil, legalHoldArn: String? = nil, legalHoldId: String? = nil, status: LegalHoldStatus? = nil, title: String? = nil) {
            self.cancellationDate = cancellationDate
            self.creationDate = creationDate
            self.description = description
            self.legalHoldArn = legalHoldArn
            self.legalHoldId = legalHoldId
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case cancellationDate = "CancellationDate"
            case creationDate = "CreationDate"
            case description = "Description"
            case legalHoldArn = "LegalHoldArn"
            case legalHoldId = "LegalHoldId"
            case status = "Status"
            case title = "Title"
        }
    }

    public struct Lifecycle: AWSEncodableShape & AWSDecodableShape {
        /// The number of days after creation that a recovery point is deleted. This value must be at least 90 days after the number of days specified in MoveToColdStorageAfterDays.
        public let deleteAfterDays: Int64?
        /// The number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAfterDays: Int64?
        /// If the value is true, your backup plan transitions supported resources to  archive (cold) storage tier in accordance with your lifecycle settings.
        public let optInToArchiveForSupportedResources: Bool?

        @inlinable
        public init(deleteAfterDays: Int64? = nil, moveToColdStorageAfterDays: Int64? = nil, optInToArchiveForSupportedResources: Bool? = nil) {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
            self.optInToArchiveForSupportedResources = optInToArchiveForSupportedResources
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAfterDays = "DeleteAfterDays"
            case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
            case optInToArchiveForSupportedResources = "OptInToArchiveForSupportedResources"
        }
    }

    public struct LimitExceededException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ListBackupJobSummariesInput: AWSEncodableShape {
        /// Returns the job count for the specified account. If the request is sent from a member account or an account  not part of Amazon Web Services Organizations, jobs within requestor's account  will be returned. Root, admin, and delegated administrator accounts can use  the value ANY to return job counts from every account in the  organization.  AGGREGATE_ALL aggregates job counts  from all accounts within the authenticated organization,  then returns the sum.
        public let accountId: String?
        /// The period for the returned results.    ONE_DAY - The daily job count for the prior 14 days.    SEVEN_DAYS - The aggregated job count for the prior 7 days.    FOURTEEN_DAYS - The aggregated job count for prior 14 days.
        public let aggregationPeriod: AggregationPeriod?
        /// The maximum number of items to be returned. The value is an integer. Range of accepted values is from  1 to 500.
        public let maxResults: Int?
        /// This parameter returns the job count for the specified  message category. Example accepted strings include AccessDenied,  Success, and InvalidParameters. See  Monitoring  for a list of accepted MessageCategory strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let messageCategory: String?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// Returns the job count for the specified resource type.  Use request GetSupportedResourceTypes to obtain  strings for supported resource types. The the value ANY returns count of all resource types.  AGGREGATE_ALL aggregates job counts  for all resource types and returns the sum. The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// This parameter returns the job count for jobs with the specified state. The the value ANY returns count of all states.  AGGREGATE_ALL aggregates job counts for all states and returns the sum.  Completed with issues is a status found only in the Backup console. For API, this status refers to jobs with a state of COMPLETED and a MessageCategory with a value other than SUCCESS; that is, the status is completed but comes with a status message. To obtain the job count for Completed with issues, run two GET requests, and subtract the second, smaller number: GET /audit/backup-job-summaries?AggregationPeriod=FOURTEEN_DAYS&State=COMPLETED GET /audit/backup-job-summaries?AggregationPeriod=FOURTEEN_DAYS&MessageCategory=SUCCESS&State=COMPLETED
        public let state: BackupJobStatus?

        @inlinable
        public init(accountId: String? = nil, aggregationPeriod: AggregationPeriod? = nil, maxResults: Int? = nil, messageCategory: String? = nil, nextToken: String? = nil, resourceType: String? = nil, state: BackupJobStatus? = nil) {
            self.accountId = accountId
            self.aggregationPeriod = aggregationPeriod
            self.maxResults = maxResults
            self.messageCategory = messageCategory
            self.nextToken = nextToken
            self.resourceType = resourceType
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "AccountId")
            request.encodeQuery(self.aggregationPeriod, key: "AggregationPeriod")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.messageCategory, key: "MessageCategory")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.resourceType, key: "ResourceType")
            request.encodeQuery(self.state, key: "State")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupJobSummariesOutput: AWSDecodableShape {
        /// The period for the returned results.    ONE_DAY - The daily job count for the prior 14 days.    SEVEN_DAYS - The aggregated job count for the prior 7 days.    FOURTEEN_DAYS - The aggregated job count for prior 14 days.
        public let aggregationPeriod: String?
        /// The summary information.
        public let backupJobSummaries: [BackupJobSummary]?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(aggregationPeriod: String? = nil, backupJobSummaries: [BackupJobSummary]? = nil, nextToken: String? = nil) {
            self.aggregationPeriod = aggregationPeriod
            self.backupJobSummaries = backupJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationPeriod = "AggregationPeriod"
            case backupJobSummaries = "BackupJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupJobsInput: AWSEncodableShape {
        /// The account ID to list the jobs from. Returns only backup jobs associated with the specified account ID. If used from an Organizations management account, passing * returns all jobs across the organization.
        public let byAccountId: String?
        /// Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let byBackupVaultName: String?
        /// Returns only backup jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
        public let byCompleteAfter: Date?
        /// Returns only backup jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
        public let byCompleteBefore: Date?
        /// Returns only backup jobs that were created after the specified date.
        public let byCreatedAfter: Date?
        /// Returns only backup jobs that were created before the specified date.
        public let byCreatedBefore: Date?
        /// This is an optional parameter that can be used to  filter out jobs with a MessageCategory which matches the  value you input. Example strings may include AccessDenied,  SUCCESS, AGGREGATE_ALL, and  InvalidParameters. View Monitoring  The wildcard () returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let byMessageCategory: String?
        /// This is a filter to list child (nested) jobs based on parent job ID.
        public let byParentJobId: String?
        /// Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).
        public let byResourceArn: String?
        /// Returns only backup jobs for the specified resources:    Aurora for Amazon Aurora    CloudFormation for CloudFormation    DocumentDB for Amazon DocumentDB (with MongoDB compatibility)    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    FSx for Amazon FSx    Neptune for Amazon Neptune    RDS for Amazon Relational Database Service    Redshift for Amazon Redshift    S3 for Amazon Simple Storage Service (Amazon S3)    SAP HANA on Amazon EC2 for SAP HANA databases  on Amazon Elastic Compute Cloud instances    Storage Gateway for Storage Gateway    Timestream for Amazon Timestream    VirtualMachine for VMware virtual machines
        public let byResourceType: String?
        /// Returns only backup jobs that are in the specified state.  Completed with issues is a status found only in the Backup console. For API, this status refers to jobs with a state of COMPLETED and a MessageCategory with a value other than SUCCESS; that is, the status is completed but comes with a status message. To obtain the job count for Completed with issues, run two GET requests, and subtract the second, smaller number: GET /backup-jobs/?state=COMPLETED GET /backup-jobs/?messageCategory=SUCCESS&state=COMPLETED
        public let byState: BackupJobState?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is  made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(byAccountId: String? = nil, byBackupVaultName: String? = nil, byCompleteAfter: Date? = nil, byCompleteBefore: Date? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byMessageCategory: String? = nil, byParentJobId: String? = nil, byResourceArn: String? = nil, byResourceType: String? = nil, byState: BackupJobState? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byAccountId = byAccountId
            self.byBackupVaultName = byBackupVaultName
            self.byCompleteAfter = byCompleteAfter
            self.byCompleteBefore = byCompleteBefore
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byMessageCategory = byMessageCategory
            self.byParentJobId = byParentJobId
            self.byResourceArn = byResourceArn
            self.byResourceType = byResourceType
            self.byState = byState
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byAccountId, key: "accountId")
            request.encodeQuery(self.byBackupVaultName, key: "backupVaultName")
            request.encodeQuery(self.byCompleteAfter, key: "completeAfter")
            request.encodeQuery(self.byCompleteBefore, key: "completeBefore")
            request.encodeQuery(self.byCreatedAfter, key: "createdAfter")
            request.encodeQuery(self.byCreatedBefore, key: "createdBefore")
            request.encodeQuery(self.byMessageCategory, key: "messageCategory")
            request.encodeQuery(self.byParentJobId, key: "parentJobId")
            request.encodeQuery(self.byResourceArn, key: "resourceArn")
            request.encodeQuery(self.byResourceType, key: "resourceType")
            request.encodeQuery(self.byState, key: "state")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.byAccountId, name: "byAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.byBackupVaultName, name: "byBackupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupJobsOutput: AWSDecodableShape {
        /// An array of structures containing metadata about your backup jobs returned in JSON format.
        public let backupJobs: [BackupJob]?
        /// The next item following a partial list of returned items. For example, if a request is   made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupJobs: [BackupJob]? = nil, nextToken: String? = nil) {
            self.backupJobs = backupJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupJobs = "BackupJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupPlanTemplatesInput: AWSEncodableShape {
        /// The maximum number of items to return.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupPlanTemplatesOutput: AWSDecodableShape {
        /// An array of template list items containing metadata about your saved templates.
        public let backupPlanTemplatesList: [BackupPlanTemplatesListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupPlanTemplatesList: [BackupPlanTemplatesListMember]? = nil, nextToken: String? = nil) {
            self.backupPlanTemplatesList = backupPlanTemplatesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplatesList = "BackupPlanTemplatesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupPlanVersionsInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupPlanId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupPlanId = backupPlanId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupPlanVersionsOutput: AWSDecodableShape {
        /// An array of version list items containing metadata about your backup plans.
        public let backupPlanVersionsList: [BackupPlansListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupPlanVersionsList: [BackupPlansListMember]? = nil, nextToken: String? = nil) {
            self.backupPlanVersionsList = backupPlanVersionsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanVersionsList = "BackupPlanVersionsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupPlansInput: AWSEncodableShape {
        /// A Boolean value with a default value of FALSE that returns deleted backup plans when set to TRUE.
        public let includeDeleted: Bool?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(includeDeleted: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeDeleted = includeDeleted
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeDeleted, key: "includeDeleted")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupPlansOutput: AWSDecodableShape {
        /// Information about the backup plans.
        public let backupPlansList: [BackupPlansListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupPlansList: [BackupPlansListMember]? = nil, nextToken: String? = nil) {
            self.backupPlansList = backupPlansList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlansList = "BackupPlansList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupSelectionsInput: AWSEncodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupPlanId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupPlanId = backupPlanId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupSelectionsOutput: AWSDecodableShape {
        /// An array of backup selection list items containing metadata about each resource in the list.
        public let backupSelectionsList: [BackupSelectionsListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupSelectionsList: [BackupSelectionsListMember]? = nil, nextToken: String? = nil) {
            self.backupSelectionsList = backupSelectionsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupSelectionsList = "BackupSelectionsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupVaultsInput: AWSEncodableShape {
        /// This parameter will sort the list of vaults by shared vaults.
        public let byShared: Bool?
        /// This parameter will sort the list of vaults by vault type.
        public let byVaultType: VaultType?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(byShared: Bool? = nil, byVaultType: VaultType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byShared = byShared
            self.byVaultType = byVaultType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byShared, key: "shared")
            request.encodeQuery(self.byVaultType, key: "vaultType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupVaultsOutput: AWSDecodableShape {
        /// An array of backup vault list members containing vault metadata, including Amazon Resource Name (ARN), display name, creation date, number of saved recovery points, and encryption information if the resources saved in the backup vault are encrypted.
        public let backupVaultList: [BackupVaultListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupVaultList: [BackupVaultListMember]? = nil, nextToken: String? = nil) {
            self.backupVaultList = backupVaultList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultList = "BackupVaultList"
            case nextToken = "NextToken"
        }
    }

    public struct ListCopyJobSummariesInput: AWSEncodableShape {
        /// Returns the job count for the specified account. If the request is sent from a member account or an account  not part of Amazon Web Services Organizations, jobs within requestor's account  will be returned. Root, admin, and delegated administrator accounts can use  the value ANY to return job counts from every account in the  organization.  AGGREGATE_ALL aggregates job counts  from all accounts within the authenticated organization,  then returns the sum.
        public let accountId: String?
        /// The period for the returned results.    ONE_DAY - The daily job count for the prior 14 days.    SEVEN_DAYS - The aggregated job count for the prior 7 days.    FOURTEEN_DAYS - The aggregated job count for prior 14 days.
        public let aggregationPeriod: AggregationPeriod?
        /// This parameter sets the maximum number of items  to be returned. The value is an integer. Range of accepted values is from  1 to 500.
        public let maxResults: Int?
        /// This parameter returns the job count for the specified  message category. Example accepted strings include AccessDenied,  Success, and InvalidParameters. See  Monitoring  for a list of accepted MessageCategory strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let messageCategory: String?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// Returns the job count for the specified resource type.  Use request GetSupportedResourceTypes to obtain  strings for supported resource types. The the value ANY returns count of all resource types.  AGGREGATE_ALL aggregates job counts  for all resource types and returns the sum. The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// This parameter returns the job count for jobs  with the specified state. The the value ANY returns count of all states.  AGGREGATE_ALL aggregates job counts  for all states and returns the sum.
        public let state: CopyJobStatus?

        @inlinable
        public init(accountId: String? = nil, aggregationPeriod: AggregationPeriod? = nil, maxResults: Int? = nil, messageCategory: String? = nil, nextToken: String? = nil, resourceType: String? = nil, state: CopyJobStatus? = nil) {
            self.accountId = accountId
            self.aggregationPeriod = aggregationPeriod
            self.maxResults = maxResults
            self.messageCategory = messageCategory
            self.nextToken = nextToken
            self.resourceType = resourceType
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "AccountId")
            request.encodeQuery(self.aggregationPeriod, key: "AggregationPeriod")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.messageCategory, key: "MessageCategory")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.resourceType, key: "ResourceType")
            request.encodeQuery(self.state, key: "State")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCopyJobSummariesOutput: AWSDecodableShape {
        /// The period for the returned results.    ONE_DAY - The daily job count for the prior 14 days.    SEVEN_DAYS - The aggregated job count for the prior 7 days.    FOURTEEN_DAYS - The aggregated job count for prior 14 days.
        public let aggregationPeriod: String?
        /// This return shows a summary that contains  Region, Account, State, ResourceType, MessageCategory,  StartTime, EndTime, and Count of included jobs.
        public let copyJobSummaries: [CopyJobSummary]?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(aggregationPeriod: String? = nil, copyJobSummaries: [CopyJobSummary]? = nil, nextToken: String? = nil) {
            self.aggregationPeriod = aggregationPeriod
            self.copyJobSummaries = copyJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationPeriod = "AggregationPeriod"
            case copyJobSummaries = "CopyJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListCopyJobsInput: AWSEncodableShape {
        /// The account ID to list the jobs from. Returns only copy jobs associated with the specified account ID.
        public let byAccountId: String?
        /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
        public let byCompleteAfter: Date?
        /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
        public let byCompleteBefore: Date?
        /// Returns only copy jobs that were created after the specified date.
        public let byCreatedAfter: Date?
        /// Returns only copy jobs that were created before the specified date.
        public let byCreatedBefore: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let byDestinationVaultArn: String?
        /// This is an optional parameter that can be used to  filter out jobs with a MessageCategory which matches the  value you input. Example strings may include AccessDenied,  SUCCESS, AGGREGATE_ALL, and  INVALIDPARAMETERS. View  Monitoring for a list of accepted strings. The the value ANY returns count of all message categories.  AGGREGATE_ALL aggregates job counts  for all message categories and returns the sum.
        public let byMessageCategory: String?
        /// This is a filter to list child (nested) jobs based on parent job ID.
        public let byParentJobId: String?
        /// Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
        public let byResourceArn: String?
        /// Returns only backup jobs for the specified resources:    Aurora for Amazon Aurora    CloudFormation for CloudFormation    DocumentDB for Amazon DocumentDB (with MongoDB compatibility)    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    FSx for Amazon FSx    Neptune for Amazon Neptune    RDS for Amazon Relational Database Service    Redshift for Amazon Redshift    S3 for Amazon Simple Storage Service (Amazon S3)    SAP HANA on Amazon EC2 for SAP HANA databases  on Amazon Elastic Compute Cloud instances    Storage Gateway for Storage Gateway    Timestream for Amazon Timestream    VirtualMachine for VMware virtual machines
        public let byResourceType: String?
        /// Returns only copy jobs that are in the specified state.
        public let byState: CopyJobState?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(byAccountId: String? = nil, byCompleteAfter: Date? = nil, byCompleteBefore: Date? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byDestinationVaultArn: String? = nil, byMessageCategory: String? = nil, byParentJobId: String? = nil, byResourceArn: String? = nil, byResourceType: String? = nil, byState: CopyJobState? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byAccountId = byAccountId
            self.byCompleteAfter = byCompleteAfter
            self.byCompleteBefore = byCompleteBefore
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byDestinationVaultArn = byDestinationVaultArn
            self.byMessageCategory = byMessageCategory
            self.byParentJobId = byParentJobId
            self.byResourceArn = byResourceArn
            self.byResourceType = byResourceType
            self.byState = byState
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byAccountId, key: "accountId")
            request.encodeQuery(self.byCompleteAfter, key: "completeAfter")
            request.encodeQuery(self.byCompleteBefore, key: "completeBefore")
            request.encodeQuery(self.byCreatedAfter, key: "createdAfter")
            request.encodeQuery(self.byCreatedBefore, key: "createdBefore")
            request.encodeQuery(self.byDestinationVaultArn, key: "destinationVaultArn")
            request.encodeQuery(self.byMessageCategory, key: "messageCategory")
            request.encodeQuery(self.byParentJobId, key: "parentJobId")
            request.encodeQuery(self.byResourceArn, key: "resourceArn")
            request.encodeQuery(self.byResourceType, key: "resourceType")
            request.encodeQuery(self.byState, key: "state")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.byAccountId, name: "byAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCopyJobsOutput: AWSDecodableShape {
        /// An array of structures containing metadata about your copy jobs returned in JSON format.
        public let copyJobs: [CopyJob]?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(copyJobs: [CopyJob]? = nil, nextToken: String? = nil) {
            self.copyJobs = copyJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case copyJobs = "CopyJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListFrameworksInput: AWSEncodableShape {
        /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFrameworksOutput: AWSDecodableShape {
        /// The frameworks with details for each framework, including the framework name, Amazon Resource Name (ARN), description, number of controls, creation time, and deployment status.
        public let frameworks: [Framework]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        @inlinable
        public init(frameworks: [Framework]? = nil, nextToken: String? = nil) {
            self.frameworks = frameworks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case frameworks = "Frameworks"
            case nextToken = "NextToken"
        }
    }

    public struct ListIndexedRecoveryPointsInput: AWSEncodableShape {
        /// Returns only indexed recovery points that were created after the  specified date.
        public let createdAfter: Date?
        /// Returns only indexed recovery points that were created before the  specified date.
        public let createdBefore: Date?
        /// Include this parameter to filter the returned list by  the indicated statuses. Accepted values: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE  can be included in a search.
        public let indexStatus: IndexStatus?
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned recovery points. For example, if a request is made to return MaxResults number of indexed recovery points, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// Returns a list of indexed recovery points for the specified  resource type(s). Accepted values include:    EBS for Amazon Elastic Block Store    S3 for Amazon Simple Storage Service (Amazon S3)
        public let resourceType: String?
        /// A string of the  Amazon Resource Name (ARN) that uniquely identifies  the source resource.
        public let sourceResourceArn: String?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, indexStatus: IndexStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceType: String? = nil, sourceResourceArn: String? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.indexStatus = indexStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
            self.sourceResourceArn = sourceResourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.createdAfter, key: "createdAfter")
            request.encodeQuery(self.createdBefore, key: "createdBefore")
            request.encodeQuery(self.indexStatus, key: "indexStatus")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
            request.encodeQuery(self.sourceResourceArn, key: "sourceResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIndexedRecoveryPointsOutput: AWSDecodableShape {
        /// This is a list of recovery points that have an  associated index, belonging to the specified account.
        public let indexedRecoveryPoints: [IndexedRecoveryPoint]?
        /// The next item following a partial list of returned recovery points. For example, if a request is made to return MaxResults number of indexed recovery points, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(indexedRecoveryPoints: [IndexedRecoveryPoint]? = nil, nextToken: String? = nil) {
            self.indexedRecoveryPoints = indexedRecoveryPoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case indexedRecoveryPoints = "IndexedRecoveryPoints"
            case nextToken = "NextToken"
        }
    }

    public struct ListLegalHoldsInput: AWSEncodableShape {
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLegalHoldsOutput: AWSDecodableShape {
        /// This is an array of returned legal holds, both active and previous.
        public let legalHolds: [LegalHold]?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(legalHolds: [LegalHold]? = nil, nextToken: String? = nil) {
            self.legalHolds = legalHolds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case legalHolds = "LegalHolds"
            case nextToken = "NextToken"
        }
    }

    public struct ListProtectedResourcesByBackupVaultInput: AWSEncodableShape {
        /// The list of protected resources by backup vault within the vault(s) you specify by account ID.
        public let backupVaultAccountId: String?
        /// The list of protected resources by backup vault within the vault(s) you specify by name.
        public let backupVaultName: String
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupVaultAccountId: String? = nil, backupVaultName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupVaultAccountId = backupVaultAccountId
            self.backupVaultName = backupVaultName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.backupVaultAccountId, key: "backupVaultAccountId")
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultAccountId, name: "backupVaultAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedResourcesByBackupVaultOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// These are the results returned for the request ListProtectedResourcesByBackupVault.
        public let results: [ProtectedResource]?

        @inlinable
        public init(nextToken: String? = nil, results: [ProtectedResource]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListProtectedResourcesInput: AWSEncodableShape {
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedResourcesOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of resources successfully backed up by Backup including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
        public let results: [ProtectedResource]?

        @inlinable
        public init(nextToken: String? = nil, results: [ProtectedResource]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListRecoveryPointsByBackupVaultInput: AWSEncodableShape {
        /// This parameter will sort the list of recovery points by account ID.
        public let backupVaultAccountId: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.  Backup vault name might not be available when a supported service creates the backup.
        public let backupVaultName: String
        /// Returns only recovery points that match the specified backup plan ID.
        public let byBackupPlanId: String?
        /// Returns only recovery points that were created after the specified timestamp.
        public let byCreatedAfter: Date?
        /// Returns only recovery points that were created before the specified timestamp.
        public let byCreatedBefore: Date?
        /// This returns only recovery points that match the specified parent (composite) recovery point Amazon Resource Name (ARN).
        public let byParentRecoveryPointArn: String?
        /// Returns only recovery points that match the specified resource Amazon Resource Name (ARN).
        public let byResourceArn: String?
        /// Returns only recovery points that match the specified resource type(s):    Aurora for Amazon Aurora    CloudFormation for CloudFormation    DocumentDB for Amazon DocumentDB (with MongoDB compatibility)    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    FSx for Amazon FSx    Neptune for Amazon Neptune    RDS for Amazon Relational Database Service    Redshift for Amazon Redshift    S3 for Amazon Simple Storage Service (Amazon S3)    SAP HANA on Amazon EC2 for SAP HANA databases  on Amazon Elastic Compute Cloud instances    Storage Gateway for Storage Gateway    Timestream for Amazon Timestream    VirtualMachine for VMware virtual machines
        public let byResourceType: String?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(backupVaultAccountId: String? = nil, backupVaultName: String, byBackupPlanId: String? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byParentRecoveryPointArn: String? = nil, byResourceArn: String? = nil, byResourceType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupVaultAccountId = backupVaultAccountId
            self.backupVaultName = backupVaultName
            self.byBackupPlanId = byBackupPlanId
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byParentRecoveryPointArn = byParentRecoveryPointArn
            self.byResourceArn = byResourceArn
            self.byResourceType = byResourceType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.backupVaultAccountId, key: "backupVaultAccountId")
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            request.encodeQuery(self.byBackupPlanId, key: "backupPlanId")
            request.encodeQuery(self.byCreatedAfter, key: "createdAfter")
            request.encodeQuery(self.byCreatedBefore, key: "createdBefore")
            request.encodeQuery(self.byParentRecoveryPointArn, key: "parentRecoveryPointArn")
            request.encodeQuery(self.byResourceArn, key: "resourceArn")
            request.encodeQuery(self.byResourceType, key: "resourceType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultAccountId, name: "backupVaultAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecoveryPointsByBackupVaultOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of objects that contain detailed information about recovery points saved in a backup vault.
        public let recoveryPoints: [RecoveryPointByBackupVault]?

        @inlinable
        public init(nextToken: String? = nil, recoveryPoints: [RecoveryPointByBackupVault]? = nil) {
            self.nextToken = nextToken
            self.recoveryPoints = recoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recoveryPoints = "RecoveryPoints"
        }
    }

    public struct ListRecoveryPointsByLegalHoldInput: AWSEncodableShape {
        /// The ID of the legal hold.
        public let legalHoldId: String
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(legalHoldId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.legalHoldId = legalHoldId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.legalHoldId, key: "LegalHoldId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecoveryPointsByLegalHoldOutput: AWSDecodableShape {
        /// The next item following a partial list of returned resources.
        public let nextToken: String?
        /// The recovery points.
        public let recoveryPoints: [RecoveryPointMember]?

        @inlinable
        public init(nextToken: String? = nil, recoveryPoints: [RecoveryPointMember]? = nil) {
            self.nextToken = nextToken
            self.recoveryPoints = recoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recoveryPoints = "RecoveryPoints"
        }
    }

    public struct ListRecoveryPointsByResourceInput: AWSEncodableShape {
        /// This attribute filters recovery points based on ownership. If this is  set to TRUE, the response will contain recovery points associated  with the selected resources that are managed by Backup. If this is set to FALSE, the response will contain all  recovery points associated with the selected resource. Type: Boolean
        public let managedByAWSBackupOnly: Bool?
        /// The maximum number of items to be returned.  Amazon RDS requires a value of at least 20.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String

        @inlinable
        public init(managedByAWSBackupOnly: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.managedByAWSBackupOnly = managedByAWSBackupOnly
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.managedByAWSBackupOnly, key: "managedByAWSBackupOnly")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecoveryPointsByResourceOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of objects that contain detailed information about recovery points of the specified resource type.  Only Amazon EFS and Amazon EC2 recovery points return BackupVaultName.
        public let recoveryPoints: [RecoveryPointByResource]?

        @inlinable
        public init(nextToken: String? = nil, recoveryPoints: [RecoveryPointByResource]? = nil) {
            self.nextToken = nextToken
            self.recoveryPoints = recoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recoveryPoints = "RecoveryPoints"
        }
    }

    public struct ListReportJobsInput: AWSEncodableShape {
        /// Returns only report jobs that were created after the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
        public let byCreationAfter: Date?
        /// Returns only report jobs that were created before the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
        public let byCreationBefore: Date?
        /// Returns only report jobs with the specified report plan name.
        public let byReportPlanName: String?
        /// Returns only report jobs that are in the specified status. The statuses are:  CREATED | RUNNING | COMPLETED | FAILED
        public let byStatus: String?
        /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        @inlinable
        public init(byCreationAfter: Date? = nil, byCreationBefore: Date? = nil, byReportPlanName: String? = nil, byStatus: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byCreationAfter = byCreationAfter
            self.byCreationBefore = byCreationBefore
            self.byReportPlanName = byReportPlanName
            self.byStatus = byStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byCreationAfter, key: "CreationAfter")
            request.encodeQuery(self.byCreationBefore, key: "CreationBefore")
            request.encodeQuery(self.byReportPlanName, key: "ReportPlanName")
            request.encodeQuery(self.byStatus, key: "Status")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.byReportPlanName, name: "byReportPlanName", parent: name, max: 256)
            try self.validate(self.byReportPlanName, name: "byReportPlanName", parent: name, min: 1)
            try self.validate(self.byReportPlanName, name: "byReportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReportJobsOutput: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// Details about your report jobs in JSON format.
        public let reportJobs: [ReportJob]?

        @inlinable
        public init(nextToken: String? = nil, reportJobs: [ReportJob]? = nil) {
            self.nextToken = nextToken
            self.reportJobs = reportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reportJobs = "ReportJobs"
        }
    }

    public struct ListReportPlansInput: AWSEncodableShape {
        /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReportPlansOutput: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The report plans with detailed information for each plan. This information includes the Amazon Resource Name (ARN), report plan name, description, settings, delivery channel, deployment status, creation time, and last times the report plan attempted to and successfully ran.
        public let reportPlans: [ReportPlan]?

        @inlinable
        public init(nextToken: String? = nil, reportPlans: [ReportPlan]? = nil) {
            self.nextToken = nextToken
            self.reportPlans = reportPlans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reportPlans = "ReportPlans"
        }
    }

    public struct ListRestoreJobSummariesInput: AWSEncodableShape {
        /// Returns the job count for the specified account. If the request is sent from a member account or an account  not part of Amazon Web Services Organizations, jobs within requestor's account  will be returned. Root, admin, and delegated administrator accounts can use  the value ANY to return job counts from every account in the  organization.  AGGREGATE_ALL aggregates job counts  from all accounts within the authenticated organization,  then returns the sum.
        public let accountId: String?
        /// The period for the returned results.    ONE_DAY - The daily job count for the prior 14 days.    SEVEN_DAYS - The aggregated job count for the prior 7 days.    FOURTEEN_DAYS - The aggregated job count for prior 14 days.
        public let aggregationPeriod: AggregationPeriod?
        /// This parameter sets the maximum number of items  to be returned. The value is an integer. Range of accepted values is from  1 to 500.
        public let maxResults: Int?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// Returns the job count for the specified resource type.  Use request GetSupportedResourceTypes to obtain  strings for supported resource types. The the value ANY returns count of all resource types.  AGGREGATE_ALL aggregates job counts  for all resource types and returns the sum. The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// This parameter returns the job count for jobs  with the specified state. The the value ANY returns count of all states.  AGGREGATE_ALL aggregates job counts  for all states and returns the sum.
        public let state: RestoreJobState?

        @inlinable
        public init(accountId: String? = nil, aggregationPeriod: AggregationPeriod? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceType: String? = nil, state: RestoreJobState? = nil) {
            self.accountId = accountId
            self.aggregationPeriod = aggregationPeriod
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "AccountId")
            request.encodeQuery(self.aggregationPeriod, key: "AggregationPeriod")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.resourceType, key: "ResourceType")
            request.encodeQuery(self.state, key: "State")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRestoreJobSummariesOutput: AWSDecodableShape {
        /// The period for the returned results.    ONE_DAY - The daily job count for the prior 14 days.    SEVEN_DAYS - The aggregated job count for the prior 7 days.    FOURTEEN_DAYS - The aggregated job count for prior 14 days.
        public let aggregationPeriod: String?
        /// The next item following a partial list of returned resources. For example, if a request is made to return MaxResults number of resources, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// This return contains a summary that contains  Region, Account, State, ResourceType, MessageCategory,  StartTime, EndTime, and Count of included jobs.
        public let restoreJobSummaries: [RestoreJobSummary]?

        @inlinable
        public init(aggregationPeriod: String? = nil, nextToken: String? = nil, restoreJobSummaries: [RestoreJobSummary]? = nil) {
            self.aggregationPeriod = aggregationPeriod
            self.nextToken = nextToken
            self.restoreJobSummaries = restoreJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationPeriod = "AggregationPeriod"
            case nextToken = "NextToken"
            case restoreJobSummaries = "RestoreJobSummaries"
        }
    }

    public struct ListRestoreJobsByProtectedResourceInput: AWSEncodableShape {
        /// Returns only restore jobs of recovery points that were created after the specified date.
        public let byRecoveryPointCreationDateAfter: Date?
        /// Returns only restore jobs of recovery points that were created before the specified date.
        public let byRecoveryPointCreationDateBefore: Date?
        /// Returns only restore jobs associated with the specified job status.
        public let byStatus: RestoreJobStatus?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example,  if a request ismade to return MaxResults number of items,  NextToken allows you to return more items in your list  starting at the location pointed to by the next token.
        public let nextToken: String?
        /// Returns only restore jobs that match the specified resource  Amazon Resource Name (ARN).
        public let resourceArn: String

        @inlinable
        public init(byRecoveryPointCreationDateAfter: Date? = nil, byRecoveryPointCreationDateBefore: Date? = nil, byStatus: RestoreJobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.byRecoveryPointCreationDateAfter = byRecoveryPointCreationDateAfter
            self.byRecoveryPointCreationDateBefore = byRecoveryPointCreationDateBefore
            self.byStatus = byStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byRecoveryPointCreationDateAfter, key: "recoveryPointCreationDateAfter")
            request.encodeQuery(self.byRecoveryPointCreationDateBefore, key: "recoveryPointCreationDateBefore")
            request.encodeQuery(self.byStatus, key: "status")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRestoreJobsByProtectedResourceOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example,  if a request is made to return MaxResults number of items,  NextToken allows youto return more items in your list starting  at the location pointed to by the next token
        public let nextToken: String?
        /// An array of objects that contain detailed information about  jobs to restore saved resources.>
        public let restoreJobs: [RestoreJobsListMember]?

        @inlinable
        public init(nextToken: String? = nil, restoreJobs: [RestoreJobsListMember]? = nil) {
            self.nextToken = nextToken
            self.restoreJobs = restoreJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case restoreJobs = "RestoreJobs"
        }
    }

    public struct ListRestoreJobsInput: AWSEncodableShape {
        /// The account ID to list the jobs from. Returns only restore jobs associated with the specified account ID.
        public let byAccountId: String?
        /// Returns only copy jobs completed after a date expressed in Unix format and Coordinated Universal Time (UTC).
        public let byCompleteAfter: Date?
        /// Returns only copy jobs completed before a date expressed in Unix format and Coordinated Universal Time (UTC).
        public let byCompleteBefore: Date?
        /// Returns only restore jobs that were created after the specified date.
        public let byCreatedAfter: Date?
        /// Returns only restore jobs that were created before the specified date.
        public let byCreatedBefore: Date?
        /// Include this parameter to return only restore jobs for the specified resources:    Aurora for Amazon Aurora    CloudFormation for CloudFormation    DocumentDB for Amazon DocumentDB (with MongoDB compatibility)    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    FSx for Amazon FSx    Neptune for Amazon Neptune    RDS for Amazon Relational Database Service    Redshift for Amazon Redshift    S3 for Amazon Simple Storage Service (Amazon S3)    SAP HANA on Amazon EC2 for SAP HANA databases  on Amazon Elastic Compute Cloud instances    Storage Gateway for Storage Gateway    Timestream for Amazon Timestream    VirtualMachine for VMware virtual machines
        public let byResourceType: String?
        /// This returns only restore testing jobs that match the  specified resource Amazon Resource Name (ARN).
        public let byRestoreTestingPlanArn: String?
        /// Returns only restore jobs associated with the specified job status.
        public let byStatus: RestoreJobStatus?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(byAccountId: String? = nil, byCompleteAfter: Date? = nil, byCompleteBefore: Date? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byResourceType: String? = nil, byRestoreTestingPlanArn: String? = nil, byStatus: RestoreJobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byAccountId = byAccountId
            self.byCompleteAfter = byCompleteAfter
            self.byCompleteBefore = byCompleteBefore
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byResourceType = byResourceType
            self.byRestoreTestingPlanArn = byRestoreTestingPlanArn
            self.byStatus = byStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byAccountId, key: "accountId")
            request.encodeQuery(self.byCompleteAfter, key: "completeAfter")
            request.encodeQuery(self.byCompleteBefore, key: "completeBefore")
            request.encodeQuery(self.byCreatedAfter, key: "createdAfter")
            request.encodeQuery(self.byCreatedBefore, key: "createdBefore")
            request.encodeQuery(self.byResourceType, key: "resourceType")
            request.encodeQuery(self.byRestoreTestingPlanArn, key: "restoreTestingPlanArn")
            request.encodeQuery(self.byStatus, key: "status")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.byAccountId, name: "byAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRestoreJobsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of objects that contain detailed information about jobs to restore saved resources.
        public let restoreJobs: [RestoreJobsListMember]?

        @inlinable
        public init(nextToken: String? = nil, restoreJobs: [RestoreJobsListMember]? = nil) {
            self.nextToken = nextToken
            self.restoreJobs = restoreJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case restoreJobs = "RestoreJobs"
        }
    }

    public struct ListRestoreTestingPlansInput: AWSEncodableShape {
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items.  For example, if a request is made to return MaxResults  number of items, NextToken allows you to return more items  in your list starting at the location pointed to by the nexttoken.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRestoreTestingPlansOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items.  For example, if a request is made to return MaxResults  number of items, NextToken allows you to return more items  in your list starting at the location pointed to by the nexttoken.
        public let nextToken: String?
        /// This is a returned list of restore testing plans.
        public let restoreTestingPlans: [RestoreTestingPlanForList]

        @inlinable
        public init(nextToken: String? = nil, restoreTestingPlans: [RestoreTestingPlanForList]) {
            self.nextToken = nextToken
            self.restoreTestingPlans = restoreTestingPlans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case restoreTestingPlans = "RestoreTestingPlans"
        }
    }

    public struct ListRestoreTestingSelectionsInput: AWSEncodableShape {
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items.  For example, if a request is made to return MaxResults  number of items, NextToken allows you to return more items  in your list starting at the location pointed to by the nexttoken.
        public let nextToken: String?
        /// Returns restore testing selections by the specified restore testing  plan name.
        public let restoreTestingPlanName: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, restoreTestingPlanName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.restoreTestingPlanName = restoreTestingPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRestoreTestingSelectionsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example,  if a request is made to return MaxResults number of items,  NextToken allows you to return more items in your list  starting at the location pointed to by the nexttoken.
        public let nextToken: String?
        /// The returned restore testing selections associated with the  restore testing plan.
        public let restoreTestingSelections: [RestoreTestingSelectionForList]

        @inlinable
        public init(nextToken: String? = nil, restoreTestingSelections: [RestoreTestingSelectionForList]) {
            self.nextToken = nextToken
            self.restoreTestingSelections = restoreTestingSelections
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case restoreTestingSelections = "RestoreTestingSelections"
        }
    }

    public struct ListTagsInput: AWSEncodableShape {
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for ListTags are recovery points, backup plans, and backup vaults.
        public let resourceArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return MaxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// Information about the tags.
        public let tags: [String: String]?

        @inlinable
        public init(nextToken: String? = nil, tags: [String: String]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct MissingParameterValueException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ProtectedResource: AWSDecodableShape {
        /// The date and time a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastBackupTime: Date?
        /// The ARN (Amazon Resource Name) of the backup vault  that contains the most recent backup recovery point.
        public let lastBackupVaultArn: String?
        /// The ARN (Amazon Resource Name) of the most  recent recovery point.
        public let lastRecoveryPointArn: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The non-unique name of the resource that  belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?

        @inlinable
        public init(lastBackupTime: Date? = nil, lastBackupVaultArn: String? = nil, lastRecoveryPointArn: String? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil) {
            self.lastBackupTime = lastBackupTime
            self.lastBackupVaultArn = lastBackupVaultArn
            self.lastRecoveryPointArn = lastRecoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case lastBackupTime = "LastBackupTime"
            case lastBackupVaultArn = "LastBackupVaultArn"
            case lastRecoveryPointArn = "LastRecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
        }
    }

    public struct ProtectedResourceConditions: AWSEncodableShape & AWSDecodableShape {
        /// Filters the values of your tagged resources for only  those resources that you tagged  with the same value.  Also called "exact matching."
        public let stringEquals: [KeyValue]?
        /// Filters the values of your tagged resources for only  those resources that you tagged  that do not have the same value.  Also called "negated matching."
        public let stringNotEquals: [KeyValue]?

        @inlinable
        public init(stringEquals: [KeyValue]? = nil, stringNotEquals: [KeyValue]? = nil) {
            self.stringEquals = stringEquals
            self.stringNotEquals = stringNotEquals
        }

        private enum CodingKeys: String, CodingKey {
            case stringEquals = "StringEquals"
            case stringNotEquals = "StringNotEquals"
        }
    }

    public struct PutBackupVaultAccessPolicyInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// The backup vault access policy document in JSON format.
        public let policy: String?

        @inlinable
        public init(backupVaultName: String, policy: String? = nil) {
            self.backupVaultName = backupVaultName
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encodeIfPresent(self.policy, forKey: .policy)
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutBackupVaultLockConfigurationInput: AWSEncodableShape {
        /// The Backup Vault Lock configuration that specifies the name of the backup vault it protects.
        public let backupVaultName: String
        /// The Backup Vault Lock configuration that specifies the number of days before the lock date. For example, setting ChangeableForDays to 30 on Jan. 1, 2022 at 8pm UTC will set the lock date to Jan. 31, 2022 at 8pm UTC. Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Therefore, you must set ChangeableForDays to 3 or greater. Before the lock date, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration. On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. If this parameter is not specified, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration at any time.
        public let changeableForDays: Int64?
        /// The Backup Vault Lock configuration that specifies the maximum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to destroy certain data after retaining it for four years (1460 days). If this parameter is not included, Vault Lock does not enforce a maximum retention period on the recovery points in the vault. If this parameter is included without a value, Vault Lock will not enforce a maximum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. The longest maximum retention period you can specify is 36500 days (approximately 100 years). Recovery points already saved in the vault prior to Vault Lock are not affected.
        public let maxRetentionDays: Int64?
        /// The Backup Vault Lock configuration that specifies the minimum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to retain certain data for at least seven years (2555 days). This parameter is required when a vault lock is created through CloudFormation; otherwise, this parameter is optional. If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. The shortest minimum retention period you can specify is 1 day. Recovery points already saved in the vault prior to Vault Lock are not affected.
        public let minRetentionDays: Int64?

        @inlinable
        public init(backupVaultName: String, changeableForDays: Int64? = nil, maxRetentionDays: Int64? = nil, minRetentionDays: Int64? = nil) {
            self.backupVaultName = backupVaultName
            self.changeableForDays = changeableForDays
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encodeIfPresent(self.changeableForDays, forKey: .changeableForDays)
            try container.encodeIfPresent(self.maxRetentionDays, forKey: .maxRetentionDays)
            try container.encodeIfPresent(self.minRetentionDays, forKey: .minRetentionDays)
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case changeableForDays = "ChangeableForDays"
            case maxRetentionDays = "MaxRetentionDays"
            case minRetentionDays = "MinRetentionDays"
        }
    }

    public struct PutBackupVaultNotificationsInput: AWSEncodableShape {
        /// An array of events that indicate the status of jobs to back up resources to the backup vault. For common use cases and code samples, see Using Amazon SNS to track Backup events. The following events are supported:    BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED     COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED     RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED     S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED     The list below includes both supported events and deprecated events that are no longer in use (for reference). Deprecated events do not return statuses or notifications.  Refer to the list above for the supported events.
        public let backupVaultEvents: [BackupVaultEvent]
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
        public let snsTopicArn: String

        @inlinable
        public init(backupVaultEvents: [BackupVaultEvent], backupVaultName: String, snsTopicArn: String) {
            self.backupVaultEvents = backupVaultEvents
            self.backupVaultName = backupVaultName
            self.snsTopicArn = snsTopicArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.backupVaultEvents, forKey: .backupVaultEvents)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encode(self.snsTopicArn, forKey: .snsTopicArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultEvents = "BackupVaultEvents"
            case snsTopicArn = "SNSTopicArn"
        }
    }

    public struct PutRestoreValidationResultInput: AWSEncodableShape {
        /// This is a unique identifier of a restore job within Backup.
        public let restoreJobId: String
        /// The status of your restore validation.
        public let validationStatus: RestoreValidationStatus
        /// This is an optional message string you can input to  describe the validation status for the restore test validation.
        public let validationStatusMessage: String?

        @inlinable
        public init(restoreJobId: String, validationStatus: RestoreValidationStatus, validationStatusMessage: String? = nil) {
            self.restoreJobId = restoreJobId
            self.validationStatus = validationStatus
            self.validationStatusMessage = validationStatusMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreJobId, key: "RestoreJobId")
            try container.encode(self.validationStatus, forKey: .validationStatus)
            try container.encodeIfPresent(self.validationStatusMessage, forKey: .validationStatusMessage)
        }

        private enum CodingKeys: String, CodingKey {
            case validationStatus = "ValidationStatus"
            case validationStatusMessage = "ValidationStatusMessage"
        }
    }

    public struct RecoveryPointByBackupVault: AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: CalculatedLifecycle?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// The identifier of a resource within a composite group, such as  nested (child) recovery point belonging to a composite (parent) stack. The  ID is transferred from  the  logical ID within a stack.
        public let compositeMemberIdentifier: String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// This is the current status for the backup index associated  with the specified recovery point. Statuses are: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE  can be included in a search.
        public let indexStatus: IndexStatus?
        /// A string in the form of a detailed message explaining the status of a backup index associated  with the recovery point.
        public let indexStatusMessage: String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public let isEncrypted: Bool?
        /// This is a boolean value indicating this is  a parent (composite) recovery point.
        public let isParent: Bool?
        /// The date and time a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastRestoreTime: Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Resource types that can transition to cold storage are listed in the Feature  availability by resource table. Backup ignores this expression for other resource types.
        public let lifecycle: Lifecycle?
        /// The Amazon Resource Name (ARN) of the parent (composite)  recovery point.
        public let parentRecoveryPointArn: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The non-unique name of the resource that  belongs to the specified backup.
        public let resourceName: String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?
        /// The backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account this value will be null.
        public let sourceBackupVaultArn: String?
        /// A status code specifying the state of the recovery point.
        public let status: RecoveryPointStatus?
        /// A message explaining the current status of the recovery point.
        public let statusMessage: String?
        /// The type of vault in which the described recovery point is stored.
        public let vaultType: VaultType?

        @inlinable
        public init(backupSizeInBytes: Int64? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, calculatedLifecycle: CalculatedLifecycle? = nil, completionDate: Date? = nil, compositeMemberIdentifier: String? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, encryptionKeyArn: String? = nil, iamRoleArn: String? = nil, indexStatus: IndexStatus? = nil, indexStatusMessage: String? = nil, isEncrypted: Bool? = nil, isParent: Bool? = nil, lastRestoreTime: Date? = nil, lifecycle: Lifecycle? = nil, parentRecoveryPointArn: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceName: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, status: RecoveryPointStatus? = nil, statusMessage: String? = nil, vaultType: VaultType? = nil) {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.compositeMemberIdentifier = compositeMemberIdentifier
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.indexStatus = indexStatus
            self.indexStatusMessage = indexStatusMessage
            self.isEncrypted = isEncrypted
            self.isParent = isParent
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.vaultType = vaultType
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case calculatedLifecycle = "CalculatedLifecycle"
            case completionDate = "CompletionDate"
            case compositeMemberIdentifier = "CompositeMemberIdentifier"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case iamRoleArn = "IamRoleArn"
            case indexStatus = "IndexStatus"
            case indexStatusMessage = "IndexStatusMessage"
            case isEncrypted = "IsEncrypted"
            case isParent = "IsParent"
            case lastRestoreTime = "LastRestoreTime"
            case lifecycle = "Lifecycle"
            case parentRecoveryPointArn = "ParentRecoveryPointArn"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case vaultType = "VaultType"
        }
    }

    public struct RecoveryPointByResource: AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeBytes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// This is the current status for the backup index associated  with the specified recovery point. Statuses are: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE  can be included in a search.
        public let indexStatus: IndexStatus?
        /// A string in the form of a detailed message explaining the status of a backup index associated with the recovery point.
        public let indexStatusMessage: String?
        /// This is a boolean value indicating this is  a parent (composite) recovery point.
        public let isParent: Bool?
        /// The Amazon Resource Name (ARN) of the parent (composite)  recovery point.
        public let parentRecoveryPointArn: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// The non-unique name of the resource that  belongs to the specified backup.
        public let resourceName: String?
        /// A status code specifying the state of the recovery point.
        public let status: RecoveryPointStatus?
        /// A message explaining the current status of the recovery point.
        public let statusMessage: String?
        /// The type of vault in which the described recovery point is  stored.
        public let vaultType: VaultType?

        @inlinable
        public init(backupSizeBytes: Int64? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, encryptionKeyArn: String? = nil, indexStatus: IndexStatus? = nil, indexStatusMessage: String? = nil, isParent: Bool? = nil, parentRecoveryPointArn: String? = nil, recoveryPointArn: String? = nil, resourceName: String? = nil, status: RecoveryPointStatus? = nil, statusMessage: String? = nil, vaultType: VaultType? = nil) {
            self.backupSizeBytes = backupSizeBytes
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.indexStatus = indexStatus
            self.indexStatusMessage = indexStatusMessage
            self.isParent = isParent
            self.parentRecoveryPointArn = parentRecoveryPointArn
            self.recoveryPointArn = recoveryPointArn
            self.resourceName = resourceName
            self.status = status
            self.statusMessage = statusMessage
            self.vaultType = vaultType
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeBytes = "BackupSizeBytes"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case indexStatus = "IndexStatus"
            case indexStatusMessage = "IndexStatusMessage"
            case isParent = "IsParent"
            case parentRecoveryPointArn = "ParentRecoveryPointArn"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceName = "ResourceName"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case vaultType = "VaultType"
        }
    }

    public struct RecoveryPointCreator: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public let backupPlanVersion: String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public let backupRuleId: String?

        @inlinable
        public init(backupPlanArn: String? = nil, backupPlanId: String? = nil, backupPlanVersion: String? = nil, backupRuleId: String? = nil) {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case backupPlanVersion = "BackupPlanVersion"
            case backupRuleId = "BackupRuleId"
        }
    }

    public struct RecoveryPointMember: AWSDecodableShape {
        /// The name of the backup vault  (the logical container in which backups are stored).
        public let backupVaultName: String?
        /// The Amazon Resource Name (ARN) of the parent (composite)  recovery point.
        public let recoveryPointArn: String?
        /// The Amazon Resource Name (ARN) that uniquely identifies  a saved resource.
        public let resourceArn: String?
        /// The Amazon Web Services resource type that is saved as  a recovery point.
        public let resourceType: String?

        @inlinable
        public init(backupVaultName: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultName = "BackupVaultName"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
        }
    }

    public struct RecoveryPointSelection: AWSEncodableShape & AWSDecodableShape {
        public let dateRange: DateRange?
        /// These are the resources included in the resource selection  (including type of resources and vaults).
        public let resourceIdentifiers: [String]?
        /// These are the names of the vaults in which the selected  recovery points are contained.
        public let vaultNames: [String]?

        @inlinable
        public init(dateRange: DateRange? = nil, resourceIdentifiers: [String]? = nil, vaultNames: [String]? = nil) {
            self.dateRange = dateRange
            self.resourceIdentifiers = resourceIdentifiers
            self.vaultNames = vaultNames
        }

        private enum CodingKeys: String, CodingKey {
            case dateRange = "DateRange"
            case resourceIdentifiers = "ResourceIdentifiers"
            case vaultNames = "VaultNames"
        }
    }

    public struct ReportDeliveryChannel: AWSEncodableShape & AWSDecodableShape {
        /// The format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
        public let formats: [String]?
        /// The unique name of the S3 bucket that receives your reports.
        public let s3BucketName: String
        /// The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
        public let s3KeyPrefix: String?

        @inlinable
        public init(formats: [String]? = nil, s3BucketName: String, s3KeyPrefix: String? = nil) {
            self.formats = formats
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case formats = "Formats"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct ReportDestination: AWSDecodableShape {
        /// The unique name of the Amazon S3 bucket that receives your reports.
        public let s3BucketName: String?
        /// The object key that uniquely identifies your reports in your S3 bucket.
        public let s3Keys: [String]?

        @inlinable
        public init(s3BucketName: String? = nil, s3Keys: [String]? = nil) {
            self.s3BucketName = s3BucketName
            self.s3Keys = s3Keys
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case s3Keys = "S3Keys"
        }
    }

    public struct ReportJob: AWSDecodableShape {
        /// The date and time that a report job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionTime: Date?
        /// The date and time that a report job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The S3 bucket name and S3 keys for the destination where the report job publishes the report.
        public let reportDestination: ReportDestination?
        /// The identifier for a report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. Report job IDs cannot be edited.
        public let reportJobId: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:   RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportTemplate: String?
        /// The status of a report job. The statuses are:  CREATED | RUNNING | COMPLETED | FAILED   COMPLETED means that the report is available for your review at your designated destination. If the status is FAILED, review the StatusMessage for the reason.
        public let status: String?
        /// A message explaining the status of the report job.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date? = nil, reportDestination: ReportDestination? = nil, reportJobId: String? = nil, reportPlanArn: String? = nil, reportTemplate: String? = nil, status: String? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.reportDestination = reportDestination
            self.reportJobId = reportJobId
            self.reportPlanArn = reportPlanArn
            self.reportTemplate = reportTemplate
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case reportDestination = "ReportDestination"
            case reportJobId = "ReportJobId"
            case reportPlanArn = "ReportPlanArn"
            case reportTemplate = "ReportTemplate"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ReportPlan: AWSDecodableShape {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The deployment status of a report plan. The statuses are:  CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED
        public let deploymentStatus: String?
        /// The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC). The value of LastAttemptedExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastAttemptedExecutionTime: Date?
        /// The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC). The value of LastSuccessfulExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastSuccessfulExecutionTime: Date?
        /// Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public let reportDeliveryChannel: ReportDeliveryChannel?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public let reportPlanDescription: String?
        /// The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let reportPlanName: String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT  If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public let reportSetting: ReportSetting?

        @inlinable
        public init(creationTime: Date? = nil, deploymentStatus: String? = nil, lastAttemptedExecutionTime: Date? = nil, lastSuccessfulExecutionTime: Date? = nil, reportDeliveryChannel: ReportDeliveryChannel? = nil, reportPlanArn: String? = nil, reportPlanDescription: String? = nil, reportPlanName: String? = nil, reportSetting: ReportSetting? = nil) {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.lastAttemptedExecutionTime = lastAttemptedExecutionTime
            self.lastSuccessfulExecutionTime = lastSuccessfulExecutionTime
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanArn = reportPlanArn
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deploymentStatus = "DeploymentStatus"
            case lastAttemptedExecutionTime = "LastAttemptedExecutionTime"
            case lastSuccessfulExecutionTime = "LastSuccessfulExecutionTime"
            case reportDeliveryChannel = "ReportDeliveryChannel"
            case reportPlanArn = "ReportPlanArn"
            case reportPlanDescription = "ReportPlanDescription"
            case reportPlanName = "ReportPlanName"
            case reportSetting = "ReportSetting"
        }
    }

    public struct ReportSetting: AWSEncodableShape & AWSDecodableShape {
        /// These are the accounts to be included in the report. Use string value of ROOT to include all organizational units.
        public let accounts: [String]?
        /// The Amazon Resource Names (ARNs) of the frameworks a report covers.
        public let frameworkArns: [String]?
        /// The number of frameworks a report covers.
        public let numberOfFrameworks: Int?
        /// These are the Organizational Units to be included in the report.
        public let organizationUnits: [String]?
        /// These are the Regions to be included in the report. Use the wildcard as the string value to include all Regions.
        public let regions: [String]?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportTemplate: String

        @inlinable
        public init(accounts: [String]? = nil, frameworkArns: [String]? = nil, numberOfFrameworks: Int? = nil, organizationUnits: [String]? = nil, regions: [String]? = nil, reportTemplate: String) {
            self.accounts = accounts
            self.frameworkArns = frameworkArns
            self.numberOfFrameworks = numberOfFrameworks
            self.organizationUnits = organizationUnits
            self.regions = regions
            self.reportTemplate = reportTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "Accounts"
            case frameworkArns = "FrameworkArns"
            case numberOfFrameworks = "NumberOfFrameworks"
            case organizationUnits = "OrganizationUnits"
            case regions = "Regions"
            case reportTemplate = "ReportTemplate"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct RestoreJobCreator: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies  a restore testing plan.
        public let restoreTestingPlanArn: String?

        @inlinable
        public init(restoreTestingPlanArn: String? = nil) {
            self.restoreTestingPlanArn = restoreTestingPlanArn
        }

        private enum CodingKeys: String, CodingKey {
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
        }
    }

    public struct RestoreJobSummary: AWSDecodableShape {
        /// The account ID that owns the jobs within the summary.
        public let accountId: String?
        /// The value as a number of jobs in a job summary.
        public let count: Int?
        /// The value of time in number format of a job end time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let endTime: Date?
        /// The Amazon Web Services Regions within the job summary.
        public let region: String?
        /// This value is the job count for the specified resource type.  The request GetSupportedResourceTypes returns  strings for supported resource types.
        public let resourceType: String?
        /// The value of time in number format of a job start time. This value is the time in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startTime: Date?
        /// This value is job count for jobs  with the specified state.
        public let state: RestoreJobState?

        @inlinable
        public init(accountId: String? = nil, count: Int? = nil, endTime: Date? = nil, region: String? = nil, resourceType: String? = nil, startTime: Date? = nil, state: RestoreJobState? = nil) {
            self.accountId = accountId
            self.count = count
            self.endTime = endTime
            self.region = region
            self.resourceType = resourceType
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case count = "Count"
            case endTime = "EndTime"
            case region = "Region"
            case resourceType = "ResourceType"
            case startTime = "StartTime"
            case state = "State"
        }
    }

    public struct RestoreJobsListMember: AWSDecodableShape {
        /// The account ID that owns the restore job.
        public let accountId: String?
        /// The size, in bytes, of the restored resource.
        public let backupSizeInBytes: Int64?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation  of a restore job.
        public let createdBy: RestoreJobCreator?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let createdResourceArn: String?
        /// The date and time a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// This notes the status of the data generated by the restore  test. The status may be Deleting, Failed,  or Successful.
        public let deletionStatus: RestoreDeletionStatus?
        /// This describes the restore job deletion status.
        public let deletionStatusMessage: String?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public let expectedCompletionTimeMinutes: Int64?
        /// The IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// The date on which a recovery point was created.
        public let recoveryPointCreationDate: Date?
        /// The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String?
        /// A status code specifying the state of the job initiated by Backup to restore a recovery point.
        public let status: RestoreJobStatus?
        /// A detailed message explaining the status of the job to restore a recovery point.
        public let statusMessage: String?
        /// The status of validation run on the indicated  restore job.
        public let validationStatus: RestoreValidationStatus?
        /// This describes the status of validation run on the  indicated restore job.
        public let validationStatusMessage: String?

        @inlinable
        public init(accountId: String? = nil, backupSizeInBytes: Int64? = nil, completionDate: Date? = nil, createdBy: RestoreJobCreator? = nil, createdResourceArn: String? = nil, creationDate: Date? = nil, deletionStatus: RestoreDeletionStatus? = nil, deletionStatusMessage: String? = nil, expectedCompletionTimeMinutes: Int64? = nil, iamRoleArn: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, recoveryPointCreationDate: Date? = nil, resourceType: String? = nil, restoreJobId: String? = nil, status: RestoreJobStatus? = nil, statusMessage: String? = nil, validationStatus: RestoreValidationStatus? = nil, validationStatusMessage: String? = nil) {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.deletionStatus = deletionStatus
            self.deletionStatusMessage = deletionStatusMessage
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.recoveryPointCreationDate = recoveryPointCreationDate
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
            self.validationStatus = validationStatus
            self.validationStatusMessage = validationStatusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupSizeInBytes = "BackupSizeInBytes"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case createdResourceArn = "CreatedResourceArn"
            case creationDate = "CreationDate"
            case deletionStatus = "DeletionStatus"
            case deletionStatusMessage = "DeletionStatusMessage"
            case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
            case iamRoleArn = "IamRoleArn"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case recoveryPointCreationDate = "RecoveryPointCreationDate"
            case resourceType = "ResourceType"
            case restoreJobId = "RestoreJobId"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case validationStatus = "ValidationStatus"
            case validationStatusMessage = "ValidationStatusMessage"
        }
    }

    public struct RestoreTestingPlanForCreate: AWSEncodableShape {
        ///  RecoveryPointSelection has five parameters (three required and two optional). The values you specify determine which recovery point is included in the restore test. You must indicate with Algorithm if you want the latest recovery point within your SelectionWindowDays or if you want a random recovery point, and you must indicate through IncludeVaults from which vaults the recovery points can be chosen.  Algorithm (required) Valid values: "LATEST_WITHIN_WINDOW" or "RANDOM_WITHIN_WINDOW".  Recovery point types (required) Valid values: "SNAPSHOT" and/or "CONTINUOUS". Include SNAPSHOT to restore only snapshot recovery points; include CONTINUOUS to restore continuous recovery points (point in time restore / PITR); use both to restore either a snapshot or a continuous recovery point. The recovery point will be determined by the value for Algorithm.  IncludeVaults (required). You must include one or more backup vaults. Use the wildcard ["*"] or specific ARNs.  SelectionWindowDays (optional) Value must be an integer (in days) from 1 to 365. If not included, the value defaults to 30.  ExcludeVaults (optional). You can choose to input one or more specific backup vault ARNs to exclude those vaults' contents from restore eligibility. Or, you can include a list of selectors. If this parameter and its value are not included, it defaults to empty list.
        public let recoveryPointSelection: RestoreTestingRecoveryPointSelection
        /// The RestoreTestingPlanName is a unique string that is the name  of the restore testing plan. This cannot be changed after creation,  and it must consist of only alphanumeric characters and underscores.
        public let restoreTestingPlanName: String
        /// A CRON expression in specified timezone when a restore  testing plan is executed.
        public let scheduleExpression: String
        /// Optional. This is the timezone in which the schedule  expression is set. By default, ScheduleExpressions are in UTC.  You can modify this to a specified timezone.
        public let scheduleExpressionTimezone: String?
        /// Defaults to 24 hours. A value in hours after a  restore test is scheduled before a job will be canceled if it  doesn't start successfully. This value is optional. If this value  is included, this parameter has a maximum value of 168 hours  (one week).
        public let startWindowHours: Int?

        @inlinable
        public init(recoveryPointSelection: RestoreTestingRecoveryPointSelection, restoreTestingPlanName: String, scheduleExpression: String, scheduleExpressionTimezone: String? = nil, startWindowHours: Int? = nil) {
            self.recoveryPointSelection = recoveryPointSelection
            self.restoreTestingPlanName = restoreTestingPlanName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryPointSelection = "RecoveryPointSelection"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startWindowHours = "StartWindowHours"
        }
    }

    public struct RestoreTestingPlanForGet: AWSDecodableShape {
        /// The date and time that a restore testing plan was created,  in Unix format and Coordinated Universal Time (UTC). The value of  CreationTime is accurate to milliseconds. For example,  the value 1516925490.087 represents Friday, January 26, 2018  12:11:30.087  AM.
        public let creationTime: Date
        /// This identifies the request and allows failed requests to  be retried without the risk of running the operation twice.  If the request includes a CreatorRequestId that  matches an existing backup plan, that plan is returned. This  parameter is optional. If used, this parameter must  contain 1 to 50 alphanumeric or '-_.' characters.
        public let creatorRequestId: String?
        /// The last time a restore test was run with the specified  restore testing plan. A date and time, in Unix format and  Coordinated Universal Time (UTC). The value of  LastExecutionDate is accurate to milliseconds.  For example, the value  1516925490.087 represents Friday,  January 26, 2018 12:11:30.087 AM.
        public let lastExecutionTime: Date?
        /// The date and time that the restore testing plan was updated.  This update is in Unix format and Coordinated Universal Time (UTC).  The value of LastUpdateTime is accurate to milliseconds.  For example, the value  1516925490.087 represents Friday,  January 26, 2018 12:11:30.087 AM.
        public let lastUpdateTime: Date?
        /// The specified criteria to assign a set of resources, such as  recovery point types or backup vaults.
        public let recoveryPointSelection: RestoreTestingRecoveryPointSelection
        /// An Amazon Resource Name (ARN) that uniquely identifies  a restore testing plan.
        public let restoreTestingPlanArn: String
        /// The restore testing plan name.
        public let restoreTestingPlanName: String
        /// A CRON expression in specified timezone when a restore  testing plan is executed.
        public let scheduleExpression: String
        /// Optional. This is the timezone in which the schedule  expression is set. By default, ScheduleExpressions are in UTC.  You can modify this to a specified timezone.
        public let scheduleExpressionTimezone: String?
        /// Defaults to 24 hours. A value in hours after a  restore test is scheduled before a job will be canceled if it  doesn't start successfully. This value is optional. If this value  is included, this parameter has a maximum value of 168 hours  (one week).
        public let startWindowHours: Int?

        @inlinable
        public init(creationTime: Date, creatorRequestId: String? = nil, lastExecutionTime: Date? = nil, lastUpdateTime: Date? = nil, recoveryPointSelection: RestoreTestingRecoveryPointSelection, restoreTestingPlanArn: String, restoreTestingPlanName: String, scheduleExpression: String, scheduleExpressionTimezone: String? = nil, startWindowHours: Int? = nil) {
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.lastExecutionTime = lastExecutionTime
            self.lastUpdateTime = lastUpdateTime
            self.recoveryPointSelection = recoveryPointSelection
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case creatorRequestId = "CreatorRequestId"
            case lastExecutionTime = "LastExecutionTime"
            case lastUpdateTime = "LastUpdateTime"
            case recoveryPointSelection = "RecoveryPointSelection"
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startWindowHours = "StartWindowHours"
        }
    }

    public struct RestoreTestingPlanForList: AWSDecodableShape {
        /// The date and time that a restore testing plan was created,  in Unix format and Coordinated Universal Time (UTC). The value  of CreationTime is accurate to milliseconds. For  example, the value 1516925490.087 represents Friday, January 26,  2018 12:11:30.087 AM.
        public let creationTime: Date
        /// The last time a restore test was run with the specified  restore testing plan. A date and time, in Unix format and  Coordinated Universal Time (UTC). The value of  LastExecutionDate is accurate to milliseconds.  For example, the value 1516925490.087 represents Friday,  January 26, 2018 12:11:30.087 AM.
        public let lastExecutionTime: Date?
        /// The date and time that the restore testing plan was updated.  This update is in Unix format and Coordinated Universal Time (UTC).  The value of LastUpdateTime is accurate to  milliseconds. For example, the value 1516925490.087 represents  Friday, January 26, 2018 12:11:30.087 AM.
        public let lastUpdateTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifiesa  restore testing plan.
        public let restoreTestingPlanArn: String
        /// The restore testing plan name.
        public let restoreTestingPlanName: String
        /// A CRON expression in specified timezone when a restore  testing plan is executed.
        public let scheduleExpression: String
        /// Optional. This is the timezone in which the schedule  expression is set. By default, ScheduleExpressions are in UTC.  You can modify this to a specified timezone.
        public let scheduleExpressionTimezone: String?
        /// Defaults to 24 hours. A value in hours after a restore test is scheduled before  a job will be canceled if it doesn't start successfully. This  value is optional. If this value is included, this parameter  has a maximum value of 168 hours (one week).
        public let startWindowHours: Int?

        @inlinable
        public init(creationTime: Date, lastExecutionTime: Date? = nil, lastUpdateTime: Date? = nil, restoreTestingPlanArn: String, restoreTestingPlanName: String, scheduleExpression: String, scheduleExpressionTimezone: String? = nil, startWindowHours: Int? = nil) {
            self.creationTime = creationTime
            self.lastExecutionTime = lastExecutionTime
            self.lastUpdateTime = lastUpdateTime
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastExecutionTime = "LastExecutionTime"
            case lastUpdateTime = "LastUpdateTime"
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startWindowHours = "StartWindowHours"
        }
    }

    public struct RestoreTestingPlanForUpdate: AWSEncodableShape {
        /// Required: Algorithm; RecoveryPointTypes;  IncludeVaults (one or more). Optional: SelectionWindowDays ('30' if  not specified); ExcludeVaults (defaults to empty  list if not listed).
        public let recoveryPointSelection: RestoreTestingRecoveryPointSelection?
        /// A CRON expression in specified timezone when a restore  testing plan is executed.
        public let scheduleExpression: String?
        /// Optional. This is the timezone in which the schedule  expression is set. By default, ScheduleExpressions are in UTC.  You can modify this to a specified timezone.
        public let scheduleExpressionTimezone: String?
        /// Defaults to 24 hours. A value in hours after a restore test is scheduled before a  job will be canceled if it doesn't start successfully. This value  is optional. If this value is included, this parameter has a  maximum value of 168 hours (one week).
        public let startWindowHours: Int?

        @inlinable
        public init(recoveryPointSelection: RestoreTestingRecoveryPointSelection? = nil, scheduleExpression: String? = nil, scheduleExpressionTimezone: String? = nil, startWindowHours: Int? = nil) {
            self.recoveryPointSelection = recoveryPointSelection
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startWindowHours = startWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryPointSelection = "RecoveryPointSelection"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startWindowHours = "StartWindowHours"
        }
    }

    public struct RestoreTestingRecoveryPointSelection: AWSEncodableShape & AWSDecodableShape {
        /// Acceptable values include "LATEST_WITHIN_WINDOW" or  "RANDOM_WITHIN_WINDOW"
        public let algorithm: RestoreTestingRecoveryPointSelectionAlgorithm?
        /// Accepted values include specific ARNs or list of selectors.  Defaults to empty list if not listed.
        public let excludeVaults: [String]?
        /// Accepted values include wildcard ["*"] or by specific ARNs or  ARN wilcard replacement  ["arn:aws:backup:us-west-2:123456789012:backup-vault:asdf", ...]  ["arn:aws:backup:*:*:backup-vault:asdf-*", ...]
        public let includeVaults: [String]?
        /// These are the types of recovery points. Include SNAPSHOT to restore only snapshot recovery points; include CONTINUOUS to restore continuous recovery points (point in time restore / PITR); use both to restore either a snapshot or a continuous recovery point. The recovery point will be determined by the value for Algorithm.
        public let recoveryPointTypes: [RestoreTestingRecoveryPointType]?
        /// Accepted values are integers from 1 to 365.
        public let selectionWindowDays: Int?

        @inlinable
        public init(algorithm: RestoreTestingRecoveryPointSelectionAlgorithm? = nil, excludeVaults: [String]? = nil, includeVaults: [String]? = nil, recoveryPointTypes: [RestoreTestingRecoveryPointType]? = nil, selectionWindowDays: Int? = nil) {
            self.algorithm = algorithm
            self.excludeVaults = excludeVaults
            self.includeVaults = includeVaults
            self.recoveryPointTypes = recoveryPointTypes
            self.selectionWindowDays = selectionWindowDays
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "Algorithm"
            case excludeVaults = "ExcludeVaults"
            case includeVaults = "IncludeVaults"
            case recoveryPointTypes = "RecoveryPointTypes"
            case selectionWindowDays = "SelectionWindowDays"
        }
    }

    public struct RestoreTestingSelectionForCreate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the IAM role that  Backup uses to create the target resource;  for example: arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// Each protected resource can be filtered by its specific ARNs, such as  ProtectedResourceArns: ["arn:aws:...", "arn:aws:..."]  or by a wildcard: ProtectedResourceArns: ["*"],  but not both.
        public let protectedResourceArns: [String]?
        /// If you have included the wildcard in ProtectedResourceArns,  you can include resource conditions, such as  ProtectedResourceConditions: {    StringEquals: [{ key: "XXXX",  value: "YYYY" }].
        public let protectedResourceConditions: ProtectedResourceConditions?
        /// The type of Amazon Web Services resource included in a restore  testing selection; for example, an Amazon EBS volume or  an Amazon RDS database. Supported resource types accepted include:    Aurora for Amazon Aurora    DocumentDB for Amazon DocumentDB (with MongoDB compatibility)    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    FSx for Amazon FSx    Neptune for Amazon Neptune    RDS for Amazon Relational Database Service    S3 for Amazon S3
        public let protectedResourceType: String
        /// You can override certain restore metadata keys by including the parameter RestoreMetadataOverrides in the body of RestoreTestingSelection. Key values are not case sensitive. See the complete list of restore testing inferred metadata.
        public let restoreMetadataOverrides: [String: String]?
        /// The unique name of the restore testing selection  that belongs to the related restore testing plan.
        public let restoreTestingSelectionName: String
        /// This is amount of hours (1 to 168) available to run a validation script on the data. The data will be deleted upon the completion of the validation script or the end of the specified retention period, whichever comes first.
        public let validationWindowHours: Int?

        @inlinable
        public init(iamRoleArn: String, protectedResourceArns: [String]? = nil, protectedResourceConditions: ProtectedResourceConditions? = nil, protectedResourceType: String, restoreMetadataOverrides: [String: String]? = nil, restoreTestingSelectionName: String, validationWindowHours: Int? = nil) {
            self.iamRoleArn = iamRoleArn
            self.protectedResourceArns = protectedResourceArns
            self.protectedResourceConditions = protectedResourceConditions
            self.protectedResourceType = protectedResourceType
            self.restoreMetadataOverrides = restoreMetadataOverrides
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.validationWindowHours = validationWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case protectedResourceArns = "ProtectedResourceArns"
            case protectedResourceConditions = "ProtectedResourceConditions"
            case protectedResourceType = "ProtectedResourceType"
            case restoreMetadataOverrides = "RestoreMetadataOverrides"
            case restoreTestingSelectionName = "RestoreTestingSelectionName"
            case validationWindowHours = "ValidationWindowHours"
        }
    }

    public struct RestoreTestingSelectionForGet: AWSDecodableShape {
        /// The date and time that a restore testing selection was created,  in Unix format and Coordinated Universal Time (UTC). The value of  CreationTime is accurate to milliseconds. For example,  the value 1516925490.087 represents Friday, January 26,  201812:11:30.087  AM.
        public let creationTime: Date
        /// This identifies the request and allows failed requests to  be retried without the risk of running the operation twice.  If the request includes a CreatorRequestId that  matches an existing backup plan, that plan is returned. This  parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric  or '-_.' characters.
        public let creatorRequestId: String?
        /// The Amazon Resource Name (ARN) of the IAM role that  Backup uses to create the target resource; for  example:arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// You can include specific ARNs, such as  ProtectedResourceArns: ["arn:aws:...", "arn:aws:..."]  or you can include a wildcard: ProtectedResourceArns: ["*"],  but not both.
        public let protectedResourceArns: [String]?
        /// In a resource testing selection, this parameter filters by  specific conditions such as StringEquals or  StringNotEquals.
        public let protectedResourceConditions: ProtectedResourceConditions?
        /// The type of Amazon Web Services resource included in a resource  testing selection;  for example, an Amazon EBS volume  or an Amazon RDS database.
        public let protectedResourceType: String
        /// You can override certain restore metadata keys by including the parameter RestoreMetadataOverrides in the body of RestoreTestingSelection. Key values are not case sensitive. See the complete list of restore testing inferred metadata.
        public let restoreMetadataOverrides: [String: String]?
        /// The RestoreTestingPlanName is a unique string that is the name  of the restore testing plan.
        public let restoreTestingPlanName: String
        /// The unique name of the restore testing selection that  belongs to the related restore testing plan.
        public let restoreTestingSelectionName: String
        /// This is amount of hours (1 to 168) available to run a validation script on the data. The data will be deleted upon the completion of the validation script or the end of the specified retention period, whichever comes first.
        public let validationWindowHours: Int?

        @inlinable
        public init(creationTime: Date, creatorRequestId: String? = nil, iamRoleArn: String, protectedResourceArns: [String]? = nil, protectedResourceConditions: ProtectedResourceConditions? = nil, protectedResourceType: String, restoreMetadataOverrides: [String: String]? = nil, restoreTestingPlanName: String, restoreTestingSelectionName: String, validationWindowHours: Int? = nil) {
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.protectedResourceArns = protectedResourceArns
            self.protectedResourceConditions = protectedResourceConditions
            self.protectedResourceType = protectedResourceType
            self.restoreMetadataOverrides = restoreMetadataOverrides
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.validationWindowHours = validationWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case creatorRequestId = "CreatorRequestId"
            case iamRoleArn = "IamRoleArn"
            case protectedResourceArns = "ProtectedResourceArns"
            case protectedResourceConditions = "ProtectedResourceConditions"
            case protectedResourceType = "ProtectedResourceType"
            case restoreMetadataOverrides = "RestoreMetadataOverrides"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case restoreTestingSelectionName = "RestoreTestingSelectionName"
            case validationWindowHours = "ValidationWindowHours"
        }
    }

    public struct RestoreTestingSelectionForList: AWSDecodableShape {
        /// The date and time that a restore testing selection  was created, in Unix format and Coordinated Universal Time (UTC).  The value of CreationTime is accurate to milliseconds.  For example, the value 1516925490.087 represents Friday,  January 26,2018 12:11:30.087 AM.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the IAM role that  Backup uses to create the target resource; for example:  arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// The type of Amazon Web Services resource included in a restore  testing selection; for example, an  Amazon EBS volume or an Amazon RDS database.
        public let protectedResourceType: String
        /// Unique string that is the name of the restore testing plan. The name cannot be changed after creation. The name must  consist of only alphanumeric characters and underscores.  Maximum length is 50.
        public let restoreTestingPlanName: String
        /// Unique name of a restore testing selection.
        public let restoreTestingSelectionName: String
        /// This value represents the time, in hours, data is retained after  a restore test so that optional validation can be completed. Accepted value is an integer between  0 and 168 (the hourly equivalent of seven days).
        public let validationWindowHours: Int?

        @inlinable
        public init(creationTime: Date, iamRoleArn: String, protectedResourceType: String, restoreTestingPlanName: String, restoreTestingSelectionName: String, validationWindowHours: Int? = nil) {
            self.creationTime = creationTime
            self.iamRoleArn = iamRoleArn
            self.protectedResourceType = protectedResourceType
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.validationWindowHours = validationWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case iamRoleArn = "IamRoleArn"
            case protectedResourceType = "ProtectedResourceType"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case restoreTestingSelectionName = "RestoreTestingSelectionName"
            case validationWindowHours = "ValidationWindowHours"
        }
    }

    public struct RestoreTestingSelectionForUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the IAM role that  Backup uses to create the target resource; for example:  arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// You can include a list of specific ARNs, such as  ProtectedResourceArns: ["arn:aws:...", "arn:aws:..."]  or you can include a wildcard: ProtectedResourceArns: ["*"],  but not both.
        public let protectedResourceArns: [String]?
        /// The conditions that you define for resources in  your restore testing plan using tags.
        public let protectedResourceConditions: ProtectedResourceConditions?
        /// You can override certain restore metadata keys by including the parameter RestoreMetadataOverrides in the body of RestoreTestingSelection. Key values are not case sensitive. See the complete list of restore testing inferred metadata.
        public let restoreMetadataOverrides: [String: String]?
        /// This value represents the time, in hours, data is retained after  a restore test so that optional validation can be completed. Accepted value is an integer between  0 and 168 (the hourly equivalent of seven days).
        public let validationWindowHours: Int?

        @inlinable
        public init(iamRoleArn: String? = nil, protectedResourceArns: [String]? = nil, protectedResourceConditions: ProtectedResourceConditions? = nil, restoreMetadataOverrides: [String: String]? = nil, validationWindowHours: Int? = nil) {
            self.iamRoleArn = iamRoleArn
            self.protectedResourceArns = protectedResourceArns
            self.protectedResourceConditions = protectedResourceConditions
            self.restoreMetadataOverrides = restoreMetadataOverrides
            self.validationWindowHours = validationWindowHours
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case protectedResourceArns = "ProtectedResourceArns"
            case protectedResourceConditions = "ProtectedResourceConditions"
            case restoreMetadataOverrides = "RestoreMetadataOverrides"
            case validationWindowHours = "ValidationWindowHours"
        }
    }

    public struct ServiceUnavailableException: AWSErrorShape {
        public let code: String?
        public let context: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, context: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.context = context
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case context = "Context"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct StartBackupJobInput: AWSEncodableShape {
        /// The backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS""disabled" to create a regular backup. The WindowsVSS option is not enabled by default.
        public let backupOptions: [String: String]?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// A value in minutes during which a successfully started backup must complete, or else Backup will cancel the job. This value is optional. This value begins counting down from when the backup was scheduled. It does not add additional time for StartWindowMinutes, or if the backup started later than scheduled. Like StartWindowMinutes, this parameter has a maximum value of  100 years (52,560,000 minutes).
        public let completeWindowMinutes: Int64?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartBackupJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// Include this parameter to enable index creation if your backup  job has a resource type that supports backup indexes. Resource types that support backup indexes include:    EBS for Amazon Elastic Block Store    S3 for Amazon Simple Storage Service (Amazon S3)   Index can have 1 of 2 possible values, either ENABLED or  DISABLED. To create a backup index for an eligible ACTIVE recovery point  that does not yet have a backup index, set value to ENABLED. To delete a backup index, set value to DISABLED.
        public let index: Index?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Resource types that can transition to cold storage are listed in the Feature  availability by resource table. Backup ignores this expression for other resource types. This parameter has a maximum value of 100 years (36,500 days).
        public let lifecycle: Lifecycle?
        /// The tags to assign to the resources.
        public let recoveryPointTags: [String: String]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional, and the default is 8 hours.  If this value is included, it must be at least 60 minutes to avoid errors. This parameter has a maximum value of 100 years (52,560,000 minutes). During the start window, the backup job status remains in CREATED status until it  has successfully begun or until the start window time has run out. If within the start  window time Backup receives an error that allows the job to be retried,  Backup will automatically retry to begin the job at least every 10 minutes  until the backup  successfully begins (the job status changes to RUNNING) or until the job status  changes to EXPIRED (which is expected to occur when the start window time is over).
        public let startWindowMinutes: Int64?

        @inlinable
        public init(backupOptions: [String: String]? = nil, backupVaultName: String, completeWindowMinutes: Int64? = nil, iamRoleArn: String, idempotencyToken: String? = nil, index: Index? = nil, lifecycle: Lifecycle? = nil, recoveryPointTags: [String: String]? = nil, resourceArn: String, startWindowMinutes: Int64? = nil) {
            self.backupOptions = backupOptions
            self.backupVaultName = backupVaultName
            self.completeWindowMinutes = completeWindowMinutes
            self.iamRoleArn = iamRoleArn
            self.idempotencyToken = idempotencyToken
            self.index = index
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.resourceArn = resourceArn
            self.startWindowMinutes = startWindowMinutes
        }

        public func validate(name: String) throws {
            try self.backupOptions?.forEach {
                try validate($0.key, name: "backupOptions.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
                try validate($0.value, name: "backupOptions[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupOptions = "BackupOptions"
            case backupVaultName = "BackupVaultName"
            case completeWindowMinutes = "CompleteWindowMinutes"
            case iamRoleArn = "IamRoleArn"
            case idempotencyToken = "IdempotencyToken"
            case index = "Index"
            case lifecycle = "Lifecycle"
            case recoveryPointTags = "RecoveryPointTags"
            case resourceArn = "ResourceArn"
            case startWindowMinutes = "StartWindowMinutes"
        }
    }

    public struct StartBackupJobOutput: AWSDecodableShape {
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String?
        /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// This is a returned boolean value indicating this is a parent (composite)  backup job.
        public let isParent: Bool?
        ///  Note: This field is only returned for Amazon EFS and Advanced DynamoDB  resources.  An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?

        @inlinable
        public init(backupJobId: String? = nil, creationDate: Date? = nil, isParent: Bool? = nil, recoveryPointArn: String? = nil) {
            self.backupJobId = backupJobId
            self.creationDate = creationDate
            self.isParent = isParent
            self.recoveryPointArn = recoveryPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupJobId = "BackupJobId"
            case creationDate = "CreationDate"
            case isParent = "IsParent"
            case recoveryPointArn = "RecoveryPointArn"
        }
    }

    public struct StartCopyJobInput: AWSEncodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let destinationBackupVaultArn: String
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartCopyJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        public let lifecycle: Lifecycle?
        /// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String
        /// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let sourceBackupVaultName: String

        @inlinable
        public init(destinationBackupVaultArn: String, iamRoleArn: String, idempotencyToken: String? = nil, lifecycle: Lifecycle? = nil, recoveryPointArn: String, sourceBackupVaultName: String) {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.iamRoleArn = iamRoleArn
            self.idempotencyToken = idempotencyToken
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.sourceBackupVaultName = sourceBackupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceBackupVaultName, name: "sourceBackupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case iamRoleArn = "IamRoleArn"
            case idempotencyToken = "IdempotencyToken"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
            case sourceBackupVaultName = "SourceBackupVaultName"
        }
    }

    public struct StartCopyJobOutput: AWSDecodableShape {
        /// Uniquely identifies a copy job.
        public let copyJobId: String?
        /// The date and time that a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// This is a returned boolean value indicating this is a parent (composite)  copy job.
        public let isParent: Bool?

        @inlinable
        public init(copyJobId: String? = nil, creationDate: Date? = nil, isParent: Bool? = nil) {
            self.copyJobId = copyJobId
            self.creationDate = creationDate
            self.isParent = isParent
        }

        private enum CodingKeys: String, CodingKey {
            case copyJobId = "CopyJobId"
            case creationDate = "CreationDate"
            case isParent = "IsParent"
        }
    }

    public struct StartReportJobInput: AWSEncodableShape {
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartReportJobInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// The unique name of a report plan.
        public let reportPlanName: String

        @inlinable
        public init(idempotencyToken: String? = StartReportJobInput.idempotencyToken(), reportPlanName: String) {
            self.idempotencyToken = idempotencyToken
            self.reportPlanName = reportPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.idempotencyToken, forKey: .idempotencyToken)
            request.encodePath(self.reportPlanName, key: "ReportPlanName")
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct StartReportJobOutput: AWSDecodableShape {
        /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
        public let reportJobId: String?

        @inlinable
        public init(reportJobId: String? = nil) {
            self.reportJobId = reportJobId
        }

        private enum CodingKeys: String, CodingKey {
            case reportJobId = "ReportJobId"
        }
    }

    public struct StartRestoreJobInput: AWSEncodableShape {
        /// This is an optional parameter. If this equals True, tags included in the backup will be copied to the restored resource. This can only be applied to backups created through Backup.
        public let copySourceTagsToRestoredResource: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target resource; for example: arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartRestoreJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// A set of metadata key-value pairs. You can get configuration metadata about a resource at the time it was backed up by calling GetRecoveryPointRestoreMetadata. However, values in addition to those provided by GetRecoveryPointRestoreMetadata might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists. For more information about the metadata for each resource, see the following:    Metadata for Amazon Aurora     Metadata for Amazon DocumentDB     Metadata for CloudFormation     Metadata for Amazon DynamoDB      Metadata for Amazon EBS     Metadata for Amazon EC2     Metadata for Amazon EFS     Metadata for Amazon FSx     Metadata for Amazon Neptune     Metadata for Amazon RDS     Metadata for Amazon Redshift     Metadata for Storage Gateway     Metadata for Amazon S3     Metadata for Amazon Timestream     Metadata for virtual machines
        public let metadata: [String: String]
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String
        /// Starts a job to restore a recovery point for one of the following resources:    Aurora - Amazon Aurora    DocumentDB - Amazon DocumentDB    CloudFormation - CloudFormation    DynamoDB - Amazon DynamoDB    EBS - Amazon Elastic Block Store    EC2 - Amazon Elastic Compute Cloud    EFS - Amazon Elastic File System    FSx - Amazon FSx    Neptune - Amazon Neptune    RDS - Amazon Relational Database Service    Redshift - Amazon Redshift    Storage Gateway - Storage Gateway    S3 - Amazon Simple Storage Service    Timestream - Amazon Timestream    VirtualMachine - Virtual machines
        public let resourceType: String?

        @inlinable
        public init(copySourceTagsToRestoredResource: Bool? = nil, iamRoleArn: String? = nil, idempotencyToken: String? = nil, metadata: [String: String], recoveryPointArn: String, resourceType: String? = nil) {
            self.copySourceTagsToRestoredResource = copySourceTagsToRestoredResource
            self.iamRoleArn = iamRoleArn
            self.idempotencyToken = idempotencyToken
            self.metadata = metadata
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case copySourceTagsToRestoredResource = "CopySourceTagsToRestoredResource"
            case iamRoleArn = "IamRoleArn"
            case idempotencyToken = "IdempotencyToken"
            case metadata = "Metadata"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceType = "ResourceType"
        }
    }

    public struct StartRestoreJobOutput: AWSDecodableShape {
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String?

        @inlinable
        public init(restoreJobId: String? = nil) {
            self.restoreJobId = restoreJobId
        }

        private enum CodingKeys: String, CodingKey {
            case restoreJobId = "RestoreJobId"
        }
    }

    public struct StopBackupJobInput: AWSEncodableShape {
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String

        @inlinable
        public init(backupJobId: String) {
            self.backupJobId = backupJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupJobId, key: "BackupJobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource. ARNs that do not include backup are incompatible with tagging.  TagResource and UntagResource with invalid ARNs will  result in an error. Acceptable ARN content can include  arn:aws:backup:us-east. Invalid ARN content may look like  arn:aws:ec2:us-east.
        public let resourceArn: String
        /// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create. For clarity, this is the structure to assign tags: [{"Key":"string","Value":"string"}].
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource. ARNs that do not include backup are incompatible with tagging.  TagResource and UntagResource with invalid ARNs will  result in an error. Acceptable ARN content can include  arn:aws:backup:us-east. Invalid ARN content may look like  arn:aws:ec2:us-east.
        public let resourceArn: String
        /// The keys to identify which key-value tags to remove from a resource.
        public let tagKeyList: [String]

        @inlinable
        public init(resourceArn: String, tagKeyList: [String]) {
            self.resourceArn = resourceArn
            self.tagKeyList = tagKeyList
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tagKeyList, forKey: .tagKeyList)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeyList = "TagKeyList"
        }
    }

    public struct UpdateBackupPlanInput: AWSEncodableShape {
        /// The body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlanInput
        /// The ID of the backup plan.
        public let backupPlanId: String

        @inlinable
        public init(backupPlan: BackupPlanInput, backupPlanId: String) {
            self.backupPlan = backupPlan
            self.backupPlanId = backupPlanId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.backupPlan, forKey: .backupPlan)
            request.encodePath(self.backupPlanId, key: "BackupPlanId")
        }

        public func validate(name: String) throws {
            try self.backupPlan.validate(name: "\(name).backupPlan")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
        }
    }

    public struct UpdateBackupPlanOutput: AWSDecodableShape {
        /// Contains a list of BackupOptions for each resource type.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version Ids cannot be edited.
        public let versionId: String?

        @inlinable
        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, creationDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case versionId = "VersionId"
        }
    }

    public struct UpdateFrameworkInput: AWSEncodableShape {
        /// The controls that make up the framework. Each control in the list has a name, input parameters, and scope.
        public let frameworkControls: [FrameworkControl]?
        /// An optional description of the framework with a maximum 1,024 characters.
        public let frameworkDescription: String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?

        @inlinable
        public init(frameworkControls: [FrameworkControl]? = nil, frameworkDescription: String? = nil, frameworkName: String, idempotencyToken: String? = UpdateFrameworkInput.idempotencyToken()) {
            self.frameworkControls = frameworkControls
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.idempotencyToken = idempotencyToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.frameworkControls, forKey: .frameworkControls)
            try container.encodeIfPresent(self.frameworkDescription, forKey: .frameworkDescription)
            request.encodePath(self.frameworkName, key: "FrameworkName")
            try container.encodeIfPresent(self.idempotencyToken, forKey: .idempotencyToken)
        }

        public func validate(name: String) throws {
            try self.frameworkControls?.forEach {
                try $0.validate(name: "\(name).frameworkControls[]")
            }
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, max: 1024)
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, pattern: "\\S")
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkControls = "FrameworkControls"
            case frameworkDescription = "FrameworkDescription"
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct UpdateFrameworkOutput: AWSDecodableShape {
        /// The date and time that a framework is created, in ISO 8601 representation. The value of CreationTime is accurate to milliseconds. For example, 2020-07-10T15:00:00.000-08:00 represents the 10th of July 2020 at 3:00 PM 8 hours behind UTC.
        public let creationTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String?

        @inlinable
        public init(creationTime: Date? = nil, frameworkArn: String? = nil, frameworkName: String? = nil) {
            self.creationTime = creationTime
            self.frameworkArn = frameworkArn
            self.frameworkName = frameworkName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case frameworkArn = "FrameworkArn"
            case frameworkName = "FrameworkName"
        }
    }

    public struct UpdateGlobalSettingsInput: AWSEncodableShape {
        /// A value for isCrossAccountBackupEnabled and a Region. Example: update-global-settings --global-settings isCrossAccountBackupEnabled=false --region us-west-2.
        public let globalSettings: [String: String]?

        @inlinable
        public init(globalSettings: [String: String]? = nil) {
            self.globalSettings = globalSettings
        }

        private enum CodingKeys: String, CodingKey {
            case globalSettings = "GlobalSettings"
        }
    }

    public struct UpdateRecoveryPointIndexSettingsInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. Accepted characters include lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// This specifies the IAM role ARN used for this operation. For example, arn:aws:iam::123456789012:role/S3Access
        public let iamRoleArn: String?
        /// Index can have 1 of 2 possible values, either ENABLED or  DISABLED. To create a backup index for an eligible ACTIVE recovery point  that does not yet have a backup index, set value to ENABLED. To delete a backup index, set value to DISABLED.
        public let index: Index
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultName: String, iamRoleArn: String? = nil, index: Index, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.iamRoleArn = iamRoleArn
            self.index = index
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encodeIfPresent(self.iamRoleArn, forKey: .iamRoleArn)
            try container.encode(self.index, forKey: .index)
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case index = "Index"
        }
    }

    public struct UpdateRecoveryPointIndexSettingsOutput: AWSDecodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created.
        public let backupVaultName: String?
        /// Index can have 1 of 2 possible values, either ENABLED or DISABLED. A value of ENABLED means a backup index for an eligible ACTIVE recovery point has been created. A value of DISABLED means a backup index was deleted.
        public let index: Index?
        /// This is the current status for the backup index associated  with the specified recovery point. Statuses are: PENDING | ACTIVE | FAILED | DELETING  A recovery point with an index that has the status of ACTIVE  can be included in a search.
        public let indexStatus: IndexStatus?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?

        @inlinable
        public init(backupVaultName: String? = nil, index: Index? = nil, indexStatus: IndexStatus? = nil, recoveryPointArn: String? = nil) {
            self.backupVaultName = backupVaultName
            self.index = index
            self.indexStatus = indexStatus
            self.recoveryPointArn = recoveryPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultName = "BackupVaultName"
            case index = "Index"
            case indexStatus = "IndexStatus"
            case recoveryPointArn = "RecoveryPointArn"
        }
    }

    public struct UpdateRecoveryPointLifecycleInput: AWSEncodableShape {
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created.
        public let backupVaultName: String
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.
        public let lifecycle: Lifecycle?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        @inlinable
        public init(backupVaultName: String, lifecycle: Lifecycle? = nil, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupVaultName, key: "BackupVaultName")
            try container.encodeIfPresent(self.lifecycle, forKey: .lifecycle)
            request.encodePath(self.recoveryPointArn, key: "RecoveryPointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycle = "Lifecycle"
        }
    }

    public struct UpdateRecoveryPointLifecycleOutput: AWSDecodableShape {
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:backup-vault:aBackupVault.
        public let backupVaultArn: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: CalculatedLifecycle?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “retention” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Resource types that can transition to cold storage are listed in the Feature availability  by resource table. Backup ignores this expression for other resource types.
        public let lifecycle: Lifecycle?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?

        @inlinable
        public init(backupVaultArn: String? = nil, calculatedLifecycle: CalculatedLifecycle? = nil, lifecycle: Lifecycle? = nil, recoveryPointArn: String? = nil) {
            self.backupVaultArn = backupVaultArn
            self.calculatedLifecycle = calculatedLifecycle
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case calculatedLifecycle = "CalculatedLifecycle"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
        }
    }

    public struct UpdateRegionSettingsInput: AWSEncodableShape {
        /// Enables or disables full Backup management of backups for a resource type. To enable full Backup management for DynamoDB along with  Backup's advanced DynamoDB backup features, follow the procedure to  enable advanced DynamoDB backup programmatically.
        public let resourceTypeManagementPreference: [String: Bool]?
        /// Updates the list of services along with the opt-in preferences for the Region. If resource assignments are only based on tags, then service opt-in settings are applied.  If a resource type is explicitly assigned to a backup plan, such as Amazon S3,  Amazon EC2, or Amazon RDS, it will be included in the  backup even if the opt-in is not enabled for that particular service.  If both a resource type and tags are specified in a resource assignment,  the resource type specified in the backup plan takes priority over the  tag condition. Service opt-in settings are disregarded in this situation.
        public let resourceTypeOptInPreference: [String: Bool]?

        @inlinable
        public init(resourceTypeManagementPreference: [String: Bool]? = nil, resourceTypeOptInPreference: [String: Bool]? = nil) {
            self.resourceTypeManagementPreference = resourceTypeManagementPreference
            self.resourceTypeOptInPreference = resourceTypeOptInPreference
        }

        public func validate(name: String) throws {
            try self.resourceTypeManagementPreference?.forEach {
                try validate($0.key, name: "resourceTypeManagementPreference.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
            try self.resourceTypeOptInPreference?.forEach {
                try validate($0.key, name: "resourceTypeOptInPreference.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
            case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
        }
    }

    public struct UpdateReportPlanInput: AWSEncodableShape {
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// The information about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public let reportDeliveryChannel: ReportDeliveryChannel?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public let reportPlanDescription: String?
        /// The unique name of the report plan. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let reportPlanName: String
        /// The report template for the report. Reports are built using a report template. The report templates are:  RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT  If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public let reportSetting: ReportSetting?

        @inlinable
        public init(idempotencyToken: String? = UpdateReportPlanInput.idempotencyToken(), reportDeliveryChannel: ReportDeliveryChannel? = nil, reportPlanDescription: String? = nil, reportPlanName: String, reportSetting: ReportSetting? = nil) {
            self.idempotencyToken = idempotencyToken
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.idempotencyToken, forKey: .idempotencyToken)
            try container.encodeIfPresent(self.reportDeliveryChannel, forKey: .reportDeliveryChannel)
            try container.encodeIfPresent(self.reportPlanDescription, forKey: .reportPlanDescription)
            request.encodePath(self.reportPlanName, key: "ReportPlanName")
            try container.encodeIfPresent(self.reportSetting, forKey: .reportSetting)
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, max: 1024)
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, pattern: "\\S")
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case idempotencyToken = "IdempotencyToken"
            case reportDeliveryChannel = "ReportDeliveryChannel"
            case reportPlanDescription = "ReportPlanDescription"
            case reportSetting = "ReportSetting"
        }
    }

    public struct UpdateReportPlanOutput: AWSDecodableShape {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// The unique name of the report plan.
        public let reportPlanName: String?

        @inlinable
        public init(creationTime: Date? = nil, reportPlanArn: String? = nil, reportPlanName: String? = nil) {
            self.creationTime = creationTime
            self.reportPlanArn = reportPlanArn
            self.reportPlanName = reportPlanName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case reportPlanArn = "ReportPlanArn"
            case reportPlanName = "ReportPlanName"
        }
    }

    public struct UpdateRestoreTestingPlanInput: AWSEncodableShape {
        /// Specifies the body of a restore testing plan.
        public let restoreTestingPlan: RestoreTestingPlanForUpdate
        /// The name of the restore testing plan name.
        public let restoreTestingPlanName: String

        @inlinable
        public init(restoreTestingPlan: RestoreTestingPlanForUpdate, restoreTestingPlanName: String) {
            self.restoreTestingPlan = restoreTestingPlan
            self.restoreTestingPlanName = restoreTestingPlanName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.restoreTestingPlan, forKey: .restoreTestingPlan)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
        }

        private enum CodingKeys: String, CodingKey {
            case restoreTestingPlan = "RestoreTestingPlan"
        }
    }

    public struct UpdateRestoreTestingPlanOutput: AWSDecodableShape {
        /// The time the resource testing plan was  created.
        public let creationTime: Date
        /// Unique ARN (Amazon Resource Name) of the restore testing plan.
        public let restoreTestingPlanArn: String
        /// The name cannot be changed after creation. The name consists of  only alphanumeric characters and underscores. Maximum length is 50.
        public let restoreTestingPlanName: String
        /// The time the update completed for the restore  testing plan.
        public let updateTime: Date

        @inlinable
        public init(creationTime: Date, restoreTestingPlanArn: String, restoreTestingPlanName: String, updateTime: Date) {
            self.creationTime = creationTime
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateRestoreTestingSelectionInput: AWSEncodableShape {
        /// The restore testing plan name is required to update the  indicated testing plan.
        public let restoreTestingPlanName: String
        /// To update your restore testing selection, you can use either  protected resource ARNs or conditions, but not both. That is, if your  selection has ProtectedResourceArns, requesting an update  with the parameter ProtectedResourceConditions will be  unsuccessful.
        public let restoreTestingSelection: RestoreTestingSelectionForUpdate
        /// The required restore testing selection name of the restore  testing selection you wish to update.
        public let restoreTestingSelectionName: String

        @inlinable
        public init(restoreTestingPlanName: String, restoreTestingSelection: RestoreTestingSelectionForUpdate, restoreTestingSelectionName: String) {
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelection = restoreTestingSelection
            self.restoreTestingSelectionName = restoreTestingSelectionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.restoreTestingPlanName, key: "RestoreTestingPlanName")
            try container.encode(self.restoreTestingSelection, forKey: .restoreTestingSelection)
            request.encodePath(self.restoreTestingSelectionName, key: "RestoreTestingSelectionName")
        }

        private enum CodingKeys: String, CodingKey {
            case restoreTestingSelection = "RestoreTestingSelection"
        }
    }

    public struct UpdateRestoreTestingSelectionOutput: AWSDecodableShape {
        /// The time the resource testing selection was  updated successfully.
        public let creationTime: Date
        /// Unique string that is the name of the restore testing plan.
        public let restoreTestingPlanArn: String
        /// The restore testing plan with which the updated restore  testing selection is associated.
        public let restoreTestingPlanName: String
        /// The returned restore testing selection name.
        public let restoreTestingSelectionName: String
        /// The time the update completed for the restore  testing selection.
        public let updateTime: Date

        @inlinable
        public init(creationTime: Date, restoreTestingPlanArn: String, restoreTestingPlanName: String, restoreTestingSelectionName: String, updateTime: Date) {
            self.creationTime = creationTime
            self.restoreTestingPlanArn = restoreTestingPlanArn
            self.restoreTestingPlanName = restoreTestingPlanName
            self.restoreTestingSelectionName = restoreTestingSelectionName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case restoreTestingPlanArn = "RestoreTestingPlanArn"
            case restoreTestingPlanName = "RestoreTestingPlanName"
            case restoreTestingSelectionName = "RestoreTestingSelectionName"
            case updateTime = "UpdateTime"
        }
    }
}

// MARK: - Errors

/// Error enum for Backup
public struct BackupErrorType: AWSErrorType {
    enum Code: String {
        case alreadyExistsException = "AlreadyExistsException"
        case conflictException = "ConflictException"
        case dependencyFailureException = "DependencyFailureException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestException = "InvalidRequestException"
        case invalidResourceStateException = "InvalidResourceStateException"
        case limitExceededException = "LimitExceededException"
        case missingParameterValueException = "MissingParameterValueException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Backup
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The required resource already exists.
    public static var alreadyExistsException: Self { .init(.alreadyExistsException) }
    /// Backup can't perform the action that you requested until it finishes performing a previous action. Try again later.
    public static var conflictException: Self { .init(.conflictException) }
    /// A dependent Amazon Web Services service or resource returned an error to the Backup service, and the action cannot be completed.
    public static var dependencyFailureException: Self { .init(.dependencyFailureException) }
    /// Indicates that something is wrong with a parameter's value. For example, the value is out of range.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// Indicates that something is wrong with the input to the request. For example, a parameter is of the wrong type.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// Backup is already performing an action on this recovery point. It can't perform the action you requested until the first action finishes. Try again later.
    public static var invalidResourceStateException: Self { .init(.invalidResourceStateException) }
    /// A limit in the request has been exceeded; for example, a maximum number of items allowed in a request.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// Indicates that a required parameter is missing.
    public static var missingParameterValueException: Self { .init(.missingParameterValueException) }
    /// A resource that is required for the action doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request failed due to a temporary failure of the server.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
}

extension BackupErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AlreadyExistsException": Backup.AlreadyExistsException.self,
        "ConflictException": Backup.ConflictException.self,
        "DependencyFailureException": Backup.DependencyFailureException.self,
        "InvalidParameterValueException": Backup.InvalidParameterValueException.self,
        "InvalidRequestException": Backup.InvalidRequestException.self,
        "InvalidResourceStateException": Backup.InvalidResourceStateException.self,
        "LimitExceededException": Backup.LimitExceededException.self,
        "MissingParameterValueException": Backup.MissingParameterValueException.self,
        "ResourceNotFoundException": Backup.ResourceNotFoundException.self,
        "ServiceUnavailableException": Backup.ServiceUnavailableException.self
    ]
}

extension BackupErrorType: Equatable {
    public static func == (lhs: BackupErrorType, rhs: BackupErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BackupErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
