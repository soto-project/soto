//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Backup {
    // MARK: Enums

    public enum BackupJobState: String, CustomStringConvertible, Codable {
        case aborted = "ABORTED"
        case aborting = "ABORTING"
        case completed = "COMPLETED"
        case created = "CREATED"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum BackupVaultEvent: String, CustomStringConvertible, Codable {
        case backupJobCompleted = "BACKUP_JOB_COMPLETED"
        case backupJobExpired = "BACKUP_JOB_EXPIRED"
        case backupJobFailed = "BACKUP_JOB_FAILED"
        case backupJobStarted = "BACKUP_JOB_STARTED"
        case backupJobSuccessful = "BACKUP_JOB_SUCCESSFUL"
        case backupPlanCreated = "BACKUP_PLAN_CREATED"
        case backupPlanModified = "BACKUP_PLAN_MODIFIED"
        case copyJobFailed = "COPY_JOB_FAILED"
        case copyJobStarted = "COPY_JOB_STARTED"
        case copyJobSuccessful = "COPY_JOB_SUCCESSFUL"
        case recoveryPointModified = "RECOVERY_POINT_MODIFIED"
        case restoreJobCompleted = "RESTORE_JOB_COMPLETED"
        case restoreJobFailed = "RESTORE_JOB_FAILED"
        case restoreJobStarted = "RESTORE_JOB_STARTED"
        case restoreJobSuccessful = "RESTORE_JOB_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum ConditionType: String, CustomStringConvertible, Codable {
        case stringequals = "STRINGEQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CopyJobState: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum RecoveryPointStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case deleting = "DELETING"
        case expired = "EXPIRED"
        case partial = "PARTIAL"
        public var description: String { return self.rawValue }
    }

    public enum RestoreJobStatus: String, CustomStringConvertible, Codable {
        case aborted = "ABORTED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable {
        case cold = "COLD"
        case deleted = "DELETED"
        case warm = "WARM"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AdvancedBackupSetting: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Valid values:  Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup.  Set to "WindowsVSS":"disabled" to create a regular backup. The WindowsVSS option is not enabled by default. If you specify an invalid option, you get an InvalidParameterValueException exception. For more information about Windows VSS backups, see Creating a VSS-Enabled Windows Backup.
        public let backupOptions: [String: String]?
        /// Specifies an object containing resource type and backup options. The only supported resource type is Amazon EC2 instances with Windows Volume Shadow Copy Service (VSS). For a CloudFormation example, see the sample CloudFormation template to enable Windows VSS in the Backup User Guide. Valid values: EC2.
        public let resourceType: String?

        public init(backupOptions: [String: String]? = nil, resourceType: String? = nil) {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.backupOptions?.forEach {
                try validate($0.key, name: "backupOptions.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
                try validate($0.value, name: "backupOptions[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupOptions = "BackupOptions"
            case resourceType = "ResourceType"
        }
    }

    public struct BackupJob: AWSDecodableShape {
        /// The account ID that owns the backup job.
        public let accountId: String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String?
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. If you specify an invalid option, you get an InvalidParameterValueException exception.
        public let backupOptions: [String: String]?
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// Represents the type of backup for a backup job.
        public let backupType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public let bytesTransferred: Int64?
        /// The date and time a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The date and time a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let expectedCompletionDate: Date?
        /// Specifies the IAM role ARN used to create the target recovery point. IAM roles other than the default role must include either AWSBackup or AwsBackup in the role name. For example, arn:aws:iam::123456789012:role/AWSBackupRDSAccess. Role names without those strings lack permissions to perform backup jobs.
        public let iamRoleArn: String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startBy: Date?
        /// The current state of a resource recovery point.
        public let state: BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public let statusMessage: String?

        public init(accountId: String? = nil, backupJobId: String? = nil, backupOptions: [String: String]? = nil, backupSizeInBytes: Int64? = nil, backupType: String? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, bytesTransferred: Int64? = nil, completionDate: Date? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, expectedCompletionDate: Date? = nil, iamRoleArn: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, startBy: Date? = nil, state: BackupJobState? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupJobId = "BackupJobId"
            case backupOptions = "BackupOptions"
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupType = "BackupType"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case bytesTransferred = "BytesTransferred"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case expectedCompletionDate = "ExpectedCompletionDate"
            case iamRoleArn = "IamRoleArn"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case startBy = "StartBy"
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct BackupPlan: AWSDecodableShape {
        /// Contains a list of BackupOptions for each resource type.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// The display name of a backup plan.
        public let backupPlanName: String
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public let rules: [BackupRule]

        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanName: String, rules: [BackupRule]) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanName = "BackupPlanName"
            case rules = "Rules"
        }
    }

    public struct BackupPlanInput: AWSEncodableShape {
        /// Specifies a list of BackupOptions for each resource type. These settings are only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// The optional display name of a backup plan.
        public let backupPlanName: String
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public let rules: [BackupRuleInput]

        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanName: String, rules: [BackupRuleInput]) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.advancedBackupSettings?.forEach {
                try $0.validate(name: "\(name).advancedBackupSettings[]")
            }
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanName = "BackupPlanName"
            case rules = "Rules"
        }
    }

    public struct BackupPlanTemplatesListMember: AWSDecodableShape {
        /// Uniquely identifies a stored backup plan template.
        public let backupPlanTemplateId: String?
        /// The optional display name of a backup plan template.
        public let backupPlanTemplateName: String?

        public init(backupPlanTemplateId: String? = nil, backupPlanTemplateName: String? = nil) {
            self.backupPlanTemplateId = backupPlanTemplateId
            self.backupPlanTemplateName = backupPlanTemplateName
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplateId = "BackupPlanTemplateId"
            case backupPlanTemplateName = "BackupPlanTemplateName"
        }
    }

    public struct BackupPlansListMember: AWSDecodableShape {
        /// Contains a list of BackupOptions for a resource type.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The display name of a saved backup plan.
        public let backupPlanName: String?
        /// The date and time a resource backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let deletionDate: Date?
        /// The last time a job to back up resources was run with this rule. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastExecutionDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, backupPlanName: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, deletionDate: Date? = nil, lastExecutionDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanName = backupPlanName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case backupPlanName = "BackupPlanName"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case deletionDate = "DeletionDate"
            case lastExecutionDate = "LastExecutionDate"
            case versionId = "VersionId"
        }
    }

    public struct BackupRule: AWSDecodableShape {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public let completionWindowMinutes: Int64?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public let copyActions: [CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public let enableContinuousBackup: Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Only Amazon EFS file system backups can be transitioned to cold storage.
        public let lifecycle: Lifecycle?
        /// An array of key-value pair strings that are assigned to resources that are associated with this rule when restored from backup.
        public let recoveryPointTags: [String: String]?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public let ruleId: String?
        /// An optional display name for a backup rule.
        public let ruleName: String
        /// A cron expression in UTC specifying when Backup initiates a backup job. For more information about cron expressions, see Schedule Expressions for Rules in the Amazon CloudWatch Events User Guide.. Prior to specifying a value for this parameter, we recommend testing your cron expression using one of the many available cron generator and testing tools.
        public let scheduleExpression: String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.
        public let startWindowMinutes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let targetBackupVaultName: String

        public init(completionWindowMinutes: Int64? = nil, copyActions: [CopyAction]? = nil, enableContinuousBackup: Bool? = nil, lifecycle: Lifecycle? = nil, recoveryPointTags: [String: String]? = nil, ruleId: String? = nil, ruleName: String, scheduleExpression: String? = nil, startWindowMinutes: Int64? = nil, targetBackupVaultName: String) {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }

        private enum CodingKeys: String, CodingKey {
            case completionWindowMinutes = "CompletionWindowMinutes"
            case copyActions = "CopyActions"
            case enableContinuousBackup = "EnableContinuousBackup"
            case lifecycle = "Lifecycle"
            case recoveryPointTags = "RecoveryPointTags"
            case ruleId = "RuleId"
            case ruleName = "RuleName"
            case scheduleExpression = "ScheduleExpression"
            case startWindowMinutes = "StartWindowMinutes"
            case targetBackupVaultName = "TargetBackupVaultName"
        }
    }

    public struct BackupRuleInput: AWSEncodableShape {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public let completionWindowMinutes: Int64?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public let copyActions: [CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public let enableContinuousBackup: Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Only Amazon EFS file system backups can be transitioned to cold storage.
        public let lifecycle: Lifecycle?
        /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
        public let recoveryPointTags: [String: String]?
        /// An optional display name for a backup rule.
        public let ruleName: String
        /// A CRON expression in UTC specifying when Backup initiates a backup job.
        public let scheduleExpression: String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.
        public let startWindowMinutes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let targetBackupVaultName: String

        public init(completionWindowMinutes: Int64? = nil, copyActions: [CopyAction]? = nil, enableContinuousBackup: Bool? = nil, lifecycle: Lifecycle? = nil, recoveryPointTags: [String: String]? = nil, ruleName: String, scheduleExpression: String? = nil, startWindowMinutes: Int64? = nil, targetBackupVaultName: String) {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.targetBackupVaultName, name: "targetBackupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case completionWindowMinutes = "CompletionWindowMinutes"
            case copyActions = "CopyActions"
            case enableContinuousBackup = "EnableContinuousBackup"
            case lifecycle = "Lifecycle"
            case recoveryPointTags = "RecoveryPointTags"
            case ruleName = "RuleName"
            case scheduleExpression = "ScheduleExpression"
            case startWindowMinutes = "StartWindowMinutes"
            case targetBackupVaultName = "TargetBackupVaultName"
        }
    }

    public struct BackupSelection: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that Backup uses to authenticate when backing up the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// An array of conditions used to specify a set of resources to assign to a backup plan; for example, "StringEquals": {"ec2:ResourceTag/Department": "accounting". Assigns the backup plan to every resource with at least one matching tag.
        public let listOfTags: [Condition]?
        /// An array of strings that contain Amazon Resource Names (ARNs)  of resources to assign to a backup plan.
        public let resources: [String]?
        /// The display name of a resource selection document.
        public let selectionName: String

        public init(iamRoleArn: String, listOfTags: [Condition]? = nil, resources: [String]? = nil, selectionName: String) {
            self.iamRoleArn = iamRoleArn
            self.listOfTags = listOfTags
            self.resources = resources
            self.selectionName = selectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.selectionName, name: "selectionName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case listOfTags = "ListOfTags"
            case resources = "Resources"
            case selectionName = "SelectionName"
        }
    }

    public struct BackupSelectionsListMember: AWSDecodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Uniquely identifies a request to assign a set of resources to a backup plan.
        public let selectionId: String?
        /// The display name of a resource selection document.
        public let selectionName: String?

        public init(backupPlanId: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, iamRoleArn: String? = nil, selectionId: String? = nil, selectionName: String? = nil) {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.selectionId = selectionId
            self.selectionName = selectionName
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case iamRoleArn = "IamRoleArn"
            case selectionId = "SelectionId"
            case selectionName = "SelectionName"
        }
    }

    public struct BackupVaultListMember: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The date and time a resource backup is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// The number of recovery points that are stored in a backup vault.
        public let numberOfRecoveryPoints: Int64?

        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, encryptionKeyArn: String? = nil, numberOfRecoveryPoints: Int64? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case encryptionKeyArn = "EncryptionKeyArn"
            case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
        }
    }

    public struct CalculatedLifecycle: AWSDecodableShape {
        /// A timestamp that specifies when to delete a recovery point.
        public let deleteAt: Date?
        /// A timestamp that specifies when to transition a recovery point to cold storage.
        public let moveToColdStorageAt: Date?

        public init(deleteAt: Date? = nil, moveToColdStorageAt: Date? = nil) {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAt = "DeleteAt"
            case moveToColdStorageAt = "MoveToColdStorageAt"
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// The key in a key-value pair. For example, in "ec2:ResourceTag/Department": "accounting", "ec2:ResourceTag/Department" is the key.
        public let conditionKey: String
        /// An operation, such as StringEquals, that is applied to a key-value pair used to filter resources in a selection.
        public let conditionType: ConditionType
        /// The value in a key-value pair. For example, in "ec2:ResourceTag/Department": "accounting", "accounting" is the value.
        public let conditionValue: String

        public init(conditionKey: String, conditionType: ConditionType, conditionValue: String) {
            self.conditionKey = conditionKey
            self.conditionType = conditionType
            self.conditionValue = conditionValue
        }

        private enum CodingKeys: String, CodingKey {
            case conditionKey = "ConditionKey"
            case conditionType = "ConditionType"
            case conditionValue = "ConditionValue"
        }
    }

    public struct ControlInputParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of a parameter, for example, BackupPlanFrequency.
        public let parameterName: String?
        /// The value of parameter, for example, hourly.
        public let parameterValue: String?

        public init(parameterName: String? = nil, parameterValue: String? = nil) {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName = "ParameterName"
            case parameterValue = "ParameterValue"
        }
    }

    public struct ControlScope: AWSEncodableShape & AWSDecodableShape {
        /// Describes whether the control scope includes a specific resource identified by its unique Amazon Resource Name (ARN).
        public let complianceResourceIds: [String]?
        /// Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
        public let complianceResourceTypes: [String]?
        /// Describes whether the control scope includes resources with one or more tags. Each tag is a key-value pair.
        public let tags: [String: String]?

        public init(complianceResourceIds: [String]? = nil, complianceResourceTypes: [String]? = nil, tags: [String: String]? = nil) {
            self.complianceResourceIds = complianceResourceIds
            self.complianceResourceTypes = complianceResourceTypes
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceResourceIds, name: "complianceResourceIds", parent: name, max: 100)
            try self.validate(self.complianceResourceIds, name: "complianceResourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceResourceIds = "ComplianceResourceIds"
            case complianceResourceTypes = "ComplianceResourceTypes"
            case tags = "Tags"
        }
    }

    public struct CopyAction: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let destinationBackupVaultArn: String
        public let lifecycle: Lifecycle?

        public init(destinationBackupVaultArn: String, lifecycle: Lifecycle? = nil) {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case lifecycle = "Lifecycle"
        }
    }

    public struct CopyJob: AWSDecodableShape {
        /// The account ID that owns the copy job.
        public let accountId: String?
        /// The size, in bytes, of a copy job.
        public let backupSizeInBytes: Int64?
        /// The date and time a copy job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Uniquely identifies a copy job.
        public let copyJobId: String?
        public let createdBy: RecoveryPointCreator?
        /// The date and time a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let destinationBackupVaultArn: String?
        /// An ARN that uniquely identifies a destination recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let destinationRecoveryPointArn: String?
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// The Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let sourceBackupVaultArn: String?
        /// An ARN that uniquely identifies a source recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let sourceRecoveryPointArn: String?
        /// The current state of a copy job.
        public let state: CopyJobState?
        /// A detailed message explaining the status of the job to copy a resource.
        public let statusMessage: String?

        public init(accountId: String? = nil, backupSizeInBytes: Int64? = nil, completionDate: Date? = nil, copyJobId: String? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, destinationBackupVaultArn: String? = nil, destinationRecoveryPointArn: String? = nil, iamRoleArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, sourceRecoveryPointArn: String? = nil, state: CopyJobState? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.copyJobId = copyJobId
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.destinationRecoveryPointArn = destinationRecoveryPointArn
            self.iamRoleArn = iamRoleArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.sourceRecoveryPointArn = sourceRecoveryPointArn
            self.state = state
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupSizeInBytes = "BackupSizeInBytes"
            case completionDate = "CompletionDate"
            case copyJobId = "CopyJobId"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case destinationRecoveryPointArn = "DestinationRecoveryPointArn"
            case iamRoleArn = "IamRoleArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case sourceRecoveryPointArn = "SourceRecoveryPointArn"
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct CreateBackupPlanInput: AWSEncodableShape {
        /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlanInput
        /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.
        public let backupPlanTags: [String: String]?
        /// Identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional.
        public let creatorRequestId: String?

        public init(backupPlan: BackupPlanInput, backupPlanTags: [String: String]? = nil, creatorRequestId: String? = nil) {
            self.backupPlan = backupPlan
            self.backupPlanTags = backupPlanTags
            self.creatorRequestId = creatorRequestId
        }

        public func validate(name: String) throws {
            try self.backupPlan.validate(name: "\(name).backupPlan")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
            case backupPlanTags = "BackupPlanTags"
            case creatorRequestId = "CreatorRequestId"
        }
    }

    public struct CreateBackupPlanOutput: AWSDecodableShape {
        /// A list of BackupOptions settings for a resource type. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public let versionId: String?

        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, creationDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case versionId = "VersionId"
        }
    }

    public struct CreateBackupSelectionInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId"))
        ]

        /// Uniquely identifies the backup plan to be associated with the selection of resources.
        public let backupPlanId: String
        /// Specifies the body of a request to assign a set of resources to a backup plan.
        public let backupSelection: BackupSelection
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?

        public init(backupPlanId: String, backupSelection: BackupSelection, creatorRequestId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.backupSelection = backupSelection
            self.creatorRequestId = creatorRequestId
        }

        public func validate(name: String) throws {
            try self.backupSelection.validate(name: "\(name).backupSelection")
        }

        private enum CodingKeys: String, CodingKey {
            case backupSelection = "BackupSelection"
            case creatorRequestId = "CreatorRequestId"
        }
    }

    public struct CreateBackupSelectionOutput: AWSDecodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String?

        public init(backupPlanId: String? = nil, creationDate: Date? = nil, selectionId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.selectionId = selectionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case selectionId = "SelectionId"
        }
    }

    public struct CreateBackupVaultInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
        public let backupVaultName: String
        /// Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.
        public let backupVaultTags: [String: String]?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?

        public init(backupVaultName: String, backupVaultTags: [String: String]? = nil, creatorRequestId: String? = nil, encryptionKeyArn: String? = nil) {
            self.backupVaultName = backupVaultName
            self.backupVaultTags = backupVaultTags
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultTags = "BackupVaultTags"
            case creatorRequestId = "CreatorRequestId"
            case encryptionKeyArn = "EncryptionKeyArn"
        }
    }

    public struct CreateBackupVaultOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?

        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
        }
    }

    public struct CreateFrameworkInput: AWSEncodableShape {
        /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
        public let frameworkControls: [FrameworkControl]
        /// An optional description of the framework with a maximum of 1,024 characters.
        public let frameworkDescription: String?
        /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String
        /// Metadata that you can assign to help organize the frameworks that you create. Each tag is a key-value pair.
        public let frameworkTags: [String: String]?
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?

        public init(frameworkControls: [FrameworkControl], frameworkDescription: String? = nil, frameworkName: String, frameworkTags: [String: String]? = nil, idempotencyToken: String? = CreateFrameworkInput.idempotencyToken()) {
            self.frameworkControls = frameworkControls
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.frameworkTags = frameworkTags
            self.idempotencyToken = idempotencyToken
        }

        public func validate(name: String) throws {
            try self.frameworkControls.forEach {
                try $0.validate(name: "\(name).frameworkControls[]")
            }
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, max: 1024)
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, pattern: "\\S")
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkControls = "FrameworkControls"
            case frameworkDescription = "FrameworkDescription"
            case frameworkName = "FrameworkName"
            case frameworkTags = "FrameworkTags"
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct CreateFrameworkOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String?

        public init(frameworkArn: String? = nil, frameworkName: String? = nil) {
            self.frameworkArn = frameworkArn
            self.frameworkName = frameworkName
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkArn = "FrameworkArn"
            case frameworkName = "FrameworkName"
        }
    }

    public struct CreateReportPlanInput: AWSEncodableShape {
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public let reportDeliveryChannel: ReportDeliveryChannel
        /// An optional description of the report plan with a maximum of 1,024 characters.
        public let reportPlanDescription: String?
        /// The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let reportPlanName: String
        /// Metadata that you can assign to help organize the frameworks that you create. Each tag is a key-value pair.
        public let reportPlanTags: [String: String]?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportSetting: ReportSetting

        public init(idempotencyToken: String? = CreateReportPlanInput.idempotencyToken(), reportDeliveryChannel: ReportDeliveryChannel, reportPlanDescription: String? = nil, reportPlanName: String, reportPlanTags: [String: String]? = nil, reportSetting: ReportSetting) {
            self.idempotencyToken = idempotencyToken
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportPlanTags = reportPlanTags
            self.reportSetting = reportSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, max: 1024)
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, pattern: "\\S")
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case idempotencyToken = "IdempotencyToken"
            case reportDeliveryChannel = "ReportDeliveryChannel"
            case reportPlanDescription = "ReportPlanDescription"
            case reportPlanName = "ReportPlanName"
            case reportPlanTags = "ReportPlanTags"
            case reportSetting = "ReportSetting"
        }
    }

    public struct CreateReportPlanOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// The unique name of the report plan.
        public let reportPlanName: String?

        public init(reportPlanArn: String? = nil, reportPlanName: String? = nil) {
            self.reportPlanArn = reportPlanArn
            self.reportPlanName = reportPlanName
        }

        private enum CodingKeys: String, CodingKey {
            case reportPlanArn = "ReportPlanArn"
            case reportPlanName = "ReportPlanName"
        }
    }

    public struct DeleteBackupPlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String

        public init(backupPlanId: String) {
            self.backupPlanId = backupPlanId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupPlanOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let deletionDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        public init(backupPlanArn: String? = nil, backupPlanId: String? = nil, deletionDate: Date? = nil, versionId: String? = nil) {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.deletionDate = deletionDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case deletionDate = "DeletionDate"
            case versionId = "VersionId"
        }
    }

    public struct DeleteBackupSelectionInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId")),
            AWSMemberEncoding(label: "selectionId", location: .uri("SelectionId"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String

        public init(backupPlanId: String, selectionId: String) {
            self.backupPlanId = backupPlanId
            self.selectionId = selectionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultAccessPolicyInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackupVaultNotificationsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFrameworkInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkName", location: .uri("FrameworkName"))
        ]

        /// The unique name of a framework.
        public let frameworkName: String

        public init(frameworkName: String) {
            self.frameworkName = frameworkName
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRecoveryPointInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName")),
            AWSMemberEncoding(label: "recoveryPointArn", location: .uri("RecoveryPointArn"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReportPlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "reportPlanName", location: .uri("ReportPlanName"))
        ]

        /// The unique name of a report plan.
        public let reportPlanName: String

        public init(reportPlanName: String) {
            self.reportPlanName = reportPlanName
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBackupJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupJobId", location: .uri("BackupJobId"))
        ]

        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String

        public init(backupJobId: String) {
            self.backupJobId = backupJobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBackupJobOutput: AWSDecodableShape {
        /// Returns the account ID that owns the backup job.
        public let accountId: String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String?
        /// Represents the options specified as part of backup plan or on-demand backup job.
        public let backupOptions: [String: String]?
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// Represents the actual backup type selected for a backup job. For example, if a successful Windows Volume Shadow Copy Service (VSS) backup was taken, BackupType returns "WindowsVSS". If BackupType is empty, then the backup type was a regular backup.
        public let backupType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public let bytesTransferred: Int64?
        /// The date and time that a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The date and time that a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let expectedCompletionDate: Date?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let startBy: Date?
        /// The current state of a resource recovery point.
        public let state: BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public let statusMessage: String?

        public init(accountId: String? = nil, backupJobId: String? = nil, backupOptions: [String: String]? = nil, backupSizeInBytes: Int64? = nil, backupType: String? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, bytesTransferred: Int64? = nil, completionDate: Date? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, expectedCompletionDate: Date? = nil, iamRoleArn: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, startBy: Date? = nil, state: BackupJobState? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupJobId = "BackupJobId"
            case backupOptions = "BackupOptions"
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupType = "BackupType"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case bytesTransferred = "BytesTransferred"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case expectedCompletionDate = "ExpectedCompletionDate"
            case iamRoleArn = "IamRoleArn"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case startBy = "StartBy"
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DescribeBackupVaultInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBackupVaultOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The date and time that a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// The number of recovery points that are stored in a backup vault.
        public let numberOfRecoveryPoints: Int64?

        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, encryptionKeyArn: String? = nil, numberOfRecoveryPoints: Int64? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case encryptionKeyArn = "EncryptionKeyArn"
            case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
        }
    }

    public struct DescribeCopyJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "copyJobId", location: .uri("CopyJobId"))
        ]

        /// Uniquely identifies a copy job.
        public let copyJobId: String

        public init(copyJobId: String) {
            self.copyJobId = copyJobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCopyJobOutput: AWSDecodableShape {
        /// Contains detailed information about a copy job.
        public let copyJob: CopyJob?

        public init(copyJob: CopyJob? = nil) {
            self.copyJob = copyJob
        }

        private enum CodingKeys: String, CodingKey {
            case copyJob = "CopyJob"
        }
    }

    public struct DescribeFrameworkInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkName", location: .uri("FrameworkName"))
        ]

        /// The unique name of a framework.
        public let frameworkName: String

        public init(frameworkName: String) {
            self.frameworkName = frameworkName
        }

        public func validate(name: String) throws {
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFrameworkOutput: AWSDecodableShape {
        /// The date and time that a framework is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The deployment status of a framework. The statuses are:  CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public let deploymentStatus: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
        public let frameworkControls: [FrameworkControl]?
        /// An optional description of the framework.
        public let frameworkDescription: String?
        /// The unique name of a framework.
        public let frameworkName: String?
        /// A framework consists of one or more controls. Each control governs a resource, such as backup plans, backup selections, backup vaults, or recovery points. You can also turn Config recording on or off for each resource. The statuses are:    ACTIVE when recording is turned on for all resources governed by the framework.    PARTIALLY_ACTIVE when recording is turned off for at least one resource governed by the framework.    INACTIVE when recording is turned off for all resources governed by the framework.    UNAVAILABLE when Backup is unable to validate recording status at this time.
        public let frameworkStatus: String?
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to DescribeFrameworkOutput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?

        public init(creationTime: Date? = nil, deploymentStatus: String? = nil, frameworkArn: String? = nil, frameworkControls: [FrameworkControl]? = nil, frameworkDescription: String? = nil, frameworkName: String? = nil, frameworkStatus: String? = nil, idempotencyToken: String? = nil) {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkControls = frameworkControls
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.frameworkStatus = frameworkStatus
            self.idempotencyToken = idempotencyToken
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deploymentStatus = "DeploymentStatus"
            case frameworkArn = "FrameworkArn"
            case frameworkControls = "FrameworkControls"
            case frameworkDescription = "FrameworkDescription"
            case frameworkName = "FrameworkName"
            case frameworkStatus = "FrameworkStatus"
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct DescribeGlobalSettingsInput: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeGlobalSettingsOutput: AWSDecodableShape {
        /// The status of the flag isCrossAccountBackupEnabled.
        public let globalSettings: [String: String]?
        /// The date and time that the flag isCrossAccountBackupEnabled was last updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastUpdateTime: Date?

        public init(globalSettings: [String: String]? = nil, lastUpdateTime: Date? = nil) {
            self.globalSettings = globalSettings
            self.lastUpdateTime = lastUpdateTime
        }

        private enum CodingKeys: String, CodingKey {
            case globalSettings = "GlobalSettings"
            case lastUpdateTime = "LastUpdateTime"
        }
    }

    public struct DescribeProtectedResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProtectedResourceOutput: AWSDecodableShape {
        /// The date and time that a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastBackupTime: Date?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon EBS volume or an Amazon RDS database.
        public let resourceType: String?

        public init(lastBackupTime: Date? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.lastBackupTime = lastBackupTime
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case lastBackupTime = "LastBackupTime"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
        }
    }

    public struct DescribeRecoveryPointInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName")),
            AWSMemberEncoding(label: "recoveryPointArn", location: .uri("RecoveryPointArn"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRecoveryPointOutput: AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: CalculatedLifecycle?
        /// The date and time that a job to create a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time that a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The server-side encryption key used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public let isEncrypted: Bool?
        /// The date and time that a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastRestoreTime: Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups that are transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Only Amazon EFS file system backups can be transitioned to cold storage.
        public let lifecycle: Lifecycle?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource to save as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public let resourceType: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in; for example, arn:aws:backup:us-east-1:123456789012:vault:BackupVault. If the recovery is restored to the same Amazon Web Services account or Region, this value will be null.
        public let sourceBackupVaultArn: String?
        /// A status code specifying the state of the recovery point.  PARTIAL status indicates Backup could not create the recovery point before the backup window closed. To increase your backup plan window using the API, see UpdateBackupPlan. You can also increase your backup plan window using the Console by choosing and editing your backup plan.  EXPIRED status indicates that the recovery point has exceeded its retention period, but Backup lacks permission or is otherwise unable to delete it. To manually delete these recovery points, see  Step 3: Delete the recovery points in the Clean up resources section of Getting started.
        public let status: RecoveryPointStatus?
        /// A status message explaining the reason for the recovery point deletion failure.
        public let statusMessage: String?
        /// Specifies the storage class of the recovery point. Valid values are WARM or COLD.
        public let storageClass: StorageClass?

        public init(backupSizeInBytes: Int64? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, calculatedLifecycle: CalculatedLifecycle? = nil, completionDate: Date? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, encryptionKeyArn: String? = nil, iamRoleArn: String? = nil, isEncrypted: Bool? = nil, lastRestoreTime: Date? = nil, lifecycle: Lifecycle? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, status: RecoveryPointStatus? = nil, statusMessage: String? = nil, storageClass: StorageClass? = nil) {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.storageClass = storageClass
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case calculatedLifecycle = "CalculatedLifecycle"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case iamRoleArn = "IamRoleArn"
            case isEncrypted = "IsEncrypted"
            case lastRestoreTime = "LastRestoreTime"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case storageClass = "StorageClass"
        }
    }

    public struct DescribeRegionSettingsInput: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeRegionSettingsOutput: AWSDecodableShape {
        /// Returns a list of all services along with the opt-in preferences in the Region.
        public let resourceTypeOptInPreference: [String: Bool]?

        public init(resourceTypeOptInPreference: [String: Bool]? = nil) {
            self.resourceTypeOptInPreference = resourceTypeOptInPreference
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
        }
    }

    public struct DescribeReportJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "reportJobId", location: .uri("ReportJobId"))
        ]

        /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
        public let reportJobId: String

        public init(reportJobId: String) {
            self.reportJobId = reportJobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReportJobOutput: AWSDecodableShape {
        /// A list of information about a report job, including its completion and creation times, report destination, unique report job ID, Amazon Resource Name (ARN), report template, status, and status message.
        public let reportJob: ReportJob?

        public init(reportJob: ReportJob? = nil) {
            self.reportJob = reportJob
        }

        private enum CodingKeys: String, CodingKey {
            case reportJob = "ReportJob"
        }
    }

    public struct DescribeReportPlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "reportPlanName", location: .uri("ReportPlanName"))
        ]

        /// The unique name of a report plan.
        public let reportPlanName: String

        public init(reportPlanName: String) {
            self.reportPlanName = reportPlanName
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReportPlanOutput: AWSDecodableShape {
        /// Returns details about the report plan that is specified by its name. These details include the report plan's Amazon Resource Name (ARN), description, settings, delivery channel, deployment status, creation time, and last attempted and successful run times.
        public let reportPlan: ReportPlan?

        public init(reportPlan: ReportPlan? = nil) {
            self.reportPlan = reportPlan
        }

        private enum CodingKeys: String, CodingKey {
            case reportPlan = "ReportPlan"
        }
    }

    public struct DescribeRestoreJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "restoreJobId", location: .uri("RestoreJobId"))
        ]

        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String

        public init(restoreJobId: String) {
            self.restoreJobId = restoreJobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRestoreJobOutput: AWSDecodableShape {
        /// Returns the account ID that owns the restore job.
        public let accountId: String?
        /// The size, in bytes, of the restored resource.
        public let backupSizeInBytes: Int64?
        /// The date and time that a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource whose recovery point is being restored. The format of the ARN depends on the resource type of the backed-up resource.
        public let createdResourceArn: String?
        /// The date and time that a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public let expectedCompletionTimeMinutes: Int64?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// Returns metadata associated with a restore job listed by resource type.
        public let resourceType: String?
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String?
        /// Status code specifying the state of the job that is initiated by Backup to restore a recovery point.
        public let status: RestoreJobStatus?
        /// A message showing the status of a job to restore a recovery point.
        public let statusMessage: String?

        public init(accountId: String? = nil, backupSizeInBytes: Int64? = nil, completionDate: Date? = nil, createdResourceArn: String? = nil, creationDate: Date? = nil, expectedCompletionTimeMinutes: Int64? = nil, iamRoleArn: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, resourceType: String? = nil, restoreJobId: String? = nil, status: RestoreJobStatus? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupSizeInBytes = "BackupSizeInBytes"
            case completionDate = "CompletionDate"
            case createdResourceArn = "CreatedResourceArn"
            case creationDate = "CreationDate"
            case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
            case iamRoleArn = "IamRoleArn"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceType = "ResourceType"
            case restoreJobId = "RestoreJobId"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DisassociateRecoveryPointInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName")),
            AWSMemberEncoding(label: "recoveryPointArn", location: .uri("RecoveryPointArn"))
        ]

        /// The unique name of an Backup vault.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery point.
        public let recoveryPointArn: String

        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportBackupPlanTemplateInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String

        public init(backupPlanId: String) {
            self.backupPlanId = backupPlanId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportBackupPlanTemplateOutput: AWSDecodableShape {
        /// The body of a backup plan template in JSON format.  This is a signed JSON document that cannot be modified before being passed to GetBackupPlanFromJSON.
        public let backupPlanTemplateJson: String?

        public init(backupPlanTemplateJson: String? = nil) {
            self.backupPlanTemplateJson = backupPlanTemplateJson
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplateJson = "BackupPlanTemplateJson"
        }
    }

    public struct Framework: AWSDecodableShape {
        /// The date and time that a framework is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The deployment status of a framework. The statuses are:  CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public let deploymentStatus: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// An optional description of the framework with a maximum 1,024 characters.
        public let frameworkDescription: String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String?
        /// The number of controls contained by the framework.
        public let numberOfControls: Int?

        public init(creationTime: Date? = nil, deploymentStatus: String? = nil, frameworkArn: String? = nil, frameworkDescription: String? = nil, frameworkName: String? = nil, numberOfControls: Int? = nil) {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.numberOfControls = numberOfControls
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deploymentStatus = "DeploymentStatus"
            case frameworkArn = "FrameworkArn"
            case frameworkDescription = "FrameworkDescription"
            case frameworkName = "FrameworkName"
            case numberOfControls = "NumberOfControls"
        }
    }

    public struct FrameworkControl: AWSEncodableShape & AWSDecodableShape {
        /// A list of ParameterName and ParameterValue pairs.
        public let controlInputParameters: [ControlInputParameter]?
        /// The name of a control. This name is between 1 and 256 characters.
        public let controlName: String
        /// The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. For more information, see ControlScope.
        public let controlScope: ControlScope?

        public init(controlInputParameters: [ControlInputParameter]? = nil, controlName: String, controlScope: ControlScope? = nil) {
            self.controlInputParameters = controlInputParameters
            self.controlName = controlName
            self.controlScope = controlScope
        }

        public func validate(name: String) throws {
            try self.controlScope?.validate(name: "\(name).controlScope")
        }

        private enum CodingKeys: String, CodingKey {
            case controlInputParameters = "ControlInputParameters"
            case controlName = "ControlName"
            case controlScope = "ControlScope"
        }
    }

    public struct GetBackupPlanFromJSONInput: AWSEncodableShape {
        /// A customer-supplied backup plan document in JSON format.
        public let backupPlanTemplateJson: String

        public init(backupPlanTemplateJson: String) {
            self.backupPlanTemplateJson = backupPlanTemplateJson
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplateJson = "BackupPlanTemplateJson"
        }
    }

    public struct GetBackupPlanFromJSONOutput: AWSDecodableShape {
        /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlan?

        public init(backupPlan: BackupPlan? = nil) {
            self.backupPlan = backupPlan
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
        }
    }

    public struct GetBackupPlanFromTemplateInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanTemplateId", location: .uri("BackupPlanTemplateId"))
        ]

        /// Uniquely identifies a stored backup plan template.
        public let backupPlanTemplateId: String

        public init(backupPlanTemplateId: String) {
            self.backupPlanTemplateId = backupPlanTemplateId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupPlanFromTemplateOutput: AWSDecodableShape {
        /// Returns the body of a backup plan based on the target template, including the name, rules, and backup vault of the plan.
        public let backupPlanDocument: BackupPlan?

        public init(backupPlanDocument: BackupPlan? = nil) {
            self.backupPlanDocument = backupPlanDocument
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanDocument = "BackupPlanDocument"
        }
    }

    public struct GetBackupPlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId")),
            AWSMemberEncoding(label: "versionId", location: .querystring("versionId"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        public init(backupPlanId: String, versionId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.versionId = versionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupPlanOutput: AWSDecodableShape {
        /// Contains a list of BackupOptions for each resource type. The list is populated only if the advanced option is set for the backup plan.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlan?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// The date and time that a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let deletionDate: Date?
        /// The last time a job to back up resources was run with this backup plan. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastExecutionDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public let versionId: String?

        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlan: BackupPlan? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, deletionDate: Date? = nil, lastExecutionDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlan = backupPlan
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlan = "BackupPlan"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case deletionDate = "DeletionDate"
            case lastExecutionDate = "LastExecutionDate"
            case versionId = "VersionId"
        }
    }

    public struct GetBackupSelectionInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId")),
            AWSMemberEncoding(label: "selectionId", location: .uri("SelectionId"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String

        public init(backupPlanId: String, selectionId: String) {
            self.backupPlanId = backupPlanId
            self.selectionId = selectionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupSelectionOutput: AWSDecodableShape {
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// Specifies the body of a request to assign a set of resources to a backup plan.
        public let backupSelection: BackupSelection?
        /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public let creatorRequestId: String?
        /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
        public let selectionId: String?

        public init(backupPlanId: String? = nil, backupSelection: BackupSelection? = nil, creationDate: Date? = nil, creatorRequestId: String? = nil, selectionId: String? = nil) {
            self.backupPlanId = backupPlanId
            self.backupSelection = backupSelection
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.selectionId = selectionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanId = "BackupPlanId"
            case backupSelection = "BackupSelection"
            case creationDate = "CreationDate"
            case creatorRequestId = "CreatorRequestId"
            case selectionId = "SelectionId"
        }
    }

    public struct GetBackupVaultAccessPolicyInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupVaultAccessPolicyOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The backup vault access policy document in JSON format.
        public let policy: String?

        public init(backupVaultArn: String? = nil, backupVaultName: String? = nil, policy: String? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case policy = "Policy"
        }
    }

    public struct GetBackupVaultNotificationsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String

        public init(backupVaultName: String) {
            self.backupVaultName = backupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackupVaultNotificationsOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// An array of events that indicate the status of jobs to back up resources to the backup vault.
        public let backupVaultEvents: [BackupVaultEvent]?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
        public let sNSTopicArn: String?

        public init(backupVaultArn: String? = nil, backupVaultEvents: [BackupVaultEvent]? = nil, backupVaultName: String? = nil, sNSTopicArn: String? = nil) {
            self.backupVaultArn = backupVaultArn
            self.backupVaultEvents = backupVaultEvents
            self.backupVaultName = backupVaultName
            self.sNSTopicArn = sNSTopicArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case backupVaultEvents = "BackupVaultEvents"
            case backupVaultName = "BackupVaultName"
            case sNSTopicArn = "SNSTopicArn"
        }
    }

    public struct GetRecoveryPointRestoreMetadataInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName")),
            AWSMemberEncoding(label: "recoveryPointArn", location: .uri("RecoveryPointArn"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        public init(backupVaultName: String, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.recoveryPointArn = recoveryPointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecoveryPointRestoreMetadataOutput: AWSDecodableShape {
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// The set of metadata key-value pairs that describe the original configuration of the backed-up resource. These values vary depending on the service that is being restored.
        public let restoreMetadata: [String: String]?

        public init(backupVaultArn: String? = nil, recoveryPointArn: String? = nil, restoreMetadata: [String: String]? = nil) {
            self.backupVaultArn = backupVaultArn
            self.recoveryPointArn = recoveryPointArn
            self.restoreMetadata = restoreMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case recoveryPointArn = "RecoveryPointArn"
            case restoreMetadata = "RestoreMetadata"
        }
    }

    public struct GetSupportedResourceTypesOutput: AWSDecodableShape {
        /// Contains a string with the supported Amazon Web Services resource types:    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    RDS for Amazon Relational Database Service    Aurora for Amazon Aurora    Storage Gateway for Storage Gateway
        public let resourceTypes: [String]?

        public init(resourceTypes: [String]? = nil) {
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct Lifecycle: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAfterDays: Int64?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAfterDays: Int64?

        public init(deleteAfterDays: Int64? = nil, moveToColdStorageAfterDays: Int64? = nil) {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAfterDays = "DeleteAfterDays"
            case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
        }
    }

    public struct ListBackupJobsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "byAccountId", location: .querystring("accountId")),
            AWSMemberEncoding(label: "byBackupVaultName", location: .querystring("backupVaultName")),
            AWSMemberEncoding(label: "byCreatedAfter", location: .querystring("createdAfter")),
            AWSMemberEncoding(label: "byCreatedBefore", location: .querystring("createdBefore")),
            AWSMemberEncoding(label: "byResourceArn", location: .querystring("resourceArn")),
            AWSMemberEncoding(label: "byResourceType", location: .querystring("resourceType")),
            AWSMemberEncoding(label: "byState", location: .querystring("state")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The account ID to list the jobs from. Returns only backup jobs associated with the specified account ID. If used from an Organizations management account, passing * returns all jobs across the organization.
        public let byAccountId: String?
        /// Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let byBackupVaultName: String?
        /// Returns only backup jobs that were created after the specified date.
        public let byCreatedAfter: Date?
        /// Returns only backup jobs that were created before the specified date.
        public let byCreatedBefore: Date?
        /// Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).
        public let byResourceArn: String?
        /// Returns only backup jobs for the specified resources:    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    RDS for Amazon Relational Database Service    Aurora for Amazon Aurora    Storage Gateway for Storage Gateway
        public let byResourceType: String?
        /// Returns only backup jobs that are in the specified state.
        public let byState: BackupJobState?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(byAccountId: String? = nil, byBackupVaultName: String? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byResourceArn: String? = nil, byResourceType: String? = nil, byState: BackupJobState? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byAccountId = byAccountId
            self.byBackupVaultName = byBackupVaultName
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byResourceArn = byResourceArn
            self.byResourceType = byResourceType
            self.byState = byState
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.byAccountId, name: "byAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.byBackupVaultName, name: "byBackupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupJobsOutput: AWSDecodableShape {
        /// An array of structures containing metadata about your backup jobs returned in JSON format.
        public let backupJobs: [BackupJob]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupJobs: [BackupJob]? = nil, nextToken: String? = nil) {
            self.backupJobs = backupJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupJobs = "BackupJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupPlanTemplatesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupPlanTemplatesOutput: AWSDecodableShape {
        /// An array of template list items containing metadata about your saved templates.
        public let backupPlanTemplatesList: [BackupPlanTemplatesListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupPlanTemplatesList: [BackupPlanTemplatesListMember]? = nil, nextToken: String? = nil) {
            self.backupPlanTemplatesList = backupPlanTemplatesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanTemplatesList = "BackupPlanTemplatesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupPlanVersionsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupPlanId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupPlanId = backupPlanId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupPlanVersionsOutput: AWSDecodableShape {
        /// An array of version list items containing metadata about your backup plans.
        public let backupPlanVersionsList: [BackupPlansListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupPlanVersionsList: [BackupPlansListMember]? = nil, nextToken: String? = nil) {
            self.backupPlanVersionsList = backupPlanVersionsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanVersionsList = "BackupPlanVersionsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupPlansInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "includeDeleted", location: .querystring("includeDeleted")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A Boolean value with a default value of FALSE that returns deleted backup plans when set to TRUE.
        public let includeDeleted: Bool?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(includeDeleted: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeDeleted = includeDeleted
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupPlansOutput: AWSDecodableShape {
        /// An array of backup plan list items containing metadata about your saved backup plans.
        public let backupPlansList: [BackupPlansListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupPlansList: [BackupPlansListMember]? = nil, nextToken: String? = nil) {
            self.backupPlansList = backupPlansList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlansList = "BackupPlansList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupSelectionsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Uniquely identifies a backup plan.
        public let backupPlanId: String
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupPlanId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupPlanId = backupPlanId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupSelectionsOutput: AWSDecodableShape {
        /// An array of backup selection list items containing metadata about each resource in the list.
        public let backupSelectionsList: [BackupSelectionsListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupSelectionsList: [BackupSelectionsListMember]? = nil, nextToken: String? = nil) {
            self.backupSelectionsList = backupSelectionsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupSelectionsList = "BackupSelectionsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBackupVaultsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackupVaultsOutput: AWSDecodableShape {
        /// An array of backup vault list members containing vault metadata, including Amazon Resource Name (ARN), display name, creation date, number of saved recovery points, and encryption information if the resources saved in the backup vault are encrypted.
        public let backupVaultList: [BackupVaultListMember]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupVaultList: [BackupVaultListMember]? = nil, nextToken: String? = nil) {
            self.backupVaultList = backupVaultList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultList = "BackupVaultList"
            case nextToken = "NextToken"
        }
    }

    public struct ListCopyJobsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "byAccountId", location: .querystring("accountId")),
            AWSMemberEncoding(label: "byCreatedAfter", location: .querystring("createdAfter")),
            AWSMemberEncoding(label: "byCreatedBefore", location: .querystring("createdBefore")),
            AWSMemberEncoding(label: "byDestinationVaultArn", location: .querystring("destinationVaultArn")),
            AWSMemberEncoding(label: "byResourceArn", location: .querystring("resourceArn")),
            AWSMemberEncoding(label: "byResourceType", location: .querystring("resourceType")),
            AWSMemberEncoding(label: "byState", location: .querystring("state")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The account ID to list the jobs from. Returns only copy jobs associated with the specified account ID.
        public let byAccountId: String?
        /// Returns only copy jobs that were created after the specified date.
        public let byCreatedAfter: Date?
        /// Returns only copy jobs that were created before the specified date.
        public let byCreatedBefore: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let byDestinationVaultArn: String?
        /// Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
        public let byResourceArn: String?
        /// Returns only backup jobs for the specified resources:    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    RDS for Amazon Relational Database Service    Aurora for Amazon Aurora    Storage Gateway for Storage Gateway
        public let byResourceType: String?
        /// Returns only copy jobs that are in the specified state.
        public let byState: CopyJobState?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(byAccountId: String? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byDestinationVaultArn: String? = nil, byResourceArn: String? = nil, byResourceType: String? = nil, byState: CopyJobState? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byAccountId = byAccountId
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byDestinationVaultArn = byDestinationVaultArn
            self.byResourceArn = byResourceArn
            self.byResourceType = byResourceType
            self.byState = byState
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.byAccountId, name: "byAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCopyJobsOutput: AWSDecodableShape {
        /// An array of structures containing metadata about your copy jobs returned in JSON format.
        public let copyJobs: [CopyJob]?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(copyJobs: [CopyJob]? = nil, nextToken: String? = nil) {
            self.copyJobs = copyJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case copyJobs = "CopyJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListFrameworksInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFrameworksOutput: AWSDecodableShape {
        /// A list of frameworks with details for each framework, including the framework name, Amazon Resource Name (ARN), description, number of controls, creation time, and deployment status.
        public let frameworks: [Framework]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(frameworks: [Framework]? = nil, nextToken: String? = nil) {
            self.frameworks = frameworks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case frameworks = "Frameworks"
            case nextToken = "NextToken"
        }
    }

    public struct ListProtectedResourcesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedResourcesOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of resources successfully backed up by Backup including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
        public let results: [ProtectedResource]?

        public init(nextToken: String? = nil, results: [ProtectedResource]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListRecoveryPointsByBackupVaultInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName")),
            AWSMemberEncoding(label: "byBackupPlanId", location: .querystring("backupPlanId")),
            AWSMemberEncoding(label: "byCreatedAfter", location: .querystring("createdAfter")),
            AWSMemberEncoding(label: "byCreatedBefore", location: .querystring("createdBefore")),
            AWSMemberEncoding(label: "byResourceArn", location: .querystring("resourceArn")),
            AWSMemberEncoding(label: "byResourceType", location: .querystring("resourceType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.  Backup vault name might not be available when a supported service creates the backup.
        public let backupVaultName: String
        /// Returns only recovery points that match the specified backup plan ID.
        public let byBackupPlanId: String?
        /// Returns only recovery points that were created after the specified timestamp.
        public let byCreatedAfter: Date?
        /// Returns only recovery points that were created before the specified timestamp.
        public let byCreatedBefore: Date?
        /// Returns only recovery points that match the specified resource Amazon Resource Name (ARN).
        public let byResourceArn: String?
        /// Returns only recovery points that match the specified resource type.
        public let byResourceType: String?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(backupVaultName: String, byBackupPlanId: String? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byResourceArn: String? = nil, byResourceType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.backupVaultName = backupVaultName
            self.byBackupPlanId = byBackupPlanId
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byResourceArn = byResourceArn
            self.byResourceType = byResourceType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
            try self.validate(self.byResourceType, name: "byResourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecoveryPointsByBackupVaultOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of objects that contain detailed information about recovery points saved in a backup vault.
        public let recoveryPoints: [RecoveryPointByBackupVault]?

        public init(nextToken: String? = nil, recoveryPoints: [RecoveryPointByBackupVault]? = nil) {
            self.nextToken = nextToken
            self.recoveryPoints = recoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recoveryPoints = "RecoveryPoints"
        }
    }

    public struct ListRecoveryPointsByResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The maximum number of items to be returned.  Amazon RDS requires a value of at least 20.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecoveryPointsByResourceOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of objects that contain detailed information about recovery points of the specified resource type.  Only Amazon EFS and Amazon EC2 recovery points return BackupVaultName.
        public let recoveryPoints: [RecoveryPointByResource]?

        public init(nextToken: String? = nil, recoveryPoints: [RecoveryPointByResource]? = nil) {
            self.nextToken = nextToken
            self.recoveryPoints = recoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recoveryPoints = "RecoveryPoints"
        }
    }

    public struct ListReportJobsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "byCreationAfter", location: .querystring("CreationAfter")),
            AWSMemberEncoding(label: "byCreationBefore", location: .querystring("CreationBefore")),
            AWSMemberEncoding(label: "byReportPlanName", location: .querystring("ReportPlanName")),
            AWSMemberEncoding(label: "byStatus", location: .querystring("Status")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// Returns only report jobs that were created after the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
        public let byCreationAfter: Date?
        /// Returns only report jobs that were created before the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
        public let byCreationBefore: Date?
        /// Returns only report jobs with the specified report plan name.
        public let byReportPlanName: String?
        /// Returns only report jobs that are in the specified status. The statuses are:  CREATED | RUNNING | COMPLETED | FAILED
        public let byStatus: String?
        /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(byCreationAfter: Date? = nil, byCreationBefore: Date? = nil, byReportPlanName: String? = nil, byStatus: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byCreationAfter = byCreationAfter
            self.byCreationBefore = byCreationBefore
            self.byReportPlanName = byReportPlanName
            self.byStatus = byStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.byReportPlanName, name: "byReportPlanName", parent: name, max: 256)
            try self.validate(self.byReportPlanName, name: "byReportPlanName", parent: name, min: 1)
            try self.validate(self.byReportPlanName, name: "byReportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReportJobsOutput: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// Details about your report jobs in JSON format.
        public let reportJobs: [ReportJob]?

        public init(nextToken: String? = nil, reportJobs: [ReportJob]? = nil) {
            self.nextToken = nextToken
            self.reportJobs = reportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reportJobs = "ReportJobs"
        }
    }

    public struct ListReportPlansInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReportPlansOutput: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A list of your report plans with detailed information for each plan. This information includes the Amazon Resource Name (ARN), report plan name, description, settings, delivery channel, deployment status, creation time, and last times the report plan attempted to and successfully ran.
        public let reportPlans: [ReportPlan]?

        public init(nextToken: String? = nil, reportPlans: [ReportPlan]? = nil) {
            self.nextToken = nextToken
            self.reportPlans = reportPlans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reportPlans = "ReportPlans"
        }
    }

    public struct ListRestoreJobsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "byAccountId", location: .querystring("accountId")),
            AWSMemberEncoding(label: "byCreatedAfter", location: .querystring("createdAfter")),
            AWSMemberEncoding(label: "byCreatedBefore", location: .querystring("createdBefore")),
            AWSMemberEncoding(label: "byStatus", location: .querystring("status")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The account ID to list the jobs from. Returns only restore jobs associated with the specified account ID.
        public let byAccountId: String?
        /// Returns only restore jobs that were created after the specified date.
        public let byCreatedAfter: Date?
        /// Returns only restore jobs that were created before the specified date.
        public let byCreatedBefore: Date?
        /// Returns only restore jobs associated with the specified job status.
        public let byStatus: RestoreJobStatus?
        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        public init(byAccountId: String? = nil, byCreatedAfter: Date? = nil, byCreatedBefore: Date? = nil, byStatus: RestoreJobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byAccountId = byAccountId
            self.byCreatedAfter = byCreatedAfter
            self.byCreatedBefore = byCreatedBefore
            self.byStatus = byStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.byAccountId, name: "byAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRestoreJobsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An array of objects that contain detailed information about jobs to restore saved resources.
        public let restoreJobs: [RestoreJobsListMember]?

        public init(nextToken: String? = nil, restoreJobs: [RestoreJobsListMember]? = nil) {
            self.nextToken = nextToken
            self.restoreJobs = restoreJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case restoreJobs = "RestoreJobs"
        }
    }

    public struct ListTagsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The maximum number of items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for ListTags are recovery points, backup plans, and backup vaults.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// To help organize your resources, you can assign your own metadata to the resources you create. Each tag is a key-value pair.
        public let tags: [String: String]?

        public init(nextToken: String? = nil, tags: [String: String]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ProtectedResource: AWSDecodableShape {
        /// The date and time a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastBackupTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?

        public init(lastBackupTime: Date? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.lastBackupTime = lastBackupTime
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case lastBackupTime = "LastBackupTime"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
        }
    }

    public struct PutBackupVaultAccessPolicyInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// The backup vault access policy document in JSON format.
        public let policy: String?

        public init(backupVaultName: String, policy: String? = nil) {
            self.backupVaultName = backupVaultName
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutBackupVaultNotificationsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName"))
        ]

        /// An array of events that indicate the status of jobs to back up resources to the backup vault.  The following events are supported:  BACKUP_JOB_STARTED, BACKUP_JOB_COMPLETED,  COPY_JOB_STARTED, COPY_JOB_SUCCESSFUL, COPY_JOB_FAILED,  RESTORE_JOB_STARTED, RESTORE_JOB_COMPLETED, and RECOVERY_POINT_MODIFIED. To find failed backup jobs, use BACKUP_JOB_COMPLETED and filter using event metadata. Other events in the following list are deprecated.
        public let backupVaultEvents: [BackupVaultEvent]
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
        public let sNSTopicArn: String

        public init(backupVaultEvents: [BackupVaultEvent], backupVaultName: String, sNSTopicArn: String) {
            self.backupVaultEvents = backupVaultEvents
            self.backupVaultName = backupVaultName
            self.sNSTopicArn = sNSTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultEvents = "BackupVaultEvents"
            case sNSTopicArn = "SNSTopicArn"
        }
    }

    public struct RecoveryPointByBackupVault: AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: CalculatedLifecycle?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public let createdBy: RecoveryPointCreator?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public let isEncrypted: Bool?
        /// The date and time a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastRestoreTime: Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Only Amazon EFS file system backups can be transitioned to cold storage.
        public let lifecycle: Lifecycle?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?
        /// The backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account this value will be null.
        public let sourceBackupVaultArn: String?
        /// A status code specifying the state of the recovery point.
        public let status: RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public let statusMessage: String?

        public init(backupSizeInBytes: Int64? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, calculatedLifecycle: CalculatedLifecycle? = nil, completionDate: Date? = nil, createdBy: RecoveryPointCreator? = nil, creationDate: Date? = nil, encryptionKeyArn: String? = nil, iamRoleArn: String? = nil, isEncrypted: Bool? = nil, lastRestoreTime: Date? = nil, lifecycle: Lifecycle? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, status: RecoveryPointStatus? = nil, statusMessage: String? = nil) {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case calculatedLifecycle = "CalculatedLifecycle"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case iamRoleArn = "IamRoleArn"
            case isEncrypted = "IsEncrypted"
            case lastRestoreTime = "LastRestoreTime"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct RecoveryPointByResource: AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeBytes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// A status code specifying the state of the recovery point.
        public let status: RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public let statusMessage: String?

        public init(backupSizeBytes: Int64? = nil, backupVaultName: String? = nil, creationDate: Date? = nil, encryptionKeyArn: String? = nil, recoveryPointArn: String? = nil, status: RecoveryPointStatus? = nil, statusMessage: String? = nil) {
            self.backupSizeBytes = backupSizeBytes
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.recoveryPointArn = recoveryPointArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeBytes = "BackupSizeBytes"
            case backupVaultName = "BackupVaultName"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case recoveryPointArn = "RecoveryPointArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct RecoveryPointCreator: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public let backupPlanVersion: String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public let backupRuleId: String?

        public init(backupPlanArn: String? = nil, backupPlanId: String? = nil, backupPlanVersion: String? = nil, backupRuleId: String? = nil) {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case backupPlanVersion = "BackupPlanVersion"
            case backupRuleId = "BackupRuleId"
        }
    }

    public struct ReportDeliveryChannel: AWSEncodableShape & AWSDecodableShape {
        /// A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
        public let formats: [String]?
        /// The unique name of the S3 bucket that receives your reports.
        public let s3BucketName: String
        /// The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
        public let s3KeyPrefix: String?

        public init(formats: [String]? = nil, s3BucketName: String, s3KeyPrefix: String? = nil) {
            self.formats = formats
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case formats = "Formats"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct ReportDestination: AWSDecodableShape {
        /// The unique name of the Amazon S3 bucket that receives your reports.
        public let s3BucketName: String?
        /// The object key that uniquely identifies your reports in your S3 bucket.
        public let s3Keys: [String]?

        public init(s3BucketName: String? = nil, s3Keys: [String]? = nil) {
            self.s3BucketName = s3BucketName
            self.s3Keys = s3Keys
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case s3Keys = "S3Keys"
        }
    }

    public struct ReportJob: AWSDecodableShape {
        /// The date and time that a report job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionTime: Date?
        /// The date and time that a report job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The S3 bucket name and S3 keys for the destination where the report job publishes the report.
        public let reportDestination: ReportDestination?
        /// The identifier for a report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. Report job IDs cannot be edited.
        public let reportJobId: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:   BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportTemplate: String?
        /// The status of a report job. The statuses are:  CREATED | RUNNING | COMPLETED | FAILED   COMPLETED means that the report is available for your review at your designated destination. If the status is FAILED, review the StatusMessage for the reason.
        public let status: String?
        /// A message explaining the status of the report job.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, creationTime: Date? = nil, reportDestination: ReportDestination? = nil, reportJobId: String? = nil, reportPlanArn: String? = nil, reportTemplate: String? = nil, status: String? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.reportDestination = reportDestination
            self.reportJobId = reportJobId
            self.reportPlanArn = reportPlanArn
            self.reportTemplate = reportTemplate
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case reportDestination = "ReportDestination"
            case reportJobId = "ReportJobId"
            case reportPlanArn = "ReportPlanArn"
            case reportTemplate = "ReportTemplate"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ReportPlan: AWSDecodableShape {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The deployment status of a report plan. The statuses are:  CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED
        public let deploymentStatus: String?
        /// The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC). The value of LastAttemptedExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastAttemptedExecutionTime: Date?
        /// The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC). The value of LastSuccessfulExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let lastSuccessfulExecutionTime: Date?
        /// Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public let reportDeliveryChannel: ReportDeliveryChannel?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public let reportPlanDescription: String?
        /// The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let reportPlanName: String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportSetting: ReportSetting?

        public init(creationTime: Date? = nil, deploymentStatus: String? = nil, lastAttemptedExecutionTime: Date? = nil, lastSuccessfulExecutionTime: Date? = nil, reportDeliveryChannel: ReportDeliveryChannel? = nil, reportPlanArn: String? = nil, reportPlanDescription: String? = nil, reportPlanName: String? = nil, reportSetting: ReportSetting? = nil) {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.lastAttemptedExecutionTime = lastAttemptedExecutionTime
            self.lastSuccessfulExecutionTime = lastSuccessfulExecutionTime
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanArn = reportPlanArn
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case deploymentStatus = "DeploymentStatus"
            case lastAttemptedExecutionTime = "LastAttemptedExecutionTime"
            case lastSuccessfulExecutionTime = "LastSuccessfulExecutionTime"
            case reportDeliveryChannel = "ReportDeliveryChannel"
            case reportPlanArn = "ReportPlanArn"
            case reportPlanDescription = "ReportPlanDescription"
            case reportPlanName = "ReportPlanName"
            case reportSetting = "ReportSetting"
        }
    }

    public struct ReportSetting: AWSEncodableShape & AWSDecodableShape {
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportTemplate: String

        public init(reportTemplate: String) {
            self.reportTemplate = reportTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case reportTemplate = "ReportTemplate"
        }
    }

    public struct RestoreJobsListMember: AWSDecodableShape {
        /// The account ID that owns the restore job.
        public let accountId: String?
        /// The size, in bytes, of the restored resource.
        public let backupSizeInBytes: Int64?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let createdResourceArn: String?
        /// The date and time a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public let expectedCompletionTimeMinutes: Int64?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public let percentDone: String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?
        /// The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public let resourceType: String?
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String?
        /// A status code specifying the state of the job initiated by Backup to restore a recovery point.
        public let status: RestoreJobStatus?
        /// A detailed message explaining the status of the job to restore a recovery point.
        public let statusMessage: String?

        public init(accountId: String? = nil, backupSizeInBytes: Int64? = nil, completionDate: Date? = nil, createdResourceArn: String? = nil, creationDate: Date? = nil, expectedCompletionTimeMinutes: Int64? = nil, iamRoleArn: String? = nil, percentDone: String? = nil, recoveryPointArn: String? = nil, resourceType: String? = nil, restoreJobId: String? = nil, status: RestoreJobStatus? = nil, statusMessage: String? = nil) {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case backupSizeInBytes = "BackupSizeInBytes"
            case completionDate = "CompletionDate"
            case createdResourceArn = "CreatedResourceArn"
            case creationDate = "CreationDate"
            case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
            case iamRoleArn = "IamRoleArn"
            case percentDone = "PercentDone"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceType = "ResourceType"
            case restoreJobId = "RestoreJobId"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct StartBackupJobInput: AWSEncodableShape {
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS""disabled" to create a regular backup. The WindowsVSS option is not enabled by default.
        public let backupOptions: [String: String]?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// A value in minutes during which a successfully started backup must complete, or else AWS Backup will cancel the job. This value is optional. This value begins counting down from when the backup was scheduled. It does not add additional time for StartWindowMinutes, or if the backup started later than scheduled.
        public let completeWindowMinutes: Int64?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartBackupJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Only Amazon EFS file system backups can be transitioned to cold storage.
        public let lifecycle: Lifecycle?
        /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
        public let recoveryPointTags: [String: String]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional, and the default is 8 hours.
        public let startWindowMinutes: Int64?

        public init(backupOptions: [String: String]? = nil, backupVaultName: String, completeWindowMinutes: Int64? = nil, iamRoleArn: String, idempotencyToken: String? = nil, lifecycle: Lifecycle? = nil, recoveryPointTags: [String: String]? = nil, resourceArn: String, startWindowMinutes: Int64? = nil) {
            self.backupOptions = backupOptions
            self.backupVaultName = backupVaultName
            self.completeWindowMinutes = completeWindowMinutes
            self.iamRoleArn = iamRoleArn
            self.idempotencyToken = idempotencyToken
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.resourceArn = resourceArn
            self.startWindowMinutes = startWindowMinutes
        }

        public func validate(name: String) throws {
            try self.backupOptions?.forEach {
                try validate($0.key, name: "backupOptions.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
                try validate($0.value, name: "backupOptions[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backupOptions = "BackupOptions"
            case backupVaultName = "BackupVaultName"
            case completeWindowMinutes = "CompleteWindowMinutes"
            case iamRoleArn = "IamRoleArn"
            case idempotencyToken = "IdempotencyToken"
            case lifecycle = "Lifecycle"
            case recoveryPointTags = "RecoveryPointTags"
            case resourceArn = "ResourceArn"
            case startWindowMinutes = "StartWindowMinutes"
        }
    }

    public struct StartBackupJobOutput: AWSDecodableShape {
        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String?
        /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?

        public init(backupJobId: String? = nil, creationDate: Date? = nil, recoveryPointArn: String? = nil) {
            self.backupJobId = backupJobId
            self.creationDate = creationDate
            self.recoveryPointArn = recoveryPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupJobId = "BackupJobId"
            case creationDate = "CreationDate"
            case recoveryPointArn = "RecoveryPointArn"
        }
    }

    public struct StartCopyJobInput: AWSEncodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let destinationBackupVaultArn: String
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartCopyJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        public let lifecycle: Lifecycle?
        /// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String
        /// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let sourceBackupVaultName: String

        public init(destinationBackupVaultArn: String, iamRoleArn: String, idempotencyToken: String? = nil, lifecycle: Lifecycle? = nil, recoveryPointArn: String, sourceBackupVaultName: String) {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.iamRoleArn = iamRoleArn
            self.idempotencyToken = idempotencyToken
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.sourceBackupVaultName = sourceBackupVaultName
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceBackupVaultName, name: "sourceBackupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case iamRoleArn = "IamRoleArn"
            case idempotencyToken = "IdempotencyToken"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
            case sourceBackupVaultName = "SourceBackupVaultName"
        }
    }

    public struct StartCopyJobOutput: AWSDecodableShape {
        /// Uniquely identifies a copy job.
        public let copyJobId: String?
        /// The date and time that a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?

        public init(copyJobId: String? = nil, creationDate: Date? = nil) {
            self.copyJobId = copyJobId
            self.creationDate = creationDate
        }

        private enum CodingKeys: String, CodingKey {
            case copyJobId = "CopyJobId"
            case creationDate = "CreationDate"
        }
    }

    public struct StartReportJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "reportPlanName", location: .uri("ReportPlanName"))
        ]

        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartReportJobInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// The unique name of a report plan.
        public let reportPlanName: String

        public init(idempotencyToken: String? = StartReportJobInput.idempotencyToken(), reportPlanName: String) {
            self.idempotencyToken = idempotencyToken
            self.reportPlanName = reportPlanName
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct StartReportJobOutput: AWSDecodableShape {
        /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
        public let reportJobId: String?

        public init(reportJobId: String? = nil) {
            self.reportJobId = reportJobId
        }

        private enum CodingKeys: String, CodingKey {
            case reportJobId = "ReportJobId"
        }
    }

    public struct StartRestoreJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public let iamRoleArn: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartRestoreJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// A set of metadata key-value pairs. Contains information, such as a resource name, required to restore a recovery point. You can get configuration metadata about a resource at the time it was backed up by calling GetRecoveryPointRestoreMetadata. However, values in addition to those provided by GetRecoveryPointRestoreMetadata might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists. You need to specify specific metadata to restore an Amazon Elastic File System (Amazon EFS) instance:    file-system-id: The ID of the Amazon EFS file system that is backed up by Backup. Returned in GetRecoveryPointRestoreMetadata.    Encrypted: A Boolean value that, if true, specifies that the file system is encrypted. If KmsKeyId is specified, Encrypted must be set to true.    KmsKeyId: Specifies the Amazon Web Services KMS key that is used to encrypt the restored file system. You can specify a key from another Amazon Web Services account provided that key it is properly shared with your account via Amazon Web Services KMS.    PerformanceMode: Specifies the throughput mode of the file system.    CreationToken: A user-supplied value that ensures the uniqueness (idempotency) of the request.    newFileSystem: A Boolean value that, if true, specifies that the recovery point is restored to a new Amazon EFS file system.    ItemsToRestore: An array of one to five strings where each string is a file path. Use ItemsToRestore to restore specific files or directories rather than the entire file system. This parameter is optional. For example, "itemsToRestore":"[\"/my.test\"]".
        public let metadata: [String: String]
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String
        /// Starts a job to restore a recovery point for one of the following resources:    DynamoDB for Amazon DynamoDB    EBS for Amazon Elastic Block Store    EC2 for Amazon Elastic Compute Cloud    EFS for Amazon Elastic File System    RDS for Amazon Relational Database Service    Aurora for Amazon Aurora    Storage Gateway for Storage Gateway
        public let resourceType: String?

        public init(iamRoleArn: String, idempotencyToken: String? = nil, metadata: [String: String], recoveryPointArn: String, resourceType: String? = nil) {
            self.iamRoleArn = iamRoleArn
            self.idempotencyToken = idempotencyToken
            self.metadata = metadata
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case idempotencyToken = "IdempotencyToken"
            case metadata = "Metadata"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceType = "ResourceType"
        }
    }

    public struct StartRestoreJobOutput: AWSDecodableShape {
        /// Uniquely identifies the job that restores a recovery point.
        public let restoreJobId: String?

        public init(restoreJobId: String? = nil) {
            self.restoreJobId = restoreJobId
        }

        private enum CodingKeys: String, CodingKey {
            case restoreJobId = "RestoreJobId"
        }
    }

    public struct StopBackupJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupJobId", location: .uri("BackupJobId"))
        ]

        /// Uniquely identifies a request to Backup to back up a resource.
        public let backupJobId: String

        public init(backupJobId: String) {
            self.backupJobId = backupJobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct TagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
        public let resourceArn: String
        /// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
        public let resourceArn: String
        /// A list of keys to identify which key-value tags to remove from a resource.
        public let tagKeyList: [String]

        public init(resourceArn: String, tagKeyList: [String]) {
            self.resourceArn = resourceArn
            self.tagKeyList = tagKeyList
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeyList = "TagKeyList"
        }
    }

    public struct UpdateBackupPlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupPlanId", location: .uri("BackupPlanId"))
        ]

        /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
        public let backupPlan: BackupPlanInput
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String

        public init(backupPlan: BackupPlanInput, backupPlanId: String) {
            self.backupPlan = backupPlan
            self.backupPlanId = backupPlanId
        }

        public func validate(name: String) throws {
            try self.backupPlan.validate(name: "\(name).backupPlan")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
        }
    }

    public struct UpdateBackupPlanOutput: AWSDecodableShape {
        /// Contains a list of BackupOptions for each resource type.
        public let advancedBackupSettings: [AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version Ids cannot be edited.
        public let versionId: String?

        public init(advancedBackupSettings: [AdvancedBackupSetting]? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, creationDate: Date? = nil, versionId: String? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case creationDate = "CreationDate"
            case versionId = "VersionId"
        }
    }

    public struct UpdateFrameworkInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "frameworkName", location: .uri("FrameworkName"))
        ]

        /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
        public let frameworkControls: [FrameworkControl]?
        /// An optional description of the framework with a maximum 1,024 characters.
        public let frameworkDescription: String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String
        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?

        public init(frameworkControls: [FrameworkControl]? = nil, frameworkDescription: String? = nil, frameworkName: String, idempotencyToken: String? = UpdateFrameworkInput.idempotencyToken()) {
            self.frameworkControls = frameworkControls
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.idempotencyToken = idempotencyToken
        }

        public func validate(name: String) throws {
            try self.frameworkControls?.forEach {
                try $0.validate(name: "\(name).frameworkControls[]")
            }
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, max: 1024)
            try self.validate(self.frameworkDescription, name: "frameworkDescription", parent: name, pattern: "\\S")
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, max: 256)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, min: 1)
            try self.validate(self.frameworkName, name: "frameworkName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case frameworkControls = "FrameworkControls"
            case frameworkDescription = "FrameworkDescription"
            case idempotencyToken = "IdempotencyToken"
        }
    }

    public struct UpdateFrameworkOutput: AWSDecodableShape {
        /// The date and time that a framework is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let frameworkArn: String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let frameworkName: String?

        public init(creationTime: Date? = nil, frameworkArn: String? = nil, frameworkName: String? = nil) {
            self.creationTime = creationTime
            self.frameworkArn = frameworkArn
            self.frameworkName = frameworkName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case frameworkArn = "FrameworkArn"
            case frameworkName = "FrameworkName"
        }
    }

    public struct UpdateGlobalSettingsInput: AWSEncodableShape {
        /// A value for isCrossAccountBackupEnabled and a Region. Example: update-global-settings --global-settings isCrossAccountBackupEnabled=false --region us-west-2.
        public let globalSettings: [String: String]?

        public init(globalSettings: [String: String]? = nil) {
            self.globalSettings = globalSettings
        }

        private enum CodingKeys: String, CodingKey {
            case globalSettings = "GlobalSettings"
        }
    }

    public struct UpdateRecoveryPointLifecycleInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupVaultName", location: .uri("BackupVaultName")),
            AWSMemberEncoding(label: "recoveryPointArn", location: .uri("RecoveryPointArn"))
        ]

        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.
        public let lifecycle: Lifecycle?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String

        public init(backupVaultName: String, lifecycle: Lifecycle? = nil, recoveryPointArn: String) {
            self.backupVaultName = backupVaultName
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]{2,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycle = "Lifecycle"
        }
    }

    public struct UpdateRecoveryPointLifecycleOutput: AWSDecodableShape {
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public let backupVaultArn: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: CalculatedLifecycle?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define.  Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.  Only Amazon EFS file system backups can be transitioned to cold storage.
        public let lifecycle: Lifecycle?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public let recoveryPointArn: String?

        public init(backupVaultArn: String? = nil, calculatedLifecycle: CalculatedLifecycle? = nil, lifecycle: Lifecycle? = nil, recoveryPointArn: String? = nil) {
            self.backupVaultArn = backupVaultArn
            self.calculatedLifecycle = calculatedLifecycle
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultArn = "BackupVaultArn"
            case calculatedLifecycle = "CalculatedLifecycle"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
        }
    }

    public struct UpdateRegionSettingsInput: AWSEncodableShape {
        /// Updates the list of services along with the opt-in preferences for the Region.
        public let resourceTypeOptInPreference: [String: Bool]?

        public init(resourceTypeOptInPreference: [String: Bool]? = nil) {
            self.resourceTypeOptInPreference = resourceTypeOptInPreference
        }

        public func validate(name: String) throws {
            try self.resourceTypeOptInPreference?.forEach {
                try validate($0.key, name: "resourceTypeOptInPreference.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]{1,50}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
        }
    }

    public struct UpdateReportPlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "reportPlanName", location: .uri("ReportPlanName"))
        ]

        /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
        public let idempotencyToken: String?
        /// A structure that contains information about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public let reportDeliveryChannel: ReportDeliveryChannel?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public let reportPlanDescription: String?
        /// The unique name of the report plan. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public let reportPlanName: String
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are:  BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public let reportSetting: ReportSetting?

        public init(idempotencyToken: String? = UpdateReportPlanInput.idempotencyToken(), reportDeliveryChannel: ReportDeliveryChannel? = nil, reportPlanDescription: String? = nil, reportPlanName: String, reportSetting: ReportSetting? = nil) {
            self.idempotencyToken = idempotencyToken
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, max: 1024)
            try self.validate(self.reportPlanDescription, name: "reportPlanDescription", parent: name, pattern: "\\S")
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, max: 256)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, min: 1)
            try self.validate(self.reportPlanName, name: "reportPlanName", parent: name, pattern: "^[a-zA-Z][_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case idempotencyToken = "IdempotencyToken"
            case reportDeliveryChannel = "ReportDeliveryChannel"
            case reportPlanDescription = "ReportPlanDescription"
            case reportSetting = "ReportSetting"
        }
    }

    public struct UpdateReportPlanOutput: AWSDecodableShape {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let reportPlanArn: String?
        /// The unique name of the report plan.
        public let reportPlanName: String?

        public init(creationTime: Date? = nil, reportPlanArn: String? = nil, reportPlanName: String? = nil) {
            self.creationTime = creationTime
            self.reportPlanArn = reportPlanArn
            self.reportPlanName = reportPlanName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case reportPlanArn = "ReportPlanArn"
            case reportPlanName = "ReportPlanName"
        }
    }
}
