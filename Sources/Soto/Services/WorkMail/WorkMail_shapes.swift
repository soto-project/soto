//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension WorkMail {
    // MARK: Enums

    public enum AccessControlRuleEffect: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum AccessEffect: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum AvailabilityProviderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ews = "EWS"
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum DnsRecordVerificationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case verified = "VERIFIED"
        public var description: String { return self.rawValue }
    }

    public enum EntityState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case group = "GROUP"
        case resource = "RESOURCE"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum FolderName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletedItems = "DELETED_ITEMS"
        case drafts = "DRAFTS"
        case inbox = "INBOX"
        case junkEmail = "JUNK_EMAIL"
        case sentItems = "SENT_ITEMS"
        public var description: String { return self.rawValue }
    }

    public enum ImpersonationRoleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullAccess = "FULL_ACCESS"
        case readOnly = "READ_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum MailboxExportJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum MemberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case group = "GROUP"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum MobileDeviceAccessRuleEffect: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum PermissionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullAccess = "FULL_ACCESS"
        case sendAs = "SEND_AS"
        case sendOnBehalf = "SEND_ON_BEHALF"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equipment = "EQUIPMENT"
        case room = "ROOM"
        public var description: String { return self.rawValue }
    }

    public enum RetentionAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case none = "NONE"
        case permanentlyDelete = "PERMANENTLY_DELETE"
        public var description: String { return self.rawValue }
    }

    public enum UserRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case remoteUser = "REMOTE_USER"
        case resource = "RESOURCE"
        case systemUser = "SYSTEM_USER"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessControlRule: AWSDecodableShape {
        /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public let actions: [String]?
        /// The date that the rule was created.
        public let dateCreated: Date?
        /// The date that the rule was modified.
        public let dateModified: Date?
        /// The rule description.
        public let description: String?
        /// The rule effect.
        public let effect: AccessControlRuleEffect?
        /// Impersonation role IDs to include in the rule.
        public let impersonationRoleIds: [String]?
        /// IPv4 CIDR ranges to include in the rule.
        public let ipRanges: [String]?
        /// The rule name.
        public let name: String?
        /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public let notActions: [String]?
        /// Impersonation role IDs to exclude from the rule.
        public let notImpersonationRoleIds: [String]?
        /// IPv4 CIDR ranges to exclude from the rule.
        public let notIpRanges: [String]?
        /// User IDs to exclude from the rule.
        public let notUserIds: [String]?
        /// User IDs to include in the rule.
        public let userIds: [String]?

        public init(actions: [String]? = nil, dateCreated: Date? = nil, dateModified: Date? = nil, description: String? = nil, effect: AccessControlRuleEffect? = nil, impersonationRoleIds: [String]? = nil, ipRanges: [String]? = nil, name: String? = nil, notActions: [String]? = nil, notImpersonationRoleIds: [String]? = nil, notIpRanges: [String]? = nil, notUserIds: [String]? = nil, userIds: [String]? = nil) {
            self.actions = actions
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.effect = effect
            self.impersonationRoleIds = impersonationRoleIds
            self.ipRanges = ipRanges
            self.name = name
            self.notActions = notActions
            self.notImpersonationRoleIds = notImpersonationRoleIds
            self.notIpRanges = notIpRanges
            self.notUserIds = notUserIds
            self.userIds = userIds
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case description = "Description"
            case effect = "Effect"
            case impersonationRoleIds = "ImpersonationRoleIds"
            case ipRanges = "IpRanges"
            case name = "Name"
            case notActions = "NotActions"
            case notImpersonationRoleIds = "NotImpersonationRoleIds"
            case notIpRanges = "NotIpRanges"
            case notUserIds = "NotUserIds"
            case userIds = "UserIds"
        }
    }

    public struct AssociateDelegateToResourceRequest: AWSEncodableShape {
        /// The member (user or group) to associate to the resource. The entity ID can accept UserId or GroupID, Username or Groupname, or email.   Entity: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity: entity
        public let entityId: String
        /// The organization under which the resource exists.
        public let organizationId: String
        /// The resource for which members (users or groups) are associated. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:   Resource ID: r-0123456789a0123456789b0123456789   Email address: resource@domain.tld   Resource name: resource
        public let resourceId: String

        public init(entityId: String, organizationId: String, resourceId: String) {
            self.entityId = entityId
            self.organizationId = organizationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
            case resourceId = "ResourceId"
        }
    }

    public struct AssociateDelegateToResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateMemberToGroupRequest: AWSEncodableShape {
        /// The group to which the member (user or group) is associated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:   Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: group@domain.tld   Group name: group
        public let groupId: String
        /// The member (user or group) to associate to the group. The member ID can accept UserID or GroupId, Username or Groupname, or email.   Member: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: member@domain.tld   Member name: member
        public let memberId: String
        /// The organization under which the group exists.
        public let organizationId: String

        public init(groupId: String, memberId: String, organizationId: String) {
            self.groupId = groupId
            self.memberId = memberId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 256)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case memberId = "MemberId"
            case organizationId = "OrganizationId"
        }
    }

    public struct AssociateMemberToGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssumeImpersonationRoleRequest: AWSEncodableShape {
        /// The impersonation role ID to assume.
        public let impersonationRoleId: String
        /// The WorkMail organization under which the impersonation role will be assumed.
        public let organizationId: String

        public init(impersonationRoleId: String, organizationId: String) {
            self.impersonationRoleId = impersonationRoleId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, max: 64)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, min: 1)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case impersonationRoleId = "ImpersonationRoleId"
            case organizationId = "OrganizationId"
        }
    }

    public struct AssumeImpersonationRoleResponse: AWSDecodableShape {
        /// The authentication token's validity, in seconds.
        public let expiresIn: Int64?
        /// The authentication token for the impersonation role.
        public let token: String?

        public init(expiresIn: Int64? = nil, token: String? = nil) {
            self.expiresIn = expiresIn
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case expiresIn = "ExpiresIn"
            case token = "Token"
        }
    }

    public struct AvailabilityConfiguration: AWSDecodableShape {
        /// The date and time at which the availability configuration was created.
        public let dateCreated: Date?
        /// The date and time at which the availability configuration was last modified.
        public let dateModified: Date?
        /// Displays the domain to which the provider applies.
        public let domainName: String?
        /// If ProviderType is EWS, then this field contains RedactedEwsAvailabilityProvider. Otherwise, it is not required.
        public let ewsProvider: RedactedEwsAvailabilityProvider?
        /// If ProviderType is LAMBDA then this field contains LambdaAvailabilityProvider. Otherwise, it is not required.
        public let lambdaProvider: LambdaAvailabilityProvider?
        /// Displays the provider type that applies to this domain.
        public let providerType: AvailabilityProviderType?

        public init(dateCreated: Date? = nil, dateModified: Date? = nil, domainName: String? = nil, ewsProvider: RedactedEwsAvailabilityProvider? = nil, lambdaProvider: LambdaAvailabilityProvider? = nil, providerType: AvailabilityProviderType? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.providerType = providerType
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case domainName = "DomainName"
            case ewsProvider = "EwsProvider"
            case lambdaProvider = "LambdaProvider"
            case providerType = "ProviderType"
        }
    }

    public struct BookingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.
        public let autoAcceptRequests: Bool?
        /// The resource's ability to automatically decline any conflicting requests.
        public let autoDeclineConflictingRequests: Bool?
        /// The resource's ability to automatically decline any recurring requests.
        public let autoDeclineRecurringRequests: Bool?

        public init(autoAcceptRequests: Bool? = nil, autoDeclineConflictingRequests: Bool? = nil, autoDeclineRecurringRequests: Bool? = nil) {
            self.autoAcceptRequests = autoAcceptRequests
            self.autoDeclineConflictingRequests = autoDeclineConflictingRequests
            self.autoDeclineRecurringRequests = autoDeclineRecurringRequests
        }

        private enum CodingKeys: String, CodingKey {
            case autoAcceptRequests = "AutoAcceptRequests"
            case autoDeclineConflictingRequests = "AutoDeclineConflictingRequests"
            case autoDeclineRecurringRequests = "AutoDeclineRecurringRequests"
        }
    }

    public struct CancelMailboxExportJobRequest: AWSEncodableShape {
        /// The idempotency token for the client request.
        public let clientToken: String
        /// The job ID.
        public let jobId: String
        /// The organization ID.
        public let organizationId: String

        public init(clientToken: String = CancelMailboxExportJobRequest.idempotencyToken(), jobId: String, organizationId: String) {
            self.clientToken = clientToken
            self.jobId = jobId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 63)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[A-Za-z0-9-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case jobId = "JobId"
            case organizationId = "OrganizationId"
        }
    }

    public struct CancelMailboxExportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateAliasRequest: AWSEncodableShape {
        /// The alias to add to the member set.
        public let alias: String
        /// The member (user or group) to which this alias is added.
        public let entityId: String
        /// The organization under which the member (user or group) exists.
        public let organizationId: String

        public init(alias: String, entityId: String, organizationId: String) {
            self.alias = alias
            self.entityId = entityId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 254)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[a-zA-Z0-9._%+-]{1,64}@[a-zA-Z0-9.-]+\\.[a-zA-Z-]{2,}$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 12)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
        }
    }

    public struct CreateAliasResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateAvailabilityConfigurationRequest: AWSEncodableShape {
        /// An idempotent token that ensures that an API request is executed only once.
        public let clientToken: String?
        /// The domain to which the provider applies.
        public let domainName: String
        /// Exchange Web Services (EWS) availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
        public let ewsProvider: EwsAvailabilityProvider?
        /// Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
        public let lambdaProvider: LambdaAvailabilityProvider?
        /// The WorkMail organization for which the AvailabilityConfiguration will be created.
        public let organizationId: String

        public init(clientToken: String? = CreateAvailabilityConfigurationRequest.idempotencyToken(), domainName: String, ewsProvider: EwsAvailabilityProvider? = nil, lambdaProvider: LambdaAvailabilityProvider? = nil, organizationId: String) {
            self.clientToken = clientToken
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.ewsProvider?.validate(name: "\(name).ewsProvider")
            try self.lambdaProvider?.validate(name: "\(name).lambdaProvider")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case domainName = "DomainName"
            case ewsProvider = "EwsProvider"
            case lambdaProvider = "LambdaProvider"
            case organizationId = "OrganizationId"
        }
    }

    public struct CreateAvailabilityConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        /// If this parameter is enabled, the group will be hidden from the address book.
        public let hiddenFromGlobalAddressList: Bool?
        /// The name of the group.
        public let name: String
        /// The organization under which the group is to be created.
        public let organizationId: String

        public init(hiddenFromGlobalAddressList: Bool? = nil, name: String, organizationId: String) {
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.name = name
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case name = "Name"
            case organizationId = "OrganizationId"
        }
    }

    public struct CreateGroupResponse: AWSDecodableShape {
        /// The identifier of the group.
        public let groupId: String?

        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
        }
    }

    public struct CreateImpersonationRoleRequest: AWSEncodableShape {
        /// The idempotency token for the client request.
        public let clientToken: String?
        /// The description of the new impersonation role.
        public let description: String?
        /// The name of the new impersonation role.
        public let name: String
        /// The WorkMail organization to create the new impersonation role within.
        public let organizationId: String
        /// The list of rules for the impersonation role.
        public let rules: [ImpersonationRule]
        /// The impersonation role's type. The available impersonation role types are READ_ONLY or FULL_ACCESS.
        public let type: ImpersonationRoleType

        public init(clientToken: String? = CreateImpersonationRoleRequest.idempotencyToken(), description: String? = nil, name: String, organizationId: String, rules: [ImpersonationRule], type: ImpersonationRoleType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.organizationId = organizationId
            self.rules = rules
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F\\x3C\\x3E\\x5C]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\x00-\\x1F\\x7F\\x3C\\x3E\\x5C]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case name = "Name"
            case organizationId = "OrganizationId"
            case rules = "Rules"
            case type = "Type"
        }
    }

    public struct CreateImpersonationRoleResponse: AWSDecodableShape {
        /// The new impersonation role ID.
        public let impersonationRoleId: String?

        public init(impersonationRoleId: String? = nil) {
            self.impersonationRoleId = impersonationRoleId
        }

        private enum CodingKeys: String, CodingKey {
            case impersonationRoleId = "ImpersonationRoleId"
        }
    }

    public struct CreateMobileDeviceAccessRuleRequest: AWSEncodableShape {
        /// The idempotency token for the client request.
        public let clientToken: String?
        /// The rule description.
        public let description: String?
        /// Device models that the rule will match.
        public let deviceModels: [String]?
        /// Device operating systems that the rule will match.
        public let deviceOperatingSystems: [String]?
        /// Device types that the rule will match.
        public let deviceTypes: [String]?
        /// Device user agents that the rule will match.
        public let deviceUserAgents: [String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public let effect: MobileDeviceAccessRuleEffect
        /// The rule name.
        public let name: String
        /// Device models that the rule will not match. All other device models will match.
        public let notDeviceModels: [String]?
        /// Device operating systems that the rule will not match. All other device operating systems will match.
        public let notDeviceOperatingSystems: [String]?
        /// Device types that the rule will not match. All other device types will match.
        public let notDeviceTypes: [String]?
        /// Device user agents that the rule will not match. All other device user agents will match.
        public let notDeviceUserAgents: [String]?
        /// The WorkMail organization under which the rule will be created.
        public let organizationId: String

        public init(clientToken: String? = CreateMobileDeviceAccessRuleRequest.idempotencyToken(), description: String? = nil, deviceModels: [String]? = nil, deviceOperatingSystems: [String]? = nil, deviceTypes: [String]? = nil, deviceUserAgents: [String]? = nil, effect: MobileDeviceAccessRuleEffect, name: String, notDeviceModels: [String]? = nil, notDeviceOperatingSystems: [String]? = nil, notDeviceTypes: [String]? = nil, notDeviceUserAgents: [String]? = nil, organizationId: String) {
            self.clientToken = clientToken
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]+$")
            try self.deviceModels?.forEach {
                try validate($0, name: "deviceModels[]", parent: name, max: 256)
                try validate($0, name: "deviceModels[]", parent: name, min: 1)
                try validate($0, name: "deviceModels[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceModels, name: "deviceModels", parent: name, max: 10)
            try self.validate(self.deviceModels, name: "deviceModels", parent: name, min: 1)
            try self.deviceOperatingSystems?.forEach {
                try validate($0, name: "deviceOperatingSystems[]", parent: name, max: 256)
                try validate($0, name: "deviceOperatingSystems[]", parent: name, min: 1)
                try validate($0, name: "deviceOperatingSystems[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceOperatingSystems, name: "deviceOperatingSystems", parent: name, max: 10)
            try self.validate(self.deviceOperatingSystems, name: "deviceOperatingSystems", parent: name, min: 1)
            try self.deviceTypes?.forEach {
                try validate($0, name: "deviceTypes[]", parent: name, max: 256)
                try validate($0, name: "deviceTypes[]", parent: name, min: 1)
                try validate($0, name: "deviceTypes[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, max: 10)
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, min: 1)
            try self.deviceUserAgents?.forEach {
                try validate($0, name: "deviceUserAgents[]", parent: name, max: 256)
                try validate($0, name: "deviceUserAgents[]", parent: name, min: 1)
                try validate($0, name: "deviceUserAgents[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceUserAgents, name: "deviceUserAgents", parent: name, max: 10)
            try self.validate(self.deviceUserAgents, name: "deviceUserAgents", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S\\s]+$")
            try self.notDeviceModels?.forEach {
                try validate($0, name: "notDeviceModels[]", parent: name, max: 256)
                try validate($0, name: "notDeviceModels[]", parent: name, min: 1)
                try validate($0, name: "notDeviceModels[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceModels, name: "notDeviceModels", parent: name, max: 10)
            try self.validate(self.notDeviceModels, name: "notDeviceModels", parent: name, min: 1)
            try self.notDeviceOperatingSystems?.forEach {
                try validate($0, name: "notDeviceOperatingSystems[]", parent: name, max: 256)
                try validate($0, name: "notDeviceOperatingSystems[]", parent: name, min: 1)
                try validate($0, name: "notDeviceOperatingSystems[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceOperatingSystems, name: "notDeviceOperatingSystems", parent: name, max: 10)
            try self.validate(self.notDeviceOperatingSystems, name: "notDeviceOperatingSystems", parent: name, min: 1)
            try self.notDeviceTypes?.forEach {
                try validate($0, name: "notDeviceTypes[]", parent: name, max: 256)
                try validate($0, name: "notDeviceTypes[]", parent: name, min: 1)
                try validate($0, name: "notDeviceTypes[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceTypes, name: "notDeviceTypes", parent: name, max: 10)
            try self.validate(self.notDeviceTypes, name: "notDeviceTypes", parent: name, min: 1)
            try self.notDeviceUserAgents?.forEach {
                try validate($0, name: "notDeviceUserAgents[]", parent: name, max: 256)
                try validate($0, name: "notDeviceUserAgents[]", parent: name, min: 1)
                try validate($0, name: "notDeviceUserAgents[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceUserAgents, name: "notDeviceUserAgents", parent: name, max: 10)
            try self.validate(self.notDeviceUserAgents, name: "notDeviceUserAgents", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case deviceModels = "DeviceModels"
            case deviceOperatingSystems = "DeviceOperatingSystems"
            case deviceTypes = "DeviceTypes"
            case deviceUserAgents = "DeviceUserAgents"
            case effect = "Effect"
            case name = "Name"
            case notDeviceModels = "NotDeviceModels"
            case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
            case notDeviceTypes = "NotDeviceTypes"
            case notDeviceUserAgents = "NotDeviceUserAgents"
            case organizationId = "OrganizationId"
        }
    }

    public struct CreateMobileDeviceAccessRuleResponse: AWSDecodableShape {
        /// The identifier for the newly created mobile device access rule.
        public let mobileDeviceAccessRuleId: String?

        public init(mobileDeviceAccessRuleId: String? = nil) {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        }

        private enum CodingKeys: String, CodingKey {
            case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        }
    }

    public struct CreateOrganizationRequest: AWSEncodableShape {
        /// The organization alias.
        public let alias: String
        /// The idempotency token associated with the request.
        public let clientToken: String?
        /// The AWS Directory Service directory ID.
        public let directoryId: String?
        /// The email domains to associate with the organization.
        public let domains: [Domain]?
        /// When true, allows organization interoperability between WorkMail and Microsoft Exchange. If true, you must include a AD Connector directory ID in the request.
        public let enableInteroperability: Bool?
        /// The Amazon Resource Name (ARN) of a customer managed key from AWS KMS.
        public let kmsKeyArn: String?

        public init(alias: String, clientToken: String? = CreateOrganizationRequest.idempotencyToken(), directoryId: String? = nil, domains: [Domain]? = nil, enableInteroperability: Bool? = nil, kmsKeyArn: String? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.directoryId = directoryId
            self.domains = domains
            self.enableInteroperability = enableInteroperability
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 62)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^(?!d-)([\\da-zA-Z]+)([-][\\da-zA-Z]+)*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.directoryId, name: "directoryId", parent: name, max: 12)
            try self.validate(self.directoryId, name: "directoryId", parent: name, min: 12)
            try self.validate(self.directoryId, name: "directoryId", parent: name, pattern: "^d-[0-9a-f]{10}$")
            try self.domains?.forEach {
                try $0.validate(name: "\(name).domains[]")
            }
            try self.validate(self.domains, name: "domains", parent: name, max: 5)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case clientToken = "ClientToken"
            case directoryId = "DirectoryId"
            case domains = "Domains"
            case enableInteroperability = "EnableInteroperability"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct CreateOrganizationResponse: AWSDecodableShape {
        /// The organization ID.
        public let organizationId: String?

        public init(organizationId: String? = nil) {
            self.organizationId = organizationId
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct CreateResourceRequest: AWSEncodableShape {
        /// Resource description.
        public let description: String?
        /// If this parameter is enabled, the resource will be hidden from the address book.
        public let hiddenFromGlobalAddressList: Bool?
        /// The name of the new resource.
        public let name: String
        /// The identifier associated with the organization for which the resource is created.
        public let organizationId: String
        /// The type of the new resource. The available types are equipment and room.
        public let type: ResourceType

        public init(description: String? = nil, hiddenFromGlobalAddressList: Bool? = nil, name: String, organizationId: String, type: ResourceType) {
            self.description = description
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.name = name
            self.organizationId = organizationId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 64)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 20)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w\\-.]+(@[a-zA-Z0-9.\\-]+\\.[a-zA-Z0-9-]{2,})?$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case name = "Name"
            case organizationId = "OrganizationId"
            case type = "Type"
        }
    }

    public struct CreateResourceResponse: AWSDecodableShape {
        /// The identifier of the new resource.
        public let resourceId: String?

        public init(resourceId: String? = nil) {
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// The display name for the new user.
        public let displayName: String
        /// The first name of the new user.
        public let firstName: String?
        /// If this parameter is enabled, the user will be hidden from the address book.
        public let hiddenFromGlobalAddressList: Bool?
        /// The last name of the new user.
        public let lastName: String?
        /// The name for the new user. WorkMail directory user names have a maximum length of 64. All others have a maximum length of 20.
        public let name: String
        /// The identifier of the organization for which the user is created.
        public let organizationId: String
        /// The password for the new user.
        public let password: String?
        /// The role of the new user. You cannot pass SYSTEM_USER or RESOURCE role in a single request. When a user role is not selected, the default role of USER is selected.
        public let role: UserRole?

        public init(displayName: String, firstName: String? = nil, hiddenFromGlobalAddressList: Bool? = nil, lastName: String? = nil, name: String, organizationId: String, password: String? = nil, role: UserRole? = nil) {
            self.displayName = displayName
            self.firstName = firstName
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.lastName = lastName
            self.name = name
            self.organizationId = organizationId
            self.password = password
            self.role = role
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.firstName, name: "firstName", parent: name, max: 256)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w\\-.]+(@[a-zA-Z0-9.\\-]+\\.[a-zA-Z0-9-]{2,})?$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.password, name: "password", parent: name, max: 256)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case firstName = "FirstName"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case lastName = "LastName"
            case name = "Name"
            case organizationId = "OrganizationId"
            case password = "Password"
            case role = "Role"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        /// The identifier for the new user.
        public let userId: String?

        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "UserId"
        }
    }

    public struct Delegate: AWSDecodableShape {
        /// The identifier for the user or group associated as the resource's delegate.
        public let id: String
        /// The type of the delegate: user or group.
        public let type: MemberType

        public init(id: String, type: MemberType) {
            self.id = id
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case type = "Type"
        }
    }

    public struct DeleteAccessControlRuleRequest: AWSEncodableShape {
        /// The name of the access control rule.
        public let name: String
        /// The identifier for the organization.
        public let organizationId: String

        public init(name: String, organizationId: String) {
            self.name = name
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteAccessControlRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAliasRequest: AWSEncodableShape {
        /// The aliases to be removed from the user's set of aliases. Duplicate entries in the list are collapsed into single entries (the list is transformed into a set).
        public let alias: String
        /// The identifier for the member (user or group) from which to have the aliases removed.
        public let entityId: String
        /// The identifier for the organization under which the user exists.
        public let organizationId: String

        public init(alias: String, entityId: String, organizationId: String) {
            self.alias = alias
            self.entityId = entityId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 254)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[a-zA-Z0-9._%+-]{1,64}@[a-zA-Z0-9.-]+\\.[a-zA-Z-]{2,}$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 12)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteAliasResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAvailabilityConfigurationRequest: AWSEncodableShape {
        /// The domain for which the AvailabilityConfiguration will be deleted.
        public let domainName: String
        /// The WorkMail organization for which the AvailabilityConfiguration will be deleted.
        public let organizationId: String

        public init(domainName: String, organizationId: String) {
            self.domainName = domainName
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteAvailabilityConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEmailMonitoringConfigurationRequest: AWSEncodableShape {
        /// The ID of the organization from which the email monitoring configuration is deleted.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteEmailMonitoringConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The identifier of the group to be deleted. The identifier can be the GroupId, or Groupname. The following identity formats are available:   Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Group name: group
        public let groupId: String
        /// The organization that contains the group.
        public let organizationId: String

        public init(groupId: String, organizationId: String) {
            self.groupId = groupId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImpersonationRoleRequest: AWSEncodableShape {
        /// The ID of the impersonation role to delete.
        public let impersonationRoleId: String
        /// The WorkMail organization from which to delete the impersonation role.
        public let organizationId: String

        public init(impersonationRoleId: String, organizationId: String) {
            self.impersonationRoleId = impersonationRoleId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, max: 64)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, min: 1)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case impersonationRoleId = "ImpersonationRoleId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteImpersonationRoleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMailboxPermissionsRequest: AWSEncodableShape {
        /// The identifier of the entity that owns the mailbox. The identifier can be UserId or Group Id, Username or Groupname, or email.   Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// The identifier of the entity for which to delete granted permissions. The identifier can be UserId, ResourceID, or Group Id, Username or Groupname, or email.   Grantee ID: 12345678-1234-1234-1234-123456789012,r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Email address: grantee@domain.tld   Grantee name: grantee
        public let granteeId: String
        /// The identifier of the organization under which the member (user or group) exists.
        public let organizationId: String

        public init(entityId: String, granteeId: String, organizationId: String) {
            self.entityId = entityId
            self.granteeId = granteeId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.granteeId, name: "granteeId", parent: name, max: 256)
            try self.validate(self.granteeId, name: "granteeId", parent: name, min: 1)
            try self.validate(self.granteeId, name: "granteeId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case granteeId = "GranteeId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteMailboxPermissionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMobileDeviceAccessOverrideRequest: AWSEncodableShape {
        /// The mobile device for which you delete the override. DeviceId is case insensitive.
        public let deviceId: String
        /// The WorkMail organization for which the access override will be deleted.
        public let organizationId: String
        /// The WorkMail user for which you want to delete the override. Accepts the following types of user identities:   User ID:  12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234    Email address: user@domain.tld    User name: user
        public let userId: String

        public init(deviceId: String, organizationId: String, userId: String) {
            self.deviceId = deviceId
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 32)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct DeleteMobileDeviceAccessOverrideResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMobileDeviceAccessRuleRequest: AWSEncodableShape {
        /// The identifier of the rule to be deleted.
        public let mobileDeviceAccessRuleId: String
        /// The WorkMail organization under which the rule will be deleted.
        public let organizationId: String

        public init(mobileDeviceAccessRuleId: String, organizationId: String) {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.mobileDeviceAccessRuleId, name: "mobileDeviceAccessRuleId", parent: name, max: 64)
            try self.validate(self.mobileDeviceAccessRuleId, name: "mobileDeviceAccessRuleId", parent: name, min: 1)
            try self.validate(self.mobileDeviceAccessRuleId, name: "mobileDeviceAccessRuleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteMobileDeviceAccessRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOrganizationRequest: AWSEncodableShape {
        /// The idempotency token associated with the request.
        public let clientToken: String?
        /// If true, deletes the AWS Directory Service directory associated with the organization.
        public let deleteDirectory: Bool
        /// Deletes a WorkMail organization even if the organization has enabled users.
        public let forceDelete: Bool?
        /// The organization ID.
        public let organizationId: String

        public init(clientToken: String? = DeleteOrganizationRequest.idempotencyToken(), deleteDirectory: Bool = false, forceDelete: Bool? = nil, organizationId: String) {
            self.clientToken = clientToken
            self.deleteDirectory = deleteDirectory
            self.forceDelete = forceDelete
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deleteDirectory = "DeleteDirectory"
            case forceDelete = "ForceDelete"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteOrganizationResponse: AWSDecodableShape {
        /// The organization ID.
        public let organizationId: String?
        /// The state of the organization.
        public let state: String?

        public init(organizationId: String? = nil, state: String? = nil) {
            self.organizationId = organizationId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case state = "State"
        }
    }

    public struct DeleteResourceRequest: AWSEncodableShape {
        /// The identifier associated with the organization from which the resource is deleted.
        public let organizationId: String
        /// The identifier of the resource to be deleted. The identifier can accept ResourceId, or Resourcename. The following identity formats are available:   Resource ID: r-0123456789a0123456789b0123456789   Resource name: resource
        public let resourceId: String

        public init(organizationId: String, resourceId: String) {
            self.organizationId = organizationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case resourceId = "ResourceId"
        }
    }

    public struct DeleteResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRetentionPolicyRequest: AWSEncodableShape {
        /// The retention policy ID.
        public let id: String
        /// The organization ID.
        public let organizationId: String

        public init(id: String, organizationId: String) {
            self.id = id
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeleteRetentionPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The organization that contains the user to be deleted.
        public let organizationId: String
        /// The identifier of the user to be deleted. The identifier can be the UserId or Username. The following identity formats are available:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   User name: user
        public let userId: String

        public init(organizationId: String, userId: String) {
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterFromWorkMailRequest: AWSEncodableShape {
        /// The identifier for the member to be updated. The identifier can be UserId, ResourceId, or Group Id, Username, Resourcename, or Groupname, or email.   Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// The identifier for the organization under which the WorkMail entity exists.
        public let organizationId: String

        public init(entityId: String, organizationId: String) {
            self.entityId = entityId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeregisterFromWorkMailResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterMailDomainRequest: AWSEncodableShape {
        /// The domain to deregister in WorkMail and SES.
        public let domainName: String
        /// The WorkMail organization for which the domain will be deregistered.
        public let organizationId: String

        public init(domainName: String, organizationId: String) {
            self.domainName = domainName
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 209)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case organizationId = "OrganizationId"
        }
    }

    public struct DeregisterMailDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeEmailMonitoringConfigurationRequest: AWSEncodableShape {
        /// The ID of the organization for which the email monitoring configuration is described.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct DescribeEmailMonitoringConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
        public let logGroupArn: String?
        /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
        public let roleArn: String?

        public init(logGroupArn: String? = nil, roleArn: String? = nil) {
            self.logGroupArn = logGroupArn
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "LogGroupArn"
            case roleArn = "RoleArn"
        }
    }

    public struct DescribeEntityRequest: AWSEncodableShape {
        /// The email under which the entity exists.
        public let email: String
        /// The identifier for the organization under which the entity exists.
        public let organizationId: String

        public init(email: String, organizationId: String) {
            self.email = email
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9._%+-]{1,64}@[a-zA-Z0-9.-]+\\.[a-zA-Z-]{2,}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case organizationId = "OrganizationId"
        }
    }

    public struct DescribeEntityResponse: AWSDecodableShape {
        /// The entity ID under which the entity exists.
        public let entityId: String?
        /// Username, GroupName, or ResourceName based on entity type.
        public let name: String?
        /// Entity type.
        public let type: EntityType?

        public init(entityId: String? = nil, name: String? = nil, type: EntityType? = nil) {
            self.entityId = entityId
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DescribeGroupRequest: AWSEncodableShape {
        /// The identifier for the group to be described. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:   Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: group@domain.tld   Group name: group
        public let groupId: String
        /// The identifier for the organization under which the group exists.
        public let organizationId: String

        public init(groupId: String, organizationId: String) {
            self.groupId = groupId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DescribeGroupResponse: AWSDecodableShape {
        /// The date and time when a user was deregistered from WorkMail, in UNIX epoch time format.
        public let disabledDate: Date?
        /// The email of the described group.
        public let email: String?
        /// The date and time when a user was registered to WorkMail, in UNIX epoch time format.
        public let enabledDate: Date?
        /// The identifier of the described group.
        public let groupId: String?
        /// If the value is set to true, the group is hidden from the address book.
        public let hiddenFromGlobalAddressList: Bool?
        /// The name of the described group.
        public let name: String?
        /// The state of the user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
        public let state: EntityState?

        public init(disabledDate: Date? = nil, email: String? = nil, enabledDate: Date? = nil, groupId: String? = nil, hiddenFromGlobalAddressList: Bool? = nil, name: String? = nil, state: EntityState? = nil) {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.groupId = groupId
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case disabledDate = "DisabledDate"
            case email = "Email"
            case enabledDate = "EnabledDate"
            case groupId = "GroupId"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case name = "Name"
            case state = "State"
        }
    }

    public struct DescribeInboundDmarcSettingsRequest: AWSEncodableShape {
        /// Lists the ID of the given organization.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct DescribeInboundDmarcSettingsResponse: AWSDecodableShape {
        /// Lists the enforcement setting of the applied policy.
        public let enforced: Bool?

        public init(enforced: Bool? = nil) {
            self.enforced = enforced
        }

        private enum CodingKeys: String, CodingKey {
            case enforced = "Enforced"
        }
    }

    public struct DescribeMailboxExportJobRequest: AWSEncodableShape {
        /// The mailbox export job ID.
        public let jobId: String
        /// The organization ID.
        public let organizationId: String

        public init(jobId: String, organizationId: String) {
            self.jobId = jobId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 63)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[A-Za-z0-9-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DescribeMailboxExportJobResponse: AWSDecodableShape {
        /// The mailbox export job description.
        public let description: String?
        /// The mailbox export job end timestamp.
        public let endTime: Date?
        /// The identifier of the user or resource associated with the mailbox.
        public let entityId: String?
        /// Error information for failed mailbox export jobs.
        public let errorInfo: String?
        /// The estimated progress of the mailbox export job, in percentage points.
        public let estimatedProgress: Int?
        /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
        public let kmsKeyArn: String?
        /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the Amazon Simple Storage Service (Amazon S3) bucket.
        public let roleArn: String?
        /// The name of the S3 bucket.
        public let s3BucketName: String?
        /// The path to the S3 bucket and file that the mailbox export job is exporting to.
        public let s3Path: String?
        /// The S3 bucket prefix.
        public let s3Prefix: String?
        /// The mailbox export job start timestamp.
        public let startTime: Date?
        /// The state of the mailbox export job.
        public let state: MailboxExportJobState?

        public init(description: String? = nil, endTime: Date? = nil, entityId: String? = nil, errorInfo: String? = nil, estimatedProgress: Int? = nil, kmsKeyArn: String? = nil, roleArn: String? = nil, s3BucketName: String? = nil, s3Path: String? = nil, s3Prefix: String? = nil, startTime: Date? = nil, state: MailboxExportJobState? = nil) {
            self.description = description
            self.endTime = endTime
            self.entityId = entityId
            self.errorInfo = errorInfo
            self.estimatedProgress = estimatedProgress
            self.kmsKeyArn = kmsKeyArn
            self.roleArn = roleArn
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
            self.s3Prefix = s3Prefix
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case endTime = "EndTime"
            case entityId = "EntityId"
            case errorInfo = "ErrorInfo"
            case estimatedProgress = "EstimatedProgress"
            case kmsKeyArn = "KmsKeyArn"
            case roleArn = "RoleArn"
            case s3BucketName = "S3BucketName"
            case s3Path = "S3Path"
            case s3Prefix = "S3Prefix"
            case startTime = "StartTime"
            case state = "State"
        }
    }

    public struct DescribeOrganizationRequest: AWSEncodableShape {
        /// The identifier for the organization to be described.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct DescribeOrganizationResponse: AWSDecodableShape {
        /// The alias for an organization.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of the organization.
        public let arn: String?
        /// The date at which the organization became usable in the WorkMail context, in UNIX epoch time format.
        public let completedDate: Date?
        /// The default mail domain associated with the organization.
        public let defaultMailDomain: String?
        /// The identifier for the directory associated with an WorkMail organization.
        public let directoryId: String?
        /// The type of directory associated with the WorkMail organization.
        public let directoryType: String?
        /// (Optional) The error message indicating if unexpected behavior was encountered with regards to the organization.
        public let errorMessage: String?
        /// Indicates if interoperability is enabled for this organization.
        public let interoperabilityEnabled: Bool?
        /// The user ID of the migration admin if migration is enabled for the organization.
        public let migrationAdmin: String?
        /// The identifier of an organization.
        public let organizationId: String?
        /// The state of an organization.
        public let state: String?

        public init(alias: String? = nil, arn: String? = nil, completedDate: Date? = nil, defaultMailDomain: String? = nil, directoryId: String? = nil, directoryType: String? = nil, errorMessage: String? = nil, interoperabilityEnabled: Bool? = nil, migrationAdmin: String? = nil, organizationId: String? = nil, state: String? = nil) {
            self.alias = alias
            self.arn = arn
            self.completedDate = completedDate
            self.defaultMailDomain = defaultMailDomain
            self.directoryId = directoryId
            self.directoryType = directoryType
            self.errorMessage = errorMessage
            self.interoperabilityEnabled = interoperabilityEnabled
            self.migrationAdmin = migrationAdmin
            self.organizationId = organizationId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case arn = "ARN"
            case completedDate = "CompletedDate"
            case defaultMailDomain = "DefaultMailDomain"
            case directoryId = "DirectoryId"
            case directoryType = "DirectoryType"
            case errorMessage = "ErrorMessage"
            case interoperabilityEnabled = "InteroperabilityEnabled"
            case migrationAdmin = "MigrationAdmin"
            case organizationId = "OrganizationId"
            case state = "State"
        }
    }

    public struct DescribeResourceRequest: AWSEncodableShape {
        /// The identifier associated with the organization for which the resource is described.
        public let organizationId: String
        /// The identifier of the resource to be described. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:   Resource ID: r-0123456789a0123456789b0123456789   Email address: resource@domain.tld   Resource name: resource
        public let resourceId: String

        public init(organizationId: String, resourceId: String) {
            self.organizationId = organizationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case resourceId = "ResourceId"
        }
    }

    public struct DescribeResourceResponse: AWSDecodableShape {
        /// The booking options for the described resource.
        public let bookingOptions: BookingOptions?
        /// Description of the resource.
        public let description: String?
        /// The date and time when a resource was disabled from WorkMail, in UNIX epoch time format.
        public let disabledDate: Date?
        /// The email of the described resource.
        public let email: String?
        /// The date and time when a resource was enabled for WorkMail, in UNIX epoch time format.
        public let enabledDate: Date?
        /// If enabled, the resource is hidden from the global address list.
        public let hiddenFromGlobalAddressList: Bool?
        /// The name of the described resource.
        public let name: String?
        /// The identifier of the described resource.
        public let resourceId: String?
        /// The state of the resource: enabled (registered to WorkMail), disabled (deregistered or never registered to WorkMail), or deleted.
        public let state: EntityState?
        /// The type of the described resource.
        public let type: ResourceType?

        public init(bookingOptions: BookingOptions? = nil, description: String? = nil, disabledDate: Date? = nil, email: String? = nil, enabledDate: Date? = nil, hiddenFromGlobalAddressList: Bool? = nil, name: String? = nil, resourceId: String? = nil, state: EntityState? = nil, type: ResourceType? = nil) {
            self.bookingOptions = bookingOptions
            self.description = description
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.name = name
            self.resourceId = resourceId
            self.state = state
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case bookingOptions = "BookingOptions"
            case description = "Description"
            case disabledDate = "DisabledDate"
            case email = "Email"
            case enabledDate = "EnabledDate"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case name = "Name"
            case resourceId = "ResourceId"
            case state = "State"
            case type = "Type"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        /// The identifier for the organization under which the user exists.
        public let organizationId: String
        /// The identifier for the user to be described. The identifier can be the UserId, Username, or email. The following identity formats are available:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: user@domain.tld   User name: user
        public let userId: String

        public init(organizationId: String, userId: String) {
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        /// City where the user is located.
        public let city: String?
        /// Company of the user.
        public let company: String?
        /// Country where the user is located.
        public let country: String?
        /// Department of the user.
        public let department: String?
        /// The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.
        public let disabledDate: Date?
        /// The display name of the user.
        public let displayName: String?
        /// The email of the user.
        public let email: String?
        /// The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.
        public let enabledDate: Date?
        /// First name of the user.
        public let firstName: String?
        /// If enabled, the user is hidden from the global address list.
        public let hiddenFromGlobalAddressList: Bool?
        /// Initials of the user.
        public let initials: String?
        /// Job title of the user.
        public let jobTitle: String?
        /// Last name of the user.
        public let lastName: String?
        /// The date when the mailbox was removed for the user.
        public let mailboxDeprovisionedDate: Date?
        /// The date when the mailbox was created for the user.
        public let mailboxProvisionedDate: Date?
        /// The name for the user.
        public let name: String?
        /// Office where the user is located.
        public let office: String?
        /// The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
        public let state: EntityState?
        /// Street where the user is located.
        public let street: String?
        /// User's contact number.
        public let telephone: String?
        /// The identifier for the described user.
        public let userId: String?
        /// In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.
        public let userRole: UserRole?
        /// Zip code of the user.
        public let zipCode: String?

        public init(city: String? = nil, company: String? = nil, country: String? = nil, department: String? = nil, disabledDate: Date? = nil, displayName: String? = nil, email: String? = nil, enabledDate: Date? = nil, firstName: String? = nil, hiddenFromGlobalAddressList: Bool? = nil, initials: String? = nil, jobTitle: String? = nil, lastName: String? = nil, mailboxDeprovisionedDate: Date? = nil, mailboxProvisionedDate: Date? = nil, name: String? = nil, office: String? = nil, state: EntityState? = nil, street: String? = nil, telephone: String? = nil, userId: String? = nil, userRole: UserRole? = nil, zipCode: String? = nil) {
            self.city = city
            self.company = company
            self.country = country
            self.department = department
            self.disabledDate = disabledDate
            self.displayName = displayName
            self.email = email
            self.enabledDate = enabledDate
            self.firstName = firstName
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.initials = initials
            self.jobTitle = jobTitle
            self.lastName = lastName
            self.mailboxDeprovisionedDate = mailboxDeprovisionedDate
            self.mailboxProvisionedDate = mailboxProvisionedDate
            self.name = name
            self.office = office
            self.state = state
            self.street = street
            self.telephone = telephone
            self.userId = userId
            self.userRole = userRole
            self.zipCode = zipCode
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case company = "Company"
            case country = "Country"
            case department = "Department"
            case disabledDate = "DisabledDate"
            case displayName = "DisplayName"
            case email = "Email"
            case enabledDate = "EnabledDate"
            case firstName = "FirstName"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case initials = "Initials"
            case jobTitle = "JobTitle"
            case lastName = "LastName"
            case mailboxDeprovisionedDate = "MailboxDeprovisionedDate"
            case mailboxProvisionedDate = "MailboxProvisionedDate"
            case name = "Name"
            case office = "Office"
            case state = "State"
            case street = "Street"
            case telephone = "Telephone"
            case userId = "UserId"
            case userRole = "UserRole"
            case zipCode = "ZipCode"
        }
    }

    public struct DisassociateDelegateFromResourceRequest: AWSEncodableShape {
        /// The identifier for the member (user, group) to be removed from the resource's delegates. The entity ID can accept UserId or GroupID, Username or Groupname, or email.   Entity: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity: entity
        public let entityId: String
        /// The identifier for the organization under which the resource exists.
        public let organizationId: String
        /// The identifier of the resource from which delegates' set members are removed.  The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:   Resource ID: r-0123456789a0123456789b0123456789   Email address: resource@domain.tld   Resource name: resource
        public let resourceId: String

        public init(entityId: String, organizationId: String, resourceId: String) {
            self.entityId = entityId
            self.organizationId = organizationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
            case resourceId = "ResourceId"
        }
    }

    public struct DisassociateDelegateFromResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMemberFromGroupRequest: AWSEncodableShape {
        /// The identifier for the group from which members are removed. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:   Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: group@domain.tld   Group name: group
        public let groupId: String
        /// The identifier for the member to be removed from the group. The member ID can accept UserID or GroupId, Username or Groupname, or email.   Member ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: member@domain.tld   Member name: member
        public let memberId: String
        /// The identifier for the organization under which the group exists.
        public let organizationId: String

        public init(groupId: String, memberId: String, organizationId: String) {
            self.groupId = groupId
            self.memberId = memberId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 256)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case memberId = "MemberId"
            case organizationId = "OrganizationId"
        }
    }

    public struct DisassociateMemberFromGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DnsRecord: AWSDecodableShape {
        /// The DNS hostname.- For example, domain.example.com.
        public let hostname: String?
        /// The RFC 1035 record type. Possible values: CNAME, A, MX.
        public let type: String?
        /// The value returned by the DNS for a query to that hostname and record type.
        public let value: String?

        public init(hostname: String? = nil, type: String? = nil, value: String? = nil) {
            self.hostname = hostname
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct Domain: AWSEncodableShape {
        /// The fully qualified domain name.
        public let domainName: String
        /// The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.
        public let hostedZoneId: String?

        public init(domainName: String, hostedZoneId: String? = nil) {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, max: 32)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, min: 1)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: "^[^/\\\\]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case hostedZoneId = "HostedZoneId"
        }
    }

    public struct EwsAvailabilityProvider: AWSEncodableShape {
        /// The endpoint of the remote EWS server.
        public let ewsEndpoint: String
        /// The password used to authenticate the remote EWS server.
        public let ewsPassword: String
        /// The username used to authenticate the remote EWS server.
        public let ewsUsername: String

        public init(ewsEndpoint: String, ewsPassword: String, ewsUsername: String) {
            self.ewsEndpoint = ewsEndpoint
            self.ewsPassword = ewsPassword
            self.ewsUsername = ewsUsername
        }

        public func validate(name: String) throws {
            try self.validate(self.ewsEndpoint, name: "ewsEndpoint", parent: name, max: 256)
            try self.validate(self.ewsEndpoint, name: "ewsEndpoint", parent: name, pattern: "^https?://[A-Za-z0-9.-]+(:[0-9]+)?/")
            try self.validate(self.ewsPassword, name: "ewsPassword", parent: name, max: 256)
            try self.validate(self.ewsPassword, name: "ewsPassword", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.ewsUsername, name: "ewsUsername", parent: name, max: 256)
            try self.validate(self.ewsUsername, name: "ewsUsername", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ewsEndpoint = "EwsEndpoint"
            case ewsPassword = "EwsPassword"
            case ewsUsername = "EwsUsername"
        }
    }

    public struct FolderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The action to take on the folder contents at the end of the folder configuration period.
        public let action: RetentionAction
        /// The folder name.
        public let name: FolderName
        /// The number of days for which the folder-configuration action applies.
        public let period: Int?

        public init(action: RetentionAction, name: FolderName, period: Int? = nil) {
            self.action = action
            self.name = name
            self.period = period
        }

        public func validate(name: String) throws {
            try self.validate(self.period, name: "period", parent: name, max: 730)
            try self.validate(self.period, name: "period", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case name = "Name"
            case period = "Period"
        }
    }

    public struct GetAccessControlEffectRequest: AWSEncodableShape {
        /// The access protocol action. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public let action: String
        /// The impersonation role ID.
        public let impersonationRoleId: String?
        /// The IPv4 address.
        public let ipAddress: String
        /// The identifier for the organization.
        public let organizationId: String
        /// The user ID.
        public let userId: String?

        public init(action: String, impersonationRoleId: String? = nil, ipAddress: String, organizationId: String, userId: String? = nil) {
            self.action = action
            self.impersonationRoleId = impersonationRoleId
            self.ipAddress = ipAddress
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, max: 64)
            try self.validate(self.action, name: "action", parent: name, min: 1)
            try self.validate(self.action, name: "action", parent: name, pattern: "^[a-zA-Z]+$")
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, max: 64)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, min: 1)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, max: 15)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, min: 1)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case impersonationRoleId = "ImpersonationRoleId"
            case ipAddress = "IpAddress"
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct GetAccessControlEffectResponse: AWSDecodableShape {
        /// The rule effect.
        public let effect: AccessControlRuleEffect?
        /// The rules that match the given parameters, resulting in an effect.
        public let matchedRules: [String]?

        public init(effect: AccessControlRuleEffect? = nil, matchedRules: [String]? = nil) {
            self.effect = effect
            self.matchedRules = matchedRules
        }

        private enum CodingKeys: String, CodingKey {
            case effect = "Effect"
            case matchedRules = "MatchedRules"
        }
    }

    public struct GetDefaultRetentionPolicyRequest: AWSEncodableShape {
        /// The organization ID.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct GetDefaultRetentionPolicyResponse: AWSDecodableShape {
        /// The retention policy description.
        public let description: String?
        /// The retention policy folder configurations.
        public let folderConfigurations: [FolderConfiguration]?
        /// The retention policy ID.
        public let id: String?
        /// The retention policy name.
        public let name: String?

        public init(description: String? = nil, folderConfigurations: [FolderConfiguration]? = nil, id: String? = nil, name: String? = nil) {
            self.description = description
            self.folderConfigurations = folderConfigurations
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case folderConfigurations = "FolderConfigurations"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct GetImpersonationRoleEffectRequest: AWSEncodableShape {
        /// The impersonation role ID to test.
        public let impersonationRoleId: String
        /// The WorkMail organization where the impersonation role is defined.
        public let organizationId: String
        /// The WorkMail organization user chosen to test the impersonation role. The following identity formats are available:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234    Email address: user@domain.tld    User name: user
        public let targetUser: String

        public init(impersonationRoleId: String, organizationId: String, targetUser: String) {
            self.impersonationRoleId = impersonationRoleId
            self.organizationId = organizationId
            self.targetUser = targetUser
        }

        public func validate(name: String) throws {
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, max: 64)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, min: 1)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.targetUser, name: "targetUser", parent: name, max: 256)
            try self.validate(self.targetUser, name: "targetUser", parent: name, min: 1)
            try self.validate(self.targetUser, name: "targetUser", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case impersonationRoleId = "ImpersonationRoleId"
            case organizationId = "OrganizationId"
            case targetUser = "TargetUser"
        }
    }

    public struct GetImpersonationRoleEffectResponse: AWSDecodableShape {
        ///  Effect of the impersonation role on the target user based on its rules. Available effects are ALLOW or DENY.
        public let effect: AccessEffect?
        /// A list of the rules that match the input and produce the configured effect.
        public let matchedRules: [ImpersonationMatchedRule]?
        /// The impersonation role type.
        public let type: ImpersonationRoleType?

        public init(effect: AccessEffect? = nil, matchedRules: [ImpersonationMatchedRule]? = nil, type: ImpersonationRoleType? = nil) {
            self.effect = effect
            self.matchedRules = matchedRules
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case effect = "Effect"
            case matchedRules = "MatchedRules"
            case type = "Type"
        }
    }

    public struct GetImpersonationRoleRequest: AWSEncodableShape {
        /// The impersonation role ID to retrieve.
        public let impersonationRoleId: String
        /// The WorkMail organization from which to retrieve the impersonation role.
        public let organizationId: String

        public init(impersonationRoleId: String, organizationId: String) {
            self.impersonationRoleId = impersonationRoleId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, max: 64)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, min: 1)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case impersonationRoleId = "ImpersonationRoleId"
            case organizationId = "OrganizationId"
        }
    }

    public struct GetImpersonationRoleResponse: AWSDecodableShape {
        /// The date when the impersonation role was created.
        public let dateCreated: Date?
        /// The date when the impersonation role was last modified.
        public let dateModified: Date?
        /// The impersonation role description.
        public let description: String?
        /// The impersonation role ID.
        public let impersonationRoleId: String?
        /// The impersonation role name.
        public let name: String?
        /// The list of rules for the given impersonation role.
        public let rules: [ImpersonationRule]?
        /// The impersonation role type.
        public let type: ImpersonationRoleType?

        public init(dateCreated: Date? = nil, dateModified: Date? = nil, description: String? = nil, impersonationRoleId: String? = nil, name: String? = nil, rules: [ImpersonationRule]? = nil, type: ImpersonationRoleType? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.impersonationRoleId = impersonationRoleId
            self.name = name
            self.rules = rules
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case description = "Description"
            case impersonationRoleId = "ImpersonationRoleId"
            case name = "Name"
            case rules = "Rules"
            case type = "Type"
        }
    }

    public struct GetMailDomainRequest: AWSEncodableShape {
        /// The domain from which you want to retrieve details.
        public let domainName: String
        /// The WorkMail organization for which the domain is retrieved.
        public let organizationId: String

        public init(domainName: String, organizationId: String) {
            self.domainName = domainName
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 209)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case organizationId = "OrganizationId"
        }
    }

    public struct GetMailDomainResponse: AWSDecodableShape {
        /// Indicates the status of a DKIM verification.
        public let dkimVerificationStatus: DnsRecordVerificationStatus?
        /// Specifies whether the domain is the default domain for your organization.
        public let isDefault: Bool?
        /// Specifies whether the domain is a test domain provided by WorkMail, or a custom domain.
        public let isTestDomain: Bool?
        ///  Indicates the status of the domain ownership verification.
        public let ownershipVerificationStatus: DnsRecordVerificationStatus?
        /// A list of the DNS records that WorkMail recommends adding in your DNS provider for the best user experience. The records configure your domain with DMARC, SPF, DKIM, and direct incoming  email traffic to SES. See admin guide for more details.
        public let records: [DnsRecord]?

        public init(dkimVerificationStatus: DnsRecordVerificationStatus? = nil, isDefault: Bool? = nil, isTestDomain: Bool? = nil, ownershipVerificationStatus: DnsRecordVerificationStatus? = nil, records: [DnsRecord]? = nil) {
            self.dkimVerificationStatus = dkimVerificationStatus
            self.isDefault = isDefault
            self.isTestDomain = isTestDomain
            self.ownershipVerificationStatus = ownershipVerificationStatus
            self.records = records
        }

        private enum CodingKeys: String, CodingKey {
            case dkimVerificationStatus = "DkimVerificationStatus"
            case isDefault = "IsDefault"
            case isTestDomain = "IsTestDomain"
            case ownershipVerificationStatus = "OwnershipVerificationStatus"
            case records = "Records"
        }
    }

    public struct GetMailboxDetailsRequest: AWSEncodableShape {
        /// The identifier for the organization that contains the user whose mailbox details are being requested.
        public let organizationId: String
        /// The identifier for the user whose mailbox details are being requested. The identifier can be the UserId, Username, or email. The following identity formats are available:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: user@domain.tld   User name: user
        public let userId: String

        public init(organizationId: String, userId: String) {
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct GetMailboxDetailsResponse: AWSDecodableShape {
        /// The maximum allowed mailbox size, in MB, for the specified user.
        public let mailboxQuota: Int?
        /// The current mailbox size, in MB, for the specified user.
        public let mailboxSize: Double?

        public init(mailboxQuota: Int? = nil, mailboxSize: Double? = nil) {
            self.mailboxQuota = mailboxQuota
            self.mailboxSize = mailboxSize
        }

        private enum CodingKeys: String, CodingKey {
            case mailboxQuota = "MailboxQuota"
            case mailboxSize = "MailboxSize"
        }
    }

    public struct GetMobileDeviceAccessEffectRequest: AWSEncodableShape {
        /// Device model the simulated user will report.
        public let deviceModel: String?
        /// Device operating system the simulated user will report.
        public let deviceOperatingSystem: String?
        /// Device type the simulated user will report.
        public let deviceType: String?
        /// Device user agent the simulated user will report.
        public let deviceUserAgent: String?
        /// The WorkMail organization to simulate the access effect for.
        public let organizationId: String

        public init(deviceModel: String? = nil, deviceOperatingSystem: String? = nil, deviceType: String? = nil, deviceUserAgent: String? = nil, organizationId: String) {
            self.deviceModel = deviceModel
            self.deviceOperatingSystem = deviceOperatingSystem
            self.deviceType = deviceType
            self.deviceUserAgent = deviceUserAgent
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceModel, name: "deviceModel", parent: name, max: 256)
            try self.validate(self.deviceModel, name: "deviceModel", parent: name, min: 1)
            try self.validate(self.deviceModel, name: "deviceModel", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.deviceOperatingSystem, name: "deviceOperatingSystem", parent: name, max: 256)
            try self.validate(self.deviceOperatingSystem, name: "deviceOperatingSystem", parent: name, min: 1)
            try self.validate(self.deviceOperatingSystem, name: "deviceOperatingSystem", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.deviceType, name: "deviceType", parent: name, max: 256)
            try self.validate(self.deviceType, name: "deviceType", parent: name, min: 1)
            try self.validate(self.deviceType, name: "deviceType", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.deviceUserAgent, name: "deviceUserAgent", parent: name, max: 256)
            try self.validate(self.deviceUserAgent, name: "deviceUserAgent", parent: name, min: 1)
            try self.validate(self.deviceUserAgent, name: "deviceUserAgent", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceModel = "DeviceModel"
            case deviceOperatingSystem = "DeviceOperatingSystem"
            case deviceType = "DeviceType"
            case deviceUserAgent = "DeviceUserAgent"
            case organizationId = "OrganizationId"
        }
    }

    public struct GetMobileDeviceAccessEffectResponse: AWSDecodableShape {
        /// The effect of the simulated access, ALLOW or DENY, after evaluating mobile device access rules in the WorkMail organization for the simulated  user parameters.
        public let effect: MobileDeviceAccessRuleEffect?
        /// A list of the rules which matched the simulated user input and produced the effect.
        public let matchedRules: [MobileDeviceAccessMatchedRule]?

        public init(effect: MobileDeviceAccessRuleEffect? = nil, matchedRules: [MobileDeviceAccessMatchedRule]? = nil) {
            self.effect = effect
            self.matchedRules = matchedRules
        }

        private enum CodingKeys: String, CodingKey {
            case effect = "Effect"
            case matchedRules = "MatchedRules"
        }
    }

    public struct GetMobileDeviceAccessOverrideRequest: AWSEncodableShape {
        /// The mobile device to which the override applies. DeviceId is case insensitive.
        public let deviceId: String
        /// The WorkMail organization to which you want to apply the override.
        public let organizationId: String
        /// Identifies the WorkMail user for the override. Accepts the following types of user identities:    User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234    Email address: user@domain.tld    User name: user
        public let userId: String

        public init(deviceId: String, organizationId: String, userId: String) {
            self.deviceId = deviceId
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 32)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct GetMobileDeviceAccessOverrideResponse: AWSDecodableShape {
        /// The date the override was first created.
        public let dateCreated: Date?
        /// The date the description was last modified.
        public let dateModified: Date?
        /// A description of the override.
        public let description: String?
        /// The device to which the access override applies.
        public let deviceId: String?
        /// The effect of the override, ALLOW or DENY.
        public let effect: MobileDeviceAccessRuleEffect?
        /// The WorkMail user to which the access override applies.
        public let userId: String?

        public init(dateCreated: Date? = nil, dateModified: Date? = nil, description: String? = nil, deviceId: String? = nil, effect: MobileDeviceAccessRuleEffect? = nil, userId: String? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case description = "Description"
            case deviceId = "DeviceId"
            case effect = "Effect"
            case userId = "UserId"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The date indicating when the group was disabled from WorkMail use.
        public let disabledDate: Date?
        /// The email of the group.
        public let email: String?
        /// The date indicating when the group was enabled for WorkMail use.
        public let enabledDate: Date?
        /// The identifier of the group.
        public let id: String?
        /// The name of the group.
        public let name: String?
        /// The state of the group, which can be ENABLED, DISABLED, or DELETED.
        public let state: EntityState?

        public init(disabledDate: Date? = nil, email: String? = nil, enabledDate: Date? = nil, id: String? = nil, name: String? = nil, state: EntityState? = nil) {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case disabledDate = "DisabledDate"
            case email = "Email"
            case enabledDate = "EnabledDate"
            case id = "Id"
            case name = "Name"
            case state = "State"
        }
    }

    public struct GroupIdentifier: AWSDecodableShape {
        /// Group ID that matched the group.
        public let groupId: String?
        /// Group name that matched the group.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
        }
    }

    public struct ImpersonationMatchedRule: AWSDecodableShape {
        /// The ID of the rule that matched the input
        public let impersonationRuleId: String?
        /// The name of the rule that matched the input.
        public let name: String?

        public init(impersonationRuleId: String? = nil, name: String? = nil) {
            self.impersonationRuleId = impersonationRuleId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case impersonationRuleId = "ImpersonationRuleId"
            case name = "Name"
        }
    }

    public struct ImpersonationRole: AWSDecodableShape {
        /// The date when the impersonation role was created.
        public let dateCreated: Date?
        /// The date when the impersonation role was last modified.
        public let dateModified: Date?
        /// The identifier of the impersonation role.
        public let impersonationRoleId: String?
        /// The impersonation role name.
        public let name: String?
        /// The impersonation role type.
        public let type: ImpersonationRoleType?

        public init(dateCreated: Date? = nil, dateModified: Date? = nil, impersonationRoleId: String? = nil, name: String? = nil, type: ImpersonationRoleType? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.impersonationRoleId = impersonationRoleId
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case impersonationRoleId = "ImpersonationRoleId"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct ImpersonationRule: AWSEncodableShape & AWSDecodableShape {
        /// The rule description.
        public let description: String?
        /// The effect of the rule when it matches the input. Allowed effect values are ALLOW or DENY.
        public let effect: AccessEffect
        /// The identifier of the rule.
        public let impersonationRuleId: String
        /// The rule name.
        public let name: String?
        /// A list of user IDs that don't match the rule.
        public let notTargetUsers: [String]?
        /// A list of user IDs that match the rule.
        public let targetUsers: [String]?

        public init(description: String? = nil, effect: AccessEffect, impersonationRuleId: String, name: String? = nil, notTargetUsers: [String]? = nil, targetUsers: [String]? = nil) {
            self.description = description
            self.effect = effect
            self.impersonationRuleId = impersonationRuleId
            self.name = name
            self.notTargetUsers = notTargetUsers
            self.targetUsers = targetUsers
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F\\x3C\\x3E\\x5C]+$")
            try self.validate(self.impersonationRuleId, name: "impersonationRuleId", parent: name, max: 64)
            try self.validate(self.impersonationRuleId, name: "impersonationRuleId", parent: name, min: 1)
            try self.validate(self.impersonationRuleId, name: "impersonationRuleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\x00-\\x1F\\x7F\\x3C\\x3E\\x5C]+$")
            try self.notTargetUsers?.forEach {
                try validate($0, name: "notTargetUsers[]", parent: name, max: 256)
                try validate($0, name: "notTargetUsers[]", parent: name, min: 1)
                try validate($0, name: "notTargetUsers[]", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            }
            try self.validate(self.notTargetUsers, name: "notTargetUsers", parent: name, max: 10)
            try self.validate(self.notTargetUsers, name: "notTargetUsers", parent: name, min: 1)
            try self.targetUsers?.forEach {
                try validate($0, name: "targetUsers[]", parent: name, max: 256)
                try validate($0, name: "targetUsers[]", parent: name, min: 1)
                try validate($0, name: "targetUsers[]", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            }
            try self.validate(self.targetUsers, name: "targetUsers", parent: name, max: 10)
            try self.validate(self.targetUsers, name: "targetUsers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case effect = "Effect"
            case impersonationRuleId = "ImpersonationRuleId"
            case name = "Name"
            case notTargetUsers = "NotTargetUsers"
            case targetUsers = "TargetUsers"
        }
    }

    public struct LambdaAvailabilityProvider: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.
        public let lambdaArn: String

        public init(lambdaArn: String) {
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 256)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, min: 49)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:aws:lambda:[a-z]{2}-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9\\-_\\.]+(:(\\$LATEST|[a-zA-Z0-9\\-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "LambdaArn"
        }
    }

    public struct ListAccessControlRulesRequest: AWSEncodableShape {
        /// The identifier for the organization.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct ListAccessControlRulesResponse: AWSDecodableShape {
        /// The access control rules.
        public let rules: [AccessControlRule]?

        public init(rules: [AccessControlRule]? = nil) {
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct ListAliasesRequest: AWSEncodableShape {
        /// The identifier for the entity for which to list the aliases.
        public let entityId: String
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier for the organization under which the entity exists.
        public let organizationId: String

        public init(entityId: String, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.entityId = entityId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 12)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListAliasesResponse: AWSDecodableShape {
        /// The entity's paginated aliases.
        public let aliases: [String]?
        /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
        public let nextToken: String?

        public init(aliases: [String]? = nil, nextToken: String? = nil) {
            self.aliases = aliases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case nextToken = "NextToken"
        }
    }

    public struct ListAvailabilityConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not require a token.
        public let nextToken: String?
        /// The WorkMail organization for which the AvailabilityConfiguration's will be listed.
        public let organizationId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListAvailabilityConfigurationsResponse: AWSDecodableShape {
        /// The list of AvailabilityConfiguration's that exist for the specified WorkMail organization.
        public let availabilityConfigurations: [AvailabilityConfiguration]?
        /// The token to use to retrieve the next page of results. The value is null when there are no further results to return.
        public let nextToken: String?

        public init(availabilityConfigurations: [AvailabilityConfiguration]? = nil, nextToken: String? = nil) {
            self.availabilityConfigurations = availabilityConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityConfigurations = "AvailabilityConfigurations"
            case nextToken = "NextToken"
        }
    }

    public struct ListGroupMembersRequest: AWSEncodableShape {
        /// The identifier for the group to which the members (users or groups) are associated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:   Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: group@domain.tld   Group name: group
        public let groupId: String
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        ///  The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier for the organization under which the group exists.
        public let organizationId: String

        public init(groupId: String, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.groupId = groupId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListGroupMembersResponse: AWSDecodableShape {
        /// The members associated to the group.
        public let members: [Member]?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListGroupsFilters: AWSEncodableShape {
        /// Filters only groups with the provided name prefix.
        public let namePrefix: String?
        /// Filters only groups with the provided primary email prefix.
        public let primaryEmailPrefix: String?
        /// Filters only groups with the provided state.
        public let state: EntityState?

        public init(namePrefix: String? = nil, primaryEmailPrefix: String? = nil, state: EntityState? = nil) {
            self.namePrefix = namePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, max: 256)
            try self.validate(self.primaryEmailPrefix, name: "primaryEmailPrefix", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case namePrefix = "NamePrefix"
            case primaryEmailPrefix = "PrimaryEmailPrefix"
            case state = "State"
        }
    }

    public struct ListGroupsForEntityFilters: AWSEncodableShape {
        /// Filters only group names that start with the provided name prefix.
        public let groupNamePrefix: String?

        public init(groupNamePrefix: String? = nil) {
            self.groupNamePrefix = groupNamePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.groupNamePrefix, name: "groupNamePrefix", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case groupNamePrefix = "GroupNamePrefix"
        }
    }

    public struct ListGroupsForEntityRequest: AWSEncodableShape {
        /// The identifier for the entity. The entity ID can accept UserId or GroupID, Username or Groupname, or email.   Entity ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// Limit the search results based on the filter criteria.
        public let filters: ListGroupsForEntityFilters?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier for the organization under which the entity exists.
        public let organizationId: String

        public init(entityId: String, filters: ListGroupsForEntityFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.entityId = entityId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListGroupsForEntityResponse: AWSDecodableShape {
        /// The overview of groups in an organization.
        public let groups: [GroupIdentifier]?
        /// The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
        public let nextToken: String?

        public init(groups: [GroupIdentifier]? = nil, nextToken: String? = nil) {
            self.groups = groups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case nextToken = "NextToken"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        /// Limit the search results based on the filter criteria. Only one filter per request is supported.
        public let filters: ListGroupsFilters?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier for the organization under which the groups exist.
        public let organizationId: String

        public init(filters: ListGroupsFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        /// The overview of groups for an organization.
        public let groups: [Group]?
        /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
        public let nextToken: String?

        public init(groups: [Group]? = nil, nextToken: String? = nil) {
            self.groups = groups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case nextToken = "NextToken"
        }
    }

    public struct ListImpersonationRolesRequest: AWSEncodableShape {
        /// The maximum number of results returned in a single call.
        public let maxResults: Int?
        /// The token used to retrieve the next page of results. The first call doesn't require a token.
        public let nextToken: String?
        /// The WorkMail organization to which the listed impersonation roles belong.
        public let organizationId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListImpersonationRolesResponse: AWSDecodableShape {
        /// The token to retrieve the next page of results. The value is null when there are no results to return.
        public let nextToken: String?
        /// The list of impersonation roles under the given WorkMail organization.
        public let roles: [ImpersonationRole]?

        public init(nextToken: String? = nil, roles: [ImpersonationRole]? = nil) {
            self.nextToken = nextToken
            self.roles = roles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case roles = "Roles"
        }
    }

    public struct ListMailDomainsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not require a token.
        public let nextToken: String?
        /// The WorkMail organization for which to list domains.
        public let organizationId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListMailDomainsResponse: AWSDecodableShape {
        /// The list of mail domain summaries, specifying domains that exist in the specified WorkMail organization, along with the information about whether the domain is or isn't the default.
        public let mailDomains: [MailDomainSummary]?
        /// The token to use to retrieve the next page of results. The value becomes null when there are no more results to return.
        public let nextToken: String?

        public init(mailDomains: [MailDomainSummary]? = nil, nextToken: String? = nil) {
            self.mailDomains = mailDomains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mailDomains = "MailDomains"
            case nextToken = "NextToken"
        }
    }

    public struct ListMailboxExportJobsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?
        /// The organization ID.
        public let organizationId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListMailboxExportJobsResponse: AWSDecodableShape {
        /// The mailbox export job details.
        public let jobs: [MailboxExportJob]?
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?

        public init(jobs: [MailboxExportJob]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListMailboxPermissionsRequest: AWSEncodableShape {
        /// The identifier of the user, or resource for which to list mailbox permissions. The entity ID can accept UserId or ResourceId, Username or Resourcename, or email.   Entity ID: 12345678-1234-1234-1234-123456789012, or r-0123456789a0123456789b0123456789   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier of the organization under which the user, group, or resource exists.
        public let organizationId: String

        public init(entityId: String, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.entityId = entityId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListMailboxPermissionsResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
        public let nextToken: String?
        /// One page of the user, group, or resource mailbox permissions.
        public let permissions: [Permission]?

        public init(nextToken: String? = nil, permissions: [Permission]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case permissions = "Permissions"
        }
    }

    public struct ListMobileDeviceAccessOverridesRequest: AWSEncodableShape {
        /// The mobile device to which the access override applies.
        public let deviceId: String?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not require a token.
        public let nextToken: String?
        /// The WorkMail organization under which to list mobile device access overrides.
        public let organizationId: String
        /// The WorkMail user under which you list the mobile device access overrides. Accepts the following types of user identities:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234    Email address: user@domain.tld    User name: user
        public let userId: String?

        public init(deviceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String, userId: String? = nil) {
            self.deviceId = deviceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 32)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct ListMobileDeviceAccessOverridesResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results. The value is “null” when there are no more results to return.
        public let nextToken: String?
        /// The list of mobile device access overrides that exist for the specified WorkMail organization and user.
        public let overrides: [MobileDeviceAccessOverride]?

        public init(nextToken: String? = nil, overrides: [MobileDeviceAccessOverride]? = nil) {
            self.nextToken = nextToken
            self.overrides = overrides
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case overrides = "Overrides"
        }
    }

    public struct ListMobileDeviceAccessRulesRequest: AWSEncodableShape {
        /// The WorkMail organization for which to list the rules.
        public let organizationId: String

        public init(organizationId: String) {
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
        }
    }

    public struct ListMobileDeviceAccessRulesResponse: AWSDecodableShape {
        /// The list of mobile device access rules that exist under the specified WorkMail organization.
        public let rules: [MobileDeviceAccessRule]?

        public init(rules: [MobileDeviceAccessRule]? = nil) {
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct ListOrganizationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrganizationsResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
        public let nextToken: String?
        /// The overview of owned organizations presented as a list of organization summaries.
        public let organizationSummaries: [OrganizationSummary]?

        public init(nextToken: String? = nil, organizationSummaries: [OrganizationSummary]? = nil) {
            self.nextToken = nextToken
            self.organizationSummaries = organizationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationSummaries = "OrganizationSummaries"
        }
    }

    public struct ListResourceDelegatesRequest: AWSEncodableShape {
        /// The number of maximum results in a page.
        public let maxResults: Int?
        /// The token used to paginate through the delegates associated with a resource.
        public let nextToken: String?
        /// The identifier for the organization that contains the resource for which delegates are listed.
        public let organizationId: String
        /// The identifier for the resource whose delegates are listed. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:   Resource ID: r-0123456789a0123456789b0123456789   Email address: resource@domain.tld   Resource name: resource
        public let resourceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, organizationId: String, resourceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
            case resourceId = "ResourceId"
        }
    }

    public struct ListResourceDelegatesResponse: AWSDecodableShape {
        /// One page of the resource's delegates.
        public let delegates: [Delegate]?
        /// The token used to paginate through the delegates associated with a resource. While results are still available, it has an associated value. When the last page is reached, the token is empty.
        public let nextToken: String?

        public init(delegates: [Delegate]? = nil, nextToken: String? = nil) {
            self.delegates = delegates
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case delegates = "Delegates"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourcesFilters: AWSEncodableShape {
        /// Filters only resource that start with the entered name prefix .
        public let namePrefix: String?
        /// Filters only resource with the provided primary email prefix.
        public let primaryEmailPrefix: String?
        /// Filters only resource with the provided state.
        public let state: EntityState?

        public init(namePrefix: String? = nil, primaryEmailPrefix: String? = nil, state: EntityState? = nil) {
            self.namePrefix = namePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, max: 256)
            try self.validate(self.primaryEmailPrefix, name: "primaryEmailPrefix", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case namePrefix = "NamePrefix"
            case primaryEmailPrefix = "PrimaryEmailPrefix"
            case state = "State"
        }
    }

    public struct ListResourcesRequest: AWSEncodableShape {
        /// Limit the resource search results based on the filter criteria. You can only use one filter per request.
        public let filters: ListResourcesFilters?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier for the organization under which the resources exist.
        public let organizationId: String

        public init(filters: ListResourcesFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListResourcesResponse: AWSDecodableShape {
        ///  The token used to paginate through all the organization's resources. While results are still available, it has an associated value. When the last page is reached, the token is empty.
        public let nextToken: String?
        /// One page of the organization's resource representation.
        public let resources: [Resource]?

        public init(nextToken: String? = nil, resources: [Resource]? = nil) {
            self.nextToken = nextToken
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resources = "Resources"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws:workmail:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tag key-value pairs.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListUsersFilters: AWSEncodableShape {
        /// Filters only users with the provided display name prefix.
        public let displayNamePrefix: String?
        /// Filters only users with the provided email prefix.
        public let primaryEmailPrefix: String?
        /// Filters only users with the provided state.
        public let state: EntityState?
        /// Filters only users with the provided username prefix.
        public let usernamePrefix: String?

        public init(displayNamePrefix: String? = nil, primaryEmailPrefix: String? = nil, state: EntityState? = nil, usernamePrefix: String? = nil) {
            self.displayNamePrefix = displayNamePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
            self.usernamePrefix = usernamePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.displayNamePrefix, name: "displayNamePrefix", parent: name, max: 256)
            try self.validate(self.primaryEmailPrefix, name: "primaryEmailPrefix", parent: name, max: 256)
            try self.validate(self.usernamePrefix, name: "usernamePrefix", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case displayNamePrefix = "DisplayNamePrefix"
            case primaryEmailPrefix = "PrimaryEmailPrefix"
            case state = "State"
            case usernamePrefix = "UsernamePrefix"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        /// Limit the user search results based on the filter criteria. You can only use one filter per request.
        public let filters: ListUsersFilters?
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
        public let nextToken: String?
        /// The identifier for the organization under which the users exist.
        public let organizationId: String

        public init(filters: ListUsersFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*|[a-zA-Z0-9/+=]{1,1024}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationId = "OrganizationId"
        }
    }

    public struct ListUsersResponse: AWSDecodableShape {
        ///  The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
        public let nextToken: String?
        /// The overview of users for an organization.
        public let users: [User]?

        public init(nextToken: String? = nil, users: [User]? = nil) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case users = "Users"
        }
    }

    public struct MailDomainSummary: AWSDecodableShape {
        /// Whether the domain is default or not.
        public let defaultDomain: Bool?
        /// The domain name.
        public let domainName: String?

        public init(defaultDomain: Bool? = nil, domainName: String? = nil) {
            self.defaultDomain = defaultDomain
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case defaultDomain = "DefaultDomain"
            case domainName = "DomainName"
        }
    }

    public struct MailboxExportJob: AWSDecodableShape {
        /// The mailbox export job description.
        public let description: String?
        /// The mailbox export job end timestamp.
        public let endTime: Date?
        /// The identifier of the user or resource associated with the mailbox.
        public let entityId: String?
        /// The estimated progress of the mailbox export job, in percentage points.
        public let estimatedProgress: Int?
        /// The identifier of the mailbox export job.
        public let jobId: String?
        /// The name of the S3 bucket.
        public let s3BucketName: String?
        /// The path to the S3 bucket and file that the mailbox export job exports to.
        public let s3Path: String?
        /// The mailbox export job start timestamp.
        public let startTime: Date?
        /// The state of the mailbox export job.
        public let state: MailboxExportJobState?

        public init(description: String? = nil, endTime: Date? = nil, entityId: String? = nil, estimatedProgress: Int? = nil, jobId: String? = nil, s3BucketName: String? = nil, s3Path: String? = nil, startTime: Date? = nil, state: MailboxExportJobState? = nil) {
            self.description = description
            self.endTime = endTime
            self.entityId = entityId
            self.estimatedProgress = estimatedProgress
            self.jobId = jobId
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case endTime = "EndTime"
            case entityId = "EntityId"
            case estimatedProgress = "EstimatedProgress"
            case jobId = "JobId"
            case s3BucketName = "S3BucketName"
            case s3Path = "S3Path"
            case startTime = "StartTime"
            case state = "State"
        }
    }

    public struct Member: AWSDecodableShape {
        /// The date indicating when the member was disabled from WorkMail use.
        public let disabledDate: Date?
        /// The date indicating when the member was enabled for WorkMail use.
        public let enabledDate: Date?
        /// The identifier of the member.
        public let id: String?
        /// The name of the member.
        public let name: String?
        /// The state of the member, which can be ENABLED, DISABLED, or DELETED.
        public let state: EntityState?
        /// A member can be a user or group.
        public let type: MemberType?

        public init(disabledDate: Date? = nil, enabledDate: Date? = nil, id: String? = nil, name: String? = nil, state: EntityState? = nil, type: MemberType? = nil) {
            self.disabledDate = disabledDate
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case disabledDate = "DisabledDate"
            case enabledDate = "EnabledDate"
            case id = "Id"
            case name = "Name"
            case state = "State"
            case type = "Type"
        }
    }

    public struct MobileDeviceAccessMatchedRule: AWSDecodableShape {
        /// Identifier of the rule that a simulated user matches.
        public let mobileDeviceAccessRuleId: String?
        /// Name of a rule that a simulated user matches.
        public let name: String?

        public init(mobileDeviceAccessRuleId: String? = nil, name: String? = nil) {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
            case name = "Name"
        }
    }

    public struct MobileDeviceAccessOverride: AWSDecodableShape {
        /// The date the override was first created.
        public let dateCreated: Date?
        /// The date the override was last modified.
        public let dateModified: Date?
        /// A description of the override.
        public let description: String?
        /// The device to which the override applies.
        public let deviceId: String?
        /// The effect of the override, ALLOW or DENY.
        public let effect: MobileDeviceAccessRuleEffect?
        /// The WorkMail user to which the access override applies.
        public let userId: String?

        public init(dateCreated: Date? = nil, dateModified: Date? = nil, description: String? = nil, deviceId: String? = nil, effect: MobileDeviceAccessRuleEffect? = nil, userId: String? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case description = "Description"
            case deviceId = "DeviceId"
            case effect = "Effect"
            case userId = "UserId"
        }
    }

    public struct MobileDeviceAccessRule: AWSDecodableShape {
        /// The date and time at which an access rule was created.
        public let dateCreated: Date?
        /// The date and time at which an access rule was modified.
        public let dateModified: Date?
        /// The description of a mobile access rule.
        public let description: String?
        /// Device models that a rule will match.
        public let deviceModels: [String]?
        /// Device operating systems that a rule will match.
        public let deviceOperatingSystems: [String]?
        /// Device types that a rule will match.
        public let deviceTypes: [String]?
        /// Device user agents that a rule will match.
        public let deviceUserAgents: [String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public let effect: MobileDeviceAccessRuleEffect?
        /// The ID assigned to a mobile access rule.
        public let mobileDeviceAccessRuleId: String?
        /// The name of a mobile access rule.
        public let name: String?
        /// Device models that a rule will not match. All other device models will match.
        public let notDeviceModels: [String]?
        /// Device operating systems that a rule will not match. All other device types will match.
        public let notDeviceOperatingSystems: [String]?
        /// Device types that a rule will not match. All other device types will match.
        public let notDeviceTypes: [String]?
        /// Device user agents that a rule will not match. All other device user agents will match.
        public let notDeviceUserAgents: [String]?

        public init(dateCreated: Date? = nil, dateModified: Date? = nil, description: String? = nil, deviceModels: [String]? = nil, deviceOperatingSystems: [String]? = nil, deviceTypes: [String]? = nil, deviceUserAgents: [String]? = nil, effect: MobileDeviceAccessRuleEffect? = nil, mobileDeviceAccessRuleId: String? = nil, name: String? = nil, notDeviceModels: [String]? = nil, notDeviceOperatingSystems: [String]? = nil, notDeviceTypes: [String]? = nil, notDeviceUserAgents: [String]? = nil) {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
        }

        private enum CodingKeys: String, CodingKey {
            case dateCreated = "DateCreated"
            case dateModified = "DateModified"
            case description = "Description"
            case deviceModels = "DeviceModels"
            case deviceOperatingSystems = "DeviceOperatingSystems"
            case deviceTypes = "DeviceTypes"
            case deviceUserAgents = "DeviceUserAgents"
            case effect = "Effect"
            case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
            case name = "Name"
            case notDeviceModels = "NotDeviceModels"
            case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
            case notDeviceTypes = "NotDeviceTypes"
            case notDeviceUserAgents = "NotDeviceUserAgents"
        }
    }

    public struct OrganizationSummary: AWSDecodableShape {
        /// The alias associated with the organization.
        public let alias: String?
        /// The default email domain associated with the organization.
        public let defaultMailDomain: String?
        /// The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.
        public let errorMessage: String?
        /// The identifier associated with the organization.
        public let organizationId: String?
        /// The state associated with the organization.
        public let state: String?

        public init(alias: String? = nil, defaultMailDomain: String? = nil, errorMessage: String? = nil, organizationId: String? = nil, state: String? = nil) {
            self.alias = alias
            self.defaultMailDomain = defaultMailDomain
            self.errorMessage = errorMessage
            self.organizationId = organizationId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case defaultMailDomain = "DefaultMailDomain"
            case errorMessage = "ErrorMessage"
            case organizationId = "OrganizationId"
            case state = "State"
        }
    }

    public struct Permission: AWSDecodableShape {
        /// The identifier of the user, group, or resource to which the permissions are granted.
        public let granteeId: String
        /// The type of user, group, or resource referred to in GranteeId.
        public let granteeType: MemberType
        /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
        public let permissionValues: [PermissionType]

        public init(granteeId: String, granteeType: MemberType, permissionValues: [PermissionType]) {
            self.granteeId = granteeId
            self.granteeType = granteeType
            self.permissionValues = permissionValues
        }

        private enum CodingKeys: String, CodingKey {
            case granteeId = "GranteeId"
            case granteeType = "GranteeType"
            case permissionValues = "PermissionValues"
        }
    }

    public struct PutAccessControlRuleRequest: AWSEncodableShape {
        /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public let actions: [String]?
        /// The rule description.
        public let description: String
        /// The rule effect.
        public let effect: AccessControlRuleEffect
        /// Impersonation role IDs to include in the rule.
        public let impersonationRoleIds: [String]?
        /// IPv4 CIDR ranges to include in the rule.
        public let ipRanges: [String]?
        /// The rule name.
        public let name: String
        /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public let notActions: [String]?
        /// Impersonation role IDs to exclude from the rule.
        public let notImpersonationRoleIds: [String]?
        /// IPv4 CIDR ranges to exclude from the rule.
        public let notIpRanges: [String]?
        /// User IDs to exclude from the rule.
        public let notUserIds: [String]?
        /// The identifier of the organization.
        public let organizationId: String
        /// User IDs to include in the rule.
        public let userIds: [String]?

        public init(actions: [String]? = nil, description: String, effect: AccessControlRuleEffect, impersonationRoleIds: [String]? = nil, ipRanges: [String]? = nil, name: String, notActions: [String]? = nil, notImpersonationRoleIds: [String]? = nil, notIpRanges: [String]? = nil, notUserIds: [String]? = nil, organizationId: String, userIds: [String]? = nil) {
            self.actions = actions
            self.description = description
            self.effect = effect
            self.impersonationRoleIds = impersonationRoleIds
            self.ipRanges = ipRanges
            self.name = name
            self.notActions = notActions
            self.notImpersonationRoleIds = notImpersonationRoleIds
            self.notIpRanges = notIpRanges
            self.notUserIds = notUserIds
            self.organizationId = organizationId
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try validate($0, name: "actions[]", parent: name, max: 64)
                try validate($0, name: "actions[]", parent: name, min: 1)
                try validate($0, name: "actions[]", parent: name, pattern: "^[a-zA-Z]+$")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.impersonationRoleIds?.forEach {
                try validate($0, name: "impersonationRoleIds[]", parent: name, max: 64)
                try validate($0, name: "impersonationRoleIds[]", parent: name, min: 1)
                try validate($0, name: "impersonationRoleIds[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.validate(self.impersonationRoleIds, name: "impersonationRoleIds", parent: name, max: 10)
            try self.ipRanges?.forEach {
                try validate($0, name: "ipRanges[]", parent: name, max: 18)
                try validate($0, name: "ipRanges[]", parent: name, min: 1)
                try validate($0, name: "ipRanges[]", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$")
            }
            try self.validate(self.ipRanges, name: "ipRanges", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.notActions?.forEach {
                try validate($0, name: "notActions[]", parent: name, max: 64)
                try validate($0, name: "notActions[]", parent: name, min: 1)
                try validate($0, name: "notActions[]", parent: name, pattern: "^[a-zA-Z]+$")
            }
            try self.validate(self.notActions, name: "notActions", parent: name, max: 10)
            try self.notImpersonationRoleIds?.forEach {
                try validate($0, name: "notImpersonationRoleIds[]", parent: name, max: 64)
                try validate($0, name: "notImpersonationRoleIds[]", parent: name, min: 1)
                try validate($0, name: "notImpersonationRoleIds[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.validate(self.notImpersonationRoleIds, name: "notImpersonationRoleIds", parent: name, max: 10)
            try self.notIpRanges?.forEach {
                try validate($0, name: "notIpRanges[]", parent: name, max: 18)
                try validate($0, name: "notIpRanges[]", parent: name, min: 1)
                try validate($0, name: "notIpRanges[]", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$")
            }
            try self.validate(self.notIpRanges, name: "notIpRanges", parent: name, max: 1024)
            try self.notUserIds?.forEach {
                try validate($0, name: "notUserIds[]", parent: name, max: 256)
                try validate($0, name: "notUserIds[]", parent: name, min: 12)
            }
            try self.validate(self.notUserIds, name: "notUserIds", parent: name, max: 10)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 256)
                try validate($0, name: "userIds[]", parent: name, min: 12)
            }
            try self.validate(self.userIds, name: "userIds", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case effect = "Effect"
            case impersonationRoleIds = "ImpersonationRoleIds"
            case ipRanges = "IpRanges"
            case name = "Name"
            case notActions = "NotActions"
            case notImpersonationRoleIds = "NotImpersonationRoleIds"
            case notIpRanges = "NotIpRanges"
            case notUserIds = "NotUserIds"
            case organizationId = "OrganizationId"
            case userIds = "UserIds"
        }
    }

    public struct PutAccessControlRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutEmailMonitoringConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
        public let logGroupArn: String
        /// The ID of the organization for which the email monitoring configuration is set.
        public let organizationId: String
        /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
        public let roleArn: String

        public init(logGroupArn: String, organizationId: String, roleArn: String) {
            self.logGroupArn = logGroupArn
            self.organizationId = organizationId
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, max: 562)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, min: 47)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws:logs:[a-z\\-0-9]*:[0-9]{12}:log-group:([\\.\\-_/#A-Za-z0-9]+):\\*$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "LogGroupArn"
            case organizationId = "OrganizationId"
            case roleArn = "RoleArn"
        }
    }

    public struct PutEmailMonitoringConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutInboundDmarcSettingsRequest: AWSEncodableShape {
        /// Enforces or suspends a policy after it's applied.
        public let enforced: Bool
        /// The ID of the organization that you are applying the DMARC policy to.
        public let organizationId: String

        public init(enforced: Bool, organizationId: String) {
            self.enforced = enforced
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case enforced = "Enforced"
            case organizationId = "OrganizationId"
        }
    }

    public struct PutInboundDmarcSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutMailboxPermissionsRequest: AWSEncodableShape {
        /// The identifier of the user or resource for which to update mailbox permissions. The identifier can be UserId, ResourceID, or Group Id, Username, Resourcename, or Groupname, or email.   Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// The identifier of the user, group, or resource to which to grant the permissions. The identifier can be UserId, ResourceID, or Group Id, Username, Resourcename, or Groupname, or email.   Grantee ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Email address: grantee@domain.tld   Grantee name: grantee
        public let granteeId: String
        /// The identifier of the organization under which the user, group, or resource exists.
        public let organizationId: String
        /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
        public let permissionValues: [PermissionType]

        public init(entityId: String, granteeId: String, organizationId: String, permissionValues: [PermissionType]) {
            self.entityId = entityId
            self.granteeId = granteeId
            self.organizationId = organizationId
            self.permissionValues = permissionValues
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.granteeId, name: "granteeId", parent: name, max: 256)
            try self.validate(self.granteeId, name: "granteeId", parent: name, min: 1)
            try self.validate(self.granteeId, name: "granteeId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case granteeId = "GranteeId"
            case organizationId = "OrganizationId"
            case permissionValues = "PermissionValues"
        }
    }

    public struct PutMailboxPermissionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutMobileDeviceAccessOverrideRequest: AWSEncodableShape {
        /// A description of the override.
        public let description: String?
        /// The mobile device for which you create the override. DeviceId is case insensitive.
        public let deviceId: String
        /// The effect of the override, ALLOW or DENY.
        public let effect: MobileDeviceAccessRuleEffect
        /// Identifies the WorkMail organization for which you create the override.
        public let organizationId: String
        /// The WorkMail user for which you create the override. Accepts the following types of user identities:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234    Email address: user@domain.tld    User name: user
        public let userId: String

        public init(description: String? = nil, deviceId: String, effect: MobileDeviceAccessRuleEffect, organizationId: String, userId: String) {
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 32)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case deviceId = "DeviceId"
            case effect = "Effect"
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct PutMobileDeviceAccessOverrideResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutRetentionPolicyRequest: AWSEncodableShape {
        /// The retention policy description.
        public let description: String?
        /// The retention policy folder configurations.
        public let folderConfigurations: [FolderConfiguration]
        /// The retention policy ID.
        public let id: String?
        /// The retention policy name.
        public let name: String
        /// The organization ID.
        public let organizationId: String

        public init(description: String? = nil, folderConfigurations: [FolderConfiguration], id: String? = nil, name: String, organizationId: String) {
            self.description = description
            self.folderConfigurations = folderConfigurations
            self.id = id
            self.name = name
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w\\d\\s\\S\\-!?=,.;:'_]+$")
            try self.folderConfigurations.forEach {
                try $0.validate(name: "\(name).folderConfigurations[]")
            }
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case folderConfigurations = "FolderConfigurations"
            case id = "Id"
            case name = "Name"
            case organizationId = "OrganizationId"
        }
    }

    public struct PutRetentionPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RedactedEwsAvailabilityProvider: AWSDecodableShape {
        /// The endpoint of the remote EWS server.
        public let ewsEndpoint: String?
        /// The username used to authenticate the remote EWS server.
        public let ewsUsername: String?

        public init(ewsEndpoint: String? = nil, ewsUsername: String? = nil) {
            self.ewsEndpoint = ewsEndpoint
            self.ewsUsername = ewsUsername
        }

        private enum CodingKeys: String, CodingKey {
            case ewsEndpoint = "EwsEndpoint"
            case ewsUsername = "EwsUsername"
        }
    }

    public struct RegisterMailDomainRequest: AWSEncodableShape {
        /// Idempotency token used when retrying requests.
        public let clientToken: String?
        /// The name of the mail domain to create in WorkMail and SES.
        public let domainName: String
        /// The WorkMail organization under which you're creating the domain.
        public let organizationId: String

        public init(clientToken: String? = RegisterMailDomainRequest.idempotencyToken(), domainName: String, organizationId: String) {
            self.clientToken = clientToken
            self.domainName = domainName
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 209)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case domainName = "DomainName"
            case organizationId = "OrganizationId"
        }
    }

    public struct RegisterMailDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterToWorkMailRequest: AWSEncodableShape {
        /// The email for the user, group, or resource to be updated.
        public let email: String
        /// The identifier for the user, group, or resource to be updated. The identifier can accept UserId, ResourceId, or GroupId, or Username, Resourcename, or Groupname. The following identity formats are available:   Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Entity name: entity
        public let entityId: String
        /// The identifier for the organization under which the user, group, or resource exists.
        public let organizationId: String

        public init(email: String, entityId: String, organizationId: String) {
            self.email = email
            self.entityId = entityId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9._%+-]{1,64}@[a-zA-Z0-9.-]+\\.[a-zA-Z-]{2,}$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
        }
    }

    public struct RegisterToWorkMailResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResetPasswordRequest: AWSEncodableShape {
        /// The identifier of the organization that contains the user for which the password is reset.
        public let organizationId: String
        /// The new password for the user.
        public let password: String
        /// The identifier of the user for whom the password is reset.
        public let userId: String

        public init(organizationId: String, password: String, userId: String) {
            self.organizationId = organizationId
            self.password = password
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.password, name: "password", parent: name, max: 256)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case organizationId = "OrganizationId"
            case password = "Password"
            case userId = "UserId"
        }
    }

    public struct ResetPasswordResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Resource: AWSDecodableShape {
        /// Resource description.
        public let description: String?
        /// The date indicating when the resource was disabled from WorkMail use.
        public let disabledDate: Date?
        /// The email of the resource.
        public let email: String?
        /// The date indicating when the resource was enabled for WorkMail use.
        public let enabledDate: Date?
        /// The identifier of the resource.
        public let id: String?
        /// The name of the resource.
        public let name: String?
        /// The state of the resource, which can be ENABLED, DISABLED, or DELETED.
        public let state: EntityState?
        /// The type of the resource: equipment or room.
        public let type: ResourceType?

        public init(description: String? = nil, disabledDate: Date? = nil, email: String? = nil, enabledDate: Date? = nil, id: String? = nil, name: String? = nil, state: EntityState? = nil, type: ResourceType? = nil) {
            self.description = description
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case disabledDate = "DisabledDate"
            case email = "Email"
            case enabledDate = "EnabledDate"
            case id = "Id"
            case name = "Name"
            case state = "State"
            case type = "Type"
        }
    }

    public struct StartMailboxExportJobRequest: AWSEncodableShape {
        /// The idempotency token for the client request.
        public let clientToken: String
        /// The mailbox export job description.
        public let description: String?
        /// The identifier of the user or resource associated with the mailbox. The identifier can accept UserId or ResourceId, Username or Resourcename, or email. The following identity formats are available:   Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789 , or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
        public let kmsKeyArn: String
        /// The identifier associated with the organization.
        public let organizationId: String
        /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the S3 bucket.
        public let roleArn: String
        /// The name of the S3 bucket.
        public let s3BucketName: String
        /// The S3 bucket prefix.
        public let s3Prefix: String

        public init(clientToken: String = StartMailboxExportJobRequest.idempotencyToken(), description: String? = nil, entityId: String, kmsKeyArn: String, organizationId: String, roleArn: String, s3BucketName: String, s3Prefix: String) {
            self.clientToken = clientToken
            self.description = description
            self.entityId = entityId
            self.kmsKeyArn = kmsKeyArn
            self.organizationId = organizationId
            self.roleArn = roleArn
            self.s3BucketName = s3BucketName
            self.s3Prefix = s3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7e]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1023)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[A-Za-z0-9.-]+$")
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, max: 1023)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, min: 1)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, pattern: "^[A-Za-z0-9!_.*'()/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case entityId = "EntityId"
            case kmsKeyArn = "KmsKeyArn"
            case organizationId = "OrganizationId"
            case roleArn = "RoleArn"
            case s3BucketName = "S3BucketName"
            case s3Prefix = "S3Prefix"
        }
    }

    public struct StartMailboxExportJobResponse: AWSDecodableShape {
        /// The job ID.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tag key-value pairs.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws:workmail:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TestAvailabilityConfigurationRequest: AWSEncodableShape {
        /// The domain to which the provider applies. If this field is provided, a stored availability provider associated to this domain name will be tested.
        public let domainName: String?
        public let ewsProvider: EwsAvailabilityProvider?
        public let lambdaProvider: LambdaAvailabilityProvider?
        /// The WorkMail organization where the availability provider will be tested.
        public let organizationId: String

        public init(domainName: String? = nil, ewsProvider: EwsAvailabilityProvider? = nil, lambdaProvider: LambdaAvailabilityProvider? = nil, organizationId: String) {
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.ewsProvider?.validate(name: "\(name).ewsProvider")
            try self.lambdaProvider?.validate(name: "\(name).lambdaProvider")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case ewsProvider = "EwsProvider"
            case lambdaProvider = "LambdaProvider"
            case organizationId = "OrganizationId"
        }
    }

    public struct TestAvailabilityConfigurationResponse: AWSDecodableShape {
        /// String containing the reason for a failed test if TestPassed is false.
        public let failureReason: String?
        /// Boolean indicating whether the test passed or failed.
        public let testPassed: Bool?

        public init(failureReason: String? = nil, testPassed: Bool? = nil) {
            self.failureReason = failureReason
            self.testPassed = testPassed
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case testPassed = "TestPassed"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws:workmail:[a-z0-9-]*:[a-z0-9-]+:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAvailabilityConfigurationRequest: AWSEncodableShape {
        /// The domain to which the provider applies the availability configuration.
        public let domainName: String
        /// The EWS availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
        public let ewsProvider: EwsAvailabilityProvider?
        /// The Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
        public let lambdaProvider: LambdaAvailabilityProvider?
        /// The WorkMail organization for which the AvailabilityConfiguration will be updated.
        public let organizationId: String

        public init(domainName: String, ewsProvider: EwsAvailabilityProvider? = nil, lambdaProvider: LambdaAvailabilityProvider? = nil, organizationId: String) {
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.ewsProvider?.validate(name: "\(name).ewsProvider")
            try self.lambdaProvider?.validate(name: "\(name).lambdaProvider")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case ewsProvider = "EwsProvider"
            case lambdaProvider = "LambdaProvider"
            case organizationId = "OrganizationId"
        }
    }

    public struct UpdateAvailabilityConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDefaultMailDomainRequest: AWSEncodableShape {
        /// The domain name that will become the default domain.
        public let domainName: String
        /// The WorkMail organization for which to list domains.
        public let organizationId: String

        public init(domainName: String, organizationId: String) {
            self.domainName = domainName
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 209)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case organizationId = "OrganizationId"
        }
    }

    public struct UpdateDefaultMailDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        /// The identifier for the group to be updated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:   Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: group@domain.tld   Group name: group
        public let groupId: String
        /// If enabled, the group is hidden from the global address list.
        public let hiddenFromGlobalAddressList: Bool?
        /// The identifier for the organization under which the group exists.
        public let organizationId: String

        public init(groupId: String, hiddenFromGlobalAddressList: Bool? = nil, organizationId: String) {
            self.groupId = groupId
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case organizationId = "OrganizationId"
        }
    }

    public struct UpdateGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateImpersonationRoleRequest: AWSEncodableShape {
        /// The updated impersonation role description.
        public let description: String?
        /// The ID of the impersonation role to update.
        public let impersonationRoleId: String
        /// The updated impersonation role name.
        public let name: String
        /// The WorkMail organization that contains the impersonation role to update.
        public let organizationId: String
        /// The updated list of rules.
        public let rules: [ImpersonationRule]
        /// The updated impersonation role type.
        public let type: ImpersonationRoleType

        public init(description: String? = nil, impersonationRoleId: String, name: String, organizationId: String, rules: [ImpersonationRule], type: ImpersonationRoleType) {
            self.description = description
            self.impersonationRoleId = impersonationRoleId
            self.name = name
            self.organizationId = organizationId
            self.rules = rules
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F\\x3C\\x3E\\x5C]+$")
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, max: 64)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, min: 1)
            try self.validate(self.impersonationRoleId, name: "impersonationRoleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\x00-\\x1F\\x7F\\x3C\\x3E\\x5C]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case impersonationRoleId = "ImpersonationRoleId"
            case name = "Name"
            case organizationId = "OrganizationId"
            case rules = "Rules"
            case type = "Type"
        }
    }

    public struct UpdateImpersonationRoleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMailboxQuotaRequest: AWSEncodableShape {
        /// The updated mailbox quota, in MB, for the specified user.
        public let mailboxQuota: Int
        /// The identifier for the organization that contains the user for whom to update the mailbox quota.
        public let organizationId: String
        /// The identifer for the user for whom to update the mailbox quota. The identifier can be the UserId, Username, or email. The following identity formats are available:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: user@domain.tld   User name: user
        public let userId: String

        public init(mailboxQuota: Int, organizationId: String, userId: String) {
            self.mailboxQuota = mailboxQuota
            self.organizationId = organizationId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.mailboxQuota, name: "mailboxQuota", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case mailboxQuota = "MailboxQuota"
            case organizationId = "OrganizationId"
            case userId = "UserId"
        }
    }

    public struct UpdateMailboxQuotaResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMobileDeviceAccessRuleRequest: AWSEncodableShape {
        /// The updated rule description.
        public let description: String?
        /// Device models that the updated rule will match.
        public let deviceModels: [String]?
        /// Device operating systems that the updated rule will match.
        public let deviceOperatingSystems: [String]?
        /// Device types that the updated rule will match.
        public let deviceTypes: [String]?
        /// User agents that the updated rule will match.
        public let deviceUserAgents: [String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public let effect: MobileDeviceAccessRuleEffect
        /// The identifier of the rule to be updated.
        public let mobileDeviceAccessRuleId: String
        /// The updated rule name.
        public let name: String
        /// Device models that the updated rule will not match. All other device models will match.
        public let notDeviceModels: [String]?
        /// Device operating systems that the updated rule will not match. All other device operating systems will match.
        public let notDeviceOperatingSystems: [String]?
        /// Device types that the updated rule will not match. All other device types will match.
        public let notDeviceTypes: [String]?
        /// User agents that the updated rule will not match. All other user agents will match.
        public let notDeviceUserAgents: [String]?
        /// The WorkMail organization under which the rule will be updated.
        public let organizationId: String

        public init(description: String? = nil, deviceModels: [String]? = nil, deviceOperatingSystems: [String]? = nil, deviceTypes: [String]? = nil, deviceUserAgents: [String]? = nil, effect: MobileDeviceAccessRuleEffect, mobileDeviceAccessRuleId: String, name: String, notDeviceModels: [String]? = nil, notDeviceOperatingSystems: [String]? = nil, notDeviceTypes: [String]? = nil, notDeviceUserAgents: [String]? = nil, organizationId: String) {
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]+$")
            try self.deviceModels?.forEach {
                try validate($0, name: "deviceModels[]", parent: name, max: 256)
                try validate($0, name: "deviceModels[]", parent: name, min: 1)
                try validate($0, name: "deviceModels[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceModels, name: "deviceModels", parent: name, max: 10)
            try self.validate(self.deviceModels, name: "deviceModels", parent: name, min: 1)
            try self.deviceOperatingSystems?.forEach {
                try validate($0, name: "deviceOperatingSystems[]", parent: name, max: 256)
                try validate($0, name: "deviceOperatingSystems[]", parent: name, min: 1)
                try validate($0, name: "deviceOperatingSystems[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceOperatingSystems, name: "deviceOperatingSystems", parent: name, max: 10)
            try self.validate(self.deviceOperatingSystems, name: "deviceOperatingSystems", parent: name, min: 1)
            try self.deviceTypes?.forEach {
                try validate($0, name: "deviceTypes[]", parent: name, max: 256)
                try validate($0, name: "deviceTypes[]", parent: name, min: 1)
                try validate($0, name: "deviceTypes[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, max: 10)
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, min: 1)
            try self.deviceUserAgents?.forEach {
                try validate($0, name: "deviceUserAgents[]", parent: name, max: 256)
                try validate($0, name: "deviceUserAgents[]", parent: name, min: 1)
                try validate($0, name: "deviceUserAgents[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.deviceUserAgents, name: "deviceUserAgents", parent: name, max: 10)
            try self.validate(self.deviceUserAgents, name: "deviceUserAgents", parent: name, min: 1)
            try self.validate(self.mobileDeviceAccessRuleId, name: "mobileDeviceAccessRuleId", parent: name, max: 64)
            try self.validate(self.mobileDeviceAccessRuleId, name: "mobileDeviceAccessRuleId", parent: name, min: 1)
            try self.validate(self.mobileDeviceAccessRuleId, name: "mobileDeviceAccessRuleId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S\\s]+$")
            try self.notDeviceModels?.forEach {
                try validate($0, name: "notDeviceModels[]", parent: name, max: 256)
                try validate($0, name: "notDeviceModels[]", parent: name, min: 1)
                try validate($0, name: "notDeviceModels[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceModels, name: "notDeviceModels", parent: name, max: 10)
            try self.validate(self.notDeviceModels, name: "notDeviceModels", parent: name, min: 1)
            try self.notDeviceOperatingSystems?.forEach {
                try validate($0, name: "notDeviceOperatingSystems[]", parent: name, max: 256)
                try validate($0, name: "notDeviceOperatingSystems[]", parent: name, min: 1)
                try validate($0, name: "notDeviceOperatingSystems[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceOperatingSystems, name: "notDeviceOperatingSystems", parent: name, max: 10)
            try self.validate(self.notDeviceOperatingSystems, name: "notDeviceOperatingSystems", parent: name, min: 1)
            try self.notDeviceTypes?.forEach {
                try validate($0, name: "notDeviceTypes[]", parent: name, max: 256)
                try validate($0, name: "notDeviceTypes[]", parent: name, min: 1)
                try validate($0, name: "notDeviceTypes[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceTypes, name: "notDeviceTypes", parent: name, max: 10)
            try self.validate(self.notDeviceTypes, name: "notDeviceTypes", parent: name, min: 1)
            try self.notDeviceUserAgents?.forEach {
                try validate($0, name: "notDeviceUserAgents[]", parent: name, max: 256)
                try validate($0, name: "notDeviceUserAgents[]", parent: name, min: 1)
                try validate($0, name: "notDeviceUserAgents[]", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            }
            try self.validate(self.notDeviceUserAgents, name: "notDeviceUserAgents", parent: name, max: 10)
            try self.validate(self.notDeviceUserAgents, name: "notDeviceUserAgents", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case deviceModels = "DeviceModels"
            case deviceOperatingSystems = "DeviceOperatingSystems"
            case deviceTypes = "DeviceTypes"
            case deviceUserAgents = "DeviceUserAgents"
            case effect = "Effect"
            case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
            case name = "Name"
            case notDeviceModels = "NotDeviceModels"
            case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
            case notDeviceTypes = "NotDeviceTypes"
            case notDeviceUserAgents = "NotDeviceUserAgents"
            case organizationId = "OrganizationId"
        }
    }

    public struct UpdateMobileDeviceAccessRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePrimaryEmailAddressRequest: AWSEncodableShape {
        /// The value of the email to be updated as primary.
        public let email: String
        /// The user, group, or resource to update. The identifier can accept UseriD, ResourceId, or GroupId, Username, Resourcename, or Groupname, or email. The following identity formats are available:   Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234   Email address: entity@domain.tld   Entity name: entity
        public let entityId: String
        /// The organization that contains the user, group, or resource to update.
        public let organizationId: String

        public init(email: String, entityId: String, organizationId: String) {
            self.email = email
            self.entityId = entityId
            self.organizationId = organizationId
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9._%+-]{1,64}@[a-zA-Z0-9.-]+\\.[a-zA-Z-]{2,}$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case entityId = "EntityId"
            case organizationId = "OrganizationId"
        }
    }

    public struct UpdatePrimaryEmailAddressResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResourceRequest: AWSEncodableShape {
        /// The resource's booking options to be updated.
        public let bookingOptions: BookingOptions?
        /// Updates the resource description.
        public let description: String?
        /// If enabled, the resource is hidden from the global address list.
        public let hiddenFromGlobalAddressList: Bool?
        /// The name of the resource to be updated.
        public let name: String?
        /// The identifier associated with the organization for which the resource is updated.
        public let organizationId: String
        /// The identifier of the resource to be updated. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:   Resource ID: r-0123456789a0123456789b0123456789   Email address: resource@domain.tld   Resource name: resource
        public let resourceId: String
        /// Updates the resource type.
        public let type: ResourceType?

        public init(bookingOptions: BookingOptions? = nil, description: String? = nil, hiddenFromGlobalAddressList: Bool? = nil, name: String? = nil, organizationId: String, resourceId: String, type: ResourceType? = nil) {
            self.bookingOptions = bookingOptions
            self.description = description
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.name = name
            self.organizationId = organizationId
            self.resourceId = resourceId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, max: 20)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w\\-.]+(@[a-zA-Z0-9.\\-]+\\.[a-zA-Z0-9-]{2,})?$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bookingOptions = "BookingOptions"
            case description = "Description"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case name = "Name"
            case organizationId = "OrganizationId"
            case resourceId = "ResourceId"
            case type = "Type"
        }
    }

    public struct UpdateResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// Updates the user's city.
        public let city: String?
        /// Updates the user's company.
        public let company: String?
        /// Updates the user's country.
        public let country: String?
        /// Updates the user's department.
        public let department: String?
        /// Updates the display name of the user.
        public let displayName: String?
        /// Updates the user's first name.
        public let firstName: String?
        /// If enabled, the user is hidden from the global address list.
        public let hiddenFromGlobalAddressList: Bool?
        /// Updates the user's initials.
        public let initials: String?
        /// Updates the user's job title.
        public let jobTitle: String?
        /// Updates the user's last name.
        public let lastName: String?
        /// Updates the user's office.
        public let office: String?
        /// The identifier for the organization under which the user exists.
        public let organizationId: String
        /// Updates the user role. You cannot pass SYSTEM_USER or RESOURCE.
        public let role: UserRole?
        /// Updates the user's street address.
        public let street: String?
        /// Updates the user's contact details.
        public let telephone: String?
        /// The identifier for the user to be updated. The identifier can be the UserId, Username, or email. The following identity formats are available:   User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234   Email address: user@domain.tld   User name: user
        public let userId: String
        /// Updates the user's zipcode.
        public let zipCode: String?

        public init(city: String? = nil, company: String? = nil, country: String? = nil, department: String? = nil, displayName: String? = nil, firstName: String? = nil, hiddenFromGlobalAddressList: Bool? = nil, initials: String? = nil, jobTitle: String? = nil, lastName: String? = nil, office: String? = nil, organizationId: String, role: UserRole? = nil, street: String? = nil, telephone: String? = nil, userId: String, zipCode: String? = nil) {
            self.city = city
            self.company = company
            self.country = country
            self.department = department
            self.displayName = displayName
            self.firstName = firstName
            self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
            self.initials = initials
            self.jobTitle = jobTitle
            self.lastName = lastName
            self.office = office
            self.organizationId = organizationId
            self.role = role
            self.street = street
            self.telephone = telephone
            self.userId = userId
            self.zipCode = zipCode
        }

        public func validate(name: String) throws {
            try self.validate(self.city, name: "city", parent: name, max: 256)
            try self.validate(self.company, name: "company", parent: name, max: 256)
            try self.validate(self.country, name: "country", parent: name, max: 256)
            try self.validate(self.department, name: "department", parent: name, max: 256)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.firstName, name: "firstName", parent: name, max: 256)
            try self.validate(self.initials, name: "initials", parent: name, max: 256)
            try self.validate(self.jobTitle, name: "jobTitle", parent: name, max: 256)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 256)
            try self.validate(self.office, name: "office", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 34)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^m-[0-9a-f]{32}$")
            try self.validate(self.street, name: "street", parent: name, max: 256)
            try self.validate(self.telephone, name: "telephone", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9._%+@-]+$")
            try self.validate(self.zipCode, name: "zipCode", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case company = "Company"
            case country = "Country"
            case department = "Department"
            case displayName = "DisplayName"
            case firstName = "FirstName"
            case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
            case initials = "Initials"
            case jobTitle = "JobTitle"
            case lastName = "LastName"
            case office = "Office"
            case organizationId = "OrganizationId"
            case role = "Role"
            case street = "Street"
            case telephone = "Telephone"
            case userId = "UserId"
            case zipCode = "ZipCode"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct User: AWSDecodableShape {
        /// The date indicating when the user was disabled from WorkMail use.
        public let disabledDate: Date?
        /// The display name of the user.
        public let displayName: String?
        /// The email of the user.
        public let email: String?
        /// The date indicating when the user was enabled for WorkMail use.
        public let enabledDate: Date?
        /// The identifier of the user.
        public let id: String?
        /// The name of the user.
        public let name: String?
        /// The state of the user, which can be ENABLED, DISABLED, or DELETED.
        public let state: EntityState?
        /// The role of the user.
        public let userRole: UserRole?

        public init(disabledDate: Date? = nil, displayName: String? = nil, email: String? = nil, enabledDate: Date? = nil, id: String? = nil, name: String? = nil, state: EntityState? = nil, userRole: UserRole? = nil) {
            self.disabledDate = disabledDate
            self.displayName = displayName
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.userRole = userRole
        }

        private enum CodingKeys: String, CodingKey {
            case disabledDate = "DisabledDate"
            case displayName = "DisplayName"
            case email = "Email"
            case enabledDate = "EnabledDate"
            case id = "Id"
            case name = "Name"
            case state = "State"
            case userRole = "UserRole"
        }
    }
}

// MARK: - Errors

/// Error enum for WorkMail
public struct WorkMailErrorType: AWSErrorType {
    enum Code: String {
        case directoryInUseException = "DirectoryInUseException"
        case directoryServiceAuthenticationFailedException = "DirectoryServiceAuthenticationFailedException"
        case directoryUnavailableException = "DirectoryUnavailableException"
        case emailAddressInUseException = "EmailAddressInUseException"
        case entityAlreadyRegisteredException = "EntityAlreadyRegisteredException"
        case entityNotFoundException = "EntityNotFoundException"
        case entityStateException = "EntityStateException"
        case invalidConfigurationException = "InvalidConfigurationException"
        case invalidCustomSesConfigurationException = "InvalidCustomSesConfigurationException"
        case invalidParameterException = "InvalidParameterException"
        case invalidPasswordException = "InvalidPasswordException"
        case limitExceededException = "LimitExceededException"
        case mailDomainInUseException = "MailDomainInUseException"
        case mailDomainNotFoundException = "MailDomainNotFoundException"
        case mailDomainStateException = "MailDomainStateException"
        case nameAvailabilityException = "NameAvailabilityException"
        case organizationNotFoundException = "OrganizationNotFoundException"
        case organizationStateException = "OrganizationStateException"
        case reservedNameException = "ReservedNameException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case tooManyTagsException = "TooManyTagsException"
        case unsupportedOperationException = "UnsupportedOperationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WorkMail
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The directory is already in use by another WorkMail organization in the same account and Region.
    public static var directoryInUseException: Self { .init(.directoryInUseException) }
    /// The directory service doesn't recognize the credentials supplied by WorkMail.
    public static var directoryServiceAuthenticationFailedException: Self { .init(.directoryServiceAuthenticationFailedException) }
    /// The directory is unavailable. It might be located in another Region or deleted.
    public static var directoryUnavailableException: Self { .init(.directoryUnavailableException) }
    /// The email address that you're trying to assign is already created for a different user, group, or resource.
    public static var emailAddressInUseException: Self { .init(.emailAddressInUseException) }
    /// The user, group, or resource that you're trying to register is already registered.
    public static var entityAlreadyRegisteredException: Self { .init(.entityAlreadyRegisteredException) }
    /// The identifier supplied for the user, group, or resource does not exist in your organization.
    public static var entityNotFoundException: Self { .init(.entityNotFoundException) }
    /// You are performing an operation on a user, group, or resource that isn't in the expected state, such as trying to delete an active user.
    public static var entityStateException: Self { .init(.entityStateException) }
    /// The configuration for a resource isn't valid. A resource must either be able to auto-respond to requests or have at least one delegate associated that can do so on its behalf.
    public static var invalidConfigurationException: Self { .init(.invalidConfigurationException) }
    /// You SES configuration has customizations that WorkMail cannot save. The error message lists the invalid setting. For examples of invalid settings, refer to  CreateReceiptRule.
    public static var invalidCustomSesConfigurationException: Self { .init(.invalidCustomSesConfigurationException) }
    /// One or more of the input parameters don't match the service's restrictions.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The supplied password doesn't match the minimum security constraints, such as length or use of special characters.
    public static var invalidPasswordException: Self { .init(.invalidPasswordException) }
    /// The request exceeds the limit of the resource.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The domain you're trying to change is in use by another user or organization in your account. See the error message for details.
    public static var mailDomainInUseException: Self { .init(.mailDomainInUseException) }
    /// The domain specified is not found in your organization.
    public static var mailDomainNotFoundException: Self { .init(.mailDomainNotFoundException) }
    /// After a domain has been added to the organization, it must be verified. The domain is not yet verified.
    public static var mailDomainStateException: Self { .init(.mailDomainStateException) }
    /// The user, group, or resource name isn't unique in WorkMail.
    public static var nameAvailabilityException: Self { .init(.nameAvailabilityException) }
    /// An operation received a valid organization identifier that either doesn't belong or exist in the system.
    public static var organizationNotFoundException: Self { .init(.organizationNotFoundException) }
    /// The organization must have a valid state to perform certain operations on the organization or its members.
    public static var organizationStateException: Self { .init(.organizationStateException) }
    /// This user, group, or resource name is not allowed in WorkMail.
    public static var reservedNameException: Self { .init(.reservedNameException) }
    /// The resource cannot be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The resource can have up to 50 user-applied tags.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// You can't perform a write operation against a read-only directory.
    public static var unsupportedOperationException: Self { .init(.unsupportedOperationException) }
}

extension WorkMailErrorType: Equatable {
    public static func == (lhs: WorkMailErrorType, rhs: WorkMailErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WorkMailErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
