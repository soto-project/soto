//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Snowball {
    // MARK: Enums

    public enum AddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsShip = "AWS_SHIP"
        case custPickup = "CUST_PICKUP"
        public var description: String { return self.rawValue }
    }

    public enum ClusterState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awaitingQuorum = "AwaitingQuorum"
        case cancelled = "Cancelled"
        case complete = "Complete"
        case inUse = "InUse"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum DeviceServiceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nfsOnDeviceService = "NFS_ON_DEVICE_SERVICE"
        case s3OnDeviceService = "S3_ON_DEVICE_SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum ImpactLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case il2 = "IL2"
        case il4 = "IL4"
        case il5 = "IL5"
        case il6 = "IL6"
        case il99 = "IL99"
        public var description: String { return self.rawValue }
    }

    public enum JobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "Cancelled"
        case complete = "Complete"
        case inProgress = "InProgress"
        case inTransitToAws = "InTransitToAWS"
        case inTransitToCustomer = "InTransitToCustomer"
        case listing = "Listing"
        case new = "New"
        case pending = "Pending"
        case preparingAppliance = "PreparingAppliance"
        case preparingShipment = "PreparingShipment"
        case withAws = "WithAWS"
        case withAwsSortingFacility = "WithAWSSortingFacility"
        case withCustomer = "WithCustomer"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `import` = "IMPORT"
        case export = "EXPORT"
        case localUse = "LOCAL_USE"
        public var description: String { return self.rawValue }
    }

    public enum LongTermPricingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneMonth = "OneMonth"
        case oneYear = "OneYear"
        case threeYear = "ThreeYear"
        public var description: String { return self.rawValue }
    }

    public enum RemoteManagement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case installedAutostart = "INSTALLED_AUTOSTART"
        case installedOnly = "INSTALLED_ONLY"
        case notInstalled = "NOT_INSTALLED"
        public var description: String { return self.rawValue }
    }

    public enum ServiceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eksAnywhere = "EKS_ANYWHERE"
        case kubernetes = "KUBERNETES"
        public var description: String { return self.rawValue }
    }

    public enum ShipmentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case received = "RECEIVED"
        case returned = "RETURNED"
        public var description: String { return self.rawValue }
    }

    public enum ShippingLabelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case succeeded = "Succeeded"
        case timedOut = "TimedOut"
        public var description: String { return self.rawValue }
    }

    public enum ShippingOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case express = "EXPRESS"
        case nextDay = "NEXT_DAY"
        case secondDay = "SECOND_DAY"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum SnowballCapacity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noPreference = "NoPreference"
        case t100 = "T100"
        case t13 = "T13"
        case t14 = "T14"
        case t240 = "T240"
        case t32 = "T32"
        case t42 = "T42"
        case t50 = "T50"
        case t8 = "T8"
        case t80 = "T80"
        case t98 = "T98"
        public var description: String { return self.rawValue }
    }

    public enum SnowballType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edge = "EDGE"
        case edgeC = "EDGE_C"
        case edgeCg = "EDGE_CG"
        case edgeS = "EDGE_S"
        case rack5UC = "RACK_5U_C"
        case snc1Hdd = "SNC1_HDD"
        case snc1Ssd = "SNC1_SSD"
        case standard = "STANDARD"
        case v35C = "V3_5C"
        case v35S = "V3_5S"
        public var description: String { return self.rawValue }
    }

    public enum StorageUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tb = "TB"
        public var description: String { return self.rawValue }
    }

    public enum TransferOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `import` = "IMPORT"
        case export = "EXPORT"
        case localUse = "LOCAL_USE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Address: AWSEncodableShape & AWSDecodableShape {
        /// The unique ID for an address.
        public let addressId: String?
        /// The city in an address that a Snow device is to be delivered to.
        public let city: String?
        /// The name of the company to receive a Snow device at an address.
        public let company: String?
        /// The country in an address that a Snow device is to be delivered to.
        public let country: String?
        /// If the address you are creating is a primary address, then set this option to true. This field is not supported in most regions.
        public let isRestricted: Bool?
        /// This field is no longer used and the value is ignored.
        public let landmark: String?
        /// The name of a person to receive a Snow device at an address.
        public let name: String?
        /// The phone number associated with an address that a Snow device is to be delivered to.
        public let phoneNumber: String?
        /// The postal code in an address that a Snow device is to be delivered to.
        public let postalCode: String?
        /// This field is no longer used and the value is ignored.
        public let prefectureOrDistrict: String?
        /// The state or province in an address that a Snow device is to be delivered to.
        public let stateOrProvince: String?
        /// The first line in a street address that a Snow device is to be delivered to.
        public let street1: String?
        /// The second line in a street address that a Snow device is to be delivered to.
        public let street2: String?
        /// The third line in a street address that a Snow device is to be delivered to.
        public let street3: String?
        /// Differentiates between delivery address and pickup address in the customer account. Provided at job creation.
        public let type: AddressType?

        @inlinable
        public init(addressId: String? = nil, city: String? = nil, company: String? = nil, country: String? = nil, isRestricted: Bool? = nil, landmark: String? = nil, name: String? = nil, phoneNumber: String? = nil, postalCode: String? = nil, prefectureOrDistrict: String? = nil, stateOrProvince: String? = nil, street1: String? = nil, street2: String? = nil, street3: String? = nil, type: AddressType? = nil) {
            self.addressId = addressId
            self.city = city
            self.company = company
            self.country = country
            self.isRestricted = isRestricted
            self.landmark = landmark
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.prefectureOrDistrict = prefectureOrDistrict
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.addressId, name: "addressId", parent: name, max: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, min: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.city, name: "city", parent: name, max: 1024)
            try self.validate(self.city, name: "city", parent: name, min: 1)
            try self.validate(self.city, name: "city", parent: name, pattern: ".*")
            try self.validate(self.company, name: "company", parent: name, max: 1024)
            try self.validate(self.company, name: "company", parent: name, min: 1)
            try self.validate(self.company, name: "company", parent: name, pattern: ".*")
            try self.validate(self.country, name: "country", parent: name, max: 1024)
            try self.validate(self.country, name: "country", parent: name, min: 1)
            try self.validate(self.country, name: "country", parent: name, pattern: ".*")
            try self.validate(self.landmark, name: "landmark", parent: name, max: 1024)
            try self.validate(self.landmark, name: "landmark", parent: name, min: 1)
            try self.validate(self.landmark, name: "landmark", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 1024)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 1)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: ".*")
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 1024)
            try self.validate(self.postalCode, name: "postalCode", parent: name, min: 1)
            try self.validate(self.postalCode, name: "postalCode", parent: name, pattern: ".*")
            try self.validate(self.prefectureOrDistrict, name: "prefectureOrDistrict", parent: name, max: 1024)
            try self.validate(self.prefectureOrDistrict, name: "prefectureOrDistrict", parent: name, min: 1)
            try self.validate(self.prefectureOrDistrict, name: "prefectureOrDistrict", parent: name, pattern: ".*")
            try self.validate(self.stateOrProvince, name: "stateOrProvince", parent: name, max: 1024)
            try self.validate(self.stateOrProvince, name: "stateOrProvince", parent: name, min: 1)
            try self.validate(self.stateOrProvince, name: "stateOrProvince", parent: name, pattern: ".*")
            try self.validate(self.street1, name: "street1", parent: name, max: 1024)
            try self.validate(self.street1, name: "street1", parent: name, min: 1)
            try self.validate(self.street1, name: "street1", parent: name, pattern: ".*")
            try self.validate(self.street2, name: "street2", parent: name, max: 1024)
            try self.validate(self.street2, name: "street2", parent: name, min: 1)
            try self.validate(self.street2, name: "street2", parent: name, pattern: ".*")
            try self.validate(self.street3, name: "street3", parent: name, max: 1024)
            try self.validate(self.street3, name: "street3", parent: name, min: 1)
            try self.validate(self.street3, name: "street3", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case city = "City"
            case company = "Company"
            case country = "Country"
            case isRestricted = "IsRestricted"
            case landmark = "Landmark"
            case name = "Name"
            case phoneNumber = "PhoneNumber"
            case postalCode = "PostalCode"
            case prefectureOrDistrict = "PrefectureOrDistrict"
            case stateOrProvince = "StateOrProvince"
            case street1 = "Street1"
            case street2 = "Street2"
            case street3 = "Street3"
            case type = "Type"
        }
    }

    public struct CancelClusterRequest: AWSEncodableShape {
        /// The 39-character ID for the cluster that you want to cancel, for example CID123e4567-e89b-12d3-a456-426655440000.
        public let clusterId: String

        @inlinable
        public init(clusterId: String) {
            self.clusterId = clusterId
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, pattern: "^CID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
        }
    }

    public struct CancelClusterResult: AWSDecodableShape {
        public init() {}
    }

    public struct CancelJobRequest: AWSEncodableShape {
        /// The 39-character job ID for the job that you want to cancel, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct CancelJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct ClusterListEntry: AWSDecodableShape {
        /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
        public let clusterId: String?
        /// The current state of this cluster. For information about the state of a specific node, see JobListEntry$JobState.
        public let clusterState: ClusterState?
        /// The creation date for this cluster.
        public let creationDate: Date?
        /// Defines an optional description of the cluster, for example Environmental Data Cluster-01.
        public let description: String?

        @inlinable
        public init(clusterId: String? = nil, clusterState: ClusterState? = nil, creationDate: Date? = nil, description: String? = nil) {
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case clusterState = "ClusterState"
            case creationDate = "CreationDate"
            case description = "Description"
        }
    }

    public struct ClusterMetadata: AWSDecodableShape {
        /// The automatically generated ID for a specific address.
        public let addressId: String?
        /// The automatically generated ID for a cluster.
        public let clusterId: String?
        /// The current status of the cluster.
        public let clusterState: ClusterState?
        /// The creation date for this cluster.
        public let creationDate: Date?
        /// The optional description of the cluster.
        public let description: String?
        /// The ID of the address that you want a cluster shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public let forwardingAddressId: String?
        /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE.
        public let jobType: JobType?
        /// The KmsKeyARN Amazon Resource Name (ARN) associated with this cluster. This ARN was created using the CreateKey API action in Key Management Service (KMS.
        public let kmsKeyARN: String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
        public let notification: Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public let onDeviceServiceConfiguration: OnDeviceServiceConfiguration?
        /// The arrays of JobResource objects that can include updated S3Resource objects or LambdaResource objects.
        public let resources: JobResource?
        /// The role ARN associated with this cluster. This ARN was created using the CreateRole API action in Identity and Access Management (IAM).
        public let roleARN: String?
        /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:   In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.   In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.   In India, Snow devices are delivered in one to seven days.   In the US, you have access to one-day shipping and two-day shipping.
        public let shippingOption: ShippingOption?
        /// The type of Snowcone device to use for this cluster.   For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type.
        public let snowballType: SnowballType?
        /// The tax documents required in your Amazon Web Services Region.
        public let taxDocuments: TaxDocuments?

        @inlinable
        public init(addressId: String? = nil, clusterId: String? = nil, clusterState: ClusterState? = nil, creationDate: Date? = nil, description: String? = nil, forwardingAddressId: String? = nil, jobType: JobType? = nil, kmsKeyARN: String? = nil, notification: Notification? = nil, onDeviceServiceConfiguration: OnDeviceServiceConfiguration? = nil, resources: JobResource? = nil, roleARN: String? = nil, shippingOption: ShippingOption? = nil, snowballType: SnowballType? = nil, taxDocuments: TaxDocuments? = nil) {
            self.addressId = addressId
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case clusterId = "ClusterId"
            case clusterState = "ClusterState"
            case creationDate = "CreationDate"
            case description = "Description"
            case forwardingAddressId = "ForwardingAddressId"
            case jobType = "JobType"
            case kmsKeyARN = "KmsKeyARN"
            case notification = "Notification"
            case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
            case resources = "Resources"
            case roleARN = "RoleARN"
            case shippingOption = "ShippingOption"
            case snowballType = "SnowballType"
            case taxDocuments = "TaxDocuments"
        }
    }

    public struct CompatibleImage: AWSDecodableShape {
        /// The unique identifier for an individual Snow device AMI.
        public let amiId: String?
        /// The optional name of a compatible image.
        public let name: String?

        @inlinable
        public init(amiId: String? = nil, name: String? = nil) {
            self.amiId = amiId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "AmiId"
            case name = "Name"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// You get this resource when you call CreateReturnShippingLabel more than once when other requests are not completed. .
        public let conflictResource: String?
        public let message: String?

        @inlinable
        public init(conflictResource: String? = nil, message: String? = nil) {
            self.conflictResource = conflictResource
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case conflictResource = "ConflictResource"
            case message = "Message"
        }
    }

    public struct CreateAddressRequest: AWSEncodableShape {
        /// The address that you want the Snow device shipped to.
        public let address: Address

        @inlinable
        public init(address: Address) {
            self.address = address
        }

        public func validate(name: String) throws {
            try self.address.validate(name: "\(name).address")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
        }
    }

    public struct CreateAddressResult: AWSDecodableShape {
        /// The automatically generated ID for a specific address. You'll use this ID when you create a job to specify which address you want the Snow device for that job shipped to.
        public let addressId: String?

        @inlinable
        public init(addressId: String? = nil) {
            self.addressId = addressId
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {
        /// The ID for the address that you want the cluster shipped to.
        public let addressId: String
        /// An optional description of this specific cluster, for example Environmental Data Cluster-01.
        public let description: String?
        /// Force to create cluster when user attempts to overprovision or underprovision a cluster. A cluster is overprovisioned or underprovisioned if the initial size of the cluster is more (overprovisioned) or less (underprovisioned) than what  needed to meet capacity requirement specified with OnDeviceServiceConfiguration.
        public let forceCreateJobs: Bool?
        /// The forwarding address ID for a cluster. This field is not supported in most regions.
        public let forwardingAddressId: String?
        /// If provided, each job will be automatically created and associated with the new cluster. If not provided, will be treated as 0.
        public let initialClusterSize: Int?
        /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let jobType: JobType
        /// The KmsKeyARN value that you want to associate with this cluster. KmsKeyARN values are created by using the CreateKey API action in Key Management Service (KMS).
        public let kmsKeyARN: String?
        /// Lists long-term pricing id that will be used to associate with jobs automatically created for the new cluster.
        public let longTermPricingIds: [String]?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
        public let notification: Notification?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
        public let onDeviceServiceConfiguration: OnDeviceServiceConfiguration?
        /// Allows you to securely operate and manage Snow devices in a cluster remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
        public let remoteManagement: RemoteManagement?
        /// The resources associated with the cluster job. These resources include Amazon S3 buckets and optional Lambda functions written in the Python language.
        public let resources: JobResource?
        /// The RoleARN that you want to associate with this cluster. RoleArn values are created by using the CreateRole API action in Identity and Access Management (IAM).
        public let roleARN: String?
        /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each Snowball Edge device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:    In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.   In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.   In India, Snow devices are delivered in one to seven days.   In the United States of America (US), you have access to one-day shipping and two-day shipping.     In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.   In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.   In India, Snow devices are delivered in one to seven days.   In the US, you have access to one-day shipping and two-day shipping.
        public let shippingOption: ShippingOption
        /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let snowballCapacityPreference: SnowballCapacity?
        /// The type of Snow Family devices to use for this cluster.   For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type.  For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let snowballType: SnowballType
        /// The tax documents required in your Amazon Web Services Region.
        public let taxDocuments: TaxDocuments?

        @inlinable
        public init(addressId: String, description: String? = nil, forceCreateJobs: Bool? = nil, forwardingAddressId: String? = nil, initialClusterSize: Int? = nil, jobType: JobType, kmsKeyARN: String? = nil, longTermPricingIds: [String]? = nil, notification: Notification? = nil, onDeviceServiceConfiguration: OnDeviceServiceConfiguration? = nil, remoteManagement: RemoteManagement? = nil, resources: JobResource? = nil, roleARN: String? = nil, shippingOption: ShippingOption, snowballCapacityPreference: SnowballCapacity? = nil, snowballType: SnowballType, taxDocuments: TaxDocuments? = nil) {
            self.addressId = addressId
            self.description = description
            self.forceCreateJobs = forceCreateJobs
            self.forwardingAddressId = forwardingAddressId
            self.initialClusterSize = initialClusterSize
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingIds = longTermPricingIds
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.remoteManagement = remoteManagement
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }

        public func validate(name: String) throws {
            try self.validate(self.addressId, name: "addressId", parent: name, max: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, min: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, max: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, min: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.initialClusterSize, name: "initialClusterSize", parent: name, max: 16)
            try self.validate(self.initialClusterSize, name: "initialClusterSize", parent: name, min: 0)
            try self.validate(self.kmsKeyARN, name: "kmsKeyARN", parent: name, max: 255)
            try self.validate(self.kmsKeyARN, name: "kmsKeyARN", parent: name, pattern: "^arn:aws.*:kms:.*:[0-9]{12}:key/")
            try self.longTermPricingIds?.forEach {
                try validate($0, name: "longTermPricingIds[]", parent: name, max: 41)
                try validate($0, name: "longTermPricingIds[]", parent: name, min: 41)
                try validate($0, name: "longTermPricingIds[]", parent: name, pattern: "^LTPID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.notification?.validate(name: "\(name).notification")
            try self.onDeviceServiceConfiguration?.validate(name: "\(name).onDeviceServiceConfiguration")
            try self.resources?.validate(name: "\(name).resources")
            try self.validate(self.roleARN, name: "roleARN", parent: name, max: 255)
            try self.validate(self.roleARN, name: "roleARN", parent: name, pattern: "^arn:aws.*:iam::[0-9]{12}:role/")
            try self.taxDocuments?.validate(name: "\(name).taxDocuments")
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case description = "Description"
            case forceCreateJobs = "ForceCreateJobs"
            case forwardingAddressId = "ForwardingAddressId"
            case initialClusterSize = "InitialClusterSize"
            case jobType = "JobType"
            case kmsKeyARN = "KmsKeyARN"
            case longTermPricingIds = "LongTermPricingIds"
            case notification = "Notification"
            case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
            case remoteManagement = "RemoteManagement"
            case resources = "Resources"
            case roleARN = "RoleARN"
            case shippingOption = "ShippingOption"
            case snowballCapacityPreference = "SnowballCapacityPreference"
            case snowballType = "SnowballType"
            case taxDocuments = "TaxDocuments"
        }
    }

    public struct CreateClusterResult: AWSDecodableShape {
        /// The automatically generated ID for a cluster.
        public let clusterId: String?
        /// List of jobs created for this cluster. For syntax, see ListJobsResult$JobListEntries in this guide.
        public let jobListEntries: [JobListEntry]?

        @inlinable
        public init(clusterId: String? = nil, jobListEntries: [JobListEntry]? = nil) {
            self.clusterId = clusterId
            self.jobListEntries = jobListEntries
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case jobListEntries = "JobListEntries"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// The ID for the address that you want the Snow device shipped to.
        public let addressId: String?
        /// The ID of a cluster. If you're creating a job for a node in a cluster, you need to provide only this clusterId value. The other job attributes are inherited from the cluster.
        public let clusterId: String?
        /// Defines an optional description of this specific job, for example Important Photos 2016-08-11.
        public let description: String?
        /// Defines the device configuration for an Snowcone job. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let deviceConfiguration: DeviceConfiguration?
        /// The forwarding address ID for a job. This field is not supported in most Regions.
        public let forwardingAddressId: String?
        /// The highest impact level of data that will be stored or processed on the device, provided at job creation.
        public let impactLevel: ImpactLevel?
        /// Defines the type of job that you're creating.
        public let jobType: JobType?
        /// The KmsKeyARN that you want to associate with this job. KmsKeyARNs are created using the CreateKey Key Management Service (KMS) API action.
        public let kmsKeyARN: String?
        /// The ID of the long-term pricing type for the device.
        public let longTermPricingId: String?
        /// Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for this job.
        public let notification: Notification?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
        public let onDeviceServiceConfiguration: OnDeviceServiceConfiguration?
        /// Information identifying the person picking up the device.
        public let pickupDetails: PickupDetails?
        /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Edge client to manage the device. When set to NOT_INSTALLED, remote management will not be available on the device.
        public let remoteManagement: RemoteManagement?
        /// Defines the Amazon S3 buckets associated with this job. With IMPORT jobs, you specify the bucket or buckets that your transferred data will be imported into. With EXPORT jobs, you specify the bucket or buckets that your transferred data will be exported from. Optionally, you can also specify a KeyRange value. If you choose to export a range, you define the length of the range by providing either an inclusive BeginMarker value, an inclusive EndMarker value, or both. Ranges are UTF-8 binary sorted.
        public let resources: JobResource?
        /// The RoleARN that you want to associate with this job. RoleArns are created using the CreateRole Identity and Access Management (IAM) API action.
        public let roleARN: String?
        /// The shipping speed for this job. This speed doesn't dictate how soon you'll get the Snow device, rather it represents how quickly the Snow device moves to its destination while in transit. Regional shipping speeds are as follows:   In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.   In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.   In India, Snow devices are delivered in one to seven days.   In the US, you have access to one-day shipping and two-day shipping.
        public let shippingOption: ShippingOption?
        /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let snowballCapacityPreference: SnowballCapacity?
        /// The type of Snow Family devices to use for this job.   For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type.  The type of Amazon Web Services Snow device to use for this job. Currently, the only supported device type for cluster jobs is EDGE. For more information, see Snowball Edge Device Options in the Snowball Edge Developer Guide. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let snowballType: SnowballType?
        /// The tax documents required in your Amazon Web Services Region.
        public let taxDocuments: TaxDocuments?

        @inlinable
        public init(addressId: String? = nil, clusterId: String? = nil, description: String? = nil, deviceConfiguration: DeviceConfiguration? = nil, forwardingAddressId: String? = nil, impactLevel: ImpactLevel? = nil, jobType: JobType? = nil, kmsKeyARN: String? = nil, longTermPricingId: String? = nil, notification: Notification? = nil, onDeviceServiceConfiguration: OnDeviceServiceConfiguration? = nil, pickupDetails: PickupDetails? = nil, remoteManagement: RemoteManagement? = nil, resources: JobResource? = nil, roleARN: String? = nil, shippingOption: ShippingOption? = nil, snowballCapacityPreference: SnowballCapacity? = nil, snowballType: SnowballType? = nil, taxDocuments: TaxDocuments? = nil) {
            self.addressId = addressId
            self.clusterId = clusterId
            self.description = description
            self.deviceConfiguration = deviceConfiguration
            self.forwardingAddressId = forwardingAddressId
            self.impactLevel = impactLevel
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingId = longTermPricingId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.pickupDetails = pickupDetails
            self.remoteManagement = remoteManagement
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }

        public func validate(name: String) throws {
            try self.validate(self.addressId, name: "addressId", parent: name, max: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, min: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, pattern: "^CID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, max: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, min: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.kmsKeyARN, name: "kmsKeyARN", parent: name, max: 255)
            try self.validate(self.kmsKeyARN, name: "kmsKeyARN", parent: name, pattern: "^arn:aws.*:kms:.*:[0-9]{12}:key/")
            try self.validate(self.longTermPricingId, name: "longTermPricingId", parent: name, max: 41)
            try self.validate(self.longTermPricingId, name: "longTermPricingId", parent: name, min: 41)
            try self.validate(self.longTermPricingId, name: "longTermPricingId", parent: name, pattern: "^LTPID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.notification?.validate(name: "\(name).notification")
            try self.onDeviceServiceConfiguration?.validate(name: "\(name).onDeviceServiceConfiguration")
            try self.pickupDetails?.validate(name: "\(name).pickupDetails")
            try self.resources?.validate(name: "\(name).resources")
            try self.validate(self.roleARN, name: "roleARN", parent: name, max: 255)
            try self.validate(self.roleARN, name: "roleARN", parent: name, pattern: "^arn:aws.*:iam::[0-9]{12}:role/")
            try self.taxDocuments?.validate(name: "\(name).taxDocuments")
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case clusterId = "ClusterId"
            case description = "Description"
            case deviceConfiguration = "DeviceConfiguration"
            case forwardingAddressId = "ForwardingAddressId"
            case impactLevel = "ImpactLevel"
            case jobType = "JobType"
            case kmsKeyARN = "KmsKeyARN"
            case longTermPricingId = "LongTermPricingId"
            case notification = "Notification"
            case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
            case pickupDetails = "PickupDetails"
            case remoteManagement = "RemoteManagement"
            case resources = "Resources"
            case roleARN = "RoleARN"
            case shippingOption = "ShippingOption"
            case snowballCapacityPreference = "SnowballCapacityPreference"
            case snowballType = "SnowballType"
            case taxDocuments = "TaxDocuments"
        }
    }

    public struct CreateJobResult: AWSDecodableShape {
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String?

        @inlinable
        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct CreateLongTermPricingRequest: AWSEncodableShape {
        /// Specifies whether the current long-term pricing type for the device should be renewed.
        public let isLongTermPricingAutoRenew: Bool?
        /// The type of long-term pricing option you want for the device, either 1-year or 3-year long-term pricing.
        public let longTermPricingType: LongTermPricingType
        /// The type of Snow Family devices to use for the long-term pricing job.
        public let snowballType: SnowballType

        @inlinable
        public init(isLongTermPricingAutoRenew: Bool? = nil, longTermPricingType: LongTermPricingType, snowballType: SnowballType) {
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.longTermPricingType = longTermPricingType
            self.snowballType = snowballType
        }

        private enum CodingKeys: String, CodingKey {
            case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
            case longTermPricingType = "LongTermPricingType"
            case snowballType = "SnowballType"
        }
    }

    public struct CreateLongTermPricingResult: AWSDecodableShape {
        /// The ID of the long-term pricing type for the device.
        public let longTermPricingId: String?

        @inlinable
        public init(longTermPricingId: String? = nil) {
            self.longTermPricingId = longTermPricingId
        }

        private enum CodingKeys: String, CodingKey {
            case longTermPricingId = "LongTermPricingId"
        }
    }

    public struct CreateReturnShippingLabelRequest: AWSEncodableShape {
        /// The ID for a job that you want to create the return shipping label for; for example, JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String
        /// The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to Amazon Web Services. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
        public let shippingOption: ShippingOption?

        @inlinable
        public init(jobId: String, shippingOption: ShippingOption? = nil) {
            self.jobId = jobId
            self.shippingOption = shippingOption
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case shippingOption = "ShippingOption"
        }
    }

    public struct CreateReturnShippingLabelResult: AWSDecodableShape {
        /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
        public let status: ShippingLabelStatus?

        @inlinable
        public init(status: ShippingLabelStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct DataTransfer: AWSDecodableShape {
        /// The number of bytes transferred between a Snow device and Amazon S3.
        public let bytesTransferred: Int64?
        /// The number of objects transferred between a Snow device and Amazon S3.
        public let objectsTransferred: Int64?
        /// The total bytes of data for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public let totalBytes: Int64?
        /// The total number of objects for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public let totalObjects: Int64?

        @inlinable
        public init(bytesTransferred: Int64? = nil, objectsTransferred: Int64? = nil, totalBytes: Int64? = nil, totalObjects: Int64? = nil) {
            self.bytesTransferred = bytesTransferred
            self.objectsTransferred = objectsTransferred
            self.totalBytes = totalBytes
            self.totalObjects = totalObjects
        }

        private enum CodingKeys: String, CodingKey {
            case bytesTransferred = "BytesTransferred"
            case objectsTransferred = "ObjectsTransferred"
            case totalBytes = "TotalBytes"
            case totalObjects = "TotalObjects"
        }
    }

    public struct DependentService: AWSEncodableShape & AWSDecodableShape {
        /// The name of the dependent service.
        public let serviceName: ServiceName?
        /// The version of the dependent service.
        public let serviceVersion: ServiceVersion?

        @inlinable
        public init(serviceName: ServiceName? = nil, serviceVersion: ServiceVersion? = nil) {
            self.serviceName = serviceName
            self.serviceVersion = serviceVersion
        }

        public func validate(name: String) throws {
            try self.serviceVersion?.validate(name: "\(name).serviceVersion")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "ServiceName"
            case serviceVersion = "ServiceVersion"
        }
    }

    public struct DescribeAddressRequest: AWSEncodableShape {
        /// The automatically generated ID for a specific address.
        public let addressId: String

        @inlinable
        public init(addressId: String) {
            self.addressId = addressId
        }

        public func validate(name: String) throws {
            try self.validate(self.addressId, name: "addressId", parent: name, max: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, min: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
        }
    }

    public struct DescribeAddressResult: AWSDecodableShape {
        /// The address that you want the Snow device(s) associated with a specific job to be shipped to.
        public let address: Address?

        @inlinable
        public init(address: Address? = nil) {
            self.address = address
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
        }
    }

    public struct DescribeAddressesRequest: AWSEncodableShape {
        /// The number of ADDRESS objects to return.
        public let maxResults: Int?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of ADDRESS objects, you have the option of specifying a value for NextToken as the starting point for your list of returned addresses.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAddressesResult: AWSDecodableShape {
        /// The Snow device shipping addresses that were created for this account.
        public let addresses: [Address]?
        /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next DescribeAddresses call, your list of returned addresses will start from this point in the array.
        public let nextToken: String?

        @inlinable
        public init(addresses: [Address]? = nil, nextToken: String? = nil) {
            self.addresses = addresses
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case addresses = "Addresses"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeClusterRequest: AWSEncodableShape {
        /// The automatically generated ID for a cluster.
        public let clusterId: String

        @inlinable
        public init(clusterId: String) {
            self.clusterId = clusterId
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, pattern: "^CID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
        }
    }

    public struct DescribeClusterResult: AWSDecodableShape {
        /// Information about a specific cluster, including shipping information, cluster status, and other important metadata.
        public let clusterMetadata: ClusterMetadata?

        @inlinable
        public init(clusterMetadata: ClusterMetadata? = nil) {
            self.clusterMetadata = clusterMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case clusterMetadata = "ClusterMetadata"
        }
    }

    public struct DescribeJobRequest: AWSEncodableShape {
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeJobResult: AWSDecodableShape {
        /// Information about a specific job, including shipping information, job status, and other important metadata.
        public let jobMetadata: JobMetadata?
        /// Information about a specific job part (in the case of an export job), including shipping information, job status, and other important metadata.
        public let subJobMetadata: [JobMetadata]?

        @inlinable
        public init(jobMetadata: JobMetadata? = nil, subJobMetadata: [JobMetadata]? = nil) {
            self.jobMetadata = jobMetadata
            self.subJobMetadata = subJobMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case jobMetadata = "JobMetadata"
            case subJobMetadata = "SubJobMetadata"
        }
    }

    public struct DescribeReturnShippingLabelRequest: AWSEncodableShape {
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DescribeReturnShippingLabelResult: AWSDecodableShape {
        /// The expiration date of the current return shipping label.
        public let expirationDate: Date?
        /// The pre-signed Amazon S3 URI used to download the return shipping label.
        public let returnShippingLabelURI: String?
        /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
        public let status: ShippingLabelStatus?

        @inlinable
        public init(expirationDate: Date? = nil, returnShippingLabelURI: String? = nil, status: ShippingLabelStatus? = nil) {
            self.expirationDate = expirationDate
            self.returnShippingLabelURI = returnShippingLabelURI
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case expirationDate = "ExpirationDate"
            case returnShippingLabelURI = "ReturnShippingLabelURI"
            case status = "Status"
        }
    }

    public struct DeviceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Returns information about the device configuration for an Snowcone job.
        public let snowconeDeviceConfiguration: SnowconeDeviceConfiguration?

        @inlinable
        public init(snowconeDeviceConfiguration: SnowconeDeviceConfiguration? = nil) {
            self.snowconeDeviceConfiguration = snowconeDeviceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case snowconeDeviceConfiguration = "SnowconeDeviceConfiguration"
        }
    }

    public struct EKSOnDeviceServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The optional version of EKS Anywhere on the Snow Family device.
        public let eksAnywhereVersion: String?
        /// The Kubernetes version for EKS Anywhere on the Snow Family device.
        public let kubernetesVersion: String?

        @inlinable
        public init(eksAnywhereVersion: String? = nil, kubernetesVersion: String? = nil) {
            self.eksAnywhereVersion = eksAnywhereVersion
            self.kubernetesVersion = kubernetesVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.eksAnywhereVersion, name: "eksAnywhereVersion", parent: name, max: 1024)
            try self.validate(self.eksAnywhereVersion, name: "eksAnywhereVersion", parent: name, min: 1)
            try self.validate(self.eksAnywhereVersion, name: "eksAnywhereVersion", parent: name, pattern: ".*")
            try self.validate(self.kubernetesVersion, name: "kubernetesVersion", parent: name, max: 1024)
            try self.validate(self.kubernetesVersion, name: "kubernetesVersion", parent: name, min: 1)
            try self.validate(self.kubernetesVersion, name: "kubernetesVersion", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case eksAnywhereVersion = "EKSAnywhereVersion"
            case kubernetesVersion = "KubernetesVersion"
        }
    }

    public struct Ec2AmiResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the AMI in Amazon EC2.
        public let amiId: String
        /// The ID of the AMI on the Snow device.
        public let snowballAmiId: String?

        @inlinable
        public init(amiId: String, snowballAmiId: String? = nil) {
            self.amiId = amiId
            self.snowballAmiId = snowballAmiId
        }

        public func validate(name: String) throws {
            try self.validate(self.amiId, name: "amiId", parent: name, max: 21)
            try self.validate(self.amiId, name: "amiId", parent: name, min: 12)
            try self.validate(self.amiId, name: "amiId", parent: name, pattern: "^(ami-[0-9a-f]{8})|(ami-[0-9a-f]{17})$")
            try self.validate(self.snowballAmiId, name: "snowballAmiId", parent: name, max: 1024)
            try self.validate(self.snowballAmiId, name: "snowballAmiId", parent: name, min: 1)
            try self.validate(self.snowballAmiId, name: "snowballAmiId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "AmiId"
            case snowballAmiId = "SnowballAmiId"
        }
    }

    public struct EventTriggerDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an Lambda function's event trigger associated with this job.
        public let eventResourceARN: String?

        @inlinable
        public init(eventResourceARN: String? = nil) {
            self.eventResourceARN = eventResourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.eventResourceARN, name: "eventResourceARN", parent: name, max: 255)
            try self.validate(self.eventResourceARN, name: "eventResourceARN", parent: name, pattern: "^arn:aws.*:*$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventResourceARN = "EventResourceARN"
        }
    }

    public struct GetJobManifestRequest: AWSEncodableShape {
        /// The ID for a job that you want to get the manifest file for, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct GetJobManifestResult: AWSDecodableShape {
        /// The Amazon S3 presigned URL for the manifest file associated with the specified JobId value.
        public let manifestURI: String?

        @inlinable
        public init(manifestURI: String? = nil) {
            self.manifestURI = manifestURI
        }

        private enum CodingKeys: String, CodingKey {
            case manifestURI = "ManifestURI"
        }
    }

    public struct GetJobUnlockCodeRequest: AWSEncodableShape {
        /// The ID for the job that you want to get the UnlockCode value for, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct GetJobUnlockCodeResult: AWSDecodableShape {
        /// The UnlockCode value for the specified job. The UnlockCode value can be accessed for up to 360 days after the job has been created.
        public let unlockCode: String?

        @inlinable
        public init(unlockCode: String? = nil) {
            self.unlockCode = unlockCode
        }

        private enum CodingKeys: String, CodingKey {
            case unlockCode = "UnlockCode"
        }
    }

    public struct GetSnowballUsageRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetSnowballUsageResult: AWSDecodableShape {
        /// The service limit for number of Snow devices this account can have at once. The default service limit is 1 (one).
        public let snowballLimit: Int?
        /// The number of Snow devices that this account is currently using.
        public let snowballsInUse: Int?

        @inlinable
        public init(snowballLimit: Int? = nil, snowballsInUse: Int? = nil) {
            self.snowballLimit = snowballLimit
            self.snowballsInUse = snowballsInUse
        }

        private enum CodingKeys: String, CodingKey {
            case snowballLimit = "SnowballLimit"
            case snowballsInUse = "SnowballsInUse"
        }
    }

    public struct GetSoftwareUpdatesRequest: AWSEncodableShape {
        /// The ID for a job that you want to get the software update file for, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct GetSoftwareUpdatesResult: AWSDecodableShape {
        /// The Amazon S3 presigned URL for the update file associated with the specified JobId value. The software update will be available for 2 days after this request is made. To access an update after the 2 days have passed, you'll have to make another call to GetSoftwareUpdates.
        public let updatesURI: String?

        @inlinable
        public init(updatesURI: String? = nil) {
            self.updatesURI = updatesURI
        }

        private enum CodingKeys: String, CodingKey {
            case updatesURI = "UpdatesURI"
        }
    }

    public struct INDTaxDocuments: AWSEncodableShape & AWSDecodableShape {
        /// The Goods and Services Tax (GST) documents required in Amazon Web Services Region in India.
        public let gstin: String?

        @inlinable
        public init(gstin: String? = nil) {
            self.gstin = gstin
        }

        public func validate(name: String) throws {
            try self.validate(self.gstin, name: "gstin", parent: name, max: 15)
            try self.validate(self.gstin, name: "gstin", parent: name, min: 15)
            try self.validate(self.gstin, name: "gstin", parent: name, pattern: "^\\d{2}[A-Z]{5}\\d{4}[A-Z]{1}[A-Z\\d]{1}[Z]{1}[A-Z\\d]{1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case gstin = "GSTIN"
        }
    }

    public struct InvalidResourceException: AWSErrorShape {
        public let message: String?
        /// The provided resource value is invalid.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceType = "ResourceType"
        }
    }

    public struct JobListEntry: AWSDecodableShape {
        /// The creation date for this job.
        public let creationDate: Date?
        /// The optional description of this specific job, for example Important Photos 2016-08-11.
        public let description: String?
        /// A value that indicates that this job is a main job. A main job represents a successful request to create an export job. Main jobs aren't associated with any Snowballs. Instead, each main job will have at least one job part, and each job part is associated with a Snowball. It might take some time before the job parts associated with a particular main job are listed, because they are created after the main job is created.
        public let isMaster: Bool?
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String?
        /// The current state of this job.
        public let jobState: JobState?
        /// The type of job.
        public let jobType: JobType?
        /// The type of device used with this job.
        public let snowballType: SnowballType?

        @inlinable
        public init(creationDate: Date? = nil, description: String? = nil, isMaster: Bool? = nil, jobId: String? = nil, jobState: JobState? = nil, jobType: JobType? = nil, snowballType: SnowballType? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.isMaster = isMaster
            self.jobId = jobId
            self.jobState = jobState
            self.jobType = jobType
            self.snowballType = snowballType
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case isMaster = "IsMaster"
            case jobId = "JobId"
            case jobState = "JobState"
            case jobType = "JobType"
            case snowballType = "SnowballType"
        }
    }

    public struct JobLogs: AWSDecodableShape {
        /// A link to an Amazon S3 presigned URL where the job completion report is located.
        public let jobCompletionReportURI: String?
        /// A link to an Amazon S3 presigned URL where the job failure log is located.
        public let jobFailureLogURI: String?
        /// A link to an Amazon S3 presigned URL where the job success log is located.
        public let jobSuccessLogURI: String?

        @inlinable
        public init(jobCompletionReportURI: String? = nil, jobFailureLogURI: String? = nil, jobSuccessLogURI: String? = nil) {
            self.jobCompletionReportURI = jobCompletionReportURI
            self.jobFailureLogURI = jobFailureLogURI
            self.jobSuccessLogURI = jobSuccessLogURI
        }

        private enum CodingKeys: String, CodingKey {
            case jobCompletionReportURI = "JobCompletionReportURI"
            case jobFailureLogURI = "JobFailureLogURI"
            case jobSuccessLogURI = "JobSuccessLogURI"
        }
    }

    public struct JobMetadata: AWSDecodableShape {
        /// The ID for the address that you want the Snow device shipped to.
        public let addressId: String?
        /// The 39-character ID for the cluster, for example CID123e4567-e89b-12d3-a456-426655440000.
        public let clusterId: String?
        /// The creation date for this job.
        public let creationDate: Date?
        /// A value that defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
        public let dataTransferProgress: DataTransfer?
        /// The description of the job, provided at job creation.
        public let description: String?
        public let deviceConfiguration: DeviceConfiguration?
        /// The ID of the address that you want a job shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public let forwardingAddressId: String?
        /// The highest impact level of data that will be stored or processed on the device, provided at job creation.
        public let impactLevel: ImpactLevel?
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String?
        /// Links to Amazon S3 presigned URLs for the job report and logs. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you.
        public let jobLogInfo: JobLogs?
        /// The current status of the jobs.
        public let jobState: JobState?
        /// The type of job.
        public let jobType: JobType?
        /// The Amazon Resource Name (ARN) for the Key Management Service (KMS) key associated with this job. This ARN was created using the CreateKey API action in KMS.
        public let kmsKeyARN: String?
        /// The ID of the long-term pricing type for the device.
        public let longTermPricingId: String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type.
        public let notification: Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public let onDeviceServiceConfiguration: OnDeviceServiceConfiguration?
        /// Information identifying the person picking up the device.
        public let pickupDetails: PickupDetails?
        /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
        public let remoteManagement: RemoteManagement?
        /// An array of S3Resource objects. Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into.
        public let resources: JobResource?
        /// The role ARN associated with this job. This ARN was created using the CreateRole API action in Identity and Access Management.
        public let roleARN: String?
        /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
        public let shippingDetails: ShippingDetails?
        /// The Snow device capacity preference for this job, specified at job creation. In US regions, you can choose between 50 TB and 80 TB Snowballs. All other regions use 80 TB capacity Snowballs. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let snowballCapacityPreference: SnowballCapacity?
        /// Unique ID associated with a device.
        public let snowballId: String?
        /// The type of device used with this job.
        public let snowballType: SnowballType?
        /// The metadata associated with the tax documents required in your Amazon Web Services Region.
        public let taxDocuments: TaxDocuments?

        @inlinable
        public init(addressId: String? = nil, clusterId: String? = nil, creationDate: Date? = nil, dataTransferProgress: DataTransfer? = nil, description: String? = nil, deviceConfiguration: DeviceConfiguration? = nil, forwardingAddressId: String? = nil, impactLevel: ImpactLevel? = nil, jobId: String? = nil, jobLogInfo: JobLogs? = nil, jobState: JobState? = nil, jobType: JobType? = nil, kmsKeyARN: String? = nil, longTermPricingId: String? = nil, notification: Notification? = nil, onDeviceServiceConfiguration: OnDeviceServiceConfiguration? = nil, pickupDetails: PickupDetails? = nil, remoteManagement: RemoteManagement? = nil, resources: JobResource? = nil, roleARN: String? = nil, shippingDetails: ShippingDetails? = nil, snowballCapacityPreference: SnowballCapacity? = nil, snowballId: String? = nil, snowballType: SnowballType? = nil, taxDocuments: TaxDocuments? = nil) {
            self.addressId = addressId
            self.clusterId = clusterId
            self.creationDate = creationDate
            self.dataTransferProgress = dataTransferProgress
            self.description = description
            self.deviceConfiguration = deviceConfiguration
            self.forwardingAddressId = forwardingAddressId
            self.impactLevel = impactLevel
            self.jobId = jobId
            self.jobLogInfo = jobLogInfo
            self.jobState = jobState
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingId = longTermPricingId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.pickupDetails = pickupDetails
            self.remoteManagement = remoteManagement
            self.resources = resources
            self.roleARN = roleARN
            self.shippingDetails = shippingDetails
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballId = snowballId
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case clusterId = "ClusterId"
            case creationDate = "CreationDate"
            case dataTransferProgress = "DataTransferProgress"
            case description = "Description"
            case deviceConfiguration = "DeviceConfiguration"
            case forwardingAddressId = "ForwardingAddressId"
            case impactLevel = "ImpactLevel"
            case jobId = "JobId"
            case jobLogInfo = "JobLogInfo"
            case jobState = "JobState"
            case jobType = "JobType"
            case kmsKeyARN = "KmsKeyARN"
            case longTermPricingId = "LongTermPricingId"
            case notification = "Notification"
            case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
            case pickupDetails = "PickupDetails"
            case remoteManagement = "RemoteManagement"
            case resources = "Resources"
            case roleARN = "RoleARN"
            case shippingDetails = "ShippingDetails"
            case snowballCapacityPreference = "SnowballCapacityPreference"
            case snowballId = "SnowballId"
            case snowballType = "SnowballType"
            case taxDocuments = "TaxDocuments"
        }
    }

    public struct JobResource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Machine Images (AMIs) associated with this job.
        public let ec2AmiResources: [Ec2AmiResource]?
        /// The Python-language Lambda functions for this job.
        public let lambdaResources: [LambdaResource]?
        /// An array of S3Resource objects.
        public let s3Resources: [S3Resource]?

        @inlinable
        public init(ec2AmiResources: [Ec2AmiResource]? = nil, lambdaResources: [LambdaResource]? = nil, s3Resources: [S3Resource]? = nil) {
            self.ec2AmiResources = ec2AmiResources
            self.lambdaResources = lambdaResources
            self.s3Resources = s3Resources
        }

        public func validate(name: String) throws {
            try self.ec2AmiResources?.forEach {
                try $0.validate(name: "\(name).ec2AmiResources[]")
            }
            try self.lambdaResources?.forEach {
                try $0.validate(name: "\(name).lambdaResources[]")
            }
            try self.s3Resources?.forEach {
                try $0.validate(name: "\(name).s3Resources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case ec2AmiResources = "Ec2AmiResources"
            case lambdaResources = "LambdaResources"
            case s3Resources = "S3Resources"
        }
    }

    public struct KeyRange: AWSEncodableShape & AWSDecodableShape {
        /// The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public let beginMarker: String?
        /// The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public let endMarker: String?

        @inlinable
        public init(beginMarker: String? = nil, endMarker: String? = nil) {
            self.beginMarker = beginMarker
            self.endMarker = endMarker
        }

        public func validate(name: String) throws {
            try self.validate(self.beginMarker, name: "beginMarker", parent: name, max: 1024)
            try self.validate(self.beginMarker, name: "beginMarker", parent: name, min: 1)
            try self.validate(self.beginMarker, name: "beginMarker", parent: name, pattern: ".*")
            try self.validate(self.endMarker, name: "endMarker", parent: name, max: 1024)
            try self.validate(self.endMarker, name: "endMarker", parent: name, min: 1)
            try self.validate(self.endMarker, name: "endMarker", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case beginMarker = "BeginMarker"
            case endMarker = "EndMarker"
        }
    }

    public struct LambdaResource: AWSEncodableShape & AWSDecodableShape {
        /// The array of ARNs for S3Resource objects to trigger the LambdaResource objects associated with this job.
        public let eventTriggers: [EventTriggerDefinition]?
        /// An Amazon Resource Name (ARN) that represents an Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource.
        public let lambdaArn: String?

        @inlinable
        public init(eventTriggers: [EventTriggerDefinition]? = nil, lambdaArn: String? = nil) {
            self.eventTriggers = eventTriggers
            self.lambdaArn = lambdaArn
        }

        public func validate(name: String) throws {
            try self.eventTriggers?.forEach {
                try $0.validate(name: "\(name).eventTriggers[]")
            }
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 255)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:aws.*:*$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTriggers = "EventTriggers"
            case lambdaArn = "LambdaArn"
        }
    }

    public struct ListClusterJobsRequest: AWSEncodableShape {
        /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
        public let clusterId: String
        /// The number of JobListEntry objects to return.
        public let maxResults: Int?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
        public let nextToken: String?

        @inlinable
        public init(clusterId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterId = clusterId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, pattern: "^CID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListClusterJobsResult: AWSDecodableShape {
        /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
        public let jobListEntries: [JobListEntry]?
        /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ListClusterJobsResult call, your list of returned jobs will start from this point in the array.
        public let nextToken: String?

        @inlinable
        public init(jobListEntries: [JobListEntry]? = nil, nextToken: String? = nil) {
            self.jobListEntries = jobListEntries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobListEntries = "JobListEntries"
            case nextToken = "NextToken"
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        /// The number of ClusterListEntry objects to return.
        public let maxResults: Int?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of ClusterListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListClustersResult: AWSDecodableShape {
        /// Each ClusterListEntry object contains a cluster's state, a cluster's ID, and other important status information.
        public let clusterListEntries: [ClusterListEntry]?
        /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ClusterListEntry call, your list of returned clusters will start from this point in the array.
        public let nextToken: String?

        @inlinable
        public init(clusterListEntries: [ClusterListEntry]? = nil, nextToken: String? = nil) {
            self.clusterListEntries = clusterListEntries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterListEntries = "ClusterListEntries"
            case nextToken = "NextToken"
        }
    }

    public struct ListCompatibleImagesRequest: AWSEncodableShape {
        /// The maximum number of results for the list of compatible images. Currently, a Snowball Edge device can store 10 AMIs.
        public let maxResults: Int?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of compatible images, you can specify a value for NextToken as the starting point for your list of returned images.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCompatibleImagesResult: AWSDecodableShape {
        /// A JSON-formatted object that describes a compatible AMI, including the ID and name for a Snow device AMI.
        public let compatibleImages: [CompatibleImage]?
        /// Because HTTP requests are stateless, this is the starting point for your next list of returned images.
        public let nextToken: String?

        @inlinable
        public init(compatibleImages: [CompatibleImage]? = nil, nextToken: String? = nil) {
            self.compatibleImages = compatibleImages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleImages = "CompatibleImages"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The number of JobListEntry objects to return.
        public let maxResults: Int?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsResult: AWSDecodableShape {
        /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
        public let jobListEntries: [JobListEntry]?
        /// HTTP requests are stateless. If you use this automatically generated NextToken value in your next ListJobs call, your returned JobListEntry objects will start from this point in the array.
        public let nextToken: String?

        @inlinable
        public init(jobListEntries: [JobListEntry]? = nil, nextToken: String? = nil) {
            self.jobListEntries = jobListEntries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobListEntries = "JobListEntries"
            case nextToken = "NextToken"
        }
    }

    public struct ListLongTermPricingRequest: AWSEncodableShape {
        /// The maximum number of ListLongTermPricing objects to return.
        public let maxResults: Int?
        /// Because HTTP requests are stateless, this is the starting point for your next list of ListLongTermPricing to return.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListLongTermPricingResult: AWSDecodableShape {
        /// Each LongTermPricingEntry object contains a status, ID, and other information about the LongTermPricing type.
        public let longTermPricingEntries: [LongTermPricingListEntry]?
        /// Because HTTP requests are stateless, this is the starting point for your next list of returned ListLongTermPricing list.
        public let nextToken: String?

        @inlinable
        public init(longTermPricingEntries: [LongTermPricingListEntry]? = nil, nextToken: String? = nil) {
            self.longTermPricingEntries = longTermPricingEntries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case longTermPricingEntries = "LongTermPricingEntries"
            case nextToken = "NextToken"
        }
    }

    public struct ListPickupLocationsRequest: AWSEncodableShape {
        /// The maximum number of locations to list per page.
        public let maxResults: Int?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of ListPickupLocationsRequest objects, you have the option of specifying NextToken as the starting point for your returned list.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPickupLocationsResult: AWSDecodableShape {
        /// Information about the address of pickup locations.
        public let addresses: [Address]?
        /// HTTP requests are stateless. To identify what object comes "next" in the list of ListPickupLocationsResult objects, you have the option of specifying NextToken as the starting point for your returned list.
        public let nextToken: String?

        @inlinable
        public init(addresses: [Address]? = nil, nextToken: String? = nil) {
            self.addresses = addresses
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case addresses = "Addresses"
            case nextToken = "NextToken"
        }
    }

    public struct ListServiceVersionsRequest: AWSEncodableShape {
        /// A list of names and versions of dependant services of the requested service.
        public let dependentServices: [DependentService]?
        /// The maximum number of ListServiceVersions objects to return.
        public let maxResults: Int?
        /// Because HTTP requests are stateless, this is the starting point for the next list of returned  ListServiceVersionsRequest versions.
        public let nextToken: String?
        /// The name of the service for which you're requesting supported versions.
        public let serviceName: ServiceName

        @inlinable
        public init(dependentServices: [DependentService]? = nil, maxResults: Int? = nil, nextToken: String? = nil, serviceName: ServiceName) {
            self.dependentServices = dependentServices
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.dependentServices?.forEach {
                try $0.validate(name: "\(name).dependentServices[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case dependentServices = "DependentServices"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case serviceName = "ServiceName"
        }
    }

    public struct ListServiceVersionsResult: AWSDecodableShape {
        /// A list of names and versions of dependant services of the service for which the system provided supported versions.
        public let dependentServices: [DependentService]?
        /// Because HTTP requests are stateless, this is the starting point of the next list of returned  ListServiceVersionsResult results.
        public let nextToken: String?
        /// The name of the service for which the system provided supported versions.
        public let serviceName: ServiceName
        /// A list of supported versions.
        public let serviceVersions: [ServiceVersion]

        @inlinable
        public init(dependentServices: [DependentService]? = nil, nextToken: String? = nil, serviceName: ServiceName, serviceVersions: [ServiceVersion]) {
            self.dependentServices = dependentServices
            self.nextToken = nextToken
            self.serviceName = serviceName
            self.serviceVersions = serviceVersions
        }

        private enum CodingKeys: String, CodingKey {
            case dependentServices = "DependentServices"
            case nextToken = "NextToken"
            case serviceName = "ServiceName"
            case serviceVersions = "ServiceVersions"
        }
    }

    public struct LongTermPricingListEntry: AWSDecodableShape {
        /// The current active jobs on the device the long-term pricing type.
        public let currentActiveJob: String?
        /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
        public let isLongTermPricingAutoRenew: Bool?
        /// The IDs of the jobs that are associated with a long-term pricing type.
        public let jobIds: [String]?
        /// The end date the long-term pricing contract.
        public let longTermPricingEndDate: Date?
        /// The ID of the long-term pricing type for the device.
        public let longTermPricingId: String?
        /// The start date of the long-term pricing contract.
        public let longTermPricingStartDate: Date?
        /// The status of the long-term pricing type.
        public let longTermPricingStatus: String?
        /// The type of long-term pricing that was selected for the device.
        public let longTermPricingType: LongTermPricingType?
        /// A new device that replaces a device that is ordered with long-term pricing.
        public let replacementJob: String?
        /// The type of Snow Family devices associated with this long-term pricing job.
        public let snowballType: SnowballType?

        @inlinable
        public init(currentActiveJob: String? = nil, isLongTermPricingAutoRenew: Bool? = nil, jobIds: [String]? = nil, longTermPricingEndDate: Date? = nil, longTermPricingId: String? = nil, longTermPricingStartDate: Date? = nil, longTermPricingStatus: String? = nil, longTermPricingType: LongTermPricingType? = nil, replacementJob: String? = nil, snowballType: SnowballType? = nil) {
            self.currentActiveJob = currentActiveJob
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.jobIds = jobIds
            self.longTermPricingEndDate = longTermPricingEndDate
            self.longTermPricingId = longTermPricingId
            self.longTermPricingStartDate = longTermPricingStartDate
            self.longTermPricingStatus = longTermPricingStatus
            self.longTermPricingType = longTermPricingType
            self.replacementJob = replacementJob
            self.snowballType = snowballType
        }

        private enum CodingKeys: String, CodingKey {
            case currentActiveJob = "CurrentActiveJob"
            case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
            case jobIds = "JobIds"
            case longTermPricingEndDate = "LongTermPricingEndDate"
            case longTermPricingId = "LongTermPricingId"
            case longTermPricingStartDate = "LongTermPricingStartDate"
            case longTermPricingStatus = "LongTermPricingStatus"
            case longTermPricingType = "LongTermPricingType"
            case replacementJob = "ReplacementJob"
            case snowballType = "SnowballType"
        }
    }

    public struct NFSOnDeviceServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum NFS storage for one Snow Family device.
        public let storageLimit: Int?
        /// The scale unit of the NFS storage on the device. Valid values: TB.
        public let storageUnit: StorageUnit?

        @inlinable
        public init(storageLimit: Int? = nil, storageUnit: StorageUnit? = nil) {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.storageLimit, name: "storageLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case storageLimit = "StorageLimit"
            case storageUnit = "StorageUnit"
        }
    }

    public struct Notification: AWSEncodableShape & AWSDecodableShape {
        /// Used to send SNS notifications for the person picking up the device (identified during job creation).
        public let devicePickupSnsTopicARN: String?
        /// The list of job states that will trigger a notification for this job.
        public let jobStatesToNotify: [JobState]?
        /// Any change in job state will trigger a notification for this job.
        public let notifyAll: Bool?
        /// The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the CreateTopic Amazon SNS API action. You can subscribe email addresses to an Amazon SNS topic through the Amazon Web Services Management Console, or by using the Subscribe Amazon Simple Notification Service (Amazon SNS) API action.
        public let snsTopicARN: String?

        @inlinable
        public init(devicePickupSnsTopicARN: String? = nil, jobStatesToNotify: [JobState]? = nil, notifyAll: Bool? = nil, snsTopicARN: String? = nil) {
            self.devicePickupSnsTopicARN = devicePickupSnsTopicARN
            self.jobStatesToNotify = jobStatesToNotify
            self.notifyAll = notifyAll
            self.snsTopicARN = snsTopicARN
        }

        public func validate(name: String) throws {
            try self.validate(self.devicePickupSnsTopicARN, name: "devicePickupSnsTopicARN", parent: name, max: 255)
            try self.validate(self.devicePickupSnsTopicARN, name: "devicePickupSnsTopicARN", parent: name, pattern: "^arn:aws.*:sns:.*:[0-9]{12}:")
            try self.validate(self.snsTopicARN, name: "snsTopicARN", parent: name, max: 255)
            try self.validate(self.snsTopicARN, name: "snsTopicARN", parent: name, pattern: "^arn:aws.*:sns:.*:[0-9]{12}:")
        }

        private enum CodingKeys: String, CodingKey {
            case devicePickupSnsTopicARN = "DevicePickupSnsTopicARN"
            case jobStatesToNotify = "JobStatesToNotify"
            case notifyAll = "NotifyAll"
            case snsTopicARN = "SnsTopicARN"
        }
    }

    public struct OnDeviceServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of EKS Anywhere on the Snow Family device.
        public let eksOnDeviceService: EKSOnDeviceServiceConfiguration?
        /// Represents the NFS (Network File System) service on a Snow Family device.
        public let nfsOnDeviceService: NFSOnDeviceServiceConfiguration?
        /// Configuration for Amazon S3 compatible storage on Snow family devices.
        public let s3OnDeviceService: S3OnDeviceServiceConfiguration?
        /// Represents the Storage Gateway service Tape Gateway type on a Snow Family device.
        public let tgwOnDeviceService: TGWOnDeviceServiceConfiguration?

        @inlinable
        public init(eksOnDeviceService: EKSOnDeviceServiceConfiguration? = nil, nfsOnDeviceService: NFSOnDeviceServiceConfiguration? = nil, s3OnDeviceService: S3OnDeviceServiceConfiguration? = nil, tgwOnDeviceService: TGWOnDeviceServiceConfiguration? = nil) {
            self.eksOnDeviceService = eksOnDeviceService
            self.nfsOnDeviceService = nfsOnDeviceService
            self.s3OnDeviceService = s3OnDeviceService
            self.tgwOnDeviceService = tgwOnDeviceService
        }

        public func validate(name: String) throws {
            try self.eksOnDeviceService?.validate(name: "\(name).eksOnDeviceService")
            try self.nfsOnDeviceService?.validate(name: "\(name).nfsOnDeviceService")
            try self.s3OnDeviceService?.validate(name: "\(name).s3OnDeviceService")
            try self.tgwOnDeviceService?.validate(name: "\(name).tgwOnDeviceService")
        }

        private enum CodingKeys: String, CodingKey {
            case eksOnDeviceService = "EKSOnDeviceService"
            case nfsOnDeviceService = "NFSOnDeviceService"
            case s3OnDeviceService = "S3OnDeviceService"
            case tgwOnDeviceService = "TGWOnDeviceService"
        }
    }

    public struct PickupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The unique ID for a device that will be picked up.
        public let devicePickupId: String?
        /// The email address of the person picking up the device.
        public let email: String?
        /// Expiration date of the credential identifying the person picking up the device.
        public let identificationExpirationDate: Date?
        /// Organization that issued the credential identifying the person picking up the device.
        public let identificationIssuingOrg: String?
        /// The number on the credential identifying the person picking up the device.
        public let identificationNumber: String?
        /// The name of the person picking up the device.
        public let name: String?
        /// The phone number of the person picking up the device.
        public let phoneNumber: String?

        @inlinable
        public init(devicePickupId: String? = nil, email: String? = nil, identificationExpirationDate: Date? = nil, identificationIssuingOrg: String? = nil, identificationNumber: String? = nil, name: String? = nil, phoneNumber: String? = nil) {
            self.devicePickupId = devicePickupId
            self.email = email
            self.identificationExpirationDate = identificationExpirationDate
            self.identificationIssuingOrg = identificationIssuingOrg
            self.identificationNumber = identificationNumber
            self.name = name
            self.phoneNumber = phoneNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.devicePickupId, name: "devicePickupId", parent: name, max: 40)
            try self.validate(self.devicePickupId, name: "devicePickupId", parent: name, min: 40)
            try self.validate(self.devicePickupId, name: "devicePickupId", parent: name, pattern: "^DPID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, min: 3)
            try self.validate(self.email, name: "email", parent: name, pattern: "^(?=.{3,100}$).+@.+[.].+$")
            try self.validate(self.identificationIssuingOrg, name: "identificationIssuingOrg", parent: name, max: 1024)
            try self.validate(self.identificationIssuingOrg, name: "identificationIssuingOrg", parent: name, min: 1)
            try self.validate(self.identificationIssuingOrg, name: "identificationIssuingOrg", parent: name, pattern: ".*")
            try self.validate(self.identificationNumber, name: "identificationNumber", parent: name, max: 1024)
            try self.validate(self.identificationNumber, name: "identificationNumber", parent: name, min: 1)
            try self.validate(self.identificationNumber, name: "identificationNumber", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 30)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 7)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^\\s*(?:\\+?(\\d{1,3}))?[-. (]*(\\d{3})[-. )]*(\\d{3})[-. ]*(\\d{4})(?: *x(\\d+))?\\s*$")
        }

        private enum CodingKeys: String, CodingKey {
            case devicePickupId = "DevicePickupId"
            case email = "Email"
            case identificationExpirationDate = "IdentificationExpirationDate"
            case identificationIssuingOrg = "IdentificationIssuingOrg"
            case identificationNumber = "IdentificationNumber"
            case name = "Name"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct S3OnDeviceServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// >Fault tolerance level of the cluster. This indicates the number of nodes that can go down without degrading the performance of the cluster. This additional input helps when the specified StorageLimit matches more than one Amazon S3 compatible storage on Snow family devices service configuration.
        public let faultTolerance: Int?
        /// Applicable when creating a cluster. Specifies how many nodes are needed for Amazon S3 compatible storage on Snow family devices. If specified, the other input can be omitted.
        public let serviceSize: Int?
        /// If the specified storage limit value matches storage limit of one of the defined configurations, that configuration will be used.  If the specified storage limit value does not match any defined configuration, the request will fail. If more than one configuration has  the same storage limit as specified, the other input need to be provided.
        public let storageLimit: Double?
        /// Storage unit. Currently the only supported unit is TB.
        public let storageUnit: StorageUnit?

        @inlinable
        public init(faultTolerance: Int? = nil, serviceSize: Int? = nil, storageLimit: Double? = nil, storageUnit: StorageUnit? = nil) {
            self.faultTolerance = faultTolerance
            self.serviceSize = serviceSize
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.faultTolerance, name: "faultTolerance", parent: name, max: 4)
            try self.validate(self.faultTolerance, name: "faultTolerance", parent: name, min: 1)
            try self.validate(self.serviceSize, name: "serviceSize", parent: name, max: 16)
            try self.validate(self.serviceSize, name: "serviceSize", parent: name, min: 3)
            try self.validate(self.storageLimit, name: "storageLimit", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case faultTolerance = "FaultTolerance"
            case serviceSize = "ServiceSize"
            case storageLimit = "StorageLimit"
            case storageUnit = "StorageUnit"
        }
    }

    public struct S3Resource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket.
        public let bucketArn: String?
        /// For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
        public let keyRange: KeyRange?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
        public let targetOnDeviceServices: [TargetOnDeviceService]?

        @inlinable
        public init(bucketArn: String? = nil, keyRange: KeyRange? = nil, targetOnDeviceServices: [TargetOnDeviceService]? = nil) {
            self.bucketArn = bucketArn
            self.keyRange = keyRange
            self.targetOnDeviceServices = targetOnDeviceServices
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, max: 255)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, pattern: "^arn:aws.*:*$")
            try self.keyRange?.validate(name: "\(name).keyRange")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "BucketArn"
            case keyRange = "KeyRange"
            case targetOnDeviceServices = "TargetOnDeviceServices"
        }
    }

    public struct ServiceVersion: AWSEncodableShape & AWSDecodableShape {
        /// The version number of the requested service.
        public let version: String?

        @inlinable
        public init(version: String? = nil) {
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.version, name: "version", parent: name, max: 1024)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case version = "Version"
        }
    }

    public struct Shipment: AWSDecodableShape {
        /// Status information for a shipment.
        public let status: String?
        /// The tracking number for this job. Using this tracking number with your region's carrier's website, you can track a Snow device as the carrier transports it. For India, the carrier is Amazon Logistics. For all other regions, UPS is the carrier.
        public let trackingNumber: String?

        @inlinable
        public init(status: String? = nil, trackingNumber: String? = nil) {
            self.status = status
            self.trackingNumber = trackingNumber
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case trackingNumber = "TrackingNumber"
        }
    }

    public struct ShippingDetails: AWSDecodableShape {
        /// The Status and TrackingNumber values for a Snow device being returned to Amazon Web Services for a particular job.
        public let inboundShipment: Shipment?
        /// The Status and TrackingNumber values for a Snow device being delivered to the address that you specified for a particular job.
        public let outboundShipment: Shipment?
        /// The shipping speed for a particular job. This speed doesn't dictate how soon you'll get the Snow device from the job's creation date. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:   In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.   In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.   In India, Snow devices are delivered in one to seven days.   In the United States of America (US), you have access to one-day shipping and two-day shipping.
        public let shippingOption: ShippingOption?

        @inlinable
        public init(inboundShipment: Shipment? = nil, outboundShipment: Shipment? = nil, shippingOption: ShippingOption? = nil) {
            self.inboundShipment = inboundShipment
            self.outboundShipment = outboundShipment
            self.shippingOption = shippingOption
        }

        private enum CodingKeys: String, CodingKey {
            case inboundShipment = "InboundShipment"
            case outboundShipment = "OutboundShipment"
            case shippingOption = "ShippingOption"
        }
    }

    public struct SnowconeDeviceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configures the wireless connection for the Snowcone device.
        public let wirelessConnection: WirelessConnection?

        @inlinable
        public init(wirelessConnection: WirelessConnection? = nil) {
            self.wirelessConnection = wirelessConnection
        }

        private enum CodingKeys: String, CodingKey {
            case wirelessConnection = "WirelessConnection"
        }
    }

    public struct TGWOnDeviceServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of virtual tapes to store on one Snow Family device. Due to physical resource limitations, this value must be set to 80 for Snowball Edge.
        public let storageLimit: Int?
        /// The scale unit of the virtual tapes on the device.
        public let storageUnit: StorageUnit?

        @inlinable
        public init(storageLimit: Int? = nil, storageUnit: StorageUnit? = nil) {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.storageLimit, name: "storageLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case storageLimit = "StorageLimit"
            case storageUnit = "StorageUnit"
        }
    }

    public struct TargetOnDeviceService: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name of the service on the Snow Family device that your transferred data will be exported from or imported into.
        public let serviceName: DeviceServiceName?
        /// Specifies whether the data is being imported or exported. You can import or export the data, or use it locally on the device.
        public let transferOption: TransferOption?

        @inlinable
        public init(serviceName: DeviceServiceName? = nil, transferOption: TransferOption? = nil) {
            self.serviceName = serviceName
            self.transferOption = transferOption
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "ServiceName"
            case transferOption = "TransferOption"
        }
    }

    public struct TaxDocuments: AWSEncodableShape & AWSDecodableShape {
        public let ind: INDTaxDocuments?

        @inlinable
        public init(ind: INDTaxDocuments? = nil) {
            self.ind = ind
        }

        public func validate(name: String) throws {
            try self.ind?.validate(name: "\(name).ind")
        }

        private enum CodingKeys: String, CodingKey {
            case ind = "IND"
        }
    }

    public struct UpdateClusterRequest: AWSEncodableShape {
        /// The ID of the updated Address object.
        public let addressId: String?
        /// The cluster ID of the cluster that you want to update, for example CID123e4567-e89b-12d3-a456-426655440000.
        public let clusterId: String
        /// The updated description of this cluster.
        public let description: String?
        /// The updated ID for the forwarding address for a cluster. This field is not supported in most regions.
        public let forwardingAddressId: String?
        /// The new or updated Notification object.
        public let notification: Notification?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
        public let onDeviceServiceConfiguration: OnDeviceServiceConfiguration?
        /// The updated arrays of JobResource objects that can include updated S3Resource objects or LambdaResource objects.
        public let resources: JobResource?
        /// The new role Amazon Resource Name (ARN) that you want to associate with this cluster. To create a role ARN, use the CreateRole API action in Identity and Access Management (IAM).
        public let roleARN: String?
        /// The updated shipping option value of this cluster's ShippingDetails object.
        public let shippingOption: ShippingOption?

        @inlinable
        public init(addressId: String? = nil, clusterId: String, description: String? = nil, forwardingAddressId: String? = nil, notification: Notification? = nil, onDeviceServiceConfiguration: OnDeviceServiceConfiguration? = nil, resources: JobResource? = nil, roleARN: String? = nil, shippingOption: ShippingOption? = nil) {
            self.addressId = addressId
            self.clusterId = clusterId
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
        }

        public func validate(name: String) throws {
            try self.validate(self.addressId, name: "addressId", parent: name, max: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, min: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 39)
            try self.validate(self.clusterId, name: "clusterId", parent: name, pattern: "^CID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, max: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, min: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.notification?.validate(name: "\(name).notification")
            try self.onDeviceServiceConfiguration?.validate(name: "\(name).onDeviceServiceConfiguration")
            try self.resources?.validate(name: "\(name).resources")
            try self.validate(self.roleARN, name: "roleARN", parent: name, max: 255)
            try self.validate(self.roleARN, name: "roleARN", parent: name, pattern: "^arn:aws.*:iam::[0-9]{12}:role/")
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case clusterId = "ClusterId"
            case description = "Description"
            case forwardingAddressId = "ForwardingAddressId"
            case notification = "Notification"
            case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
            case resources = "Resources"
            case roleARN = "RoleARN"
            case shippingOption = "ShippingOption"
        }
    }

    public struct UpdateClusterResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateJobRequest: AWSEncodableShape {
        /// The ID of the updated Address object.
        public let addressId: String?
        /// The updated description of this job's JobMetadata object.
        public let description: String?
        /// The updated ID for the forwarding address for a job. This field is not supported in most regions.
        public let forwardingAddressId: String?
        /// The job ID of the job that you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String
        /// The new or updated Notification object.
        public let notification: Notification?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
        public let onDeviceServiceConfiguration: OnDeviceServiceConfiguration?
        public let pickupDetails: PickupDetails?
        /// The updated JobResource object, or the updated JobResource object.
        public let resources: JobResource?
        /// The new role Amazon Resource Name (ARN) that you want to associate with this job. To create a role ARN, use the CreateRoleIdentity and Access Management (IAM) API action.
        public let roleARN: String?
        /// The updated shipping option value of this job's ShippingDetails object.
        public let shippingOption: ShippingOption?
        /// The updated SnowballCapacityPreference of this job's JobMetadata object. The 50 TB Snowballs are only available in the US regions. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public let snowballCapacityPreference: SnowballCapacity?

        @inlinable
        public init(addressId: String? = nil, description: String? = nil, forwardingAddressId: String? = nil, jobId: String, notification: Notification? = nil, onDeviceServiceConfiguration: OnDeviceServiceConfiguration? = nil, pickupDetails: PickupDetails? = nil, resources: JobResource? = nil, roleARN: String? = nil, shippingOption: ShippingOption? = nil, snowballCapacityPreference: SnowballCapacity? = nil) {
            self.addressId = addressId
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.jobId = jobId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.pickupDetails = pickupDetails
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballCapacityPreference = snowballCapacityPreference
        }

        public func validate(name: String) throws {
            try self.validate(self.addressId, name: "addressId", parent: name, max: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, min: 40)
            try self.validate(self.addressId, name: "addressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, max: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, min: 40)
            try self.validate(self.forwardingAddressId, name: "forwardingAddressId", parent: name, pattern: "^ADID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.notification?.validate(name: "\(name).notification")
            try self.onDeviceServiceConfiguration?.validate(name: "\(name).onDeviceServiceConfiguration")
            try self.pickupDetails?.validate(name: "\(name).pickupDetails")
            try self.resources?.validate(name: "\(name).resources")
            try self.validate(self.roleARN, name: "roleARN", parent: name, max: 255)
            try self.validate(self.roleARN, name: "roleARN", parent: name, pattern: "^arn:aws.*:iam::[0-9]{12}:role/")
        }

        private enum CodingKeys: String, CodingKey {
            case addressId = "AddressId"
            case description = "Description"
            case forwardingAddressId = "ForwardingAddressId"
            case jobId = "JobId"
            case notification = "Notification"
            case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
            case pickupDetails = "PickupDetails"
            case resources = "Resources"
            case roleARN = "RoleARN"
            case shippingOption = "ShippingOption"
            case snowballCapacityPreference = "SnowballCapacityPreference"
        }
    }

    public struct UpdateJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateJobShipmentStateRequest: AWSEncodableShape {
        /// The job ID of the job whose shipment date you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
        public let jobId: String
        /// The state of a device when it is being shipped.  Set to RECEIVED when the device arrives at your location. Set to RETURNED when you have returned the device to Amazon Web Services.
        public let shipmentState: ShipmentState

        @inlinable
        public init(jobId: String, shipmentState: ShipmentState) {
            self.jobId = jobId
            self.shipmentState = shipmentState
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 39)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case shipmentState = "ShipmentState"
        }
    }

    public struct UpdateJobShipmentStateResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLongTermPricingRequest: AWSEncodableShape {
        /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
        public let isLongTermPricingAutoRenew: Bool?
        /// The ID of the long-term pricing type for the device.
        public let longTermPricingId: String
        /// Specifies that a device that is ordered with long-term pricing should be replaced with a new device.
        public let replacementJob: String?

        @inlinable
        public init(isLongTermPricingAutoRenew: Bool? = nil, longTermPricingId: String, replacementJob: String? = nil) {
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.longTermPricingId = longTermPricingId
            self.replacementJob = replacementJob
        }

        public func validate(name: String) throws {
            try self.validate(self.longTermPricingId, name: "longTermPricingId", parent: name, max: 41)
            try self.validate(self.longTermPricingId, name: "longTermPricingId", parent: name, min: 41)
            try self.validate(self.longTermPricingId, name: "longTermPricingId", parent: name, pattern: "^LTPID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.replacementJob, name: "replacementJob", parent: name, max: 39)
            try self.validate(self.replacementJob, name: "replacementJob", parent: name, min: 39)
            try self.validate(self.replacementJob, name: "replacementJob", parent: name, pattern: "^(M|J)ID[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
            case longTermPricingId = "LongTermPricingId"
            case replacementJob = "ReplacementJob"
        }
    }

    public struct UpdateLongTermPricingResult: AWSDecodableShape {
        public init() {}
    }

    public struct WirelessConnection: AWSEncodableShape & AWSDecodableShape {
        /// Enables the Wi-Fi adapter on an Snowcone device.
        public let isWifiEnabled: Bool?

        @inlinable
        public init(isWifiEnabled: Bool? = nil) {
            self.isWifiEnabled = isWifiEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isWifiEnabled = "IsWifiEnabled"
        }
    }
}

// MARK: - Errors

/// Error enum for Snowball
public struct SnowballErrorType: AWSErrorType {
    enum Code: String {
        case clusterLimitExceededException = "ClusterLimitExceededException"
        case conflictException = "ConflictException"
        case ec2RequestFailedException = "Ec2RequestFailedException"
        case invalidAddressException = "InvalidAddressException"
        case invalidInputCombinationException = "InvalidInputCombinationException"
        case invalidJobStateException = "InvalidJobStateException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidResourceException = "InvalidResourceException"
        case kmsRequestFailedException = "KMSRequestFailedException"
        case returnShippingLabelAlreadyExistsException = "ReturnShippingLabelAlreadyExistsException"
        case unsupportedAddressException = "UnsupportedAddressException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Snowball
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Job creation failed. Currently, clusters support five nodes. If you have fewer than five nodes for your cluster and you have more nodes to create for this cluster, try again and create jobs until your cluster has exactly five nodes.
    public static var clusterLimitExceededException: Self { .init(.clusterLimitExceededException) }
    /// You get this exception when you call CreateReturnShippingLabel more than once when other requests are not completed.
    public static var conflictException: Self { .init(.conflictException) }
    /// Your user lacks the necessary Amazon EC2 permissions to perform the attempted action.
    public static var ec2RequestFailedException: Self { .init(.ec2RequestFailedException) }
    /// The address provided was invalid. Check the address with your region's carrier, and try again.
    public static var invalidAddressException: Self { .init(.invalidAddressException) }
    /// Job or cluster creation failed. One or more inputs were invalid. Confirm that the CreateClusterRequest$SnowballType value supports your CreateJobRequest$JobType, and try again.
    public static var invalidInputCombinationException: Self { .init(.invalidInputCombinationException) }
    /// The action can't be performed because the job's current state doesn't allow that action to be performed.
    public static var invalidJobStateException: Self { .init(.invalidJobStateException) }
    /// The NextToken string was altered unexpectedly, and the operation has stopped. Run the operation without changing the NextToken string, and try again.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// The specified resource can't be found. Check the information you provided in your last request, and try again.
    public static var invalidResourceException: Self { .init(.invalidResourceException) }
    /// The provided Key Management Service key lacks the permissions to perform the specified CreateJob or UpdateJob action.
    public static var kmsRequestFailedException: Self { .init(.kmsRequestFailedException) }
    /// You get this exception if you call CreateReturnShippingLabel and a valid return shipping label already exists. In this case, use DescribeReturnShippingLabel to get the URL.
    public static var returnShippingLabelAlreadyExistsException: Self { .init(.returnShippingLabelAlreadyExistsException) }
    /// The address is either outside the serviceable area for your region, or an error occurred. Check the address with your region's carrier and try again. If the issue persists, contact Amazon Web Services Support.
    public static var unsupportedAddressException: Self { .init(.unsupportedAddressException) }
}

extension SnowballErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Snowball.ConflictException.self,
        "InvalidResourceException": Snowball.InvalidResourceException.self
    ]
}

extension SnowballErrorType: Equatable {
    public static func == (lhs: SnowballErrorType, rhs: SnowballErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SnowballErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
