//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension GeoPlaces {
    // MARK: Enums

    public enum AutocompleteAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case core = "Core"
        public var description: String { return self.rawValue }
    }

    public enum AutocompleteFilterPlaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case locality = "Locality"
        case postalCode = "PostalCode"
        public var description: String { return self.rawValue }
    }

    public enum AutocompleteIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        public var description: String { return self.rawValue }
    }

    public enum GeocodeAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "Access"
        case timeZone = "TimeZone"
        public var description: String { return self.rawValue }
    }

    public enum GeocodeFilterPlaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case interpolatedAddress = "InterpolatedAddress"
        case intersection = "Intersection"
        case locality = "Locality"
        case pointAddress = "PointAddress"
        case postalCode = "PostalCode"
        case street = "Street"
        public var description: String { return self.rawValue }
    }

    public enum GeocodeIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum GetPlaceAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "Access"
        case contact = "Contact"
        case phonemes = "Phonemes"
        case timeZone = "TimeZone"
        public var description: String { return self.rawValue }
    }

    public enum GetPlaceIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum PlaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case block = "Block"
        case country = "Country"
        case district = "District"
        case interpolatedAddress = "InterpolatedAddress"
        case intersection = "Intersection"
        case locality = "Locality"
        case pointAddress = "PointAddress"
        case pointOfInterest = "PointOfInterest"
        case postalCode = "PostalCode"
        case region = "Region"
        case street = "Street"
        case subBlock = "SubBlock"
        case subDistrict = "SubDistrict"
        case subRegion = "SubRegion"
        public var description: String { return self.rawValue }
    }

    public enum PostalAuthority: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case usps = "Usps"
        public var description: String { return self.rawValue }
    }

    public enum PostalCodeMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enumerateSpannedLocalities = "EnumerateSpannedLocalities"
        case mergeAllSpannedLocalities = "MergeAllSpannedLocalities"
        public var description: String { return self.rawValue }
    }

    public enum PostalCodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case uspsZip = "UspsZip"
        case uspsZipPlus4 = "UspsZipPlus4"
        public var description: String { return self.rawValue }
    }

    public enum QueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessChain = "BusinessChain"
        case category = "Category"
        public var description: String { return self.rawValue }
    }

    public enum RecordTypeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case firm = "Firm"
        case general = "General"
        case highRise = "HighRise"
        case postOfficeBox = "PostOfficeBox"
        case rural = "Rural"
        case street = "Street"
        public var description: String { return self.rawValue }
    }

    public enum ReverseGeocodeAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "Access"
        case timeZone = "TimeZone"
        public var description: String { return self.rawValue }
    }

    public enum ReverseGeocodeFilterPlaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case interpolatedAddress = "InterpolatedAddress"
        case intersection = "Intersection"
        case locality = "Locality"
        case pointAddress = "PointAddress"
        case street = "Street"
        public var description: String { return self.rawValue }
    }

    public enum ReverseGeocodeIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum SearchNearbyAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "Access"
        case contact = "Contact"
        case phonemes = "Phonemes"
        case timeZone = "TimeZone"
        public var description: String { return self.rawValue }
    }

    public enum SearchNearbyIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum SearchTextAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "Access"
        case contact = "Contact"
        case phonemes = "Phonemes"
        case timeZone = "TimeZone"
        public var description: String { return self.rawValue }
    }

    public enum SearchTextIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum SuggestAdditionalFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "Access"
        case core = "Core"
        case phonemes = "Phonemes"
        case timeZone = "TimeZone"
        public var description: String { return self.rawValue }
    }

    public enum SuggestIntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        public var description: String { return self.rawValue }
    }

    public enum SuggestResultItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case place = "Place"
        case query = "Query"
        public var description: String { return self.rawValue }
    }

    public enum TypePlacement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterBaseName = "AfterBaseName"
        case beforeBaseName = "BeforeBaseName"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse = "CannotParse"
        ///     The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed = "FieldValidationFailed"
        /// The required input is missing.
        case missing = "Missing"
        /// The input is invalid but no more specific reason is applicable.
        case other = "Other"
        /// No such field is supported.
        case unknownField = "UnknownField"
        /// No such operation is supported.
        case unknownOperation = "UnknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum ZipClassificationCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case military = "Military"
        case postOfficeBoxes = "PostOfficeBoxes"
        case unique = "Unique"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPoint: AWSDecodableShape {
        /// The position, in longitude and latitude.
        public let position: [Double]?

        @inlinable
        public init(position: [Double]? = nil) {
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
        }
    }

    public struct AccessRestriction: AWSDecodableShape {
        /// Categories of results that results must belong too.
        public let categories: [Category]?
        /// The restriction.
        public let restricted: Bool?

        @inlinable
        public init(categories: [Category]? = nil, restricted: Bool? = nil) {
            self.categories = categories
            self.restricted = restricted
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case restricted = "Restricted"
        }
    }

    public struct Address: AWSDecodableShape {
        /// The number that identifies an address within a street.
        public let addressNumber: String?
        /// Name of the block.  Example: Sunny Mansion 203 block: 2 Chome
        public let block: String?
        /// The name of the building at the address.
        public let building: String?
        /// The country component of the address.
        public let country: Country?
        /// The district or division of a locality associated with this address.
        public let district: String?
        /// Name of the streets in the intersection.  Example: ["Friedrichstraße","Unter den Linden"]
        public let intersection: [String]?
        /// Assembled address value built out of the address components, according to the regional postal rules. This is the correctly formatted address.
        public let label: String?
        /// The locality or city of the address. Example: Vancouver.
        public let locality: String?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code, for which the result should posses.
        public let postalCode: String?
        /// The region or state results should be present in.  Example: North Rhine-Westphalia.
        public let region: Region?
        /// The name of the street results should be present in.
        public let street: String?
        /// Components of the street.  Example: Younge from the "Younge street".
        public let streetComponents: [StreetComponents]?
        /// Name of sub-block.  Example: Sunny Mansion 203 sub-block: 4
        public let subBlock: String?
        /// A subdivision of a district.  Example: Minden-Lübbecke.
        public let subDistrict: String?
        /// The sub-region or county for which results should be present in.
        public let subRegion: SubRegion?

        @inlinable
        public init(addressNumber: String? = nil, block: String? = nil, building: String? = nil, country: Country? = nil, district: String? = nil, intersection: [String]? = nil, label: String? = nil, locality: String? = nil, postalCode: String? = nil, region: Region? = nil, street: String? = nil, streetComponents: [StreetComponents]? = nil, subBlock: String? = nil, subDistrict: String? = nil, subRegion: SubRegion? = nil) {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.label = label
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.streetComponents = streetComponents
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case block = "Block"
            case building = "Building"
            case country = "Country"
            case district = "District"
            case intersection = "Intersection"
            case label = "Label"
            case locality = "Locality"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case streetComponents = "StreetComponents"
            case subBlock = "SubBlock"
            case subDistrict = "SubDistrict"
            case subRegion = "SubRegion"
        }
    }

    public struct AddressComponentMatchScores: AWSDecodableShape {
        /// The house number or address results should have.
        public let addressNumber: Double?
        /// Name of the block.  Example: Sunny Mansion 203 block: 2 Chome
        public let block: Double?
        /// The name of the building at the address.
        public let building: Double?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public let country: Double?
        /// The district or division of a city the results should be present in.
        public let district: Double?
        /// Name of the streets in the intersection.  Example: ["Friedrichstraße","Unter den Linden"]
        public let intersection: [Double]?
        /// The city or locality results should be present in.  Example: Vancouver.
        public let locality: Double?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code, for which the result should posses.
        public let postalCode: Double?
        /// The region or state results should be to be present in.  Example: North Rhine-Westphalia.
        public let region: Double?
        /// Name of sub-block.  Example: Sunny Mansion 203 sub-block: 4
        public let subBlock: Double?
        /// A subdivision of a district.  Example: Minden-Lübbecke
        public let subDistrict: Double?
        /// The sub-region or county for which results should be present in.
        public let subRegion: Double?

        @inlinable
        public init(addressNumber: Double? = nil, block: Double? = nil, building: Double? = nil, country: Double? = nil, district: Double? = nil, intersection: [Double]? = nil, locality: Double? = nil, postalCode: Double? = nil, region: Double? = nil, subBlock: Double? = nil, subDistrict: Double? = nil, subRegion: Double? = nil) {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case block = "Block"
            case building = "Building"
            case country = "Country"
            case district = "District"
            case intersection = "Intersection"
            case locality = "Locality"
            case postalCode = "PostalCode"
            case region = "Region"
            case subBlock = "SubBlock"
            case subDistrict = "SubDistrict"
            case subRegion = "SubRegion"
        }
    }

    public struct AddressComponentPhonemes: AWSDecodableShape {
        /// How to pronounce the name of the block.
        public let block: [PhonemeTranscription]?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public let country: [PhonemeTranscription]?
        /// How to pronounce the district or division of a city results should be present in.
        public let district: [PhonemeTranscription]?
        /// How to pronounce the city or locality results should be present in.  Example: Vancouver.
        public let locality: [PhonemeTranscription]?
        /// How to pronounce the region or state results should be to be present in.
        public let region: [PhonemeTranscription]?
        /// How to pronounce the name of the street results should be present in.
        public let street: [PhonemeTranscription]?
        /// How to pronounce the name of the sub-block.
        public let subBlock: [PhonemeTranscription]?
        /// How to pronounce the sub-district or division of a city results should be present in.
        public let subDistrict: [PhonemeTranscription]?
        /// How to pronounce the sub-region or county for which results should be present in.
        public let subRegion: [PhonemeTranscription]?

        @inlinable
        public init(block: [PhonemeTranscription]? = nil, country: [PhonemeTranscription]? = nil, district: [PhonemeTranscription]? = nil, locality: [PhonemeTranscription]? = nil, region: [PhonemeTranscription]? = nil, street: [PhonemeTranscription]? = nil, subBlock: [PhonemeTranscription]? = nil, subDistrict: [PhonemeTranscription]? = nil, subRegion: [PhonemeTranscription]? = nil) {
            self.block = block
            self.country = country
            self.district = district
            self.locality = locality
            self.region = region
            self.street = street
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case block = "Block"
            case country = "Country"
            case district = "District"
            case locality = "Locality"
            case region = "Region"
            case street = "Street"
            case subBlock = "SubBlock"
            case subDistrict = "SubDistrict"
            case subRegion = "SubRegion"
        }
    }

    public struct AutocompleteAddressHighlights: AWSDecodableShape {
        /// The house number or address results should have.
        public let addressNumber: [Highlight]?
        /// Name of the block. Example: Sunny Mansion 203
        /// block: 2 Chome
        public let block: [Highlight]?
        /// The name of the building at the address.
        public let building: [Highlight]?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public let country: CountryHighlights?
        /// The district or division of a city the results should be present in.
        public let district: [Highlight]?
        /// Name of the streets in the intersection. For example: e.g. ["Friedrichstraße","Unter den Linden"]
        public let intersection: [[Highlight]]?
        /// Indicates the starting and ending indexes for result items where they are identified to match the input query. This should be used to provide emphasis to output display to make selecting the correct result from a list easier for end users.
        public let label: [Highlight]?
        /// The city or locality results should be present in.  Example: Vancouver.
        public let locality: [Highlight]?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code for which the result should posses.
        public let postalCode: [Highlight]?
        /// The region or state results should be to be present in.  Example: North Rhine-Westphalia.
        public let region: RegionHighlights?
        /// The name of the street results should be present in.
        public let street: [Highlight]?
        /// Name of sub-block. Example Sunny Mansion 203 sub-block: 4
        public let subBlock: [Highlight]?
        /// Indicates the starting and ending index of the title in the text query that match the found title.
        public let subDistrict: [Highlight]?
        /// The sub-region or county for which results should be present in.
        public let subRegion: SubRegionHighlights?

        @inlinable
        public init(addressNumber: [Highlight]? = nil, block: [Highlight]? = nil, building: [Highlight]? = nil, country: CountryHighlights? = nil, district: [Highlight]? = nil, intersection: [[Highlight]]? = nil, label: [Highlight]? = nil, locality: [Highlight]? = nil, postalCode: [Highlight]? = nil, region: RegionHighlights? = nil, street: [Highlight]? = nil, subBlock: [Highlight]? = nil, subDistrict: [Highlight]? = nil, subRegion: SubRegionHighlights? = nil) {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.label = label
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case block = "Block"
            case building = "Building"
            case country = "Country"
            case district = "District"
            case intersection = "Intersection"
            case label = "Label"
            case locality = "Locality"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case subBlock = "SubBlock"
            case subDistrict = "SubDistrict"
            case subRegion = "SubRegion"
        }
    }

    public struct AutocompleteFilter: AWSEncodableShape {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let boundingBox: [Double]?
        public let circle: FilterCircle?
        ///  A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public let includeCountries: [String]?
        /// The included place types.
        public let includePlaceTypes: [AutocompleteFilterPlaceType]?

        @inlinable
        public init(boundingBox: [Double]? = nil, circle: FilterCircle? = nil, includeCountries: [String]? = nil, includePlaceTypes: [AutocompleteFilterPlaceType]? = nil) {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
            self.includePlaceTypes = includePlaceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.circle?.validate(name: "\(name).circle")
            try self.includeCountries?.forEach {
                try validate($0, name: "includeCountries[]", parent: name, max: 3)
                try validate($0, name: "includeCountries[]", parent: name, min: 2)
                try validate($0, name: "includeCountries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, max: 100)
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, min: 1)
            try self.validate(self.includePlaceTypes, name: "includePlaceTypes", parent: name, max: 2)
            try self.validate(self.includePlaceTypes, name: "includePlaceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case circle = "Circle"
            case includeCountries = "IncludeCountries"
            case includePlaceTypes = "IncludePlaceTypes"
        }
    }

    public struct AutocompleteHighlights: AWSDecodableShape {
        /// Describes how part of the result address match the input query.
        public let address: AutocompleteAddressHighlights?
        /// Indicates where the title field in the result matches the input query.
        public let title: [Highlight]?

        @inlinable
        public init(address: AutocompleteAddressHighlights? = nil, title: [Highlight]? = nil) {
            self.address = address
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case title = "Title"
        }
    }

    public struct AutocompleteRequest: AWSEncodableShape {
        /// A list of optional additional parameters that can be requested for each result.
        public let additionalFeatures: [AutocompleteAdditionalFeature]?
        /// The position in longitude and latitude that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format.  The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
        public let biasPosition: [Double]?
        /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
        public let filter: AutocompleteFilter?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: AutocompleteIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// An optional limit for the number of results returned in a single call.
        public let maxResults: Int?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The PostalCodeMode affects how postal code results are returned. If a postal code spans multiple localities and this value is empty,  partial district or locality information may be returned under a single postal code result entry. If it's populated with the value cityLookup, all cities in that postal code are returned.
        public let postalCodeMode: PostalCodeMode?
        /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
        public let queryText: String

        @inlinable
        public init(additionalFeatures: [AutocompleteAdditionalFeature]? = nil, biasPosition: [Double]? = nil, filter: AutocompleteFilter? = nil, intendedUse: AutocompleteIntendedUse? = nil, key: String? = nil, language: String? = nil, maxResults: Int? = nil, politicalView: String? = nil, postalCodeMode: PostalCodeMode? = nil, queryText: String) {
            self.additionalFeatures = additionalFeatures
            self.biasPosition = biasPosition
            self.filter = filter
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.politicalView = politicalView
            self.postalCodeMode = postalCodeMode
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalFeatures, forKey: .additionalFeatures)
            try container.encodeIfPresent(self.biasPosition, forKey: .biasPosition)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.intendedUse, forKey: .intendedUse)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.politicalView, forKey: .politicalView)
            try container.encodeIfPresent(self.postalCodeMode, forKey: .postalCodeMode)
            try container.encode(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 1)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFeatures = "AdditionalFeatures"
            case biasPosition = "BiasPosition"
            case filter = "Filter"
            case intendedUse = "IntendedUse"
            case language = "Language"
            case maxResults = "MaxResults"
            case politicalView = "PoliticalView"
            case postalCodeMode = "PostalCodeMode"
            case queryText = "QueryText"
        }
    }

    public struct AutocompleteResponse: AWSDecodableShape {
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// List of places or results returned for a query.
        public let resultItems: [AutocompleteResultItem]?

        @inlinable
        public init(pricingBucket: String, resultItems: [AutocompleteResultItem]? = nil) {
            self.pricingBucket = pricingBucket
            self.resultItems = resultItems
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.resultItems = try container.decodeIfPresent([AutocompleteResultItem].self, forKey: .resultItems)
        }

        private enum CodingKeys: String, CodingKey {
            case resultItems = "ResultItems"
        }
    }

    public struct AutocompleteResultItem: AWSDecodableShape {
        /// The address associated with this result.
        public let address: Address?
        /// The distance in meters between the center of the search area and this result. Useful to evaluate how far away from the original bias position the result is.
        public let distance: Int64?
        /// Indicates the starting and ending index of the place in the text query that match the found title.
        public let highlights: AutocompleteHighlights?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// The PlaceId of the place associated with this result. This can be used to look up additional details about the result via GetPlace.
        public let placeId: String
        /// PlaceType describes the type of result entry returned.
        public let placeType: PlaceType
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// A formatted string for display when presenting this result to an end user.
        public let title: String

        @inlinable
        public init(address: Address? = nil, distance: Int64? = nil, highlights: AutocompleteHighlights? = nil, language: String? = nil, placeId: String, placeType: PlaceType, politicalView: String? = nil, title: String) {
            self.address = address
            self.distance = distance
            self.highlights = highlights
            self.language = language
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case distance = "Distance"
            case highlights = "Highlights"
            case language = "Language"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case title = "Title"
        }
    }

    public struct BusinessChain: AWSDecodableShape {
        /// The Business Chain Id.
        public let id: String?
        /// The business chain name.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct Category: AWSDecodableShape {
        /// The category ID.
        public let id: String
        /// Localized name of the category type.
        public let localizedName: String?
        /// The category name.
        public let name: String
        /// Boolean which indicates if this category is the primary offered by the place.
        public let primary: Bool?

        @inlinable
        public init(id: String, localizedName: String? = nil, name: String, primary: Bool? = nil) {
            self.id = id
            self.localizedName = localizedName
            self.name = name
            self.primary = primary
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case localizedName = "LocalizedName"
            case name = "Name"
            case primary = "Primary"
        }
    }

    public struct ComponentMatchScores: AWSDecodableShape {
        /// The place's address.
        public let address: AddressComponentMatchScores?
        /// Indicates the starting and ending index of the title in the text query that match the found title.
        public let title: Double?

        @inlinable
        public init(address: AddressComponentMatchScores? = nil, title: Double? = nil) {
            self.address = address
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case title = "Title"
        }
    }

    public struct ContactDetails: AWSDecodableShape {
        /// Categories of results that results must belong too.
        public let categories: [Category]?
        /// The contact's label.
        public let label: String?
        /// The contact's value.
        public let value: String?

        @inlinable
        public init(categories: [Category]? = nil, label: String? = nil, value: String? = nil) {
            self.categories = categories
            self.label = label
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case label = "Label"
            case value = "Value"
        }
    }

    public struct Contacts: AWSDecodableShape {
        /// List of emails for contacts of the result.
        public let emails: [ContactDetails]?
        /// List of fax addresses for the result contact.
        public let faxes: [ContactDetails]?
        /// List of phone numbers for the results contact.
        public let phones: [ContactDetails]?
        /// List of website URLs that belong to the result.
        public let websites: [ContactDetails]?

        @inlinable
        public init(emails: [ContactDetails]? = nil, faxes: [ContactDetails]? = nil, phones: [ContactDetails]? = nil, websites: [ContactDetails]? = nil) {
            self.emails = emails
            self.faxes = faxes
            self.phones = phones
            self.websites = websites
        }

        private enum CodingKeys: String, CodingKey {
            case emails = "Emails"
            case faxes = "Faxes"
            case phones = "Phones"
            case websites = "Websites"
        }
    }

    public struct Country: AWSDecodableShape {
        /// Country, represented by its alpha 2-character code.
        public let code2: String?
        /// Country, represented by its alpha t-character code.
        public let code3: String?
        /// Name of the country.
        public let name: String?

        @inlinable
        public init(code2: String? = nil, code3: String? = nil, name: String? = nil) {
            self.code2 = code2
            self.code3 = code3
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code2 = "Code2"
            case code3 = "Code3"
            case name = "Name"
        }
    }

    public struct CountryHighlights: AWSDecodableShape {
        /// Indicates the starting and ending index of the country code in the text query that match the found title.
        public let code: [Highlight]?
        /// Indicates the starting and ending index of the country code in the text query that match the found title.
        public let name: [Highlight]?

        @inlinable
        public init(code: [Highlight]? = nil, name: [Highlight]? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case name = "Name"
        }
    }

    public struct FilterCircle: AWSEncodableShape {
        /// The center position, in longitude and latitude, of the FilterCircle.
        public let center: [Double]
        /// The radius, in meters, of the FilterCircle.
        public let radius: Int64

        @inlinable
        public init(center: [Double], radius: Int64) {
            self.center = center
            self.radius = radius
        }

        public func validate(name: String) throws {
            try self.validate(self.center, name: "center", parent: name, max: 2)
            try self.validate(self.center, name: "center", parent: name, min: 2)
            try self.validate(self.radius, name: "radius", parent: name, max: 4294967295)
            try self.validate(self.radius, name: "radius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case center = "Center"
            case radius = "Radius"
        }
    }

    public struct FoodType: AWSDecodableShape {
        /// The Food Type Id.
        public let id: String?
        /// Localized name of the food type.
        public let localizedName: String
        /// Boolean which indicates if this food type is the primary offered by the place. For example, if a location serves fast food, but also dessert, he primary would likely be fast food.
        public let primary: Bool?

        @inlinable
        public init(id: String? = nil, localizedName: String, primary: Bool? = nil) {
            self.id = id
            self.localizedName = localizedName
            self.primary = primary
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case localizedName = "LocalizedName"
            case primary = "Primary"
        }
    }

    public struct GeocodeFilter: AWSEncodableShape {
        ///  A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public let includeCountries: [String]?
        /// The included place types.
        public let includePlaceTypes: [GeocodeFilterPlaceType]?

        @inlinable
        public init(includeCountries: [String]? = nil, includePlaceTypes: [GeocodeFilterPlaceType]? = nil) {
            self.includeCountries = includeCountries
            self.includePlaceTypes = includePlaceTypes
        }

        public func validate(name: String) throws {
            try self.includeCountries?.forEach {
                try validate($0, name: "includeCountries[]", parent: name, max: 3)
                try validate($0, name: "includeCountries[]", parent: name, min: 2)
                try validate($0, name: "includeCountries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, max: 100)
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, min: 1)
            try self.validate(self.includePlaceTypes, name: "includePlaceTypes", parent: name, max: 6)
            try self.validate(self.includePlaceTypes, name: "includePlaceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeCountries = "IncludeCountries"
            case includePlaceTypes = "IncludePlaceTypes"
        }
    }

    public struct GeocodeQueryComponents: AWSEncodableShape {
        /// The house number or address results should have.
        public let addressNumber: String?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public let country: String?
        /// The district or division of a city the results should be present in.
        public let district: String?
        /// City or locality results should be present in.  Example: Vancouver.
        public let locality: String?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code for which the result should posses.
        public let postalCode: String?
        /// The region or state results should be to be present in.  Example: North Rhine-Westphalia.
        public let region: String?
        /// The name of the street results should be present in.
        public let street: String?
        /// The sub-region or county for which results should be present in.
        public let subRegion: String?

        @inlinable
        public init(addressNumber: String? = nil, country: String? = nil, district: String? = nil, locality: String? = nil, postalCode: String? = nil, region: String? = nil, street: String? = nil, subRegion: String? = nil) {
            self.addressNumber = addressNumber
            self.country = country
            self.district = district
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case country = "Country"
            case district = "District"
            case locality = "Locality"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case subRegion = "SubRegion"
        }
    }

    public struct GeocodeRequest: AWSEncodableShape {
        /// A list of optional additional parameters, such as time zone, that can be requested for each result.
        public let additionalFeatures: [GeocodeAdditionalFeature]?
        /// The position, in longitude and latitude, that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format.  The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
        public let biasPosition: [Double]?
        /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
        public let filter: GeocodeFilter?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: GeocodeIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// An optional limit for the number of results returned in a single call.
        public let maxResults: Int?
        /// The alpha-2 or alpha-3 character code for the political view of a country.  The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        public let queryComponents: GeocodeQueryComponents?
        /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
        public let queryText: String?

        @inlinable
        public init(additionalFeatures: [GeocodeAdditionalFeature]? = nil, biasPosition: [Double]? = nil, filter: GeocodeFilter? = nil, intendedUse: GeocodeIntendedUse? = nil, key: String? = nil, language: String? = nil, maxResults: Int? = nil, politicalView: String? = nil, queryComponents: GeocodeQueryComponents? = nil, queryText: String? = nil) {
            self.additionalFeatures = additionalFeatures
            self.biasPosition = biasPosition
            self.filter = filter
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.politicalView = politicalView
            self.queryComponents = queryComponents
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalFeatures, forKey: .additionalFeatures)
            try container.encodeIfPresent(self.biasPosition, forKey: .biasPosition)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.intendedUse, forKey: .intendedUse)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.politicalView, forKey: .politicalView)
            try container.encodeIfPresent(self.queryComponents, forKey: .queryComponents)
            try container.encodeIfPresent(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 2)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFeatures = "AdditionalFeatures"
            case biasPosition = "BiasPosition"
            case filter = "Filter"
            case intendedUse = "IntendedUse"
            case language = "Language"
            case maxResults = "MaxResults"
            case politicalView = "PoliticalView"
            case queryComponents = "QueryComponents"
            case queryText = "QueryText"
        }
    }

    public struct GeocodeResponse: AWSDecodableShape {
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// List of places or results returned for a query.
        public let resultItems: [GeocodeResultItem]?

        @inlinable
        public init(pricingBucket: String, resultItems: [GeocodeResultItem]? = nil) {
            self.pricingBucket = pricingBucket
            self.resultItems = resultItems
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.resultItems = try container.decodeIfPresent([GeocodeResultItem].self, forKey: .resultItems)
        }

        private enum CodingKeys: String, CodingKey {
            case resultItems = "ResultItems"
        }
    }

    public struct GeocodeResultItem: AWSDecodableShape {
        /// Position of the access point represent by longitude and latitude.
        public let accessPoints: [AccessPoint]?
        /// The place's address.
        public let address: Address?
        /// Boolean indicating if the address provided has been corrected.
        public let addressNumberCorrected: Bool?
        /// Categories of results that results must belong to.
        public let categories: [Category]?
        /// The distance in meters from the QueryPosition.
        public let distance: Int64?
        /// List of food types offered by this result.
        public let foodTypes: [FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let mapView: [Double]?
        /// Indicates how well the entire input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
        public let matchScores: MatchScoreDetails?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String
        /// A PlaceType is a category that the result place must belong to.
        public let placeType: PlaceType
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position in longitude and latitude.
        public let position: [Double]?
        /// Contains details about the postal code of the place/result.
        public let postalCodeDetails: [PostalCodeDetails]?
        /// The time zone in which the place is located.
        public let timeZone: TimeZone?
        /// The localized display name of this result item based on request parameter language.
        public let title: String

        @inlinable
        public init(accessPoints: [AccessPoint]? = nil, address: Address? = nil, addressNumberCorrected: Bool? = nil, categories: [Category]? = nil, distance: Int64? = nil, foodTypes: [FoodType]? = nil, mapView: [Double]? = nil, matchScores: MatchScoreDetails? = nil, placeId: String, placeType: PlaceType, politicalView: String? = nil, position: [Double]? = nil, postalCodeDetails: [PostalCodeDetails]? = nil, timeZone: TimeZone? = nil, title: String) {
            self.accessPoints = accessPoints
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.matchScores = matchScores
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.timeZone = timeZone
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case address = "Address"
            case addressNumberCorrected = "AddressNumberCorrected"
            case categories = "Categories"
            case distance = "Distance"
            case foodTypes = "FoodTypes"
            case mapView = "MapView"
            case matchScores = "MatchScores"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case position = "Position"
            case postalCodeDetails = "PostalCodeDetails"
            case timeZone = "TimeZone"
            case title = "Title"
        }
    }

    public struct GetPlaceRequest: AWSEncodableShape {
        /// A list of optional additional parameters such as time zone that can be requested for each result.
        public let additionalFeatures: [GetPlaceAdditionalFeature]?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: GetPlaceIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?

        @inlinable
        public init(additionalFeatures: [GetPlaceAdditionalFeature]? = nil, intendedUse: GetPlaceIntendedUse? = nil, key: String? = nil, language: String? = nil, placeId: String, politicalView: String? = nil) {
            self.additionalFeatures = additionalFeatures
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.placeId = placeId
            self.politicalView = politicalView
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.additionalFeatures, key: "additional-features")
            request.encodeQuery(self.intendedUse, key: "intended-use")
            request.encodeQuery(self.key, key: "key")
            request.encodeQuery(self.language, key: "language")
            request.encodePath(self.placeId, key: "PlaceId")
            request.encodeQuery(self.politicalView, key: "political-view")
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 4)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPlaceResponse: AWSDecodableShape {
        /// Position of the access point in (lng,lat).
        public let accessPoints: [AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public let accessRestrictions: [AccessRestriction]?
        /// The place's address.
        public let address: Address?
        /// Boolean indicating if the address provided has been corrected.
        public let addressNumberCorrected: Bool?
        /// The Business Chains associated with the place.
        public let businessChains: [BusinessChain]?
        /// Categories of results that results must belong to.
        public let categories: [Category]?
        /// List of potential contact methods for the result/place.
        public let contacts: Contacts?
        /// List of food types offered by this result.
        public let foodTypes: [FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set of four coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let mapView: [Double]?
        /// List of opening hours objects.
        public let openingHours: [OpeningHours]?
        /// How the various components of the result's address are pronounced in various languages.
        public let phonemes: PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String
        /// A PlaceType is a category that the result place must belong to.
        public let placeType: PlaceType
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position, in longitude and latitude.
        public let position: [Double]?
        /// Contains details about the postal code of the place/result.
        public let postalCodeDetails: [PostalCodeDetails]?
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// The time zone in which the place is located.
        public let timeZone: TimeZone?
        /// The localized display name of this result item based on request parameter language.
        public let title: String

        @inlinable
        public init(accessPoints: [AccessPoint]? = nil, accessRestrictions: [AccessRestriction]? = nil, address: Address? = nil, addressNumberCorrected: Bool? = nil, businessChains: [BusinessChain]? = nil, categories: [Category]? = nil, contacts: Contacts? = nil, foodTypes: [FoodType]? = nil, mapView: [Double]? = nil, openingHours: [OpeningHours]? = nil, phonemes: PhonemeDetails? = nil, placeId: String, placeType: PlaceType, politicalView: String? = nil, position: [Double]? = nil, postalCodeDetails: [PostalCodeDetails]? = nil, pricingBucket: String, timeZone: TimeZone? = nil, title: String) {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.pricingBucket = pricingBucket
            self.timeZone = timeZone
            self.title = title
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessPoints = try container.decodeIfPresent([AccessPoint].self, forKey: .accessPoints)
            self.accessRestrictions = try container.decodeIfPresent([AccessRestriction].self, forKey: .accessRestrictions)
            self.address = try container.decodeIfPresent(Address.self, forKey: .address)
            self.addressNumberCorrected = try container.decodeIfPresent(Bool.self, forKey: .addressNumberCorrected)
            self.businessChains = try container.decodeIfPresent([BusinessChain].self, forKey: .businessChains)
            self.categories = try container.decodeIfPresent([Category].self, forKey: .categories)
            self.contacts = try container.decodeIfPresent(Contacts.self, forKey: .contacts)
            self.foodTypes = try container.decodeIfPresent([FoodType].self, forKey: .foodTypes)
            self.mapView = try container.decodeIfPresent([Double].self, forKey: .mapView)
            self.openingHours = try container.decodeIfPresent([OpeningHours].self, forKey: .openingHours)
            self.phonemes = try container.decodeIfPresent(PhonemeDetails.self, forKey: .phonemes)
            self.placeId = try container.decode(String.self, forKey: .placeId)
            self.placeType = try container.decode(PlaceType.self, forKey: .placeType)
            self.politicalView = try container.decodeIfPresent(String.self, forKey: .politicalView)
            self.position = try container.decodeIfPresent([Double].self, forKey: .position)
            self.postalCodeDetails = try container.decodeIfPresent([PostalCodeDetails].self, forKey: .postalCodeDetails)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.timeZone = try container.decodeIfPresent(TimeZone.self, forKey: .timeZone)
            self.title = try container.decode(String.self, forKey: .title)
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case accessRestrictions = "AccessRestrictions"
            case address = "Address"
            case addressNumberCorrected = "AddressNumberCorrected"
            case businessChains = "BusinessChains"
            case categories = "Categories"
            case contacts = "Contacts"
            case foodTypes = "FoodTypes"
            case mapView = "MapView"
            case openingHours = "OpeningHours"
            case phonemes = "Phonemes"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case position = "Position"
            case postalCodeDetails = "PostalCodeDetails"
            case timeZone = "TimeZone"
            case title = "Title"
        }
    }

    public struct Highlight: AWSDecodableShape {
        /// End index of the highlight.
        public let endIndex: Int?
        /// Start index of the highlight.
        public let startIndex: Int?
        /// The highlight's value.
        public let value: String?

        @inlinable
        public init(endIndex: Int? = nil, startIndex: Int? = nil, value: String? = nil) {
            self.endIndex = endIndex
            self.startIndex = startIndex
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case endIndex = "EndIndex"
            case startIndex = "StartIndex"
            case value = "Value"
        }
    }

    public struct MatchScoreDetails: AWSDecodableShape {
        /// Indicates how well the component input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
        public let components: ComponentMatchScores?
        /// Indicates how well the entire input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
        public let overall: Double?

        @inlinable
        public init(components: ComponentMatchScores? = nil, overall: Double? = nil) {
            self.components = components
            self.overall = overall
        }

        private enum CodingKeys: String, CodingKey {
            case components = "Components"
            case overall = "Overall"
        }
    }

    public struct OpeningHours: AWSDecodableShape {
        /// Categories of results that results must belong too.
        public let categories: [Category]?
        /// Components of the opening hours object.
        public let components: [OpeningHoursComponents]?
        /// List of opening hours in the format they are displayed in. This can vary by result and in most cases represents how the result uniquely formats their opening hours.
        public let display: [String]?
        /// Boolean which indicates if the result/place is currently open.
        public let openNow: Bool?

        @inlinable
        public init(categories: [Category]? = nil, components: [OpeningHoursComponents]? = nil, display: [String]? = nil, openNow: Bool? = nil) {
            self.categories = categories
            self.components = components
            self.display = display
            self.openNow = openNow
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case components = "Components"
            case display = "Display"
            case openNow = "OpenNow"
        }
    }

    public struct OpeningHoursComponents: AWSDecodableShape {
        /// String which represents the duration of the opening period, such as "PT12H00M".
        public let openDuration: String?
        /// String which represents the opening hours, such as "T070000".
        public let openTime: String?
        /// Days or periods when the provided opening hours are in affect.  Example: FREQ:DAILY;BYDAY:MO,TU,WE,TH,SU
        public let recurrence: String?

        @inlinable
        public init(openDuration: String? = nil, openTime: String? = nil, recurrence: String? = nil) {
            self.openDuration = openDuration
            self.openTime = openTime
            self.recurrence = recurrence
        }

        private enum CodingKeys: String, CodingKey {
            case openDuration = "OpenDuration"
            case openTime = "OpenTime"
            case recurrence = "Recurrence"
        }
    }

    public struct PhonemeDetails: AWSDecodableShape {
        /// How to pronounce the address.
        public let address: AddressComponentPhonemes?
        /// List of PhonemeTranscription. See PhonemeTranscription for fields.
        public let title: [PhonemeTranscription]?

        @inlinable
        public init(address: AddressComponentPhonemes? = nil, title: [PhonemeTranscription]? = nil) {
            self.address = address
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case title = "Title"
        }
    }

    public struct PhonemeTranscription: AWSDecodableShape {
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// Boolean which indicates if it the preferred pronunciation.
        public let preferred: Bool?
        /// Value which indicates how to pronounce the value.
        public let value: String?

        @inlinable
        public init(language: String? = nil, preferred: Bool? = nil, value: String? = nil) {
            self.language = language
            self.preferred = preferred
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case language = "Language"
            case preferred = "Preferred"
            case value = "Value"
        }
    }

    public struct PostalCodeDetails: AWSDecodableShape {
        /// The postal authority or entity. This could be a governmental authority, a regulatory authority, or a designated postal operator.
        public let postalAuthority: PostalAuthority?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code for which the result should posses.
        public let postalCode: String?
        /// The postal code type.
        public let postalCodeType: PostalCodeType?
        /// The ZIP Classification Code, or in other words what type of postal code is it.
        public let uspsZip: UspsZip?
        /// The USPS ZIP+4 Record Type Code.
        public let uspsZipPlus4: UspsZipPlus4?

        @inlinable
        public init(postalAuthority: PostalAuthority? = nil, postalCode: String? = nil, postalCodeType: PostalCodeType? = nil, uspsZip: UspsZip? = nil, uspsZipPlus4: UspsZipPlus4? = nil) {
            self.postalAuthority = postalAuthority
            self.postalCode = postalCode
            self.postalCodeType = postalCodeType
            self.uspsZip = uspsZip
            self.uspsZipPlus4 = uspsZipPlus4
        }

        private enum CodingKeys: String, CodingKey {
            case postalAuthority = "PostalAuthority"
            case postalCode = "PostalCode"
            case postalCodeType = "PostalCodeType"
            case uspsZip = "UspsZip"
            case uspsZipPlus4 = "UspsZipPlus4"
        }
    }

    public struct QueryRefinement: AWSDecodableShape {
        /// End index of the parsed query.
        public let endIndex: Int
        /// The sub-string of the original query that is replaced by this query term.
        public let originalTerm: String
        /// The term that will be suggested to the user.
        public let refinedTerm: String
        /// Start index of the parsed component.
        public let startIndex: Int

        @inlinable
        public init(endIndex: Int, originalTerm: String, refinedTerm: String, startIndex: Int) {
            self.endIndex = endIndex
            self.originalTerm = originalTerm
            self.refinedTerm = refinedTerm
            self.startIndex = startIndex
        }

        private enum CodingKeys: String, CodingKey {
            case endIndex = "EndIndex"
            case originalTerm = "OriginalTerm"
            case refinedTerm = "RefinedTerm"
            case startIndex = "StartIndex"
        }
    }

    public struct Region: AWSDecodableShape {
        /// Abbreviated code for a the state, province or region of the country.  Example: BC.
        public let code: String?
        /// Name for a the state, province, or region of the country.  Example: British Columbia.
        public let name: String?

        @inlinable
        public init(code: String? = nil, name: String? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case name = "Name"
        }
    }

    public struct RegionHighlights: AWSDecodableShape {
        /// Indicates the starting and ending index of the region in the text query that match the found title.
        public let code: [Highlight]?
        /// Indicates the starting and ending index of the region name in the text query that match the found title.
        public let name: [Highlight]?

        @inlinable
        public init(code: [Highlight]? = nil, name: [Highlight]? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case name = "Name"
        }
    }

    public struct ReverseGeocodeFilter: AWSEncodableShape {
        /// The included place types.
        public let includePlaceTypes: [ReverseGeocodeFilterPlaceType]?

        @inlinable
        public init(includePlaceTypes: [ReverseGeocodeFilterPlaceType]? = nil) {
            self.includePlaceTypes = includePlaceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.includePlaceTypes, name: "includePlaceTypes", parent: name, max: 5)
            try self.validate(self.includePlaceTypes, name: "includePlaceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includePlaceTypes = "IncludePlaceTypes"
        }
    }

    public struct ReverseGeocodeRequest: AWSEncodableShape {
        /// A list of optional additional parameters, such as time zone that can be requested for each result.
        public let additionalFeatures: [ReverseGeocodeAdditionalFeature]?
        /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
        public let filter: ReverseGeocodeFilter?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: ReverseGeocodeIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// An optional limit for the number of results returned in a single call.
        public let maxResults: Int?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position, in [lng, lat] for which you are querying nearby resultsfor. Results closer to the position will be ranked higher then results further away from the position
        public let queryPosition: [Double]
        /// The maximum distance in meters from the QueryPosition from which a result will be returned.
        public let queryRadius: Int64?

        @inlinable
        public init(additionalFeatures: [ReverseGeocodeAdditionalFeature]? = nil, filter: ReverseGeocodeFilter? = nil, intendedUse: ReverseGeocodeIntendedUse? = nil, key: String? = nil, language: String? = nil, maxResults: Int? = nil, politicalView: String? = nil, queryPosition: [Double], queryRadius: Int64? = nil) {
            self.additionalFeatures = additionalFeatures
            self.filter = filter
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.politicalView = politicalView
            self.queryPosition = queryPosition
            self.queryRadius = queryRadius
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalFeatures, forKey: .additionalFeatures)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.intendedUse, forKey: .intendedUse)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.politicalView, forKey: .politicalView)
            try container.encode(self.queryPosition, forKey: .queryPosition)
            try container.encodeIfPresent(self.queryRadius, forKey: .queryRadius)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 2)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            try self.validate(self.queryPosition, name: "queryPosition", parent: name, max: 2)
            try self.validate(self.queryPosition, name: "queryPosition", parent: name, min: 2)
            try self.validate(self.queryRadius, name: "queryRadius", parent: name, max: 4294967295)
            try self.validate(self.queryRadius, name: "queryRadius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFeatures = "AdditionalFeatures"
            case filter = "Filter"
            case intendedUse = "IntendedUse"
            case language = "Language"
            case maxResults = "MaxResults"
            case politicalView = "PoliticalView"
            case queryPosition = "QueryPosition"
            case queryRadius = "QueryRadius"
        }
    }

    public struct ReverseGeocodeResponse: AWSDecodableShape {
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// List of places or results returned for a query.
        public let resultItems: [ReverseGeocodeResultItem]?

        @inlinable
        public init(pricingBucket: String, resultItems: [ReverseGeocodeResultItem]? = nil) {
            self.pricingBucket = pricingBucket
            self.resultItems = resultItems
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.resultItems = try container.decodeIfPresent([ReverseGeocodeResultItem].self, forKey: .resultItems)
        }

        private enum CodingKeys: String, CodingKey {
            case resultItems = "ResultItems"
        }
    }

    public struct ReverseGeocodeResultItem: AWSDecodableShape {
        /// Position of the access point represent by longitude and latitude.
        public let accessPoints: [AccessPoint]?
        /// The place's address.
        public let address: Address?
        /// Boolean indicating if the address provided has been corrected.
        public let addressNumberCorrected: Bool?
        /// Categories of results that results must belong to.
        public let categories: [Category]?
        /// The distance in meters from the QueryPosition.
        public let distance: Int64?
        /// List of food types offered by this result.
        public let foodTypes: [FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let mapView: [Double]?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String
        /// A PlaceType is a category that the result place must belong to.
        public let placeType: PlaceType
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position in longitude and latitude.
        public let position: [Double]?
        /// Contains details about the postal code of the place/result.
        public let postalCodeDetails: [PostalCodeDetails]?
        /// The time zone in which the place is located.
        public let timeZone: TimeZone?
        /// The localized display name of this result item based on request parameter language.
        public let title: String

        @inlinable
        public init(accessPoints: [AccessPoint]? = nil, address: Address? = nil, addressNumberCorrected: Bool? = nil, categories: [Category]? = nil, distance: Int64? = nil, foodTypes: [FoodType]? = nil, mapView: [Double]? = nil, placeId: String, placeType: PlaceType, politicalView: String? = nil, position: [Double]? = nil, postalCodeDetails: [PostalCodeDetails]? = nil, timeZone: TimeZone? = nil, title: String) {
            self.accessPoints = accessPoints
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.timeZone = timeZone
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case address = "Address"
            case addressNumberCorrected = "AddressNumberCorrected"
            case categories = "Categories"
            case distance = "Distance"
            case foodTypes = "FoodTypes"
            case mapView = "MapView"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case position = "Position"
            case postalCodeDetails = "PostalCodeDetails"
            case timeZone = "TimeZone"
            case title = "Title"
        }
    }

    public struct SearchNearbyFilter: AWSEncodableShape {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let boundingBox: [Double]?
        /// The Business Chains associated with the place.
        public let excludeBusinessChains: [String]?
        /// Categories of results that results are excluded from.
        public let excludeCategories: [String]?
        /// Food types that results are excluded from.
        public let excludeFoodTypes: [String]?
        /// The Business Chains associated with the place.
        public let includeBusinessChains: [String]?
        /// Categories of results that results must belong too.
        public let includeCategories: [String]?
        /// A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public let includeCountries: [String]?
        /// Food types that results are included from.
        public let includeFoodTypes: [String]?

        @inlinable
        public init(boundingBox: [Double]? = nil, excludeBusinessChains: [String]? = nil, excludeCategories: [String]? = nil, excludeFoodTypes: [String]? = nil, includeBusinessChains: [String]? = nil, includeCategories: [String]? = nil, includeCountries: [String]? = nil, includeFoodTypes: [String]? = nil) {
            self.boundingBox = boundingBox
            self.excludeBusinessChains = excludeBusinessChains
            self.excludeCategories = excludeCategories
            self.excludeFoodTypes = excludeFoodTypes
            self.includeBusinessChains = includeBusinessChains
            self.includeCategories = includeCategories
            self.includeCountries = includeCountries
            self.includeFoodTypes = includeFoodTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.validate(self.excludeBusinessChains, name: "excludeBusinessChains", parent: name, max: 10)
            try self.validate(self.excludeBusinessChains, name: "excludeBusinessChains", parent: name, min: 1)
            try self.validate(self.excludeCategories, name: "excludeCategories", parent: name, max: 10)
            try self.validate(self.excludeCategories, name: "excludeCategories", parent: name, min: 1)
            try self.validate(self.excludeFoodTypes, name: "excludeFoodTypes", parent: name, max: 10)
            try self.validate(self.excludeFoodTypes, name: "excludeFoodTypes", parent: name, min: 1)
            try self.validate(self.includeBusinessChains, name: "includeBusinessChains", parent: name, max: 10)
            try self.validate(self.includeBusinessChains, name: "includeBusinessChains", parent: name, min: 1)
            try self.validate(self.includeCategories, name: "includeCategories", parent: name, max: 10)
            try self.validate(self.includeCategories, name: "includeCategories", parent: name, min: 1)
            try self.includeCountries?.forEach {
                try validate($0, name: "includeCountries[]", parent: name, max: 3)
                try validate($0, name: "includeCountries[]", parent: name, min: 2)
                try validate($0, name: "includeCountries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, max: 100)
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, min: 1)
            try self.validate(self.includeFoodTypes, name: "includeFoodTypes", parent: name, max: 10)
            try self.validate(self.includeFoodTypes, name: "includeFoodTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case excludeBusinessChains = "ExcludeBusinessChains"
            case excludeCategories = "ExcludeCategories"
            case excludeFoodTypes = "ExcludeFoodTypes"
            case includeBusinessChains = "IncludeBusinessChains"
            case includeCategories = "IncludeCategories"
            case includeCountries = "IncludeCountries"
            case includeFoodTypes = "IncludeFoodTypes"
        }
    }

    public struct SearchNearbyRequest: AWSEncodableShape {
        /// A list of optional additional parameters, such as time zone, that can be requested for each result.
        public let additionalFeatures: [SearchNearbyAdditionalFeature]?
        /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
        public let filter: SearchNearbyFilter?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: SearchNearbyIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// An optional limit for the number of results returned in a single call.
        public let maxResults: Int?
        /// If nextToken is returned,  there are more results available. The value of nextToken is a unique pagination token for each page.
        public let nextToken: String?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position, in [lng, lat] for which you are querying nearby resultsfor. Results closer to the position will be ranked higher then results further away from the position
        public let queryPosition: [Double]
        /// The maximum distance in meters from the QueryPosition from which a result will be returned.
        public let queryRadius: Int64?

        @inlinable
        public init(additionalFeatures: [SearchNearbyAdditionalFeature]? = nil, filter: SearchNearbyFilter? = nil, intendedUse: SearchNearbyIntendedUse? = nil, key: String? = nil, language: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, politicalView: String? = nil, queryPosition: [Double], queryRadius: Int64? = nil) {
            self.additionalFeatures = additionalFeatures
            self.filter = filter
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.politicalView = politicalView
            self.queryPosition = queryPosition
            self.queryRadius = queryRadius
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalFeatures, forKey: .additionalFeatures)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.intendedUse, forKey: .intendedUse)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.politicalView, forKey: .politicalView)
            try container.encode(self.queryPosition, forKey: .queryPosition)
            try container.encodeIfPresent(self.queryRadius, forKey: .queryRadius)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 4)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            try self.validate(self.queryPosition, name: "queryPosition", parent: name, max: 2)
            try self.validate(self.queryPosition, name: "queryPosition", parent: name, min: 2)
            try self.validate(self.queryRadius, name: "queryRadius", parent: name, max: 4294967295)
            try self.validate(self.queryRadius, name: "queryRadius", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFeatures = "AdditionalFeatures"
            case filter = "Filter"
            case intendedUse = "IntendedUse"
            case language = "Language"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case politicalView = "PoliticalView"
            case queryPosition = "QueryPosition"
            case queryRadius = "QueryRadius"
        }
    }

    public struct SearchNearbyResponse: AWSDecodableShape {
        /// If nextToken is returned,  there are more results available. The value of nextToken is a unique pagination token for each page.
        public let nextToken: String?
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// List of places or results returned for a query.
        public let resultItems: [SearchNearbyResultItem]?

        @inlinable
        public init(nextToken: String? = nil, pricingBucket: String, resultItems: [SearchNearbyResultItem]? = nil) {
            self.nextToken = nextToken
            self.pricingBucket = pricingBucket
            self.resultItems = resultItems
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.resultItems = try container.decodeIfPresent([SearchNearbyResultItem].self, forKey: .resultItems)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resultItems = "ResultItems"
        }
    }

    public struct SearchNearbyResultItem: AWSDecodableShape {
        /// Position of the access point represent by longitude and latitude.
        public let accessPoints: [AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public let accessRestrictions: [AccessRestriction]?
        /// The place's address.
        public let address: Address?
        /// Boolean indicating if the address provided has been corrected.
        public let addressNumberCorrected: Bool?
        /// The Business Chains associated with the place.
        public let businessChains: [BusinessChain]?
        /// Categories of results that results must belong to.
        public let categories: [Category]?
        /// List of potential contact methods for the result/place.
        public let contacts: Contacts?
        /// The distance in meters from the QueryPosition.
        public let distance: Int64?
        /// List of food types offered by this result.
        public let foodTypes: [FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let mapView: [Double]?
        /// List of opening hours objects.
        public let openingHours: [OpeningHours]?
        /// How the various components of the result's address are pronounced in various languages.
        public let phonemes: PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String
        /// A PlaceType is a category that the result place must belong to.
        public let placeType: PlaceType
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position in longitude and latitude.
        public let position: [Double]?
        /// The time zone in which the place is located.
        public let timeZone: TimeZone?
        /// The item's title.
        public let title: String

        @inlinable
        public init(accessPoints: [AccessPoint]? = nil, accessRestrictions: [AccessRestriction]? = nil, address: Address? = nil, addressNumberCorrected: Bool? = nil, businessChains: [BusinessChain]? = nil, categories: [Category]? = nil, contacts: Contacts? = nil, distance: Int64? = nil, foodTypes: [FoodType]? = nil, mapView: [Double]? = nil, openingHours: [OpeningHours]? = nil, phonemes: PhonemeDetails? = nil, placeId: String, placeType: PlaceType, politicalView: String? = nil, position: [Double]? = nil, timeZone: TimeZone? = nil, title: String) {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case accessRestrictions = "AccessRestrictions"
            case address = "Address"
            case addressNumberCorrected = "AddressNumberCorrected"
            case businessChains = "BusinessChains"
            case categories = "Categories"
            case contacts = "Contacts"
            case distance = "Distance"
            case foodTypes = "FoodTypes"
            case mapView = "MapView"
            case openingHours = "OpeningHours"
            case phonemes = "Phonemes"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case position = "Position"
            case timeZone = "TimeZone"
            case title = "Title"
        }
    }

    public struct SearchTextFilter: AWSEncodableShape {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let boundingBox: [Double]?
        public let circle: FilterCircle?
        ///  A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public let includeCountries: [String]?

        @inlinable
        public init(boundingBox: [Double]? = nil, circle: FilterCircle? = nil, includeCountries: [String]? = nil) {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.circle?.validate(name: "\(name).circle")
            try self.includeCountries?.forEach {
                try validate($0, name: "includeCountries[]", parent: name, max: 3)
                try validate($0, name: "includeCountries[]", parent: name, min: 2)
                try validate($0, name: "includeCountries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, max: 100)
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case circle = "Circle"
            case includeCountries = "IncludeCountries"
        }
    }

    public struct SearchTextRequest: AWSEncodableShape {
        /// A list of optional additional parameters, such as time zone, that can be requested for each result.
        public let additionalFeatures: [SearchTextAdditionalFeature]?
        /// The position, in longitude and latitude, that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format.  The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
        public let biasPosition: [Double]?
        /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
        public let filter: SearchTextFilter?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: SearchTextIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// An optional limit for the number of results returned in a single call.
        public let maxResults: Int?
        /// If nextToken is returned,  there are more results available. The value of nextToken is a unique pagination token for each page.
        public let nextToken: String?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The query Id.
        public let queryId: String?
        /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
        public let queryText: String?

        @inlinable
        public init(additionalFeatures: [SearchTextAdditionalFeature]? = nil, biasPosition: [Double]? = nil, filter: SearchTextFilter? = nil, intendedUse: SearchTextIntendedUse? = nil, key: String? = nil, language: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, politicalView: String? = nil, queryId: String? = nil, queryText: String? = nil) {
            self.additionalFeatures = additionalFeatures
            self.biasPosition = biasPosition
            self.filter = filter
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.politicalView = politicalView
            self.queryId = queryId
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalFeatures, forKey: .additionalFeatures)
            try container.encodeIfPresent(self.biasPosition, forKey: .biasPosition)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.intendedUse, forKey: .intendedUse)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.politicalView, forKey: .politicalView)
            try container.encodeIfPresent(self.queryId, forKey: .queryId)
            try container.encodeIfPresent(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 4)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFeatures = "AdditionalFeatures"
            case biasPosition = "BiasPosition"
            case filter = "Filter"
            case intendedUse = "IntendedUse"
            case language = "Language"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case politicalView = "PoliticalView"
            case queryId = "QueryId"
            case queryText = "QueryText"
        }
    }

    public struct SearchTextResponse: AWSDecodableShape {
        /// If nextToken is returned,  there are more results available. The value of nextToken is a unique pagination token for each page.
        public let nextToken: String?
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// List of places or results returned for a query.
        public let resultItems: [SearchTextResultItem]?

        @inlinable
        public init(nextToken: String? = nil, pricingBucket: String, resultItems: [SearchTextResultItem]? = nil) {
            self.nextToken = nextToken
            self.pricingBucket = pricingBucket
            self.resultItems = resultItems
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.resultItems = try container.decodeIfPresent([SearchTextResultItem].self, forKey: .resultItems)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resultItems = "ResultItems"
        }
    }

    public struct SearchTextResultItem: AWSDecodableShape {
        /// Position of the access point represent by longitude and latitude.
        public let accessPoints: [AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public let accessRestrictions: [AccessRestriction]?
        /// The place's address.
        public let address: Address?
        /// Boolean indicating if the address provided has been corrected.
        public let addressNumberCorrected: Bool?
        /// The Business Chains associated with the place.
        public let businessChains: [BusinessChain]?
        /// Categories of results that results must belong to.
        public let categories: [Category]?
        /// List of potential contact methods for the result/place.
        public let contacts: Contacts?
        /// The distance in meters from the QueryPosition.
        public let distance: Int64?
        /// List of food types offered by this result.
        public let foodTypes: [FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let mapView: [Double]?
        /// List of opening hours objects.
        public let openingHours: [OpeningHours]?
        /// How the various components of the result's address are pronounced in various languages.
        public let phonemes: PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String
        /// A PlaceType is a category that the result place must belong to.
        public let placeType: PlaceType
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position, in longitude and latitude.
        public let position: [Double]?
        /// The time zone in which the place is located.
        public let timeZone: TimeZone?
        /// The item's title.
        public let title: String

        @inlinable
        public init(accessPoints: [AccessPoint]? = nil, accessRestrictions: [AccessRestriction]? = nil, address: Address? = nil, addressNumberCorrected: Bool? = nil, businessChains: [BusinessChain]? = nil, categories: [Category]? = nil, contacts: Contacts? = nil, distance: Int64? = nil, foodTypes: [FoodType]? = nil, mapView: [Double]? = nil, openingHours: [OpeningHours]? = nil, phonemes: PhonemeDetails? = nil, placeId: String, placeType: PlaceType, politicalView: String? = nil, position: [Double]? = nil, timeZone: TimeZone? = nil, title: String) {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case accessRestrictions = "AccessRestrictions"
            case address = "Address"
            case addressNumberCorrected = "AddressNumberCorrected"
            case businessChains = "BusinessChains"
            case categories = "Categories"
            case contacts = "Contacts"
            case distance = "Distance"
            case foodTypes = "FoodTypes"
            case mapView = "MapView"
            case openingHours = "OpeningHours"
            case phonemes = "Phonemes"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case position = "Position"
            case timeZone = "TimeZone"
            case title = "Title"
        }
    }

    public struct StreetComponents: AWSDecodableShape {
        /// Base name part of the street name.  Example: Younge from the “Younge street".
        public let baseName: String?
        /// Indicates the official directional identifiers assigned to highways.
        public let direction: String?
        /// A BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// A prefix is a directional identifier that precedes, but is not included in, the base name of a road.  Example: E for East.
        public let prefix: String?
        /// A suffix is a directional identifier that follows, but is not included in, the base name of a road.  Example W for West.
        public let suffix: String?
        /// Street type part of the street name.  Example: “avenue".
        public let type: String?
        /// Defines if the street type is before or after the base name.
        public let typePlacement: TypePlacement?
        /// What character(s) separates the string from its type.
        public let typeSeparator: String?

        @inlinable
        public init(baseName: String? = nil, direction: String? = nil, language: String? = nil, prefix: String? = nil, suffix: String? = nil, type: String? = nil, typePlacement: TypePlacement? = nil, typeSeparator: String? = nil) {
            self.baseName = baseName
            self.direction = direction
            self.language = language
            self.prefix = prefix
            self.suffix = suffix
            self.type = type
            self.typePlacement = typePlacement
            self.typeSeparator = typeSeparator
        }

        private enum CodingKeys: String, CodingKey {
            case baseName = "BaseName"
            case direction = "Direction"
            case language = "Language"
            case prefix = "Prefix"
            case suffix = "Suffix"
            case type = "Type"
            case typePlacement = "TypePlacement"
            case typeSeparator = "TypeSeparator"
        }
    }

    public struct SubRegion: AWSDecodableShape {
        /// Abbreviated code for the county or sub-region.
        public let code: String?
        /// Name for the county or sub-region.
        public let name: String?

        @inlinable
        public init(code: String? = nil, name: String? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case name = "Name"
        }
    }

    public struct SubRegionHighlights: AWSDecodableShape {
        /// Indicates the starting and ending index of the sub-region in the text query that match the found title.
        public let code: [Highlight]?
        /// Indicates the starting and ending index of the name in the text query that match the found title.
        public let name: [Highlight]?

        @inlinable
        public init(code: [Highlight]? = nil, name: [Highlight]? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case name = "Name"
        }
    }

    public struct SuggestAddressHighlights: AWSDecodableShape {
        /// Indicates the starting and ending indexes of the places in the result which were identified to match the textQuery. This result is useful for providing emphasis to results where the user query directly matched to make selecting the correct result from a list easier for an end user.
        public let label: [Highlight]?

        @inlinable
        public init(label: [Highlight]? = nil) {
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
        }
    }

    public struct SuggestFilter: AWSEncodableShape {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let boundingBox: [Double]?
        public let circle: FilterCircle?
        ///  A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public let includeCountries: [String]?

        @inlinable
        public init(boundingBox: [Double]? = nil, circle: FilterCircle? = nil, includeCountries: [String]? = nil) {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
        }

        public func validate(name: String) throws {
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, max: 4)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 4)
            try self.circle?.validate(name: "\(name).circle")
            try self.includeCountries?.forEach {
                try validate($0, name: "includeCountries[]", parent: name, max: 3)
                try validate($0, name: "includeCountries[]", parent: name, min: 2)
                try validate($0, name: "includeCountries[]", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            }
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, max: 100)
            try self.validate(self.includeCountries, name: "includeCountries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case circle = "Circle"
            case includeCountries = "IncludeCountries"
        }
    }

    public struct SuggestHighlights: AWSDecodableShape {
        /// The place's address.
        public let address: SuggestAddressHighlights?
        /// Indicates the starting and ending index of the title in the text query that match the found title.
        public let title: [Highlight]?

        @inlinable
        public init(address: SuggestAddressHighlights? = nil, title: [Highlight]? = nil) {
            self.address = address
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case title = "Title"
        }
    }

    public struct SuggestPlaceResult: AWSDecodableShape {
        /// Position of the access point represent by longitude and latitude.
        public let accessPoints: [AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public let accessRestrictions: [AccessRestriction]?
        /// The place's address.
        public let address: Address?
        /// The Business Chains associated with the place.
        public let businessChains: [BusinessChain]?
        /// Categories of results that results must belong to.
        public let categories: [Category]?
        /// The distance in meters from the QueryPosition.
        public let distance: Int64?
        /// List of food types offered by this result.
        public let foodTypes: [FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public let mapView: [Double]?
        /// How the various components of the result's address are pronounced in various languages.
        public let phonemes: PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        public let placeId: String?
        /// A PlaceType is a category that the result place must belong to.
        public let placeType: PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The position, in longitude and latitude.
        public let position: [Double]?
        /// The time zone in which the place is located.
        public let timeZone: TimeZone?

        @inlinable
        public init(accessPoints: [AccessPoint]? = nil, accessRestrictions: [AccessRestriction]? = nil, address: Address? = nil, businessChains: [BusinessChain]? = nil, categories: [Category]? = nil, distance: Int64? = nil, foodTypes: [FoodType]? = nil, mapView: [Double]? = nil, phonemes: PhonemeDetails? = nil, placeId: String? = nil, placeType: PlaceType? = nil, politicalView: String? = nil, position: [Double]? = nil, timeZone: TimeZone? = nil) {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.businessChains = businessChains
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "AccessPoints"
            case accessRestrictions = "AccessRestrictions"
            case address = "Address"
            case businessChains = "BusinessChains"
            case categories = "Categories"
            case distance = "Distance"
            case foodTypes = "FoodTypes"
            case mapView = "MapView"
            case phonemes = "Phonemes"
            case placeId = "PlaceId"
            case placeType = "PlaceType"
            case politicalView = "PoliticalView"
            case position = "Position"
            case timeZone = "TimeZone"
        }
    }

    public struct SuggestQueryResult: AWSDecodableShape {
        /// QueryId can be used to complete a follow up query through the SearchText API. The QueryId retains context from the original Suggest request such as filters, political view and language. See the SearchText API documentation for more details SearchText API docs.
        public let queryId: String?
        /// The query type. Category qeuries will search for places which have an entry matching the given category, for example "doctor office". BusinessChain queries will search for instances of a given business.
        public let queryType: QueryType?

        @inlinable
        public init(queryId: String? = nil, queryType: QueryType? = nil) {
            self.queryId = queryId
            self.queryType = queryType
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "QueryId"
            case queryType = "QueryType"
        }
    }

    public struct SuggestRequest: AWSEncodableShape {
        /// A list of optional additional parameters, such as time zone, that can be requested for each result.
        public let additionalFeatures: [SuggestAdditionalFeature]?
        /// The position, in longitude and latitude, that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format.  The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
        public let biasPosition: [Double]?
        /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
        public let filter: SuggestFilter?
        /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
        public let intendedUse: SuggestIntendedUse?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// A list of BCP 47 compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public let language: String?
        /// Maximum number of query terms to be returned for use with a search text query.
        public let maxQueryRefinements: Int?
        /// An optional limit for the number of results returned in a single call.
        public let maxResults: Int?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public let politicalView: String?
        /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
        public let queryText: String

        @inlinable
        public init(additionalFeatures: [SuggestAdditionalFeature]? = nil, biasPosition: [Double]? = nil, filter: SuggestFilter? = nil, intendedUse: SuggestIntendedUse? = nil, key: String? = nil, language: String? = nil, maxQueryRefinements: Int? = nil, maxResults: Int? = nil, politicalView: String? = nil, queryText: String) {
            self.additionalFeatures = additionalFeatures
            self.biasPosition = biasPosition
            self.filter = filter
            self.intendedUse = intendedUse
            self.key = key
            self.language = language
            self.maxQueryRefinements = maxQueryRefinements
            self.maxResults = maxResults
            self.politicalView = politicalView
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalFeatures, forKey: .additionalFeatures)
            try container.encodeIfPresent(self.biasPosition, forKey: .biasPosition)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.intendedUse, forKey: .intendedUse)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxQueryRefinements, forKey: .maxQueryRefinements)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.politicalView, forKey: .politicalView)
            try container.encode(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, max: 4)
            try self.validate(self.additionalFeatures, name: "additionalFeatures", parent: name, min: 1)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalFeatures = "AdditionalFeatures"
            case biasPosition = "BiasPosition"
            case filter = "Filter"
            case intendedUse = "IntendedUse"
            case language = "Language"
            case maxQueryRefinements = "MaxQueryRefinements"
            case maxResults = "MaxResults"
            case politicalView = "PoliticalView"
            case queryText = "QueryText"
        }
    }

    public struct SuggestResponse: AWSDecodableShape {
        /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit Amazon Location Service Pricing.
        public let pricingBucket: String
        /// Maximum number of query terms to be returned for use with a search text query.
        public let queryRefinements: [QueryRefinement]?
        /// List of places or results returned for a query.
        public let resultItems: [SuggestResultItem]?

        @inlinable
        public init(pricingBucket: String, queryRefinements: [QueryRefinement]? = nil, resultItems: [SuggestResultItem]? = nil) {
            self.pricingBucket = pricingBucket
            self.queryRefinements = queryRefinements
            self.resultItems = resultItems
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
            self.queryRefinements = try container.decodeIfPresent([QueryRefinement].self, forKey: .queryRefinements)
            self.resultItems = try container.decodeIfPresent([SuggestResultItem].self, forKey: .resultItems)
        }

        private enum CodingKeys: String, CodingKey {
            case queryRefinements = "QueryRefinements"
            case resultItems = "ResultItems"
        }
    }

    public struct SuggestResultItem: AWSDecodableShape {
        /// Describes how the parts of the response element matched the input query by returning the sections of the response which matched to input query terms.
        public let highlights: SuggestHighlights?
        /// The suggested place by its unique ID.
        public let place: SuggestPlaceResult?
        public let query: SuggestQueryResult?
        /// The result type. Place results represent the final result for a point of interest, Query results represent a follow up query which can be completed through the SearchText operation.
        public let suggestResultItemType: SuggestResultItemType
        /// The display title that should be used when presenting this option to the end user.
        public let title: String

        @inlinable
        public init(highlights: SuggestHighlights? = nil, place: SuggestPlaceResult? = nil, query: SuggestQueryResult? = nil, suggestResultItemType: SuggestResultItemType, title: String) {
            self.highlights = highlights
            self.place = place
            self.query = query
            self.suggestResultItemType = suggestResultItemType
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case highlights = "Highlights"
            case place = "Place"
            case query = "Query"
            case suggestResultItemType = "SuggestResultItemType"
            case title = "Title"
        }
    }

    public struct TimeZone: AWSDecodableShape {
        /// The time zone name.
        public let name: String
        /// Time zone offset of the timezone from UTC.
        public let offset: String?
        /// The offset of the time zone from UTC, in seconds.
        public let offsetSeconds: Int64?

        @inlinable
        public init(name: String, offset: String? = nil, offsetSeconds: Int64? = nil) {
            self.name = name
            self.offset = offset
            self.offsetSeconds = offsetSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case offset = "Offset"
            case offsetSeconds = "OffsetSeconds"
        }
    }

    public struct UspsZip: AWSDecodableShape {
        /// The ZIP Classification Code, or in other words what type of postal code is it.
        public let zipClassificationCode: ZipClassificationCode?

        @inlinable
        public init(zipClassificationCode: ZipClassificationCode? = nil) {
            self.zipClassificationCode = zipClassificationCode
        }

        private enum CodingKeys: String, CodingKey {
            case zipClassificationCode = "ZipClassificationCode"
        }
    }

    public struct UspsZipPlus4: AWSDecodableShape {
        /// The USPS ZIP+4 Record Type Code.
        public let recordTypeCode: RecordTypeCode?

        @inlinable
        public init(recordTypeCode: RecordTypeCode? = nil) {
            self.recordTypeCode = recordTypeCode
        }

        private enum CodingKeys: String, CodingKey {
            case recordTypeCode = "RecordTypeCode"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// Test stub for FieldList.
        public let fieldList: [ValidationExceptionField]
        public let message: String
        /// Test stub for reason
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField], message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The error message.
        public let message: String
        /// The name of the resource.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for GeoPlaces
public struct GeoPlacesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GeoPlaces
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension GeoPlacesErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": GeoPlaces.ValidationException.self
    ]
}

extension GeoPlacesErrorType: Equatable {
    public static func == (lhs: GeoPlacesErrorType, rhs: GeoPlacesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GeoPlacesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
