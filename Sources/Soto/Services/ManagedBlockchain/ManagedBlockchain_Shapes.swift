//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension ManagedBlockchain {
    // MARK: Enums

    public enum Edition: String, CustomStringConvertible, Codable {
        case standard = "STANDARD"
        case starter = "STARTER"
        public var description: String { return self.rawValue }
    }

    public enum Framework: String, CustomStringConvertible, Codable {
        case ethereum = "ETHEREUM"
        case hyperledgerFabric = "HYPERLEDGER_FABRIC"
        public var description: String { return self.rawValue }
    }

    public enum InvitationStatus: String, CustomStringConvertible, Codable {
        case accepted = "ACCEPTED"
        case accepting = "ACCEPTING"
        case expired = "EXPIRED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum MemberStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case inaccessibleEncryptionKey = "INACCESSIBLE_ENCRYPTION_KEY"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum NetworkStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum NodeStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case inaccessibleEncryptionKey = "INACCESSIBLE_ENCRYPTION_KEY"
        case unhealthy = "UNHEALTHY"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ProposalStatus: String, CustomStringConvertible, Codable {
        case actionFailed = "ACTION_FAILED"
        case approved = "APPROVED"
        case expired = "EXPIRED"
        case inProgress = "IN_PROGRESS"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum StateDBType: String, CustomStringConvertible, Codable {
        case couchdb = "CouchDB"
        case leveldb = "LevelDB"
        public var description: String { return self.rawValue }
    }

    public enum ThresholdComparator: String, CustomStringConvertible, Codable {
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        public var description: String { return self.rawValue }
    }

    public enum VoteValue: String, CustomStringConvertible, Codable {
        case no = "NO"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApprovalThresholdPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The duration from the time that a proposal is created until it expires. If members cast neither the required number of YES votes to approve the proposal nor the number of NO votes required to reject it before the duration expires, the proposal is EXPIRED and ProposalActions are not carried out.
        public let proposalDurationInHours: Int?
        /// Determines whether the vote percentage must be greater than the ThresholdPercentage or must be greater than or equal to the ThreholdPercentage to be approved.
        public let thresholdComparator: ThresholdComparator?
        /// The percentage of votes among all members that must be YES for a proposal to be approved. For example, a ThresholdPercentage value of 50 indicates 50%. The ThresholdComparator determines the precise comparison. If a ThresholdPercentage value of 50 is specified on a network with 10 members, along with a ThresholdComparator value of GREATER_THAN, this indicates that 6 YES votes are required for the proposal to be approved.
        public let thresholdPercentage: Int?

        public init(proposalDurationInHours: Int? = nil, thresholdComparator: ThresholdComparator? = nil, thresholdPercentage: Int? = nil) {
            self.proposalDurationInHours = proposalDurationInHours
            self.thresholdComparator = thresholdComparator
            self.thresholdPercentage = thresholdPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.proposalDurationInHours, name: "proposalDurationInHours", parent: name, max: 168)
            try self.validate(self.proposalDurationInHours, name: "proposalDurationInHours", parent: name, min: 1)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, max: 100)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case proposalDurationInHours = "ProposalDurationInHours"
            case thresholdComparator = "ThresholdComparator"
            case thresholdPercentage = "ThresholdPercentage"
        }
    }

    public struct CreateMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// The unique identifier of the invitation that is sent to the member to join the network.
        public let invitationId: String
        /// Member configuration parameters.
        public let memberConfiguration: MemberConfiguration
        /// The unique identifier of the network in which the member is created.
        public let networkId: String

        public init(clientRequestToken: String = CreateMemberInput.idempotencyToken(), invitationId: String, memberConfiguration: MemberConfiguration, networkId: String) {
            self.clientRequestToken = clientRequestToken
            self.invitationId = invitationId
            self.memberConfiguration = memberConfiguration
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.invitationId, name: "invitationId", parent: name, max: 32)
            try self.validate(self.invitationId, name: "invitationId", parent: name, min: 1)
            try self.memberConfiguration.validate(name: "\(name).memberConfiguration")
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case invitationId = "InvitationId"
            case memberConfiguration = "MemberConfiguration"
        }
    }

    public struct CreateMemberOutput: AWSDecodableShape {
        /// The unique identifier of the member.
        public let memberId: String?

        public init(memberId: String? = nil) {
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
        }
    }

    public struct CreateNetworkInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// An optional description for the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework
        ///  Configuration properties of the blockchain framework relevant to the network configuration.
        public let frameworkConfiguration: NetworkFrameworkConfiguration?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String
        /// Configuration properties for the first member within the network.
        public let memberConfiguration: MemberConfiguration
        /// The name of the network.
        public let name: String
        /// Tags to assign to the network. Each tag consists of a key and optional value. When specifying tags during creation, you can specify multiple key-value pairs in a single request, with an overall maximum of 50 tags added to each resource. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Ethereum Developer Guide, or Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?
        ///  The voting rules used by the network to determine if a proposal is approved.
        public let votingPolicy: VotingPolicy

        public init(clientRequestToken: String = CreateNetworkInput.idempotencyToken(), description: String? = nil, framework: Framework, frameworkConfiguration: NetworkFrameworkConfiguration? = nil, frameworkVersion: String, memberConfiguration: MemberConfiguration, name: String, tags: [String: String]? = nil, votingPolicy: VotingPolicy) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.framework = framework
            self.frameworkConfiguration = frameworkConfiguration
            self.frameworkVersion = frameworkVersion
            self.memberConfiguration = memberConfiguration
            self.name = name
            self.tags = tags
            self.votingPolicy = votingPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, max: 8)
            try self.validate(self.frameworkVersion, name: "frameworkVersion", parent: name, min: 1)
            try self.memberConfiguration.validate(name: "\(name).memberConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.votingPolicy.validate(name: "\(name).votingPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case framework = "Framework"
            case frameworkConfiguration = "FrameworkConfiguration"
            case frameworkVersion = "FrameworkVersion"
            case memberConfiguration = "MemberConfiguration"
            case name = "Name"
            case tags = "Tags"
            case votingPolicy = "VotingPolicy"
        }
    }

    public struct CreateNetworkOutput: AWSDecodableShape {
        /// The unique identifier for the first member within the network.
        public let memberId: String?
        /// The unique identifier for the network.
        public let networkId: String?

        public init(memberId: String? = nil, networkId: String? = nil) {
            self.memberId = memberId
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case networkId = "NetworkId"
        }
    }

    public struct CreateNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// The unique identifier of the member that owns this node. Applies only to Hyperledger Fabric.
        public let memberId: String?
        /// The unique identifier of the network for the node. Ethereum public networks have the following NetworkIds:    n-ethereum-mainnet     n-ethereum-rinkeby     n-ethereum-ropsten
        public let networkId: String
        /// The properties of a node configuration.
        public let nodeConfiguration: NodeConfiguration
        /// Tags to assign to the node. Each tag consists of a key and optional value. When specifying tags during creation, you can specify multiple key-value pairs in a single request, with an overall maximum of 50 tags added to each resource. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Ethereum Developer Guide, or Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?

        public init(clientRequestToken: String = CreateNodeInput.idempotencyToken(), memberId: String? = nil, networkId: String, nodeConfiguration: NodeConfiguration, tags: [String: String]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.memberId = memberId
            self.networkId = networkId
            self.nodeConfiguration = nodeConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case memberId = "MemberId"
            case nodeConfiguration = "NodeConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateNodeOutput: AWSDecodableShape {
        /// The unique identifier of the node.
        public let nodeId: String?

        public init(nodeId: String? = nil) {
            self.nodeId = nodeId
        }

        private enum CodingKeys: String, CodingKey {
            case nodeId = "NodeId"
        }
    }

    public struct CreateProposalInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The type of actions proposed, such as inviting a member or removing a member. The types of Actions in a proposal are mutually exclusive. For example, a proposal with Invitations actions cannot also contain Removals actions.
        public let actions: ProposalActions
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// A description for the proposal that is visible to voting members, for example, "Proposal to add Example Corp. as member."
        public let description: String?
        /// The unique identifier of the member that is creating the proposal. This identifier is especially useful for identifying the member making the proposal when multiple members exist in a single AWS account.
        public let memberId: String
        ///  The unique identifier of the network for which the proposal is made.
        public let networkId: String
        /// Tags to assign to the proposal. Each tag consists of a key and optional value. When specifying tags during creation, you can specify multiple key-value pairs in a single request, with an overall maximum of 50 tags added to each resource. If the proposal is for a network invitation, the invitation inherits the tags added to the proposal. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Ethereum Developer Guide, or Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?

        public init(actions: ProposalActions, clientRequestToken: String = CreateProposalInput.idempotencyToken(), description: String? = nil, memberId: String, networkId: String, tags: [String: String]? = nil) {
            self.actions = actions
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.memberId = memberId
            self.networkId = networkId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.actions.validate(name: "\(name).actions")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case memberId = "MemberId"
            case tags = "Tags"
        }
    }

    public struct CreateProposalOutput: AWSDecodableShape {
        /// The unique identifier of the proposal.
        public let proposalId: String?

        public init(proposalId: String? = nil) {
            self.proposalId = proposalId
        }

        private enum CodingKeys: String, CodingKey {
            case proposalId = "ProposalId"
        }
    }

    public struct DeleteMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The unique identifier of the member to remove.
        public let memberId: String
        /// The unique identifier of the network from which the member is removed.
        public let networkId: String

        public init(memberId: String, networkId: String) {
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .querystring(locationName: "memberId")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nodeId", location: .uri(locationName: "nodeId"))
        ]

        /// The unique identifier of the member that owns this node. Applies only to Hyperledger Fabric and is required for Hyperledger Fabric.
        public let memberId: String?
        /// The unique identifier of the network that the node is on. Ethereum public networks have the following NetworkIds:    n-ethereum-mainnet     n-ethereum-rinkeby     n-ethereum-ropsten
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(memberId: String? = nil, networkId: String, nodeId: String) {
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 32)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNodeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct GetMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The unique identifier of the member.
        public let memberId: String
        /// The unique identifier of the network to which the member belongs.
        public let networkId: String

        public init(memberId: String, networkId: String) {
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemberOutput: AWSDecodableShape {
        /// The properties of a member.
        public let member: Member?

        public init(member: Member? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct GetNetworkInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The unique identifier of the network to get information about.
        public let networkId: String

        public init(networkId: String) {
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkOutput: AWSDecodableShape {
        /// An object containing network configuration parameters.
        public let network: Network?

        public init(network: Network? = nil) {
            self.network = network
        }

        private enum CodingKeys: String, CodingKey {
            case network = "Network"
        }
    }

    public struct GetNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .querystring(locationName: "memberId")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nodeId", location: .uri(locationName: "nodeId"))
        ]

        /// The unique identifier of the member that owns the node. Applies only to Hyperledger Fabric and is required for Hyperledger Fabric.
        public let memberId: String?
        /// The unique identifier of the network that the node is on.
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(memberId: String? = nil, networkId: String, nodeId: String) {
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 32)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNodeOutput: AWSDecodableShape {
        /// Properties of the node configuration.
        public let node: Node?

        public init(node: Node? = nil) {
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case node = "Node"
        }
    }

    public struct GetProposalInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "proposalId", location: .uri(locationName: "proposalId"))
        ]

        /// The unique identifier of the network for which the proposal is made.
        public let networkId: String
        /// The unique identifier of the proposal.
        public let proposalId: String

        public init(networkId: String, proposalId: String) {
            self.networkId = networkId
            self.proposalId = proposalId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.proposalId, name: "proposalId", parent: name, max: 32)
            try self.validate(self.proposalId, name: "proposalId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProposalOutput: AWSDecodableShape {
        /// Information about a proposal.
        public let proposal: Proposal?

        public init(proposal: Proposal? = nil) {
            self.proposal = proposal
        }

        private enum CodingKeys: String, CodingKey {
            case proposal = "Proposal"
        }
    }

    public struct Invitation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the invitation. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The date and time that the invitation was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The date and time that the invitation expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, the invitee can no longer create a member and join the network using this InvitationId.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationDate: Date?
        /// The unique identifier for the invitation.
        public let invitationId: String?
        public let networkSummary: NetworkSummary?
        /// The status of the invitation:    PENDING - The invitee has not created a member to join the network, and the invitation has not yet expired.    ACCEPTING - The invitee has begun creating a member, and creation has not yet completed.    ACCEPTED - The invitee created a member and joined the network using the InvitationID.    REJECTED - The invitee rejected the invitation.    EXPIRED - The invitee neither created a member nor rejected the invitation before the ExpirationDate.
        public let status: InvitationStatus?

        public init(arn: String? = nil, creationDate: Date? = nil, expirationDate: Date? = nil, invitationId: String? = nil, networkSummary: NetworkSummary? = nil, status: InvitationStatus? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.expirationDate = expirationDate
            self.invitationId = invitationId
            self.networkSummary = networkSummary
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case expirationDate = "ExpirationDate"
            case invitationId = "InvitationId"
            case networkSummary = "NetworkSummary"
            case status = "Status"
        }
    }

    public struct InviteAction: AWSEncodableShape & AWSDecodableShape {
        /// The AWS account ID to invite.
        public let principal: String

        public init(principal: String) {
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case principal = "Principal"
        }
    }

    public struct ListInvitationsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of invitations to return.
        public let maxResults: Int?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsOutput: AWSDecodableShape {
        /// The invitations for the network.
        public let invitations: [Invitation]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "isOwned", location: .querystring(locationName: "isOwned")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring(locationName: "name")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// An optional Boolean value. If provided, the request is limited either to members that the current AWS account owns (true) or that other AWS accounts own (false). If omitted, all members are listed.
        public let isOwned: Bool?
        /// The maximum number of members to return in the request.
        public let maxResults: Int?
        /// The optional name of the member to list.
        public let name: String?
        /// The unique identifier of the network for which to list members.
        public let networkId: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only members currently in this status are listed.
        public let status: MemberStatus?

        public init(isOwned: Bool? = nil, maxResults: Int? = nil, name: String? = nil, networkId: String, nextToken: String? = nil, status: MemberStatus? = nil) {
            self.isOwned = isOwned
            self.maxResults = maxResults
            self.name = name
            self.networkId = networkId
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersOutput: AWSDecodableShape {
        /// An array of MemberSummary objects. Each object contains details about a network member.
        public let members: [MemberSummary]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(members: [MemberSummary]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListNetworksInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "framework", location: .querystring(locationName: "framework")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring(locationName: "name")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// An optional framework specifier. If provided, only networks of this framework type are listed.
        public let framework: Framework?
        /// The maximum number of networks to list.
        public let maxResults: Int?
        /// The name of the network.
        public let name: String?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only networks currently in this status are listed. Applies only to Hyperledger Fabric.
        public let status: NetworkStatus?

        public init(framework: Framework? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, status: NetworkStatus? = nil) {
            self.framework = framework
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNetworksOutput: AWSDecodableShape {
        /// An array of NetworkSummary objects that contain configuration properties for each network.
        public let networks: [NetworkSummary]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(networks: [NetworkSummary]? = nil, nextToken: String? = nil) {
            self.networks = networks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networks = "Networks"
            case nextToken = "NextToken"
        }
    }

    public struct ListNodesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "memberId", location: .querystring(locationName: "memberId")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// The maximum number of nodes to list.
        public let maxResults: Int?
        /// The unique identifier of the member who owns the nodes to list. Applies only to Hyperledger Fabric and is required for Hyperledger Fabric.
        public let memberId: String?
        /// The unique identifier of the network for which to list nodes.
        public let networkId: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only nodes currently in this status are listed.
        public let status: NodeStatus?

        public init(maxResults: Int? = nil, memberId: String? = nil, networkId: String, nextToken: String? = nil, status: NodeStatus? = nil) {
            self.maxResults = maxResults
            self.memberId = memberId
            self.networkId = networkId
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesOutput: AWSDecodableShape {
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An array of NodeSummary objects that contain configuration properties for each node.
        public let nodes: [NodeSummary]?

        public init(nextToken: String? = nil, nodes: [NodeSummary]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case nodes = "Nodes"
        }
    }

    public struct ListProposalVotesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "proposalId", location: .uri(locationName: "proposalId"))
        ]

        ///  The maximum number of votes to return.
        public let maxResults: Int?
        ///  The unique identifier of the network.
        public let networkId: String
        ///  The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        ///  The unique identifier of the proposal.
        public let proposalId: String

        public init(maxResults: Int? = nil, networkId: String, nextToken: String? = nil, proposalId: String) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.proposalId = proposalId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.proposalId, name: "proposalId", parent: name, max: 32)
            try self.validate(self.proposalId, name: "proposalId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProposalVotesOutput: AWSDecodableShape {
        ///  The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        ///  The list of votes.
        public let proposalVotes: [VoteSummary]?

        public init(nextToken: String? = nil, proposalVotes: [VoteSummary]? = nil) {
            self.nextToken = nextToken
            self.proposalVotes = proposalVotes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proposalVotes = "ProposalVotes"
        }
    }

    public struct ListProposalsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        ///  The maximum number of proposals to return.
        public let maxResults: Int?
        ///  The unique identifier of the network.
        public let networkId: String
        ///  The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(maxResults: Int? = nil, networkId: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProposalsOutput: AWSDecodableShape {
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The summary of each proposal made on the network.
        public let proposals: [ProposalSummary]?

        public init(nextToken: String? = nil, proposals: [ProposalSummary]? = nil) {
            self.nextToken = nextToken
            self.proposals = proposals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proposals = "Proposals"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+:.+:.+:.+:.+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags assigned to the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LogConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether logging is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct LogConfigurations: AWSEncodableShape & AWSDecodableShape {
        /// Parameters for publishing logs to Amazon CloudWatch Logs.
        public let cloudwatch: LogConfiguration?

        public init(cloudwatch: LogConfiguration? = nil) {
            self.cloudwatch = cloudwatch
        }

        private enum CodingKeys: String, CodingKey {
            case cloudwatch = "Cloudwatch"
        }
    }

    public struct Member: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the member. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The date and time that the member was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// An optional description for the member.
        public let description: String?
        /// Attributes relevant to a member for the blockchain framework that the Managed Blockchain network uses.
        public let frameworkAttributes: MemberFrameworkAttributes?
        /// The unique identifier of the member.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the customer managed key in AWS Key Management Service (AWS KMS) that the member uses for encryption at rest. If the value of this parameter is "AWS Owned KMS Key", the member uses an AWS owned KMS key for encryption. This parameter is inherited by the nodes that this member owns.
        public let kmsKeyArn: String?
        /// Configuration properties for logging events associated with a member.
        public let logPublishingConfiguration: MemberLogPublishingConfiguration?
        /// The name of the member.
        public let name: String?
        /// The unique identifier of the network to which the member belongs.
        public let networkId: String?
        /// The status of a member.    CREATING - The AWS account is in the process of creating a member.    AVAILABLE - The member has been created and can participate in the network.    CREATE_FAILED - The AWS account attempted to create a member and creation failed.    UPDATING - The member is in the process of being updated.    DELETING - The member and all associated resources are in the process of being deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    DELETED - The member can no longer participate on the network and all associated resources are deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    INACCESSIBLE_ENCRYPTION_KEY - The member is impaired and might not function as expected because it cannot access the specified customer managed key in AWS KMS for encryption at rest. Either the KMS key was disabled or deleted, or the grants on the key were revoked. The effect of disabling or deleting a key, or revoking a grant is not immediate. The member resource might take some time to find that the key is inaccessible. When a resource is in this state, we recommend deleting and recreating the resource.
        public let status: MemberStatus?
        /// Tags assigned to the member. Tags consist of a key and optional value. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationDate: Date? = nil, description: String? = nil, frameworkAttributes: MemberFrameworkAttributes? = nil, id: String? = nil, kmsKeyArn: String? = nil, logPublishingConfiguration: MemberLogPublishingConfiguration? = nil, name: String? = nil, networkId: String? = nil, status: MemberStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.frameworkAttributes = frameworkAttributes
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.logPublishingConfiguration = logPublishingConfiguration
            self.name = name
            self.networkId = networkId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case frameworkAttributes = "FrameworkAttributes"
            case id = "Id"
            case kmsKeyArn = "KmsKeyArn"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case name = "Name"
            case networkId = "NetworkId"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct MemberConfiguration: AWSEncodableShape {
        /// An optional description of the member.
        public let description: String?
        /// Configuration properties of the blockchain framework relevant to the member.
        public let frameworkConfiguration: MemberFrameworkConfiguration
        /// The Amazon Resource Name (ARN) of the customer managed key in AWS Key Management Service (AWS KMS) to use for encryption at rest in the member. This parameter is inherited by any nodes that this member creates. Use one of the following options to specify this parameter:    Undefined or empty string - The member uses an AWS owned KMS key for encryption by default.    A valid symmetric customer managed KMS key - The member uses the specified key for encryption. Amazon Managed Blockchain doesn't support asymmetric keys. For more information, see Using symmetric and asymmetric keys in the AWS Key Management Service Developer Guide. The following is an example of a KMS key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
        public let kmsKeyArn: String?
        /// Configuration properties for logging events associated with a member of a Managed Blockchain network.
        public let logPublishingConfiguration: MemberLogPublishingConfiguration?
        /// The name of the member.
        public let name: String
        /// Tags assigned to the member. Tags consist of a key and optional value. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide. When specifying tags during creation, you can specify multiple key-value pairs in a single request, with an overall maximum of 50 tags added to each resource.
        public let tags: [String: String]?

        public init(description: String? = nil, frameworkConfiguration: MemberFrameworkConfiguration, kmsKeyArn: String? = nil, logPublishingConfiguration: MemberLogPublishingConfiguration? = nil, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.frameworkConfiguration = frameworkConfiguration
            self.kmsKeyArn = kmsKeyArn
            self.logPublishingConfiguration = logPublishingConfiguration
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.frameworkConfiguration.validate(name: "\(name).frameworkConfiguration")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 1011)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:.+:.+:.+:.+:.+")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!-|[0-9])(?!.*-$)(?!.*?--)[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case frameworkConfiguration = "FrameworkConfiguration"
            case kmsKeyArn = "KmsKeyArn"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct MemberFabricAttributes: AWSDecodableShape {
        /// The user name for the initial administrator user for the member.
        public let adminUsername: String?
        /// The endpoint used to access the member's certificate authority.
        public let caEndpoint: String?

        public init(adminUsername: String? = nil, caEndpoint: String? = nil) {
            self.adminUsername = adminUsername
            self.caEndpoint = caEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case adminUsername = "AdminUsername"
            case caEndpoint = "CaEndpoint"
        }
    }

    public struct MemberFabricConfiguration: AWSEncodableShape {
        /// The password for the member's initial administrative user. The AdminPassword must be at least eight characters long and no more than 32 characters. It must contain at least one uppercase letter, one lowercase letter, and one digit. It cannot have a single quotation mark (‘), a double quotation marks (“), a forward slash(/), a backward slash(\), @, or a space.
        public let adminPassword: String
        /// The user name for the member's initial administrative user.
        public let adminUsername: String

        public init(adminPassword: String, adminUsername: String) {
            self.adminPassword = adminPassword
            self.adminUsername = adminUsername
        }

        public func validate(name: String) throws {
            try self.validate(self.adminPassword, name: "adminPassword", parent: name, max: 32)
            try self.validate(self.adminPassword, name: "adminPassword", parent: name, min: 8)
            try self.validate(self.adminPassword, name: "adminPassword", parent: name, pattern: "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?!.*[@'\\\\\"/])[a-zA-Z0-9\\S]*$")
            try self.validate(self.adminUsername, name: "adminUsername", parent: name, max: 16)
            try self.validate(self.adminUsername, name: "adminUsername", parent: name, min: 1)
            try self.validate(self.adminUsername, name: "adminUsername", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminPassword = "AdminPassword"
            case adminUsername = "AdminUsername"
        }
    }

    public struct MemberFabricLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration properties for logging events associated with a member's Certificate Authority (CA). CA logs help you determine when a member in your account joins the network, or when new peers register with a member CA.
        public let caLogs: LogConfigurations?

        public init(caLogs: LogConfigurations? = nil) {
            self.caLogs = caLogs
        }

        private enum CodingKeys: String, CodingKey {
            case caLogs = "CaLogs"
        }
    }

    public struct MemberFrameworkAttributes: AWSDecodableShape {
        /// Attributes of Hyperledger Fabric relevant to a member on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: MemberFabricAttributes?

        public init(fabric: MemberFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberFrameworkConfiguration: AWSEncodableShape {
        /// Attributes of Hyperledger Fabric for a member on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: MemberFabricConfiguration?

        public init(fabric: MemberFabricConfiguration? = nil) {
            self.fabric = fabric
        }

        public func validate(name: String) throws {
            try self.fabric?.validate(name: "\(name).fabric")
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration properties for logging events associated with a member of a Managed Blockchain network using the Hyperledger Fabric framework.
        public let fabric: MemberFabricLogPublishingConfiguration?

        public init(fabric: MemberFabricLogPublishingConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the member. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The date and time that the member was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// An optional description of the member.
        public let description: String?
        /// The unique identifier of the member.
        public let id: String?
        /// An indicator of whether the member is owned by your AWS account or a different AWS account.
        public let isOwned: Bool?
        /// The name of the member.
        public let name: String?
        /// The status of the member.    CREATING - The AWS account is in the process of creating a member.    AVAILABLE - The member has been created and can participate in the network.    CREATE_FAILED - The AWS account attempted to create a member and creation failed.    UPDATING - The member is in the process of being updated.    DELETING - The member and all associated resources are in the process of being deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    DELETED - The member can no longer participate on the network and all associated resources are deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    INACCESSIBLE_ENCRYPTION_KEY - The member is impaired and might not function as expected because it cannot access the specified customer managed key in AWS Key Management Service (AWS KMS) for encryption at rest. Either the KMS key was disabled or deleted, or the grants on the key were revoked. The effect of disabling or deleting a key, or revoking a grant is not immediate. The member resource might take some time to find that the key is inaccessible. When a resource is in this state, we recommend deleting and recreating the resource.
        public let status: MemberStatus?

        public init(arn: String? = nil, creationDate: Date? = nil, description: String? = nil, id: String? = nil, isOwned: Bool? = nil, name: String? = nil, status: MemberStatus? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.isOwned = isOwned
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case id = "Id"
            case isOwned = "IsOwned"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct Network: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the network. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The date and time that the network was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// Attributes of the blockchain framework for the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework?
        /// Attributes of the blockchain framework that the network uses.
        public let frameworkAttributes: NetworkFrameworkAttributes?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String?
        /// The unique identifier of the network.
        public let id: String?
        /// The name of the network.
        public let name: String?
        /// The current status of the network.
        public let status: NetworkStatus?
        /// Tags assigned to the network. Each tag consists of a key and optional value. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Ethereum Developer Guide, or Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?
        /// The voting rules for the network to decide if a proposal is accepted.
        public let votingPolicy: VotingPolicy?
        /// The VPC endpoint service name of the VPC endpoint service of the network. Members use the VPC endpoint service name to create a VPC endpoint to access network resources.
        public let vpcEndpointServiceName: String?

        public init(arn: String? = nil, creationDate: Date? = nil, description: String? = nil, framework: Framework? = nil, frameworkAttributes: NetworkFrameworkAttributes? = nil, frameworkVersion: String? = nil, id: String? = nil, name: String? = nil, status: NetworkStatus? = nil, tags: [String: String]? = nil, votingPolicy: VotingPolicy? = nil, vpcEndpointServiceName: String? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.framework = framework
            self.frameworkAttributes = frameworkAttributes
            self.frameworkVersion = frameworkVersion
            self.id = id
            self.name = name
            self.status = status
            self.tags = tags
            self.votingPolicy = votingPolicy
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case framework = "Framework"
            case frameworkAttributes = "FrameworkAttributes"
            case frameworkVersion = "FrameworkVersion"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case votingPolicy = "VotingPolicy"
            case vpcEndpointServiceName = "VpcEndpointServiceName"
        }
    }

    public struct NetworkEthereumAttributes: AWSDecodableShape {
        /// The Ethereum CHAIN_ID associated with the Ethereum network. Chain IDs are as follows:   mainnet = 1    rinkeby = 4    ropsten = 3
        public let chainId: String?

        public init(chainId: String? = nil) {
            self.chainId = chainId
        }

        private enum CodingKeys: String, CodingKey {
            case chainId = "ChainId"
        }
    }

    public struct NetworkFabricAttributes: AWSDecodableShape {
        /// The edition of Amazon Managed Blockchain that Hyperledger Fabric uses. For more information, see Amazon Managed Blockchain Pricing.
        public let edition: Edition?
        /// The endpoint of the ordering service for the network.
        public let orderingServiceEndpoint: String?

        public init(edition: Edition? = nil, orderingServiceEndpoint: String? = nil) {
            self.edition = edition
            self.orderingServiceEndpoint = orderingServiceEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
            case orderingServiceEndpoint = "OrderingServiceEndpoint"
        }
    }

    public struct NetworkFabricConfiguration: AWSEncodableShape {
        /// The edition of Amazon Managed Blockchain that the network uses. For more information, see Amazon Managed Blockchain Pricing.
        public let edition: Edition

        public init(edition: Edition) {
            self.edition = edition
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
        }
    }

    public struct NetworkFrameworkAttributes: AWSDecodableShape {
        /// Attributes of an Ethereum network for Managed Blockchain resources participating in an Ethereum network.
        public let ethereum: NetworkEthereumAttributes?
        /// Attributes of Hyperledger Fabric for a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NetworkFabricAttributes?

        public init(ethereum: NetworkEthereumAttributes? = nil, fabric: NetworkFabricAttributes? = nil) {
            self.ethereum = ethereum
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case ethereum = "Ethereum"
            case fabric = "Fabric"
        }
    }

    public struct NetworkFrameworkConfiguration: AWSEncodableShape {
        ///  Hyperledger Fabric configuration properties for a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NetworkFabricConfiguration?

        public init(fabric: NetworkFabricConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NetworkSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the network. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The date and time that the network was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// An optional description of the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String?
        /// The unique identifier of the network.
        public let id: String?
        /// The name of the network.
        public let name: String?
        /// The current status of the network.
        public let status: NetworkStatus?

        public init(arn: String? = nil, creationDate: Date? = nil, description: String? = nil, framework: Framework? = nil, frameworkVersion: String? = nil, id: String? = nil, name: String? = nil, status: NetworkStatus? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case id = "Id"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct Node: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the node. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The Availability Zone in which the node exists. Required for Ethereum nodes.
        public let availabilityZone: String?
        /// The date and time that the node was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// Attributes of the blockchain framework being used.
        public let frameworkAttributes: NodeFrameworkAttributes?
        /// The unique identifier of the node.
        public let id: String?
        /// The instance type of the node.
        public let instanceType: String?
        /// The Amazon Resource Name (ARN) of the customer managed key in AWS Key Management Service (AWS KMS) that the node uses for encryption at rest. If the value of this parameter is "AWS Owned KMS Key", the node uses an AWS owned KMS key for encryption. The node inherits this parameter from the member that it belongs to. Applies only to Hyperledger Fabric.
        public let kmsKeyArn: String?
        /// Configuration properties for logging events associated with a peer node on a Hyperledger Fabric network on Managed Blockchain.
        public let logPublishingConfiguration: NodeLogPublishingConfiguration?
        /// The unique identifier of the member to which the node belongs. Applies only to Hyperledger Fabric.
        public let memberId: String?
        /// The unique identifier of the network that the node is on.
        public let networkId: String?
        /// The state database that the node uses. Values are LevelDB or CouchDB. Applies only to Hyperledger Fabric.
        public let stateDB: StateDBType?
        /// The status of the node.    CREATING - The AWS account is in the process of creating a node.    AVAILABLE - The node has been created and can participate in the network.    UNHEALTHY - The node is impaired and might not function as expected. Amazon Managed Blockchain automatically finds nodes in this state and tries to recover them. If a node is recoverable, it returns to AVAILABLE. Otherwise, it moves to FAILED status.    CREATE_FAILED - The AWS account attempted to create a node and creation failed.    UPDATING - The node is in the process of being updated.    DELETING - The node is in the process of being deleted.    DELETED - The node can no longer participate on the network.    FAILED - The node is no longer functional, cannot be recovered, and must be deleted.    INACCESSIBLE_ENCRYPTION_KEY - The node is impaired and might not function as expected because it cannot access the specified customer managed key in AWS KMS for encryption at rest. Either the KMS key was disabled or deleted, or the grants on the key were revoked. The effect of disabling or deleting a key, or revoking a grant is not immediate. The node resource might take some time to find that the key is inaccessible. When a resource is in this state, we recommend deleting and recreating the resource.
        public let status: NodeStatus?
        /// Tags assigned to the node. Each tag consists of a key and optional value. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Ethereum Developer Guide, or Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?

        public init(arn: String? = nil, availabilityZone: String? = nil, creationDate: Date? = nil, frameworkAttributes: NodeFrameworkAttributes? = nil, id: String? = nil, instanceType: String? = nil, kmsKeyArn: String? = nil, logPublishingConfiguration: NodeLogPublishingConfiguration? = nil, memberId: String? = nil, networkId: String? = nil, stateDB: StateDBType? = nil, status: NodeStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.creationDate = creationDate
            self.frameworkAttributes = frameworkAttributes
            self.id = id
            self.instanceType = instanceType
            self.kmsKeyArn = kmsKeyArn
            self.logPublishingConfiguration = logPublishingConfiguration
            self.memberId = memberId
            self.networkId = networkId
            self.stateDB = stateDB
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityZone = "AvailabilityZone"
            case creationDate = "CreationDate"
            case frameworkAttributes = "FrameworkAttributes"
            case id = "Id"
            case instanceType = "InstanceType"
            case kmsKeyArn = "KmsKeyArn"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case memberId = "MemberId"
            case networkId = "NetworkId"
            case stateDB = "StateDB"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct NodeConfiguration: AWSEncodableShape {
        /// The Availability Zone in which the node exists. Required for Ethereum nodes.
        public let availabilityZone: String?
        /// The Amazon Managed Blockchain instance type for the node.
        public let instanceType: String
        /// Configuration properties for logging events associated with a peer node on a Hyperledger Fabric network on Managed Blockchain.
        public let logPublishingConfiguration: NodeLogPublishingConfiguration?
        /// The state database that the node uses. Values are LevelDB or CouchDB. When using an Amazon Managed Blockchain network with Hyperledger Fabric version 1.4 or later, the default is CouchDB. Applies only to Hyperledger Fabric.
        public let stateDB: StateDBType?

        public init(availabilityZone: String? = nil, instanceType: String, logPublishingConfiguration: NodeLogPublishingConfiguration? = nil, stateDB: StateDBType? = nil) {
            self.availabilityZone = availabilityZone
            self.instanceType = instanceType
            self.logPublishingConfiguration = logPublishingConfiguration
            self.stateDB = stateDB
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case instanceType = "InstanceType"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case stateDB = "StateDB"
        }
    }

    public struct NodeEthereumAttributes: AWSDecodableShape {
        /// The endpoint on which the Ethereum node listens to run Ethereum JSON-RPC methods over HTTP connections from a client. Use this endpoint in client code for smart contracts when using an HTTP connection. Connections to this endpoint are authenticated using Signature Version 4.
        public let httpEndpoint: String?
        /// The endpoint on which the Ethereum node listens to run Ethereum JSON-RPC methods over WebSockets connections from a client. Use this endpoint in client code for smart contracts when using a WebSockets connection. Connections to this endpoint are authenticated using Signature Version 4.
        public let webSocketEndpoint: String?

        public init(httpEndpoint: String? = nil, webSocketEndpoint: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.webSocketEndpoint = webSocketEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case webSocketEndpoint = "WebSocketEndpoint"
        }
    }

    public struct NodeFabricAttributes: AWSDecodableShape {
        /// The endpoint that identifies the peer node for all services except peer channel-based event services.
        public let peerEndpoint: String?
        /// The endpoint that identifies the peer node for peer channel-based event services.
        public let peerEventEndpoint: String?

        public init(peerEndpoint: String? = nil, peerEventEndpoint: String? = nil) {
            self.peerEndpoint = peerEndpoint
            self.peerEventEndpoint = peerEventEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case peerEndpoint = "PeerEndpoint"
            case peerEventEndpoint = "PeerEventEndpoint"
        }
    }

    public struct NodeFabricLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration properties for logging events associated with chaincode execution on a peer node. Chaincode logs contain the results of instantiating, invoking, and querying the chaincode. A peer can run multiple instances of chaincode. When enabled, a log stream is created for all chaincodes, with an individual log stream for each chaincode.
        public let chaincodeLogs: LogConfigurations?
        /// Configuration properties for a peer node log. Peer node logs contain messages generated when your client submits transaction proposals to peer nodes, requests to join channels, enrolls an admin peer, and lists the chaincode instances on a peer node.
        public let peerLogs: LogConfigurations?

        public init(chaincodeLogs: LogConfigurations? = nil, peerLogs: LogConfigurations? = nil) {
            self.chaincodeLogs = chaincodeLogs
            self.peerLogs = peerLogs
        }

        private enum CodingKeys: String, CodingKey {
            case chaincodeLogs = "ChaincodeLogs"
            case peerLogs = "PeerLogs"
        }
    }

    public struct NodeFrameworkAttributes: AWSDecodableShape {
        /// Attributes of Ethereum for a node on a Managed Blockchain network that uses Ethereum.
        public let ethereum: NodeEthereumAttributes?
        /// Attributes of Hyperledger Fabric for a peer node on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NodeFabricAttributes?

        public init(ethereum: NodeEthereumAttributes? = nil, fabric: NodeFabricAttributes? = nil) {
            self.ethereum = ethereum
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case ethereum = "Ethereum"
            case fabric = "Fabric"
        }
    }

    public struct NodeLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration properties for logging events associated with a node that is owned by a member of a Managed Blockchain network using the Hyperledger Fabric framework.
        public let fabric: NodeFabricLogPublishingConfiguration?

        public init(fabric: NodeFabricLogPublishingConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NodeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the node. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        /// The Availability Zone in which the node exists.
        public let availabilityZone: String?
        /// The date and time that the node was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The unique identifier of the node.
        public let id: String?
        /// The EC2 instance type for the node.
        public let instanceType: String?
        /// The status of the node.
        public let status: NodeStatus?

        public init(arn: String? = nil, availabilityZone: String? = nil, creationDate: Date? = nil, id: String? = nil, instanceType: String? = nil, status: NodeStatus? = nil) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.creationDate = creationDate
            self.id = id
            self.instanceType = instanceType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityZone = "AvailabilityZone"
            case creationDate = "CreationDate"
            case id = "Id"
            case instanceType = "InstanceType"
            case status = "Status"
        }
    }

    public struct Proposal: AWSDecodableShape {
        /// The actions to perform on the network if the proposal is APPROVED.
        public let actions: ProposalActions?
        /// The Amazon Resource Name (ARN) of the proposal. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        ///  The date and time that the proposal was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        /// The description of the proposal.
        public let description: String?
        ///  The date and time that the proposal expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, if members have not cast enough votes to determine the outcome according to the voting policy, the proposal is EXPIRED and Actions are not carried out.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationDate: Date?
        /// The unique identifier of the network for which the proposal is made.
        public let networkId: String?
        ///  The current total of NO votes cast on the proposal by members.
        public let noVoteCount: Int?
        ///  The number of votes remaining to be cast on the proposal by members. In other words, the number of members minus the sum of YES votes and NO votes.
        public let outstandingVoteCount: Int?
        /// The unique identifier of the proposal.
        public let proposalId: String?
        /// The unique identifier of the member that created the proposal.
        public let proposedByMemberId: String?
        /// The name of the member that created the proposal.
        public let proposedByMemberName: String?
        /// The status of the proposal. Values are as follows:    IN_PROGRESS - The proposal is active and open for member voting.    APPROVED - The proposal was approved with sufficient YES votes among members according to the VotingPolicy specified for the Network. The specified proposal actions are carried out.    REJECTED - The proposal was rejected with insufficient YES votes among members according to the VotingPolicy specified for the Network. The specified ProposalActions are not carried out.    EXPIRED - Members did not cast the number of votes required to determine the proposal outcome before the proposal expired. The specified ProposalActions are not carried out.    ACTION_FAILED - One or more of the specified ProposalActions in a proposal that was approved could not be completed because of an error. The ACTION_FAILED status occurs even if only one ProposalAction fails and other actions are successful.
        public let status: ProposalStatus?
        /// Tags assigned to the proposal. Each tag consists of a key and optional value. For more information about tags, see Tagging Resources in the Amazon Managed Blockchain Ethereum Developer Guide, or Tagging Resources in the Amazon Managed Blockchain Hyperledger Fabric Developer Guide.
        public let tags: [String: String]?
        ///  The current total of YES votes cast on the proposal by members.
        public let yesVoteCount: Int?

        public init(actions: ProposalActions? = nil, arn: String? = nil, creationDate: Date? = nil, description: String? = nil, expirationDate: Date? = nil, networkId: String? = nil, noVoteCount: Int? = nil, outstandingVoteCount: Int? = nil, proposalId: String? = nil, proposedByMemberId: String? = nil, proposedByMemberName: String? = nil, status: ProposalStatus? = nil, tags: [String: String]? = nil, yesVoteCount: Int? = nil) {
            self.actions = actions
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.expirationDate = expirationDate
            self.networkId = networkId
            self.noVoteCount = noVoteCount
            self.outstandingVoteCount = outstandingVoteCount
            self.proposalId = proposalId
            self.proposedByMemberId = proposedByMemberId
            self.proposedByMemberName = proposedByMemberName
            self.status = status
            self.tags = tags
            self.yesVoteCount = yesVoteCount
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case expirationDate = "ExpirationDate"
            case networkId = "NetworkId"
            case noVoteCount = "NoVoteCount"
            case outstandingVoteCount = "OutstandingVoteCount"
            case proposalId = "ProposalId"
            case proposedByMemberId = "ProposedByMemberId"
            case proposedByMemberName = "ProposedByMemberName"
            case status = "Status"
            case tags = "Tags"
            case yesVoteCount = "YesVoteCount"
        }
    }

    public struct ProposalActions: AWSEncodableShape & AWSDecodableShape {
        ///  The actions to perform for an APPROVED proposal to invite an AWS account to create a member and join the network.
        public let invitations: [InviteAction]?
        ///  The actions to perform for an APPROVED proposal to remove a member from the network, which deletes the member and all associated member resources from the network.
        public let removals: [RemoveAction]?

        public init(invitations: [InviteAction]? = nil, removals: [RemoveAction]? = nil) {
            self.invitations = invitations
            self.removals = removals
        }

        public func validate(name: String) throws {
            try self.removals?.forEach {
                try $0.validate(name: "\(name).removals[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case removals = "Removals"
        }
    }

    public struct ProposalSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the proposal. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let arn: String?
        ///  The date and time that the proposal was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        ///  The description of the proposal.
        public let description: String?
        ///  The date and time that the proposal expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, if members have not cast enough votes to determine the outcome according to the voting policy, the proposal is EXPIRED and Actions are not carried out.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationDate: Date?
        ///  The unique identifier of the proposal.
        public let proposalId: String?
        ///  The unique identifier of the member that created the proposal.
        public let proposedByMemberId: String?
        ///  The name of the member that created the proposal.
        public let proposedByMemberName: String?
        /// The status of the proposal. Values are as follows:    IN_PROGRESS - The proposal is active and open for member voting.    APPROVED - The proposal was approved with sufficient YES votes among members according to the VotingPolicy specified for the Network. The specified proposal actions are carried out.    REJECTED - The proposal was rejected with insufficient YES votes among members according to the VotingPolicy specified for the Network. The specified ProposalActions are not carried out.    EXPIRED - Members did not cast the number of votes required to determine the proposal outcome before the proposal expired. The specified ProposalActions are not carried out.    ACTION_FAILED - One or more of the specified ProposalActions in a proposal that was approved could not be completed because of an error.
        public let status: ProposalStatus?

        public init(arn: String? = nil, creationDate: Date? = nil, description: String? = nil, expirationDate: Date? = nil, proposalId: String? = nil, proposedByMemberId: String? = nil, proposedByMemberName: String? = nil, status: ProposalStatus? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.expirationDate = expirationDate
            self.proposalId = proposalId
            self.proposedByMemberId = proposedByMemberId
            self.proposedByMemberName = proposedByMemberName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case expirationDate = "ExpirationDate"
            case proposalId = "ProposalId"
            case proposedByMemberId = "ProposedByMemberId"
            case proposedByMemberName = "ProposedByMemberName"
            case status = "Status"
        }
    }

    public struct RejectInvitationInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "invitationId", location: .uri(locationName: "invitationId"))
        ]

        /// The unique identifier of the invitation to reject.
        public let invitationId: String

        public init(invitationId: String) {
            self.invitationId = invitationId
        }

        public func validate(name: String) throws {
            try self.validate(self.invitationId, name: "invitationId", parent: name, max: 32)
            try self.validate(self.invitationId, name: "invitationId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectInvitationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct RemoveAction: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the member to remove.
        public let memberId: String

        public init(memberId: String) {
            self.memberId = memberId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let resourceArn: String
        /// The tags to assign to the specified resource. Tag values can be empty, for example, "MyTagKey" : "". You can specify multiple key-value pairs in a single request, with an overall maximum of 50 tags added to each resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+:.+:.+:.+:.+")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource. For more information about ARNs and their format, see Amazon Resource Names (ARNs) in the AWS General Reference.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+:.+:.+:.+:.+")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")),
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// Configuration properties for publishing to Amazon CloudWatch Logs.
        public let logPublishingConfiguration: MemberLogPublishingConfiguration?
        /// The unique identifier of the member.
        public let memberId: String
        /// The unique identifier of the Managed Blockchain network to which the member belongs.
        public let networkId: String

        public init(logPublishingConfiguration: MemberLogPublishingConfiguration? = nil, memberId: String, networkId: String) {
            self.logPublishingConfiguration = logPublishingConfiguration
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case logPublishingConfiguration = "LogPublishingConfiguration"
        }
    }

    public struct UpdateMemberOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "nodeId", location: .uri(locationName: "nodeId"))
        ]

        /// Configuration properties for publishing to Amazon CloudWatch Logs.
        public let logPublishingConfiguration: NodeLogPublishingConfiguration?
        /// The unique identifier of the member that owns the node. Applies only to Hyperledger Fabric.
        public let memberId: String?
        /// The unique identifier of the network that the node is on.
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(logPublishingConfiguration: NodeLogPublishingConfiguration? = nil, memberId: String? = nil, networkId: String, nodeId: String) {
            self.logPublishingConfiguration = logPublishingConfiguration
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        public func validate(name: String) throws {
            try self.validate(self.memberId, name: "memberId", parent: name, max: 32)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 32)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case memberId = "MemberId"
        }
    }

    public struct UpdateNodeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct VoteOnProposalInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")),
            AWSMemberEncoding(label: "proposalId", location: .uri(locationName: "proposalId"))
        ]

        ///  The unique identifier of the network.
        public let networkId: String
        ///  The unique identifier of the proposal.
        public let proposalId: String
        ///  The value of the vote.
        public let vote: VoteValue
        /// The unique identifier of the member casting the vote.
        public let voterMemberId: String

        public init(networkId: String, proposalId: String, vote: VoteValue, voterMemberId: String) {
            self.networkId = networkId
            self.proposalId = proposalId
            self.vote = vote
            self.voterMemberId = voterMemberId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkId, name: "networkId", parent: name, max: 32)
            try self.validate(self.networkId, name: "networkId", parent: name, min: 1)
            try self.validate(self.proposalId, name: "proposalId", parent: name, max: 32)
            try self.validate(self.proposalId, name: "proposalId", parent: name, min: 1)
            try self.validate(self.voterMemberId, name: "voterMemberId", parent: name, max: 32)
            try self.validate(self.voterMemberId, name: "voterMemberId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vote = "Vote"
            case voterMemberId = "VoterMemberId"
        }
    }

    public struct VoteOnProposalOutput: AWSDecodableShape {
        public init() {}
    }

    public struct VoteSummary: AWSDecodableShape {
        ///  The unique identifier of the member that cast the vote.
        public let memberId: String?
        ///  The name of the member that cast the vote.
        public let memberName: String?
        ///  The vote value, either YES or NO.
        public let vote: VoteValue?

        public init(memberId: String? = nil, memberName: String? = nil, vote: VoteValue? = nil) {
            self.memberId = memberId
            self.memberName = memberName
            self.vote = vote
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case memberName = "MemberName"
            case vote = "Vote"
        }
    }

    public struct VotingPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Defines the rules for the network for voting on proposals, such as the percentage of YES votes required for the proposal to be approved and the duration of the proposal. The policy applies to all proposals and is specified when the network is created.
        public let approvalThresholdPolicy: ApprovalThresholdPolicy?

        public init(approvalThresholdPolicy: ApprovalThresholdPolicy? = nil) {
            self.approvalThresholdPolicy = approvalThresholdPolicy
        }

        public func validate(name: String) throws {
            try self.approvalThresholdPolicy?.validate(name: "\(name).approvalThresholdPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case approvalThresholdPolicy = "ApprovalThresholdPolicy"
        }
    }
}
