//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore
import Foundation

extension ManagedBlockchain {
    // MARK: Enums

    public enum Edition: String, CustomStringConvertible, Codable {
        case starter = "STARTER"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum Framework: String, CustomStringConvertible, Codable {
        case hyperledgerFabric = "HYPERLEDGER_FABRIC"
        public var description: String { return self.rawValue }
    }

    public enum InvitationStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case accepted = "ACCEPTED"
        case accepting = "ACCEPTING"
        case rejected = "REJECTED"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum MemberStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public enum NetworkStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case deleting = "DELETING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public enum NodeStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case deleted = "DELETED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ProposalStatus: String, CustomStringConvertible, Codable {
        case inProgress = "IN_PROGRESS"
        case approved = "APPROVED"
        case rejected = "REJECTED"
        case expired = "EXPIRED"
        case actionFailed = "ACTION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ThresholdComparator: String, CustomStringConvertible, Codable {
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        public var description: String { return self.rawValue }
    }

    public enum VoteValue: String, CustomStringConvertible, Codable {
        case yes = "YES"
        case no = "NO"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApprovalThresholdPolicy: AWSEncodableShape & AWSDecodableShape {

        /// The duration from the time that a proposal is created until it expires. If members cast neither the required number of YES votes to approve the proposal nor the number of NO votes required to reject it before the duration expires, the proposal is EXPIRED and ProposalActions are not carried out.
        public let proposalDurationInHours: Int?
        /// Determines whether the vote percentage must be greater than the ThresholdPercentage or must be greater than or equal to the ThreholdPercentage to be approved.
        public let thresholdComparator: ThresholdComparator?
        /// The percentage of votes among all members that must be YES for a proposal to be approved. For example, a ThresholdPercentage value of 50 indicates 50%. The ThresholdComparator determines the precise comparison. If a ThresholdPercentage value of 50 is specified on a network with 10 members, along with a ThresholdComparator value of GREATER_THAN, this indicates that 6 YES votes are required for the proposal to be approved.
        public let thresholdPercentage: Int?

        public init(proposalDurationInHours: Int? = nil, thresholdComparator: ThresholdComparator? = nil, thresholdPercentage: Int? = nil) {
            self.proposalDurationInHours = proposalDurationInHours
            self.thresholdComparator = thresholdComparator
            self.thresholdPercentage = thresholdPercentage
        }

        public func validate(name: String) throws {
            try validate(self.proposalDurationInHours, name: "proposalDurationInHours", parent: name, max: 168)
            try validate(self.proposalDurationInHours, name: "proposalDurationInHours", parent: name, min: 1)
            try validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, max: 100)
            try validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case proposalDurationInHours = "ProposalDurationInHours"
            case thresholdComparator = "ThresholdComparator"
            case thresholdPercentage = "ThresholdPercentage"
        }
    }

    public struct CreateMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// The unique identifier of the invitation that is sent to the member to join the network.
        public let invitationId: String
        /// Member configuration parameters.
        public let memberConfiguration: MemberConfiguration
        /// The unique identifier of the network in which the member is created.
        public let networkId: String

        public init(clientRequestToken: String = CreateMemberInput.idempotencyToken(), invitationId: String, memberConfiguration: MemberConfiguration, networkId: String) {
            self.clientRequestToken = clientRequestToken
            self.invitationId = invitationId
            self.memberConfiguration = memberConfiguration
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try validate(self.invitationId, name: "invitationId", parent: name, max: 32)
            try validate(self.invitationId, name: "invitationId", parent: name, min: 1)
            try self.memberConfiguration.validate(name: "\(name).memberConfiguration")
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case invitationId = "InvitationId"
            case memberConfiguration = "MemberConfiguration"
        }
    }

    public struct CreateMemberOutput: AWSDecodableShape {

        /// The unique identifier of the member.
        public let memberId: String?

        public init(memberId: String? = nil) {
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
        }
    }

    public struct CreateNetworkInput: AWSEncodableShape {

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// An optional description for the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework
        ///  Configuration properties of the blockchain framework relevant to the network configuration. 
        public let frameworkConfiguration: NetworkFrameworkConfiguration?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String
        /// Configuration properties for the first member within the network.
        public let memberConfiguration: MemberConfiguration
        /// The name of the network.
        public let name: String
        ///  The voting rules used by the network to determine if a proposal is approved. 
        public let votingPolicy: VotingPolicy

        public init(clientRequestToken: String = CreateNetworkInput.idempotencyToken(), description: String? = nil, framework: Framework, frameworkConfiguration: NetworkFrameworkConfiguration? = nil, frameworkVersion: String, memberConfiguration: MemberConfiguration, name: String, votingPolicy: VotingPolicy) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.framework = framework
            self.frameworkConfiguration = frameworkConfiguration
            self.frameworkVersion = frameworkVersion
            self.memberConfiguration = memberConfiguration
            self.name = name
            self.votingPolicy = votingPolicy
        }

        public func validate(name: String) throws {
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 128)
            try validate(self.frameworkVersion, name: "frameworkVersion", parent: name, max: 8)
            try validate(self.frameworkVersion, name: "frameworkVersion", parent: name, min: 1)
            try self.memberConfiguration.validate(name: "\(name).memberConfiguration")
            try validate(self.name, name: "name", parent: name, max: 64)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.votingPolicy.validate(name: "\(name).votingPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case framework = "Framework"
            case frameworkConfiguration = "FrameworkConfiguration"
            case frameworkVersion = "FrameworkVersion"
            case memberConfiguration = "MemberConfiguration"
            case name = "Name"
            case votingPolicy = "VotingPolicy"
        }
    }

    public struct CreateNetworkOutput: AWSDecodableShape {

        /// The unique identifier for the first member within the network.
        public let memberId: String?
        /// The unique identifier for the network.
        public let networkId: String?

        public init(memberId: String? = nil, networkId: String? = nil) {
            self.memberId = memberId
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case networkId = "NetworkId"
        }
    }

    public struct CreateNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// The unique identifier of the member that owns this node.
        public let memberId: String
        /// The unique identifier of the network in which this node runs.
        public let networkId: String
        /// The properties of a node configuration.
        public let nodeConfiguration: NodeConfiguration

        public init(clientRequestToken: String = CreateNodeInput.idempotencyToken(), memberId: String, networkId: String, nodeConfiguration: NodeConfiguration) {
            self.clientRequestToken = clientRequestToken
            self.memberId = memberId
            self.networkId = networkId
            self.nodeConfiguration = nodeConfiguration
        }

        public func validate(name: String) throws {
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case nodeConfiguration = "NodeConfiguration"
        }
    }

    public struct CreateNodeOutput: AWSDecodableShape {

        /// The unique identifier of the node.
        public let nodeId: String?

        public init(nodeId: String? = nil) {
            self.nodeId = nodeId
        }

        private enum CodingKeys: String, CodingKey {
            case nodeId = "NodeId"
        }
    }

    public struct CreateProposalInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The type of actions proposed, such as inviting a member or removing a member. The types of Actions in a proposal are mutually exclusive. For example, a proposal with Invitations actions cannot also contain Removals actions.
        public let actions: ProposalActions
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// A description for the proposal that is visible to voting members, for example, "Proposal to add Example Corp. as member."
        public let description: String?
        /// The unique identifier of the member that is creating the proposal. This identifier is especially useful for identifying the member making the proposal when multiple members exist in a single AWS account.
        public let memberId: String
        ///  The unique identifier of the network for which the proposal is made.
        public let networkId: String

        public init(actions: ProposalActions, clientRequestToken: String = CreateProposalInput.idempotencyToken(), description: String? = nil, memberId: String, networkId: String) {
            self.actions = actions
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try self.actions.validate(name: "\(name).actions")
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 128)
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case memberId = "MemberId"
        }
    }

    public struct CreateProposalOutput: AWSDecodableShape {

        /// The unique identifier of the proposal.
        public let proposalId: String?

        public init(proposalId: String? = nil) {
            self.proposalId = proposalId
        }

        private enum CodingKeys: String, CodingKey {
            case proposalId = "ProposalId"
        }
    }

    public struct DeleteMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The unique identifier of the member to remove.
        public let memberId: String
        /// The unique identifier of the network from which the member is removed.
        public let networkId: String

        public init(memberId: String, networkId: String) {
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nodeId", location: .uri(locationName: "nodeId"))
        ]

        /// The unique identifier of the member that owns this node.
        public let memberId: String
        /// The unique identifier of the network that the node belongs to.
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(memberId: String, networkId: String, nodeId: String) {
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nodeId, name: "nodeId", parent: name, max: 32)
            try validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNodeOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct GetMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The unique identifier of the member.
        public let memberId: String
        /// The unique identifier of the network to which the member belongs.
        public let networkId: String

        public init(memberId: String, networkId: String) {
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemberOutput: AWSDecodableShape {

        /// The properties of a member.
        public let member: Member?

        public init(member: Member? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct GetNetworkInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// The unique identifier of the network to get information about.
        public let networkId: String

        public init(networkId: String) {
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkOutput: AWSDecodableShape {

        /// An object containing network configuration parameters.
        public let network: Network?

        public init(network: Network? = nil) {
            self.network = network
        }

        private enum CodingKeys: String, CodingKey {
            case network = "Network"
        }
    }

    public struct GetNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nodeId", location: .uri(locationName: "nodeId"))
        ]

        /// The unique identifier of the member that owns the node.
        public let memberId: String
        /// The unique identifier of the network to which the node belongs.
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(memberId: String, networkId: String, nodeId: String) {
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nodeId, name: "nodeId", parent: name, max: 32)
            try validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNodeOutput: AWSDecodableShape {

        /// Properties of the node configuration.
        public let node: Node?

        public init(node: Node? = nil) {
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case node = "Node"
        }
    }

    public struct GetProposalInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "proposalId", location: .uri(locationName: "proposalId"))
        ]

        /// The unique identifier of the network for which the proposal is made.
        public let networkId: String
        /// The unique identifier of the proposal.
        public let proposalId: String

        public init(networkId: String, proposalId: String) {
            self.networkId = networkId
            self.proposalId = proposalId
        }

        public func validate(name: String) throws {
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.proposalId, name: "proposalId", parent: name, max: 32)
            try validate(self.proposalId, name: "proposalId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProposalOutput: AWSDecodableShape {

        /// Information about a proposal.
        public let proposal: Proposal?

        public init(proposal: Proposal? = nil) {
            self.proposal = proposal
        }

        private enum CodingKeys: String, CodingKey {
            case proposal = "Proposal"
        }
    }

    public struct Invitation: AWSDecodableShape {

        /// The date and time that the invitation was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// The date and time that the invitation expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, the invitee can no longer create a member and join the network using this InvitationId.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var expirationDate: TimeStamp?
        /// The unique identifier for the invitation.
        public let invitationId: String?
        public let networkSummary: NetworkSummary?
        /// The status of the invitation:    PENDING - The invitee has not created a member to join the network, and the invitation has not yet expired.    ACCEPTING - The invitee has begun creating a member, and creation has not yet completed.    ACCEPTED - The invitee created a member and joined the network using the InvitationID.    REJECTED - The invitee rejected the invitation.    EXPIRED - The invitee neither created a member nor rejected the invitation before the ExpirationDate.  
        public let status: InvitationStatus?

        public init(creationDate: TimeStamp? = nil, expirationDate: TimeStamp? = nil, invitationId: String? = nil, networkSummary: NetworkSummary? = nil, status: InvitationStatus? = nil) {
            self.creationDate = creationDate
            self.expirationDate = expirationDate
            self.invitationId = invitationId
            self.networkSummary = networkSummary
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case expirationDate = "ExpirationDate"
            case invitationId = "InvitationId"
            case networkSummary = "NetworkSummary"
            case status = "Status"
        }
    }

    public struct InviteAction: AWSEncodableShape & AWSDecodableShape {

        /// The AWS account ID to invite.
        public let principal: String

        public init(principal: String) {
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case principal = "Principal"
        }
    }

    public struct ListInvitationsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of invitations to return.
        public let maxResults: Int?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsOutput: AWSDecodableShape {

        /// The invitations for the network.
        public let invitations: [Invitation]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "isOwned", location: .querystring(locationName: "isOwned")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "name", location: .querystring(locationName: "name")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// An optional Boolean value. If provided, the request is limited either to members that the current AWS account owns (true) or that other AWS accounts own (false). If omitted, all members are listed.
        public let isOwned: Bool?
        /// The maximum number of members to return in the request.
        public let maxResults: Int?
        /// The optional name of the member to list.
        public let name: String?
        /// The unique identifier of the network for which to list members.
        public let networkId: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only members currently in this status are listed.
        public let status: MemberStatus?

        public init(isOwned: Bool? = nil, maxResults: Int? = nil, name: String? = nil, networkId: String, nextToken: String? = nil, status: MemberStatus? = nil) {
            self.isOwned = isOwned
            self.maxResults = maxResults
            self.name = name
            self.networkId = networkId
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersOutput: AWSDecodableShape {

        /// An array of MemberSummary objects. Each object contains details about a network member.
        public let members: [MemberSummary]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(members: [MemberSummary]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListNetworksInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "framework", location: .querystring(locationName: "framework")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "name", location: .querystring(locationName: "name")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// An optional framework specifier. If provided, only networks of this framework type are listed.
        public let framework: Framework?
        /// The maximum number of networks to list.
        public let maxResults: Int?
        /// The name of the network.
        public let name: String?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only networks currently in this status are listed.
        public let status: NetworkStatus?

        public init(framework: Framework? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, status: NetworkStatus? = nil) {
            self.framework = framework
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNetworksOutput: AWSDecodableShape {

        /// An array of NetworkSummary objects that contain configuration properties for each network.
        public let networks: [NetworkSummary]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(networks: [NetworkSummary]? = nil, nextToken: String? = nil) {
            self.networks = networks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networks = "Networks"
            case nextToken = "NextToken"
        }
    }

    public struct ListNodesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// The maximum number of nodes to list.
        public let maxResults: Int?
        /// The unique identifier of the member who owns the nodes to list.
        public let memberId: String
        /// The unique identifier of the network for which to list nodes.
        public let networkId: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only nodes currently in this status are listed.
        public let status: NodeStatus?

        public init(maxResults: Int? = nil, memberId: String, networkId: String, nextToken: String? = nil, status: NodeStatus? = nil) {
            self.maxResults = maxResults
            self.memberId = memberId
            self.networkId = networkId
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesOutput: AWSDecodableShape {

        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An array of NodeSummary objects that contain configuration properties for each node.
        public let nodes: [NodeSummary]?

        public init(nextToken: String? = nil, nodes: [NodeSummary]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case nodes = "Nodes"
        }
    }

    public struct ListProposalVotesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "proposalId", location: .uri(locationName: "proposalId"))
        ]

        ///  The maximum number of votes to return. 
        public let maxResults: Int?
        ///  The unique identifier of the network. 
        public let networkId: String
        ///  The pagination token that indicates the next set of results to retrieve. 
        public let nextToken: String?
        ///  The unique identifier of the proposal. 
        public let proposalId: String

        public init(maxResults: Int? = nil, networkId: String, nextToken: String? = nil, proposalId: String) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.proposalId = proposalId
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try validate(self.proposalId, name: "proposalId", parent: name, max: 32)
            try validate(self.proposalId, name: "proposalId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProposalVotesOutput: AWSDecodableShape {

        ///  The pagination token that indicates the next set of results to retrieve. 
        public let nextToken: String?
        ///  The listing of votes. 
        public let proposalVotes: [VoteSummary]?

        public init(nextToken: String? = nil, proposalVotes: [VoteSummary]? = nil) {
            self.nextToken = nextToken
            self.proposalVotes = proposalVotes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proposalVotes = "ProposalVotes"
        }
    }

    public struct ListProposalsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        ///  The maximum number of proposals to return. 
        public let maxResults: Int?
        ///  The unique identifier of the network. 
        public let networkId: String
        ///  The pagination token that indicates the next set of results to retrieve. 
        public let nextToken: String?

        public init(maxResults: Int? = nil, networkId: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProposalsOutput: AWSDecodableShape {

        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The summary of each proposal made on the network.
        public let proposals: [ProposalSummary]?

        public init(nextToken: String? = nil, proposals: [ProposalSummary]? = nil) {
            self.nextToken = nextToken
            self.proposals = proposals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proposals = "Proposals"
        }
    }

    public struct LogConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// Indicates whether logging is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct LogConfigurations: AWSEncodableShape & AWSDecodableShape {

        /// Parameters for publishing logs to Amazon CloudWatch Logs.
        public let cloudwatch: LogConfiguration?

        public init(cloudwatch: LogConfiguration? = nil) {
            self.cloudwatch = cloudwatch
        }

        private enum CodingKeys: String, CodingKey {
            case cloudwatch = "Cloudwatch"
        }
    }

    public struct Member: AWSDecodableShape {

        /// The date and time that the member was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// An optional description for the member.
        public let description: String?
        /// Attributes relevant to a member for the blockchain framework that the Managed Blockchain network uses.
        public let frameworkAttributes: MemberFrameworkAttributes?
        /// The unique identifier of the member.
        public let id: String?
        /// Configuration properties for logging events associated with a member.
        public let logPublishingConfiguration: MemberLogPublishingConfiguration?
        /// The name of the member.
        public let name: String?
        /// The unique identifier of the network to which the member belongs.
        public let networkId: String?
        /// The status of a member.    CREATING - The AWS account is in the process of creating a member.    AVAILABLE - The member has been created and can participate in the network.    CREATE_FAILED - The AWS account attempted to create a member and creation failed.    DELETING - The member and all associated resources are in the process of being deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    DELETED - The member can no longer participate on the network and all associated resources are deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.  
        public let status: MemberStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, frameworkAttributes: MemberFrameworkAttributes? = nil, id: String? = nil, logPublishingConfiguration: MemberLogPublishingConfiguration? = nil, name: String? = nil, networkId: String? = nil, status: MemberStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.frameworkAttributes = frameworkAttributes
            self.id = id
            self.logPublishingConfiguration = logPublishingConfiguration
            self.name = name
            self.networkId = networkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case frameworkAttributes = "FrameworkAttributes"
            case id = "Id"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case name = "Name"
            case networkId = "NetworkId"
            case status = "Status"
        }
    }

    public struct MemberConfiguration: AWSEncodableShape {

        /// An optional description of the member.
        public let description: String?
        /// Configuration properties of the blockchain framework relevant to the member.
        public let frameworkConfiguration: MemberFrameworkConfiguration
        public let logPublishingConfiguration: MemberLogPublishingConfiguration?
        /// The name of the member.
        public let name: String

        public init(description: String? = nil, frameworkConfiguration: MemberFrameworkConfiguration, logPublishingConfiguration: MemberLogPublishingConfiguration? = nil, name: String) {
            self.description = description
            self.frameworkConfiguration = frameworkConfiguration
            self.logPublishingConfiguration = logPublishingConfiguration
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.description, name: "description", parent: name, max: 128)
            try self.frameworkConfiguration.validate(name: "\(name).frameworkConfiguration")
            try validate(self.name, name: "name", parent: name, max: 64)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "^(?!-)^[^0-9](?!.*--)[A-Za-z0-9-]+[^- ]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case frameworkConfiguration = "FrameworkConfiguration"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case name = "Name"
        }
    }

    public struct MemberFabricAttributes: AWSDecodableShape {

        /// The user name for the initial administrator user for the member.
        public let adminUsername: String?
        /// The endpoint used to access the member's certificate authority.
        public let caEndpoint: String?

        public init(adminUsername: String? = nil, caEndpoint: String? = nil) {
            self.adminUsername = adminUsername
            self.caEndpoint = caEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case adminUsername = "AdminUsername"
            case caEndpoint = "CaEndpoint"
        }
    }

    public struct MemberFabricConfiguration: AWSEncodableShape {

        /// The password for the member's initial administrative user. The AdminPassword must be at least eight characters long and no more than 32 characters. It must contain at least one uppercase letter, one lowercase letter, and one digit. It cannot have a single quote(‘), double quote(“), forward slash(/), backward slash(\), @, or a space.
        public let adminPassword: String
        /// The user name for the member's initial administrative user.
        public let adminUsername: String

        public init(adminPassword: String, adminUsername: String) {
            self.adminPassword = adminPassword
            self.adminUsername = adminUsername
        }

        public func validate(name: String) throws {
            try validate(self.adminPassword, name: "adminPassword", parent: name, max: 32)
            try validate(self.adminPassword, name: "adminPassword", parent: name, min: 8)
            try validate(self.adminPassword, name: "adminPassword", parent: name, pattern: "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?!.*[@'\\\\\"/])[a-zA-Z0-9\\S]*$")
            try validate(self.adminUsername, name: "adminUsername", parent: name, max: 16)
            try validate(self.adminUsername, name: "adminUsername", parent: name, min: 1)
            try validate(self.adminUsername, name: "adminUsername", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminPassword = "AdminPassword"
            case adminUsername = "AdminUsername"
        }
    }

    public struct MemberFabricLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// Configuration properties for logging events associated with a member's Certificate Authority (CA). CA logs help you determine when a member in your account joins the network, or when new peers register with a member CA.
        public let caLogs: LogConfigurations?

        public init(caLogs: LogConfigurations? = nil) {
            self.caLogs = caLogs
        }

        private enum CodingKeys: String, CodingKey {
            case caLogs = "CaLogs"
        }
    }

    public struct MemberFrameworkAttributes: AWSDecodableShape {

        /// Attributes of Hyperledger Fabric relevant to a member on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: MemberFabricAttributes?

        public init(fabric: MemberFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberFrameworkConfiguration: AWSEncodableShape {

        /// Attributes of Hyperledger Fabric for a member on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: MemberFabricConfiguration?

        public init(fabric: MemberFabricConfiguration? = nil) {
            self.fabric = fabric
        }

        public func validate(name: String) throws {
            try self.fabric?.validate(name: "\(name).fabric")
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// Configuration properties for logging events associated with a member of a Managed Blockchain network using the Hyperledger Fabric framework.
        public let fabric: MemberFabricLogPublishingConfiguration?

        public init(fabric: MemberFabricLogPublishingConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberSummary: AWSDecodableShape {

        /// The date and time that the member was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// An optional description of the member.
        public let description: String?
        /// The unique identifier of the member.
        public let id: String?
        /// An indicator of whether the member is owned by your AWS account or a different AWS account.
        public let isOwned: Bool?
        /// The name of the member.
        public let name: String?
        /// The status of the member.    CREATING - The AWS account is in the process of creating a member.    AVAILABLE - The member has been created and can participate in the network.    CREATE_FAILED - The AWS account attempted to create a member and creation failed.    DELETING - The member and all associated resources are in the process of being deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    DELETED - The member can no longer participate on the network and all associated resources are deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.  
        public let status: MemberStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, id: String? = nil, isOwned: Bool? = nil, name: String? = nil, status: MemberStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.isOwned = isOwned
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case id = "Id"
            case isOwned = "IsOwned"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct Network: AWSDecodableShape {

        /// The date and time that the network was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// Attributes of the blockchain framework for the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework?
        /// Attributes of the blockchain framework that the network uses.
        public let frameworkAttributes: NetworkFrameworkAttributes?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String?
        /// The unique identifier of the network.
        public let id: String?
        /// The name of the network.
        public let name: String?
        /// The current status of the network.
        public let status: NetworkStatus?
        /// The voting rules for the network to decide if a proposal is accepted.
        public let votingPolicy: VotingPolicy?
        /// The VPC endpoint service name of the VPC endpoint service of the network. Members use the VPC endpoint service name to create a VPC endpoint to access network resources.
        public let vpcEndpointServiceName: String?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, framework: Framework? = nil, frameworkAttributes: NetworkFrameworkAttributes? = nil, frameworkVersion: String? = nil, id: String? = nil, name: String? = nil, status: NetworkStatus? = nil, votingPolicy: VotingPolicy? = nil, vpcEndpointServiceName: String? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.framework = framework
            self.frameworkAttributes = frameworkAttributes
            self.frameworkVersion = frameworkVersion
            self.id = id
            self.name = name
            self.status = status
            self.votingPolicy = votingPolicy
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case framework = "Framework"
            case frameworkAttributes = "FrameworkAttributes"
            case frameworkVersion = "FrameworkVersion"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case votingPolicy = "VotingPolicy"
            case vpcEndpointServiceName = "VpcEndpointServiceName"
        }
    }

    public struct NetworkFabricAttributes: AWSDecodableShape {

        /// The edition of Amazon Managed Blockchain that Hyperledger Fabric uses. For more information, see Amazon Managed Blockchain Pricing.
        public let edition: Edition?
        /// The endpoint of the ordering service for the network.
        public let orderingServiceEndpoint: String?

        public init(edition: Edition? = nil, orderingServiceEndpoint: String? = nil) {
            self.edition = edition
            self.orderingServiceEndpoint = orderingServiceEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
            case orderingServiceEndpoint = "OrderingServiceEndpoint"
        }
    }

    public struct NetworkFabricConfiguration: AWSEncodableShape {

        /// The edition of Amazon Managed Blockchain that the network uses. For more information, see Amazon Managed Blockchain Pricing.
        public let edition: Edition

        public init(edition: Edition) {
            self.edition = edition
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
        }
    }

    public struct NetworkFrameworkAttributes: AWSDecodableShape {

        /// Attributes of Hyperledger Fabric for a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NetworkFabricAttributes?

        public init(fabric: NetworkFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NetworkFrameworkConfiguration: AWSEncodableShape {

        ///  Hyperledger Fabric configuration properties for a Managed Blockchain network that uses Hyperledger Fabric. 
        public let fabric: NetworkFabricConfiguration?

        public init(fabric: NetworkFabricConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NetworkSummary: AWSDecodableShape {

        /// The date and time that the network was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// An optional description of the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String?
        /// The unique identifier of the network.
        public let id: String?
        /// The name of the network.
        public let name: String?
        /// The current status of the network.
        public let status: NetworkStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, framework: Framework? = nil, frameworkVersion: String? = nil, id: String? = nil, name: String? = nil, status: NetworkStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case id = "Id"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct Node: AWSDecodableShape {

        /// The Availability Zone in which the node exists.
        public let availabilityZone: String?
        /// The date and time that the node was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// Attributes of the blockchain framework being used.
        public let frameworkAttributes: NodeFrameworkAttributes?
        /// The unique identifier of the node.
        public let id: String?
        /// The instance type of the node.
        public let instanceType: String?
        public let logPublishingConfiguration: NodeLogPublishingConfiguration?
        /// The unique identifier of the member to which the node belongs.
        public let memberId: String?
        /// The unique identifier of the network that the node is in.
        public let networkId: String?
        /// The status of the node.
        public let status: NodeStatus?

        public init(availabilityZone: String? = nil, creationDate: TimeStamp? = nil, frameworkAttributes: NodeFrameworkAttributes? = nil, id: String? = nil, instanceType: String? = nil, logPublishingConfiguration: NodeLogPublishingConfiguration? = nil, memberId: String? = nil, networkId: String? = nil, status: NodeStatus? = nil) {
            self.availabilityZone = availabilityZone
            self.creationDate = creationDate
            self.frameworkAttributes = frameworkAttributes
            self.id = id
            self.instanceType = instanceType
            self.logPublishingConfiguration = logPublishingConfiguration
            self.memberId = memberId
            self.networkId = networkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case creationDate = "CreationDate"
            case frameworkAttributes = "FrameworkAttributes"
            case id = "Id"
            case instanceType = "InstanceType"
            case logPublishingConfiguration = "LogPublishingConfiguration"
            case memberId = "MemberId"
            case networkId = "NetworkId"
            case status = "Status"
        }
    }

    public struct NodeConfiguration: AWSEncodableShape {

        /// The Availability Zone in which the node exists.
        public let availabilityZone: String
        /// The Amazon Managed Blockchain instance type for the node.
        public let instanceType: String
        public let logPublishingConfiguration: NodeLogPublishingConfiguration?

        public init(availabilityZone: String, instanceType: String, logPublishingConfiguration: NodeLogPublishingConfiguration? = nil) {
            self.availabilityZone = availabilityZone
            self.instanceType = instanceType
            self.logPublishingConfiguration = logPublishingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case instanceType = "InstanceType"
            case logPublishingConfiguration = "LogPublishingConfiguration"
        }
    }

    public struct NodeFabricAttributes: AWSDecodableShape {

        /// The endpoint that identifies the peer node for all services except peer channel-based event services.
        public let peerEndpoint: String?
        /// The endpoint that identifies the peer node for peer channel-based event services.
        public let peerEventEndpoint: String?

        public init(peerEndpoint: String? = nil, peerEventEndpoint: String? = nil) {
            self.peerEndpoint = peerEndpoint
            self.peerEventEndpoint = peerEventEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case peerEndpoint = "PeerEndpoint"
            case peerEventEndpoint = "PeerEventEndpoint"
        }
    }

    public struct NodeFabricLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// Configuration properties for logging events associated with chaincode execution on a peer node. Chaincode logs contain the results of instantiating, invoking, and querying the chaincode. A peer can run multiple instances of chaincode. When enabled, a log stream is created for all chaincodes, with an individual log stream for each chaincode.
        public let chaincodeLogs: LogConfigurations?
        /// Configuration properties for a peer node log. Peer node logs contain messages generated when your client submits transaction proposals to peer nodes, requests to join channels, enrolls an admin peer, and lists the chaincode instances on a peer node. 
        public let peerLogs: LogConfigurations?

        public init(chaincodeLogs: LogConfigurations? = nil, peerLogs: LogConfigurations? = nil) {
            self.chaincodeLogs = chaincodeLogs
            self.peerLogs = peerLogs
        }

        private enum CodingKeys: String, CodingKey {
            case chaincodeLogs = "ChaincodeLogs"
            case peerLogs = "PeerLogs"
        }
    }

    public struct NodeFrameworkAttributes: AWSDecodableShape {

        /// Attributes of Hyperledger Fabric for a peer node on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NodeFabricAttributes?

        public init(fabric: NodeFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NodeLogPublishingConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// Configuration properties for logging events associated with a node that is owned by a member of a Managed Blockchain network using the Hyperledger Fabric framework.
        public let fabric: NodeFabricLogPublishingConfiguration?

        public init(fabric: NodeFabricLogPublishingConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NodeSummary: AWSDecodableShape {

        /// The Availability Zone in which the node exists.
        public let availabilityZone: String?
        /// The date and time that the node was created.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// The unique identifier of the node.
        public let id: String?
        /// The EC2 instance type for the node.
        public let instanceType: String?
        /// The status of the node.
        public let status: NodeStatus?

        public init(availabilityZone: String? = nil, creationDate: TimeStamp? = nil, id: String? = nil, instanceType: String? = nil, status: NodeStatus? = nil) {
            self.availabilityZone = availabilityZone
            self.creationDate = creationDate
            self.id = id
            self.instanceType = instanceType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case creationDate = "CreationDate"
            case id = "Id"
            case instanceType = "InstanceType"
            case status = "Status"
        }
    }

    public struct Proposal: AWSDecodableShape {

        /// The actions to perform on the network if the proposal is APPROVED.
        public let actions: ProposalActions?
        ///  The date and time that the proposal was created. 
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        /// The description of the proposal.
        public let description: String?
        ///  The date and time that the proposal expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, if members have not cast enough votes to determine the outcome according to the voting policy, the proposal is EXPIRED and Actions are not carried out. 
        @OptionalCoding<ISO8601TimeStampCoder>
        public var expirationDate: TimeStamp?
        /// The unique identifier of the network for which the proposal is made.
        public let networkId: String?
        ///  The current total of NO votes cast on the proposal by members. 
        public let noVoteCount: Int?
        ///  The number of votes remaining to be cast on the proposal by members. In other words, the number of members minus the sum of YES votes and NO votes. 
        public let outstandingVoteCount: Int?
        /// The unique identifier of the proposal.
        public let proposalId: String?
        /// The unique identifier of the member that created the proposal.
        public let proposedByMemberId: String?
        /// The name of the member that created the proposal.
        public let proposedByMemberName: String?
        /// The status of the proposal. Values are as follows:    IN_PROGRESS - The proposal is active and open for member voting.    APPROVED - The proposal was approved with sufficient YES votes among members according to the VotingPolicy specified for the Network. The specified proposal actions are carried out.    REJECTED - The proposal was rejected with insufficient YES votes among members according to the VotingPolicy specified for the Network. The specified ProposalActions are not carried out.    EXPIRED - Members did not cast the number of votes required to determine the proposal outcome before the proposal expired. The specified ProposalActions are not carried out.    ACTION_FAILED - One or more of the specified ProposalActions in a proposal that was approved could not be completed because of an error. The ACTION_FAILED status occurs even if only one ProposalAction fails and other actions are successful.  
        public let status: ProposalStatus?
        ///  The current total of YES votes cast on the proposal by members. 
        public let yesVoteCount: Int?

        public init(actions: ProposalActions? = nil, creationDate: TimeStamp? = nil, description: String? = nil, expirationDate: TimeStamp? = nil, networkId: String? = nil, noVoteCount: Int? = nil, outstandingVoteCount: Int? = nil, proposalId: String? = nil, proposedByMemberId: String? = nil, proposedByMemberName: String? = nil, status: ProposalStatus? = nil, yesVoteCount: Int? = nil) {
            self.actions = actions
            self.creationDate = creationDate
            self.description = description
            self.expirationDate = expirationDate
            self.networkId = networkId
            self.noVoteCount = noVoteCount
            self.outstandingVoteCount = outstandingVoteCount
            self.proposalId = proposalId
            self.proposedByMemberId = proposedByMemberId
            self.proposedByMemberName = proposedByMemberName
            self.status = status
            self.yesVoteCount = yesVoteCount
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case creationDate = "CreationDate"
            case description = "Description"
            case expirationDate = "ExpirationDate"
            case networkId = "NetworkId"
            case noVoteCount = "NoVoteCount"
            case outstandingVoteCount = "OutstandingVoteCount"
            case proposalId = "ProposalId"
            case proposedByMemberId = "ProposedByMemberId"
            case proposedByMemberName = "ProposedByMemberName"
            case status = "Status"
            case yesVoteCount = "YesVoteCount"
        }
    }

    public struct ProposalActions: AWSEncodableShape & AWSDecodableShape {

        ///  The actions to perform for an APPROVED proposal to invite an AWS account to create a member and join the network. 
        public let invitations: [InviteAction]?
        ///  The actions to perform for an APPROVED proposal to remove a member from the network, which deletes the member and all associated member resources from the network. 
        public let removals: [RemoveAction]?

        public init(invitations: [InviteAction]? = nil, removals: [RemoveAction]? = nil) {
            self.invitations = invitations
            self.removals = removals
        }

        public func validate(name: String) throws {
            try self.removals?.forEach {
                try $0.validate(name: "\(name).removals[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case removals = "Removals"
        }
    }

    public struct ProposalSummary: AWSDecodableShape {

        ///  The date and time that the proposal was created. 
        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        ///  The description of the proposal. 
        public let description: String?
        ///  The date and time that the proposal expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, if members have not cast enough votes to determine the outcome according to the voting policy, the proposal is EXPIRED and Actions are not carried out. 
        @OptionalCoding<ISO8601TimeStampCoder>
        public var expirationDate: TimeStamp?
        ///  The unique identifier of the proposal. 
        public let proposalId: String?
        ///  The unique identifier of the member that created the proposal. 
        public let proposedByMemberId: String?
        ///  The name of the member that created the proposal. 
        public let proposedByMemberName: String?
        /// The status of the proposal. Values are as follows:    IN_PROGRESS - The proposal is active and open for member voting.    APPROVED - The proposal was approved with sufficient YES votes among members according to the VotingPolicy specified for the Network. The specified proposal actions are carried out.    REJECTED - The proposal was rejected with insufficient YES votes among members according to the VotingPolicy specified for the Network. The specified ProposalActions are not carried out.    EXPIRED - Members did not cast the number of votes required to determine the proposal outcome before the proposal expired. The specified ProposalActions are not carried out.    ACTION_FAILED - One or more of the specified ProposalActions in a proposal that was approved could not be completed because of an error.  
        public let status: ProposalStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, expirationDate: TimeStamp? = nil, proposalId: String? = nil, proposedByMemberId: String? = nil, proposedByMemberName: String? = nil, status: ProposalStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.expirationDate = expirationDate
            self.proposalId = proposalId
            self.proposedByMemberId = proposedByMemberId
            self.proposedByMemberName = proposedByMemberName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case expirationDate = "ExpirationDate"
            case proposalId = "ProposalId"
            case proposedByMemberId = "ProposedByMemberId"
            case proposedByMemberName = "ProposedByMemberName"
            case status = "Status"
        }
    }

    public struct RejectInvitationInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "invitationId", location: .uri(locationName: "invitationId"))
        ]

        /// The unique identifier of the invitation to reject.
        public let invitationId: String

        public init(invitationId: String) {
            self.invitationId = invitationId
        }

        public func validate(name: String) throws {
            try validate(self.invitationId, name: "invitationId", parent: name, max: 32)
            try validate(self.invitationId, name: "invitationId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectInvitationOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct RemoveAction: AWSEncodableShape & AWSDecodableShape {

        /// The unique identifier of the member to remove.
        public let memberId: String

        public init(memberId: String) {
            self.memberId = memberId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
        }
    }

    public struct UpdateMemberInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId"))
        ]

        /// Configuration properties for publishing to Amazon CloudWatch Logs.
        public let logPublishingConfiguration: MemberLogPublishingConfiguration?
        /// The unique ID of the member.
        public let memberId: String
        /// The unique ID of the Managed Blockchain network to which the member belongs.
        public let networkId: String

        public init(logPublishingConfiguration: MemberLogPublishingConfiguration? = nil, memberId: String, networkId: String) {
            self.logPublishingConfiguration = logPublishingConfiguration
            self.memberId = memberId
            self.networkId = networkId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case logPublishingConfiguration = "LogPublishingConfiguration"
        }
    }

    public struct UpdateMemberOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "memberId")), 
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "nodeId", location: .uri(locationName: "nodeId"))
        ]

        /// Configuration properties for publishing to Amazon CloudWatch Logs.
        public let logPublishingConfiguration: NodeLogPublishingConfiguration?
        /// The unique ID of the member that owns the node.
        public let memberId: String
        /// The unique ID of the Managed Blockchain network to which the node belongs.
        public let networkId: String
        /// The unique ID of the node.
        public let nodeId: String

        public init(logPublishingConfiguration: NodeLogPublishingConfiguration? = nil, memberId: String, networkId: String, nodeId: String) {
            self.logPublishingConfiguration = logPublishingConfiguration
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        public func validate(name: String) throws {
            try validate(self.memberId, name: "memberId", parent: name, max: 32)
            try validate(self.memberId, name: "memberId", parent: name, min: 1)
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.nodeId, name: "nodeId", parent: name, max: 32)
            try validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case logPublishingConfiguration = "LogPublishingConfiguration"
        }
    }

    public struct UpdateNodeOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct VoteOnProposalInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "networkId", location: .uri(locationName: "networkId")), 
            AWSMemberEncoding(label: "proposalId", location: .uri(locationName: "proposalId"))
        ]

        ///  The unique identifier of the network. 
        public let networkId: String
        ///  The unique identifier of the proposal. 
        public let proposalId: String
        ///  The value of the vote. 
        public let vote: VoteValue
        /// The unique identifier of the member casting the vote. 
        public let voterMemberId: String

        public init(networkId: String, proposalId: String, vote: VoteValue, voterMemberId: String) {
            self.networkId = networkId
            self.proposalId = proposalId
            self.vote = vote
            self.voterMemberId = voterMemberId
        }

        public func validate(name: String) throws {
            try validate(self.networkId, name: "networkId", parent: name, max: 32)
            try validate(self.networkId, name: "networkId", parent: name, min: 1)
            try validate(self.proposalId, name: "proposalId", parent: name, max: 32)
            try validate(self.proposalId, name: "proposalId", parent: name, min: 1)
            try validate(self.voterMemberId, name: "voterMemberId", parent: name, max: 32)
            try validate(self.voterMemberId, name: "voterMemberId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vote = "Vote"
            case voterMemberId = "VoterMemberId"
        }
    }

    public struct VoteOnProposalOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct VoteSummary: AWSDecodableShape {

        ///  The unique identifier of the member that cast the vote. 
        public let memberId: String?
        ///  The name of the member that cast the vote. 
        public let memberName: String?
        ///  The vote value, either YES or NO. 
        public let vote: VoteValue?

        public init(memberId: String? = nil, memberName: String? = nil, vote: VoteValue? = nil) {
            self.memberId = memberId
            self.memberName = memberName
            self.vote = vote
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case memberName = "MemberName"
            case vote = "Vote"
        }
    }

    public struct VotingPolicy: AWSEncodableShape & AWSDecodableShape {

        /// Defines the rules for the network for voting on proposals, such as the percentage of YES votes required for the proposal to be approved and the duration of the proposal. The policy applies to all proposals and is specified when the network is created.
        public let approvalThresholdPolicy: ApprovalThresholdPolicy?

        public init(approvalThresholdPolicy: ApprovalThresholdPolicy? = nil) {
            self.approvalThresholdPolicy = approvalThresholdPolicy
        }

        public func validate(name: String) throws {
            try self.approvalThresholdPolicy?.validate(name: "\(name).approvalThresholdPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case approvalThresholdPolicy = "ApprovalThresholdPolicy"
        }
    }
}
