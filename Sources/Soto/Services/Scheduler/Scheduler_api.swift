//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Scheduler service.
///
///  Amazon EventBridge Scheduler is a serverless scheduler that allows you to create, run, and manage tasks from one central, managed service. EventBridge Scheduler delivers your tasks reliably, with built-in mechanisms that adjust your schedules based on the availability of downstream targets. The following reference lists the available API actions, and data types for EventBridge Scheduler.
public struct Scheduler: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Scheduler client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Scheduler",
            serviceIdentifier: "scheduler",
            serviceProtocol: .restjson,
            apiVersion: "2021-06-30",
            endpoint: endpoint,
            errorType: SchedulerErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates the specified schedule.
    @Sendable
    @inlinable
    public func createSchedule(_ input: CreateScheduleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScheduleOutput {
        try await self.client.execute(
            operation: "CreateSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates the specified schedule.
    ///
    /// Parameters:
    ///   - actionAfterCompletion: Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
    ///   - clientToken:  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    ///   - description: The description you specify for the schedule.
    ///   - endDate: The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
    ///   - flexibleTimeWindow: Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
    ///   - groupName: The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.
    ///   - kmsKeyArn: The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
    ///   - name: The name of the schedule that you are creating.
    ///   - scheduleExpression:  The expression that defines when the schedule runs. The following formats are supported.
    ///   - scheduleExpressionTimezone: The timezone in which the scheduling expression is evaluated.
    ///   - startDate: The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
    ///   - state: Specifies whether the schedule is enabled or disabled.
    ///   - target: The schedule's target.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSchedule(
        actionAfterCompletion: ActionAfterCompletion? = nil,
        clientToken: String? = CreateScheduleInput.idempotencyToken(),
        description: String? = nil,
        endDate: Date? = nil,
        flexibleTimeWindow: FlexibleTimeWindow,
        groupName: String? = nil,
        kmsKeyArn: String? = nil,
        name: String,
        scheduleExpression: String,
        scheduleExpressionTimezone: String? = nil,
        startDate: Date? = nil,
        state: ScheduleState? = nil,
        target: Target,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScheduleOutput {
        let input = CreateScheduleInput(
            actionAfterCompletion: actionAfterCompletion, 
            clientToken: clientToken, 
            description: description, 
            endDate: endDate, 
            flexibleTimeWindow: flexibleTimeWindow, 
            groupName: groupName, 
            kmsKeyArn: kmsKeyArn, 
            name: name, 
            scheduleExpression: scheduleExpression, 
            scheduleExpressionTimezone: scheduleExpressionTimezone, 
            startDate: startDate, 
            state: state, 
            target: target
        )
        return try await self.createSchedule(input, logger: logger)
    }

    /// Creates the specified schedule group.
    @Sendable
    @inlinable
    public func createScheduleGroup(_ input: CreateScheduleGroupInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScheduleGroupOutput {
        try await self.client.execute(
            operation: "CreateScheduleGroup", 
            path: "/schedule-groups/{Name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates the specified schedule group.
    ///
    /// Parameters:
    ///   - clientToken:  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    ///   - name: The name of the schedule group that you are creating.
    ///   - tags: The list of tags to associate with the schedule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func createScheduleGroup(
        clientToken: String? = CreateScheduleGroupInput.idempotencyToken(),
        name: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScheduleGroupOutput {
        let input = CreateScheduleGroupInput(
            clientToken: clientToken, 
            name: name, 
            tags: tags
        )
        return try await self.createScheduleGroup(input, logger: logger)
    }

    /// Deletes the specified schedule.
    @Sendable
    @inlinable
    public func deleteSchedule(_ input: DeleteScheduleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteScheduleOutput {
        try await self.client.execute(
            operation: "DeleteSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified schedule.
    ///
    /// Parameters:
    ///   - clientToken:  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    ///   - groupName: The name of the schedule group associated with this schedule. If you omit this, the default schedule group is used.
    ///   - name: The name of the schedule to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSchedule(
        clientToken: String? = DeleteScheduleInput.idempotencyToken(),
        groupName: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteScheduleOutput {
        let input = DeleteScheduleInput(
            clientToken: clientToken, 
            groupName: groupName, 
            name: name
        )
        return try await self.deleteSchedule(input, logger: logger)
    }

    /// Deletes the specified schedule group. Deleting a schedule group results in EventBridge Scheduler deleting all schedules associated with the group. When you delete a group, it remains in a DELETING state until all of its associated schedules are deleted. Schedules associated with the group that are set to run while the schedule group is in the process of being deleted might continue to invoke their targets until the schedule group and its associated schedules are deleted.   This operation is eventually consistent.
    @Sendable
    @inlinable
    public func deleteScheduleGroup(_ input: DeleteScheduleGroupInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteScheduleGroupOutput {
        try await self.client.execute(
            operation: "DeleteScheduleGroup", 
            path: "/schedule-groups/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified schedule group. Deleting a schedule group results in EventBridge Scheduler deleting all schedules associated with the group. When you delete a group, it remains in a DELETING state until all of its associated schedules are deleted. Schedules associated with the group that are set to run while the schedule group is in the process of being deleted might continue to invoke their targets until the schedule group and its associated schedules are deleted.   This operation is eventually consistent.
    ///
    /// Parameters:
    ///   - clientToken:  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    ///   - name: The name of the schedule group to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteScheduleGroup(
        clientToken: String? = DeleteScheduleGroupInput.idempotencyToken(),
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteScheduleGroupOutput {
        let input = DeleteScheduleGroupInput(
            clientToken: clientToken, 
            name: name
        )
        return try await self.deleteScheduleGroup(input, logger: logger)
    }

    /// Retrieves the specified schedule.
    @Sendable
    @inlinable
    public func getSchedule(_ input: GetScheduleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetScheduleOutput {
        try await self.client.execute(
            operation: "GetSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified schedule.
    ///
    /// Parameters:
    ///   - groupName: The name of the schedule group associated with this schedule. If you omit this, EventBridge Scheduler assumes that the schedule is associated with the default group.
    ///   - name: The name of the schedule to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchedule(
        groupName: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetScheduleOutput {
        let input = GetScheduleInput(
            groupName: groupName, 
            name: name
        )
        return try await self.getSchedule(input, logger: logger)
    }

    /// Retrieves the specified schedule group.
    @Sendable
    @inlinable
    public func getScheduleGroup(_ input: GetScheduleGroupInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetScheduleGroupOutput {
        try await self.client.execute(
            operation: "GetScheduleGroup", 
            path: "/schedule-groups/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified schedule group.
    ///
    /// Parameters:
    ///   - name: The name of the schedule group to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getScheduleGroup(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetScheduleGroupOutput {
        let input = GetScheduleGroupInput(
            name: name
        )
        return try await self.getScheduleGroup(input, logger: logger)
    }

    /// Returns a paginated list of your schedule groups.
    @Sendable
    @inlinable
    public func listScheduleGroups(_ input: ListScheduleGroupsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListScheduleGroupsOutput {
        try await self.client.execute(
            operation: "ListScheduleGroups", 
            path: "/schedule-groups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of your schedule groups.
    ///
    /// Parameters:
    ///   - maxResults: If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    ///   - namePrefix: The name prefix that you can use to return a filtered list of your schedule groups.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listScheduleGroups(
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListScheduleGroupsOutput {
        let input = ListScheduleGroupsInput(
            maxResults: maxResults, 
            namePrefix: namePrefix, 
            nextToken: nextToken
        )
        return try await self.listScheduleGroups(input, logger: logger)
    }

    /// Returns a paginated list of your EventBridge Scheduler schedules.
    @Sendable
    @inlinable
    public func listSchedules(_ input: ListSchedulesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSchedulesOutput {
        try await self.client.execute(
            operation: "ListSchedules", 
            path: "/schedules", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of your EventBridge Scheduler schedules.
    ///
    /// Parameters:
    ///   - groupName: If specified, only lists the schedules whose associated schedule group matches the given filter.
    ///   - maxResults: If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    ///   - namePrefix: Schedule name prefix to return the filtered list of resources.
    ///   - nextToken: The token returned by a previous call to retrieve the next set of results.
    ///   - state: If specified, only lists the schedules whose current state matches the given filter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSchedules(
        groupName: String? = nil,
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil,
        state: ScheduleState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSchedulesOutput {
        let input = ListSchedulesInput(
            groupName: groupName, 
            maxResults: maxResults, 
            namePrefix: namePrefix, 
            nextToken: nextToken, 
            state: state
        )
        return try await self.listSchedules(input, logger: logger)
    }

    /// Lists the tags associated with the Scheduler resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags associated with the Scheduler resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the EventBridge Scheduler resource for which you want to view tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Assigns one or more tags (key-value pairs) to the specified EventBridge Scheduler resource. You can only assign tags to schedule groups.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceOutput {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Assigns one or more tags (key-value pairs) to the specified EventBridge Scheduler resource. You can only assign tags to schedule groups.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the schedule group that you are adding tags to.
    ///   - tags: The list of tags to associate with the schedule group.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceOutput {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes one or more tags from the specified EventBridge Scheduler schedule group.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceOutput {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes one or more tags from the specified EventBridge Scheduler schedule group.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the schedule group from which you are removing tags.
    ///   - tagKeys: The list of tag keys to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceOutput {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    ///  Updates the specified schedule. When you call UpdateSchedule, EventBridge Scheduler uses all values, including empty values, specified in the request and overrides the existing schedule. This is by design. This means that if you do not set an optional field in your request, that field will be set to its system-default value after the update.   Before calling this operation, we recommend that you call the GetSchedule API operation and make a note of all optional parameters for your UpdateSchedule call.
    @Sendable
    @inlinable
    public func updateSchedule(_ input: UpdateScheduleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateScheduleOutput {
        try await self.client.execute(
            operation: "UpdateSchedule", 
            path: "/schedules/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates the specified schedule. When you call UpdateSchedule, EventBridge Scheduler uses all values, including empty values, specified in the request and overrides the existing schedule. This is by design. This means that if you do not set an optional field in your request, that field will be set to its system-default value after the update.   Before calling this operation, we recommend that you call the GetSchedule API operation and make a note of all optional parameters for your UpdateSchedule call.
    ///
    /// Parameters:
    ///   - actionAfterCompletion: Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
    ///   - clientToken:  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    ///   - description: The description you specify for the schedule.
    ///   - endDate: The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
    ///   - flexibleTimeWindow: Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
    ///   - groupName: The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.
    ///   - kmsKeyArn: The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.
    ///   - name: The name of the schedule that you are updating.
    ///   - scheduleExpression:  The expression that defines when the schedule runs. The following formats are supported.
    ///   - scheduleExpressionTimezone: The timezone in which the scheduling expression is evaluated.
    ///   - startDate: The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
    ///   - state: Specifies whether the schedule is enabled or disabled.
    ///   - target: The schedule target. You can use this operation to change the target that your schedule invokes.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSchedule(
        actionAfterCompletion: ActionAfterCompletion? = nil,
        clientToken: String? = UpdateScheduleInput.idempotencyToken(),
        description: String? = nil,
        endDate: Date? = nil,
        flexibleTimeWindow: FlexibleTimeWindow,
        groupName: String? = nil,
        kmsKeyArn: String? = nil,
        name: String,
        scheduleExpression: String,
        scheduleExpressionTimezone: String? = nil,
        startDate: Date? = nil,
        state: ScheduleState? = nil,
        target: Target,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateScheduleOutput {
        let input = UpdateScheduleInput(
            actionAfterCompletion: actionAfterCompletion, 
            clientToken: clientToken, 
            description: description, 
            endDate: endDate, 
            flexibleTimeWindow: flexibleTimeWindow, 
            groupName: groupName, 
            kmsKeyArn: kmsKeyArn, 
            name: name, 
            scheduleExpression: scheduleExpression, 
            scheduleExpressionTimezone: scheduleExpressionTimezone, 
            startDate: startDate, 
            state: state, 
            target: target
        )
        return try await self.updateSchedule(input, logger: logger)
    }
}

extension Scheduler {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Scheduler, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Scheduler {
    /// Return PaginatorSequence for operation ``listScheduleGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listScheduleGroupsPaginator(
        _ input: ListScheduleGroupsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListScheduleGroupsInput, ListScheduleGroupsOutput> {
        return .init(
            input: input,
            command: self.listScheduleGroups,
            inputKey: \ListScheduleGroupsInput.nextToken,
            outputKey: \ListScheduleGroupsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listScheduleGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    ///   - namePrefix: The name prefix that you can use to return a filtered list of your schedule groups.
    ///   - logger: Logger used for logging
    @inlinable
    public func listScheduleGroupsPaginator(
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListScheduleGroupsInput, ListScheduleGroupsOutput> {
        let input = ListScheduleGroupsInput(
            maxResults: maxResults, 
            namePrefix: namePrefix
        )
        return self.listScheduleGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSchedules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchedulesPaginator(
        _ input: ListSchedulesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSchedulesInput, ListSchedulesOutput> {
        return .init(
            input: input,
            command: self.listSchedules,
            inputKey: \ListSchedulesInput.nextToken,
            outputKey: \ListSchedulesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSchedules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - groupName: If specified, only lists the schedules whose associated schedule group matches the given filter.
    ///   - maxResults: If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    ///   - namePrefix: Schedule name prefix to return the filtered list of resources.
    ///   - state: If specified, only lists the schedules whose current state matches the given filter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchedulesPaginator(
        groupName: String? = nil,
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        state: ScheduleState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSchedulesInput, ListSchedulesOutput> {
        let input = ListSchedulesInput(
            groupName: groupName, 
            maxResults: maxResults, 
            namePrefix: namePrefix, 
            state: state
        )
        return self.listSchedulesPaginator(input, logger: logger)
    }
}

extension Scheduler.ListScheduleGroupsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Scheduler.ListScheduleGroupsInput {
        return .init(
            maxResults: self.maxResults,
            namePrefix: self.namePrefix,
            nextToken: token
        )
    }
}

extension Scheduler.ListSchedulesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Scheduler.ListSchedulesInput {
        return .init(
            groupName: self.groupName,
            maxResults: self.maxResults,
            namePrefix: self.namePrefix,
            nextToken: token,
            state: self.state
        )
    }
}
