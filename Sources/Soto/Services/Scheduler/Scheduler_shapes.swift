//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Scheduler {
    // MARK: Enums

    public enum ActionAfterCompletion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AssignPublicIp: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum FlexibleTimeWindowMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flexible = "FLEXIBLE"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum LaunchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2 = "EC2"
        case external = "EXTERNAL"
        case fargate = "FARGATE"
        public var description: String { return self.rawValue }
    }

    public enum PlacementConstraintType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case distinctInstance = "distinctInstance"
        case memberOf = "memberOf"
        public var description: String { return self.rawValue }
    }

    public enum PlacementStrategyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binpack = "binpack"
        case random = "random"
        case spread = "spread"
        public var description: String { return self.rawValue }
    }

    public enum PropagateTags: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case taskDefinition = "TASK_DEFINITION"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleGroupState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AwsVpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE.
        public let assignPublicIp: AssignPublicIp?
        /// Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        public let securityGroups: [String]?
        /// Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        public let subnets: [String]

        public init(assignPublicIp: AssignPublicIp? = nil, securityGroups: [String]? = nil, subnets: [String]) {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, max: 1000)
                try validate($0, name: "securityGroups[]", parent: name, min: 1)
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 5)
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, max: 1000)
                try validate($0, name: "subnets[]", parent: name, min: 1)
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assignPublicIp = "AssignPublicIp"
            case securityGroups = "SecurityGroups"
            case subnets = "Subnets"
        }
    }

    public struct CapacityProviderStrategyItem: AWSEncodableShape & AWSDecodableShape {
        /// The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.
        public let base: Int?
        /// The short name of the capacity provider.
        public let capacityProvider: String
        /// The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
        public let weight: Int?

        public init(base: Int? = nil, capacityProvider: String, weight: Int? = nil) {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.base, name: "base", parent: name, max: 100000)
            try self.validate(self.base, name: "base", parent: name, min: 0)
            try self.validate(self.capacityProvider, name: "capacityProvider", parent: name, max: 255)
            try self.validate(self.capacityProvider, name: "capacityProvider", parent: name, min: 1)
            try self.validate(self.weight, name: "weight", parent: name, max: 1000)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case base = "base"
            case capacityProvider = "capacityProvider"
            case weight = "weight"
        }
    }

    public struct CreateScheduleGroupInput: AWSEncodableShape {
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
        public let clientToken: String?
        /// The name of the schedule group that you are creating.
        public let name: String
        /// The list of tags to associate with the schedule group.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateScheduleGroupInput.idempotencyToken(), name: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateScheduleGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schedule group.
        public let scheduleGroupArn: String

        public init(scheduleGroupArn: String) {
            self.scheduleGroupArn = scheduleGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleGroupArn = "ScheduleGroupArn"
        }
    }

    public struct CreateScheduleInput: AWSEncodableShape {
        /// Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
        public let actionAfterCompletion: ActionAfterCompletion?
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
        public let clientToken: String?
        /// The description you specify for the schedule.
        public let description: String?
        /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
        /// EventBridge Scheduler ignores EndDate for one-time schedules.
        public let endDate: Date?
        /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
        public let flexibleTimeWindow: FlexibleTimeWindow
        /// The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.
        public let groupName: String?
        /// The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
        public let kmsKeyArn: String?
        /// The name of the schedule that you are creating.
        public let name: String
        ///  The expression that defines when the schedule runs. The following formats are supported.
        ///     at expression - at(yyyy-mm-ddThh:mm:ss)     rate expression - rate(value unit)     cron expression - cron(fields)     You can use at expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use rate and cron expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
        ///   A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year).
        ///   A rate expression consists of a value as a positive integer, and a unit with the following options: minute | minutes | hour | hours | day | days   For more information and examples, see Schedule types on EventBridge Scheduler in the EventBridge Scheduler User Guide.
        public let scheduleExpression: String
        /// The timezone in which the scheduling expression is evaluated.
        public let scheduleExpressionTimezone: String?
        /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
        /// EventBridge Scheduler ignores StartDate for one-time schedules.
        public let startDate: Date?
        /// Specifies whether the schedule is enabled or disabled.
        public let state: ScheduleState?
        /// The schedule's target.
        public let target: Target

        public init(actionAfterCompletion: ActionAfterCompletion? = nil, clientToken: String? = CreateScheduleInput.idempotencyToken(), description: String? = nil, endDate: Date? = nil, flexibleTimeWindow: FlexibleTimeWindow, groupName: String? = nil, kmsKeyArn: String? = nil, name: String, scheduleExpression: String, scheduleExpressionTimezone: String? = nil, startDate: Date? = nil, state: ScheduleState? = nil, target: Target) {
            self.actionAfterCompletion = actionAfterCompletion
            self.clientToken = clientToken
            self.description = description
            self.endDate = endDate
            self.flexibleTimeWindow = flexibleTimeWindow
            self.groupName = groupName
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startDate = startDate
            self.state = state
            self.target = target
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionAfterCompletion, forKey: .actionAfterCompletion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.endDate, forKey: .endDate)
            try container.encode(self.flexibleTimeWindow, forKey: .flexibleTimeWindow)
            try container.encodeIfPresent(self.groupName, forKey: .groupName)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.scheduleExpression, forKey: .scheduleExpression)
            try container.encodeIfPresent(self.scheduleExpressionTimezone, forKey: .scheduleExpressionTimezone)
            try container.encodeIfPresent(self.startDate, forKey: .startDate)
            try container.encodeIfPresent(self.state, forKey: .state)
            try container.encode(self.target, forKey: .target)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.flexibleTimeWindow.validate(name: "\(name).flexibleTimeWindow")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 64)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(-[a-z]+)?:kms:[a-z0-9\\-]+:\\d{12}:(key|alias)\\/[0-9a-zA-Z-_]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.scheduleExpressionTimezone, name: "scheduleExpressionTimezone", parent: name, max: 50)
            try self.validate(self.scheduleExpressionTimezone, name: "scheduleExpressionTimezone", parent: name, min: 1)
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case actionAfterCompletion = "ActionAfterCompletion"
            case clientToken = "ClientToken"
            case description = "Description"
            case endDate = "EndDate"
            case flexibleTimeWindow = "FlexibleTimeWindow"
            case groupName = "GroupName"
            case kmsKeyArn = "KmsKeyArn"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startDate = "StartDate"
            case state = "State"
            case target = "Target"
        }
    }

    public struct CreateScheduleOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schedule.
        public let scheduleArn: String

        public init(scheduleArn: String) {
            self.scheduleArn = scheduleArn
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleArn = "ScheduleArn"
        }
    }

    public struct DeadLetterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeleteScheduleGroupInput: AWSEncodableShape {
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
        public let clientToken: String?
        /// The name of the schedule group to delete.
        public let name: String

        public init(clientToken: String? = DeleteScheduleGroupInput.idempotencyToken(), name: String) {
            self.clientToken = clientToken
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScheduleGroupOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteScheduleInput: AWSEncodableShape {
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
        public let clientToken: String?
        /// The name of the schedule group associated with this schedule. If you omit this, the default schedule group is used.
        public let groupName: String?
        /// The name of the schedule to delete.
        public let name: String

        public init(clientToken: String? = DeleteScheduleInput.idempotencyToken(), groupName: String? = nil, name: String) {
            self.clientToken = clientToken
            self.groupName = groupName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeQuery(self.groupName, key: "groupName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 64)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScheduleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EcsParameters: AWSEncodableShape & AWSDecodableShape {
        /// The capacity provider strategy to use for the task.
        public let capacityProviderStrategy: [CapacityProviderStrategyItem]?
        /// Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon ECS Developer Guide.
        public let enableECSManagedTags: Bool?
        /// Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
        public let enableExecuteCommand: Bool?
        /// Specifies an ECS task group for the task. The maximum length is 255 characters.
        public let group: String?
        /// Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see AWS Fargate on Amazon ECS in the Amazon ECS Developer Guide.
        public let launchType: LaunchType?
        /// This structure specifies the network configuration for an ECS task.
        public let networkConfiguration: NetworkConfiguration?
        /// An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).
        public let placementConstraints: [PlacementConstraint]?
        /// The task placement strategy for a task or service.
        public let placementStrategy: [PlacementStrategy]?
        /// Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
        public let platformVersion: String?
        /// Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's  TagResource  API action.
        public let propagateTags: PropagateTags?
        /// The reference ID to use for the task.
        public let referenceId: String?
        /// The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see  RunTask in the Amazon ECS API Reference.
        public let tags: [[String: String]]?
        /// The number of tasks to create based on TaskDefinition. The default is 1.
        public let taskCount: Int?
        /// The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.
        public let taskDefinitionArn: String

        public init(capacityProviderStrategy: [CapacityProviderStrategyItem]? = nil, enableECSManagedTags: Bool? = nil, enableExecuteCommand: Bool? = nil, group: String? = nil, launchType: LaunchType? = nil, networkConfiguration: NetworkConfiguration? = nil, placementConstraints: [PlacementConstraint]? = nil, placementStrategy: [PlacementStrategy]? = nil, platformVersion: String? = nil, propagateTags: PropagateTags? = nil, referenceId: String? = nil, tags: [[String: String]]? = nil, taskCount: Int? = nil, taskDefinitionArn: String) {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.enableECSManagedTags = enableECSManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.group = group
            self.launchType = launchType
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategy = placementStrategy
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.referenceId = referenceId
            self.tags = tags
            self.taskCount = taskCount
            self.taskDefinitionArn = taskDefinitionArn
        }

        public func validate(name: String) throws {
            try self.capacityProviderStrategy?.forEach {
                try $0.validate(name: "\(name).capacityProviderStrategy[]")
            }
            try self.validate(self.capacityProviderStrategy, name: "capacityProviderStrategy", parent: name, max: 6)
            try self.validate(self.group, name: "group", parent: name, max: 255)
            try self.validate(self.group, name: "group", parent: name, min: 1)
            try self.networkConfiguration?.validate(name: "\(name).networkConfiguration")
            try self.placementConstraints?.forEach {
                try $0.validate(name: "\(name).placementConstraints[]")
            }
            try self.validate(self.placementConstraints, name: "placementConstraints", parent: name, max: 10)
            try self.placementStrategy?.forEach {
                try $0.validate(name: "\(name).placementStrategy[]")
            }
            try self.validate(self.placementStrategy, name: "placementStrategy", parent: name, max: 5)
            try self.validate(self.platformVersion, name: "platformVersion", parent: name, max: 64)
            try self.validate(self.platformVersion, name: "platformVersion", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, max: 1024)
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.taskCount, name: "taskCount", parent: name, max: 10)
            try self.validate(self.taskCount, name: "taskCount", parent: name, min: 1)
            try self.validate(self.taskDefinitionArn, name: "taskDefinitionArn", parent: name, max: 1600)
            try self.validate(self.taskDefinitionArn, name: "taskDefinitionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case capacityProviderStrategy = "CapacityProviderStrategy"
            case enableECSManagedTags = "EnableECSManagedTags"
            case enableExecuteCommand = "EnableExecuteCommand"
            case group = "Group"
            case launchType = "LaunchType"
            case networkConfiguration = "NetworkConfiguration"
            case placementConstraints = "PlacementConstraints"
            case placementStrategy = "PlacementStrategy"
            case platformVersion = "PlatformVersion"
            case propagateTags = "PropagateTags"
            case referenceId = "ReferenceId"
            case tags = "Tags"
            case taskCount = "TaskCount"
            case taskDefinitionArn = "TaskDefinitionArn"
        }
    }

    public struct EventBridgeParameters: AWSEncodableShape & AWSDecodableShape {
        /// A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
        public let detailType: String
        /// The source of the event.
        public let source: String

        public init(detailType: String, source: String) {
            self.detailType = detailType
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.detailType, name: "detailType", parent: name, max: 128)
            try self.validate(self.detailType, name: "detailType", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, max: 256)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^(?=[/\\.\\-_A-Za-z0-9]+)((?!aws\\.).*)|(\\$(\\.[\\w_-]+(\\[(\\d+|\\*)\\])*)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detailType = "DetailType"
            case source = "Source"
        }
    }

    public struct FlexibleTimeWindow: AWSEncodableShape & AWSDecodableShape {
        /// The maximum time window during which a schedule can be invoked.
        public let maximumWindowInMinutes: Int?
        /// Determines whether the schedule is invoked within a flexible time window.
        public let mode: FlexibleTimeWindowMode

        public init(maximumWindowInMinutes: Int? = nil, mode: FlexibleTimeWindowMode) {
            self.maximumWindowInMinutes = maximumWindowInMinutes
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumWindowInMinutes, name: "maximumWindowInMinutes", parent: name, max: 1440)
            try self.validate(self.maximumWindowInMinutes, name: "maximumWindowInMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumWindowInMinutes = "MaximumWindowInMinutes"
            case mode = "Mode"
        }
    }

    public struct GetScheduleGroupInput: AWSEncodableShape {
        /// The name of the schedule group to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetScheduleGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schedule group.
        public let arn: String?
        /// The time at which the schedule group was created.
        public let creationDate: Date?
        /// The time at which the schedule group was last modified.
        public let lastModificationDate: Date?
        /// The name of the schedule group.
        public let name: String?
        /// Specifies the state of the schedule group.
        public let state: ScheduleGroupState?

        public init(arn: String? = nil, creationDate: Date? = nil, lastModificationDate: Date? = nil, name: String? = nil, state: ScheduleGroupState? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.lastModificationDate = lastModificationDate
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case lastModificationDate = "LastModificationDate"
            case name = "Name"
            case state = "State"
        }
    }

    public struct GetScheduleInput: AWSEncodableShape {
        /// The name of the schedule group associated with this schedule. If you omit this, EventBridge Scheduler assumes that the schedule is associated with the default group.
        public let groupName: String?
        /// The name of the schedule to retrieve.
        public let name: String

        public init(groupName: String? = nil, name: String) {
            self.groupName = groupName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.groupName, key: "groupName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, max: 64)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetScheduleOutput: AWSDecodableShape {
        /// Indicates the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
        public let actionAfterCompletion: ActionAfterCompletion?
        /// The Amazon Resource Name (ARN) of the schedule.
        public let arn: String?
        /// The time at which the schedule was created.
        public let creationDate: Date?
        /// The description of the schedule.
        public let description: String?
        /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
        /// EventBridge Scheduler ignores EndDate for one-time schedules.
        public let endDate: Date?
        /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
        public let flexibleTimeWindow: FlexibleTimeWindow?
        /// The name of the schedule group associated with this schedule.
        public let groupName: String?
        /// The ARN for a customer managed KMS Key that is be used to encrypt and decrypt your data.
        public let kmsKeyArn: String?
        /// The time at which the schedule was last modified.
        public let lastModificationDate: Date?
        /// The name of the schedule.
        public let name: String?
        ///  The expression that defines when the schedule runs. The following formats are supported.
        ///     at expression - at(yyyy-mm-ddThh:mm:ss)     rate expression - rate(value unit)     cron expression - cron(fields)     You can use at expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use rate and cron expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
        ///   A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year).
        ///   A rate expression consists of a value as a positive integer, and a unit with the following options: minute | minutes | hour | hours | day | days   For more information and examples, see Schedule types on EventBridge Scheduler in the EventBridge Scheduler User Guide.
        public let scheduleExpression: String?
        /// The timezone in which the scheduling expression is evaluated.
        public let scheduleExpressionTimezone: String?
        /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
        /// EventBridge Scheduler ignores StartDate for one-time schedules.
        public let startDate: Date?
        /// Specifies whether the schedule is enabled or disabled.
        public let state: ScheduleState?
        /// The schedule target.
        public let target: Target?

        public init(actionAfterCompletion: ActionAfterCompletion? = nil, arn: String? = nil, creationDate: Date? = nil, description: String? = nil, endDate: Date? = nil, flexibleTimeWindow: FlexibleTimeWindow? = nil, groupName: String? = nil, kmsKeyArn: String? = nil, lastModificationDate: Date? = nil, name: String? = nil, scheduleExpression: String? = nil, scheduleExpressionTimezone: String? = nil, startDate: Date? = nil, state: ScheduleState? = nil, target: Target? = nil) {
            self.actionAfterCompletion = actionAfterCompletion
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.endDate = endDate
            self.flexibleTimeWindow = flexibleTimeWindow
            self.groupName = groupName
            self.kmsKeyArn = kmsKeyArn
            self.lastModificationDate = lastModificationDate
            self.name = name
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startDate = startDate
            self.state = state
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case actionAfterCompletion = "ActionAfterCompletion"
            case arn = "Arn"
            case creationDate = "CreationDate"
            case description = "Description"
            case endDate = "EndDate"
            case flexibleTimeWindow = "FlexibleTimeWindow"
            case groupName = "GroupName"
            case kmsKeyArn = "KmsKeyArn"
            case lastModificationDate = "LastModificationDate"
            case name = "Name"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startDate = "StartDate"
            case state = "State"
            case target = "Target"
        }
    }

    public struct KinesisParameters: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the shard to which EventBridge Scheduler sends the event. For more information, see Amazon Kinesis Data Streams terminology and concepts in the Amazon Kinesis Streams Developer Guide.
        public let partitionKey: String

        public init(partitionKey: String) {
            self.partitionKey = partitionKey
        }

        public func validate(name: String) throws {
            try self.validate(self.partitionKey, name: "partitionKey", parent: name, max: 256)
            try self.validate(self.partitionKey, name: "partitionKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case partitionKey = "PartitionKey"
        }
    }

    public struct ListScheduleGroupsInput: AWSEncodableShape {
        /// If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
        public let maxResults: Int?
        /// The name prefix that you can use to return a filtered list of your schedule groups.
        public let namePrefix: String?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, namePrefix: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.namePrefix = namePrefix
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.namePrefix, key: "NamePrefix")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, max: 64)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, min: 1)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScheduleGroupsOutput: AWSDecodableShape {
        /// Indicates whether there are additional results to retrieve. If the value is null, there are no more results.
        public let nextToken: String?
        /// The schedule groups that match the specified criteria.
        public let scheduleGroups: [ScheduleGroupSummary]

        public init(nextToken: String? = nil, scheduleGroups: [ScheduleGroupSummary]) {
            self.nextToken = nextToken
            self.scheduleGroups = scheduleGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case scheduleGroups = "ScheduleGroups"
        }
    }

    public struct ListSchedulesInput: AWSEncodableShape {
        /// If specified, only lists the schedules whose associated schedule group matches the given filter.
        public let groupName: String?
        /// If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
        public let maxResults: Int?
        /// Schedule name prefix to return the filtered list of resources.
        public let namePrefix: String?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?
        /// If specified, only lists the schedules whose current state matches the given filter.
        public let state: ScheduleState?

        public init(groupName: String? = nil, maxResults: Int? = nil, namePrefix: String? = nil, nextToken: String? = nil, state: ScheduleState? = nil) {
            self.groupName = groupName
            self.maxResults = maxResults
            self.namePrefix = namePrefix
            self.nextToken = nextToken
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.groupName, key: "ScheduleGroup")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.namePrefix, key: "NamePrefix")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.state, key: "State")
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, max: 64)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, max: 64)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, min: 1)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchedulesOutput: AWSDecodableShape {
        /// Indicates whether there are additional results to retrieve. If the value is null, there are no more results.
        public let nextToken: String?
        /// The schedules that match the specified criteria.
        public let schedules: [ScheduleSummary]

        public init(nextToken: String? = nil, schedules: [ScheduleSummary]) {
            self.nextToken = nextToken
            self.schedules = schedules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schedules = "Schedules"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The ARN of the EventBridge Scheduler resource for which you want to view tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-[a-z]+)?:scheduler:[a-z0-9\\-]+:\\d{12}:schedule-group\\/[0-9a-zA-Z-_.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The list of tags associated with the specified resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct NetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
        public let awsvpcConfiguration: AwsVpcConfiguration?

        public init(awsvpcConfiguration: AwsVpcConfiguration? = nil) {
            self.awsvpcConfiguration = awsvpcConfiguration
        }

        public func validate(name: String) throws {
            try self.awsvpcConfiguration?.validate(name: "\(name).awsvpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case awsvpcConfiguration = "awsvpcConfiguration"
        }
    }

    public struct PlacementConstraint: AWSEncodableShape & AWSDecodableShape {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see Cluster query language in the Amazon ECS Developer Guide.
        public let expression: String?
        /// The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict the selection to a group of valid candidates.
        public let type: PlacementConstraintType?

        public init(expression: String? = nil, type: PlacementConstraintType? = nil) {
            self.expression = expression
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case type = "type"
        }
    }

    public struct PlacementStrategy: AWSEncodableShape & AWSDecodableShape {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or instanceId, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.
        public let field: String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).
        public let type: PlacementStrategyType?

        public init(field: String? = nil, type: PlacementStrategyType? = nil) {
            self.field = field
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.field, name: "field", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case type = "type"
        }
    }

    public struct RetryPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The maximum amount of time, in seconds, to continue to make retry attempts.
        public let maximumEventAgeInSeconds: Int?
        /// The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the MaximumEventAgeInSeconds is reached.
        public let maximumRetryAttempts: Int?

        public init(maximumEventAgeInSeconds: Int? = nil, maximumRetryAttempts: Int? = nil) {
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, max: 86400)
            try self.validate(self.maximumEventAgeInSeconds, name: "maximumEventAgeInSeconds", parent: name, min: 60)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, max: 185)
            try self.validate(self.maximumRetryAttempts, name: "maximumRetryAttempts", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
            case maximumRetryAttempts = "MaximumRetryAttempts"
        }
    }

    public struct SageMakerPipelineParameter: AWSEncodableShape & AWSDecodableShape {
        /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
        public let name: String
        /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9\\-_]*$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SageMakerPipelineParameters: AWSEncodableShape & AWSDecodableShape {
        /// List of parameter names and values to use when executing the SageMaker Model Building Pipeline.
        public let pipelineParameterList: [SageMakerPipelineParameter]?

        public init(pipelineParameterList: [SageMakerPipelineParameter]? = nil) {
            self.pipelineParameterList = pipelineParameterList
        }

        public func validate(name: String) throws {
            try self.pipelineParameterList?.forEach {
                try $0.validate(name: "\(name).pipelineParameterList[]")
            }
            try self.validate(self.pipelineParameterList, name: "pipelineParameterList", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineParameterList = "PipelineParameterList"
        }
    }

    public struct ScheduleGroupSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schedule group.
        public let arn: String?
        /// The time at which the schedule group was created.
        public let creationDate: Date?
        /// The time at which the schedule group was last modified.
        public let lastModificationDate: Date?
        /// The name of the schedule group.
        public let name: String?
        /// Specifies the state of the schedule group.
        public let state: ScheduleGroupState?

        public init(arn: String? = nil, creationDate: Date? = nil, lastModificationDate: Date? = nil, name: String? = nil, state: ScheduleGroupState? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.lastModificationDate = lastModificationDate
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case lastModificationDate = "LastModificationDate"
            case name = "Name"
            case state = "State"
        }
    }

    public struct ScheduleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schedule.
        public let arn: String?
        /// The time at which the schedule was created.
        public let creationDate: Date?
        /// The name of the schedule group associated with this schedule.
        public let groupName: String?
        /// The time at which the schedule was last modified.
        public let lastModificationDate: Date?
        /// The name of the schedule.
        public let name: String?
        /// Specifies whether the schedule is enabled or disabled.
        public let state: ScheduleState?
        /// The schedule's target details.
        public let target: TargetSummary?

        public init(arn: String? = nil, creationDate: Date? = nil, groupName: String? = nil, lastModificationDate: Date? = nil, name: String? = nil, state: ScheduleState? = nil, target: TargetSummary? = nil) {
            self.arn = arn
            self.creationDate = creationDate
            self.groupName = groupName
            self.lastModificationDate = lastModificationDate
            self.name = name
            self.state = state
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationDate = "CreationDate"
            case groupName = "GroupName"
            case lastModificationDate = "LastModificationDate"
            case name = "Name"
            case state = "State"
            case target = "Target"
        }
    }

    public struct SqsParameters: AWSEncodableShape & AWSDecodableShape {
        /// The FIFO message group ID to use as the target.
        public let messageGroupId: String?

        public init(messageGroupId: String? = nil) {
            self.messageGroupId = messageGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.messageGroupId, name: "messageGroupId", parent: name, max: 128)
            try self.validate(self.messageGroupId, name: "messageGroupId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case messageGroupId = "MessageGroupId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key for the tag.
        public let key: String
        /// The value for the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the schedule group that you are adding tags to.
        public let resourceArn: String
        /// The list of tags to associate with the schedule group.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-[a-z]+)?:scheduler:[a-z0-9\\-]+:\\d{12}:schedule-group\\/[0-9a-zA-Z-_.]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Target: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target.
        public let arn: String
        /// An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
        public let deadLetterConfig: DeadLetterConfig?
        /// The templated target type for the Amazon ECS  RunTask API operation.
        public let ecsParameters: EcsParameters?
        /// The templated target type for the EventBridge  PutEvents API operation.
        public let eventBridgeParameters: EventBridgeParameters?
        /// The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.
        public let input: String?
        /// The templated target type for the Amazon Kinesis  PutRecord API operation.
        public let kinesisParameters: KinesisParameters?
        /// A RetryPolicy object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
        public let retryPolicy: RetryPolicy?
        /// The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.
        public let roleArn: String
        /// The templated target type for the Amazon SageMaker  StartPipelineExecution API operation.
        public let sageMakerPipelineParameters: SageMakerPipelineParameters?
        /// The templated target type for the Amazon SQS  SendMessage API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see Using the Amazon SQS message deduplication ID in the Amazon SQS Developer Guide.
        public let sqsParameters: SqsParameters?

        public init(arn: String, deadLetterConfig: DeadLetterConfig? = nil, ecsParameters: EcsParameters? = nil, eventBridgeParameters: EventBridgeParameters? = nil, input: String? = nil, kinesisParameters: KinesisParameters? = nil, retryPolicy: RetryPolicy? = nil, roleArn: String, sageMakerPipelineParameters: SageMakerPipelineParameters? = nil, sqsParameters: SqsParameters? = nil) {
            self.arn = arn
            self.deadLetterConfig = deadLetterConfig
            self.ecsParameters = ecsParameters
            self.eventBridgeParameters = eventBridgeParameters
            self.input = input
            self.kinesisParameters = kinesisParameters
            self.retryPolicy = retryPolicy
            self.roleArn = roleArn
            self.sageMakerPipelineParameters = sageMakerPipelineParameters
            self.sqsParameters = sqsParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.ecsParameters?.validate(name: "\(name).ecsParameters")
            try self.eventBridgeParameters?.validate(name: "\(name).eventBridgeParameters")
            try self.validate(self.input, name: "input", parent: name, min: 1)
            try self.kinesisParameters?.validate(name: "\(name).kinesisParameters")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[a-z]+)?:iam::\\d{12}:role\\/[\\w+=,.@\\/-]+$")
            try self.sageMakerPipelineParameters?.validate(name: "\(name).sageMakerPipelineParameters")
            try self.sqsParameters?.validate(name: "\(name).sqsParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case deadLetterConfig = "DeadLetterConfig"
            case ecsParameters = "EcsParameters"
            case eventBridgeParameters = "EventBridgeParameters"
            case input = "Input"
            case kinesisParameters = "KinesisParameters"
            case retryPolicy = "RetryPolicy"
            case roleArn = "RoleArn"
            case sageMakerPipelineParameters = "SageMakerPipelineParameters"
            case sqsParameters = "SqsParameters"
        }
    }

    public struct TargetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the schedule group from which you are removing tags.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "TagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-[a-z]+)?:scheduler:[a-z0-9\\-]+:\\d{12}:schedule-group\\/[0-9a-zA-Z-_.]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateScheduleInput: AWSEncodableShape {
        /// Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
        public let actionAfterCompletion: ActionAfterCompletion?
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
        public let clientToken: String?
        /// The description you specify for the schedule.
        public let description: String?
        /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
        /// EventBridge Scheduler ignores EndDate for one-time schedules.
        public let endDate: Date?
        /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
        public let flexibleTimeWindow: FlexibleTimeWindow
        /// The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.
        public let groupName: String?
        /// The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.
        public let kmsKeyArn: String?
        /// The name of the schedule that you are updating.
        public let name: String
        ///  The expression that defines when the schedule runs. The following formats are supported.
        ///     at expression - at(yyyy-mm-ddThh:mm:ss)     rate expression - rate(value unit)     cron expression - cron(fields)     You can use at expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use rate and cron expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month.
        ///   A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year).
        ///   A rate expression consists of a value as a positive integer, and a unit with the following options: minute | minutes | hour | hours | day | days   For more information and examples, see Schedule types on EventBridge Scheduler in the EventBridge Scheduler User Guide.
        public let scheduleExpression: String
        /// The timezone in which the scheduling expression is evaluated.
        public let scheduleExpressionTimezone: String?
        /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
        /// EventBridge Scheduler ignores StartDate for one-time schedules.
        public let startDate: Date?
        /// Specifies whether the schedule is enabled or disabled.
        public let state: ScheduleState?
        /// The schedule target. You can use this operation to change the target that your schedule invokes.
        public let target: Target

        public init(actionAfterCompletion: ActionAfterCompletion? = nil, clientToken: String? = UpdateScheduleInput.idempotencyToken(), description: String? = nil, endDate: Date? = nil, flexibleTimeWindow: FlexibleTimeWindow, groupName: String? = nil, kmsKeyArn: String? = nil, name: String, scheduleExpression: String, scheduleExpressionTimezone: String? = nil, startDate: Date? = nil, state: ScheduleState? = nil, target: Target) {
            self.actionAfterCompletion = actionAfterCompletion
            self.clientToken = clientToken
            self.description = description
            self.endDate = endDate
            self.flexibleTimeWindow = flexibleTimeWindow
            self.groupName = groupName
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
            self.startDate = startDate
            self.state = state
            self.target = target
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionAfterCompletion, forKey: .actionAfterCompletion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.endDate, forKey: .endDate)
            try container.encode(self.flexibleTimeWindow, forKey: .flexibleTimeWindow)
            try container.encodeIfPresent(self.groupName, forKey: .groupName)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.scheduleExpression, forKey: .scheduleExpression)
            try container.encodeIfPresent(self.scheduleExpressionTimezone, forKey: .scheduleExpressionTimezone)
            try container.encodeIfPresent(self.startDate, forKey: .startDate)
            try container.encodeIfPresent(self.state, forKey: .state)
            try container.encode(self.target, forKey: .target)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.flexibleTimeWindow.validate(name: "\(name).flexibleTimeWindow")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 64)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(-[a-z]+)?:kms:[a-z0-9\\-]+:\\d{12}:(key|alias)\\/[0-9a-zA-Z-_]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.scheduleExpressionTimezone, name: "scheduleExpressionTimezone", parent: name, max: 50)
            try self.validate(self.scheduleExpressionTimezone, name: "scheduleExpressionTimezone", parent: name, min: 1)
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case actionAfterCompletion = "ActionAfterCompletion"
            case clientToken = "ClientToken"
            case description = "Description"
            case endDate = "EndDate"
            case flexibleTimeWindow = "FlexibleTimeWindow"
            case groupName = "GroupName"
            case kmsKeyArn = "KmsKeyArn"
            case scheduleExpression = "ScheduleExpression"
            case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
            case startDate = "StartDate"
            case state = "State"
            case target = "Target"
        }
    }

    public struct UpdateScheduleOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schedule that you updated.
        public let scheduleArn: String

        public init(scheduleArn: String) {
            self.scheduleArn = scheduleArn
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleArn = "ScheduleArn"
        }
    }
}

// MARK: - Errors

/// Error enum for Scheduler
public struct SchedulerErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Scheduler
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Updating or deleting the resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error encountered while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension SchedulerErrorType: Equatable {
    public static func == (lhs: SchedulerErrorType, rhs: SchedulerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SchedulerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
