//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Billingconductor {
    // MARK: Enums

    public enum AssociateResourceErrorReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case illegalCustomlineitem = "ILLEGAL_CUSTOMLINEITEM"
        case internalServerException = "INTERNAL_SERVER_EXCEPTION"
        case invalidArn = "INVALID_ARN"
        case invalidBillingPeriodRange = "INVALID_BILLING_PERIOD_RANGE"
        case serviceLimitExceeded = "SERVICE_LIMIT_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum BillingGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case primaryAccountMissing = "PRIMARY_ACCOUNT_MISSING"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pricingPlanAttachedToBillingGroupDeleteConflict = "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT"
        case pricingRuleAttachedToPricingPlanDeleteConflict = "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT"
        case pricingRuleInPricingPlanConflict = "PRICING_RULE_IN_PRICING_PLAN_CONFLICT"
        case resourceNameConflict = "RESOURCE_NAME_CONFLICT"
        case writeConflictRetry = "WRITE_CONFLICT_RETRY"
        public var description: String { return self.rawValue }
    }

    public enum CurrencyCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cny = "CNY"
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum CustomLineItemRelationship: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case child = "CHILD"
        case parent = "PARENT"
        public var description: String { return self.rawValue }
    }

    public enum CustomLineItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case credit = "CREDIT"
        case fee = "FEE"
        public var description: String { return self.rawValue }
    }

    public enum GroupByAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case billingPeriod = "BILLING_PERIOD"
        case productName = "PRODUCT_NAME"
        public var description: String { return self.rawValue }
    }

    public enum LineItemFilterAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lineItemType = "LINE_ITEM_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum LineItemFilterValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case savingsPlanNegation = "SAVINGS_PLAN_NEGATION"
        public var description: String { return self.rawValue }
    }

    public enum MatchOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notEqual = "NOT_EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum PricingRuleScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case billingEntity = "BILLING_ENTITY"
        case global = "GLOBAL"
        case service = "SERVICE"
        case sku = "SKU"
        public var description: String { return self.rawValue }
    }

    public enum PricingRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case discount = "DISCOUNT"
        case markup = "MARKUP"
        case tiering = "TIERING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountsAlreadyAssociated = "ACCOUNTS_ALREADY_ASSOCIATED"
        case accountsNotAssociated = "ACCOUNTS_NOT_ASSOCIATED"
        case cannotDeleteAutoAssociateBillingGroup = "CANNOT_DELETE_AUTO_ASSOCIATE_BILLING_GROUP"
        case cannotParse = "CANNOT_PARSE"
        case customLineItemAssociationExists = "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS"
        case duplicateAccount = "DUPLICATE_ACCOUNT"
        case duplicatePricingruleArns = "DUPLICATE_PRICINGRULE_ARNS"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case illegalAccounts = "ILLEGAL_ACCOUNTS"
        case illegalAccountId = "ILLEGAL_ACCOUNT_ID"
        case illegalBillingEntity = "ILLEGAL_BILLING_ENTITY"
        case illegalBillingPeriod = "ILLEGAL_BILLING_PERIOD"
        case illegalBillingPeriodRange = "ILLEGAL_BILLING_PERIOD_RANGE"
        case illegalChargeDetails = "ILLEGAL_CHARGE_DETAILS"
        case illegalChildAssociateResource = "ILLEGAL_CHILD_ASSOCIATE_RESOURCE"
        case illegalCustomlineitem = "ILLEGAL_CUSTOMLINEITEM"
        case illegalCustomlineitemModification = "ILLEGAL_CUSTOMLINEITEM_MODIFICATION"
        case illegalCustomlineitemUpdate = "ILLEGAL_CUSTOMLINEITEM_UPDATE"
        case illegalEndedBillinggroup = "ILLEGAL_ENDED_BILLINGGROUP"
        case illegalExpression = "ILLEGAL_EXPRESSION"
        case illegalModifierPercentage = "ILLEGAL_MODIFIER_PERCENTAGE"
        case illegalOperation = "ILLEGAL_OPERATION"
        case illegalPrimaryAccount = "ILLEGAL_PRIMARY_ACCOUNT"
        case illegalResourceArns = "ILLEGAL_RESOURCE_ARNS"
        case illegalScope = "ILLEGAL_SCOPE"
        case illegalService = "ILLEGAL_SERVICE"
        case illegalTieringInput = "ILLEGAL_TIERING_INPUT"
        case illegalType = "ILLEGAL_TYPE"
        case illegalUpdateChargeDetails = "ILLEGAL_UPDATE_CHARGE_DETAILS"
        case illegalUsageType = "ILLEGAL_USAGE_TYPE"
        case invalidArn = "INVALID_ARN"
        case invalidBillingviewArn = "INVALID_BILLINGVIEW_ARN"
        case invalidBillingGroup = "INVALID_BILLING_GROUP"
        case invalidBillingGroupStatus = "INVALID_BILLING_GROUP_STATUS"
        case invalidBillingPeriodForOperation = "INVALID_BILLING_PERIOD_FOR_OPERATION"
        case invalidFilter = "INVALID_FILTER"
        case invalidSkuCombo = "INVALID_SKU_COMBO"
        case invalidTimeRange = "INVALID_TIME_RANGE"
        case mismatchedBillinggroupArn = "MISMATCHED_BILLINGGROUP_ARN"
        case mismatchedBillingviewArn = "MISMATCHED_BILLINGVIEW_ARN"
        case mismatchedCustomlineitemArn = "MISMATCHED_CUSTOMLINEITEM_ARN"
        case mismatchedPricingplanArn = "MISMATCHED_PRICINGPLAN_ARN"
        case mismatchedPricingruleArn = "MISMATCHED_PRICINGRULE_ARN"
        case missingBillinggroup = "MISSING_BILLINGGROUP"
        case missingCustomlineitem = "MISSING_CUSTOMLINEITEM"
        case missingLinkedAccountIds = "MISSING_LINKED_ACCOUNT_IDS"
        case missingPricingplan = "MISSING_PRICINGPLAN"
        case missingPricingPlanArn = "MISSING_PRICING_PLAN_ARN"
        case multipleLinkedAccountIds = "MULTIPLE_LINKED_ACCOUNT_IDS"
        case multiplePricingPlanArn = "MULTIPLE_PRICING_PLAN_ARN"
        case other = "OTHER"
        case pricingrulesAlreadyAssociated = "PRICINGRULES_ALREADY_ASSOCIATED"
        case pricingrulesNotAssociated = "PRICINGRULES_NOT_ASSOCIATED"
        case pricingrulesNotExist = "PRICINGRULES_NOT_EXIST"
        case primaryCannotDisassociate = "PRIMARY_CANNOT_DISASSOCIATE"
        case primaryNotAssociated = "PRIMARY_NOT_ASSOCIATED"
        case tooManyAccountsInRequest = "TOO_MANY_ACCOUNTS_IN_REQUEST"
        case tooManyAutoAssociateBillingGroups = "TOO_MANY_AUTO_ASSOCIATE_BILLING_GROUPS"
        case tooManyCustomlineitemsInRequest = "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAssociationsListElement: AWSDecodableShape {
        /// The Amazon Web Services account email.
        public let accountEmail: String?
        /// The associating array of account IDs.
        public let accountId: String?
        /// The Amazon Web Services account name.
        public let accountName: String?
        /// The Billing Group Arn that the linked account is associated to.
        public let billingGroupArn: String?

        @inlinable
        public init(accountEmail: String? = nil, accountId: String? = nil, accountName: String? = nil, billingGroupArn: String? = nil) {
            self.accountEmail = accountEmail
            self.accountId = accountId
            self.accountName = accountName
            self.billingGroupArn = billingGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case accountEmail = "AccountEmail"
            case accountId = "AccountId"
            case accountName = "AccountName"
            case billingGroupArn = "BillingGroupArn"
        }
    }

    public struct AccountGrouping: AWSEncodableShape {
        /// Specifies if this billing group will automatically associate newly added
        /// Amazon Web Services accounts that join your consolidated billing family.
        public let autoAssociate: Bool?
        /// The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group.
        public let linkedAccountIds: [String]

        @inlinable
        public init(autoAssociate: Bool? = nil, linkedAccountIds: [String]) {
            self.autoAssociate = autoAssociate
            self.linkedAccountIds = linkedAccountIds
        }

        public func validate(name: String) throws {
            try self.linkedAccountIds.forEach {
                try validate($0, name: "linkedAccountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.linkedAccountIds, name: "linkedAccountIds", parent: name, max: 30)
            try self.validate(self.linkedAccountIds, name: "linkedAccountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoAssociate = "AutoAssociate"
            case linkedAccountIds = "LinkedAccountIds"
        }
    }

    public struct AssociateAccountsInput: AWSEncodableShape {
        ///  The associating array of account IDs.
        public let accountIds: [String]
        ///  The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
        public let arn: String

        @inlinable
        public init(accountIds: [String], arn: String) {
            self.accountIds = accountIds
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 30)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case arn = "Arn"
        }
    }

    public struct AssociateAccountsOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct AssociatePricingRulesInput: AWSEncodableShape {
        ///  The PricingPlanArn that the PricingRuleArns are associated with.
        public let arn: String
        ///  The PricingRuleArns that are associated with the Pricing Plan.
        public let pricingRuleArns: [String]

        @inlinable
        public init(arn: String, pricingRuleArns: [String]) {
            self.arn = arn
            self.pricingRuleArns = pricingRuleArns
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/)?[a-zA-Z0-9]{10}$")
            try self.pricingRuleArns.forEach {
                try validate($0, name: "pricingRuleArns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
            }
            try self.validate(self.pricingRuleArns, name: "pricingRuleArns", parent: name, max: 30)
            try self.validate(self.pricingRuleArns, name: "pricingRuleArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case pricingRuleArns = "PricingRuleArns"
        }
    }

    public struct AssociatePricingRulesOutput: AWSDecodableShape {
        ///  The PricingPlanArn that the PricingRuleArns are associated with.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct AssociateResourceError: AWSDecodableShape {
        /// The reason why the resource association failed.
        public let message: String?
        /// A static error code that's used to classify the type of failure.
        public let reason: AssociateResourceErrorReason?

        @inlinable
        public init(message: String? = nil, reason: AssociateResourceErrorReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct AssociateResourceResponseElement: AWSDecodableShape {
        /// The resource ARN that was associated to the custom line item.
        public let arn: String?
        /// An AssociateResourceError that will populate if the resource association fails.
        public let error: AssociateResourceError?

        @inlinable
        public init(arn: String? = nil, error: AssociateResourceError? = nil) {
            self.arn = arn
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case error = "Error"
        }
    }

    public struct Attribute: AWSDecodableShape {
        /// The key in a key-value pair that describes the margin summary.
        public let key: String?
        /// The value in a key-value pair that describes the margin summary.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct BatchAssociateResourcesToCustomLineItemInput: AWSEncodableShape {
        public let billingPeriodRange: CustomLineItemBillingPeriodRange?
        ///  A list containing the ARNs of the resources to be associated.
        public let resourceArns: [String]
        ///  A percentage custom line item ARN to associate the resources to.
        public let targetArn: String

        @inlinable
        public init(billingPeriodRange: CustomLineItemBillingPeriodRange? = nil, resourceArns: [String], targetArn: String) {
            self.billingPeriodRange = billingPeriodRange
            self.resourceArns = resourceArns
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
            try self.resourceArns.forEach {
                try validate($0, name: "resourceArns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:(customlineitem|billinggroup)/)?[a-zA-Z0-9]{10,12}$")
            }
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 30)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, min: 1)
            try self.validate(self.targetArn, name: "targetArn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriodRange = "BillingPeriodRange"
            case resourceArns = "ResourceArns"
            case targetArn = "TargetArn"
        }
    }

    public struct BatchAssociateResourcesToCustomLineItemOutput: AWSDecodableShape {
        ///  A list of AssociateResourceResponseElement for each resource that failed association to a percentage custom line item.
        public let failedAssociatedResources: [AssociateResourceResponseElement]?
        ///  A list of AssociateResourceResponseElement for each resource that's been associated to a percentage custom line item successfully.
        public let successfullyAssociatedResources: [AssociateResourceResponseElement]?

        @inlinable
        public init(failedAssociatedResources: [AssociateResourceResponseElement]? = nil, successfullyAssociatedResources: [AssociateResourceResponseElement]? = nil) {
            self.failedAssociatedResources = failedAssociatedResources
            self.successfullyAssociatedResources = successfullyAssociatedResources
        }

        private enum CodingKeys: String, CodingKey {
            case failedAssociatedResources = "FailedAssociatedResources"
            case successfullyAssociatedResources = "SuccessfullyAssociatedResources"
        }
    }

    public struct BatchDisassociateResourcesFromCustomLineItemInput: AWSEncodableShape {
        public let billingPeriodRange: CustomLineItemBillingPeriodRange?
        ///  A list containing the ARNs of resources to be disassociated.
        public let resourceArns: [String]
        ///  A percentage custom line item ARN to disassociate the resources from.
        public let targetArn: String

        @inlinable
        public init(billingPeriodRange: CustomLineItemBillingPeriodRange? = nil, resourceArns: [String], targetArn: String) {
            self.billingPeriodRange = billingPeriodRange
            self.resourceArns = resourceArns
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
            try self.resourceArns.forEach {
                try validate($0, name: "resourceArns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:(customlineitem|billinggroup)/)?[a-zA-Z0-9]{10,12}$")
            }
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 30)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, min: 1)
            try self.validate(self.targetArn, name: "targetArn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriodRange = "BillingPeriodRange"
            case resourceArns = "ResourceArns"
            case targetArn = "TargetArn"
        }
    }

    public struct BatchDisassociateResourcesFromCustomLineItemOutput: AWSDecodableShape {
        ///  A list of DisassociateResourceResponseElement for each resource that failed disassociation from a percentage custom line item.
        public let failedDisassociatedResources: [DisassociateResourceResponseElement]?
        ///  A list of DisassociateResourceResponseElement for each resource that's been disassociated from a percentage custom line item successfully.
        public let successfullyDisassociatedResources: [DisassociateResourceResponseElement]?

        @inlinable
        public init(failedDisassociatedResources: [DisassociateResourceResponseElement]? = nil, successfullyDisassociatedResources: [DisassociateResourceResponseElement]? = nil) {
            self.failedDisassociatedResources = failedDisassociatedResources
            self.successfullyDisassociatedResources = successfullyDisassociatedResources
        }

        private enum CodingKeys: String, CodingKey {
            case failedDisassociatedResources = "FailedDisassociatedResources"
            case successfullyDisassociatedResources = "SuccessfullyDisassociatedResources"
        }
    }

    public struct BillingGroupCostReportElement: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a billing group.
        public let arn: String?
        /// The actual Amazon Web Services charges for the billing group.
        public let awsCost: String?
        /// The displayed currency.
        public let currency: String?
        /// The billing group margin.
        public let margin: String?
        /// The percentage of billing group margin.
        public let marginPercentage: String?
        /// The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group.
        public let proformaCost: String?

        @inlinable
        public init(arn: String? = nil, awsCost: String? = nil, currency: String? = nil, margin: String? = nil, marginPercentage: String? = nil, proformaCost: String? = nil) {
            self.arn = arn
            self.awsCost = awsCost
            self.currency = currency
            self.margin = margin
            self.marginPercentage = marginPercentage
            self.proformaCost = proformaCost
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case awsCost = "AWSCost"
            case currency = "Currency"
            case margin = "Margin"
            case marginPercentage = "MarginPercentage"
            case proformaCost = "ProformaCost"
        }
    }

    public struct BillingGroupCostReportResultElement: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) that uniquely identifies the billing group.
        public let arn: String?
        /// The list of key-value pairs that represent the attributes by which the BillingGroupCostReportResults are grouped. For example, if you want the Amazon S3 service-level breakdown of a billing group for November 2023, the attributes list will contain a key-value pair of "PRODUCT_NAME" and "S3" and a key-value pair of "BILLING_PERIOD" and "Nov 2023".
        public let attributes: [Attribute]?
        /// The actual Amazon Web Services charges for the billing group.
        public let awsCost: String?
        /// The displayed currency.
        public let currency: String?
        /// The billing group margin.
        public let margin: String?
        /// The percentage of the billing group margin.
        public let marginPercentage: String?
        /// The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group.
        public let proformaCost: String?

        @inlinable
        public init(arn: String? = nil, attributes: [Attribute]? = nil, awsCost: String? = nil, currency: String? = nil, margin: String? = nil, marginPercentage: String? = nil, proformaCost: String? = nil) {
            self.arn = arn
            self.attributes = attributes
            self.awsCost = awsCost
            self.currency = currency
            self.margin = margin
            self.marginPercentage = marginPercentage
            self.proformaCost = proformaCost
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case attributes = "Attributes"
            case awsCost = "AWSCost"
            case currency = "Currency"
            case margin = "Margin"
            case marginPercentage = "MarginPercentage"
            case proformaCost = "ProformaCost"
        }
    }

    public struct BillingGroupListElement: AWSDecodableShape {
        /// Specifies if the billing group has automatic account
        /// association (AutoAssociate) enabled.
        public let accountGrouping: ListBillingGroupAccountGrouping?
        /// The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group.
        public let arn: String?
        public let computationPreference: ComputationPreference?
        /// The time when the billing group was created.
        public let creationTime: Int64?
        /// The description of the billing group.
        public let description: String?
        /// The most recent time when the billing group was modified.
        public let lastModifiedTime: Int64?
        /// The name of the billing group.
        public let name: String?
        /// The account ID that serves as the main account in a billing group.
        public let primaryAccountId: String?
        /// The number of accounts in the particular billing group.
        public let size: Int64?
        /// The billing group status. Only one of the valid values can be used.
        public let status: BillingGroupStatus?
        /// The reason why the billing group is in its current status.
        public let statusReason: String?

        @inlinable
        public init(accountGrouping: ListBillingGroupAccountGrouping? = nil, arn: String? = nil, computationPreference: ComputationPreference? = nil, creationTime: Int64? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil, primaryAccountId: String? = nil, size: Int64? = nil, status: BillingGroupStatus? = nil, statusReason: String? = nil) {
            self.accountGrouping = accountGrouping
            self.arn = arn
            self.computationPreference = computationPreference
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.primaryAccountId = primaryAccountId
            self.size = size
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case accountGrouping = "AccountGrouping"
            case arn = "Arn"
            case computationPreference = "ComputationPreference"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case primaryAccountId = "PrimaryAccountId"
            case size = "Size"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct BillingPeriodRange: AWSEncodableShape {
        /// The exclusive end billing period that defines a billing period range for the margin summary. For example, if you choose a billing period that starts in October 2023 and ends in December 2023, the margin summary will only include data from October 2023 and November 2023.
        public let exclusiveEndBillingPeriod: String
        /// The inclusive start billing period that defines a billing period range for the margin summary.
        public let inclusiveStartBillingPeriod: String

        @inlinable
        public init(exclusiveEndBillingPeriod: String, inclusiveStartBillingPeriod: String) {
            self.exclusiveEndBillingPeriod = exclusiveEndBillingPeriod
            self.inclusiveStartBillingPeriod = inclusiveStartBillingPeriod
        }

        public func validate(name: String) throws {
            try self.validate(self.exclusiveEndBillingPeriod, name: "exclusiveEndBillingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.validate(self.inclusiveStartBillingPeriod, name: "inclusiveStartBillingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
        }

        private enum CodingKeys: String, CodingKey {
            case exclusiveEndBillingPeriod = "ExclusiveEndBillingPeriod"
            case inclusiveStartBillingPeriod = "InclusiveStartBillingPeriod"
        }
    }

    public struct ComputationPreference: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group.
        public let pricingPlanArn: String

        @inlinable
        public init(pricingPlanArn: String) {
            self.pricingPlanArn = pricingPlanArn
        }

        public func validate(name: String) throws {
            try self.validate(self.pricingPlanArn, name: "pricingPlanArn", parent: name, pattern: "^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case pricingPlanArn = "PricingPlanArn"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// Reason for the inconsistent state.
        public let reason: ConflictExceptionReason?
        /// Identifier of the resource in use.
        public let resourceId: String
        /// Type of the resource in use.
        public let resourceType: String

        @inlinable
        public init(message: String, reason: ConflictExceptionReason? = nil, resourceId: String, resourceType: String) {
            self.message = message
            self.reason = reason
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateBillingGroupInput: AWSEncodableShape {
        ///  The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated billing family.
        public let accountGrouping: AccountGrouping
        ///  The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
        public let clientToken: String?
        ///  The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
        public let computationPreference: ComputationPreference
        /// The description of the billing group.
        public let description: String?
        ///  The billing group name. The names must be unique.
        public let name: String
        ///  The account ID that serves as the main account in a billing group.
        public let primaryAccountId: String?
        ///  A map that contains tag keys and tag values that are attached to a billing group. This feature isn't available during the beta.
        public let tags: [String: String]?

        @inlinable
        public init(accountGrouping: AccountGrouping, clientToken: String? = CreateBillingGroupInput.idempotencyToken(), computationPreference: ComputationPreference, description: String? = nil, name: String, primaryAccountId: String? = nil, tags: [String: String]? = nil) {
            self.accountGrouping = accountGrouping
            self.clientToken = clientToken
            self.computationPreference = computationPreference
            self.description = description
            self.name = name
            self.primaryAccountId = primaryAccountId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.accountGrouping, forKey: .accountGrouping)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.computationPreference, forKey: .computationPreference)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.primaryAccountId, forKey: .primaryAccountId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.accountGrouping.validate(name: "\(name).accountGrouping")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.computationPreference.validate(name: "\(name).computationPreference")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
            try self.validate(self.primaryAccountId, name: "primaryAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountGrouping = "AccountGrouping"
            case computationPreference = "ComputationPreference"
            case description = "Description"
            case name = "Name"
            case primaryAccountId = "PrimaryAccountId"
            case tags = "Tags"
        }
    }

    public struct CreateBillingGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created billing group.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct CreateCustomLineItemInput: AWSEncodableShape {
        /// The Amazon Web Services account in which this custom line item will be applied to.
        public let accountId: String?
        ///  The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
        public let billingGroupArn: String
        ///  A time range for which the custom line item is effective.
        public let billingPeriodRange: CustomLineItemBillingPeriodRange?
        ///  A CustomLineItemChargeDetails that describes the charge details for a custom line item.
        public let chargeDetails: CustomLineItemChargeDetails
        ///  The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
        public let clientToken: String?
        ///  The description of the custom line item. This is shown on the Bills page in association with the charge value.
        public let description: String
        ///  The name of the custom line item.
        public let name: String
        ///  A map that contains tag keys and tag values that are attached to a custom line item.
        public let tags: [String: String]?

        @inlinable
        public init(accountId: String? = nil, billingGroupArn: String, billingPeriodRange: CustomLineItemBillingPeriodRange? = nil, chargeDetails: CustomLineItemChargeDetails, clientToken: String? = CreateCustomLineItemInput.idempotencyToken(), description: String, name: String, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.billingGroupArn = billingGroupArn
            self.billingPeriodRange = billingPeriodRange
            self.chargeDetails = chargeDetails
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountId, forKey: .accountId)
            try container.encode(self.billingGroupArn, forKey: .billingGroupArn)
            try container.encodeIfPresent(self.billingPeriodRange, forKey: .billingPeriodRange)
            try container.encode(self.chargeDetails, forKey: .chargeDetails)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.billingGroupArn, name: "billingGroupArn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
            try self.chargeDetails.validate(name: "\(name).chargeDetails")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case billingGroupArn = "BillingGroupArn"
            case billingPeriodRange = "BillingPeriodRange"
            case chargeDetails = "ChargeDetails"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateCustomLineItemOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the created custom line item.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct CreateFreeTierConfig: AWSEncodableShape {
        ///  Activate or deactivate Amazon Web Services Free Tier.
        public let activated: Bool

        @inlinable
        public init(activated: Bool) {
            self.activated = activated
        }

        private enum CodingKeys: String, CodingKey {
            case activated = "Activated"
        }
    }

    public struct CreatePricingPlanInput: AWSEncodableShape {
        ///  The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
        public let clientToken: String?
        /// The description of the pricing plan.
        public let description: String?
        /// The name of the pricing plan. The names must be unique to each pricing plan.
        public let name: String
        ///  A list of Amazon Resource Names (ARNs) that define the pricing plan parameters.
        public let pricingRuleArns: [String]?
        ///  A map that contains tag keys and tag values that are attached to a pricing plan.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreatePricingPlanInput.idempotencyToken(), description: String? = nil, name: String, pricingRuleArns: [String]? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.pricingRuleArns = pricingRuleArns
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.pricingRuleArns, forKey: .pricingRuleArns)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
            try self.pricingRuleArns?.forEach {
                try validate($0, name: "pricingRuleArns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
            }
            try self.validate(self.pricingRuleArns, name: "pricingRuleArns", parent: name, max: 30)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case pricingRuleArns = "PricingRuleArns"
            case tags = "Tags"
        }
    }

    public struct CreatePricingPlanOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created pricing plan.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct CreatePricingRuleInput: AWSEncodableShape {
        ///  The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
        public let billingEntity: String?
        ///  The token that's needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
        public let clientToken: String?
        ///  The pricing rule description.
        public let description: String?
        ///  A percentage modifier that's applied on the public pricing rates.
        public let modifierPercentage: Double?
        ///  The pricing rule name. The names must be unique to each pricing rule.
        public let name: String
        ///  Operation is the specific Amazon Web Services action covered by this line item. This describes the specific usage of the line item.  If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
        public let operation: String?
        ///  The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
        public let scope: PricingRuleScope
        ///  If the Scope attribute is set to SERVICE or SKU, the attribute indicates which service the PricingRule is applicable for.
        public let service: String?
        ///  A map that contains tag keys and tag values that are attached to a pricing rule.
        public let tags: [String: String]?
        ///  The set of tiering configurations for the pricing rule.
        public let tiering: CreateTieringInput?
        ///  The type of pricing rule.
        public let type: PricingRuleType
        ///  Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
        public let usageType: String?

        @inlinable
        public init(billingEntity: String? = nil, clientToken: String? = CreatePricingRuleInput.idempotencyToken(), description: String? = nil, modifierPercentage: Double? = nil, name: String, operation: String? = nil, scope: PricingRuleScope, service: String? = nil, tags: [String: String]? = nil, tiering: CreateTieringInput? = nil, type: PricingRuleType, usageType: String? = nil) {
            self.billingEntity = billingEntity
            self.clientToken = clientToken
            self.description = description
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.operation = operation
            self.scope = scope
            self.service = service
            self.tags = tags
            self.tiering = tiering
            self.type = type
            self.usageType = usageType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.billingEntity, forKey: .billingEntity)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.modifierPercentage, forKey: .modifierPercentage)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.operation, forKey: .operation)
            try container.encode(self.scope, forKey: .scope)
            try container.encodeIfPresent(self.service, forKey: .service)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.tiering, forKey: .tiering)
            try container.encode(self.type, forKey: .type)
            try container.encodeIfPresent(self.usageType, forKey: .usageType)
        }

        public func validate(name: String) throws {
            try self.validate(self.billingEntity, name: "billingEntity", parent: name, pattern: "^[a-zA-Z0-9 ]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.modifierPercentage, name: "modifierPercentage", parent: name, min: 0.0)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
            try self.validate(self.operation, name: "operation", parent: name, max: 256)
            try self.validate(self.operation, name: "operation", parent: name, min: 1)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^\\S+$")
            try self.validate(self.service, name: "service", parent: name, max: 128)
            try self.validate(self.service, name: "service", parent: name, min: 1)
            try self.validate(self.service, name: "service", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.usageType, name: "usageType", parent: name, max: 256)
            try self.validate(self.usageType, name: "usageType", parent: name, min: 1)
            try self.validate(self.usageType, name: "usageType", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case billingEntity = "BillingEntity"
            case description = "Description"
            case modifierPercentage = "ModifierPercentage"
            case name = "Name"
            case operation = "Operation"
            case scope = "Scope"
            case service = "Service"
            case tags = "Tags"
            case tiering = "Tiering"
            case type = "Type"
            case usageType = "UsageType"
        }
    }

    public struct CreatePricingRuleOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the created pricing rule.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct CreateTieringInput: AWSEncodableShape {
        ///  The possible Amazon Web Services Free Tier configurations.
        public let freeTier: CreateFreeTierConfig

        @inlinable
        public init(freeTier: CreateFreeTierConfig) {
            self.freeTier = freeTier
        }

        private enum CodingKeys: String, CodingKey {
            case freeTier = "FreeTier"
        }
    }

    public struct CustomLineItemBillingPeriodRange: AWSEncodableShape {
        /// The inclusive end billing period that defines a billing period range where a custom line is applied.
        public let exclusiveEndBillingPeriod: String?
        /// The inclusive start billing period that defines a billing period range where a custom line is applied.
        public let inclusiveStartBillingPeriod: String

        @inlinable
        public init(exclusiveEndBillingPeriod: String? = nil, inclusiveStartBillingPeriod: String) {
            self.exclusiveEndBillingPeriod = exclusiveEndBillingPeriod
            self.inclusiveStartBillingPeriod = inclusiveStartBillingPeriod
        }

        public func validate(name: String) throws {
            try self.validate(self.exclusiveEndBillingPeriod, name: "exclusiveEndBillingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.validate(self.inclusiveStartBillingPeriod, name: "inclusiveStartBillingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
        }

        private enum CodingKeys: String, CodingKey {
            case exclusiveEndBillingPeriod = "ExclusiveEndBillingPeriod"
            case inclusiveStartBillingPeriod = "InclusiveStartBillingPeriod"
        }
    }

    public struct CustomLineItemChargeDetails: AWSEncodableShape {
        /// A CustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public let flat: CustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public let lineItemFilters: [LineItemFilter]?
        /// A CustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public let percentage: CustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        public let type: CustomLineItemType

        @inlinable
        public init(flat: CustomLineItemFlatChargeDetails? = nil, lineItemFilters: [LineItemFilter]? = nil, percentage: CustomLineItemPercentageChargeDetails? = nil, type: CustomLineItemType) {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
            self.type = type
        }

        public func validate(name: String) throws {
            try self.flat?.validate(name: "\(name).flat")
            try self.lineItemFilters?.forEach {
                try $0.validate(name: "\(name).lineItemFilters[]")
            }
            try self.validate(self.lineItemFilters, name: "lineItemFilters", parent: name, max: 1)
            try self.percentage?.validate(name: "\(name).percentage")
        }

        private enum CodingKeys: String, CodingKey {
            case flat = "Flat"
            case lineItemFilters = "LineItemFilters"
            case percentage = "Percentage"
            case type = "Type"
        }
    }

    public struct CustomLineItemFlatChargeDetails: AWSEncodableShape {
        /// The custom line item's fixed charge value in USD.
        public let chargeValue: Double

        @inlinable
        public init(chargeValue: Double) {
            self.chargeValue = chargeValue
        }

        public func validate(name: String) throws {
            try self.validate(self.chargeValue, name: "chargeValue", parent: name, max: 1000000.0)
            try self.validate(self.chargeValue, name: "chargeValue", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case chargeValue = "ChargeValue"
        }
    }

    public struct CustomLineItemListElement: AWSDecodableShape {
        /// The Amazon Web Services account in which this custom line item will be applied to.
        public let accountId: String?
        /// The Amazon Resource Names (ARNs) for custom line items.
        public let arn: String?
        /// The number of resources that are associated to the custom line item.
        public let associationSize: Int64?
        /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
        public let billingGroupArn: String?
        /// A ListCustomLineItemChargeDetails that describes the charge details of a custom line item.
        public let chargeDetails: ListCustomLineItemChargeDetails?
        /// The time created.
        public let creationTime: Int64?
        /// The custom line item's charge value currency. Only one of the valid values can be used.
        public let currencyCode: CurrencyCode?
        /// The custom line item's description. This is shown on the Bills page in association with the charge value.
        public let description: String?
        /// The most recent time when the custom line item was modified.
        public let lastModifiedTime: Int64?
        /// The custom line item's name.
        public let name: String?
        /// The product code that's associated with the custom line item.
        public let productCode: String?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, associationSize: Int64? = nil, billingGroupArn: String? = nil, chargeDetails: ListCustomLineItemChargeDetails? = nil, creationTime: Int64? = nil, currencyCode: CurrencyCode? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil, productCode: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case arn = "Arn"
            case associationSize = "AssociationSize"
            case billingGroupArn = "BillingGroupArn"
            case chargeDetails = "ChargeDetails"
            case creationTime = "CreationTime"
            case currencyCode = "CurrencyCode"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case productCode = "ProductCode"
        }
    }

    public struct CustomLineItemPercentageChargeDetails: AWSEncodableShape {
        /// A list of resource ARNs to associate to the percentage custom line item.
        public let associatedValues: [String]?
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        public let percentageValue: Double

        @inlinable
        public init(associatedValues: [String]? = nil, percentageValue: Double) {
            self.associatedValues = associatedValues
            self.percentageValue = percentageValue
        }

        public func validate(name: String) throws {
            try self.associatedValues?.forEach {
                try validate($0, name: "associatedValues[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:(customlineitem|billinggroup)/)?[a-zA-Z0-9]{10,12}$")
            }
            try self.validate(self.associatedValues, name: "associatedValues", parent: name, max: 5)
            try self.validate(self.percentageValue, name: "percentageValue", parent: name, max: 10000.0)
            try self.validate(self.percentageValue, name: "percentageValue", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case associatedValues = "AssociatedValues"
            case percentageValue = "PercentageValue"
        }
    }

    public struct CustomLineItemVersionListElement: AWSDecodableShape {
        /// The Amazon Web Services account in which this custom line item will be applied to.
        public let accountId: String?
        ///  A list of custom line item Amazon Resource Names (ARNs) to retrieve information.
        public let arn: String?
        /// The number of resources that are associated with the custom line item.
        public let associationSize: Int64?
        /// The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.
        public let billingGroupArn: String?
        public let chargeDetails: ListCustomLineItemChargeDetails?
        /// The time when the custom line item version was created.
        public let creationTime: Int64?
        /// The charge value currency of the custom line item.
        public let currencyCode: CurrencyCode?
        /// The description of the custom line item.
        public let description: String?
        /// The end billing period of the custom line item version.
        public let endBillingPeriod: String?
        /// The most recent time that the custom line item version was modified.
        public let lastModifiedTime: Int64?
        /// The name of the custom line item.
        public let name: String?
        /// The product code thats associated with the custom line item.
        public let productCode: String?
        /// The start billing period of the custom line item version.
        public let startBillingPeriod: String?
        ///  The inclusive start time.
        public let startTime: Int64?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, associationSize: Int64? = nil, billingGroupArn: String? = nil, chargeDetails: ListCustomLineItemChargeDetails? = nil, creationTime: Int64? = nil, currencyCode: CurrencyCode? = nil, description: String? = nil, endBillingPeriod: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil, productCode: String? = nil, startBillingPeriod: String? = nil, startTime: Int64? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.endBillingPeriod = endBillingPeriod
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
            self.startBillingPeriod = startBillingPeriod
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case arn = "Arn"
            case associationSize = "AssociationSize"
            case billingGroupArn = "BillingGroupArn"
            case chargeDetails = "ChargeDetails"
            case creationTime = "CreationTime"
            case currencyCode = "CurrencyCode"
            case description = "Description"
            case endBillingPeriod = "EndBillingPeriod"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case productCode = "ProductCode"
            case startBillingPeriod = "StartBillingPeriod"
            case startTime = "StartTime"
        }
    }

    public struct DeleteBillingGroupInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the billing group that you're deleting.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeleteBillingGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted billing group.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeleteCustomLineItemInput: AWSEncodableShape {
        ///  The ARN of the custom line item to be deleted.
        public let arn: String
        public let billingPeriodRange: CustomLineItemBillingPeriodRange?

        @inlinable
        public init(arn: String, billingPeriodRange: CustomLineItemBillingPeriodRange? = nil) {
            self.arn = arn
            self.billingPeriodRange = billingPeriodRange
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case billingPeriodRange = "BillingPeriodRange"
        }
    }

    public struct DeleteCustomLineItemOutput: AWSDecodableShape {
        /// The ARN of the deleted custom line item.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeletePricingPlanInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pricing plan that you're deleting.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeletePricingPlanOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the deleted pricing plan.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeletePricingRuleInput: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the pricing rule that you are deleting.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeletePricingRuleOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the deleted pricing rule.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DisassociateAccountsInput: AWSEncodableShape {
        /// The array of account IDs to disassociate.
        public let accountIds: [String]
        /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs will disassociate from.
        public let arn: String

        @inlinable
        public init(accountIds: [String], arn: String) {
            self.accountIds = accountIds
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 30)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case arn = "Arn"
        }
    }

    public struct DisassociateAccountsOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs is disassociated from.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DisassociatePricingRulesInput: AWSEncodableShape {
        ///  The pricing plan Amazon Resource Name (ARN) to disassociate pricing rules from.
        public let arn: String
        ///  A list containing the Amazon Resource Name (ARN) of the pricing rules that will be disassociated.
        public let pricingRuleArns: [String]

        @inlinable
        public init(arn: String, pricingRuleArns: [String]) {
            self.arn = arn
            self.pricingRuleArns = pricingRuleArns
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/)?[a-zA-Z0-9]{10}$")
            try self.pricingRuleArns.forEach {
                try validate($0, name: "pricingRuleArns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
            }
            try self.validate(self.pricingRuleArns, name: "pricingRuleArns", parent: name, max: 30)
            try self.validate(self.pricingRuleArns, name: "pricingRuleArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case pricingRuleArns = "PricingRuleArns"
        }
    }

    public struct DisassociatePricingRulesOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the pricing plan that the pricing rules successfully disassociated from.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DisassociateResourceResponseElement: AWSDecodableShape {
        /// The resource ARN that was disassociated from the custom line item.
        public let arn: String?
        ///  An AssociateResourceError that's shown if the resource disassociation fails.
        public let error: AssociateResourceError?

        @inlinable
        public init(arn: String? = nil, error: AssociateResourceError? = nil) {
            self.arn = arn
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case error = "Error"
        }
    }

    public struct FreeTierConfig: AWSDecodableShape {
        ///  Activate or deactivate Amazon Web Services Free Tier application.
        public let activated: Bool

        @inlinable
        public init(activated: Bool) {
            self.activated = activated
        }

        private enum CodingKeys: String, CodingKey {
            case activated = "Activated"
        }
    }

    public struct GetBillingGroupCostReportInput: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) that uniquely identifies the billing group.
        public let arn: String
        /// A time range for which the margin summary is effective. You can specify up to 12 months.
        public let billingPeriodRange: BillingPeriodRange?
        /// A list of strings that specify the attributes that are used to break down costs in the margin summary reports for the billing group. For example, you can view your costs by the Amazon Web Service name or the billing period.
        public let groupBy: [GroupByAttributeName]?
        /// The maximum number of margin summary reports to retrieve.
        public let maxResults: Int?
        /// The pagination token used on subsequent calls to get reports.
        public let nextToken: String?

        @inlinable
        public init(arn: String, billingPeriodRange: BillingPeriodRange? = nil, groupBy: [GroupByAttributeName]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.billingPeriodRange = billingPeriodRange
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 300)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case billingPeriodRange = "BillingPeriodRange"
            case groupBy = "GroupBy"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetBillingGroupCostReportOutput: AWSDecodableShape {
        /// The list of margin summary reports.
        public let billingGroupCostReportResults: [BillingGroupCostReportResultElement]?
        /// The pagination token used on subsequent calls to get reports.
        public let nextToken: String?

        @inlinable
        public init(billingGroupCostReportResults: [BillingGroupCostReportResultElement]? = nil, nextToken: String? = nil) {
            self.billingGroupCostReportResults = billingGroupCostReportResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case billingGroupCostReportResults = "BillingGroupCostReportResults"
            case nextToken = "NextToken"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// Number of seconds you can retry after the call.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct LineItemFilter: AWSEncodableShape & AWSDecodableShape {
        /// The attribute of the line item filter. This specifies what attribute that you can filter on.
        public let attribute: LineItemFilterAttributeName
        /// The match criteria of the line item filter. This parameter specifies whether not to include the resource value from the billing group total cost.
        public let matchOption: MatchOption
        /// The values of the line item filter. This specifies the values to filter on. Currently, you can only exclude Savings Plan discounts.
        public let values: [LineItemFilterValue]

        @inlinable
        public init(attribute: LineItemFilterAttributeName, matchOption: MatchOption, values: [LineItemFilterValue]) {
            self.attribute = attribute
            self.matchOption = matchOption
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
            case matchOption = "MatchOption"
            case values = "Values"
        }
    }

    public struct ListAccountAssociationsFilter: AWSEncodableShape {
        /// The Amazon Web Services account ID to filter on.
        public let accountId: String?
        ///  The list of Amazon Web Services IDs to retrieve their associated billing group for a given time range.
        public let accountIds: [String]?
        ///  MONITORED: linked accounts that are associated to billing groups.  UNMONITORED: linked accounts that are not associated to billing groups.  Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
        public let association: String?

        @inlinable
        public init(accountId: String? = nil, accountIds: [String]? = nil, association: String? = nil) {
            self.accountId = accountId
            self.accountIds = accountIds
            self.association = association
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 30)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.association, name: "association", parent: name, pattern: "^((arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}|MONITORED|UNMONITORED)$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case accountIds = "AccountIds"
            case association = "Association"
        }
    }

    public struct ListAccountAssociationsInput: AWSEncodableShape {
        ///  The preferred billing period to get account associations.
        public let billingPeriod: String?
        /// The filter on the account ID of the linked account, or any of the following:  MONITORED: linked accounts that are associated to billing groups.  UNMONITORED: linked accounts that aren't associated to billing groups.  Billing Group Arn: linked accounts that are associated to the provided billing group Arn.
        public let filters: ListAccountAssociationsFilter?
        ///  The pagination token that's used on subsequent calls to retrieve accounts.
        public let nextToken: String?

        @inlinable
        public init(billingPeriod: String? = nil, filters: ListAccountAssociationsFilter? = nil, nextToken: String? = nil) {
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.filters?.validate(name: "\(name).filters")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case nextToken = "NextToken"
        }
    }

    public struct ListAccountAssociationsOutput: AWSDecodableShape {
        ///  The list of linked accounts in the payer account.
        public let linkedAccounts: [AccountAssociationsListElement]?
        ///  The pagination token that's used on subsequent calls to get accounts.
        public let nextToken: String?

        @inlinable
        public init(linkedAccounts: [AccountAssociationsListElement]? = nil, nextToken: String? = nil) {
            self.linkedAccounts = linkedAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case linkedAccounts = "LinkedAccounts"
            case nextToken = "NextToken"
        }
    }

    public struct ListBillingGroupAccountGrouping: AWSDecodableShape {
        /// Specifies if this billing group will automatically associate newly added
        /// Amazon Web Services accounts that join your consolidated billing family.
        public let autoAssociate: Bool?

        @inlinable
        public init(autoAssociate: Bool? = nil) {
            self.autoAssociate = autoAssociate
        }

        private enum CodingKeys: String, CodingKey {
            case autoAssociate = "AutoAssociate"
        }
    }

    public struct ListBillingGroupCostReportsFilter: AWSEncodableShape {
        /// The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports.
        public let billingGroupArns: [String]?

        @inlinable
        public init(billingGroupArns: [String]? = nil) {
            self.billingGroupArns = billingGroupArns
        }

        public func validate(name: String) throws {
            try self.billingGroupArns?.forEach {
                try validate($0, name: "billingGroupArns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
            }
            try self.validate(self.billingGroupArns, name: "billingGroupArns", parent: name, max: 100)
            try self.validate(self.billingGroupArns, name: "billingGroupArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billingGroupArns = "BillingGroupArns"
        }
    }

    public struct ListBillingGroupCostReportsInput: AWSEncodableShape {
        /// The preferred billing period for your report.
        public let billingPeriod: String?
        /// A ListBillingGroupCostReportsFilter to specify billing groups to retrieve reports from.
        public let filters: ListBillingGroupCostReportsFilter?
        /// The maximum number of reports to retrieve.
        public let maxResults: Int?
        /// The pagination token that's used on subsequent calls to get reports.
        public let nextToken: String?

        @inlinable
        public init(billingPeriod: String? = nil, filters: ListBillingGroupCostReportsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListBillingGroupCostReportsOutput: AWSDecodableShape {
        /// A list of BillingGroupCostReportElement retrieved.
        public let billingGroupCostReports: [BillingGroupCostReportElement]?
        /// The pagination token that's used on subsequent calls to get reports.
        public let nextToken: String?

        @inlinable
        public init(billingGroupCostReports: [BillingGroupCostReportElement]? = nil, nextToken: String? = nil) {
            self.billingGroupCostReports = billingGroupCostReports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case billingGroupCostReports = "BillingGroupCostReports"
            case nextToken = "NextToken"
        }
    }

    public struct ListBillingGroupsFilter: AWSEncodableShape {
        /// The list of billing group Amazon Resource Names (ARNs) to retrieve information.
        public let arns: [String]?
        /// Specifies if this billing group will automatically associate newly added
        /// Amazon Web Services accounts that join your consolidated billing family.
        public let autoAssociate: Bool?
        /// The pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public let pricingPlan: String?
        ///  A list of billing groups to retrieve their current status for a specific time range
        public let statuses: [BillingGroupStatus]?

        @inlinable
        public init(arns: [String]? = nil, autoAssociate: Bool? = nil, pricingPlan: String? = nil, statuses: [BillingGroupStatus]? = nil) {
            self.arns = arns
            self.autoAssociate = autoAssociate
            self.pricingPlan = pricingPlan
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.arns?.forEach {
                try validate($0, name: "arns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
            }
            try self.validate(self.arns, name: "arns", parent: name, max: 100)
            try self.validate(self.arns, name: "arns", parent: name, min: 1)
            try self.validate(self.pricingPlan, name: "pricingPlan", parent: name, pattern: "^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/[a-zA-Z0-9]{10}$")
            try self.validate(self.statuses, name: "statuses", parent: name, max: 2)
            try self.validate(self.statuses, name: "statuses", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arns = "Arns"
            case autoAssociate = "AutoAssociate"
            case pricingPlan = "PricingPlan"
            case statuses = "Statuses"
        }
    }

    public struct ListBillingGroupsInput: AWSEncodableShape {
        /// The preferred billing period to get billing groups.
        public let billingPeriod: String?
        /// A ListBillingGroupsFilter that specifies the billing group and pricing plan to retrieve billing group information.
        public let filters: ListBillingGroupsFilter?
        /// The maximum number of billing groups to retrieve.
        public let maxResults: Int?
        /// The pagination token that's used on subsequent calls to get billing groups.
        public let nextToken: String?

        @inlinable
        public init(billingPeriod: String? = nil, filters: ListBillingGroupsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListBillingGroupsOutput: AWSDecodableShape {
        /// A list of BillingGroupListElement retrieved.
        public let billingGroups: [BillingGroupListElement]?
        /// The pagination token that's used on subsequent calls to get billing groups.
        public let nextToken: String?

        @inlinable
        public init(billingGroups: [BillingGroupListElement]? = nil, nextToken: String? = nil) {
            self.billingGroups = billingGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case billingGroups = "BillingGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomLineItemChargeDetails: AWSDecodableShape {
        ///  A ListCustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public let flat: ListCustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public let lineItemFilters: [LineItemFilter]?
        ///  A ListCustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public let percentage: ListCustomLineItemPercentageChargeDetails?
        ///  The type of the custom line item that indicates whether the charge is a fee or credit.
        public let type: CustomLineItemType

        @inlinable
        public init(flat: ListCustomLineItemFlatChargeDetails? = nil, lineItemFilters: [LineItemFilter]? = nil, percentage: ListCustomLineItemPercentageChargeDetails? = nil, type: CustomLineItemType) {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case flat = "Flat"
            case lineItemFilters = "LineItemFilters"
            case percentage = "Percentage"
            case type = "Type"
        }
    }

    public struct ListCustomLineItemFlatChargeDetails: AWSDecodableShape {
        ///  The custom line item's fixed charge value in USD.
        public let chargeValue: Double

        @inlinable
        public init(chargeValue: Double) {
            self.chargeValue = chargeValue
        }

        private enum CodingKeys: String, CodingKey {
            case chargeValue = "ChargeValue"
        }
    }

    public struct ListCustomLineItemPercentageChargeDetails: AWSDecodableShape {
        ///  The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        public let percentageValue: Double

        @inlinable
        public init(percentageValue: Double) {
            self.percentageValue = percentageValue
        }

        private enum CodingKeys: String, CodingKey {
            case percentageValue = "PercentageValue"
        }
    }

    public struct ListCustomLineItemVersionsBillingPeriodRangeFilter: AWSEncodableShape {
        /// The exclusive end billing period that defines a billing period range where a  custom line item version is applied.
        public let endBillingPeriod: String?
        /// The inclusive start billing period that defines a billing period range where  a custom line item version is applied.
        public let startBillingPeriod: String?

        @inlinable
        public init(endBillingPeriod: String? = nil, startBillingPeriod: String? = nil) {
            self.endBillingPeriod = endBillingPeriod
            self.startBillingPeriod = startBillingPeriod
        }

        public func validate(name: String) throws {
            try self.validate(self.endBillingPeriod, name: "endBillingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.validate(self.startBillingPeriod, name: "startBillingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
        }

        private enum CodingKeys: String, CodingKey {
            case endBillingPeriod = "EndBillingPeriod"
            case startBillingPeriod = "StartBillingPeriod"
        }
    }

    public struct ListCustomLineItemVersionsFilter: AWSEncodableShape {
        /// The billing period range in which the custom line item version is applied.
        public let billingPeriodRange: ListCustomLineItemVersionsBillingPeriodRangeFilter?

        @inlinable
        public init(billingPeriodRange: ListCustomLineItemVersionsBillingPeriodRangeFilter? = nil) {
            self.billingPeriodRange = billingPeriodRange
        }

        public func validate(name: String) throws {
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriodRange = "BillingPeriodRange"
        }
    }

    public struct ListCustomLineItemVersionsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the custom line item.
        public let arn: String
        /// A ListCustomLineItemVersionsFilter that specifies the billing period range in which the custom line item versions are applied.
        public let filters: ListCustomLineItemVersionsFilter?
        /// The maximum number of custom line item versions to retrieve.
        public let maxResults: Int?
        /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
        public let nextToken: String?

        @inlinable
        public init(arn: String, filters: ListCustomLineItemVersionsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomLineItemVersionsOutput: AWSDecodableShape {
        /// A list of CustomLineItemVersionListElements that are received.
        public let customLineItemVersions: [CustomLineItemVersionListElement]?
        /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
        public let nextToken: String?

        @inlinable
        public init(customLineItemVersions: [CustomLineItemVersionListElement]? = nil, nextToken: String? = nil) {
            self.customLineItemVersions = customLineItemVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customLineItemVersions = "CustomLineItemVersions"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomLineItemsFilter: AWSEncodableShape {
        /// The Amazon Web Services accounts in which this custom line item will be applied to.
        public let accountIds: [String]?
        /// A list of custom line item ARNs to retrieve information.
        public let arns: [String]?
        /// The billing group Amazon Resource Names (ARNs) to retrieve information.
        public let billingGroups: [String]?
        /// A list of custom line items to retrieve information.
        public let names: [String]?

        @inlinable
        public init(accountIds: [String]? = nil, arns: [String]? = nil, billingGroups: [String]? = nil, names: [String]? = nil) {
            self.accountIds = accountIds
            self.arns = arns
            self.billingGroups = billingGroups
            self.names = names
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 30)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.arns?.forEach {
                try validate($0, name: "arns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            }
            try self.validate(self.arns, name: "arns", parent: name, max: 100)
            try self.validate(self.arns, name: "arns", parent: name, min: 1)
            try self.billingGroups?.forEach {
                try validate($0, name: "billingGroups[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
            }
            try self.validate(self.billingGroups, name: "billingGroups", parent: name, max: 100)
            try self.validate(self.billingGroups, name: "billingGroups", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, max: 128)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 100)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case arns = "Arns"
            case billingGroups = "BillingGroups"
            case names = "Names"
        }
    }

    public struct ListCustomLineItemsInput: AWSEncodableShape {
        ///  The preferred billing period to get custom line items (FFLIs).
        public let billingPeriod: String?
        /// A ListCustomLineItemsFilter that specifies the custom line item names and/or billing group Amazon Resource Names (ARNs) to retrieve FFLI information.
        public let filters: ListCustomLineItemsFilter?
        ///  The maximum number of billing groups to retrieve.
        public let maxResults: Int?
        ///  The pagination token that's used on subsequent calls to get custom line items (FFLIs).
        public let nextToken: String?

        @inlinable
        public init(billingPeriod: String? = nil, filters: ListCustomLineItemsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomLineItemsOutput: AWSDecodableShape {
        ///  A list of FreeFormLineItemListElements received.
        public let customLineItems: [CustomLineItemListElement]?
        ///  The pagination token that's used on subsequent calls to get custom line items (FFLIs).
        public let nextToken: String?

        @inlinable
        public init(customLineItems: [CustomLineItemListElement]? = nil, nextToken: String? = nil) {
            self.customLineItems = customLineItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customLineItems = "CustomLineItems"
            case nextToken = "NextToken"
        }
    }

    public struct ListPricingPlansAssociatedWithPricingRuleInput: AWSEncodableShape {
        ///  The pricing plan billing period for which associations will be listed.
        public let billingPeriod: String?
        ///  The optional maximum number of pricing rule associations to retrieve.
        public let maxResults: Int?
        ///  The optional pagination token returned by a previous call.
        public let nextToken: String?
        ///  The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
        public let pricingRuleArn: String

        @inlinable
        public init(billingPeriod: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, pricingRuleArn: String) {
            self.billingPeriod = billingPeriod
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pricingRuleArn = pricingRuleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.pricingRuleArn, name: "pricingRuleArn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pricingRuleArn = "PricingRuleArn"
        }
    }

    public struct ListPricingPlansAssociatedWithPricingRuleOutput: AWSDecodableShape {
        ///  The pricing plan billing period for which associations will be listed.
        public let billingPeriod: String?
        ///  The pagination token to be used on subsequent calls.
        public let nextToken: String?
        ///  The list containing pricing plans that are associated with the requested pricing rule.
        public let pricingPlanArns: [String]?
        ///  The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
        public let pricingRuleArn: String?

        @inlinable
        public init(billingPeriod: String? = nil, nextToken: String? = nil, pricingPlanArns: [String]? = nil, pricingRuleArn: String? = nil) {
            self.billingPeriod = billingPeriod
            self.nextToken = nextToken
            self.pricingPlanArns = pricingPlanArns
            self.pricingRuleArn = pricingRuleArn
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case nextToken = "NextToken"
            case pricingPlanArns = "PricingPlanArns"
            case pricingRuleArn = "PricingRuleArn"
        }
    }

    public struct ListPricingPlansFilter: AWSEncodableShape {
        /// A list of pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public let arns: [String]?

        @inlinable
        public init(arns: [String]? = nil) {
            self.arns = arns
        }

        public func validate(name: String) throws {
            try self.arns?.forEach {
                try validate($0, name: "arns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/)?[a-zA-Z0-9]{10}$")
            }
            try self.validate(self.arns, name: "arns", parent: name, max: 100)
            try self.validate(self.arns, name: "arns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arns = "Arns"
        }
    }

    public struct ListPricingPlansInput: AWSEncodableShape {
        /// The preferred billing period to get pricing plan.
        public let billingPeriod: String?
        /// A ListPricingPlansFilter that specifies the Amazon Resource Name (ARNs) of pricing plans to retrieve pricing plans information.
        public let filters: ListPricingPlansFilter?
        /// The maximum number of pricing plans to retrieve.
        public let maxResults: Int?
        /// The pagination token that's used on subsequent call to get pricing plans.
        public let nextToken: String?

        @inlinable
        public init(billingPeriod: String? = nil, filters: ListPricingPlansFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPricingPlansOutput: AWSDecodableShape {
        ///  The billing period for which the described pricing plans are applicable.
        public let billingPeriod: String?
        /// The pagination token that's used on subsequent calls to get pricing plans.
        public let nextToken: String?
        /// A list of PricingPlanListElement retrieved.
        public let pricingPlans: [PricingPlanListElement]?

        @inlinable
        public init(billingPeriod: String? = nil, nextToken: String? = nil, pricingPlans: [PricingPlanListElement]? = nil) {
            self.billingPeriod = billingPeriod
            self.nextToken = nextToken
            self.pricingPlans = pricingPlans
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case nextToken = "NextToken"
            case pricingPlans = "PricingPlans"
        }
    }

    public struct ListPricingRulesAssociatedToPricingPlanInput: AWSEncodableShape {
        ///  The billing period for which the pricing rule associations are to be listed.
        public let billingPeriod: String?
        /// The optional maximum number of pricing rule associations to retrieve.
        public let maxResults: Int?
        ///  The optional pagination token returned by a previous call.
        public let nextToken: String?
        ///  The Amazon Resource Name (ARN) of the pricing plan for which associations are to be listed.
        public let pricingPlanArn: String

        @inlinable
        public init(billingPeriod: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, pricingPlanArn: String) {
            self.billingPeriod = billingPeriod
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pricingPlanArn = pricingPlanArn
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.pricingPlanArn, name: "pricingPlanArn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pricingPlanArn = "PricingPlanArn"
        }
    }

    public struct ListPricingRulesAssociatedToPricingPlanOutput: AWSDecodableShape {
        ///  The billing period for which the pricing rule associations are listed.
        public let billingPeriod: String?
        ///  The pagination token to be used on subsequent calls.
        public let nextToken: String?
        ///  The Amazon Resource Name (ARN) of the pricing plan for which associations are listed.
        public let pricingPlanArn: String?
        ///  A list containing pricing rules that are associated with the requested pricing plan.
        public let pricingRuleArns: [String]?

        @inlinable
        public init(billingPeriod: String? = nil, nextToken: String? = nil, pricingPlanArn: String? = nil, pricingRuleArns: [String]? = nil) {
            self.billingPeriod = billingPeriod
            self.nextToken = nextToken
            self.pricingPlanArn = pricingPlanArn
            self.pricingRuleArns = pricingRuleArns
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case nextToken = "NextToken"
            case pricingPlanArn = "PricingPlanArn"
            case pricingRuleArns = "PricingRuleArns"
        }
    }

    public struct ListPricingRulesFilter: AWSEncodableShape {
        /// A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response.
        public let arns: [String]?

        @inlinable
        public init(arns: [String]? = nil) {
            self.arns = arns
        }

        public func validate(name: String) throws {
            try self.arns?.forEach {
                try validate($0, name: "arns[]", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
            }
            try self.validate(self.arns, name: "arns", parent: name, max: 100)
            try self.validate(self.arns, name: "arns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arns = "Arns"
        }
    }

    public struct ListPricingRulesInput: AWSEncodableShape {
        ///  The preferred billing period to get the pricing plan.
        public let billingPeriod: String?
        ///  A DescribePricingRuleFilter that specifies the Amazon Resource Name (ARNs) of pricing rules to retrieve pricing rules information.
        public let filters: ListPricingRulesFilter?
        ///  The maximum number of pricing rules to retrieve.
        public let maxResults: Int?
        ///  The pagination token that's used on subsequent call to get pricing rules.
        public let nextToken: String?

        @inlinable
        public init(billingPeriod: String? = nil, filters: ListPricingRulesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPricingRulesOutput: AWSDecodableShape {
        ///  The billing period for which the described pricing rules are applicable.
        public let billingPeriod: String?
        ///  The pagination token that's used on subsequent calls to get pricing rules.
        public let nextToken: String?
        ///  A list containing the described pricing rules.
        public let pricingRules: [PricingRuleListElement]?

        @inlinable
        public init(billingPeriod: String? = nil, nextToken: String? = nil, pricingRules: [PricingRuleListElement]? = nil) {
            self.billingPeriod = billingPeriod
            self.nextToken = nextToken
            self.pricingRules = pricingRules
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case nextToken = "NextToken"
            case pricingRules = "PricingRules"
        }
    }

    public struct ListResourcesAssociatedToCustomLineItemFilter: AWSEncodableShape {
        ///  The type of relationship between the custom line item and the associated resource.
        public let relationship: CustomLineItemRelationship?

        @inlinable
        public init(relationship: CustomLineItemRelationship? = nil) {
            self.relationship = relationship
        }

        private enum CodingKeys: String, CodingKey {
            case relationship = "Relationship"
        }
    }

    public struct ListResourcesAssociatedToCustomLineItemInput: AWSEncodableShape {
        ///  The ARN of the custom line item for which the resource associations will be listed.
        public let arn: String
        ///  The billing period for which the resource associations will be listed.
        public let billingPeriod: String?
        ///  (Optional) A ListResourcesAssociatedToCustomLineItemFilter that can specify the types of resources that should be retrieved.
        public let filters: ListResourcesAssociatedToCustomLineItemFilter?
        ///  (Optional) The maximum number of resource associations to be retrieved.
        public let maxResults: Int?
        ///  (Optional) The pagination token that's returned by a previous request.
        public let nextToken: String?

        @inlinable
        public init(arn: String, billingPeriod: String? = nil, filters: ListResourcesAssociatedToCustomLineItemFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.billingPeriod = billingPeriod
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            try self.validate(self.billingPeriod, name: "billingPeriod", parent: name, pattern: "^\\d{4}-(0?[1-9]|1[012])$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case billingPeriod = "BillingPeriod"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourcesAssociatedToCustomLineItemOutput: AWSDecodableShape {
        ///  The custom line item ARN for which the resource associations are listed.
        public let arn: String?
        ///  A list of ListResourcesAssociatedToCustomLineItemResponseElement for each resource association retrieved.
        public let associatedResources: [ListResourcesAssociatedToCustomLineItemResponseElement]?
        ///  The pagination token to be used in subsequent requests to retrieve additional results.
        public let nextToken: String?

        @inlinable
        public init(arn: String? = nil, associatedResources: [ListResourcesAssociatedToCustomLineItemResponseElement]? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.associatedResources = associatedResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedResources = "AssociatedResources"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourcesAssociatedToCustomLineItemResponseElement: AWSDecodableShape {
        ///  The ARN of the associated resource.
        public let arn: String?
        /// The end billing period of the associated resource.
        public let endBillingPeriod: String?
        ///  The type of relationship between the custom line item and the associated resource.
        public let relationship: CustomLineItemRelationship?

        @inlinable
        public init(arn: String? = nil, endBillingPeriod: String? = nil, relationship: CustomLineItemRelationship? = nil) {
            self.arn = arn
            self.endBillingPeriod = endBillingPeriod
            self.relationship = relationship
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case endBillingPeriod = "EndBillingPeriod"
            case relationship = "Relationship"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) that identifies the resource to list the tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/?[0-9]{12}$|^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/[a-zA-Z0-9]{10}$|^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/[a-zA-Z0-9]{10}$|^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The tags for the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct PricingPlanListElement: AWSDecodableShape {
        /// The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan.
        public let arn: String?
        /// The time when the pricing plan was created.
        public let creationTime: Int64?
        /// The pricing plan description.
        public let description: String?
        /// The most recent time when the pricing plan was modified.
        public let lastModifiedTime: Int64?
        /// The name of a pricing plan.
        public let name: String?
        /// The pricing rules count that's currently associated with this pricing plan list element.
        public let size: Int64?

        @inlinable
        public init(arn: String? = nil, creationTime: Int64? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil, size: Int64? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case size = "Size"
        }
    }

    public struct PricingRuleListElement: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) used to uniquely identify a pricing rule.
        public let arn: String?
        /// The pricing plans count that this pricing rule is associated with.
        public let associatedPricingPlanCount: Int64?
        ///  The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
        public let billingEntity: String?
        /// The time when the pricing rule was created.
        public let creationTime: Int64?
        /// The pricing rule description.
        public let description: String?
        ///  The most recent time when the pricing rule was modified.
        public let lastModifiedTime: Int64?
        /// A percentage modifier applied on the public pricing rates.
        public let modifierPercentage: Double?
        /// The name of a pricing rule.
        public let name: String?
        ///  Operation is the specific Amazon Web Services action covered by this line item. This describes the specific usage of the line item.  If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
        public let operation: String?
        /// The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific.
        public let scope: PricingRuleScope?
        /// If the Scope attribute is SERVICE, this attribute indicates which service the PricingRule is applicable for.
        public let service: String?
        ///  The set of tiering configurations for the pricing rule.
        public let tiering: Tiering?
        /// The type of pricing rule.
        public let type: PricingRuleType?
        ///  Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
        public let usageType: String?

        @inlinable
        public init(arn: String? = nil, associatedPricingPlanCount: Int64? = nil, billingEntity: String? = nil, creationTime: Int64? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, modifierPercentage: Double? = nil, name: String? = nil, operation: String? = nil, scope: PricingRuleScope? = nil, service: String? = nil, tiering: Tiering? = nil, type: PricingRuleType? = nil, usageType: String? = nil) {
            self.arn = arn
            self.associatedPricingPlanCount = associatedPricingPlanCount
            self.billingEntity = billingEntity
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.operation = operation
            self.scope = scope
            self.service = service
            self.tiering = tiering
            self.type = type
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedPricingPlanCount = "AssociatedPricingPlanCount"
            case billingEntity = "BillingEntity"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case modifierPercentage = "ModifierPercentage"
            case name = "Name"
            case operation = "Operation"
            case scope = "Scope"
            case service = "Service"
            case tiering = "Tiering"
            case type = "Type"
            case usageType = "UsageType"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// Resource identifier that was not found.
        public let resourceId: String
        /// Resource type that was not found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ServiceLimitExceededException: AWSErrorShape {
        /// The unique code identifier of the service limit that is being exceeded.
        public let limitCode: String
        public let message: String
        /// Identifier of the resource affected.
        public let resourceId: String?
        /// Type of the resource affected.
        public let resourceType: String?
        /// The unique code for the service of the limit that is being exceeded.
        public let serviceCode: String

        @inlinable
        public init(limitCode: String, message: String, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String) {
            self.limitCode = limitCode
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case limitCode = "LimitCode"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case serviceCode = "ServiceCode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource to which to add tags.
        public let resourceArn: String
        ///  The tags to add to the resource as a list of key-value pairs.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/?[0-9]{12}$|^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/[a-zA-Z0-9]{10}$|^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/[a-zA-Z0-9]{10}$|^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// Number of seconds you can safely retry after the call.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct Tiering: AWSDecodableShape {
        ///  The possible Amazon Web Services Free Tier configurations.
        public let freeTier: FreeTierConfig

        @inlinable
        public init(freeTier: FreeTierConfig) {
            self.freeTier = freeTier
        }

        private enum CodingKeys: String, CodingKey {
            case freeTier = "FreeTier"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource to which to delete tags.
        public let resourceArn: String
        ///  The tags to delete from the resource as a list of key-value pairs.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/?[0-9]{12}$|^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/[a-zA-Z0-9]{10}$|^arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/[a-zA-Z0-9]{10}$|^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBillingGroupAccountGrouping: AWSEncodableShape & AWSDecodableShape {
        /// Specifies if this billing group will automatically associate newly added
        /// Amazon Web Services accounts that join your consolidated billing family.
        public let autoAssociate: Bool?

        @inlinable
        public init(autoAssociate: Bool? = nil) {
            self.autoAssociate = autoAssociate
        }

        private enum CodingKeys: String, CodingKey {
            case autoAssociate = "AutoAssociate"
        }
    }

    public struct UpdateBillingGroupInput: AWSEncodableShape {
        /// Specifies if the billing group has automatic account
        /// association (AutoAssociate) enabled.
        public let accountGrouping: UpdateBillingGroupAccountGrouping?
        /// The Amazon Resource Name (ARN) of the billing group being updated.
        public let arn: String
        ///  The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
        public let computationPreference: ComputationPreference?
        /// A description of the billing group.
        public let description: String?
        /// The name of the billing group. The names must be unique to each billing group.
        public let name: String?
        /// The status of the billing group. Only one of the valid values can be used.
        public let status: BillingGroupStatus?

        @inlinable
        public init(accountGrouping: UpdateBillingGroupAccountGrouping? = nil, arn: String, computationPreference: ComputationPreference? = nil, description: String? = nil, name: String? = nil, status: BillingGroupStatus? = nil) {
            self.accountGrouping = accountGrouping
            self.arn = arn
            self.computationPreference = computationPreference
            self.description = description
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:billinggroup/)?[0-9]{12}$")
            try self.computationPreference?.validate(name: "\(name).computationPreference")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountGrouping = "AccountGrouping"
            case arn = "Arn"
            case computationPreference = "ComputationPreference"
            case description = "Description"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct UpdateBillingGroupOutput: AWSDecodableShape {
        /// Specifies if the billing group has automatic account
        /// association (AutoAssociate) enabled.
        public let accountGrouping: UpdateBillingGroupAccountGrouping?
        /// The Amazon Resource Name (ARN) of the billing group that was updated.
        public let arn: String?
        ///  A description of the billing group.
        public let description: String?
        ///  The most recent time when the billing group was modified.
        public let lastModifiedTime: Int64?
        ///  The name of the billing group. The names must be unique to each billing group.
        public let name: String?
        ///  The Amazon Resource Name (ARN) of the pricing plan to compute Amazon Web Services charges for the billing group.
        public let pricingPlanArn: String?
        ///  The account ID that serves as the main account in a billing group.
        public let primaryAccountId: String?
        ///  The number of accounts in the particular billing group.
        public let size: Int64?
        ///  The status of the billing group. Only one of the valid values can be used.
        public let status: BillingGroupStatus?
        ///  The reason why the billing group is in its current status.
        public let statusReason: String?

        @inlinable
        public init(accountGrouping: UpdateBillingGroupAccountGrouping? = nil, arn: String? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil, pricingPlanArn: String? = nil, primaryAccountId: String? = nil, size: Int64? = nil, status: BillingGroupStatus? = nil, statusReason: String? = nil) {
            self.accountGrouping = accountGrouping
            self.arn = arn
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.pricingPlanArn = pricingPlanArn
            self.primaryAccountId = primaryAccountId
            self.size = size
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case accountGrouping = "AccountGrouping"
            case arn = "Arn"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case pricingPlanArn = "PricingPlanArn"
            case primaryAccountId = "PrimaryAccountId"
            case size = "Size"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct UpdateCustomLineItemChargeDetails: AWSEncodableShape {
        ///  An UpdateCustomLineItemFlatChargeDetails that describes the new charge details of a flat custom line item.
        public let flat: UpdateCustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public let lineItemFilters: [LineItemFilter]?
        ///  An UpdateCustomLineItemPercentageChargeDetails that describes the new charge details of a percentage custom line item.
        public let percentage: UpdateCustomLineItemPercentageChargeDetails?

        @inlinable
        public init(flat: UpdateCustomLineItemFlatChargeDetails? = nil, lineItemFilters: [LineItemFilter]? = nil, percentage: UpdateCustomLineItemPercentageChargeDetails? = nil) {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
        }

        public func validate(name: String) throws {
            try self.flat?.validate(name: "\(name).flat")
            try self.lineItemFilters?.forEach {
                try $0.validate(name: "\(name).lineItemFilters[]")
            }
            try self.validate(self.lineItemFilters, name: "lineItemFilters", parent: name, max: 1)
            try self.percentage?.validate(name: "\(name).percentage")
        }

        private enum CodingKeys: String, CodingKey {
            case flat = "Flat"
            case lineItemFilters = "LineItemFilters"
            case percentage = "Percentage"
        }
    }

    public struct UpdateCustomLineItemFlatChargeDetails: AWSEncodableShape {
        ///  The custom line item's new fixed charge value in USD.
        public let chargeValue: Double

        @inlinable
        public init(chargeValue: Double) {
            self.chargeValue = chargeValue
        }

        public func validate(name: String) throws {
            try self.validate(self.chargeValue, name: "chargeValue", parent: name, max: 1000000.0)
            try self.validate(self.chargeValue, name: "chargeValue", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case chargeValue = "ChargeValue"
        }
    }

    public struct UpdateCustomLineItemInput: AWSEncodableShape {
        ///  The ARN of the custom line item to be updated.
        public let arn: String
        public let billingPeriodRange: CustomLineItemBillingPeriodRange?
        ///  A ListCustomLineItemChargeDetails containing the new charge details for the custom line item.
        public let chargeDetails: UpdateCustomLineItemChargeDetails?
        ///  The new line item description of the custom line item.
        public let description: String?
        ///  The new name for the custom line item.
        public let name: String?

        @inlinable
        public init(arn: String, billingPeriodRange: CustomLineItemBillingPeriodRange? = nil, chargeDetails: UpdateCustomLineItemChargeDetails? = nil, description: String? = nil, name: String? = nil) {
            self.arn = arn
            self.billingPeriodRange = billingPeriodRange
            self.chargeDetails = chargeDetails
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:customlineitem/)?[a-zA-Z0-9]{10}$")
            try self.billingPeriodRange?.validate(name: "\(name).billingPeriodRange")
            try self.chargeDetails?.validate(name: "\(name).chargeDetails")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case billingPeriodRange = "BillingPeriodRange"
            case chargeDetails = "ChargeDetails"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateCustomLineItemOutput: AWSDecodableShape {
        ///  The ARN of the successfully updated custom line item.
        public let arn: String?
        ///  The number of resources that are associated to the custom line item.
        public let associationSize: Int64?
        ///  The ARN of the billing group that the custom line item is applied to.
        public let billingGroupArn: String?
        ///  A ListCustomLineItemChargeDetails containing the charge details of the successfully updated custom line item.
        public let chargeDetails: ListCustomLineItemChargeDetails?
        ///  The description of the successfully updated custom line item.
        public let description: String?
        ///  The most recent time when the custom line item was modified.
        public let lastModifiedTime: Int64?
        ///  The name of the successfully updated custom line item.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, associationSize: Int64? = nil, billingGroupArn: String? = nil, chargeDetails: ListCustomLineItemChargeDetails? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil) {
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associationSize = "AssociationSize"
            case billingGroupArn = "BillingGroupArn"
            case chargeDetails = "ChargeDetails"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct UpdateCustomLineItemPercentageChargeDetails: AWSEncodableShape {
        ///  The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        public let percentageValue: Double

        @inlinable
        public init(percentageValue: Double) {
            self.percentageValue = percentageValue
        }

        public func validate(name: String) throws {
            try self.validate(self.percentageValue, name: "percentageValue", parent: name, max: 10000.0)
            try self.validate(self.percentageValue, name: "percentageValue", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case percentageValue = "PercentageValue"
        }
    }

    public struct UpdateFreeTierConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Activate or deactivate application of Amazon Web Services Free Tier.
        public let activated: Bool

        @inlinable
        public init(activated: Bool) {
            self.activated = activated
        }

        private enum CodingKeys: String, CodingKey {
            case activated = "Activated"
        }
    }

    public struct UpdatePricingPlanInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pricing plan that you're updating.
        public let arn: String
        /// The description of the pricing plan.
        public let description: String?
        /// The name of the pricing plan. The name must be unique to each pricing plan.
        public let name: String?

        @inlinable
        public init(arn: String, description: String? = nil, name: String? = nil) {
            self.arn = arn
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingplan/)?[a-zA-Z0-9]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdatePricingPlanOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated pricing plan.
        public let arn: String?
        ///  The new description for the pricing rule.
        public let description: String?
        ///  The most recent time when the pricing plan was modified.
        public let lastModifiedTime: Int64?
        ///  The name of the pricing plan. The name must be unique to each pricing plan.
        public let name: String?
        ///  The pricing rules count that's currently associated with this pricing plan list.
        public let size: Int64?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, name: String? = nil, size: Int64? = nil) {
            self.arn = arn
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case size = "Size"
        }
    }

    public struct UpdatePricingRuleInput: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the pricing rule to update.
        public let arn: String
        ///  The new description for the pricing rule.
        public let description: String?
        ///  The new modifier to show pricing plan rates as a percentage.
        public let modifierPercentage: Double?
        ///  The new name of the pricing rule. The name must be unique to each pricing rule.
        public let name: String?
        ///  The set of tiering configurations for the pricing rule.
        public let tiering: UpdateTieringInput?
        ///  The new pricing rule type.
        public let type: PricingRuleType?

        @inlinable
        public init(arn: String, description: String? = nil, modifierPercentage: Double? = nil, name: String? = nil, tiering: UpdateTieringInput? = nil, type: PricingRuleType? = nil) {
            self.arn = arn
            self.description = description
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.tiering = tiering
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws(-cn)?:billingconductor::[0-9]{12}:pricingrule/)?[a-zA-Z0-9]{10}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.modifierPercentage, name: "modifierPercentage", parent: name, min: 0.0)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\+=\\.\\-@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case modifierPercentage = "ModifierPercentage"
            case name = "Name"
            case tiering = "Tiering"
            case type = "Type"
        }
    }

    public struct UpdatePricingRuleOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the successfully updated pricing rule.
        public let arn: String?
        ///  The pricing plans count that this pricing rule is associated with.
        public let associatedPricingPlanCount: Int64?
        ///  The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
        public let billingEntity: String?
        ///  The new description for the pricing rule.
        public let description: String?
        ///  The most recent time the pricing rule was modified.
        public let lastModifiedTime: Int64?
        ///  The new modifier to show pricing plan rates as a percentage.
        public let modifierPercentage: Double?
        ///  The new name of the pricing rule. The name must be unique to each pricing rule.
        public let name: String?
        /// Operation refers to the specific Amazon Web Services covered by this line item. This describes the specific usage of the line item.  If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
        public let operation: String?
        ///  The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
        public let scope: PricingRuleScope?
        ///  If the Scope attribute is set to SERVICE, the attribute indicates which service the PricingRule is applicable for.
        public let service: String?
        ///  The set of tiering configurations for the pricing rule.
        public let tiering: UpdateTieringInput?
        ///  The new pricing rule type.
        public let type: PricingRuleType?
        /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
        public let usageType: String?

        @inlinable
        public init(arn: String? = nil, associatedPricingPlanCount: Int64? = nil, billingEntity: String? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, modifierPercentage: Double? = nil, name: String? = nil, operation: String? = nil, scope: PricingRuleScope? = nil, service: String? = nil, tiering: UpdateTieringInput? = nil, type: PricingRuleType? = nil, usageType: String? = nil) {
            self.arn = arn
            self.associatedPricingPlanCount = associatedPricingPlanCount
            self.billingEntity = billingEntity
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.operation = operation
            self.scope = scope
            self.service = service
            self.tiering = tiering
            self.type = type
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedPricingPlanCount = "AssociatedPricingPlanCount"
            case billingEntity = "BillingEntity"
            case description = "Description"
            case lastModifiedTime = "LastModifiedTime"
            case modifierPercentage = "ModifierPercentage"
            case name = "Name"
            case operation = "Operation"
            case scope = "Scope"
            case service = "Service"
            case tiering = "Tiering"
            case type = "Type"
            case usageType = "UsageType"
        }
    }

    public struct UpdateTieringInput: AWSEncodableShape & AWSDecodableShape {
        ///  The possible Amazon Web Services Free Tier configurations.
        public let freeTier: UpdateFreeTierConfig

        @inlinable
        public init(freeTier: UpdateFreeTierConfig) {
            self.freeTier = freeTier
        }

        private enum CodingKeys: String, CodingKey {
            case freeTier = "FreeTier"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The fields that caused the error, if applicable.
        public let fields: [ValidationExceptionField]?
        public let message: String
        /// The reason the request's validation failed.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The message describing why the field failed validation.
        public let message: String
        /// The field name.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }
}

// MARK: - Errors

/// Error enum for Billingconductor
public struct BillingconductorErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceLimitExceededException = "ServiceLimitExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Billingconductor
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// You can cause an inconsistent state by updating or deleting a resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred while processing a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service limit to exceed.
    public static var serviceLimitExceededException: Self { .init(.serviceLimitExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input doesn't match with the constraints specified by Amazon Web Services.
    public static var validationException: Self { .init(.validationException) }
}

extension BillingconductorErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Billingconductor.ConflictException.self,
        "InternalServerException": Billingconductor.InternalServerException.self,
        "ResourceNotFoundException": Billingconductor.ResourceNotFoundException.self,
        "ServiceLimitExceededException": Billingconductor.ServiceLimitExceededException.self,
        "ThrottlingException": Billingconductor.ThrottlingException.self,
        "ValidationException": Billingconductor.ValidationException.self
    ]
}

extension BillingconductorErrorType: Equatable {
    public static func == (lhs: BillingconductorErrorType, rhs: BillingconductorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BillingconductorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
