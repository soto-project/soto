//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension FreeTier {
    // MARK: Enums

    public enum Dimension: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case description = "DESCRIPTION"
        case freeTierType = "FREE_TIER_TYPE"
        case operation = "OPERATION"
        case region = "REGION"
        case service = "SERVICE"
        case usagePercentage = "USAGE_PERCENTAGE"
        case usageType = "USAGE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum MatchOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equals = "EQUALS"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct DimensionValues: AWSEncodableShape {
        /// The name of the dimension that you want to filter on.
        public let key: Dimension
        /// The match options that you can use to filter your results. You can specify only one of these values in the array.
        public let matchOptions: [MatchOption]
        /// The metadata values you can specify to filter upon, so that the results all match at least one of the specified values.
        public let values: [String]

        public init(key: Dimension, matchOptions: [MatchOption], values: [String]) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 20)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[ a-zA-Z0-9\\-\\:\\.\\_\\/\\,\\$\\(\\)]*$")
            }
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case matchOptions = "MatchOptions"
            case values = "Values"
        }
    }

    public final class Expression: AWSEncodableShape {
        /// Return results that match all Expressions  that you specified in the array.
        public let and: [Expression]?
        /// The specific dimension, values, and match type to filter objects with.
        public let dimensions: DimensionValues?
        /// Return results that donâ€™t match the Expression that you specified.
        public let not: Expression?
        /// Return results that match any of the Expressions  that you specified. in the array.
        public let or: [Expression]?

        public init(and: [Expression]? = nil, dimensions: DimensionValues? = nil, not: Expression? = nil, or: [Expression]? = nil) {
            self.and = and
            self.dimensions = dimensions
            self.not = not
            self.or = or
        }

        public func validate(name: String) throws {
            try self.and?.forEach {
                try $0.validate(name: "\(name).and[]")
            }
            try self.dimensions?.validate(name: "\(name).dimensions")
            try self.not?.validate(name: "\(name).not")
            try self.or?.forEach {
                try $0.validate(name: "\(name).or[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case and = "And"
            case dimensions = "Dimensions"
            case not = "Not"
            case or = "Or"
        }
    }

    public struct FreeTierUsage: AWSDecodableShape {
        /// Describes the actual usage accrued month-to-day (MTD) that you've used so far.
        public let actualUsageAmount: Double?
        /// The description of the Free Tier offer.
        public let description: String?
        /// Describes the forecasted usage by the month that you're expected to use.
        public let forecastedUsageAmount: Double?
        /// Describes the type of the Free Tier offer. For example, the offer can be "12 Months Free",  "Always Free", and "Free Trial".
        public let freeTierType: String?
        /// Describes the maximum usage allowed in Free Tier.
        public let limit: Double?
        /// Describes usageType more granularly with the specific Amazon Web Service API operation. For example, this can be the RunInstances API operation for Amazon Elastic Compute Cloud.
        public let operation: String?
        /// Describes the Amazon Web Services Region for which this offer is applicable
        public let region: String?
        /// The name of the Amazon Web Service providing the Free Tier offer. For example, this can be Amazon Elastic Compute Cloud.
        public let service: String?
        /// Describes the unit of the usageType, such as Hrs.
        public let unit: String?
        /// Describes the usage details of the offer. For example, this might be Global-BoxUsage:freetrial.
        public let usageType: String?

        public init(actualUsageAmount: Double? = nil, description: String? = nil, forecastedUsageAmount: Double? = nil, freeTierType: String? = nil, limit: Double? = nil, operation: String? = nil, region: String? = nil, service: String? = nil, unit: String? = nil, usageType: String? = nil) {
            self.actualUsageAmount = actualUsageAmount
            self.description = description
            self.forecastedUsageAmount = forecastedUsageAmount
            self.freeTierType = freeTierType
            self.limit = limit
            self.operation = operation
            self.region = region
            self.service = service
            self.unit = unit
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case actualUsageAmount = "actualUsageAmount"
            case description = "description"
            case forecastedUsageAmount = "forecastedUsageAmount"
            case freeTierType = "freeTierType"
            case limit = "limit"
            case operation = "operation"
            case region = "region"
            case service = "service"
            case unit = "unit"
            case usageType = "usageType"
        }
    }

    public struct GetFreeTierUsageRequest: AWSEncodableShape {
        /// An expression that specifies the conditions that you want each FreeTierUsage object to meet.
        public let filter: Expression?
        /// The maximum number of results to return in the response. MaxResults means that there can be up to the specified number of values, but there might be fewer results based on your filters.
        public let maxResults: Int?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(filter: Expression? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetFreeTierUsageResponse: AWSDecodableShape {
        /// The list of Free Tier usage objects that meet your filter expression.
        public let freeTierUsages: [FreeTierUsage]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(freeTierUsages: [FreeTierUsage], nextToken: String? = nil) {
            self.freeTierUsages = freeTierUsages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case freeTierUsages = "freeTierUsages"
            case nextToken = "nextToken"
        }
    }
}

// MARK: - Errors

/// Error enum for FreeTier
public struct FreeTierErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize FreeTier
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An unexpected error occurred during the processing of your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Service.
    public static var validationException: Self { .init(.validationException) }
}

extension FreeTierErrorType: Equatable {
    public static func == (lhs: FreeTierErrorType, rhs: FreeTierErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension FreeTierErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
