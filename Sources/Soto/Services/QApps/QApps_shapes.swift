//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QApps {
    // MARK: Enums

    public enum AppRequiredCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creatorMode = "CreatorMode"
        case fileUpload = "FileUpload"
        case pluginMode = "PluginMode"
        case retrievalMode = "RetrievalMode"
        public var description: String { return self.rawValue }
    }

    public enum AppStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case draft = "DRAFT"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum CardOutputSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approvedSources = "approved-sources"
        case llm = "llm"
        public var description: String { return self.rawValue }
    }

    public enum CardType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fileUpload = "file-upload"
        case qPlugin = "q-plugin"
        case qQuery = "q-query"
        case textInput = "text-input"
        public var description: String { return self.rawValue }
    }

    public enum DocumentScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case application = "APPLICATION"
        case session = "SESSION"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum LibraryItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum PluginType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case jira = "JIRA"
        case salesforce = "SALESFORCE"
        case serviceNow = "SERVICE_NOW"
        case zendesk = "ZENDESK"
        public var description: String { return self.rawValue }
    }

    public enum Sender: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case system = "SYSTEM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum Card: AWSDecodableShape, Sendable {
        /// A container for the properties of the file upload card.
        case fileUpload(FileUploadCard)
        /// A container for the properties of the plugin card.
        case qPlugin(QPluginCard)
        /// A container for the properties of the query card.
        case qQuery(QQueryCard)
        /// A container for the properties of the text input card.
        case textInput(TextInputCard)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileUpload:
                let value = try container.decode(FileUploadCard.self, forKey: .fileUpload)
                self = .fileUpload(value)
            case .qPlugin:
                let value = try container.decode(QPluginCard.self, forKey: .qPlugin)
                self = .qPlugin(value)
            case .qQuery:
                let value = try container.decode(QQueryCard.self, forKey: .qQuery)
                self = .qQuery(value)
            case .textInput:
                let value = try container.decode(TextInputCard.self, forKey: .textInput)
                self = .textInput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileUpload = "fileUpload"
            case qPlugin = "qPlugin"
            case qQuery = "qQuery"
            case textInput = "textInput"
        }
    }

    public enum CardInput: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A container for the properties of the file upload input card.
        case fileUpload(FileUploadCardInput)
        /// A container for the properties of the plugin input card.
        case qPlugin(QPluginCardInput)
        /// A container for the properties of the query input card.
        case qQuery(QQueryCardInput)
        /// A container for the properties of the text input card.
        case textInput(TextInputCardInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileUpload:
                let value = try container.decode(FileUploadCardInput.self, forKey: .fileUpload)
                self = .fileUpload(value)
            case .qPlugin:
                let value = try container.decode(QPluginCardInput.self, forKey: .qPlugin)
                self = .qPlugin(value)
            case .qQuery:
                let value = try container.decode(QQueryCardInput.self, forKey: .qQuery)
                self = .qQuery(value)
            case .textInput:
                let value = try container.decode(TextInputCardInput.self, forKey: .textInput)
                self = .textInput(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fileUpload(let value):
                try container.encode(value, forKey: .fileUpload)
            case .qPlugin(let value):
                try container.encode(value, forKey: .qPlugin)
            case .qQuery(let value):
                try container.encode(value, forKey: .qQuery)
            case .textInput(let value):
                try container.encode(value, forKey: .textInput)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .fileUpload(let value):
                try value.validate(name: "\(name).fileUpload")
            case .qPlugin(let value):
                try value.validate(name: "\(name).qPlugin")
            case .qQuery(let value):
                try value.validate(name: "\(name).qQuery")
            case .textInput(let value):
                try value.validate(name: "\(name).textInput")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileUpload = "fileUpload"
            case qPlugin = "qPlugin"
            case qQuery = "qQuery"
            case textInput = "textInput"
        }
    }

    public enum DocumentAttributeValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case dateValue(Date)
        /// A long integer value.
        case longValue(Int64)
        /// A list of strings.
        case stringListValue([String])
        /// A string.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dateValue:
                let value = try container.decode(Date.self, forKey: .dateValue)
                self = .dateValue(value)
            case .longValue:
                let value = try container.decode(Int64.self, forKey: .longValue)
                self = .longValue(value)
            case .stringListValue:
                let value = try container.decode([String].self, forKey: .stringListValue)
                self = .stringListValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateValue(let value):
                try container.encode(value, forKey: .dateValue)
            case .longValue(let value):
                try container.encode(value, forKey: .longValue)
            case .stringListValue(let value):
                try container.encode(value, forKey: .stringListValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringListValue(let value):
                try value.forEach {
                    try validate($0, name: "stringListValue[]", parent: name, max: 2048)
                    try validate($0, name: "stringListValue[]", parent: name, min: 1)
                }
            case .stringValue(let value):
                try self.validate(value, name: "stringValue", parent: name, max: 2048)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateValue = "dateValue"
            case longValue = "longValue"
            case stringListValue = "stringListValue"
            case stringValue = "stringValue"
        }
    }

    public enum PredictQAppInputOptions: AWSEncodableShape, Sendable {
        /// A conversation to use as input for generating the Q App definition.
        case conversation([ConversationMessage])
        /// A problem statement to use as input for generating the Q App definition.
        case problemStatement(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conversation(let value):
                try container.encode(value, forKey: .conversation)
            case .problemStatement(let value):
                try container.encode(value, forKey: .problemStatement)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conversation = "conversation"
            case problemStatement = "problemStatement"
        }
    }

    // MARK: Shapes

    public struct AppDefinition: AWSDecodableShape {
        /// The version of the app definition schema or specification.
        public let appDefinitionVersion: String
        /// A flag indicating whether the Q App's definition can be edited by the user.
        public let canEdit: Bool?
        /// The cards that make up the Q App, such as text input, file upload, or query cards.
        public let cards: [Card]

        public init(appDefinitionVersion: String, canEdit: Bool? = nil, cards: [Card]) {
            self.appDefinitionVersion = appDefinitionVersion
            self.canEdit = canEdit
            self.cards = cards
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinitionVersion = "appDefinitionVersion"
            case canEdit = "canEdit"
            case cards = "cards"
        }
    }

    public struct AppDefinitionInput: AWSEncodableShape & AWSDecodableShape {
        /// The cards that make up the Q App definition.
        public let cards: [CardInput]
        /// The initial prompt displayed when the Q App is started.
        public let initialPrompt: String?

        public init(cards: [CardInput], initialPrompt: String? = nil) {
            self.cards = cards
            self.initialPrompt = initialPrompt
        }

        public func validate(name: String) throws {
            try self.cards.forEach {
                try $0.validate(name: "\(name).cards[]")
            }
            try self.validate(self.cards, name: "cards", parent: name, max: 20)
            try self.validate(self.initialPrompt, name: "initialPrompt", parent: name, max: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case cards = "cards"
            case initialPrompt = "initialPrompt"
        }
    }

    public struct AssociateLibraryItemReviewInput: AWSEncodableShape {
        /// The unique identifier for the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to associate the review with.
        public let libraryItemId: String

        public init(instanceId: String, libraryItemId: String) {
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItemId = "libraryItemId"
        }
    }

    public struct AssociateQAppWithUserInput: AWSEncodableShape {
        /// The ID of the Amazon Q App to associate with the user.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public final class AttributeFilter: AWSEncodableShape & AWSDecodableShape {
        /// Performs a logical AND operation on all supplied filters.
        public let andAllFilters: [AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields. Supported for the following document attribute value types: stringListValue.
        public let containsAll: DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields. Supported for the following document attribute value types: stringListValue.
        public let containsAny: DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue, longValue, stringListValue and stringValue.
        public let equalsTo: DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let greaterThan: DocumentAttribute?
        /// Performs a greater than or equals operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let greaterThanOrEquals: DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let lessThan: DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following document attribute value type: dateValue and longValue.
        public let lessThanOrEquals: DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        public let notFilter: AttributeFilter?
        ///  Performs a logical OR operation on all supplied filters.
        public let orAllFilters: [AttributeFilter]?

        public init(andAllFilters: [AttributeFilter]? = nil, containsAll: DocumentAttribute? = nil, containsAny: DocumentAttribute? = nil, equalsTo: DocumentAttribute? = nil, greaterThan: DocumentAttribute? = nil, greaterThanOrEquals: DocumentAttribute? = nil, lessThan: DocumentAttribute? = nil, lessThanOrEquals: DocumentAttribute? = nil, notFilter: AttributeFilter? = nil, orAllFilters: [AttributeFilter]? = nil) {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }

        public func validate(name: String) throws {
            try self.andAllFilters?.forEach {
                try $0.validate(name: "\(name).andAllFilters[]")
            }
            try self.containsAll?.validate(name: "\(name).containsAll")
            try self.containsAny?.validate(name: "\(name).containsAny")
            try self.equalsTo?.validate(name: "\(name).equalsTo")
            try self.greaterThan?.validate(name: "\(name).greaterThan")
            try self.greaterThanOrEquals?.validate(name: "\(name).greaterThanOrEquals")
            try self.lessThan?.validate(name: "\(name).lessThan")
            try self.lessThanOrEquals?.validate(name: "\(name).lessThanOrEquals")
            try self.notFilter?.validate(name: "\(name).notFilter")
            try self.orAllFilters?.forEach {
                try $0.validate(name: "\(name).orAllFilters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAllFilters = "andAllFilters"
            case containsAll = "containsAll"
            case containsAny = "containsAny"
            case equalsTo = "equalsTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case notFilter = "notFilter"
            case orAllFilters = "orAllFilters"
        }
    }

    public struct CardStatus: AWSDecodableShape {
        /// The current state of the card.
        public let currentState: ExecutionStatus
        /// The current value or result associated with the card.
        public let currentValue: String

        public init(currentState: ExecutionStatus, currentValue: String) {
            self.currentState = currentState
            self.currentValue = currentValue
        }

        private enum CodingKeys: String, CodingKey {
            case currentState = "currentState"
            case currentValue = "currentValue"
        }
    }

    public struct CardValue: AWSEncodableShape {
        /// The unique identifier of the card.
        public let cardId: String
        /// The value or result associated with the card.
        public let value: String

        public init(cardId: String, value: String) {
            self.cardId = cardId
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.cardId, name: "cardId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case cardId = "cardId"
            case value = "value"
        }
    }

    public struct Category: AWSDecodableShape {
        /// The unique identifier of the category.
        public let id: String
        /// The title or name of the category.
        public let title: String

        public init(id: String, title: String) {
            self.id = id
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case title = "title"
        }
    }

    public struct ConversationMessage: AWSEncodableShape {
        /// The text content of the conversation message.
        public let body: String
        /// The type of the conversation message.
        public let type: Sender

        public init(body: String, type: Sender) {
            self.body = body
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case type = "type"
        }
    }

    public struct CreateLibraryItemInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q App to publish to the library.
        public let appId: String
        /// The version of the Amazon Q App to publish to the library.
        public let appVersion: Int
        /// The categories to associate with the library item for easier discovery.
        public let categories: [String]
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        public init(appId: String, appVersion: Int, categories: [String], instanceId: String) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.appVersion, forKey: .appVersion)
            try container.encode(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.appVersion, name: "appVersion", parent: name, max: 2147483647)
            try self.validate(self.appVersion, name: "appVersion", parent: name, min: 0)
            try self.categories.forEach {
                try validate($0, name: "categories[]", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
        }
    }

    public struct CreateLibraryItemOutput: AWSDecodableShape {
        /// The date and time the library item was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the library item.
        public let createdBy: String
        /// The unique identifier of the new library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received from users.
        public let ratingCount: Int
        /// The status of the new library item, such as "Published".
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateQAppInput: AWSEncodableShape {
        /// The definition of the new Q App, specifying the cards and flow.
        public let appDefinition: AppDefinitionInput
        /// The description of the new Q App.
        public let description: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// Optional tags to associate with the new Q App.
        public let tags: [String: String]?
        /// The title of the new Q App.
        public let title: String

        public init(appDefinition: AppDefinitionInput, description: String? = nil, instanceId: String, tags: [String: String]? = nil, title: String) {
            self.appDefinition = appDefinition
            self.description = description
            self.instanceId = instanceId
            self.tags = tags
            self.title = title
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appDefinition, forKey: .appDefinition)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.title, forKey: .title)
        }

        public func validate(name: String) throws {
            try self.appDefinition.validate(name: "\(name).appDefinition")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinition = "appDefinition"
            case description = "description"
            case tags = "tags"
            case title = "title"
        }
    }

    public struct CreateQAppOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new Q App.
        public let appArn: String
        /// The unique identifier of the new Q App.
        public let appId: String
        /// The version of the new Q App.
        public let appVersion: Int
        /// The date and time the Q App was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the Q App.
        public let createdBy: String
        /// The description of the new Q App.
        public let description: String?
        /// The initial prompt displayed when the Q App is started.
        public let initialPrompt: String?
        /// The capabilities required to run the Q App, such as file upload or third-party integrations.
        public let requiredCapabilities: [AppRequiredCapability]?
        /// The status of the new Q App, such as "Created".
        public let status: AppStatus
        /// The title of the new Q App.
        public let title: String
        /// The date and time the Q App was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The user who last updated the Q App.
        public let updatedBy: String

        public init(appArn: String, appId: String, appVersion: Int, createdAt: Date, createdBy: String, description: String? = nil, initialPrompt: String? = nil, requiredCapabilities: [AppRequiredCapability]? = nil, status: AppStatus, title: String, updatedAt: Date, updatedBy: String) {
            self.appArn = appArn
            self.appId = appId
            self.appVersion = appVersion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.initialPrompt = initialPrompt
            self.requiredCapabilities = requiredCapabilities
            self.status = status
            self.title = title
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case appVersion = "appVersion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case initialPrompt = "initialPrompt"
            case requiredCapabilities = "requiredCapabilities"
            case status = "status"
            case title = "title"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct DeleteLibraryItemInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to delete.
        public let libraryItemId: String

        public init(instanceId: String, libraryItemId: String) {
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItemId = "libraryItemId"
        }
    }

    public struct DeleteQAppInput: AWSEncodableShape {
        /// The unique identifier of the Q App to delete.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DisassociateLibraryItemReviewInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to remove the review from.
        public let libraryItemId: String

        public init(instanceId: String, libraryItemId: String) {
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItemId = "libraryItemId"
        }
    }

    public struct DisassociateQAppFromUserInput: AWSEncodableShape {
        /// The unique identifier of the Q App to disassociate from the user.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DocumentAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the attribute.
        public let name: String
        /// The value of the attribute.
        public let value: DocumentAttributeValue

        public init(name: String, value: DocumentAttributeValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct FileUploadCard: AWSDecodableShape {
        /// A flag indicating if the user can override the default file for the upload card.
        public let allowOverride: Bool?
        /// Any dependencies or requirements for the file upload card.
        public let dependencies: [String]
        /// The unique identifier of the file associated with the card.
        public let fileId: String?
        /// The name of the file being uploaded.
        public let filename: String?
        /// The unique identifier of the file upload card.
        public let id: String
        /// The title of the file upload card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(allowOverride: Bool? = nil, dependencies: [String], fileId: String? = nil, filename: String? = nil, id: String, title: String, type: CardType) {
            self.allowOverride = allowOverride
            self.dependencies = dependencies
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverride = "allowOverride"
            case dependencies = "dependencies"
            case fileId = "fileId"
            case filename = "filename"
            case id = "id"
            case title = "title"
            case type = "type"
        }
    }

    public struct FileUploadCardInput: AWSEncodableShape & AWSDecodableShape {
        /// A flag indicating if the user can override the default file for the upload card.
        public let allowOverride: Bool?
        /// The identifier of a pre-uploaded file associated with the card.
        public let fileId: String?
        /// The default filename to use for the file upload card.
        public let filename: String?
        /// The unique identifier of the file upload card.
        public let id: String
        /// The title or label of the file upload card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(allowOverride: Bool? = nil, fileId: String? = nil, filename: String? = nil, id: String, title: String, type: CardType) {
            self.allowOverride = allowOverride
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.fileId, name: "fileId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.filename, name: "filename", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.title, name: "title", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverride = "allowOverride"
            case fileId = "fileId"
            case filename = "filename"
            case id = "id"
            case title = "title"
            case type = "type"
        }
    }

    public struct GetLibraryItemInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q App associated with the library item.
        public let appId: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to retrieve.
        public let libraryItemId: String

        public init(appId: String? = nil, instanceId: String, libraryItemId: String) {
            self.appId = appId
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appId, key: "appId")
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.libraryItemId, key: "libraryItemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLibraryItemOutput: AWSDecodableShape {
        /// The unique identifier of the Q App associated with the library item.
        public let appId: String
        /// The version of the Q App associated with the library item.
        public let appVersion: Int
        /// The categories associated with the library item for discovery.
        public let categories: [Category]
        /// The date and time the library item was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the library item.
        public let createdBy: String
        /// Whether the current user has rated the library item.
        public let isRatedByUser: Bool?
        /// The unique identifier of the library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received from users.
        public let ratingCount: Int
        /// The status of the library item, such as "Published".
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?
        /// The number of users who have associated the Q App with their account.
        public let userCount: Int?

        public init(appId: String, appVersion: Int, categories: [Category], createdAt: Date, createdBy: String, isRatedByUser: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil, userCount: Int? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isRatedByUser = "isRatedByUser"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case userCount = "userCount"
        }
    }

    public struct GetQAppInput: AWSEncodableShape {
        /// The unique identifier of the Q App to retrieve.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appId, key: "appId")
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQAppOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Q App.
        public let appArn: String
        /// The full definition of the Q App, specifying the cards and flow.
        public let appDefinition: AppDefinition
        /// The unique identifier of the Q App.
        public let appId: String
        /// The version of the Q App.
        public let appVersion: Int
        /// The date and time the Q App was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the Q App.
        public let createdBy: String
        /// The description of the Q App.
        public let description: String?
        /// The initial prompt displayed when the Q App is started.
        public let initialPrompt: String?
        /// The capabilities required to run the Q App, such as file upload or third-party integrations.
        public let requiredCapabilities: [AppRequiredCapability]?
        /// The status of the Q App.
        public let status: AppStatus
        /// The title of the Q App.
        public let title: String
        /// The date and time the Q App was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The user who last updated the Q App.
        public let updatedBy: String

        public init(appArn: String, appDefinition: AppDefinition, appId: String, appVersion: Int, createdAt: Date, createdBy: String, description: String? = nil, initialPrompt: String? = nil, requiredCapabilities: [AppRequiredCapability]? = nil, status: AppStatus, title: String, updatedAt: Date, updatedBy: String) {
            self.appArn = appArn
            self.appDefinition = appDefinition
            self.appId = appId
            self.appVersion = appVersion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.initialPrompt = initialPrompt
            self.requiredCapabilities = requiredCapabilities
            self.status = status
            self.title = title
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appDefinition = "appDefinition"
            case appId = "appId"
            case appVersion = "appVersion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case initialPrompt = "initialPrompt"
            case requiredCapabilities = "requiredCapabilities"
            case status = "status"
            case title = "title"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to retrieve.
        public let sessionId: String

        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQAppSessionOutput: AWSDecodableShape {
        /// The current status for each card in the Q App session.
        public let cardStatus: [String: CardStatus]
        /// The Amazon Resource Name (ARN) of the Q App session.
        public let sessionArn: String
        /// The unique identifier of the Q App session.
        public let sessionId: String
        /// The current status of the Q App session.
        public let status: ExecutionStatus

        public init(cardStatus: [String: CardStatus], sessionArn: String, sessionId: String, status: ExecutionStatus) {
            self.cardStatus = cardStatus
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case cardStatus = "cardStatus"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case status = "status"
        }
    }

    public struct ImportDocumentInput: AWSEncodableShape {
        /// The unique identifier of the Q App the file is associated with.
        public let appId: String
        /// The unique identifier of the card the file is associated with, if applicable.
        public let cardId: String
        /// The base64-encoded contents of the file to upload.
        public let fileContentsBase64: String
        /// The name of the file being uploaded.
        public let fileName: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// Whether the file is associated with an Q App definition or a specific Q App session.
        public let scope: DocumentScope
        /// The unique identifier of the Q App session the file is associated with, if applicable.
        public let sessionId: String?

        public init(appId: String, cardId: String, fileContentsBase64: String, fileName: String, instanceId: String, scope: DocumentScope, sessionId: String? = nil) {
            self.appId = appId
            self.cardId = cardId
            self.fileContentsBase64 = fileContentsBase64
            self.fileName = fileName
            self.instanceId = instanceId
            self.scope = scope
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.cardId, forKey: .cardId)
            try container.encode(self.fileContentsBase64, forKey: .fileContentsBase64)
            try container.encode(self.fileName, forKey: .fileName)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.scope, forKey: .scope)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.cardId, name: "cardId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.fileName, name: "fileName", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case cardId = "cardId"
            case fileContentsBase64 = "fileContentsBase64"
            case fileName = "fileName"
            case scope = "scope"
            case sessionId = "sessionId"
        }
    }

    public struct ImportDocumentOutput: AWSDecodableShape {
        /// The unique identifier assigned to the uploaded file.
        public let fileId: String?

        public init(fileId: String? = nil) {
            self.fileId = fileId
        }

        private enum CodingKeys: String, CodingKey {
            case fileId = "fileId"
        }
    }

    public struct LibraryItemMember: AWSDecodableShape {
        /// The unique identifier of the Q App associated with the library item.
        public let appId: String
        /// The version of the Q App associated with the library item.
        public let appVersion: Int
        /// The categories associated with the library item.
        public let categories: [Category]
        /// The date and time the library item was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the library item.
        public let createdBy: String
        /// Whether the current user has rated the library item.
        public let isRatedByUser: Bool?
        /// The unique identifier of the library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received.
        public let ratingCount: Int
        /// The status of the library item.
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?
        /// The number of users who have the associated Q App.
        public let userCount: Int?

        public init(appId: String, appVersion: Int, categories: [Category], createdAt: Date, createdBy: String, isRatedByUser: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil, userCount: Int? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isRatedByUser = "isRatedByUser"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case userCount = "userCount"
        }
    }

    public struct ListLibraryItemsInput: AWSEncodableShape {
        /// Optional category to filter the library items by.
        public let categoryId: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The maximum number of library items to return in the response.
        public let limit: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(categoryId: String? = nil, instanceId: String, limit: Int? = nil, nextToken: String? = nil) {
            self.categoryId = categoryId
            self.instanceId = instanceId
            self.limit = limit
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.categoryId, key: "categoryId")
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.categoryId, name: "categoryId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 300)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLibraryItemsOutput: AWSDecodableShape {
        /// The list of library items meeting the request criteria.
        public let libraryItems: [LibraryItemMember]?
        /// The token to use to request the next page of results.
        public let nextToken: String?

        public init(libraryItems: [LibraryItemMember]? = nil, nextToken: String? = nil) {
            self.libraryItems = libraryItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItems = "libraryItems"
            case nextToken = "nextToken"
        }
    }

    public struct ListQAppsInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The maximum number of Q Apps to return in the response.
        public let limit: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(instanceId: String, limit: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.limit = limit
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 300)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQAppsOutput: AWSDecodableShape {
        /// The list of Amazon Q Apps meeting the request criteria.
        public let apps: [UserAppItem]
        /// The token to use to request the next page of results.
        public let nextToken: String?

        public init(apps: [UserAppItem], nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps = "apps"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags should be listed.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags that are assigned to the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PredictAppDefinition: AWSDecodableShape {
        /// The definition specifying the cards and flow of the generated Q App.
        public let appDefinition: AppDefinitionInput
        /// The description of the generated Q App definition.
        public let description: String?
        /// The title of the generated Q App definition.
        public let title: String

        public init(appDefinition: AppDefinitionInput, description: String? = nil, title: String) {
            self.appDefinition = appDefinition
            self.description = description
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinition = "appDefinition"
            case description = "description"
            case title = "title"
        }
    }

    public struct PredictQAppInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The input to generate the Q App definition from, either a conversation or problem statement.
        public let options: PredictQAppInputOptions?

        public init(instanceId: String, options: PredictQAppInputOptions? = nil) {
            self.instanceId = instanceId
            self.options = options
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.options, forKey: .options)
        }

        private enum CodingKeys: String, CodingKey {
            case options = "options"
        }
    }

    public struct PredictQAppOutput: AWSDecodableShape {
        /// The generated Q App definition.
        public let app: PredictAppDefinition
        /// The problem statement extracted from the input conversation, if provided.
        public let problemStatement: String

        public init(app: PredictAppDefinition, problemStatement: String) {
            self.app = app
            self.problemStatement = problemStatement
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case problemStatement = "problemStatement"
        }
    }

    public struct QPluginCard: AWSDecodableShape {
        /// Any dependencies or requirements for the plugin card.
        public let dependencies: [String]
        /// The unique identifier of the plugin card.
        public let id: String
        /// The unique identifier of the plugin used by the card.
        public let pluginId: String
        /// The type or category of the plugin used by the card.
        public let pluginType: PluginType
        /// The prompt or instructions displayed for the plugin card.
        public let prompt: String
        /// The title or label of the plugin card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(dependencies: [String], id: String, pluginId: String, pluginType: PluginType, prompt: String, title: String, type: CardType) {
            self.dependencies = dependencies
            self.id = id
            self.pluginId = pluginId
            self.pluginType = pluginType
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies = "dependencies"
            case id = "id"
            case pluginId = "pluginId"
            case pluginType = "pluginType"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct QPluginCardInput: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the plugin card.
        public let id: String
        /// The unique identifier of the plugin used by the card.
        public let pluginId: String
        /// The prompt or instructions displayed for the plugin card.
        public let prompt: String
        /// The title or label of the plugin card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(id: String, pluginId: String, prompt: String, title: String, type: CardType) {
            self.id = id
            self.pluginId = pluginId
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.prompt, name: "prompt", parent: name, max: 7000)
            try self.validate(self.title, name: "title", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case pluginId = "pluginId"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct QQueryCard: AWSDecodableShape {
        /// The Amazon Q Business filters applied in this query card when resolving data sources
        public let attributeFilter: AttributeFilter?
        /// Any dependencies or requirements for the query card.
        public let dependencies: [String]
        /// The unique identifier of the query card.
        public let id: String
        /// The source or type of output generated by the query card.
        public let outputSource: CardOutputSource
        /// The prompt or instructions displayed for the query card.
        public let prompt: String
        /// The title or label of the query card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(attributeFilter: AttributeFilter? = nil, dependencies: [String], id: String, outputSource: CardOutputSource, prompt: String, title: String, type: CardType) {
            self.attributeFilter = attributeFilter
            self.dependencies = dependencies
            self.id = id
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "attributeFilter"
            case dependencies = "dependencies"
            case id = "id"
            case outputSource = "outputSource"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct QQueryCardInput: AWSEncodableShape & AWSDecodableShape {
        /// Turns on filtering of responses based on document attributes or metadata fields.
        public let attributeFilter: AttributeFilter?
        /// The unique identifier of the query card.
        public let id: String
        /// The source or type of output to generate for the query card.
        public let outputSource: CardOutputSource?
        /// The prompt or instructions displayed for the query card.
        public let prompt: String
        /// The title or label of the query card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(attributeFilter: AttributeFilter? = nil, id: String, outputSource: CardOutputSource? = nil, prompt: String, title: String, type: CardType) {
            self.attributeFilter = attributeFilter
            self.id = id
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.attributeFilter?.validate(name: "\(name).attributeFilter")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.prompt, name: "prompt", parent: name, max: 7000)
            try self.validate(self.title, name: "title", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "attributeFilter"
            case id = "id"
            case outputSource = "outputSource"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct StartQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Q App to start a session for.
        public let appId: String
        /// The version of the Q App to use for the session.
        public let appVersion: Int
        /// Optional initial input values to provide for the Q App session.
        public let initialValues: [CardValue]?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// Optional tags to associate with the new Q App session.
        public let tags: [String: String]?

        public init(appId: String, appVersion: Int, initialValues: [CardValue]? = nil, instanceId: String, tags: [String: String]? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.initialValues = initialValues
            self.instanceId = instanceId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.appVersion, forKey: .appVersion)
            try container.encodeIfPresent(self.initialValues, forKey: .initialValues)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.appVersion, name: "appVersion", parent: name, max: 2147483647)
            try self.validate(self.appVersion, name: "appVersion", parent: name, min: 0)
            try self.initialValues?.forEach {
                try $0.validate(name: "\(name).initialValues[]")
            }
            try self.validate(self.initialValues, name: "initialValues", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case initialValues = "initialValues"
            case tags = "tags"
        }
    }

    public struct StartQAppSessionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new Q App session.
        public let sessionArn: String
        /// The unique identifier of the new Q App session.
        public let sessionId: String

        public init(sessionArn: String, sessionId: String) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct StopQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to stop.
        public let sessionId: String

        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceARN: String
        /// The tags to associate with the resource.
        public let tags: [String: String]

        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextInputCard: AWSDecodableShape {
        /// The default value to pre-populate in the text input field.
        public let defaultValue: String?
        /// Any dependencies or requirements for the text input card.
        public let dependencies: [String]
        /// The unique identifier of the text input card.
        public let id: String
        /// The placeholder text to display in the text input field.
        public let placeholder: String?
        /// The title or label of the text input card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(defaultValue: String? = nil, dependencies: [String], id: String, placeholder: String? = nil, title: String, type: CardType) {
            self.defaultValue = defaultValue
            self.dependencies = dependencies
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case dependencies = "dependencies"
            case id = "id"
            case placeholder = "placeholder"
            case title = "title"
            case type = "type"
        }
    }

    public struct TextInputCardInput: AWSEncodableShape & AWSDecodableShape {
        /// The default value to pre-populate in the text input field.
        public let defaultValue: String?
        /// The unique identifier of the text input card.
        public let id: String
        /// The placeholder text to display in the text input field.
        public let placeholder: String?
        /// The title or label of the text input card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        public init(defaultValue: String? = nil, id: String, placeholder: String? = nil, title: String, type: CardType) {
            self.defaultValue = defaultValue
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.placeholder, name: "placeholder", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case id = "id"
            case placeholder = "placeholder"
            case title = "title"
            case type = "type"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to disassociate the tag from.
        public let resourceARN: String
        /// The keys of the tags to disassociate from the resource.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLibraryItemInput: AWSEncodableShape {
        /// The new categories to associate with the library item.
        public let categories: [String]?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to update.
        public let libraryItemId: String
        /// The new status to set for the library item, such as "Published" or "Hidden".
        public let status: LibraryItemStatus?

        public init(categories: [String]? = nil, instanceId: String, libraryItemId: String, status: LibraryItemStatus? = nil) {
            self.categories = categories
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.categories?.forEach {
                try validate($0, name: "categories[]", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 3)
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "categories"
            case libraryItemId = "libraryItemId"
            case status = "status"
        }
    }

    public struct UpdateLibraryItemOutput: AWSDecodableShape {
        /// The unique identifier of the Q App associated with the library item.
        public let appId: String
        /// The version of the Q App associated with the library item.
        public let appVersion: Int
        /// The categories associated with the updated library item.
        public let categories: [Category]
        /// The date and time the library item was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who originally created the library item.
        public let createdBy: String
        /// Whether the current user has rated the library item.
        public let isRatedByUser: Bool?
        /// The unique identifier of the updated library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received.
        public let ratingCount: Int
        /// The new status of the updated library item.
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?
        /// The number of users who have the associated Q App.
        public let userCount: Int?

        public init(appId: String, appVersion: Int, categories: [Category], createdAt: Date, createdBy: String, isRatedByUser: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil, userCount: Int? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isRatedByUser = "isRatedByUser"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case userCount = "userCount"
        }
    }

    public struct UpdateQAppInput: AWSEncodableShape {
        /// The new definition specifying the cards and flow for the Q App.
        public let appDefinition: AppDefinitionInput?
        /// The unique identifier of the Q App to update.
        public let appId: String
        /// The new description for the Q App.
        public let description: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The new title for the Q App.
        public let title: String?

        public init(appDefinition: AppDefinitionInput? = nil, appId: String, description: String? = nil, instanceId: String, title: String? = nil) {
            self.appDefinition = appDefinition
            self.appId = appId
            self.description = description
            self.instanceId = instanceId
            self.title = title
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.appDefinition, forKey: .appDefinition)
            try container.encode(self.appId, forKey: .appId)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.title, forKey: .title)
        }

        public func validate(name: String) throws {
            try self.appDefinition?.validate(name: "\(name).appDefinition")
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinition = "appDefinition"
            case appId = "appId"
            case description = "description"
            case title = "title"
        }
    }

    public struct UpdateQAppOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated Q App.
        public let appArn: String
        /// The unique identifier of the updated Q App.
        public let appId: String
        /// The new version of the updated Q App.
        public let appVersion: Int
        /// The date and time the Q App was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who originally created the Q App.
        public let createdBy: String
        /// The new description of the updated Q App.
        public let description: String?
        /// The initial prompt for the updated Q App.
        public let initialPrompt: String?
        /// The capabilities required for the updated Q App.
        public let requiredCapabilities: [AppRequiredCapability]?
        /// The status of the updated Q App.
        public let status: AppStatus
        /// The new title of the updated Q App.
        public let title: String
        /// The date and time the Q App was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The user who last updated the Q App.
        public let updatedBy: String

        public init(appArn: String, appId: String, appVersion: Int, createdAt: Date, createdBy: String, description: String? = nil, initialPrompt: String? = nil, requiredCapabilities: [AppRequiredCapability]? = nil, status: AppStatus, title: String, updatedAt: Date, updatedBy: String) {
            self.appArn = appArn
            self.appId = appId
            self.appVersion = appVersion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.initialPrompt = initialPrompt
            self.requiredCapabilities = requiredCapabilities
            self.status = status
            self.title = title
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case appVersion = "appVersion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case initialPrompt = "initialPrompt"
            case requiredCapabilities = "requiredCapabilities"
            case status = "status"
            case title = "title"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to provide input for.
        public let sessionId: String
        /// The input values to provide for the current state of the Q App session.
        public let values: [CardValue]?

        public init(instanceId: String, sessionId: String, values: [CardValue]? = nil) {
            self.instanceId = instanceId
            self.sessionId = sessionId
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.sessionId, forKey: .sessionId)
            try container.encodeIfPresent(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case values = "values"
        }
    }

    public struct UpdateQAppSessionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated Q App session.
        public let sessionArn: String
        /// The unique identifier of the updated Q App session.
        public let sessionId: String

        public init(sessionArn: String, sessionId: String) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct UserAppItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Q App.
        public let appArn: String
        /// The unique identifier of the Q App.
        public let appId: String
        /// A flag indicating whether the user can edit the Q App.
        public let canEdit: Bool?
        /// The date and time the user's association with the Q App was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the Q App.
        public let description: String?
        /// The status of the user's association with the Q App.
        public let status: String?
        /// The title of the Q App.
        public let title: String

        public init(appArn: String, appId: String, canEdit: Bool? = nil, createdAt: Date, description: String? = nil, status: String? = nil, title: String) {
            self.appArn = appArn
            self.appId = appId
            self.canEdit = canEdit
            self.createdAt = createdAt
            self.description = description
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case canEdit = "canEdit"
            case createdAt = "createdAt"
            case description = "description"
            case status = "status"
            case title = "title"
        }
    }
}

// MARK: - Errors

/// Error enum for QApps
public struct QAppsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case contentTooLargeException = "ContentTooLargeException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QApps
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The client is not authorized to perform the requested operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation could not be completed due to a  conflict with the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The requested operation could not be completed because  the content exceeds the maximum allowed size.
    public static var contentTooLargeException: Self { .init(.contentTooLargeException) }
    /// An internal service error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The requested operation could not be completed because  it would exceed the service's quota or limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The requested operation could not be completed because too many  requests were sent at once. Wait a bit and try again later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The client is not authenticated or authorized to perform the requested operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input failed to satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension QAppsErrorType: Equatable {
    public static func == (lhs: QAppsErrorType, rhs: QAppsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QAppsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
