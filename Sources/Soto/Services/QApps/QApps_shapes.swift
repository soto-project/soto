//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QApps {
    // MARK: Enums

    public enum Action: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case read = "read"
        case write = "write"
        public var description: String { return self.rawValue }
    }

    public enum AppRequiredCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creatorMode = "CreatorMode"
        case fileUpload = "FileUpload"
        case pluginMode = "PluginMode"
        case retrievalMode = "RetrievalMode"
        public var description: String { return self.rawValue }
    }

    public enum AppStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case draft = "DRAFT"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum CardOutputSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approvedSources = "approved-sources"
        case llm = "llm"
        public var description: String { return self.rawValue }
    }

    public enum CardType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fileUpload = "file-upload"
        case formInput = "form-input"
        case qPlugin = "q-plugin"
        case qQuery = "q-query"
        case textInput = "text-input"
        public var description: String { return self.rawValue }
    }

    public enum DocumentScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case application = "APPLICATION"
        case session = "SESSION"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum InputCardComputeMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case append = "append"
        case replace = "replace"
        public var description: String { return self.rawValue }
    }

    public enum LibraryItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum PluginType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asana = "ASANA"
        case atlassianConfluence = "ATLASSIAN_CONFLUENCE"
        case custom = "CUSTOM"
        case googleCalendar = "GOOGLE_CALENDAR"
        case jira = "JIRA"
        case jiraCloud = "JIRA_CLOUD"
        case microsoftExchange = "MICROSOFT_EXCHANGE"
        case microsoftTeams = "MICROSOFT_TEAMS"
        case pagerdutyAdvance = "PAGERDUTY_ADVANCE"
        case salesforce = "SALESFORCE"
        case salesforceCrm = "SALESFORCE_CRM"
        case serviceNow = "SERVICE_NOW"
        case servicenowNowPlatform = "SERVICENOW_NOW_PLATFORM"
        case smartsheet = "SMARTSHEET"
        case zendesk = "ZENDESK"
        case zendeskSuite = "ZENDESK_SUITE"
        public var description: String { return self.rawValue }
    }

    public enum Sender: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case system = "SYSTEM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum SubmissionMutationKind: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "add"
        case delete = "delete"
        case edit = "edit"
        public var description: String { return self.rawValue }
    }

    public enum UserType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case owner = "owner"
        case user = "user"
        public var description: String { return self.rawValue }
    }

    public enum Card: AWSDecodableShape, Sendable {
        /// A container for the properties of the file upload card.
        case fileUpload(FileUploadCard)
        /// A container for the properties of the form input card.
        case formInput(FormInputCard)
        /// A container for the properties of the plugin card.
        case qPlugin(QPluginCard)
        /// A container for the properties of the query card.
        case qQuery(QQueryCard)
        /// A container for the properties of the text input card.
        case textInput(TextInputCard)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileUpload:
                let value = try container.decode(FileUploadCard.self, forKey: .fileUpload)
                self = .fileUpload(value)
            case .formInput:
                let value = try container.decode(FormInputCard.self, forKey: .formInput)
                self = .formInput(value)
            case .qPlugin:
                let value = try container.decode(QPluginCard.self, forKey: .qPlugin)
                self = .qPlugin(value)
            case .qQuery:
                let value = try container.decode(QQueryCard.self, forKey: .qQuery)
                self = .qQuery(value)
            case .textInput:
                let value = try container.decode(TextInputCard.self, forKey: .textInput)
                self = .textInput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileUpload = "fileUpload"
            case formInput = "formInput"
            case qPlugin = "qPlugin"
            case qQuery = "qQuery"
            case textInput = "textInput"
        }
    }

    public enum CardInput: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A container for the properties of the file upload input card.
        case fileUpload(FileUploadCardInput)
        /// A container for the properties of the form input card.
        case formInput(FormInputCardInput)
        /// A container for the properties of the plugin input card.
        case qPlugin(QPluginCardInput)
        /// A container for the properties of the query input card.
        case qQuery(QQueryCardInput)
        /// A container for the properties of the text input card.
        case textInput(TextInputCardInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileUpload:
                let value = try container.decode(FileUploadCardInput.self, forKey: .fileUpload)
                self = .fileUpload(value)
            case .formInput:
                let value = try container.decode(FormInputCardInput.self, forKey: .formInput)
                self = .formInput(value)
            case .qPlugin:
                let value = try container.decode(QPluginCardInput.self, forKey: .qPlugin)
                self = .qPlugin(value)
            case .qQuery:
                let value = try container.decode(QQueryCardInput.self, forKey: .qQuery)
                self = .qQuery(value)
            case .textInput:
                let value = try container.decode(TextInputCardInput.self, forKey: .textInput)
                self = .textInput(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fileUpload(let value):
                try container.encode(value, forKey: .fileUpload)
            case .formInput(let value):
                try container.encode(value, forKey: .formInput)
            case .qPlugin(let value):
                try container.encode(value, forKey: .qPlugin)
            case .qQuery(let value):
                try container.encode(value, forKey: .qQuery)
            case .textInput(let value):
                try container.encode(value, forKey: .textInput)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .fileUpload(let value):
                try value.validate(name: "\(name).fileUpload")
            case .formInput(let value):
                try value.validate(name: "\(name).formInput")
            case .qPlugin(let value):
                try value.validate(name: "\(name).qPlugin")
            case .qQuery(let value):
                try value.validate(name: "\(name).qQuery")
            case .textInput(let value):
                try value.validate(name: "\(name).textInput")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileUpload = "fileUpload"
            case formInput = "formInput"
            case qPlugin = "qPlugin"
            case qQuery = "qQuery"
            case textInput = "textInput"
        }
    }

    public enum DocumentAttributeValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case dateValue(Date)
        /// A long integer value.
        case longValue(Int64)
        /// A list of strings.
        case stringListValue([String])
        /// A string.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dateValue:
                let value = try container.decode(Date.self, forKey: .dateValue)
                self = .dateValue(value)
            case .longValue:
                let value = try container.decode(Int64.self, forKey: .longValue)
                self = .longValue(value)
            case .stringListValue:
                let value = try container.decode([String].self, forKey: .stringListValue)
                self = .stringListValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateValue(let value):
                try container.encode(value, forKey: .dateValue)
            case .longValue(let value):
                try container.encode(value, forKey: .longValue)
            case .stringListValue(let value):
                try container.encode(value, forKey: .stringListValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringListValue(let value):
                try value.forEach {
                    try validate($0, name: "stringListValue[]", parent: name, max: 2048)
                    try validate($0, name: "stringListValue[]", parent: name, min: 1)
                }
            case .stringValue(let value):
                try self.validate(value, name: "stringValue", parent: name, max: 2048)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateValue = "dateValue"
            case longValue = "longValue"
            case stringListValue = "stringListValue"
            case stringValue = "stringValue"
        }
    }

    public enum PredictQAppInputOptions: AWSEncodableShape, Sendable {
        /// A conversation to use as input for generating the Q App definition.
        case conversation([ConversationMessage])
        /// A problem statement to use as input for generating the Q App definition.
        case problemStatement(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conversation(let value):
                try container.encode(value, forKey: .conversation)
            case .problemStatement(let value):
                try container.encode(value, forKey: .problemStatement)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conversation = "conversation"
            case problemStatement = "problemStatement"
        }
    }

    // MARK: Shapes

    public struct AppDefinition: AWSDecodableShape {
        /// The version of the app definition schema or specification.
        public let appDefinitionVersion: String
        /// A flag indicating whether the Q App's definition can be edited by the user.
        public let canEdit: Bool?
        /// The cards that make up the Q App, such as text input, file upload, or query cards.
        public let cards: [Card]

        @inlinable
        public init(appDefinitionVersion: String, canEdit: Bool? = nil, cards: [Card]) {
            self.appDefinitionVersion = appDefinitionVersion
            self.canEdit = canEdit
            self.cards = cards
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinitionVersion = "appDefinitionVersion"
            case canEdit = "canEdit"
            case cards = "cards"
        }
    }

    public struct AppDefinitionInput: AWSEncodableShape & AWSDecodableShape {
        /// The cards that make up the Q App definition.
        public let cards: [CardInput]
        /// The initial prompt displayed when the Q App is started.
        public let initialPrompt: String?

        @inlinable
        public init(cards: [CardInput], initialPrompt: String? = nil) {
            self.cards = cards
            self.initialPrompt = initialPrompt
        }

        public func validate(name: String) throws {
            try self.cards.forEach {
                try $0.validate(name: "\(name).cards[]")
            }
            try self.validate(self.cards, name: "cards", parent: name, max: 20)
            try self.validate(self.initialPrompt, name: "initialPrompt", parent: name, max: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case cards = "cards"
            case initialPrompt = "initialPrompt"
        }
    }

    public struct AssociateLibraryItemReviewInput: AWSEncodableShape {
        /// The unique identifier for the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to associate the review with.
        public let libraryItemId: String

        @inlinable
        public init(instanceId: String, libraryItemId: String) {
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItemId = "libraryItemId"
        }
    }

    public struct AssociateQAppWithUserInput: AWSEncodableShape {
        /// The ID of the Amazon Q App to associate with the user.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public final class AttributeFilter: AWSEncodableShape & AWSDecodableShape {
        /// Performs a logical AND operation on all supplied filters.
        public let andAllFilters: [AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields. Supported for the following document attribute value types: stringListValue.
        public let containsAll: DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields. Supported for the following document attribute value types: stringListValue.
        public let containsAny: DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue, longValue, stringListValue and stringValue.
        public let equalsTo: DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let greaterThan: DocumentAttribute?
        /// Performs a greater than or equals operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let greaterThanOrEquals: DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let lessThan: DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following document attribute value type: dateValue and longValue.
        public let lessThanOrEquals: DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        public let notFilter: AttributeFilter?
        ///  Performs a logical OR operation on all supplied filters.
        public let orAllFilters: [AttributeFilter]?

        @inlinable
        public init(andAllFilters: [AttributeFilter]? = nil, containsAll: DocumentAttribute? = nil, containsAny: DocumentAttribute? = nil, equalsTo: DocumentAttribute? = nil, greaterThan: DocumentAttribute? = nil, greaterThanOrEquals: DocumentAttribute? = nil, lessThan: DocumentAttribute? = nil, lessThanOrEquals: DocumentAttribute? = nil, notFilter: AttributeFilter? = nil, orAllFilters: [AttributeFilter]? = nil) {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }

        public func validate(name: String) throws {
            try self.andAllFilters?.forEach {
                try $0.validate(name: "\(name).andAllFilters[]")
            }
            try self.containsAll?.validate(name: "\(name).containsAll")
            try self.containsAny?.validate(name: "\(name).containsAny")
            try self.equalsTo?.validate(name: "\(name).equalsTo")
            try self.greaterThan?.validate(name: "\(name).greaterThan")
            try self.greaterThanOrEquals?.validate(name: "\(name).greaterThanOrEquals")
            try self.lessThan?.validate(name: "\(name).lessThan")
            try self.lessThanOrEquals?.validate(name: "\(name).lessThanOrEquals")
            try self.notFilter?.validate(name: "\(name).notFilter")
            try self.orAllFilters?.forEach {
                try $0.validate(name: "\(name).orAllFilters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAllFilters = "andAllFilters"
            case containsAll = "containsAll"
            case containsAny = "containsAny"
            case equalsTo = "equalsTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case notFilter = "notFilter"
            case orAllFilters = "orAllFilters"
        }
    }

    public struct BatchCreateCategoryInput: AWSEncodableShape {
        /// The list of category objects to be created
        public let categories: [BatchCreateCategoryInputCategory]
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(categories: [BatchCreateCategoryInputCategory], instanceId: String) {
            self.categories = categories
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.categories.forEach {
                try $0.validate(name: "\(name).categories[]")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "categories"
        }
    }

    public struct BatchCreateCategoryInputCategory: AWSEncodableShape {
        /// The color to be associated with a category. The color must be a hexadecimal value of either 3 or 6 digits.
        public let color: String?
        /// The unique identifier to be associated with a category. If you don't include a value, the category is automatically assigned a unique identifier.
        public let id: String?
        /// The name of the category.
        public let title: String

        @inlinable
        public init(color: String? = nil, id: String? = nil, title: String) {
            self.color = color
            self.id = id
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "color"
            case id = "id"
            case title = "title"
        }
    }

    public struct BatchDeleteCategoryInput: AWSEncodableShape {
        /// The list of IDs of the categories to be deleted.
        public let categories: [String]
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(categories: [String], instanceId: String) {
            self.categories = categories
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.categories.forEach {
                try validate($0, name: "categories[]", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "categories"
        }
    }

    public struct BatchUpdateCategoryInput: AWSEncodableShape {
        /// The list of categories to be updated with their new values.
        public let categories: [CategoryInput]
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(categories: [CategoryInput], instanceId: String) {
            self.categories = categories
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.categories.forEach {
                try $0.validate(name: "\(name).categories[]")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "categories"
        }
    }

    public struct CardStatus: AWSDecodableShape {
        /// The current state of the card.
        public let currentState: ExecutionStatus
        /// The current value or result associated with the card.
        public let currentValue: String
        /// A list of previous submissions, if the card is a form card.
        public let submissions: [Submission]?

        @inlinable
        public init(currentState: ExecutionStatus, currentValue: String, submissions: [Submission]? = nil) {
            self.currentState = currentState
            self.currentValue = currentValue
            self.submissions = submissions
        }

        private enum CodingKeys: String, CodingKey {
            case currentState = "currentState"
            case currentValue = "currentValue"
            case submissions = "submissions"
        }
    }

    public struct CardValue: AWSEncodableShape {
        /// The unique identifier of the card.
        public let cardId: String
        /// The structure that describes how the current form card value is mutated. Only applies for form cards when multiple responses are allowed.
        public let submissionMutation: SubmissionMutation?
        /// The value or result associated with the card.
        public let value: String

        @inlinable
        public init(cardId: String, submissionMutation: SubmissionMutation? = nil, value: String) {
            self.cardId = cardId
            self.submissionMutation = submissionMutation
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.cardId, name: "cardId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.submissionMutation?.validate(name: "\(name).submissionMutation")
        }

        private enum CodingKeys: String, CodingKey {
            case cardId = "cardId"
            case submissionMutation = "submissionMutation"
            case value = "value"
        }
    }

    public struct Category: AWSDecodableShape {
        /// The number of published Amazon Q Apps associated with a category
        public let appCount: Int?
        /// The color of the category
        public let color: String?
        /// The unique identifier of the category.
        public let id: String
        /// The title or name of the category.
        public let title: String

        @inlinable
        public init(appCount: Int? = nil, color: String? = nil, id: String, title: String) {
            self.appCount = appCount
            self.color = color
            self.id = id
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case appCount = "appCount"
            case color = "color"
            case id = "id"
            case title = "title"
        }
    }

    public struct CategoryInput: AWSEncodableShape {
        /// The color of the category, represented as a hexadecimal value of either 3 or 6 digits.
        public let color: String?
        /// The unique identifier of the category.
        public let id: String
        /// The name of the category.
        public let title: String

        @inlinable
        public init(color: String? = nil, id: String, title: String) {
            self.color = color
            self.id = id
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "color"
            case id = "id"
            case title = "title"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The unique identifier of the resource
        public let resourceId: String
        /// The type of the resource
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ContentTooLargeException: AWSErrorShape {
        public let message: String
        /// The unique identifier of the resource
        public let resourceId: String
        /// The type of the resource
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ConversationMessage: AWSEncodableShape {
        /// The text content of the conversation message.
        public let body: String
        /// The type of the conversation message.
        public let type: Sender

        @inlinable
        public init(body: String, type: Sender) {
            self.body = body
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case type = "type"
        }
    }

    public struct CreateLibraryItemInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q App to publish to the library.
        public let appId: String
        /// The version of the Amazon Q App to publish to the library.
        public let appVersion: Int
        /// The categories to associate with the library item for easier discovery.
        public let categories: [String]
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(appId: String, appVersion: Int, categories: [String], instanceId: String) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.appVersion, forKey: .appVersion)
            try container.encode(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.appVersion, name: "appVersion", parent: name, max: 2147483647)
            try self.validate(self.appVersion, name: "appVersion", parent: name, min: 0)
            try self.categories.forEach {
                try validate($0, name: "categories[]", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
        }
    }

    public struct CreateLibraryItemOutput: AWSDecodableShape {
        /// The date and time the library item was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the library item.
        public let createdBy: String
        /// Indicates whether the library item has been verified.
        public let isVerified: Bool?
        /// The unique identifier of the new library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received from users.
        public let ratingCount: Int
        /// The status of the new library item, such as "Published".
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, isVerified: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isVerified = "isVerified"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreatePresignedUrlInput: AWSEncodableShape {
        /// The unique identifier of the Q App the file is associated with.
        public let appId: String
        /// The unique identifier of the card the file is associated with.
        public let cardId: String
        /// The Base64-encoded SHA-256 digest of the contents of the file to be uploaded.
        public let fileContentsSha256: String
        /// The name of the file to be uploaded.
        public let fileName: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// Whether the file is associated with a Q App definition or a specific Q App session.
        public let scope: DocumentScope
        /// The unique identifier of the Q App session the file is associated with, if applicable.
        public let sessionId: String?

        @inlinable
        public init(appId: String, cardId: String, fileContentsSha256: String, fileName: String, instanceId: String, scope: DocumentScope, sessionId: String? = nil) {
            self.appId = appId
            self.cardId = cardId
            self.fileContentsSha256 = fileContentsSha256
            self.fileName = fileName
            self.instanceId = instanceId
            self.scope = scope
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.cardId, forKey: .cardId)
            try container.encode(self.fileContentsSha256, forKey: .fileContentsSha256)
            try container.encode(self.fileName, forKey: .fileName)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.scope, forKey: .scope)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.cardId, name: "cardId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.fileName, name: "fileName", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case cardId = "cardId"
            case fileContentsSha256 = "fileContentsSha256"
            case fileName = "fileName"
            case scope = "scope"
            case sessionId = "sessionId"
        }
    }

    public struct CreatePresignedUrlOutput: AWSDecodableShape {
        /// The unique identifier assigned to the file to be uploaded.
        public let fileId: String
        /// The URL for a presigned S3 POST operation used to upload a file.
        public let presignedUrl: String
        /// The date and time that the presigned URL will expire in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var presignedUrlExpiration: Date
        /// The form fields to include in the presigned S3 POST operation used to upload a file.
        public let presignedUrlFields: [String: String]

        @inlinable
        public init(fileId: String, presignedUrl: String, presignedUrlExpiration: Date, presignedUrlFields: [String: String]) {
            self.fileId = fileId
            self.presignedUrl = presignedUrl
            self.presignedUrlExpiration = presignedUrlExpiration
            self.presignedUrlFields = presignedUrlFields
        }

        private enum CodingKeys: String, CodingKey {
            case fileId = "fileId"
            case presignedUrl = "presignedUrl"
            case presignedUrlExpiration = "presignedUrlExpiration"
            case presignedUrlFields = "presignedUrlFields"
        }
    }

    public struct CreateQAppInput: AWSEncodableShape {
        /// The definition of the new Q App, specifying the cards and flow.
        public let appDefinition: AppDefinitionInput
        /// The description of the new Q App.
        public let description: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// Optional tags to associate with the new Q App.
        public let tags: [String: String]?
        /// The title of the new Q App.
        public let title: String

        @inlinable
        public init(appDefinition: AppDefinitionInput, description: String? = nil, instanceId: String, tags: [String: String]? = nil, title: String) {
            self.appDefinition = appDefinition
            self.description = description
            self.instanceId = instanceId
            self.tags = tags
            self.title = title
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appDefinition, forKey: .appDefinition)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.title, forKey: .title)
        }

        public func validate(name: String) throws {
            try self.appDefinition.validate(name: "\(name).appDefinition")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinition = "appDefinition"
            case description = "description"
            case tags = "tags"
            case title = "title"
        }
    }

    public struct CreateQAppOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new Q App.
        public let appArn: String
        /// The unique identifier of the new Q App.
        public let appId: String
        /// The version of the new Q App.
        public let appVersion: Int
        /// The date and time the Q App was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the Q App.
        public let createdBy: String
        /// The description of the new Q App.
        public let description: String?
        /// The initial prompt displayed when the Q App is started.
        public let initialPrompt: String?
        /// The capabilities required to run the Q App, such as file upload or third-party integrations.
        public let requiredCapabilities: [AppRequiredCapability]?
        /// The status of the new Q App, such as "Created".
        public let status: AppStatus
        /// The title of the new Q App.
        public let title: String
        /// The date and time the Q App was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The user who last updated the Q App.
        public let updatedBy: String

        @inlinable
        public init(appArn: String, appId: String, appVersion: Int, createdAt: Date, createdBy: String, description: String? = nil, initialPrompt: String? = nil, requiredCapabilities: [AppRequiredCapability]? = nil, status: AppStatus, title: String, updatedAt: Date, updatedBy: String) {
            self.appArn = appArn
            self.appId = appId
            self.appVersion = appVersion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.initialPrompt = initialPrompt
            self.requiredCapabilities = requiredCapabilities
            self.status = status
            self.title = title
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case appVersion = "appVersion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case initialPrompt = "initialPrompt"
            case requiredCapabilities = "requiredCapabilities"
            case status = "status"
            case title = "title"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct DeleteLibraryItemInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to delete.
        public let libraryItemId: String

        @inlinable
        public init(instanceId: String, libraryItemId: String) {
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItemId = "libraryItemId"
        }
    }

    public struct DeleteQAppInput: AWSEncodableShape {
        /// The unique identifier of the Q App to delete.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DescribeQAppPermissionsInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q App for which to retrieve permissions.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appId, key: "appId")
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeQAppPermissionsOutput: AWSDecodableShape {
        /// The unique identifier of the Amazon Q App for which permissions are returned.
        public let appId: String?
        /// The list of permissions granted for the Amazon Q App.
        public let permissions: [PermissionOutput]?
        /// The Amazon Resource Name (ARN) of the Amazon Q App for which permissions are returned.
        public let resourceArn: String?

        @inlinable
        public init(appId: String? = nil, permissions: [PermissionOutput]? = nil, resourceArn: String? = nil) {
            self.appId = appId
            self.permissions = permissions
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case permissions = "permissions"
            case resourceArn = "resourceArn"
        }
    }

    public struct DisassociateLibraryItemReviewInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to remove the review from.
        public let libraryItemId: String

        @inlinable
        public init(instanceId: String, libraryItemId: String) {
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItemId = "libraryItemId"
        }
    }

    public struct DisassociateQAppFromUserInput: AWSEncodableShape {
        /// The unique identifier of the Q App to disassociate from the user.
        public let appId: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(appId: String, instanceId: String) {
            self.appId = appId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DocumentAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the attribute.
        public let name: String
        /// The value of the attribute.
        public let value: DocumentAttributeValue

        @inlinable
        public init(name: String, value: DocumentAttributeValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct ExportQAppSessionDataInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App data collection session.
        public let sessionId: String

        @inlinable
        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
        }
    }

    public struct ExportQAppSessionDataOutput: AWSDecodableShape {
        /// The link where the exported Q App session data can be downloaded from.
        public let csvFileLink: String
        /// The date and time when the link for the exported Q App session data expires.
        @CustomCoding<ISO8601DateCoder>
        public var expiresAt: Date
        /// The Amazon Resource Name (ARN) of the Q App data collection session.
        public let sessionArn: String

        @inlinable
        public init(csvFileLink: String, expiresAt: Date, sessionArn: String) {
            self.csvFileLink = csvFileLink
            self.expiresAt = expiresAt
            self.sessionArn = sessionArn
        }

        private enum CodingKeys: String, CodingKey {
            case csvFileLink = "csvFileLink"
            case expiresAt = "expiresAt"
            case sessionArn = "sessionArn"
        }
    }

    public struct FileUploadCard: AWSDecodableShape {
        /// A flag indicating if the user can override the default file for the upload card.
        public let allowOverride: Bool?
        /// Any dependencies or requirements for the file upload card.
        public let dependencies: [String]
        /// The unique identifier of the file associated with the card.
        public let fileId: String?
        /// The name of the file being uploaded.
        public let filename: String?
        /// The unique identifier of the file upload card.
        public let id: String
        /// The title of the file upload card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(allowOverride: Bool? = nil, dependencies: [String], fileId: String? = nil, filename: String? = nil, id: String, title: String, type: CardType) {
            self.allowOverride = allowOverride
            self.dependencies = dependencies
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverride = "allowOverride"
            case dependencies = "dependencies"
            case fileId = "fileId"
            case filename = "filename"
            case id = "id"
            case title = "title"
            case type = "type"
        }
    }

    public struct FileUploadCardInput: AWSEncodableShape & AWSDecodableShape {
        /// A flag indicating if the user can override the default file for the upload card.
        public let allowOverride: Bool?
        /// The identifier of a pre-uploaded file associated with the card.
        public let fileId: String?
        /// The default filename to use for the file upload card.
        public let filename: String?
        /// The unique identifier of the file upload card.
        public let id: String
        /// The title or label of the file upload card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(allowOverride: Bool? = nil, fileId: String? = nil, filename: String? = nil, id: String, title: String, type: CardType) {
            self.allowOverride = allowOverride
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.fileId, name: "fileId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.filename, name: "filename", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverride = "allowOverride"
            case fileId = "fileId"
            case filename = "filename"
            case id = "id"
            case title = "title"
            case type = "type"
        }
    }

    public struct FormInputCard: AWSDecodableShape {
        /// The compute mode of the form input card. This property determines whether individual participants of a data collection session can submit multiple response or one response. A compute mode of append shall allow participants to submit the same form multiple times with different values. A compute mode of replacecode&gt; shall overwrite the current value for each participant.
        public let computeMode: InputCardComputeMode?
        /// Any dependencies or requirements for the form input card.
        public let dependencies: [String]
        /// The unique identifier of the form input card.
        public let id: String
        /// The metadata that defines the form input card data.
        public let metadata: FormInputCardMetadata
        /// The title of the form input card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(computeMode: InputCardComputeMode? = nil, dependencies: [String], id: String, metadata: FormInputCardMetadata, title: String, type: CardType) {
            self.computeMode = computeMode
            self.dependencies = dependencies
            self.id = id
            self.metadata = metadata
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case computeMode = "computeMode"
            case dependencies = "dependencies"
            case id = "id"
            case metadata = "metadata"
            case title = "title"
            case type = "type"
        }
    }

    public struct FormInputCardInput: AWSEncodableShape & AWSDecodableShape {
        /// The compute mode of the form input card. This property determines whether individual participants of a data collection session can submit multiple response or one response. A compute mode of append shall allow participants to submit the same form multiple times with different values. A compute mode of replacecode&gt; shall overwrite the current value for each participant.
        public let computeMode: InputCardComputeMode?
        /// The unique identifier of the form input card.
        public let id: String
        /// The metadata that defines the form input card data.
        public let metadata: FormInputCardMetadata
        /// The title or label of the form input card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(computeMode: InputCardComputeMode? = nil, id: String, metadata: FormInputCardMetadata, title: String, type: CardType) {
            self.computeMode = computeMode
            self.id = id
            self.metadata = metadata
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case computeMode = "computeMode"
            case id = "id"
            case metadata = "metadata"
            case title = "title"
            case type = "type"
        }
    }

    public struct FormInputCardMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The JSON schema that defines the shape of the response data.
        public let schema: AWSDocument

        @inlinable
        public init(schema: AWSDocument) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct GetLibraryItemInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q App associated with the library item.
        public let appId: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to retrieve.
        public let libraryItemId: String

        @inlinable
        public init(appId: String? = nil, instanceId: String, libraryItemId: String) {
            self.appId = appId
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appId, key: "appId")
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.libraryItemId, key: "libraryItemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLibraryItemOutput: AWSDecodableShape {
        /// The unique identifier of the Q App associated with the library item.
        public let appId: String
        /// The version of the Q App associated with the library item.
        public let appVersion: Int
        /// The categories associated with the library item for discovery.
        public let categories: [Category]
        /// The date and time the library item was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the library item.
        public let createdBy: String
        /// Whether the current user has rated the library item.
        public let isRatedByUser: Bool?
        /// Indicates whether the library item has been verified.
        public let isVerified: Bool?
        /// The unique identifier of the library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received from users.
        public let ratingCount: Int
        /// The status of the library item, such as "Published".
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?
        /// The number of users who have associated the Q App with their account.
        public let userCount: Int?

        @inlinable
        public init(appId: String, appVersion: Int, categories: [Category], createdAt: Date, createdBy: String, isRatedByUser: Bool? = nil, isVerified: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil, userCount: Int? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isRatedByUser = "isRatedByUser"
            case isVerified = "isVerified"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case userCount = "userCount"
        }
    }

    public struct GetQAppInput: AWSEncodableShape {
        /// The unique identifier of the Q App to retrieve.
        public let appId: String
        /// The version of the Q App.
        public let appVersion: Int?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(appId: String, appVersion: Int? = nil, instanceId: String) {
            self.appId = appId
            self.appVersion = appVersion
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appId, key: "appId")
            request.encodeQuery(self.appVersion, key: "appVersion")
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.appVersion, name: "appVersion", parent: name, max: 2147483647)
            try self.validate(self.appVersion, name: "appVersion", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQAppOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Q App.
        public let appArn: String
        /// The full definition of the Q App, specifying the cards and flow.
        public let appDefinition: AppDefinition
        /// The unique identifier of the Q App.
        public let appId: String
        /// The version of the Q App.
        public let appVersion: Int
        /// The date and time the Q App was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the Q App.
        public let createdBy: String
        /// The description of the Q App.
        public let description: String?
        /// The initial prompt displayed when the Q App is started.
        public let initialPrompt: String?
        /// The capabilities required to run the Q App, such as file upload or third-party integrations.
        public let requiredCapabilities: [AppRequiredCapability]?
        /// The status of the Q App.
        public let status: AppStatus
        /// The title of the Q App.
        public let title: String
        /// The date and time the Q App was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The user who last updated the Q App.
        public let updatedBy: String

        @inlinable
        public init(appArn: String, appDefinition: AppDefinition, appId: String, appVersion: Int, createdAt: Date, createdBy: String, description: String? = nil, initialPrompt: String? = nil, requiredCapabilities: [AppRequiredCapability]? = nil, status: AppStatus, title: String, updatedAt: Date, updatedBy: String) {
            self.appArn = appArn
            self.appDefinition = appDefinition
            self.appId = appId
            self.appVersion = appVersion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.initialPrompt = initialPrompt
            self.requiredCapabilities = requiredCapabilities
            self.status = status
            self.title = title
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appDefinition = "appDefinition"
            case appId = "appId"
            case appVersion = "appVersion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case initialPrompt = "initialPrompt"
            case requiredCapabilities = "requiredCapabilities"
            case status = "status"
            case title = "title"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to retrieve.
        public let sessionId: String

        @inlinable
        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQAppSessionMetadataInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session.
        public let sessionId: String

        @inlinable
        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQAppSessionMetadataOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Q App session.
        public let sessionArn: String
        /// The unique identifier of the Q App session.
        public let sessionId: String
        /// The name of the Q App session.
        public let sessionName: String?
        /// Indicates whether the current user is the owner of the Q App session.
        public let sessionOwner: Bool?
        /// The sharing configuration of the Q App data collection session.
        public let sharingConfiguration: SessionSharingConfiguration

        @inlinable
        public init(sessionArn: String, sessionId: String, sessionName: String? = nil, sessionOwner: Bool? = nil, sharingConfiguration: SessionSharingConfiguration) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionName = sessionName
            self.sessionOwner = sessionOwner
            self.sharingConfiguration = sharingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionName = "sessionName"
            case sessionOwner = "sessionOwner"
            case sharingConfiguration = "sharingConfiguration"
        }
    }

    public struct GetQAppSessionOutput: AWSDecodableShape {
        /// The version of the Q App used for the session.
        public let appVersion: Int?
        /// The current status for each card in the Q App session.
        public let cardStatus: [String: CardStatus]
        /// The latest published version of the Q App used for the session.
        public let latestPublishedAppVersion: Int?
        /// The Amazon Resource Name (ARN) of the Q App session.
        public let sessionArn: String
        /// The unique identifier of the Q App session.
        public let sessionId: String
        /// The name of the Q App session.
        public let sessionName: String?
        /// The current status of the Q App session.
        public let status: ExecutionStatus
        /// Indicates whether the current user is the owner of the Q App data collection session.
        public let userIsHost: Bool?

        @inlinable
        public init(appVersion: Int? = nil, cardStatus: [String: CardStatus], latestPublishedAppVersion: Int? = nil, sessionArn: String, sessionId: String, sessionName: String? = nil, status: ExecutionStatus, userIsHost: Bool? = nil) {
            self.appVersion = appVersion
            self.cardStatus = cardStatus
            self.latestPublishedAppVersion = latestPublishedAppVersion
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionName = sessionName
            self.status = status
            self.userIsHost = userIsHost
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion = "appVersion"
            case cardStatus = "cardStatus"
            case latestPublishedAppVersion = "latestPublishedAppVersion"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionName = "sessionName"
            case status = "status"
            case userIsHost = "userIsHost"
        }
    }

    public struct ImportDocumentInput: AWSEncodableShape {
        /// The unique identifier of the Q App the file is associated with.
        public let appId: String
        /// The unique identifier of the card the file is associated with.
        public let cardId: String
        /// The base64-encoded contents of the file to upload.
        public let fileContentsBase64: String
        /// The name of the file being uploaded.
        public let fileName: String
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// Whether the file is associated with a Q App definition or a specific Q App session.
        public let scope: DocumentScope
        /// The unique identifier of the Q App session the file is associated with, if applicable.
        public let sessionId: String?

        @inlinable
        public init(appId: String, cardId: String, fileContentsBase64: String, fileName: String, instanceId: String, scope: DocumentScope, sessionId: String? = nil) {
            self.appId = appId
            self.cardId = cardId
            self.fileContentsBase64 = fileContentsBase64
            self.fileName = fileName
            self.instanceId = instanceId
            self.scope = scope
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.cardId, forKey: .cardId)
            try container.encode(self.fileContentsBase64, forKey: .fileContentsBase64)
            try container.encode(self.fileName, forKey: .fileName)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.scope, forKey: .scope)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.cardId, name: "cardId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.fileName, name: "fileName", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case cardId = "cardId"
            case fileContentsBase64 = "fileContentsBase64"
            case fileName = "fileName"
            case scope = "scope"
            case sessionId = "sessionId"
        }
    }

    public struct ImportDocumentOutput: AWSDecodableShape {
        /// The unique identifier assigned to the uploaded file.
        public let fileId: String?

        @inlinable
        public init(fileId: String? = nil) {
            self.fileId = fileId
        }

        private enum CodingKeys: String, CodingKey {
            case fileId = "fileId"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the operation
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct LibraryItemMember: AWSDecodableShape {
        /// The unique identifier of the Q App associated with the library item.
        public let appId: String
        /// The version of the Q App associated with the library item.
        public let appVersion: Int
        /// The categories associated with the library item.
        public let categories: [Category]
        /// The date and time the library item was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who created the library item.
        public let createdBy: String
        /// Whether the current user has rated the library item.
        public let isRatedByUser: Bool?
        /// Indicates whether the library item has been verified.
        public let isVerified: Bool?
        /// The unique identifier of the library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received.
        public let ratingCount: Int
        /// The status of the library item.
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?
        /// The number of users who have the associated Q App.
        public let userCount: Int?

        @inlinable
        public init(appId: String, appVersion: Int, categories: [Category], createdAt: Date, createdBy: String, isRatedByUser: Bool? = nil, isVerified: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil, userCount: Int? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isRatedByUser = "isRatedByUser"
            case isVerified = "isVerified"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case userCount = "userCount"
        }
    }

    public struct ListCategoriesInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String

        @inlinable
        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCategoriesOutput: AWSDecodableShape {
        /// The categories of a Amazon Q Business application environment instance.
        public let categories: [Category]?

        @inlinable
        public init(categories: [Category]? = nil) {
            self.categories = categories
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "categories"
        }
    }

    public struct ListLibraryItemsInput: AWSEncodableShape {
        /// Optional category to filter the library items by.
        public let categoryId: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The maximum number of library items to return in the response.
        public let limit: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(categoryId: String? = nil, instanceId: String, limit: Int? = nil, nextToken: String? = nil) {
            self.categoryId = categoryId
            self.instanceId = instanceId
            self.limit = limit
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.categoryId, key: "categoryId")
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.categoryId, name: "categoryId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 300)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLibraryItemsOutput: AWSDecodableShape {
        /// The list of library items meeting the request criteria.
        public let libraryItems: [LibraryItemMember]?
        /// The token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(libraryItems: [LibraryItemMember]? = nil, nextToken: String? = nil) {
            self.libraryItems = libraryItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case libraryItems = "libraryItems"
            case nextToken = "nextToken"
        }
    }

    public struct ListQAppSessionDataInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App data collection session.
        public let sessionId: String

        @inlinable
        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQAppSessionDataOutput: AWSDecodableShape {
        ///  The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the Q App data collection session.
        public let sessionArn: String
        /// The collected responses of a Q App session.
        public let sessionData: [QAppSessionData]?
        /// The unique identifier of the Q App data collection session.
        public let sessionId: String

        @inlinable
        public init(nextToken: String? = nil, sessionArn: String, sessionData: [QAppSessionData]? = nil, sessionId: String) {
            self.nextToken = nextToken
            self.sessionArn = sessionArn
            self.sessionData = sessionData
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionArn = "sessionArn"
            case sessionData = "sessionData"
            case sessionId = "sessionId"
        }
    }

    public struct ListQAppsInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The maximum number of Q Apps to return in the response.
        public let limit: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, limit: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.limit = limit
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 300)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQAppsOutput: AWSDecodableShape {
        /// The list of Amazon Q Apps meeting the request criteria.
        public let apps: [UserAppItem]
        /// The token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(apps: [UserAppItem], nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps = "apps"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags should be listed.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags that are assigned to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PermissionInput: AWSEncodableShape {
        /// The action associated with the permission.
        public let action: Action
        /// The principal user to which the permission applies.
        public let principal: String

        @inlinable
        public init(action: Action, principal: String) {
            self.action = action
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case principal = "principal"
        }
    }

    public struct PermissionOutput: AWSDecodableShape {
        /// The action associated with the permission.
        public let action: Action
        /// The principal user to which the permission applies.
        public let principal: PrincipalOutput

        @inlinable
        public init(action: Action, principal: PrincipalOutput) {
            self.action = action
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case principal = "principal"
        }
    }

    public struct PredictAppDefinition: AWSDecodableShape {
        /// The definition specifying the cards and flow of the generated Q App.
        public let appDefinition: AppDefinitionInput
        /// The description of the generated Q App definition.
        public let description: String?
        /// The title of the generated Q App definition.
        public let title: String

        @inlinable
        public init(appDefinition: AppDefinitionInput, description: String? = nil, title: String) {
            self.appDefinition = appDefinition
            self.description = description
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinition = "appDefinition"
            case description = "description"
            case title = "title"
        }
    }

    public struct PredictQAppInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The input to generate the Q App definition from, either a conversation or problem statement.
        public let options: PredictQAppInputOptions?

        @inlinable
        public init(instanceId: String, options: PredictQAppInputOptions? = nil) {
            self.instanceId = instanceId
            self.options = options
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.options, forKey: .options)
        }

        private enum CodingKeys: String, CodingKey {
            case options = "options"
        }
    }

    public struct PredictQAppOutput: AWSDecodableShape {
        /// The generated Q App definition.
        public let app: PredictAppDefinition
        /// The problem statement extracted from the input conversation, if provided.
        public let problemStatement: String

        @inlinable
        public init(app: PredictAppDefinition, problemStatement: String) {
            self.app = app
            self.problemStatement = problemStatement
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case problemStatement = "problemStatement"
        }
    }

    public struct PrincipalOutput: AWSDecodableShape {
        /// The email address associated with the user.
        public let email: String?
        /// The unique identifier of the user.
        public let userId: String?
        /// The type of the user.
        public let userType: UserType?

        @inlinable
        public init(email: String? = nil, userId: String? = nil, userType: UserType? = nil) {
            self.email = email
            self.userId = userId
            self.userType = userType
        }

        private enum CodingKeys: String, CodingKey {
            case email = "email"
            case userId = "userId"
            case userType = "userType"
        }
    }

    public struct QAppSessionData: AWSDecodableShape {
        /// The card Id associated with the response submitted for a Q App session.
        public let cardId: String
        /// The unique identifier of the submission.
        public let submissionId: String?
        /// The date and time when the session data is submitted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var timestamp: Date?
        /// The user who submitted the response for a Q App session.
        public let user: User
        /// The response submitted for a Q App session.
        public let value: AWSDocument?

        @inlinable
        public init(cardId: String, submissionId: String? = nil, timestamp: Date? = nil, user: User, value: AWSDocument? = nil) {
            self.cardId = cardId
            self.submissionId = submissionId
            self.timestamp = timestamp
            self.user = user
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case cardId = "cardId"
            case submissionId = "submissionId"
            case timestamp = "timestamp"
            case user = "user"
            case value = "value"
        }
    }

    public struct QPluginCard: AWSDecodableShape {
        /// The action identifier of the action to be performed by the plugin card.
        public let actionIdentifier: String?
        /// Any dependencies or requirements for the plugin card.
        public let dependencies: [String]
        /// The unique identifier of the plugin card.
        public let id: String
        /// The unique identifier of the plugin used by the card.
        public let pluginId: String
        /// The type or category of the plugin used by the card.
        public let pluginType: PluginType
        /// The prompt or instructions displayed for the plugin card.
        public let prompt: String
        /// The title or label of the plugin card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(actionIdentifier: String? = nil, dependencies: [String], id: String, pluginId: String, pluginType: PluginType, prompt: String, title: String, type: CardType) {
            self.actionIdentifier = actionIdentifier
            self.dependencies = dependencies
            self.id = id
            self.pluginId = pluginId
            self.pluginType = pluginType
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionIdentifier = "actionIdentifier"
            case dependencies = "dependencies"
            case id = "id"
            case pluginId = "pluginId"
            case pluginType = "pluginType"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct QPluginCardInput: AWSEncodableShape & AWSDecodableShape {
        /// The action identifier of the action to be performed by the plugin card.
        public let actionIdentifier: String?
        /// The unique identifier of the plugin card.
        public let id: String
        /// The unique identifier of the plugin used by the card.
        public let pluginId: String
        /// The prompt or instructions displayed for the plugin card.
        public let prompt: String
        /// The title or label of the plugin card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(actionIdentifier: String? = nil, id: String, pluginId: String, prompt: String, title: String, type: CardType) {
            self.actionIdentifier = actionIdentifier
            self.id = id
            self.pluginId = pluginId
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.actionIdentifier, name: "actionIdentifier", parent: name, max: 256)
            try self.validate(self.actionIdentifier, name: "actionIdentifier", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.prompt, name: "prompt", parent: name, max: 50000)
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionIdentifier = "actionIdentifier"
            case id = "id"
            case pluginId = "pluginId"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct QQueryCard: AWSDecodableShape {
        /// The Amazon Q Business filters applied in this query card when resolving data sources
        public let attributeFilter: AttributeFilter?
        /// Any dependencies or requirements for the query card.
        public let dependencies: [String]
        /// The unique identifier of the query card.
        public let id: String
        /// Any dependencies for the query card, where the dependencies are references to the collected responses.
        public let memoryReferences: [String]?
        /// The source or type of output generated by the query card.
        public let outputSource: CardOutputSource
        /// The prompt or instructions displayed for the query card.
        public let prompt: String
        /// The title or label of the query card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(attributeFilter: AttributeFilter? = nil, dependencies: [String], id: String, memoryReferences: [String]? = nil, outputSource: CardOutputSource, prompt: String, title: String, type: CardType) {
            self.attributeFilter = attributeFilter
            self.dependencies = dependencies
            self.id = id
            self.memoryReferences = memoryReferences
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "attributeFilter"
            case dependencies = "dependencies"
            case id = "id"
            case memoryReferences = "memoryReferences"
            case outputSource = "outputSource"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct QQueryCardInput: AWSEncodableShape & AWSDecodableShape {
        /// Turns on filtering of responses based on document attributes or metadata fields.
        public let attributeFilter: AttributeFilter?
        /// The unique identifier of the query card.
        public let id: String
        /// The source or type of output to generate for the query card.
        public let outputSource: CardOutputSource?
        /// The prompt or instructions displayed for the query card.
        public let prompt: String
        /// The title or label of the query card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(attributeFilter: AttributeFilter? = nil, id: String, outputSource: CardOutputSource? = nil, prompt: String, title: String, type: CardType) {
            self.attributeFilter = attributeFilter
            self.id = id
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.attributeFilter?.validate(name: "\(name).attributeFilter")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.prompt, name: "prompt", parent: name, max: 50000)
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "attributeFilter"
            case id = "id"
            case outputSource = "outputSource"
            case prompt = "prompt"
            case title = "title"
            case type = "type"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The unique identifier of the resource
        public let resourceId: String
        /// The type of the resource
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The code of the quota that was exceeded
        public let quotaCode: String
        /// The unique identifier of the resource
        public let resourceId: String
        /// The type of the resource
        public let resourceType: String
        /// The code for the service where the quota was exceeded
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct SessionSharingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether an Q App session can accept responses from users.
        public let acceptResponses: Bool?
        /// Indicates whether an Q App session is shareable with other users.
        public let enabled: Bool
        /// Indicates whether collected responses for an Q App session are revealed for all users.
        public let revealCards: Bool?

        @inlinable
        public init(acceptResponses: Bool? = nil, enabled: Bool, revealCards: Bool? = nil) {
            self.acceptResponses = acceptResponses
            self.enabled = enabled
            self.revealCards = revealCards
        }

        private enum CodingKeys: String, CodingKey {
            case acceptResponses = "acceptResponses"
            case enabled = "enabled"
            case revealCards = "revealCards"
        }
    }

    public struct StartQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Q App to start a session for.
        public let appId: String
        /// The version of the Q App to use for the session.
        public let appVersion: Int
        /// Optional initial input values to provide for the Q App session.
        public let initialValues: [CardValue]?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the a Q App session.
        public let sessionId: String?
        /// Optional tags to associate with the new Q App session.
        public let tags: [String: String]?

        @inlinable
        public init(appId: String, appVersion: Int, initialValues: [CardValue]? = nil, instanceId: String, sessionId: String? = nil, tags: [String: String]? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.initialValues = initialValues
            self.instanceId = instanceId
            self.sessionId = sessionId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encode(self.appVersion, forKey: .appVersion)
            try container.encodeIfPresent(self.initialValues, forKey: .initialValues)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.appVersion, name: "appVersion", parent: name, max: 2147483647)
            try self.validate(self.appVersion, name: "appVersion", parent: name, min: 0)
            try self.initialValues?.forEach {
                try $0.validate(name: "\(name).initialValues[]")
            }
            try self.validate(self.initialValues, name: "initialValues", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case initialValues = "initialValues"
            case sessionId = "sessionId"
            case tags = "tags"
        }
    }

    public struct StartQAppSessionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new Q App session.
        public let sessionArn: String
        /// The unique identifier of the new or retrieved Q App session.
        public let sessionId: String

        @inlinable
        public init(sessionArn: String, sessionId: String) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct StopQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to stop.
        public let sessionId: String

        @inlinable
        public init(instanceId: String, sessionId: String) {
            self.instanceId = instanceId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
        }
    }

    public struct Submission: AWSDecodableShape {
        /// The unique identifier of the submission.
        public let submissionId: String?
        /// The date and time when the card is submitted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var timestamp: Date?
        /// The data submitted by the user.
        public let value: AWSDocument?

        @inlinable
        public init(submissionId: String? = nil, timestamp: Date? = nil, value: AWSDocument? = nil) {
            self.submissionId = submissionId
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case submissionId = "submissionId"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct SubmissionMutation: AWSEncodableShape {
        /// The operation that is performed on a submission.
        public let mutationType: SubmissionMutationKind
        /// The unique identifier of the submission.
        public let submissionId: String

        @inlinable
        public init(mutationType: SubmissionMutationKind, submissionId: String) {
            self.mutationType = mutationType
            self.submissionId = submissionId
        }

        public func validate(name: String) throws {
            try self.validate(self.submissionId, name: "submissionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case mutationType = "mutationType"
            case submissionId = "submissionId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceARN: String
        /// The tags to associate with the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextInputCard: AWSDecodableShape {
        /// The default value to pre-populate in the text input field.
        public let defaultValue: String?
        /// Any dependencies or requirements for the text input card.
        public let dependencies: [String]
        /// The unique identifier of the text input card.
        public let id: String
        /// The placeholder text to display in the text input field.
        public let placeholder: String?
        /// The title or label of the text input card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(defaultValue: String? = nil, dependencies: [String], id: String, placeholder: String? = nil, title: String, type: CardType) {
            self.defaultValue = defaultValue
            self.dependencies = dependencies
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case dependencies = "dependencies"
            case id = "id"
            case placeholder = "placeholder"
            case title = "title"
            case type = "type"
        }
    }

    public struct TextInputCardInput: AWSEncodableShape & AWSDecodableShape {
        /// The default value to pre-populate in the text input field.
        public let defaultValue: String?
        /// The unique identifier of the text input card.
        public let id: String
        /// The placeholder text to display in the text input field.
        public let placeholder: String?
        /// The title or label of the text input card.
        public let title: String
        /// The type of the card.
        public let type: CardType

        @inlinable
        public init(defaultValue: String? = nil, id: String, placeholder: String? = nil, title: String, type: CardType) {
            self.defaultValue = defaultValue
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.placeholder, name: "placeholder", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case id = "id"
            case placeholder = "placeholder"
            case title = "title"
            case type = "type"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The code of the quota that was exceeded
        public let quotaCode: String
        /// The number of seconds to wait before retrying the operation
        public let retryAfterSeconds: Int?
        /// The code for the service where the quota was exceeded
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, retryAfterSeconds: Int? = nil, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decode(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decode(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to disassociate the tag from.
        public let resourceARN: String
        /// The keys of the tags to disassociate from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLibraryItemInput: AWSEncodableShape {
        /// The new categories to associate with the library item.
        public let categories: [String]?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the library item to update.
        public let libraryItemId: String
        /// The new status to set for the library item, such as "Published" or "Hidden".
        public let status: LibraryItemStatus?

        @inlinable
        public init(categories: [String]? = nil, instanceId: String, libraryItemId: String, status: LibraryItemStatus? = nil) {
            self.categories = categories
            self.instanceId = instanceId
            self.libraryItemId = libraryItemId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.categories, forKey: .categories)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.categories?.forEach {
                try validate($0, name: "categories[]", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 3)
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "categories"
            case libraryItemId = "libraryItemId"
            case status = "status"
        }
    }

    public struct UpdateLibraryItemMetadataInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The verification status of the library item
        public let isVerified: Bool?
        /// The unique identifier of the updated library item.
        public let libraryItemId: String

        @inlinable
        public init(instanceId: String, isVerified: Bool? = nil, libraryItemId: String) {
            self.instanceId = instanceId
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.isVerified, forKey: .isVerified)
            try container.encode(self.libraryItemId, forKey: .libraryItemId)
        }

        public func validate(name: String) throws {
            try self.validate(self.libraryItemId, name: "libraryItemId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case isVerified = "isVerified"
            case libraryItemId = "libraryItemId"
        }
    }

    public struct UpdateLibraryItemOutput: AWSDecodableShape {
        /// The unique identifier of the Q App associated with the library item.
        public let appId: String
        /// The version of the Q App associated with the library item.
        public let appVersion: Int
        /// The categories associated with the updated library item.
        public let categories: [Category]
        /// The date and time the library item was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who originally created the library item.
        public let createdBy: String
        /// Whether the current user has rated the library item.
        public let isRatedByUser: Bool?
        /// Indicates whether the library item has been verified.
        public let isVerified: Bool?
        /// The unique identifier of the updated library item.
        public let libraryItemId: String
        /// The number of ratings the library item has received.
        public let ratingCount: Int
        /// The new status of the updated library item.
        public let status: String
        /// The date and time the library item was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user who last updated the library item.
        public let updatedBy: String?
        /// The number of users who have the associated Q App.
        public let userCount: Int?

        @inlinable
        public init(appId: String, appVersion: Int, categories: [Category], createdAt: Date, createdBy: String, isRatedByUser: Bool? = nil, isVerified: Bool? = nil, libraryItemId: String, ratingCount: Int, status: String, updatedAt: Date? = nil, updatedBy: String? = nil, userCount: Int? = nil) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appVersion = "appVersion"
            case categories = "categories"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case isRatedByUser = "isRatedByUser"
            case isVerified = "isVerified"
            case libraryItemId = "libraryItemId"
            case ratingCount = "ratingCount"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case userCount = "userCount"
        }
    }

    public struct UpdateQAppInput: AWSEncodableShape {
        /// The new definition specifying the cards and flow for the Q App.
        public let appDefinition: AppDefinitionInput?
        /// The unique identifier of the Q App to update.
        public let appId: String
        /// The new description for the Q App.
        public let description: String?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The new title for the Q App.
        public let title: String?

        @inlinable
        public init(appDefinition: AppDefinitionInput? = nil, appId: String, description: String? = nil, instanceId: String, title: String? = nil) {
            self.appDefinition = appDefinition
            self.appId = appId
            self.description = description
            self.instanceId = instanceId
            self.title = title
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.appDefinition, forKey: .appDefinition)
            try container.encode(self.appId, forKey: .appId)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.title, forKey: .title)
        }

        public func validate(name: String) throws {
            try self.appDefinition?.validate(name: "\(name).appDefinition")
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[^{}\\\\\"<>]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case appDefinition = "appDefinition"
            case appId = "appId"
            case description = "description"
            case title = "title"
        }
    }

    public struct UpdateQAppOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated Q App.
        public let appArn: String
        /// The unique identifier of the updated Q App.
        public let appId: String
        /// The new version of the updated Q App.
        public let appVersion: Int
        /// The date and time the Q App was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user who originally created the Q App.
        public let createdBy: String
        /// The new description of the updated Q App.
        public let description: String?
        /// The initial prompt for the updated Q App.
        public let initialPrompt: String?
        /// The capabilities required for the updated Q App.
        public let requiredCapabilities: [AppRequiredCapability]?
        /// The status of the updated Q App.
        public let status: AppStatus
        /// The new title of the updated Q App.
        public let title: String
        /// The date and time the Q App was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The user who last updated the Q App.
        public let updatedBy: String

        @inlinable
        public init(appArn: String, appId: String, appVersion: Int, createdAt: Date, createdBy: String, description: String? = nil, initialPrompt: String? = nil, requiredCapabilities: [AppRequiredCapability]? = nil, status: AppStatus, title: String, updatedAt: Date, updatedBy: String) {
            self.appArn = appArn
            self.appId = appId
            self.appVersion = appVersion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.initialPrompt = initialPrompt
            self.requiredCapabilities = requiredCapabilities
            self.status = status
            self.title = title
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case appVersion = "appVersion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case initialPrompt = "initialPrompt"
            case requiredCapabilities = "requiredCapabilities"
            case status = "status"
            case title = "title"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateQAppPermissionsInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q App for which permissions are being updated.
        public let appId: String
        /// The list of permissions to grant for the Amazon Q App.
        public let grantPermissions: [PermissionInput]?
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The list of permissions to revoke for the Amazon Q App.
        public let revokePermissions: [PermissionInput]?

        @inlinable
        public init(appId: String, grantPermissions: [PermissionInput]? = nil, instanceId: String, revokePermissions: [PermissionInput]? = nil) {
            self.appId = appId
            self.grantPermissions = grantPermissions
            self.instanceId = instanceId
            self.revokePermissions = revokePermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appId, forKey: .appId)
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case grantPermissions = "grantPermissions"
            case revokePermissions = "revokePermissions"
        }
    }

    public struct UpdateQAppPermissionsOutput: AWSDecodableShape {
        /// The unique identifier of the Amazon Q App for which permissions were updated.
        public let appId: String?
        /// The updated list of permissions for the Amazon Q App.
        public let permissions: [PermissionOutput]?
        /// The Amazon Resource Name (ARN) of the Amazon Q App for which permissions were updated.
        public let resourceArn: String?

        @inlinable
        public init(appId: String? = nil, permissions: [PermissionOutput]? = nil, resourceArn: String? = nil) {
            self.appId = appId
            self.permissions = permissions
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case permissions = "permissions"
            case resourceArn = "resourceArn"
        }
    }

    public struct UpdateQAppSessionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to provide input for.
        public let sessionId: String
        /// The input values to provide for the current state of the Q App session.
        public let values: [CardValue]?

        @inlinable
        public init(instanceId: String, sessionId: String, values: [CardValue]? = nil) {
            self.instanceId = instanceId
            self.sessionId = sessionId
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.sessionId, forKey: .sessionId)
            try container.encodeIfPresent(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case values = "values"
        }
    }

    public struct UpdateQAppSessionMetadataInput: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application environment instance.
        public let instanceId: String
        /// The unique identifier of the Q App session to update configuration for.
        public let sessionId: String
        /// The new name for the Q App session.
        public let sessionName: String?
        /// The new sharing configuration for the Q App data collection session.
        public let sharingConfiguration: SessionSharingConfiguration

        @inlinable
        public init(instanceId: String, sessionId: String, sessionName: String? = nil, sharingConfiguration: SessionSharingConfiguration) {
            self.instanceId = instanceId
            self.sessionId = sessionId
            self.sessionName = sessionName
            self.sharingConfiguration = sharingConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.instanceId, key: "instance-id")
            try container.encode(self.sessionId, forKey: .sessionId)
            try container.encodeIfPresent(self.sessionName, forKey: .sessionName)
            try container.encode(self.sharingConfiguration, forKey: .sharingConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\da-f]{8}-[\\da-f]{4}-[45][\\da-f]{3}-[89ABab][\\da-f]{3}-[\\da-f]{12}$")
            try self.validate(self.sessionName, name: "sessionName", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case sessionName = "sessionName"
            case sharingConfiguration = "sharingConfiguration"
        }
    }

    public struct UpdateQAppSessionMetadataOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated Q App session.
        public let sessionArn: String
        /// The unique identifier of the updated Q App session.
        public let sessionId: String
        /// The new name of the updated Q App session.
        public let sessionName: String?
        /// The new sharing configuration of the updated Q App data collection session.
        public let sharingConfiguration: SessionSharingConfiguration

        @inlinable
        public init(sessionArn: String, sessionId: String, sessionName: String? = nil, sharingConfiguration: SessionSharingConfiguration) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionName = sessionName
            self.sharingConfiguration = sharingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case sessionName = "sessionName"
            case sharingConfiguration = "sharingConfiguration"
        }
    }

    public struct UpdateQAppSessionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated Q App session.
        public let sessionArn: String
        /// The unique identifier of the updated Q App session.
        public let sessionId: String

        @inlinable
        public init(sessionArn: String, sessionId: String) {
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct User: AWSDecodableShape {
        /// The unique identifier of a user.
        public let userId: String?

        @inlinable
        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
        }
    }

    public struct UserAppItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Q App.
        public let appArn: String
        /// The unique identifier of the Q App.
        public let appId: String
        /// A flag indicating whether the user can edit the Q App.
        public let canEdit: Bool?
        /// The date and time the user's association with the Q App was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the Q App.
        public let description: String?
        /// Indicates whether the Q App has been verified.
        public let isVerified: Bool?
        /// The status of the user's association with the Q App.
        public let status: String?
        /// The title of the Q App.
        public let title: String

        @inlinable
        public init(appArn: String, appId: String, canEdit: Bool? = nil, createdAt: Date, description: String? = nil, isVerified: Bool? = nil, status: String? = nil, title: String) {
            self.appArn = appArn
            self.appId = appId
            self.canEdit = canEdit
            self.createdAt = createdAt
            self.description = description
            self.isVerified = isVerified
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case canEdit = "canEdit"
            case createdAt = "createdAt"
            case description = "description"
            case isVerified = "isVerified"
            case status = "status"
            case title = "title"
        }
    }
}

// MARK: - Errors

/// Error enum for QApps
public struct QAppsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case contentTooLargeException = "ContentTooLargeException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QApps
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The client is not authorized to perform the requested operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation could not be completed due to a conflict with the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The requested operation could not be completed because the content exceeds the maximum allowed size.
    public static var contentTooLargeException: Self { .init(.contentTooLargeException) }
    /// An internal service error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The requested operation could not be completed because it would exceed the service's quota or limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The requested operation could not be completed because too many requests were sent at once. Wait a bit and try again later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The client is not authenticated or authorized to perform the requested operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input failed to satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension QAppsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": QApps.ConflictException.self,
        "ContentTooLargeException": QApps.ContentTooLargeException.self,
        "InternalServerException": QApps.InternalServerException.self,
        "ResourceNotFoundException": QApps.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": QApps.ServiceQuotaExceededException.self,
        "ThrottlingException": QApps.ThrottlingException.self
    ]
}

extension QAppsErrorType: Equatable {
    public static func == (lhs: QAppsErrorType, rhs: QAppsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QAppsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
