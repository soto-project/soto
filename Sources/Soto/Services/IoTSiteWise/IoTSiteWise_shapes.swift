//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTSiteWise {
    // MARK: Enums

    public enum AggregateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case average = "AVERAGE"
        case count = "COUNT"
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        case standardDeviation = "STANDARD_DEVIATION"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AssetErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case propagating = "PROPAGATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assetModel = "ASSET_MODEL"
        case componentModel = "COMPONENT_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum AssetRelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hierarchy = "HIERARCHY"
        public var description: String { return self.rawValue }
    }

    public enum AssetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AuthMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum BatchEntryCompletionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyAggregatesErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyValueHistoryErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchPutAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case conflictingOperationException = "ConflictingOperationException"
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case timestampOutOfRangeException = "TimestampOutOfRangeException"
        public var description: String { return self.rawValue }
    }

    public enum CapabilitySyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inSync = "IN_SYNC"
        case outOfSync = "OUT_OF_SYNC"
        case syncFailed = "SYNC_FAILED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum ColumnName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alias = "ALIAS"
        case assetId = "ASSET_ID"
        case dataType = "DATA_TYPE"
        case propertyId = "PROPERTY_ID"
        case quality = "QUALITY"
        case timestampNanoOffset = "TIMESTAMP_NANO_OFFSET"
        case timestampSeconds = "TIMESTAMP_SECONDS"
        case value = "VALUE"
        public var description: String { return self.rawValue }
    }

    public enum ComputeLocation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case edge = "EDGE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DetailedErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case incompatibleComputeLocation = "INCOMPATIBLE_COMPUTE_LOCATION"
        case incompatibleForwardingConfiguration = "INCOMPATIBLE_FORWARDING_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum DisassociatedDataStorageState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kmsBasedEncryption = "KMS_BASED_ENCRYPTION"
        case sitewiseDefaultEncryption = "SITEWISE_DEFAULT_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ForwardingConfigState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case group = "GROUP"
        case iam = "IAM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ImageFileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case png = "PNG"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetModelPropertiesFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case base = "BASE"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetPropertiesFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case base = "BASE"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetsFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case topLevel = "TOP_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum ListBulkImportJobsFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ListTimeSeriesType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associated = "ASSOCIATED"
        case disassociated = "DISASSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case info = "INFO"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum MonitorErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        case limitExceeded = "LIMIT_EXCEEDED"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case administrator = "ADMINISTRATOR"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PortalState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PropertyDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `struct` = "STRUCT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum PropertyNotificationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Quality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bad = "BAD"
        case good = "GOOD"
        case uncertain = "UNCERTAIN"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case portal = "PORTAL"
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum ScalarType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case int = "INT"
        case string = "STRING"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiLayerStorage = "MULTI_LAYER_STORAGE"
        case sitewiseDefaultStorage = "SITEWISE_DEFAULT_STORAGE"
        public var description: String { return self.rawValue }
    }

    public enum TargetResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        public var description: String { return self.rawValue }
    }

    public enum TimeOrdering: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TraversalDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case child = "CHILD"
        case parent = "PARENT"
        public var description: String { return self.rawValue }
    }

    public enum TraversalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pathToRoot = "PATH_TO_ROOT"
        public var description: String { return self.rawValue }
    }

    public enum WarmTierState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPolicySummary: AWSDecodableShape {
        /// The date the access policy was created, in Unix epoch time.
        public let creationDate: Date?
        /// The ID of the access policy.
        public let id: String
        /// The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).
        public let identity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let permission: Permission
        /// The IoT SiteWise Monitor resource (a portal or project).
        public let resource: Resource

        public init(creationDate: Date? = nil, id: String, identity: Identity, lastUpdateDate: Date? = nil, permission: Permission, resource: Resource) {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case id = "id"
            case identity = "identity"
            case lastUpdateDate = "lastUpdateDate"
            case permission = "permission"
            case resource = "resource"
        }
    }

    public struct ActionDefinition: AWSDecodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String
        /// The name of the action definition.
        public let actionName: String
        /// The type of the action definition.
        public let actionType: String

        public init(actionDefinitionId: String, actionName: String, actionType: String) {
            self.actionDefinitionId = actionDefinitionId
            self.actionName = actionName
            self.actionType = actionType
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionName = "actionName"
            case actionType = "actionType"
        }
    }

    public struct ActionPayload: AWSEncodableShape & AWSDecodableShape {
        /// The payload of the action in a JSON string.
        public let stringValue: String

        public init(stringValue: String) {
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case stringValue = "stringValue"
        }
    }

    public struct ActionSummary: AWSDecodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String?
        /// The ID of the action.
        public let actionId: String?
        /// The resource the action will be taken on.
        public let targetResource: TargetResource?

        public init(actionDefinitionId: String? = nil, actionId: String? = nil, targetResource: TargetResource? = nil) {
            self.actionDefinitionId = actionDefinitionId
            self.actionId = actionId
            self.targetResource = targetResource
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionId = "actionId"
            case targetResource = "targetResource"
        }
    }

    public struct AggregatedValue: AWSDecodableShape {
        /// The quality of the aggregated data.
        public let quality: Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        public let timestamp: Date
        /// The value of the aggregates.
        public let value: Aggregates

        public init(quality: Quality? = nil, timestamp: Date, value: Aggregates) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case quality = "quality"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct Aggregates: AWSDecodableShape {
        /// The average (mean) value of the time series over a time interval window.
        public let average: Double?
        /// The count of data points in the time series over a time interval window.
        public let count: Double?
        /// The maximum value of the time series over a time interval window.
        public let maximum: Double?
        /// The minimum value of the time series over a time interval window.
        public let minimum: Double?
        /// The standard deviation of the time series over a time interval window.
        public let standardDeviation: Double?
        /// The sum of the time series over a time interval window.
        public let sum: Double?

        public init(average: Double? = nil, count: Double? = nil, maximum: Double? = nil, minimum: Double? = nil, standardDeviation: Double? = nil, sum: Double? = nil) {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case average = "average"
            case count = "count"
            case maximum = "maximum"
            case minimum = "minimum"
            case standardDeviation = "standardDeviation"
            case sum = "sum"
        }
    }

    public struct Alarms: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        public let alarmRoleArn: String
        /// The ARN of the Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the IoT Events Developer Guide.
        public let notificationLambdaArn: String?

        public init(alarmRoleArn: String, notificationLambdaArn: String? = nil) {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, max: 1600)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, min: 1)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, max: 1600)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, min: 1)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmRoleArn = "alarmRoleArn"
            case notificationLambdaArn = "notificationLambdaArn"
        }
    }

    public struct AssetCompositeModel: AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The external ID of the asset composite model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        ///  The ID of the asset composite model.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset properties that this composite model defines.
        public let properties: [AssetProperty]
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, externalId: String? = nil, id: String? = nil, name: String, properties: [AssetProperty], type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case type = "type"
        }
    }

    public struct AssetCompositeModelPathSegment: AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetCompositeModelSummary: AWSDecodableShape {
        /// A description of the composite model that this summary describes.
        public let description: String
        /// An external ID to assign to the asset model. If the composite model is a derived composite model, or one nested inside a component model, you can only set the external ID using  UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public let externalId: String?
        /// The ID of the composite model that this summary describes.
        public let id: String
        /// The name of the composite model that this summary describes.
        public let name: String
        /// The path that includes all the components of the asset model for the asset.
        public let path: [AssetCompositeModelPathSegment]
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let type: String

        public init(description: String, externalId: String? = nil, id: String, name: String, path: [AssetCompositeModelPathSegment], type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
        }
    }

    public struct AssetErrorDetails: AWSDecodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String
        /// The error code.
        public let code: AssetErrorCode
        /// The error message.
        public let message: String

        public init(assetId: String, code: AssetErrorCode, message: String) {
            self.assetId = assetId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case code = "code"
            case message = "message"
        }
    }

    public struct AssetHierarchy: AWSDecodableShape {
        /// The external ID of the hierarchy, if it has one. When you update an asset hierarchy, you may assign an external ID if it doesn't already have one. You can't change the external ID of an asset hierarchy that already has one. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The hierarchy name provided in the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(externalId: String? = nil, id: String? = nil, name: String) {
            self.externalId = externalId
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "externalId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetHierarchyInfo: AWSDecodableShape {
        /// The ID of the child asset in this asset relationship.
        public let childAssetId: String?
        /// The ID of the parent asset in this asset relationship.
        public let parentAssetId: String?

        public init(childAssetId: String? = nil, parentAssetId: String? = nil) {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case parentAssetId = "parentAssetId"
        }
    }

    public struct AssetModelCompositeModel: AWSEncodableShape & AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The external ID of the asset model composite model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        ///  The ID of the asset model composite model.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, externalId: String? = nil, id: String? = nil, name: String, properties: [AssetModelProperty]? = nil, type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 139)
            try self.validate(self.id, name: "id", parent: name, min: 13)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case type = "type"
        }
    }

    public struct AssetModelCompositeModelDefinition: AWSEncodableShape {
        /// The description of the composite model.
        public let description: String?
        /// An external ID to assign to the composite model. The external ID must be unique among composite models within this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID to assign to the composite model, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, externalId: String? = nil, id: String? = nil, name: String, properties: [AssetModelPropertyDefinition]? = nil, type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case type = "type"
        }
    }

    public struct AssetModelCompositeModelPathSegment: AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelCompositeModelSummary: AWSDecodableShape {
        /// The description of the the composite model that this summary describes..
        public let description: String?
        /// The external ID of a composite model on this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the the composite model that this summary describes..
        public let id: String
        /// The name of the the composite model that this summary describes..
        public let name: String
        /// The path that includes all the pieces that make up the composite model.
        public let path: [AssetModelCompositeModelPathSegment]?
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let type: String

        public init(description: String? = nil, externalId: String? = nil, id: String, name: String, path: [AssetModelCompositeModelPathSegment]? = nil, type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
        }
    }

    public struct AssetModelHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset model, in UUID format. All assets in this hierarchy must be instances of the childAssetModelId asset model. IoT SiteWise will always return the actual asset model ID for this value. However, when you are specifying this value as part of a call to UpdateAssetModel, you may provide either the asset model ID or else externalId: followed by the asset model's external ID. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let childAssetModelId: String
        /// The external ID (if any) provided in the CreateAssetModel or UpdateAssetModel operation. You can assign an external ID by specifying this value as part of a call to UpdateAssetModel. However, you can't change the external ID if one is already assigned. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.   If you are callling UpdateAssetModel to create a new hierarchy: You can specify its ID here, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.   If you are calling UpdateAssetModel to modify an existing hierarchy: This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let id: String?
        /// The name of the asset model hierarchy that you specify by using the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(childAssetModelId: String, externalId: String? = nil, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.externalId = externalId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 139)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 13)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 139)
            try self.validate(self.id, name: "id", parent: name, min: 13)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId = "childAssetModelId"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelHierarchyDefinition: AWSEncodableShape {
        /// The ID of an asset model for this hierarchy. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let childAssetModelId: String
        /// An external ID to assign to the asset model hierarchy. The external ID must be unique among asset model hierarchies within this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID to assign to the asset model hierarchy, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let id: String?
        /// The name of the asset model hierarchy definition (as specified in the CreateAssetModel or UpdateAssetModel API operation).
        public let name: String

        public init(childAssetModelId: String, externalId: String? = nil, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.externalId = externalId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 139)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 13)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId = "childAssetModelId"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelProperty: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the asset model property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The external ID (if any) provided in the CreateAssetModel or UpdateAssetModel operation. You can assign an external ID by specifying this value as part of a call to UpdateAssetModel. However, you can't change the external ID if one is already assigned. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset model property.   If you are callling UpdateAssetModel to create a new property: You can specify its ID here, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.   If you are calling UpdateAssetModel to modify an existing property: This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let id: String?
        /// The name of the asset model property.
        public let name: String
        /// The structured path to the property from the root of the asset model.
        public let path: [AssetModelPropertyPathSegment]?
        /// The property type (see PropertyType).
        public let type: PropertyType
        /// The unit of the asset model property, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String? = nil, name: String, path: [AssetModelPropertyPathSegment]? = nil, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 139)
            try self.validate(self.id, name: "id", parent: name, min: 13)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.path?.forEach {
                try $0.validate(name: "\(name).path[]")
            }
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelPropertyDefinition: AWSEncodableShape {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// An external ID to assign to the property definition. The external ID must be unique among property definitions within this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID to assign to the asset model property, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let id: String?
        /// The name of the property definition.
        public let name: String
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        public let type: PropertyType
        /// The unit of the property definition, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelPropertyPathSegment: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelPropertySummary: AWSDecodableShape {
        ///  The ID of the composite model that contains the asset model property.
        public let assetModelCompositeModelId: String?
        /// The data type of the property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The external ID of the property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the property.
        public let id: String?
        /// The name of the property.
        public let name: String
        /// The structured path to the property from the root of the asset model.
        public let path: [AssetModelPropertyPathSegment]?
        public let type: PropertyType
        /// The unit (such as Newtons or RPM) of the property.
        public let unit: String?

        public init(assetModelCompositeModelId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String? = nil, name: String, path: [AssetModelPropertyPathSegment]? = nil, type: PropertyType, unit: String? = nil) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current state of the asset model.
        public let state: AssetModelState

        public init(error: ErrorDetails? = nil, state: AssetModelState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct AssetModelSummary: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let arn: String
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelType: AssetModelType?
        /// The date the asset model was created, in Unix epoch time.
        public let creationDate: Date
        /// The asset model description.
        public let description: String
        /// The external ID of the asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset model (used with IoT SiteWise API operations).
        public let id: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset model.
        public let name: String
        /// The current status of the asset model.
        public let status: AssetModelStatus

        public init(arn: String, assetModelType: AssetModelType? = nil, creationDate: Date, description: String, externalId: String? = nil, id: String, lastUpdateDate: Date, name: String, status: AssetModelStatus) {
            self.arn = arn
            self.assetModelType = assetModelType
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelType = "assetModelType"
            case creationDate = "creationDate"
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssetProperty: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The data type of the asset property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The external ID of the asset property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public let path: [AssetPropertyPathSegment]?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String, name: String, notification: PropertyNotification? = nil, path: [AssetPropertyPathSegment]? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.notification = notification
            self.path = path
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case notification = "notification"
            case path = "path"
            case unit = "unit"
        }
    }

    public struct AssetPropertyPathSegment: AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetPropertySummary: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        ///  The ID of the composite model that contains the asset property.
        public let assetCompositeModelId: String?
        /// The external ID of the property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the property.
        public let id: String
        public let notification: PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public let path: [AssetPropertyPathSegment]?
        ///  The unit of measure (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, assetCompositeModelId: String? = nil, externalId: String? = nil, id: String, notification: PropertyNotification? = nil, path: [AssetPropertyPathSegment]? = nil, unit: String? = nil) {
            self.alias = alias
            self.assetCompositeModelId = assetCompositeModelId
            self.externalId = externalId
            self.id = id
            self.notification = notification
            self.path = path
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case assetCompositeModelId = "assetCompositeModelId"
            case externalId = "externalId"
            case id = "id"
            case notification = "notification"
            case path = "path"
            case unit = "unit"
        }
    }

    public struct AssetPropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// The quality of the asset property value.
        public let quality: Quality?
        /// The timestamp of the asset property value.
        public let timestamp: TimeInNanos
        /// The value of the asset property (see Variant).
        public let value: Variant

        public init(quality: Quality? = nil, timestamp: TimeInNanos, value: Variant) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.timestamp.validate(name: "\(name).timestamp")
        }

        private enum CodingKeys: String, CodingKey {
            case quality = "quality"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct AssetRelationshipSummary: AWSDecodableShape {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public let hierarchyInfo: AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:    HIERARCHY – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        public let relationshipType: AssetRelationshipType

        public init(hierarchyInfo: AssetHierarchyInfo? = nil, relationshipType: AssetRelationshipType) {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyInfo = "hierarchyInfo"
            case relationshipType = "relationshipType"
        }
    }

    public struct AssetStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current status of the asset.
        public let state: AssetState

        public init(error: ErrorDetails? = nil, state: AssetState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct AssetSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create this asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A description for the asset.
        public let description: String?
        /// The external ID of the asset. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset, in UUID format.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, description: String? = nil, externalId: String? = nil, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelId = "assetModelId"
            case creationDate = "creationDate"
            case description = "description"
            case externalId = "externalId"
            case hierarchies = "hierarchies"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssociateAssetsRequest: AWSEncodableShape {
        /// The ID of the parent asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the child asset to be associated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.) Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = AssociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            try container.encode(self.childAssetId, forKey: .childAssetId)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.hierarchyId, forKey: .hierarchyId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 139)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 13)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 139)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 13)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case clientToken = "clientToken"
            case hierarchyId = "hierarchyId"
        }
    }

    public struct AssociateTimeSeriesToAssetPropertyRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String

        public init(alias: String, assetId: String, clientToken: String? = AssociateTimeSeriesToAssetPropertyRequest.idempotencyToken(), propertyId: String) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct AssociatedAssetsSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create the asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A description for the asset.
        public let description: String?
        /// The external ID of the asset. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset, in UUID format.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, description: String? = nil, externalId: String? = nil, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelId = "assetModelId"
            case creationDate = "creationDate"
            case description = "description"
            case externalId = "externalId"
            case hierarchies = "hierarchies"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see Updating attribute values in the IoT SiteWise User Guide.
        public let defaultValue: String?

        public init(defaultValue: String? = nil) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
        }
    }

    public struct BatchAssociateProjectAssetsRequest: AWSEncodableShape {
        /// The IDs of the assets to be associated to the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project to which to associate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchAssociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assetIds, forKey: .assetIds)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case clientToken = "clientToken"
        }
    }

    public struct BatchAssociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDisassociateProjectAssetsRequest: AWSEncodableShape {
        /// The IDs of the assets to be disassociated from the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project from which to disassociate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchDisassociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assetIds, forKey: .assetIds)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case clientToken = "clientToken"
        }
    }

    public struct BatchDisassociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchGetAssetPropertyAggregatesEntry: AWSEncodableShape {
        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 3)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "^1m|15m|1h|1d$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateTypes = "aggregateTypes"
            case assetId = "assetId"
            case endDate = "endDate"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case qualities = "qualities"
            case resolution = "resolution"
            case startDate = "startDate"
            case timeOrdering = "timeOrdering"
        }
    }

    public struct BatchGetAssetPropertyAggregatesErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyAggregatesErrorCode
        /// The associated error message.
        public let errorMessage: String

        public init(entryId: String, errorCode: BatchGetAssetPropertyAggregatesErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchGetAssetPropertyAggregatesErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyAggregatesErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        public init(errorCode: BatchGetAssetPropertyAggregatesErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorTimestamp = "errorTimestamp"
        }
    }

    public struct BatchGetAssetPropertyAggregatesRequest: AWSEncodableShape {
        /// The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyAggregatesEntry]
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 1 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 4000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(entries: [BatchGetAssetPropertyAggregatesEntry], maxResults: Int? = nil, nextToken: String? = nil) {
            self.entries = entries
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct BatchGetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyAggregatesErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyAggregatesSkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyAggregatesSuccessEntry]

        public init(errorEntries: [BatchGetAssetPropertyAggregatesErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyAggregatesSkippedEntry], successEntries: [BatchGetAssetPropertyAggregatesSuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
            case nextToken = "nextToken"
            case skippedEntries = "skippedEntries"
            case successEntries = "successEntries"
        }
    }

    public struct BatchGetAssetPropertyAggregatesSkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyAggregates API.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyAggregatesErrorInfo?

        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyAggregatesErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "completionStatus"
            case entryId = "entryId"
            case errorInfo = "errorInfo"
        }
    }

    public struct BatchGetAssetPropertyAggregatesSuccessEntry: AWSDecodableShape {
        /// The requested aggregated asset property values (for example, average, minimum, and maximum).
        public let aggregatedValues: [AggregatedValue]
        /// The ID of the entry.
        public let entryId: String

        public init(aggregatedValues: [AggregatedValue], entryId: String) {
            self.aggregatedValues = aggregatedValues
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues = "aggregatedValues"
            case entryId = "entryId"
        }
    }

    public struct BatchGetAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?

        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
        }
    }

    public struct BatchGetAssetPropertyValueErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String

        public init(entryId: String, errorCode: BatchGetAssetPropertyValueErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchGetAssetPropertyValueErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        public init(errorCode: BatchGetAssetPropertyValueErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorTimestamp = "errorTimestamp"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryEntry: AWSEncodableShape {
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(assetId: String? = nil, endDate: Date? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case endDate = "endDate"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case qualities = "qualities"
            case startDate = "startDate"
            case timeOrdering = "timeOrdering"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueHistoryErrorCode
        /// The associated error message.
        public let errorMessage: String

        public init(entryId: String, errorCode: BatchGetAssetPropertyValueHistoryErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueHistoryErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        public init(errorCode: BatchGetAssetPropertyValueHistoryErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorTimestamp = "errorTimestamp"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        /// The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyValueHistoryEntry]
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 4 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(entries: [BatchGetAssetPropertyValueHistoryEntry], maxResults: Int? = nil, nextToken: String? = nil) {
            self.entries = entries
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyValueHistoryErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyValueHistorySkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyValueHistorySuccessEntry]

        public init(errorEntries: [BatchGetAssetPropertyValueHistoryErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyValueHistorySkippedEntry], successEntries: [BatchGetAssetPropertyValueHistorySuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
            case nextToken = "nextToken"
            case skippedEntries = "skippedEntries"
            case successEntries = "successEntries"
        }
    }

    public struct BatchGetAssetPropertyValueHistorySkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyValueHistory API.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyValueHistoryErrorInfo?

        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyValueHistoryErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "completionStatus"
            case entryId = "entryId"
            case errorInfo = "errorInfo"
        }
    }

    public struct BatchGetAssetPropertyValueHistorySuccessEntry: AWSDecodableShape {
        /// The requested historical values for the specified asset property.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The ID of the entry.
        public let entryId: String

        public init(assetPropertyValueHistory: [AssetPropertyValue], entryId: String) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory = "assetPropertyValueHistory"
            case entryId = "entryId"
        }
    }

    public struct BatchGetAssetPropertyValueRequest: AWSEncodableShape {
        /// The list of asset property value entries for the batch get request. You can specify up to 128 entries per request.
        public let entries: [BatchGetAssetPropertyValueEntry]
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(entries: [BatchGetAssetPropertyValueEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
            case nextToken = "nextToken"
        }
    }

    public struct BatchGetAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyValueErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyValueSkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyValueSuccessEntry]

        public init(errorEntries: [BatchGetAssetPropertyValueErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyValueSkippedEntry], successEntries: [BatchGetAssetPropertyValueSuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
            case nextToken = "nextToken"
            case skippedEntries = "skippedEntries"
            case successEntries = "successEntries"
        }
    }

    public struct BatchGetAssetPropertyValueSkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyValue request.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyValueErrorInfo?

        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyValueErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "completionStatus"
            case entryId = "entryId"
            case errorInfo = "errorInfo"
        }
    }

    public struct BatchGetAssetPropertyValueSuccessEntry: AWSDecodableShape {
        public let assetPropertyValue: AssetPropertyValue?
        /// The ID of the entry.
        public let entryId: String

        public init(assetPropertyValue: AssetPropertyValue? = nil, entryId: String) {
            self.assetPropertyValue = assetPropertyValue
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValue = "assetPropertyValue"
            case entryId = "entryId"
        }
    }

    public struct BatchPutAssetPropertyError: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchPutAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String
        /// A list of timestamps for each  error, if any.
        public let timestamps: [TimeInNanos]

        public init(errorCode: BatchPutAssetPropertyValueErrorCode, errorMessage: String, timestamps: [TimeInNanos]) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case timestamps = "timestamps"
        }
    }

    public struct BatchPutAssetPropertyErrorEntry: AWSDecodableShape {
        /// The ID of the failed entry.
        public let entryId: String
        /// The list of update property value errors.
        public let errors: [BatchPutAssetPropertyError]

        public init(entryId: String, errors: [BatchPutAssetPropertyError]) {
            self.entryId = entryId
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errors = "errors"
        }
    }

    public struct BatchPutAssetPropertyValueRequest: AWSEncodableShape {
        /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
        public let entries: [PutAssetPropertyValueEntry]

        public init(entries: [PutAssetPropertyValueEntry]) {
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
        }
    }

    public struct BatchPutAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchPutAssetPropertyErrorEntry]

        public init(errorEntries: [BatchPutAssetPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct ColumnInfo: AWSDecodableShape {
        /// The name of the column description.
        public let name: String?
        /// The type of the column description.
        public let type: ColumnType?

        public init(name: String? = nil, type: ColumnType? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ColumnType: AWSDecodableShape {
        /// The allowed data types that the column has as it's value.
        public let scalarType: ScalarType?

        public init(scalarType: ScalarType? = nil) {
            self.scalarType = scalarType
        }

        private enum CodingKeys: String, CodingKey {
            case scalarType = "scalarType"
        }
    }

    public struct CompositeModelProperty: AWSDecodableShape {
        public let assetProperty: Property
        /// The external ID of the composite model that contains the property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        ///  The ID of the composite model that contains the property.
        public let id: String?
        /// The name of the property.
        public let name: String
        /// The type of the composite model that defines this property.
        public let type: String

        public init(assetProperty: Property, externalId: String? = nil, id: String? = nil, name: String, type: String) {
            self.assetProperty = assetProperty
            self.externalId = externalId
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assetProperty = "assetProperty"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case type = "type"
        }
    }

    public struct CompositionDetails: AWSDecodableShape {
        /// An array detailing the composition relationship for this composite model.
        public let compositionRelationship: [CompositionRelationshipItem]?

        public init(compositionRelationship: [CompositionRelationshipItem]? = nil) {
            self.compositionRelationship = compositionRelationship
        }

        private enum CodingKeys: String, CodingKey {
            case compositionRelationship = "compositionRelationship"
        }
    }

    public struct CompositionRelationshipItem: AWSDecodableShape {
        /// The ID of the component.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CompositionRelationshipSummary: AWSDecodableShape {
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        public let assetModelCompositeModelType: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String

        public init(assetModelCompositeModelId: String, assetModelCompositeModelType: String, assetModelId: String) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelType = "assetModelCompositeModelType"
            case assetModelId = "assetModelId"
        }
    }

    public struct ConfigurationErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        /// The error message.
        public let message: String

        public init(code: ErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ConfigurationStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ConfigurationErrorDetails?
        /// The current state of the configuration.
        public let state: ConfigurationState

        public init(error: ConfigurationErrorDetails? = nil, state: ConfigurationState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {
        /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the access policy. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyArn: String, accessPolicyId: String) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyId = accessPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn = "accessPolicyArn"
            case accessPolicyId = "accessPolicyId"
        }
    }

    public struct CreateAssetModelCompositeModelRequest: AWSEncodableShape {
        /// A description for the composite model.
        public let assetModelCompositeModelDescription: String?
        /// An external ID to assign to the composite model. If the composite model is a derived composite model, or one nested inside a component model, you can only set the external ID using  UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public let assetModelCompositeModelExternalId: String?
        /// The ID of the composite model.  IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However,  if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let assetModelCompositeModelId: String?
        /// A unique, friendly name for the composite model.
        public let assetModelCompositeModelName: String
        /// The property definitions of the composite model. For more information, see . You can specify up to 200 properties per composite model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelCompositeModelProperties: [AssetModelPropertyDefinition]?
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        public let assetModelCompositeModelType: String
        /// The ID of the asset model this composite model is a part of.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a composite model on this asset.
        public let composedAssetModelId: String?
        /// The ID of the parent composite model in this asset model relationship.
        public let parentAssetModelCompositeModelId: String?

        public init(assetModelCompositeModelDescription: String? = nil, assetModelCompositeModelExternalId: String? = nil, assetModelCompositeModelId: String? = nil, assetModelCompositeModelName: String, assetModelCompositeModelProperties: [AssetModelPropertyDefinition]? = nil, assetModelCompositeModelType: String, assetModelId: String, clientToken: String? = CreateAssetModelCompositeModelRequest.idempotencyToken(), composedAssetModelId: String? = nil, parentAssetModelCompositeModelId: String? = nil) {
            self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
            self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelName = assetModelCompositeModelName
            self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
            self.clientToken = clientToken
            self.composedAssetModelId = composedAssetModelId
            self.parentAssetModelCompositeModelId = parentAssetModelCompositeModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetModelCompositeModelDescription, forKey: .assetModelCompositeModelDescription)
            try container.encodeIfPresent(self.assetModelCompositeModelExternalId, forKey: .assetModelCompositeModelExternalId)
            try container.encodeIfPresent(self.assetModelCompositeModelId, forKey: .assetModelCompositeModelId)
            try container.encode(self.assetModelCompositeModelName, forKey: .assetModelCompositeModelName)
            try container.encodeIfPresent(self.assetModelCompositeModelProperties, forKey: .assetModelCompositeModelProperties)
            try container.encode(self.assetModelCompositeModelType, forKey: .assetModelCompositeModelType)
            request.encodePath(self.assetModelId, key: "assetModelId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.composedAssetModelId, forKey: .composedAssetModelId)
            try container.encodeIfPresent(self.parentAssetModelCompositeModelId, forKey: .parentAssetModelCompositeModelId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 36)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 36)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, max: 256)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelCompositeModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModelProperties[]")
            }
            try self.validate(self.assetModelCompositeModelType, name: "assetModelCompositeModelType", parent: name, max: 256)
            try self.validate(self.assetModelCompositeModelType, name: "assetModelCompositeModelType", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelType, name: "assetModelCompositeModelType", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.composedAssetModelId, name: "composedAssetModelId", parent: name, max: 139)
            try self.validate(self.composedAssetModelId, name: "composedAssetModelId", parent: name, min: 13)
            try self.validate(self.composedAssetModelId, name: "composedAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.parentAssetModelCompositeModelId, name: "parentAssetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.parentAssetModelCompositeModelId, name: "parentAssetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.parentAssetModelCompositeModelId, name: "parentAssetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelDescription = "assetModelCompositeModelDescription"
            case assetModelCompositeModelExternalId = "assetModelCompositeModelExternalId"
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelName = "assetModelCompositeModelName"
            case assetModelCompositeModelProperties = "assetModelCompositeModelProperties"
            case assetModelCompositeModelType = "assetModelCompositeModelType"
            case clientToken = "clientToken"
            case composedAssetModelId = "composedAssetModelId"
            case parentAssetModelCompositeModelId = "parentAssetModelCompositeModelId"
        }
    }

    public struct CreateAssetModelCompositeModelResponse: AWSDecodableShape {
        /// The ID of the composed asset model. You can use this ID when you call other IoT SiteWise APIs.
        public let assetModelCompositeModelId: String
        /// The path to the composite model listing the parent composite models.
        public let assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment]
        public let assetModelStatus: AssetModelStatus

        public init(assetModelCompositeModelId: String, assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment], assetModelStatus: AssetModelStatus) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelPath = assetModelCompositeModelPath
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelPath = "assetModelCompositeModelPath"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct CreateAssetModelRequest: AWSEncodableShape {
        /// The composite models that are part of this asset model. It groups properties (such as attributes, measurements, transforms, and metrics) and child composite models that model parts of your industrial equipment. Each composite model has a type that defines the properties that the composite model supports. Use composite models to define alarms on this asset model.  When creating custom composite models, you need to use CreateAssetModelCompositeModel. For more information, see .
        public let assetModelCompositeModels: [AssetModelCompositeModelDefinition]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// An external ID to assign to the asset model. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetModelExternalId: String?
        /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
        /// The ID to assign to the asset model, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let assetModelId: String?
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelPropertyDefinition]?
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelType: AssetModelType?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset model. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetModelCompositeModels: [AssetModelCompositeModelDefinition]? = nil, assetModelDescription: String? = nil, assetModelExternalId: String? = nil, assetModelHierarchies: [AssetModelHierarchyDefinition]? = nil, assetModelId: String? = nil, assetModelName: String, assetModelProperties: [AssetModelPropertyDefinition]? = nil, assetModelType: AssetModelType? = nil, clientToken: String? = CreateAssetModelRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelExternalId = assetModelExternalId
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelType = assetModelType
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels = "assetModelCompositeModels"
            case assetModelDescription = "assetModelDescription"
            case assetModelExternalId = "assetModelExternalId"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelId = "assetModelId"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case assetModelType = "assetModelType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The ID of the asset model, in UUID format. You can use this ID when you call other IoT SiteWise API operations.
        public let assetModelId: String
        /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelId: String, assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelId = assetModelId
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn = "assetModelArn"
            case assetModelId = "assetModelId"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {
        /// A description for the asset.
        public let assetDescription: String?
        /// An external ID to assign to the asset. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetExternalId: String?
        /// The ID to assign to the asset, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let assetId: String?
        /// The ID of the asset model from which to create the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// A friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetDescription: String? = nil, assetExternalId: String? = nil, assetId: String? = nil, assetModelId: String, assetName: String, clientToken: String? = CreateAssetRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetDescription = assetDescription
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, max: 2048)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, min: 1)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, max: 128)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, min: 2)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetDescription = "assetDescription"
            case assetExternalId = "assetExternalId"
            case assetId = "assetId"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The ID of the asset, in UUID format. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise API operations.
        public let assetId: String
        /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetId: String, assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetId = assetId
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn = "assetArn"
            case assetId = "assetId"
            case assetStatus = "assetStatus"
        }
    }

    public struct CreateBulkImportJobRequest: AWSEncodableShape {
        /// If set to true, ingest new data into IoT SiteWise storage. Measurements with notifications, metrics and transforms are  computed. If set to false, historical data is ingested into IoT SiteWise as is.
        public let adaptiveIngestion: Bool?
        /// If set to true, your data files is deleted from S3, after ingestion into IoT SiteWise storage.
        public let deleteFilesAfterImport: Bool?
        /// The Amazon S3 destination where errors associated with the job creation request are saved.
        public let errorReportLocation: ErrorReportLocation
        /// The files in the specified Amazon S3 bucket that contain your data.
        public let files: [File]
        /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
        public let jobConfiguration: JobConfiguration
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The ARN of the IAM role that allows IoT SiteWise to read Amazon S3 data.
        public let jobRoleArn: String

        public init(adaptiveIngestion: Bool? = nil, deleteFilesAfterImport: Bool? = nil, errorReportLocation: ErrorReportLocation, files: [File], jobConfiguration: JobConfiguration, jobName: String, jobRoleArn: String) {
            self.adaptiveIngestion = adaptiveIngestion
            self.deleteFilesAfterImport = deleteFilesAfterImport
            self.errorReportLocation = errorReportLocation
            self.files = files
            self.jobConfiguration = jobConfiguration
            self.jobName = jobName
            self.jobRoleArn = jobRoleArn
        }

        public func validate(name: String) throws {
            try self.errorReportLocation.validate(name: "\(name).errorReportLocation")
            try self.files.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, max: 1600)
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, min: 1)
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case adaptiveIngestion = "adaptiveIngestion"
            case deleteFilesAfterImport = "deleteFilesAfterImport"
            case errorReportLocation = "errorReportLocation"
            case files = "files"
            case jobConfiguration = "jobConfiguration"
            case jobName = "jobName"
            case jobRoleArn = "jobRoleArn"
        }
    }

    public struct CreateBulkImportJobResponse: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The status of the bulk import job can be one of following values:    PENDING – IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED – The bulk import job has been canceled.    RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let jobStatus: JobStatus

        public init(jobId: String, jobName: String, jobStatus: JobStatus) {
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case jobName = "jobName"
            case jobStatus = "jobStatus"
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The dashboard definition specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A description for the dashboard.
        public let dashboardDescription: String?
        /// A friendly name for the dashboard.
        public let dashboardName: String
        /// The ID of the project in which to create the dashboard.
        public let projectId: String
        /// A list of key-value pairs that contain metadata for the dashboard. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardName: String, projectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardName = dashboardName
            self.projectId = projectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: "^.+$")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardName = "dashboardName"
            case projectId = "projectId"
            case tags = "tags"
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardArn: String, dashboardId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "dashboardArn"
            case dashboardId = "dashboardId"
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// A unique, friendly name for the gateway.
        public let gatewayName: String
        /// The gateway's platform. You can only specify one platform in a gateway.
        public let gatewayPlatform: GatewayPlatform
        /// A list of key-value pairs that contain metadata for the gateway. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(gatewayName: String, gatewayPlatform: GatewayPlatform, tags: [String: String]? = nil) {
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.gatewayPlatform.validate(name: "\(name).gatewayPlatform")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case tags = "tags"
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise API operations.
        public let gatewayId: String

        public init(gatewayArn: String, gatewayId: String) {
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.  If you use the IoT Events managed Lambda function to manage your emails, you must verify the sender email address in Amazon SES.
        public let notificationSenderEmail: String?
        /// The service to use to authenticate users to the portal. Choose from the following options:    SSO – The portal uses IAM Identity Center to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see Enabling IAM Identity Center in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.    IAM – The portal uses Identity and Access Management to authenticate users and manage user permissions.   You can't change this value after you create a portal. Default: SSO
        public let portalAuthMode: AuthMode?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A description for the portal.
        public let portalDescription: String?
        /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
        public let portalLogoImageFile: ImageFile?
        /// A friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String
        /// A list of key-value pairs that contain metadata for the portal. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(alarms: Alarms? = nil, clientToken: String? = CreatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalAuthMode: AuthMode? = nil, portalContactEmail: String, portalDescription: String? = nil, portalLogoImageFile: ImageFile? = nil, portalName: String, roleArn: String, tags: [String: String]? = nil) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalAuthMode = portalAuthMode
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalLogoImageFile = portalLogoImageFile
            self.portalName = portalName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.portalLogoImageFile?.validate(name: "\(name).portalLogoImageFile")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "alarms"
            case clientToken = "clientToken"
            case notificationSenderEmail = "notificationSenderEmail"
            case portalAuthMode = "portalAuthMode"
            case portalContactEmail = "portalContactEmail"
            case portalDescription = "portalDescription"
            case portalLogoImageFile = "portalLogoImageFile"
            case portalName = "portalName"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The ID of the created portal.
        public let portalId: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus
        /// The associated IAM Identity Center application ID, if the portal uses IAM Identity Center.
        public let ssoApplicationId: String

        public init(portalArn: String, portalId: String, portalStartUrl: String, portalStatus: PortalStatus, ssoApplicationId: String) {
            self.portalArn = portalArn
            self.portalId = portalId
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.ssoApplicationId = ssoApplicationId
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case portalId = "portalId"
            case portalStartUrl = "portalStartUrl"
            case portalStatus = "portalStatus"
            case ssoApplicationId = "ssoApplicationId"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal in which to create the project.
        public let portalId: String
        /// A description for the project.
        public let projectDescription: String?
        /// A friendly name for the project.
        public let projectName: String
        /// A list of key-value pairs that contain metadata for the project. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), portalId: String, projectDescription: String? = nil, projectName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.portalId = portalId
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case portalId = "portalId"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case tags = "tags"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The ID of the project.
        public let projectId: String

        public init(projectArn: String, projectId: String) {
            self.projectArn = projectArn
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectId = "projectId"
        }
    }

    public struct Csv: AWSEncodableShape & AWSDecodableShape {
        /// The column names specified in the .csv file.
        public let columnNames: [ColumnName]

        public init(columnNames: [ColumnName]) {
            self.columnNames = columnNames
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "columnNames"
        }
    }

    public struct CustomerManagedS3Storage: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        public let roleArn: String
        /// The ARN of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see Amazon S3 resources in the Amazon Simple Storage Service User Guide.
        public let s3ResourceArn: String

        public init(roleArn: String, s3ResourceArn: String) {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, max: 1600)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, min: 1)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case s3ResourceArn = "s3ResourceArn"
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The date the dashboard was created, in Unix epoch time.
        public let creationDate: Date?
        /// The dashboard's description.
        public let description: String?
        /// The ID of the dashboard.
        public let id: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the dashboard
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
        }
    }

    public struct Datum: AWSDecodableShape {
        /// Indicates if the data point is an array.
        public let arrayValue: [Datum]?
        /// Indicates if the data point is null.
        public let nullValue: Bool?
        /// Indicates if the data point is a row.
        public let rowValue: Row?
        /// Indicates if the data point is a scalar value such as integer, string, double, or Boolean.
        public let scalarValue: String?

        public init(arrayValue: [Datum]? = nil, nullValue: Bool? = nil, rowValue: Row? = nil, scalarValue: String? = nil) {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
        }

        private enum CodingKeys: String, CodingKey {
            case arrayValue = "arrayValue"
            case nullValue = "nullValue"
            case rowValue = "rowValue"
            case scalarValue = "scalarValue"
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        /// The ID of the access policy to be deleted.
        public let accessPolicyId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPolicyId, key: "accessPolicyId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssetModelCompositeModelRequest: AWSEncodableShape {
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelCompositeModelId: String, assetModelId: String, clientToken: String? = DeleteAssetModelCompositeModelRequest.idempotencyToken()) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelId = assetModelId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelCompositeModelId, key: "assetModelCompositeModelId")
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelCompositeModelResponse: AWSDecodableShape {
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct DeleteAssetModelRequest: AWSEncodableShape {
        /// The ID of the asset model to delete. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelId: String, clientToken: String? = DeleteAssetModelRequest.idempotencyToken()) {
            self.assetModelId = assetModelId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        /// The ID of the asset to delete. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetId: String, clientToken: String? = DeleteAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus = "assetStatus"
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the dashboard to delete.
        public let dashboardId: String

        public init(clientToken: String? = DeleteDashboardRequest.idempotencyToken(), dashboardId: String) {
            self.clientToken = clientToken
            self.dashboardId = dashboardId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.dashboardId, key: "dashboardId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        /// The ID of the gateway to delete.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal to delete.
        public let portalId: String

        public init(clientToken: String? = DeletePortalRequest.idempotencyToken(), portalId: String) {
            self.clientToken = clientToken
            self.portalId = portalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.portalId, key: "portalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus = "portalStatus"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectId: String) {
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTimeSeriesRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String?

        public init(alias: String? = nil, assetId: String? = nil, clientToken: String? = DeleteTimeSeriesRequest.idempotencyToken(), propertyId: String? = nil) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct DescribeAccessPolicyRequest: AWSEncodableShape {
        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyId: String) {
            self.accessPolicyId = accessPolicyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPolicyId, key: "accessPolicyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The date the access policy was created, in Unix epoch time.
        public let accessPolicyCreationDate: Date
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity (IAM Identity Center user, IAM Identity Center group, or IAM user) to which this access policy applies.
        public let accessPolicyIdentity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let accessPolicyLastUpdateDate: Date
        /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
        public let accessPolicyResource: Resource

        public init(accessPolicyArn: String, accessPolicyCreationDate: Date, accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyLastUpdateDate: Date, accessPolicyPermission: Permission, accessPolicyResource: Resource) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyCreationDate = accessPolicyCreationDate
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn = "accessPolicyArn"
            case accessPolicyCreationDate = "accessPolicyCreationDate"
            case accessPolicyId = "accessPolicyId"
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyLastUpdateDate = "accessPolicyLastUpdateDate"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
        }
    }

    public struct DescribeActionRequest: AWSEncodableShape {
        /// The ID of the action.
        public let actionId: String

        public init(actionId: String) {
            self.actionId = actionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionId, key: "actionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionId, name: "actionId", parent: name, max: 36)
            try self.validate(self.actionId, name: "actionId", parent: name, min: 36)
            try self.validate(self.actionId, name: "actionId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeActionResponse: AWSDecodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String
        /// The ID of the action.
        public let actionId: String
        /// The JSON payload of the action.
        public let actionPayload: ActionPayload
        /// The time the action was executed.
        public let executionTime: Date
        /// The resource the action will be taken on.
        public let targetResource: TargetResource

        public init(actionDefinitionId: String, actionId: String, actionPayload: ActionPayload, executionTime: Date, targetResource: TargetResource) {
            self.actionDefinitionId = actionDefinitionId
            self.actionId = actionId
            self.actionPayload = actionPayload
            self.executionTime = executionTime
            self.targetResource = targetResource
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionId = "actionId"
            case actionPayload = "actionPayload"
            case executionTime = "executionTime"
            case targetResource = "targetResource"
        }
    }

    public struct DescribeAssetCompositeModelRequest: AWSEncodableShape {
        /// The ID of a composite model on this asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetCompositeModelId: String
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String

        public init(assetCompositeModelId: String, assetId: String) {
            self.assetCompositeModelId = assetCompositeModelId
            self.assetId = assetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetCompositeModelId, key: "assetCompositeModelId")
            request.encodePath(self.assetId, key: "assetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetCompositeModelId, name: "assetCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetCompositeModelId, name: "assetCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetCompositeModelId, name: "assetCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetCompositeModelResponse: AWSDecodableShape {
        /// The available actions for a composite model on this asset.
        public let actionDefinitions: [ActionDefinition]?
        /// A description for the composite model.
        public let assetCompositeModelDescription: String
        /// An external ID to assign to the asset model. If the composite model is a component-based composite model, or one nested inside a component model, you can only set the external ID using  UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public let assetCompositeModelExternalId: String?
        /// The ID of a composite model on this asset.
        public let assetCompositeModelId: String
        /// The unique, friendly name for the composite model.
        public let assetCompositeModelName: String
        /// The path to the composite model listing the parent composite models.
        public let assetCompositeModelPath: [AssetCompositeModelPathSegment]
        /// The property definitions of the composite model that was used to create the asset.
        public let assetCompositeModelProperties: [AssetProperty]
        /// The list of composite model summaries.
        public let assetCompositeModelSummaries: [AssetCompositeModelSummary]
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        public let assetCompositeModelType: String
        /// The ID of the asset, in UUID format. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
        public let assetId: String

        public init(actionDefinitions: [ActionDefinition]? = nil, assetCompositeModelDescription: String, assetCompositeModelExternalId: String? = nil, assetCompositeModelId: String, assetCompositeModelName: String, assetCompositeModelPath: [AssetCompositeModelPathSegment], assetCompositeModelProperties: [AssetProperty], assetCompositeModelSummaries: [AssetCompositeModelSummary], assetCompositeModelType: String, assetId: String) {
            self.actionDefinitions = actionDefinitions
            self.assetCompositeModelDescription = assetCompositeModelDescription
            self.assetCompositeModelExternalId = assetCompositeModelExternalId
            self.assetCompositeModelId = assetCompositeModelId
            self.assetCompositeModelName = assetCompositeModelName
            self.assetCompositeModelPath = assetCompositeModelPath
            self.assetCompositeModelProperties = assetCompositeModelProperties
            self.assetCompositeModelSummaries = assetCompositeModelSummaries
            self.assetCompositeModelType = assetCompositeModelType
            self.assetId = assetId
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitions = "actionDefinitions"
            case assetCompositeModelDescription = "assetCompositeModelDescription"
            case assetCompositeModelExternalId = "assetCompositeModelExternalId"
            case assetCompositeModelId = "assetCompositeModelId"
            case assetCompositeModelName = "assetCompositeModelName"
            case assetCompositeModelPath = "assetCompositeModelPath"
            case assetCompositeModelProperties = "assetCompositeModelProperties"
            case assetCompositeModelSummaries = "assetCompositeModelSummaries"
            case assetCompositeModelType = "assetCompositeModelType"
            case assetId = "assetId"
        }
    }

    public struct DescribeAssetModelCompositeModelRequest: AWSEncodableShape {
        /// The ID of a composite model on this asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelCompositeModelId: String
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String

        public init(assetModelCompositeModelId: String, assetModelId: String) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelId = assetModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelCompositeModelId, key: "assetModelCompositeModelId")
            request.encodePath(self.assetModelId, key: "assetModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelCompositeModelResponse: AWSDecodableShape {
        /// The available actions for a composite model on this asset model.
        public let actionDefinitions: [ActionDefinition]?
        /// The description for the composite model.
        public let assetModelCompositeModelDescription: String
        /// The external ID of a composite model on this asset model.
        public let assetModelCompositeModelExternalId: String?
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// The unique, friendly name for the composite model.
        public let assetModelCompositeModelName: String
        /// The path to the composite model listing the parent composite models.
        public let assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment]
        /// The property definitions of the composite model.
        public let assetModelCompositeModelProperties: [AssetModelProperty]
        /// The list of composite model summaries for the composite model.
        public let assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        public let assetModelCompositeModelType: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// Metadata for the composition relationship established by using composedAssetModelId in  CreateAssetModelCompositeModel . For instance, an array detailing the path of the composition relationship for this composite model.
        public let compositionDetails: CompositionDetails?

        public init(actionDefinitions: [ActionDefinition]? = nil, assetModelCompositeModelDescription: String, assetModelCompositeModelExternalId: String? = nil, assetModelCompositeModelId: String, assetModelCompositeModelName: String, assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment], assetModelCompositeModelProperties: [AssetModelProperty], assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary], assetModelCompositeModelType: String, assetModelId: String, compositionDetails: CompositionDetails? = nil) {
            self.actionDefinitions = actionDefinitions
            self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
            self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelName = assetModelCompositeModelName
            self.assetModelCompositeModelPath = assetModelCompositeModelPath
            self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
            self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
            self.compositionDetails = compositionDetails
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitions = "actionDefinitions"
            case assetModelCompositeModelDescription = "assetModelCompositeModelDescription"
            case assetModelCompositeModelExternalId = "assetModelCompositeModelExternalId"
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelName = "assetModelCompositeModelName"
            case assetModelCompositeModelPath = "assetModelCompositeModelPath"
            case assetModelCompositeModelProperties = "assetModelCompositeModelProperties"
            case assetModelCompositeModelSummaries = "assetModelCompositeModelSummaries"
            case assetModelCompositeModelType = "assetModelCompositeModelType"
            case assetModelId = "assetModelId"
            case compositionDetails = "compositionDetails"
        }
    }

    public struct DescribeAssetModelRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        ///  Whether or not to exclude asset model properties from the response.
        public let excludeProperties: Bool?

        public init(assetModelId: String, excludeProperties: Bool? = nil) {
            self.assetModelId = assetModelId
            self.excludeProperties = excludeProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.excludeProperties, key: "excludeProperties")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The list of built-in composite models for the asset model, such as those with those of type AWS/ALARMS.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// The list of the immediate child custom composite model summaries for the asset model.
        public let assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]?
        /// The date the asset model was created, in Unix epoch time.
        public let assetModelCreationDate: Date
        /// The asset model's description.
        public let assetModelDescription: String
        /// The external ID of the asset model, if any.
        public let assetModelExternalId: String?
        /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
        public let assetModelHierarchies: [AssetModelHierarchy]
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let assetModelLastUpdateDate: Date
        /// The name of the asset model.
        public let assetModelName: String
        /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
        public let assetModelProperties: [AssetModelProperty]
        /// The current status of the asset model, which contains a state and any error message.
        public let assetModelStatus: AssetModelStatus
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelType: AssetModelType?

        public init(assetModelArn: String, assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]? = nil, assetModelCreationDate: Date, assetModelDescription: String, assetModelExternalId: String? = nil, assetModelHierarchies: [AssetModelHierarchy], assetModelId: String, assetModelLastUpdateDate: Date, assetModelName: String, assetModelProperties: [AssetModelProperty], assetModelStatus: AssetModelStatus, assetModelType: AssetModelType? = nil) {
            self.assetModelArn = assetModelArn
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
            self.assetModelCreationDate = assetModelCreationDate
            self.assetModelDescription = assetModelDescription
            self.assetModelExternalId = assetModelExternalId
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelLastUpdateDate = assetModelLastUpdateDate
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelStatus = assetModelStatus
            self.assetModelType = assetModelType
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn = "assetModelArn"
            case assetModelCompositeModels = "assetModelCompositeModels"
            case assetModelCompositeModelSummaries = "assetModelCompositeModelSummaries"
            case assetModelCreationDate = "assetModelCreationDate"
            case assetModelDescription = "assetModelDescription"
            case assetModelExternalId = "assetModelExternalId"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelId = "assetModelId"
            case assetModelLastUpdateDate = "assetModelLastUpdateDate"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case assetModelStatus = "assetModelStatus"
            case assetModelType = "assetModelType"
        }
    }

    public struct DescribeAssetPropertyRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String

        public init(assetId: String, propertyId: String) {
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodePath(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetPropertyResponse: AWSDecodableShape {
        /// The external ID of the asset. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetExternalId: String?
        /// The ID of the asset, in UUID format.
        public let assetId: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
        public let assetProperty: Property?
        /// The composite model that declares this asset property, if this asset property exists in a composite model.
        public let compositeModel: CompositeModelProperty?

        public init(assetExternalId: String? = nil, assetId: String, assetModelId: String, assetName: String, assetProperty: Property? = nil, compositeModel: CompositeModelProperty? = nil) {
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperty = assetProperty
            self.compositeModel = compositeModel
        }

        private enum CodingKeys: String, CodingKey {
            case assetExternalId = "assetExternalId"
            case assetId = "assetId"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case assetProperty = "assetProperty"
            case compositeModel = "compositeModel"
        }
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        ///  Whether or not to exclude asset properties from the response.
        public let excludeProperties: Bool?

        public init(assetId: String, excludeProperties: Bool? = nil) {
            self.assetId = assetId
            self.excludeProperties = excludeProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.excludeProperties, key: "excludeProperties")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The composite models for the asset.
        public let assetCompositeModels: [AssetCompositeModel]?
        /// The list of the immediate child custom composite model summaries for the asset.
        public let assetCompositeModelSummaries: [AssetCompositeModelSummary]?
        /// The date the asset was created, in Unix epoch time.
        public let assetCreationDate: Date
        /// A description for the asset.
        public let assetDescription: String?
        /// The external ID of the asset, if any.
        public let assetExternalId: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let assetHierarchies: [AssetHierarchy]
        /// The ID of the asset, in UUID format.
        public let assetId: String
        /// The date the asset was last updated, in Unix epoch time.
        public let assetLastUpdateDate: Date
        /// The ID of the asset model that was used to create the asset.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
        public let assetProperties: [AssetProperty]
        /// The current status of the asset, which contains a state and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetCompositeModels: [AssetCompositeModel]? = nil, assetCompositeModelSummaries: [AssetCompositeModelSummary]? = nil, assetCreationDate: Date, assetDescription: String? = nil, assetExternalId: String? = nil, assetHierarchies: [AssetHierarchy], assetId: String, assetLastUpdateDate: Date, assetModelId: String, assetName: String, assetProperties: [AssetProperty], assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetCompositeModels = assetCompositeModels
            self.assetCompositeModelSummaries = assetCompositeModelSummaries
            self.assetCreationDate = assetCreationDate
            self.assetDescription = assetDescription
            self.assetExternalId = assetExternalId
            self.assetHierarchies = assetHierarchies
            self.assetId = assetId
            self.assetLastUpdateDate = assetLastUpdateDate
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperties = assetProperties
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn = "assetArn"
            case assetCompositeModels = "assetCompositeModels"
            case assetCompositeModelSummaries = "assetCompositeModelSummaries"
            case assetCreationDate = "assetCreationDate"
            case assetDescription = "assetDescription"
            case assetExternalId = "assetExternalId"
            case assetHierarchies = "assetHierarchies"
            case assetId = "assetId"
            case assetLastUpdateDate = "assetLastUpdateDate"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case assetProperties = "assetProperties"
            case assetStatus = "assetStatus"
        }
    }

    public struct DescribeBulkImportJobRequest: AWSEncodableShape {
        /// The ID of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBulkImportJobResponse: AWSDecodableShape {
        /// If set to true, ingest new data into IoT SiteWise storage. Measurements with notifications, metrics and transforms are  computed. If set to false, historical data is ingested into IoT SiteWise as is.
        public let adaptiveIngestion: Bool?
        /// If set to true, your data files is deleted from S3, after ingestion into IoT SiteWise storage.
        public let deleteFilesAfterImport: Bool?
        /// The Amazon S3 destination where errors associated with the job creation request are saved.
        public let errorReportLocation: ErrorReportLocation
        /// The files in the specified Amazon S3 bucket that contain your data.
        public let files: [File]
        /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
        public let jobConfiguration: JobConfiguration
        /// The date the job was created, in Unix epoch TIME.
        public let jobCreationDate: Date
        /// The ID of the job.
        public let jobId: String
        /// The date the job was last updated, in Unix epoch time.
        public let jobLastUpdateDate: Date
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The ARN of the IAM role that allows IoT SiteWise to read Amazon S3 data.
        public let jobRoleArn: String
        /// The status of the bulk import job can be one of following values:    PENDING – IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED – The bulk import job has been canceled.    RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let jobStatus: JobStatus

        public init(adaptiveIngestion: Bool? = nil, deleteFilesAfterImport: Bool? = nil, errorReportLocation: ErrorReportLocation, files: [File], jobConfiguration: JobConfiguration, jobCreationDate: Date, jobId: String, jobLastUpdateDate: Date, jobName: String, jobRoleArn: String, jobStatus: JobStatus) {
            self.adaptiveIngestion = adaptiveIngestion
            self.deleteFilesAfterImport = deleteFilesAfterImport
            self.errorReportLocation = errorReportLocation
            self.files = files
            self.jobConfiguration = jobConfiguration
            self.jobCreationDate = jobCreationDate
            self.jobId = jobId
            self.jobLastUpdateDate = jobLastUpdateDate
            self.jobName = jobName
            self.jobRoleArn = jobRoleArn
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case adaptiveIngestion = "adaptiveIngestion"
            case deleteFilesAfterImport = "deleteFilesAfterImport"
            case errorReportLocation = "errorReportLocation"
            case files = "files"
            case jobConfiguration = "jobConfiguration"
            case jobCreationDate = "jobCreationDate"
            case jobId = "jobId"
            case jobLastUpdateDate = "jobLastUpdateDate"
            case jobName = "jobName"
            case jobRoleArn = "jobRoleArn"
            case jobStatus = "jobStatus"
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardId: String) {
            self.dashboardId = dashboardId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dashboardId, key: "dashboardId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The date the dashboard was created, in Unix epoch time.
        public let dashboardCreationDate: Date
        /// The dashboard's definition JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// The dashboard's description.
        public let dashboardDescription: String?
        /// The ID of the dashboard.
        public let dashboardId: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let dashboardLastUpdateDate: Date
        /// The name of the dashboard.
        public let dashboardName: String
        /// The ID of the project that the dashboard is in.
        public let projectId: String

        public init(dashboardArn: String, dashboardCreationDate: Date, dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardLastUpdateDate: Date, dashboardName: String, projectId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardCreationDate = dashboardCreationDate
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardLastUpdateDate = dashboardLastUpdateDate
            self.dashboardName = dashboardName
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "dashboardArn"
            case dashboardCreationDate = "dashboardCreationDate"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardId = "dashboardId"
            case dashboardLastUpdateDate = "dashboardLastUpdateDate"
            case dashboardName = "dashboardName"
            case projectId = "projectId"
        }
    }

    public struct DescribeDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The key ARN of the customer managed key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct DescribeGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityNamespace: String, gatewayId: String) {
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityNamespace, key: "capabilityNamespace")
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The JSON document that defines the gateway capability's configuration. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration = "capabilityConfiguration"
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
            case gatewayId = "gatewayId"
        }
    }

    public struct DescribeGatewayRequest: AWSEncodableShape {
        /// The ID of the gateway device.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayResponse: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the gateway.
        public let gatewayName: String
        /// The gateway's platform.
        public let gatewayPlatform: GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayArn: String, gatewayCapabilitySummaries: [GatewayCapabilitySummary], gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayArn = gatewayArn
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case gatewayArn = "gatewayArn"
            case gatewayCapabilitySummaries = "gatewayCapabilitySummaries"
            case gatewayId = "gatewayId"
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case lastUpdateDate = "lastUpdateDate"
        }
    }

    public struct DescribeLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeLoggingOptionsResponse: AWSDecodableShape {
        /// The current logging options.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions = "loggingOptions"
        }
    }

    public struct DescribePortalRequest: AWSEncodableShape {
        /// The ID of the portal.
        public let portalId: String

        public init(portalId: String) {
            self.portalId = portalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalId, key: "portalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePortalResponse: AWSDecodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
        public let alarms: Alarms?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The service to use to authenticate users to the portal.
        public let portalAuthMode: AuthMode?
        /// The IAM Identity Center application generated client ID (used with IAM Identity Center API operations). IoT SiteWise includes portalClientId for only portals that use IAM Identity Center to authenticate users.
        public let portalClientId: String
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// The date the portal was created, in Unix epoch time.
        public let portalCreationDate: Date
        /// The portal's description.
        public let portalDescription: String?
        /// The ID of the portal.
        public let portalId: String
        /// The date the portal was last updated, in Unix epoch time.
        public let portalLastUpdateDate: Date
        /// The portal's logo image, which is available at a URL.
        public let portalLogoImageLocation: ImageLocation?
        /// The name of the portal.
        public let portalName: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The current status of the portal, which contains a state and any error message.
        public let portalStatus: PortalStatus
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?

        public init(alarms: Alarms? = nil, notificationSenderEmail: String? = nil, portalArn: String, portalAuthMode: AuthMode? = nil, portalClientId: String, portalContactEmail: String, portalCreationDate: Date, portalDescription: String? = nil, portalId: String, portalLastUpdateDate: Date, portalLogoImageLocation: ImageLocation? = nil, portalName: String, portalStartUrl: String, portalStatus: PortalStatus, roleArn: String? = nil) {
            self.alarms = alarms
            self.notificationSenderEmail = notificationSenderEmail
            self.portalArn = portalArn
            self.portalAuthMode = portalAuthMode
            self.portalClientId = portalClientId
            self.portalContactEmail = portalContactEmail
            self.portalCreationDate = portalCreationDate
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLastUpdateDate = portalLastUpdateDate
            self.portalLogoImageLocation = portalLogoImageLocation
            self.portalName = portalName
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "alarms"
            case notificationSenderEmail = "notificationSenderEmail"
            case portalArn = "portalArn"
            case portalAuthMode = "portalAuthMode"
            case portalClientId = "portalClientId"
            case portalContactEmail = "portalContactEmail"
            case portalCreationDate = "portalCreationDate"
            case portalDescription = "portalDescription"
            case portalId = "portalId"
            case portalLastUpdateDate = "portalLastUpdateDate"
            case portalLogoImageLocation = "portalLogoImageLocation"
            case portalName = "portalName"
            case portalStartUrl = "portalStartUrl"
            case portalStatus = "portalStatus"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        /// The ID of the project.
        public let projectId: String

        public init(projectId: String) {
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The ID of the portal that the project is in.
        public let portalId: String
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The date the project was created, in Unix epoch time.
        public let projectCreationDate: Date
        /// The project's description.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The date the project was last updated, in Unix epoch time.
        public let projectLastUpdateDate: Date
        /// The name of the project.
        public let projectName: String

        public init(portalId: String, projectArn: String, projectCreationDate: Date, projectDescription: String? = nil, projectId: String, projectLastUpdateDate: Date, projectName: String) {
            self.portalId = portalId
            self.projectArn = projectArn
            self.projectCreationDate = projectCreationDate
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectLastUpdateDate = projectLastUpdateDate
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case portalId = "portalId"
            case projectArn = "projectArn"
            case projectCreationDate = "projectCreationDate"
            case projectDescription = "projectDescription"
            case projectId = "projectId"
            case projectLastUpdateDate = "projectLastUpdateDate"
            case projectName = "projectName"
        }
    }

    public struct DescribeStorageConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:    ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// The date the storage configuration was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        /// The number of days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.    MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType
        /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
        public let warmTier: WarmTierState?
        /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
        public let warmTierRetentionPeriod: WarmTierRetentionPeriod?

        public init(configurationStatus: ConfigurationStatus, disassociatedDataStorage: DisassociatedDataStorageState? = nil, lastUpdateDate: Date? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType, warmTier: WarmTierState? = nil, warmTierRetentionPeriod: WarmTierRetentionPeriod? = nil) {
            self.configurationStatus = configurationStatus
            self.disassociatedDataStorage = disassociatedDataStorage
            self.lastUpdateDate = lastUpdateDate
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
            self.warmTier = warmTier
            self.warmTierRetentionPeriod = warmTierRetentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case disassociatedDataStorage = "disassociatedDataStorage"
            case lastUpdateDate = "lastUpdateDate"
            case multiLayerStorage = "multiLayerStorage"
            case retentionPeriod = "retentionPeriod"
            case storageType = "storageType"
            case warmTier = "warmTier"
            case warmTierRetentionPeriod = "warmTierRetentionPeriod"
        }
    }

    public struct DescribeTimeSeriesRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String?

        public init(alias: String? = nil, assetId: String? = nil, propertyId: String? = nil) {
            self.alias = alias
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTimeSeriesResponse: AWSDecodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        public let dataType: PropertyDataType
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The ARN of the time series, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
        public let timeSeriesArn: String
        /// The date that the time series was created, in Unix epoch time.
        public let timeSeriesCreationDate: Date
        /// The ID of the time series.
        public let timeSeriesId: String
        /// The date that the time series was last updated, in Unix epoch time.
        public let timeSeriesLastUpdateDate: Date

        public init(alias: String? = nil, assetId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, propertyId: String? = nil, timeSeriesArn: String, timeSeriesCreationDate: Date, timeSeriesId: String, timeSeriesLastUpdateDate: Date) {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesArn = timeSeriesArn
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case assetId = "assetId"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case propertyId = "propertyId"
            case timeSeriesArn = "timeSeriesArn"
            case timeSeriesCreationDate = "timeSeriesCreationDate"
            case timeSeriesId = "timeSeriesId"
            case timeSeriesLastUpdateDate = "timeSeriesLastUpdateDate"
        }
    }

    public struct DetailedError: AWSDecodableShape {
        /// The error code.
        public let code: DetailedErrorCode
        /// The error message.
        public let message: String

        public init(code: DetailedErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct DisassociateAssetsRequest: AWSEncodableShape {
        /// The ID of the parent asset from which to disassociate the child asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the child asset to disassociate. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.) Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = DisassociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            try container.encode(self.childAssetId, forKey: .childAssetId)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.hierarchyId, forKey: .hierarchyId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 139)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 13)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 139)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 13)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case clientToken = "clientToken"
            case hierarchyId = "hierarchyId"
        }
    }

    public struct DisassociateTimeSeriesFromAssetPropertyRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String

        public init(alias: String, assetId: String, clientToken: String? = DisassociateTimeSeriesFromAssetPropertyRequest.idempotencyToken(), propertyId: String) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        ///  A list of detailed errors.
        public let details: [DetailedError]?
        /// The error message.
        public let message: String

        public init(code: ErrorCode, details: [DetailedError]? = nil, message: String) {
            self.code = code
            self.details = details
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case details = "details"
            case message = "message"
        }
    }

    public struct ErrorReportLocation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.
        public let bucket: String
        /// Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see Organizing objects using prefixes in the Amazon Simple Storage Service User Guide.
        public let prefix: String

        public init(bucket: String, prefix: String) {
            self.bucket = bucket
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case prefix = "prefix"
        }
    }

    public struct ExecuteActionRequest: AWSEncodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String
        /// The JSON payload of the action.
        public let actionPayload: ActionPayload
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The resource the action will be taken on.
        public let targetResource: TargetResource

        public init(actionDefinitionId: String, actionPayload: ActionPayload, clientToken: String? = nil, targetResource: TargetResource) {
            self.actionDefinitionId = actionDefinitionId
            self.actionPayload = actionPayload
            self.clientToken = clientToken
            self.targetResource = targetResource
        }

        public func validate(name: String) throws {
            try self.validate(self.actionDefinitionId, name: "actionDefinitionId", parent: name, max: 36)
            try self.validate(self.actionDefinitionId, name: "actionDefinitionId", parent: name, min: 36)
            try self.validate(self.actionDefinitionId, name: "actionDefinitionId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.actionPayload.validate(name: "\(name).actionPayload")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.targetResource.validate(name: "\(name).targetResource")
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionPayload = "actionPayload"
            case clientToken = "clientToken"
            case targetResource = "targetResource"
        }
    }

    public struct ExecuteActionResponse: AWSDecodableShape {
        /// The ID of the action.
        public let actionId: String

        public init(actionId: String) {
            self.actionId = actionId
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
        }
    }

    public struct ExecuteQueryRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 25.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The IoT SiteWise query statement.
        public let queryStatement: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, queryStatement: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryStatement = queryStatement
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case queryStatement = "queryStatement"
        }
    }

    public struct ExecuteQueryResponse: AWSDecodableShape {
        /// Represents a single column in the query results.
        public let columns: [ColumnInfo]?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Represents a single row in the query results.
        public let rows: [Row]?

        public init(columns: [ColumnInfo]? = nil, nextToken: String? = nil, rows: [Row]? = nil) {
            self.columns = columns
            self.nextToken = nextToken
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
            case nextToken = "nextToken"
            case rows = "rows"
        }
    }

    public struct ExpressionVariable: AWSEncodableShape & AWSDecodableShape {
        /// The friendly name of the variable to be used in the expression.
        public let name: String
        /// The variable that identifies an asset property from which to use values.
        public let value: VariableValue

        public init(name: String, value: VariableValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct File: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket from which data is imported.
        public let bucket: String
        /// The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.
        public let key: String
        /// The version ID to identify a specific version of the Amazon S3 object that contains your data.
        public let versionId: String?

        public init(bucket: String, key: String, versionId: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
            case versionId = "versionId"
        }
    }

    public struct FileFormat: AWSEncodableShape & AWSDecodableShape {
        /// The file is in .CSV format.
        public let csv: Csv?
        /// The file is in parquet format.
        public let parquet: Parquet?

        public init(csv: Csv? = nil, parquet: Parquet? = nil) {
            self.csv = csv
            self.parquet = parquet
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "csv"
            case parquet = "parquet"
        }
    }

    public struct ForwardingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The forwarding state for the given property.
        public let state: ForwardingConfigState

        public init(state: ForwardingConfigState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct GatewayCapabilitySummary: AWSDecodableShape {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
        }
    }

    public struct GatewayPlatform: AWSEncodableShape & AWSDecodableShape {
        /// A gateway that runs on IoT Greengrass.
        public let greengrass: Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public let greengrassV2: GreengrassV2?

        public init(greengrass: Greengrass? = nil, greengrassV2: GreengrassV2? = nil) {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
        }

        public func validate(name: String) throws {
            try self.greengrass?.validate(name: "\(name).greengrass")
            try self.greengrassV2?.validate(name: "\(name).greengrassV2")
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass = "greengrass"
            case greengrassV2 = "greengrassV2"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the asset.
        public let gatewayName: String
        public let gatewayPlatform: GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil, gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case gatewayCapabilitySummaries = "gatewayCapabilitySummaries"
            case gatewayId = "gatewayId"
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case lastUpdateDate = "lastUpdateDate"
        }
    }

    public struct GetAssetPropertyAggregatesRequest: AWSEncodableShape {
        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 1 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 2500.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aggregateTypes, key: "aggregateTypes")
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.endDate, key: "endDate")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
            request.encodeQuery(self.qualities, key: "qualities")
            request.encodeQuery(self.resolution, key: "resolution")
            request.encodeQuery(self.startDate, key: "startDate")
            request.encodeQuery(self.timeOrdering, key: "timeOrdering")
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 3)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "^1m|15m|1h|1d$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// The requested aggregated values.
        public let aggregatedValues: [AggregatedValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(aggregatedValues: [AggregatedValue], nextToken: String? = nil) {
            self.aggregatedValues = aggregatedValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues = "aggregatedValues"
            case nextToken = "nextToken"
        }
    }

    public struct GetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 4 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(assetId: String? = nil, endDate: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.endDate, key: "endDate")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
            request.encodeQuery(self.qualities, key: "qualities")
            request.encodeQuery(self.startDate, key: "startDate")
            request.encodeQuery(self.timeOrdering, key: "timeOrdering")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The asset property's value history.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetPropertyValueHistory: [AssetPropertyValue], nextToken: String? = nil) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory = "assetPropertyValueHistory"
            case nextToken = "nextToken"
        }
    }

    public struct GetAssetPropertyValueRequest: AWSEncodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?

        public init(assetId: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueResponse: AWSDecodableShape {
        /// The current asset property value.
        public let propertyValue: AssetPropertyValue?

        public init(propertyValue: AssetPropertyValue? = nil) {
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValue = "propertyValue"
        }
    }

    public struct GetInterpolatedAssetPropertyValuesRequest: AWSEncodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let endTimeInSeconds: Int64
        /// The nanosecond offset converted from endTimeInSeconds.
        public let endTimeOffsetInNanos: Int?
        /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
        public let intervalInSeconds: Int64
        /// The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.    If you specify a value for the intervalWindowInSeconds parameter, the value for the type parameter must be LINEAR_INTERPOLATION.   If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.    For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.
        public let intervalWindowInSeconds: Int64?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
        public let quality: Quality
        /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let startTimeInSeconds: Int64
        /// The nanosecond offset converted from startTimeInSeconds.
        public let startTimeOffsetInNanos: Int?
        /// The interpolation type. Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION     LINEAR_INTERPOLATION – Estimates missing data using linear interpolation. For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.    LOCF_INTERPOLATION – Estimates missing data using last observation carried forward interpolation If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found. For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
        public let type: String

        public init(assetId: String? = nil, endTimeInSeconds: Int64, endTimeOffsetInNanos: Int? = nil, intervalInSeconds: Int64, intervalWindowInSeconds: Int64? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, quality: Quality, startTimeInSeconds: Int64, startTimeOffsetInNanos: Int? = nil, type: String) {
            self.assetId = assetId
            self.endTimeInSeconds = endTimeInSeconds
            self.endTimeOffsetInNanos = endTimeOffsetInNanos
            self.intervalInSeconds = intervalInSeconds
            self.intervalWindowInSeconds = intervalWindowInSeconds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.quality = quality
            self.startTimeInSeconds = startTimeInSeconds
            self.startTimeOffsetInNanos = startTimeOffsetInNanos
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.endTimeInSeconds, key: "endTimeInSeconds")
            request.encodeQuery(self.endTimeOffsetInNanos, key: "endTimeOffsetInNanos")
            request.encodeQuery(self.intervalInSeconds, key: "intervalInSeconds")
            request.encodeQuery(self.intervalWindowInSeconds, key: "intervalWindowInSeconds")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
            request.encodeQuery(self.quality, key: "quality")
            request.encodeQuery(self.startTimeInSeconds, key: "startTimeInSeconds")
            request.encodeQuery(self.startTimeOffsetInNanos, key: "startTimeOffsetInNanos")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, max: 9223372036854774)
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, min: 1)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, max: 999999999)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, max: 320000000)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, min: 1)
            try self.validate(self.intervalWindowInSeconds, name: "intervalWindowInSeconds", parent: name, max: 320000000)
            try self.validate(self.intervalWindowInSeconds, name: "intervalWindowInSeconds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, max: 9223372036854774)
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, min: 1)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, max: 999999999)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInterpolatedAssetPropertyValuesResponse: AWSDecodableShape {
        /// The requested interpolated values.
        public let interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue], nextToken: String? = nil) {
            self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case interpolatedAssetPropertyValues = "interpolatedAssetPropertyValues"
            case nextToken = "nextToken"
        }
    }

    public struct Greengrass: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Greengrass group. For more information about how to find a group's ARN, see ListGroups and GetGroup in the IoT Greengrass API Reference.
        public let groupArn: String

        public init(groupArn: String) {
            self.groupArn = groupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.groupArn, name: "groupArn", parent: name, max: 1600)
            try self.validate(self.groupArn, name: "groupArn", parent: name, min: 1)
            try self.validate(self.groupArn, name: "groupArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupArn = "groupArn"
        }
    }

    public struct GreengrassV2: AWSEncodableShape & AWSDecodableShape {
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        public let coreDeviceThingName: String

        public init(coreDeviceThingName: String) {
            self.coreDeviceThingName = coreDeviceThingName
        }

        public func validate(name: String) throws {
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, max: 128)
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case coreDeviceThingName = "coreDeviceThingName"
        }
    }

    public struct GroupIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The IAM Identity Center ID of the group.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct IAMRoleIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role. For more information, see IAM ARNs in the IAM User Guide.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct IAMUserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide.  If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Identity: AWSEncodableShape & AWSDecodableShape {
        /// An IAM Identity Center group identity.
        public let group: GroupIdentity?
        /// An IAM role identity.
        public let iamRole: IAMRoleIdentity?
        /// An IAM user identity.
        public let iamUser: IAMUserIdentity?
        /// An IAM Identity Center user identity.
        public let user: UserIdentity?

        public init(group: GroupIdentity? = nil, iamRole: IAMRoleIdentity? = nil, iamUser: IAMUserIdentity? = nil, user: UserIdentity? = nil) {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }

        public func validate(name: String) throws {
            try self.group?.validate(name: "\(name).group")
            try self.iamRole?.validate(name: "\(name).iamRole")
            try self.iamUser?.validate(name: "\(name).iamUser")
            try self.user?.validate(name: "\(name).user")
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case iamRole = "iamRole"
            case iamUser = "iamUser"
            case user = "user"
        }
    }

    public struct Image: AWSEncodableShape {
        public let file: ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public let id: String?

        public init(file: ImageFile? = nil, id: String? = nil) {
            self.file = file
            self.id = id
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case id = "id"
        }
    }

    public struct ImageFile: AWSEncodableShape {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        public let data: AWSBase64Data
        /// The file type of the image.
        public let type: ImageFileType

        public init(data: AWSBase64Data, type: ImageFileType) {
            self.data = data
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 1500000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case type = "type"
        }
    }

    public struct ImageLocation: AWSDecodableShape {
        /// The ID of the image.
        public let id: String
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        public let url: String

        public init(id: String, url: String) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case url = "url"
        }
    }

    public struct InterpolatedAssetPropertyValue: AWSDecodableShape {
        public let timestamp: TimeInNanos
        public let value: Variant

        public init(timestamp: TimeInNanos, value: Variant) {
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct JobConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file format of the data in S3.
        public let fileFormat: FileFormat

        public init(fileFormat: FileFormat) {
            self.fileFormat = fileFormat
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The ID of the job.
        public let id: String
        /// The unique name that helps identify the job request.
        public let name: String
        /// The status of the bulk import job can be one of following values:    PENDING – IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED – The bulk import job has been canceled.    RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let status: JobStatus

        public init(id: String, name: String, status: JobStatus) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide. This parameter is required if you specify IAM for identityType.
        public let iamArn: String?
        /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
        public let identityId: String?
        /// The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify identityId.
        public let identityType: IdentityType?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the resource. This parameter is required if you specify resourceType.
        public let resourceId: String?
        /// The type of resource (portal or project). This parameter is required if you specify resourceId.
        public let resourceType: ResourceType?

        public init(iamArn: String? = nil, identityId: String? = nil, identityType: IdentityType? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.iamArn = iamArn
            self.identityId = identityId
            self.identityType = identityType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.iamArn, key: "iamArn")
            request.encodeQuery(self.identityId, key: "identityId")
            request.encodeQuery(self.identityType, key: "identityType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceId, key: "resourceId")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.iamArn, name: "iamArn", parent: name, max: 1600)
            try self.validate(self.iamArn, name: "iamArn", parent: name, min: 1)
            try self.validate(self.iamArn, name: "iamArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
            try self.validate(self.identityId, name: "identityId", parent: name, max: 256)
            try self.validate(self.identityId, name: "identityId", parent: name, min: 1)
            try self.validate(self.identityId, name: "identityId", parent: name, pattern: "^\\S+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {
        /// A list that summarizes each access policy.
        public let accessPolicySummaries: [AccessPolicySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(accessPolicySummaries: [AccessPolicySummary], nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries = "accessPolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListActionsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the target resource.
        public let targetResourceId: String
        /// The type of resource.
        public let targetResourceType: TargetResourceType

        public init(maxResults: Int? = nil, nextToken: String? = nil, targetResourceId: String, targetResourceType: TargetResourceType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetResourceId = targetResourceId
            self.targetResourceType = targetResourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.targetResourceId, key: "targetResourceId")
            request.encodeQuery(self.targetResourceType, key: "targetResourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, max: 139)
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, min: 13)
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListActionsResponse: AWSDecodableShape {
        /// A list that summarizes the actions associated with the specified asset.
        public let actionSummaries: [ActionSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String

        public init(actionSummaries: [ActionSummary], nextToken: String) {
            self.actionSummaries = actionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionSummaries = "actionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelCompositeModelsRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelCompositeModelsResponse: AWSDecodableShape {
        /// A list that summarizes each composite model.
        public let assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary], nextToken: String? = nil) {
            self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelSummaries = "assetModelCompositeModelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelPropertiesRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        ///  Filters the requested list of asset model properties. You can choose one of the following options:    ALL – The list includes all asset model properties for a given asset model ID.     BASE – The list includes only base asset model properties for a given asset model ID.    Default: BASE
        public let filter: ListAssetModelPropertiesFilter?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String, filter: ListAssetModelPropertiesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelPropertiesResponse: AWSDecodableShape {
        /// A list that summarizes the properties associated with the specified asset model.
        public let assetModelPropertySummaries: [AssetModelPropertySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelPropertySummaries: [AssetModelPropertySummary], nextToken: String? = nil) {
            self.assetModelPropertySummaries = assetModelPropertySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelPropertySummaries = "assetModelPropertySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelsRequest: AWSEncodableShape {
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelTypes: [AssetModelType]?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelTypes: [AssetModelType]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelTypes = assetModelTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetModelTypes, key: "assetModelTypes")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelsResponse: AWSDecodableShape {
        /// A list that summarizes each asset model.
        public let assetModelSummaries: [AssetModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelSummaries: [AssetModelSummary], nextToken: String? = nil) {
            self.assetModelSummaries = assetModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelSummaries = "assetModelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetPropertiesRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        ///  Filters the requested list of asset properties. You can choose one of the following options:    ALL – The list includes all asset properties for a given asset model ID.     BASE – The list includes only base asset properties for a given asset model ID.    Default: BASE
        public let filter: ListAssetPropertiesFilter?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetId: String, filter: ListAssetPropertiesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetId = assetId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetPropertiesResponse: AWSDecodableShape {
        /// A list that summarizes the properties associated with the specified asset.
        public let assetPropertySummaries: [AssetPropertySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetPropertySummaries: [AssetPropertySummary], nextToken: String? = nil) {
            self.assetPropertySummaries = assetPropertySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertySummaries = "assetPropertySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetRelationshipsRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of traversal to use to identify asset relationships. Choose the following option:    PATH_TO_ROOT – Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
        public let traversalType: TraversalType

        public init(assetId: String, maxResults: Int? = nil, nextToken: String? = nil, traversalType: TraversalType) {
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalType = traversalType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.traversalType, key: "traversalType")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetRelationshipsResponse: AWSDecodableShape {
        /// A list that summarizes each asset relationship.
        public let assetRelationshipSummaries: [AssetRelationshipSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetRelationshipSummaries: [AssetRelationshipSummary], nextToken: String? = nil) {
            self.assetRelationshipSummaries = assetRelationshipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetRelationshipSummaries = "assetRelationshipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String?
        /// The filter for the requested list of assets. Choose one of the following options:    ALL – The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.    TOP_LEVEL – The list includes only top-level assets in the asset hierarchy tree.   Default: ALL
        public let filter: ListAssetsFilter?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String? = nil, filter: ListAssetsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {
        /// A list that summarizes each asset.
        public let assetSummaries: [AssetSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssetSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries = "assetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssociatedAssetsRequest: AWSEncodableShape {
        /// The ID of the asset to query. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the hierarchy by which child assets are associated to the asset. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.) To find a hierarchy ID, use the DescribeAsset or DescribeAssetModel operations. This parameter is required if you choose CHILD for traversalDirection. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The direction to list associated assets. Choose one of the following options:    CHILD – The list includes all child assets associated to the asset. The hierarchyId parameter is required if you choose CHILD.    PARENT – The list includes the asset's parent asset.   Default: CHILD
        public let traversalDirection: TraversalDirection?

        public init(assetId: String, hierarchyId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, traversalDirection: TraversalDirection? = nil) {
            self.assetId = assetId
            self.hierarchyId = hierarchyId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalDirection = traversalDirection
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.hierarchyId, key: "hierarchyId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.traversalDirection, key: "traversalDirection")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 139)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 13)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedAssetsResponse: AWSDecodableShape {
        /// A list that summarizes the associated assets.
        public let assetSummaries: [AssociatedAssetsSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssociatedAssetsSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries = "assetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBulkImportJobsRequest: AWSEncodableShape {
        /// You can use a filter to select the bulk import jobs that you want to retrieve.
        public let filter: ListBulkImportJobsFilter?
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(filter: ListBulkImportJobsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBulkImportJobsResponse: AWSDecodableShape {
        /// One or more job summaries to list.
        public let jobSummaries: [JobSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(jobSummaries: [JobSummary], nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries = "jobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCompositionRelationshipsRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCompositionRelationshipsResponse: AWSDecodableShape {
        /// A list that summarizes each composition relationship.
        public let compositionRelationshipSummaries: [CompositionRelationshipSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(compositionRelationshipSummaries: [CompositionRelationshipSummary], nextToken: String? = nil) {
            self.compositionRelationshipSummaries = compositionRelationshipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compositionRelationshipSummaries = "compositionRelationshipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        /// A list that summarizes each dashboard in the project.
        public let dashboardSummaries: [DashboardSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(dashboardSummaries: [DashboardSummary], nextToken: String? = nil) {
            self.dashboardSummaries = dashboardSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaries = "dashboardSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// A list that summarizes each gateway.
        public let gatewaySummaries: [GatewaySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(gatewaySummaries: [GatewaySummary], nextToken: String? = nil) {
            self.gatewaySummaries = gatewaySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewaySummaries = "gatewaySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each portal.
        public let portalSummaries: [PortalSummary]?

        public init(nextToken: String? = nil, portalSummaries: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portalSummaries = portalSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case portalSummaries = "portalSummaries"
        }
    }

    public struct ListProjectAssetsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectAssetsResponse: AWSDecodableShape {
        /// A list that contains the IDs of each asset associated with the project.
        public let assetIds: [String]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetIds: [String], nextToken: String? = nil) {
            self.assetIds = assetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the portal.
        public let portalId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, portalId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalId = portalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.portalId, key: "portalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each project in the portal.
        public let projectSummaries: [ProjectSummary]

        public init(nextToken: String? = nil, projectSummaries: [ProjectSummary]) {
            self.nextToken = nextToken
            self.projectSummaries = projectSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projectSummaries = "projectSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTimeSeriesRequest: AWSEncodableShape {
        /// The alias prefix of the time series.
        public let aliasPrefix: String?
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String?
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of the time series. The time series type can be one of the following values:    ASSOCIATED – The time series is associated with an asset property.    DISASSOCIATED – The time series isn't associated with any asset property.
        public let timeSeriesType: ListTimeSeriesType?

        public init(aliasPrefix: String? = nil, assetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, timeSeriesType: ListTimeSeriesType? = nil) {
            self.aliasPrefix = aliasPrefix
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.timeSeriesType = timeSeriesType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasPrefix, key: "aliasPrefix")
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.timeSeriesType, key: "timeSeriesType")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasPrefix, name: "aliasPrefix", parent: name, min: 1)
            try self.validate(self.aliasPrefix, name: "aliasPrefix", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTimeSeriesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// One or more time series summaries to list.
        public let timeSeriesSummaries: [TimeSeriesSummary]

        public init(nextToken: String? = nil, timeSeriesSummaries: [TimeSeriesSummary]) {
            self.nextToken = nextToken
            self.timeSeriesSummaries = timeSeriesSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case timeSeriesSummaries = "TimeSeriesSummaries"
        }
    }

    public struct LoggingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The IoT SiteWise logging verbosity level.
        public let level: LoggingLevel

        public init(level: LoggingLevel) {
            self.level = level
        }

        private enum CodingKeys: String, CodingKey {
            case level = "level"
        }
    }

    public struct Measurement: AWSEncodableShape & AWSDecodableShape {
        /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
        public let processingConfig: MeasurementProcessingConfig?

        public init(processingConfig: MeasurementProcessingConfig? = nil) {
            self.processingConfig = processingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case processingConfig = "processingConfig"
        }
    }

    public struct MeasurementProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The forwarding configuration for the given measurement property.
        public let forwardingConfig: ForwardingConfig

        public init(forwardingConfig: ForwardingConfig) {
            self.forwardingConfig = forwardingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case forwardingConfig = "forwardingConfig"
        }
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
        public let processingConfig: MetricProcessingConfig?
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        public let window: MetricWindow

        public init(expression: String, processingConfig: MetricProcessingConfig? = nil, variables: [ExpressionVariable], window: MetricWindow) {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
            try self.window.validate(name: "\(name).window")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case processingConfig = "processingConfig"
            case variables = "variables"
            case window = "window"
        }
    }

    public struct MetricProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The compute location for the given metric property.
        public let computeLocation: ComputeLocation

        public init(computeLocation: ComputeLocation) {
            self.computeLocation = computeLocation
        }

        private enum CodingKeys: String, CodingKey {
            case computeLocation = "computeLocation"
        }
    }

    public struct MetricWindow: AWSEncodableShape & AWSDecodableShape {
        /// The tumbling time interval window.
        public let tumbling: TumblingWindow?

        public init(tumbling: TumblingWindow? = nil) {
            self.tumbling = tumbling
        }

        public func validate(name: String) throws {
            try self.tumbling?.validate(name: "\(name).tumbling")
        }

        private enum CodingKeys: String, CodingKey {
            case tumbling = "tumbling"
        }
    }

    public struct MonitorErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: MonitorErrorCode?
        /// The error message.
        public let message: String?

        public init(code: MonitorErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct MultiLayerStorage: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about a customer managed Amazon S3 bucket.
        public let customerManagedS3Storage: CustomerManagedS3Storage

        public init(customerManagedS3Storage: CustomerManagedS3Storage) {
            self.customerManagedS3Storage = customerManagedS3Storage
        }

        public func validate(name: String) throws {
            try self.customerManagedS3Storage.validate(name: "\(name).customerManagedS3Storage")
        }

        private enum CodingKeys: String, CodingKey {
            case customerManagedS3Storage = "customerManagedS3Storage"
        }
    }

    public struct Parquet: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct PortalResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the portal.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct PortalStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: MonitorErrorDetails?
        /// The current state of the portal.
        public let state: PortalState

        public init(error: MonitorErrorDetails? = nil, state: PortalState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct PortalSummary: AWSDecodableShape {
        /// The date the portal was created, in Unix epoch time.
        public let creationDate: Date?
        /// The portal's description.
        public let description: String?
        /// The ID of the portal.
        public let id: String
        /// The date the portal was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the portal.
        public let name: String
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let startUrl: String
        public let status: PortalStatus

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String, roleArn: String? = nil, startUrl: String, status: PortalStatus) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case roleArn = "roleArn"
            case startUrl = "startUrl"
            case status = "status"
        }
    }

    public struct ProjectResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the project.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The date the project was created, in Unix epoch time.
        public let creationDate: Date?
        /// The project's description.
        public let description: String?
        /// The ID of the project.
        public let id: String
        /// The date the project was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the project.
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
        }
    }

    public struct Property: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The property data type.
        public let dataType: PropertyDataType
        /// The external ID of the asset property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public let path: [AssetPropertyPathSegment]?
        /// The property type (see PropertyType). A property contains one type.
        public let type: PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, externalId: String? = nil, id: String, name: String, notification: PropertyNotification? = nil, path: [AssetPropertyPathSegment]? = nil, type: PropertyType? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.externalId = externalId
            self.id = id
            self.name = name
            self.notification = notification
            self.path = path
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case dataType = "dataType"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case notification = "notification"
            case path = "path"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct PropertyNotification: AWSDecodableShape {
        /// The current notification state.
        public let state: PropertyNotificationState
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        public let topic: String

        public init(state: PropertyNotificationState, topic: String) {
            self.state = state
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case topic = "topic"
        }
    }

    public struct PropertyType: AWSEncodableShape & AWSDecodableShape {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an IIoT wind turbine.
        public let attribute: Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public let measurement: Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public let metric: Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public let transform: Transform?

        public init(attribute: Attribute? = nil, measurement: Measurement? = nil, metric: Metric? = nil, transform: Transform? = nil) {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }

        public func validate(name: String) throws {
            try self.attribute?.validate(name: "\(name).attribute")
            try self.metric?.validate(name: "\(name).metric")
            try self.transform?.validate(name: "\(name).transform")
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case measurement = "measurement"
            case metric = "metric"
            case transform = "transform"
        }
    }

    public struct PutAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset to update.
        public let assetId: String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property for this entry.
        public let propertyId: String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        public let propertyValues: [AssetPropertyValue]

        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, propertyValues: [AssetPropertyValue]) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.propertyValues.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case propertyValues = "propertyValues"
        }
    }

    public struct PutDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ID of the customer managed key used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyId: String?

        public init(encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct PutDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ARN of the KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// The logging options to set.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions = "loggingOptions"
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStorageConfigurationRequest: AWSEncodableShape {
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:    ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type, you must specify a MultiLayerStorage object.
        public let multiLayerStorage: MultiLayerStorage?
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.    MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType
        /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
        public let warmTier: WarmTierState?
        /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
        public let warmTierRetentionPeriod: WarmTierRetentionPeriod?

        public init(disassociatedDataStorage: DisassociatedDataStorageState? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType, warmTier: WarmTierState? = nil, warmTierRetentionPeriod: WarmTierRetentionPeriod? = nil) {
            self.disassociatedDataStorage = disassociatedDataStorage
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
            self.warmTier = warmTier
            self.warmTierRetentionPeriod = warmTierRetentionPeriod
        }

        public func validate(name: String) throws {
            try self.multiLayerStorage?.validate(name: "\(name).multiLayerStorage")
            try self.retentionPeriod?.validate(name: "\(name).retentionPeriod")
            try self.warmTierRetentionPeriod?.validate(name: "\(name).warmTierRetentionPeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case disassociatedDataStorage = "disassociatedDataStorage"
            case multiLayerStorage = "multiLayerStorage"
            case retentionPeriod = "retentionPeriod"
            case storageType = "storageType"
            case warmTier = "warmTier"
            case warmTierRetentionPeriod = "warmTierRetentionPeriod"
        }
    }

    public struct PutStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:    ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.    MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType
        /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
        public let warmTier: WarmTierState?
        /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
        public let warmTierRetentionPeriod: WarmTierRetentionPeriod?

        public init(configurationStatus: ConfigurationStatus, disassociatedDataStorage: DisassociatedDataStorageState? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType, warmTier: WarmTierState? = nil, warmTierRetentionPeriod: WarmTierRetentionPeriod? = nil) {
            self.configurationStatus = configurationStatus
            self.disassociatedDataStorage = disassociatedDataStorage
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
            self.warmTier = warmTier
            self.warmTierRetentionPeriod = warmTierRetentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case disassociatedDataStorage = "disassociatedDataStorage"
            case multiLayerStorage = "multiLayerStorage"
            case retentionPeriod = "retentionPeriod"
            case storageType = "storageType"
            case warmTier = "warmTier"
            case warmTierRetentionPeriod = "warmTierRetentionPeriod"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// A portal resource.
        public let portal: PortalResource?
        /// A project resource.
        public let project: ProjectResource?

        public init(portal: PortalResource? = nil, project: ProjectResource? = nil) {
            self.portal = portal
            self.project = project
        }

        public func validate(name: String) throws {
            try self.portal?.validate(name: "\(name).portal")
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
            case project = "project"
        }
    }

    public struct RetentionPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The number of days that your data is kept.  If you specified a value for this parameter, the unlimited parameter must be false.
        public let numberOfDays: Int?
        /// If true, your data is kept indefinitely.  If configured to true, you must not specify a value for the numberOfDays parameter.
        public let unlimited: Bool?

        public init(numberOfDays: Int? = nil, unlimited: Bool? = nil) {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDays, name: "numberOfDays", parent: name, min: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDays = "numberOfDays"
            case unlimited = "unlimited"
        }
    }

    public struct Row: AWSDecodableShape {
        /// List of data points in a single row of the result set.
        public let data: [Datum]

        public init(data: [Datum]) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to tag.
        public let resourceArn: String
        /// A list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String

        public init(assetId: String) {
            self.assetId = assetId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
        }
    }

    public struct TimeInNanos: AWSEncodableShape & AWSDecodableShape {
        /// The nanosecond offset from timeInSeconds.
        public let offsetInNanos: Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        public let timeInSeconds: Int64

        public init(offsetInNanos: Int? = nil, timeInSeconds: Int64) {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, max: 999999999)
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, min: 0)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, max: 9223372036854774)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case offsetInNanos = "offsetInNanos"
            case timeInSeconds = "timeInSeconds"
        }
    }

    public struct TimeSeriesSummary: AWSDecodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        public let dataType: PropertyDataType
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The ARN of the time series, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
        public let timeSeriesArn: String
        /// The date that the time series was created, in Unix epoch time.
        public let timeSeriesCreationDate: Date
        /// The ID of the time series.
        public let timeSeriesId: String
        /// The date that the time series was last updated, in Unix epoch time.
        public let timeSeriesLastUpdateDate: Date

        public init(alias: String? = nil, assetId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, propertyId: String? = nil, timeSeriesArn: String, timeSeriesCreationDate: Date, timeSeriesId: String, timeSeriesLastUpdateDate: Date) {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesArn = timeSeriesArn
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case assetId = "assetId"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case propertyId = "propertyId"
            case timeSeriesArn = "timeSeriesArn"
            case timeSeriesCreationDate = "timeSeriesCreationDate"
            case timeSeriesId = "timeSeriesId"
            case timeSeriesLastUpdateDate = "timeSeriesLastUpdateDate"
        }
    }

    public struct Transform: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
        public let processingConfig: TransformProcessingConfig?
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]

        public init(expression: String, processingConfig: TransformProcessingConfig? = nil, variables: [ExpressionVariable]) {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case processingConfig = "processingConfig"
            case variables = "variables"
        }
    }

    public struct TransformProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The compute location for the given transform property.
        public let computeLocation: ComputeLocation
        public let forwardingConfig: ForwardingConfig?

        public init(computeLocation: ComputeLocation, forwardingConfig: ForwardingConfig? = nil) {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case computeLocation = "computeLocation"
            case forwardingConfig = "forwardingConfig"
        }
    }

    public struct TumblingWindow: AWSEncodableShape & AWSDecodableShape {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on.  When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        public let interval: String
        /// The offset for the tumbling window. The offset parameter accepts the following:   The offset time. For example, if you specify 18h for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.   If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.     The ISO 8601 format. For example, if you specify PT18H for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.   If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.     The 24-hour clock. For example, if you specify 00:03:00 for offset, 5m for interval, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC).    The offset time zone. For example, if you specify 2021-07-23T18:00-08 for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.   If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.
        public let offset: String?

        public init(interval: String, offset: String? = nil) {
            self.interval = interval
            self.offset = offset
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, max: 23)
            try self.validate(self.interval, name: "interval", parent: name, min: 2)
            try self.validate(self.offset, name: "offset", parent: name, max: 25)
            try self.validate(self.offset, name: "offset", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "interval"
            case offset = "offset"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to untag.
        public let resourceArn: String
        /// A list of keys for tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPolicyId, key: "accessPolicyId")
            try container.encode(self.accessPolicyIdentity, forKey: .accessPolicyIdentity)
            try container.encode(self.accessPolicyPermission, forKey: .accessPolicyPermission)
            try container.encode(self.accessPolicyResource, forKey: .accessPolicyResource)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssetModelCompositeModelRequest: AWSEncodableShape {
        /// A description for the composite model.
        public let assetModelCompositeModelDescription: String?
        /// An external ID to assign to the asset model. You can only set the external ID of the asset model if it wasn't set when it was created, or you're setting it to  the exact same thing as when it was created.
        public let assetModelCompositeModelExternalId: String?
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// A unique, friendly name for the composite model.
        public let assetModelCompositeModelName: String
        /// The property definitions of the composite model. For more information, see . You can specify up to 200 properties per composite model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelCompositeModelProperties: [AssetModelProperty]?
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelCompositeModelDescription: String? = nil, assetModelCompositeModelExternalId: String? = nil, assetModelCompositeModelId: String, assetModelCompositeModelName: String, assetModelCompositeModelProperties: [AssetModelProperty]? = nil, assetModelId: String, clientToken: String? = UpdateAssetModelCompositeModelRequest.idempotencyToken()) {
            self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
            self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelName = assetModelCompositeModelName
            self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
            self.assetModelId = assetModelId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetModelCompositeModelDescription, forKey: .assetModelCompositeModelDescription)
            try container.encodeIfPresent(self.assetModelCompositeModelExternalId, forKey: .assetModelCompositeModelExternalId)
            request.encodePath(self.assetModelCompositeModelId, key: "assetModelCompositeModelId")
            try container.encode(self.assetModelCompositeModelName, forKey: .assetModelCompositeModelName)
            try container.encodeIfPresent(self.assetModelCompositeModelProperties, forKey: .assetModelCompositeModelProperties)
            request.encodePath(self.assetModelId, key: "assetModelId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, max: 256)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelCompositeModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModelProperties[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelDescription = "assetModelCompositeModelDescription"
            case assetModelCompositeModelExternalId = "assetModelCompositeModelExternalId"
            case assetModelCompositeModelName = "assetModelCompositeModelName"
            case assetModelCompositeModelProperties = "assetModelCompositeModelProperties"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetModelCompositeModelResponse: AWSDecodableShape {
        /// The path to the composite model listing the parent composite models.
        public let assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment]
        public let assetModelStatus: AssetModelStatus

        public init(assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment], assetModelStatus: AssetModelStatus) {
            self.assetModelCompositeModelPath = assetModelCompositeModelPath
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelPath = "assetModelCompositeModelPath"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct UpdateAssetModelRequest: AWSEncodableShape {
        /// The composite models that are part of this asset model. It groups properties (such as attributes, measurements, transforms, and metrics) and child composite models that model parts of your industrial equipment. Each composite model has a type that defines the properties that the composite model supports. Use composite models to define alarms on this asset model.  When creating custom composite models, you need to use CreateAssetModelCompositeModel. For more information, see .
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// An external ID to assign to the asset model. The asset model must not already have an external ID. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetModelExternalId: String?
        /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchy]?
        /// The ID of the asset model to update. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The updated property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelProperty]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelDescription: String? = nil, assetModelExternalId: String? = nil, assetModelHierarchies: [AssetModelHierarchy]? = nil, assetModelId: String, assetModelName: String, assetModelProperties: [AssetModelProperty]? = nil, clientToken: String? = UpdateAssetModelRequest.idempotencyToken()) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelExternalId = assetModelExternalId
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetModelCompositeModels, forKey: .assetModelCompositeModels)
            try container.encodeIfPresent(self.assetModelDescription, forKey: .assetModelDescription)
            try container.encodeIfPresent(self.assetModelExternalId, forKey: .assetModelExternalId)
            try container.encodeIfPresent(self.assetModelHierarchies, forKey: .assetModelHierarchies)
            request.encodePath(self.assetModelId, key: "assetModelId")
            try container.encode(self.assetModelName, forKey: .assetModelName)
            try container.encodeIfPresent(self.assetModelProperties, forKey: .assetModelProperties)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels = "assetModelCompositeModels"
            case assetModelDescription = "assetModelDescription"
            case assetModelExternalId = "assetModelExternalId"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct UpdateAssetPropertyRequest: AWSEncodableShape {
        /// The ID of the asset to be updated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
        public let propertyAlias: String?
        /// The ID of the asset property to be updated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String
        /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see Interacting with other services in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
        public let propertyNotificationState: PropertyNotificationState?
        /// The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
        public let propertyUnit: String?

        public init(assetId: String, clientToken: String? = UpdateAssetPropertyRequest.idempotencyToken(), propertyAlias: String? = nil, propertyId: String, propertyNotificationState: PropertyNotificationState? = nil, propertyUnit: String? = nil) {
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyNotificationState = propertyNotificationState
            self.propertyUnit = propertyUnit
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.propertyAlias, forKey: .propertyAlias)
            request.encodePath(self.propertyId, key: "propertyId")
            try container.encodeIfPresent(self.propertyNotificationState, forKey: .propertyNotificationState)
            try container.encodeIfPresent(self.propertyUnit, forKey: .propertyUnit)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, max: 256)
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, min: 1)
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case propertyAlias = "propertyAlias"
            case propertyNotificationState = "propertyNotificationState"
            case propertyUnit = "propertyUnit"
        }
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        /// A description for the asset.
        public let assetDescription: String?
        /// An external ID to assign to the asset. The asset must not already have an external ID. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetExternalId: String?
        /// The ID of the asset to update. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetDescription: String? = nil, assetExternalId: String? = nil, assetId: String, assetName: String, clientToken: String? = UpdateAssetRequest.idempotencyToken()) {
            self.assetDescription = assetDescription
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.assetName = assetName
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetDescription, forKey: .assetDescription)
            try container.encodeIfPresent(self.assetExternalId, forKey: .assetExternalId)
            request.encodePath(self.assetId, key: "assetId")
            try container.encode(self.assetName, forKey: .assetName)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, max: 2048)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, min: 1)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, max: 128)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, min: 2)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetDescription = "assetDescription"
            case assetExternalId = "assetExternalId"
            case assetName = "assetName"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus = "assetStatus"
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The new dashboard definition, as specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A new description for the dashboard.
        public let dashboardDescription: String?
        /// The ID of the dashboard to update.
        public let dashboardId: String
        /// A new friendly name for the dashboard.
        public let dashboardName: String

        public init(clientToken: String? = UpdateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardName: String) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardName = dashboardName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.dashboardDefinition, forKey: .dashboardDefinition)
            try container.encodeIfPresent(self.dashboardDescription, forKey: .dashboardDescription)
            request.encodePath(self.dashboardId, key: "dashboardId")
            try container.encode(self.dashboardName, forKey: .dashboardName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: "^.+$")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardName = "dashboardName"
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        /// The JSON document that defines the configuration for the gateway capability. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway to be updated.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.capabilityConfiguration, forKey: .capabilityConfiguration)
            try container.encode(self.capabilityNamespace, forKey: .capabilityNamespace)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, max: 104857600)
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration = "capabilityConfiguration"
            case capabilityNamespace = "capabilityNamespace"
        }
    }

    public struct UpdateGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.   After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        /// The ID of the gateway to update.
        public let gatewayId: String
        /// A unique, friendly name for the gateway.
        public let gatewayName: String

        public init(gatewayId: String, gatewayName: String) {
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            try container.encode(self.gatewayName, forKey: .gatewayName)
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName = "gatewayName"
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A new description for the portal.
        public let portalDescription: String?
        /// The ID of the portal to update.
        public let portalId: String
        public let portalLogoImage: Image?
        /// A new friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String

        public init(alarms: Alarms? = nil, clientToken: String? = UpdatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalContactEmail: String, portalDescription: String? = nil, portalId: String, portalLogoImage: Image? = nil, portalName: String, roleArn: String) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLogoImage = portalLogoImage
            self.portalName = portalName
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.alarms, forKey: .alarms)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.notificationSenderEmail, forKey: .notificationSenderEmail)
            try container.encode(self.portalContactEmail, forKey: .portalContactEmail)
            try container.encodeIfPresent(self.portalDescription, forKey: .portalDescription)
            request.encodePath(self.portalId, key: "portalId")
            try container.encodeIfPresent(self.portalLogoImage, forKey: .portalLogoImage)
            try container.encode(self.portalName, forKey: .portalName)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.portalLogoImage?.validate(name: "\(name).portalLogoImage")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "alarms"
            case clientToken = "clientToken"
            case notificationSenderEmail = "notificationSenderEmail"
            case portalContactEmail = "portalContactEmail"
            case portalDescription = "portalDescription"
            case portalLogoImage = "portalLogoImage"
            case portalName = "portalName"
            case roleArn = "roleArn"
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus = "portalStatus"
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A new description for the project.
        public let projectDescription: String?
        /// The ID of the project to update.
        public let projectId: String
        /// A new friendly name for the project.
        public let projectName: String

        public init(clientToken: String? = UpdateProjectRequest.idempotencyToken(), projectDescription: String? = nil, projectId: String, projectName: String) {
            self.clientToken = clientToken
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.projectDescription, forKey: .projectDescription)
            request.encodePath(self.projectId, key: "projectId")
            try container.encode(self.projectName, forKey: .projectName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The IAM Identity Center ID of the user.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct VariableValue: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID.  If the hierarchy has an external ID, you can specify externalId: followed by the external ID. For more information, see Using external IDs in the IoT SiteWise User Guide. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model. If the property has an external ID, you can specify externalId: followed by the external ID. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let propertyId: String?
        /// The path of the property.
        public let propertyPath: [AssetModelPropertyPathSegment]?

        public init(hierarchyId: String? = nil, propertyId: String? = nil, propertyPath: [AssetModelPropertyPathSegment]? = nil) {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
            self.propertyPath = propertyPath
        }

        public func validate(name: String) throws {
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 256)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 256)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 1)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.propertyPath?.forEach {
                try $0.validate(name: "\(name).propertyPath[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyId = "hierarchyId"
            case propertyId = "propertyId"
            case propertyPath = "propertyPath"
        }
    }

    public struct Variant: AWSEncodableShape & AWSDecodableShape {
        /// Asset property data of type Boolean (true or false).
        public let booleanValue: Bool?
        /// Asset property data of type double (floating point number).
        public let doubleValue: Double?
        /// Asset property data of type integer (number that's greater than or equal to zero).
        public let integerValue: Int?
        /// Asset property data of type string (sequence of characters).
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, integerValue: Int? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case integerValue = "integerValue"
            case stringValue = "stringValue"
        }
    }

    public struct WarmTierRetentionPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The number of days the data is stored in the warm tier.
        public let numberOfDays: Int?
        /// If set to true, the data is stored indefinitely in the warm tier.
        public let unlimited: Bool?

        public init(numberOfDays: Int? = nil, unlimited: Bool? = nil) {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDays, name: "numberOfDays", parent: name, min: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDays = "numberOfDays"
            case unlimited = "unlimited"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTSiteWise
public struct IoTSiteWiseErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictingOperationException = "ConflictingOperationException"
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case queryTimeoutException = "QueryTimeoutException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTSiteWise
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
    public static var conflictingOperationException: Self { .init(.conflictingOperationException) }
    /// IoT SiteWise can't process your request right now. Try again later.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters. Check your request and try again.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// You've reached the limit for a resource. For example, this can occur if you're trying to associate more than the allowed number of child assets or attempting to create more than the allowed number of properties for an asset model. For more information, see Quotas in the IoT SiteWise User Guide.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The query timed out.
    public static var queryTimeoutException: Self { .init(.queryTimeoutException) }
    /// The resource already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The requested resource can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The requested service is unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Your request exceeded a rate limit. For example, you might have exceeded the number of IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so on. For more information, see Quotas in the IoT SiteWise User Guide.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You've reached the limit for the number of tags allowed for a resource. For more information, see Tag naming limits and requirements in the Amazon Web Services General Reference.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// You are not authorized.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The validation failed for this query.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTSiteWiseErrorType: Equatable {
    public static func == (lhs: IoTSiteWiseErrorType, rhs: IoTSiteWiseErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTSiteWiseErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
