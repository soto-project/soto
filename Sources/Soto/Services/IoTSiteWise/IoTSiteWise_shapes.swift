//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTSiteWise {
    // MARK: Enums

    public enum AggregateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case average = "AVERAGE"
        case count = "COUNT"
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        case standardDeviation = "STANDARD_DEVIATION"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AssetErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case propagating = "PROPAGATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assetModel = "ASSET_MODEL"
        case componentModel = "COMPONENT_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelVersionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case latest = "LATEST"
        public var description: String { return self.rawValue }
    }

    public enum AssetRelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hierarchy = "HIERARCHY"
        public var description: String { return self.rawValue }
    }

    public enum AssetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AuthMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum BatchEntryCompletionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyAggregatesErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyValueHistoryErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchPutAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case conflictingOperationException = "ConflictingOperationException"
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case timestampOutOfRangeException = "TimestampOutOfRangeException"
        public var description: String { return self.rawValue }
    }

    public enum CapabilitySyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inSync = "IN_SYNC"
        case notApplicable = "NOT_APPLICABLE"
        case outOfSync = "OUT_OF_SYNC"
        case syncFailed = "SYNC_FAILED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum ColumnName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alias = "ALIAS"
        case assetId = "ASSET_ID"
        case dataType = "DATA_TYPE"
        case propertyId = "PROPERTY_ID"
        case quality = "QUALITY"
        case timestampNanoOffset = "TIMESTAMP_NANO_OFFSET"
        case timestampSeconds = "TIMESTAMP_SECONDS"
        case value = "VALUE"
        public var description: String { return self.rawValue }
    }

    public enum ComputeLocation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case edge = "EDGE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum CoreDeviceOperatingSystem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linuxAarch64 = "LINUX_AARCH64"
        case linuxAmd64 = "LINUX_AMD64"
        case windowsAmd64 = "WINDOWS_AMD64"
        public var description: String { return self.rawValue }
    }

    public enum DatasetSourceFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum DatasetSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kendra = "KENDRA"
        public var description: String { return self.rawValue }
    }

    public enum DatasetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum DetailedErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case incompatibleComputeLocation = "INCOMPATIBLE_COMPUTE_LOCATION"
        case incompatibleForwardingConfiguration = "INCOMPATIBLE_FORWARDING_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum DisassociatedDataStorageState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kmsBasedEncryption = "KMS_BASED_ENCRYPTION"
        case sitewiseDefaultEncryption = "SITEWISE_DEFAULT_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ForwardingConfigState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case group = "GROUP"
        case iam = "IAM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ImageFileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case png = "PNG"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetModelPropertiesFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case base = "BASE"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetPropertiesFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case base = "BASE"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetsFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case topLevel = "TOP_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum ListBulkImportJobsFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ListTimeSeriesType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associated = "ASSOCIATED"
        case disassociated = "DISASSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case info = "INFO"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum MonitorErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        case limitExceeded = "LIMIT_EXCEEDED"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case administrator = "ADMINISTRATOR"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PortalState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PortalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sitewisePortalV1 = "SITEWISE_PORTAL_V1"
        case sitewisePortalV2 = "SITEWISE_PORTAL_V2"
        public var description: String { return self.rawValue }
    }

    public enum PropertyDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `struct` = "STRUCT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum PropertyNotificationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Quality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bad = "BAD"
        case good = "GOOD"
        case uncertain = "UNCERTAIN"
        public var description: String { return self.rawValue }
    }

    public enum RawValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "B"
        case double = "D"
        case integer = "I"
        case string = "S"
        case unknown = "U"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case portal = "PORTAL"
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum ScalarType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case int = "INT"
        case string = "STRING"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiLayerStorage = "MULTI_LAYER_STORAGE"
        case sitewiseDefaultStorage = "SITEWISE_DEFAULT_STORAGE"
        public var description: String { return self.rawValue }
    }

    public enum TargetResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        public var description: String { return self.rawValue }
    }

    public enum TimeOrdering: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TraversalDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case child = "CHILD"
        case parent = "PARENT"
        public var description: String { return self.rawValue }
    }

    public enum TraversalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pathToRoot = "PATH_TO_ROOT"
        public var description: String { return self.rawValue }
    }

    public enum WarmTierState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        case accessDeniedException(AccessDeniedException)
        case conflictingOperationException(ConflictingOperationException)
        case internalFailureException(InternalFailureException)
        case invalidRequestException(InvalidRequestException)
        case limitExceededException(LimitExceededException)
        /// Contains the SiteWise Assistant's response.
        case output(InvocationOutput)
        case resourceNotFoundException(ResourceNotFoundException)
        case throttlingException(ThrottlingException)
        /// Contains tracing information of the SiteWise Assistant's reasoning and data access.
        case trace(Trace)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .conflictingOperationException:
                let value = try container.decode(ConflictingOperationException.self, forKey: .conflictingOperationException)
                self = .conflictingOperationException(value)
            case .internalFailureException:
                let value = try container.decode(InternalFailureException.self, forKey: .internalFailureException)
                self = .internalFailureException(value)
            case .invalidRequestException:
                let value = try container.decode(InvalidRequestException.self, forKey: .invalidRequestException)
                self = .invalidRequestException(value)
            case .limitExceededException:
                let value = try container.decode(LimitExceededException.self, forKey: .limitExceededException)
                self = .limitExceededException(value)
            case .output:
                let value = try container.decode(InvocationOutput.self, forKey: .output)
                self = .output(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .trace:
                let value = try container.decode(Trace.self, forKey: .trace)
                self = .trace(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case conflictingOperationException = "conflictingOperationException"
            case internalFailureException = "internalFailureException"
            case invalidRequestException = "invalidRequestException"
            case limitExceededException = "limitExceededException"
            case output = "output"
            case resourceNotFoundException = "resourceNotFoundException"
            case throttlingException = "throttlingException"
            case trace = "trace"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct AccessPolicySummary: AWSDecodableShape {
        /// The date the access policy was created, in Unix epoch time.
        public let creationDate: Date?
        /// The ID of the access policy.
        public let id: String
        /// The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).
        public let identity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let permission: Permission
        /// The IoT SiteWise Monitor resource (a portal or project).
        public let resource: Resource

        @inlinable
        public init(creationDate: Date? = nil, id: String, identity: Identity, lastUpdateDate: Date? = nil, permission: Permission, resource: Resource) {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case id = "id"
            case identity = "identity"
            case lastUpdateDate = "lastUpdateDate"
            case permission = "permission"
            case resource = "resource"
        }
    }

    public struct ActionDefinition: AWSDecodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String
        /// The name of the action definition.
        public let actionName: String
        /// The type of the action definition.
        public let actionType: String

        @inlinable
        public init(actionDefinitionId: String, actionName: String, actionType: String) {
            self.actionDefinitionId = actionDefinitionId
            self.actionName = actionName
            self.actionType = actionType
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionName = "actionName"
            case actionType = "actionType"
        }
    }

    public struct ActionPayload: AWSEncodableShape & AWSDecodableShape {
        /// The payload of the action in a JSON string.
        public let stringValue: String

        @inlinable
        public init(stringValue: String) {
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case stringValue = "stringValue"
        }
    }

    public struct ActionSummary: AWSDecodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String?
        /// The ID of the action.
        public let actionId: String?
        /// The resource the action will be taken on.
        public let targetResource: TargetResource?

        @inlinable
        public init(actionDefinitionId: String? = nil, actionId: String? = nil, targetResource: TargetResource? = nil) {
            self.actionDefinitionId = actionDefinitionId
            self.actionId = actionId
            self.targetResource = targetResource
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionId = "actionId"
            case targetResource = "targetResource"
        }
    }

    public struct AggregatedValue: AWSDecodableShape {
        /// The quality of the aggregated data.
        public let quality: Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        public let timestamp: Date
        /// The value of the aggregates.
        public let value: Aggregates

        @inlinable
        public init(quality: Quality? = nil, timestamp: Date, value: Aggregates) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case quality = "quality"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct Aggregates: AWSDecodableShape {
        /// The average (mean) value of the time series over a time interval window.
        public let average: Double?
        /// The count of data points in the time series over a time interval window.
        public let count: Double?
        /// The maximum value of the time series over a time interval window.
        public let maximum: Double?
        /// The minimum value of the time series over a time interval window.
        public let minimum: Double?
        /// The standard deviation of the time series over a time interval window.
        public let standardDeviation: Double?
        /// The sum of the time series over a time interval window.
        public let sum: Double?

        @inlinable
        public init(average: Double? = nil, count: Double? = nil, maximum: Double? = nil, minimum: Double? = nil, standardDeviation: Double? = nil, sum: Double? = nil) {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case average = "average"
            case count = "count"
            case maximum = "maximum"
            case minimum = "minimum"
            case standardDeviation = "standardDeviation"
            case sum = "sum"
        }
    }

    public struct Alarms: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        public let alarmRoleArn: String
        /// The ARN of the Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the IoT Events Developer Guide.
        public let notificationLambdaArn: String?

        @inlinable
        public init(alarmRoleArn: String, notificationLambdaArn: String? = nil) {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, max: 1600)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, min: 1)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.\\+=,@]+$")
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, max: 1600)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, min: 1)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmRoleArn = "alarmRoleArn"
            case notificationLambdaArn = "notificationLambdaArn"
        }
    }

    public struct AssetCompositeModel: AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The external ID of the asset composite model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        ///  The ID of the asset composite model.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset properties that this composite model defines.
        public let properties: [AssetProperty]
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        @inlinable
        public init(description: String? = nil, externalId: String? = nil, id: String? = nil, name: String, properties: [AssetProperty], type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case type = "type"
        }
    }

    public struct AssetCompositeModelPathSegment: AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetCompositeModelSummary: AWSDecodableShape {
        /// A description of the composite model that this summary describes.
        public let description: String
        /// An external ID to assign to the asset model. If the composite model is a derived composite model, or one nested inside a component model, you can only set the external ID using UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public let externalId: String?
        /// The ID of the composite model that this summary describes.
        public let id: String
        /// The name of the composite model that this summary describes.
        public let name: String
        /// The path that includes all the components of the asset model for the asset.
        public let path: [AssetCompositeModelPathSegment]
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let type: String

        @inlinable
        public init(description: String, externalId: String? = nil, id: String, name: String, path: [AssetCompositeModelPathSegment], type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
        }
    }

    public struct AssetErrorDetails: AWSDecodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String
        /// The error code.
        public let code: AssetErrorCode
        /// The error message.
        public let message: String

        @inlinable
        public init(assetId: String, code: AssetErrorCode, message: String) {
            self.assetId = assetId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case code = "code"
            case message = "message"
        }
    }

    public struct AssetHierarchy: AWSDecodableShape {
        /// The external ID of the hierarchy, if it has one. When you update an asset hierarchy, you may assign an external ID if it doesn't already have one. You can't change the external ID of an asset hierarchy that already has one. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The hierarchy name provided in the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        @inlinable
        public init(externalId: String? = nil, id: String? = nil, name: String) {
            self.externalId = externalId
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "externalId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetHierarchyInfo: AWSDecodableShape {
        /// The ID of the child asset in this asset relationship.
        public let childAssetId: String?
        /// The ID of the parent asset in this asset relationship.
        public let parentAssetId: String?

        @inlinable
        public init(childAssetId: String? = nil, parentAssetId: String? = nil) {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case parentAssetId = "parentAssetId"
        }
    }

    public struct AssetModelCompositeModel: AWSEncodableShape & AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The external ID of the asset model composite model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        ///  The ID of the asset model composite model.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        @inlinable
        public init(description: String? = nil, externalId: String? = nil, id: String? = nil, name: String, properties: [AssetModelProperty]? = nil, type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 139)
            try self.validate(self.id, name: "id", parent: name, min: 13)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case type = "type"
        }
    }

    public struct AssetModelCompositeModelDefinition: AWSEncodableShape {
        /// The description of the composite model.
        public let description: String?
        /// An external ID to assign to the composite model. The external ID must be unique among composite models within this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID to assign to the composite model, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        @inlinable
        public init(description: String? = nil, externalId: String? = nil, id: String? = nil, name: String, properties: [AssetModelPropertyDefinition]? = nil, type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case type = "type"
        }
    }

    public struct AssetModelCompositeModelPathSegment: AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelCompositeModelSummary: AWSDecodableShape {
        /// The description of the composite model that this summary describes..
        public let description: String?
        /// The external ID of a composite model on this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the composite model that this summary describes..
        public let id: String
        /// The name of the composite model that this summary describes..
        public let name: String
        /// The path that includes all the pieces that make up the composite model.
        public let path: [AssetModelCompositeModelPathSegment]?
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        public let type: String

        @inlinable
        public init(description: String? = nil, externalId: String? = nil, id: String, name: String, path: [AssetModelCompositeModelPathSegment]? = nil, type: String) {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
        }
    }

    public struct AssetModelHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset model, in UUID format. All assets in this hierarchy must be instances of the childAssetModelId asset model. IoT SiteWise will always return the actual asset model ID for this value. However, when you are specifying this value as part of a call to UpdateAssetModel, you may provide either the asset model ID or else externalId: followed by the asset model's external ID. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let childAssetModelId: String
        /// The external ID (if any) provided in the CreateAssetModel or UpdateAssetModel operation. You can assign an external ID by specifying this value as part of a call to UpdateAssetModel. However, you can't change the external ID if one is already assigned. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.   If you are callling UpdateAssetModel to create a new hierarchy: You can specify its ID here, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.   If you are calling UpdateAssetModel to modify an existing hierarchy: This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let id: String?
        /// The name of the asset model hierarchy that you specify by using the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        @inlinable
        public init(childAssetModelId: String, externalId: String? = nil, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.externalId = externalId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 139)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 13)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 139)
            try self.validate(self.id, name: "id", parent: name, min: 13)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId = "childAssetModelId"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelHierarchyDefinition: AWSEncodableShape {
        /// The ID of an asset model for this hierarchy. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let childAssetModelId: String
        /// An external ID to assign to the asset model hierarchy. The external ID must be unique among asset model hierarchies within this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID to assign to the asset model hierarchy, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let id: String?
        /// The name of the asset model hierarchy definition (as specified in the CreateAssetModel or UpdateAssetModel API operation).
        public let name: String

        @inlinable
        public init(childAssetModelId: String, externalId: String? = nil, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.externalId = externalId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 139)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 13)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId = "childAssetModelId"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelProperty: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the asset model property. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The external ID (if any) provided in the CreateAssetModel or UpdateAssetModel operation. You can assign an external ID by specifying this value as part of a call to UpdateAssetModel. However, you can't change the external ID if one is already assigned. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset model property.   If you are callling UpdateAssetModel to create a new property: You can specify its ID here, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.   If you are calling UpdateAssetModel to modify an existing property: This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let id: String?
        /// The name of the asset model property.
        public let name: String
        /// The structured path to the property from the root of the asset model.
        public let path: [AssetModelPropertyPathSegment]?
        /// The property type (see PropertyType).
        public let type: PropertyType
        /// The unit of the asset model property, such as Newtons or RPM.
        public let unit: String?

        @inlinable
        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String? = nil, name: String, path: [AssetModelPropertyPathSegment]? = nil, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 139)
            try self.validate(self.id, name: "id", parent: name, min: 13)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.path?.forEach {
                try $0.validate(name: "\(name).path[]")
            }
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelPropertyDefinition: AWSEncodableShape {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// An external ID to assign to the property definition. The external ID must be unique among property definitions within this asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID to assign to the asset model property, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let id: String?
        /// The name of the property definition.
        public let name: String
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        public let type: PropertyType
        /// The unit of the property definition, such as Newtons or RPM.
        public let unit: String?

        @inlinable
        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.externalId, name: "externalId", parent: name, max: 128)
            try self.validate(self.externalId, name: "externalId", parent: name, min: 2)
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelPropertyPathSegment: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelPropertySummary: AWSDecodableShape {
        ///  The ID of the composite model that contains the asset model property.
        public let assetModelCompositeModelId: String?
        /// The data type of the property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The external ID of the property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the property.
        public let id: String?
        /// The name of the property.
        public let name: String
        /// The structured path to the property from the root of the asset model.
        public let path: [AssetModelPropertyPathSegment]?
        public let type: PropertyType
        /// The unit (such as Newtons or RPM) of the property.
        public let unit: String?

        @inlinable
        public init(assetModelCompositeModelId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String? = nil, name: String, path: [AssetModelPropertyPathSegment]? = nil, type: PropertyType, unit: String? = nil) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case path = "path"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current state of the asset model.
        public let state: AssetModelState

        @inlinable
        public init(error: ErrorDetails? = nil, state: AssetModelState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct AssetModelSummary: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let arn: String
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelType: AssetModelType?
        /// The date the asset model was created, in Unix epoch time.
        public let creationDate: Date
        /// The asset model description.
        public let description: String
        /// The external ID of the asset model. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset model (used with IoT SiteWise API operations).
        public let id: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset model.
        public let name: String
        /// The current status of the asset model.
        public let status: AssetModelStatus
        /// The version number of the asset model.
        public let version: String?

        @inlinable
        public init(arn: String, assetModelType: AssetModelType? = nil, creationDate: Date, description: String, externalId: String? = nil, id: String, lastUpdateDate: Date, name: String, status: AssetModelStatus, version: String? = nil) {
            self.arn = arn
            self.assetModelType = assetModelType
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelType = "assetModelType"
            case creationDate = "creationDate"
            case description = "description"
            case externalId = "externalId"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
            case version = "version"
        }
    }

    public struct AssetProperty: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The data type of the asset property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The external ID of the asset property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public let path: [AssetPropertyPathSegment]?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        @inlinable
        public init(alias: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, externalId: String? = nil, id: String, name: String, notification: PropertyNotification? = nil, path: [AssetPropertyPathSegment]? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.notification = notification
            self.path = path
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case notification = "notification"
            case path = "path"
            case unit = "unit"
        }
    }

    public struct AssetPropertyPathSegment: AWSDecodableShape {
        /// The ID of the path segment.
        public let id: String?
        /// The name of the path segment.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetPropertySummary: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        ///  The ID of the composite model that contains the asset property.
        public let assetCompositeModelId: String?
        /// The external ID of the property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the property.
        public let id: String
        public let notification: PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public let path: [AssetPropertyPathSegment]?
        ///  The unit of measure (such as Newtons or RPM) of the asset property.
        public let unit: String?

        @inlinable
        public init(alias: String? = nil, assetCompositeModelId: String? = nil, externalId: String? = nil, id: String, notification: PropertyNotification? = nil, path: [AssetPropertyPathSegment]? = nil, unit: String? = nil) {
            self.alias = alias
            self.assetCompositeModelId = assetCompositeModelId
            self.externalId = externalId
            self.id = id
            self.notification = notification
            self.path = path
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case assetCompositeModelId = "assetCompositeModelId"
            case externalId = "externalId"
            case id = "id"
            case notification = "notification"
            case path = "path"
            case unit = "unit"
        }
    }

    public struct AssetPropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// The quality of the asset property value.
        public let quality: Quality?
        /// The timestamp of the asset property value.
        public let timestamp: TimeInNanos
        /// The value of the asset property (see Variant).
        public let value: Variant

        @inlinable
        public init(quality: Quality? = nil, timestamp: TimeInNanos, value: Variant) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.timestamp.validate(name: "\(name).timestamp")
        }

        private enum CodingKeys: String, CodingKey {
            case quality = "quality"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct AssetRelationshipSummary: AWSDecodableShape {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public let hierarchyInfo: AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:    HIERARCHY – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        public let relationshipType: AssetRelationshipType

        @inlinable
        public init(hierarchyInfo: AssetHierarchyInfo? = nil, relationshipType: AssetRelationshipType) {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyInfo = "hierarchyInfo"
            case relationshipType = "relationshipType"
        }
    }

    public struct AssetStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current status of the asset.
        public let state: AssetState

        @inlinable
        public init(error: ErrorDetails? = nil, state: AssetState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct AssetSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create this asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A description for the asset.
        public let description: String?
        /// The external ID of the asset. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset, in UUID format.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        @inlinable
        public init(arn: String, assetModelId: String, creationDate: Date, description: String? = nil, externalId: String? = nil, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelId = "assetModelId"
            case creationDate = "creationDate"
            case description = "description"
            case externalId = "externalId"
            case hierarchies = "hierarchies"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssociateAssetsRequest: AWSEncodableShape {
        /// The ID of the parent asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the child asset to be associated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.) Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        @inlinable
        public init(assetId: String, childAssetId: String, clientToken: String? = AssociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            try container.encode(self.childAssetId, forKey: .childAssetId)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.hierarchyId, forKey: .hierarchyId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 139)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 13)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 139)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 13)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case clientToken = "clientToken"
            case hierarchyId = "hierarchyId"
        }
    }

    public struct AssociateTimeSeriesToAssetPropertyRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String

        @inlinable
        public init(alias: String, assetId: String, clientToken: String? = AssociateTimeSeriesToAssetPropertyRequest.idempotencyToken(), propertyId: String) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct AssociatedAssetsSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create the asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A description for the asset.
        public let description: String?
        /// The external ID of the asset. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset, in UUID format.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        @inlinable
        public init(arn: String, assetModelId: String, creationDate: Date, description: String? = nil, externalId: String? = nil, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelId = "assetModelId"
            case creationDate = "creationDate"
            case description = "description"
            case externalId = "externalId"
            case hierarchies = "hierarchies"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see Updating attribute values in the IoT SiteWise User Guide.
        public let defaultValue: String?

        @inlinable
        public init(defaultValue: String? = nil) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
        }
    }

    public struct BatchAssociateProjectAssetsRequest: AWSEncodableShape {
        /// The IDs of the assets to be associated to the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project to which to associate the assets.
        public let projectId: String

        @inlinable
        public init(assetIds: [String], clientToken: String? = BatchAssociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assetIds, forKey: .assetIds)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case clientToken = "clientToken"
        }
    }

    public struct BatchAssociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        @inlinable
        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDisassociateProjectAssetsRequest: AWSEncodableShape {
        /// The IDs of the assets to be disassociated from the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project from which to disassociate the assets.
        public let projectId: String

        @inlinable
        public init(assetIds: [String], clientToken: String? = BatchDisassociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assetIds, forKey: .assetIds)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case clientToken = "clientToken"
        }
    }

    public struct BatchDisassociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        @inlinable
        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchGetAssetPropertyAggregatesEntry: AWSEncodableShape {
        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        @inlinable
        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 3)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "^1m|15m|1h|1d$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateTypes = "aggregateTypes"
            case assetId = "assetId"
            case endDate = "endDate"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case qualities = "qualities"
            case resolution = "resolution"
            case startDate = "startDate"
            case timeOrdering = "timeOrdering"
        }
    }

    public struct BatchGetAssetPropertyAggregatesErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyAggregatesErrorCode
        /// The associated error message.
        public let errorMessage: String

        @inlinable
        public init(entryId: String, errorCode: BatchGetAssetPropertyAggregatesErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchGetAssetPropertyAggregatesErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyAggregatesErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        @inlinable
        public init(errorCode: BatchGetAssetPropertyAggregatesErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorTimestamp = "errorTimestamp"
        }
    }

    public struct BatchGetAssetPropertyAggregatesRequest: AWSEncodableShape {
        /// The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyAggregatesEntry]
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 1 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 4000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(entries: [BatchGetAssetPropertyAggregatesEntry], maxResults: Int? = nil, nextToken: String? = nil) {
            self.entries = entries
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct BatchGetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyAggregatesErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyAggregatesSkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyAggregatesSuccessEntry]

        @inlinable
        public init(errorEntries: [BatchGetAssetPropertyAggregatesErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyAggregatesSkippedEntry], successEntries: [BatchGetAssetPropertyAggregatesSuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
            case nextToken = "nextToken"
            case skippedEntries = "skippedEntries"
            case successEntries = "successEntries"
        }
    }

    public struct BatchGetAssetPropertyAggregatesSkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyAggregates API.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyAggregatesErrorInfo?

        @inlinable
        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyAggregatesErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "completionStatus"
            case entryId = "entryId"
            case errorInfo = "errorInfo"
        }
    }

    public struct BatchGetAssetPropertyAggregatesSuccessEntry: AWSDecodableShape {
        /// The requested aggregated asset property values (for example, average, minimum, and maximum).
        public let aggregatedValues: [AggregatedValue]
        /// The ID of the entry.
        public let entryId: String

        @inlinable
        public init(aggregatedValues: [AggregatedValue], entryId: String) {
            self.aggregatedValues = aggregatedValues
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues = "aggregatedValues"
            case entryId = "entryId"
        }
    }

    public struct BatchGetAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?

        @inlinable
        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
        }
    }

    public struct BatchGetAssetPropertyValueErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String

        @inlinable
        public init(entryId: String, errorCode: BatchGetAssetPropertyValueErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchGetAssetPropertyValueErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        @inlinable
        public init(errorCode: BatchGetAssetPropertyValueErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorTimestamp = "errorTimestamp"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryEntry: AWSEncodableShape {
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        @inlinable
        public init(assetId: String? = nil, endDate: Date? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case endDate = "endDate"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case qualities = "qualities"
            case startDate = "startDate"
            case timeOrdering = "timeOrdering"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueHistoryErrorCode
        /// The associated error message.
        public let errorMessage: String

        @inlinable
        public init(entryId: String, errorCode: BatchGetAssetPropertyValueHistoryErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueHistoryErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        @inlinable
        public init(errorCode: BatchGetAssetPropertyValueHistoryErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorTimestamp = "errorTimestamp"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        /// The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyValueHistoryEntry]
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 4 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(entries: [BatchGetAssetPropertyValueHistoryEntry], maxResults: Int? = nil, nextToken: String? = nil) {
            self.entries = entries
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct BatchGetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyValueHistoryErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyValueHistorySkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyValueHistorySuccessEntry]

        @inlinable
        public init(errorEntries: [BatchGetAssetPropertyValueHistoryErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyValueHistorySkippedEntry], successEntries: [BatchGetAssetPropertyValueHistorySuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
            case nextToken = "nextToken"
            case skippedEntries = "skippedEntries"
            case successEntries = "successEntries"
        }
    }

    public struct BatchGetAssetPropertyValueHistorySkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyValueHistory API.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyValueHistoryErrorInfo?

        @inlinable
        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyValueHistoryErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "completionStatus"
            case entryId = "entryId"
            case errorInfo = "errorInfo"
        }
    }

    public struct BatchGetAssetPropertyValueHistorySuccessEntry: AWSDecodableShape {
        /// The requested historical values for the specified asset property.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The ID of the entry.
        public let entryId: String

        @inlinable
        public init(assetPropertyValueHistory: [AssetPropertyValue], entryId: String) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory = "assetPropertyValueHistory"
            case entryId = "entryId"
        }
    }

    public struct BatchGetAssetPropertyValueRequest: AWSEncodableShape {
        /// The list of asset property value entries for the batch get request. You can specify up to 128 entries per request.
        public let entries: [BatchGetAssetPropertyValueEntry]
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(entries: [BatchGetAssetPropertyValueEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
            case nextToken = "nextToken"
        }
    }

    public struct BatchGetAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyValueErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyValueSkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyValueSuccessEntry]

        @inlinable
        public init(errorEntries: [BatchGetAssetPropertyValueErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyValueSkippedEntry], successEntries: [BatchGetAssetPropertyValueSuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
            case nextToken = "nextToken"
            case skippedEntries = "skippedEntries"
            case successEntries = "successEntries"
        }
    }

    public struct BatchGetAssetPropertyValueSkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyValue request.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyValueErrorInfo?

        @inlinable
        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyValueErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "completionStatus"
            case entryId = "entryId"
            case errorInfo = "errorInfo"
        }
    }

    public struct BatchGetAssetPropertyValueSuccessEntry: AWSDecodableShape {
        public let assetPropertyValue: AssetPropertyValue?
        /// The ID of the entry.
        public let entryId: String

        @inlinable
        public init(assetPropertyValue: AssetPropertyValue? = nil, entryId: String) {
            self.assetPropertyValue = assetPropertyValue
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValue = "assetPropertyValue"
            case entryId = "entryId"
        }
    }

    public struct BatchPutAssetPropertyError: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchPutAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String
        /// A list of timestamps for each  error, if any.
        public let timestamps: [TimeInNanos]

        @inlinable
        public init(errorCode: BatchPutAssetPropertyValueErrorCode, errorMessage: String, timestamps: [TimeInNanos]) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case timestamps = "timestamps"
        }
    }

    public struct BatchPutAssetPropertyErrorEntry: AWSDecodableShape {
        /// The ID of the failed entry.
        public let entryId: String
        /// The list of update property value errors.
        public let errors: [BatchPutAssetPropertyError]

        @inlinable
        public init(entryId: String, errors: [BatchPutAssetPropertyError]) {
            self.entryId = entryId
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errors = "errors"
        }
    }

    public struct BatchPutAssetPropertyValueRequest: AWSEncodableShape {
        /// This setting enables partial ingestion at entry-level. If set to true, we ingest all TQVs not resulting in an error. If set to  false, an invalid TQV fails ingestion of the entire entry that contains it.
        public let enablePartialEntryProcessing: Bool?
        /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
        public let entries: [PutAssetPropertyValueEntry]

        @inlinable
        public init(enablePartialEntryProcessing: Bool? = nil, entries: [PutAssetPropertyValueEntry]) {
            self.enablePartialEntryProcessing = enablePartialEntryProcessing
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enablePartialEntryProcessing = "enablePartialEntryProcessing"
            case entries = "entries"
        }
    }

    public struct BatchPutAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchPutAssetPropertyErrorEntry]

        @inlinable
        public init(errorEntries: [BatchPutAssetPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct Citation: AWSDecodableShape {
        /// Contains the cited text from the data source.
        public let content: Content?
        /// Contains information about the data source.
        public let reference: Reference?

        @inlinable
        public init(content: Content? = nil, reference: Reference? = nil) {
            self.content = content
            self.reference = reference
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case reference = "reference"
        }
    }

    public struct ColumnInfo: AWSDecodableShape {
        /// The name of the column description.
        public let name: String?
        /// The type of the column description.
        public let type: ColumnType?

        @inlinable
        public init(name: String? = nil, type: ColumnType? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ColumnType: AWSDecodableShape {
        /// The allowed data types that the column has as it's value.
        public let scalarType: ScalarType?

        @inlinable
        public init(scalarType: ScalarType? = nil) {
            self.scalarType = scalarType
        }

        private enum CodingKeys: String, CodingKey {
            case scalarType = "scalarType"
        }
    }

    public struct CompositeModelProperty: AWSDecodableShape {
        public let assetProperty: Property
        /// The external ID of the composite model that contains the property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        ///  The ID of the composite model that contains the property.
        public let id: String?
        /// The name of the property.
        public let name: String
        /// The type of the composite model that defines this property.
        public let type: String

        @inlinable
        public init(assetProperty: Property, externalId: String? = nil, id: String? = nil, name: String, type: String) {
            self.assetProperty = assetProperty
            self.externalId = externalId
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assetProperty = "assetProperty"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case type = "type"
        }
    }

    public struct CompositionDetails: AWSDecodableShape {
        /// An array detailing the composition relationship for this composite model.
        public let compositionRelationship: [CompositionRelationshipItem]?

        @inlinable
        public init(compositionRelationship: [CompositionRelationshipItem]? = nil) {
            self.compositionRelationship = compositionRelationship
        }

        private enum CodingKeys: String, CodingKey {
            case compositionRelationship = "compositionRelationship"
        }
    }

    public struct CompositionRelationshipItem: AWSDecodableShape {
        /// The ID of the component.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CompositionRelationshipSummary: AWSDecodableShape {
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or AWS/L4E_ANOMALY.
        public let assetModelCompositeModelType: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String

        @inlinable
        public init(assetModelCompositeModelId: String, assetModelCompositeModelType: String, assetModelId: String) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelType = "assetModelCompositeModelType"
            case assetModelId = "assetModelId"
        }
    }

    public struct ConfigurationErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        /// The error message.
        public let message: String

        @inlinable
        public init(code: ErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ConfigurationStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ConfigurationErrorDetails?
        /// The current state of the configuration.
        public let state: ConfigurationState

        @inlinable
        public init(error: ConfigurationErrorDetails? = nil, state: ConfigurationState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct ConflictingOperationException: AWSErrorShape {
        public let message: String
        /// The ARN of the resource that conflicts with this operation.
        public let resourceArn: String
        /// The ID of the resource that conflicts with this operation.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceArn: String, resourceId: String) {
            self.message = message
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct Content: AWSDecodableShape {
        /// The cited text from the data source.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {
        /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the access policy. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The ID of the access policy.
        public let accessPolicyId: String

        @inlinable
        public init(accessPolicyArn: String, accessPolicyId: String) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyId = accessPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn = "accessPolicyArn"
            case accessPolicyId = "accessPolicyId"
        }
    }

    public struct CreateAssetModelCompositeModelRequest: AWSEncodableShape {
        /// A description for the composite model.
        public let assetModelCompositeModelDescription: String?
        /// An external ID to assign to the composite model. If the composite model is a derived composite model, or one nested inside a component model, you can only set the external ID using UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public let assetModelCompositeModelExternalId: String?
        /// The ID of the composite model. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let assetModelCompositeModelId: String?
        /// A unique name for the composite model.
        public let assetModelCompositeModelName: String
        /// The property definitions of the composite model. For more information, see  Inline custom composite models in the IoT SiteWise User Guide. You can specify up to 200 properties per composite model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelCompositeModelProperties: [AssetModelPropertyDefinition]?
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        public let assetModelCompositeModelType: String
        /// The ID of the asset model this composite model is a part of.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a component model which is reused to create this composite model.
        public let composedAssetModelId: String?
        /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType).    The create request is rejected if the tag does not match the latest or active version's current entity tag. See Optimistic locking for asset model writes in the IoT SiteWise User Guide.
        public let ifMatch: String?
        /// Accepts * to reject the create request if an active version  (specified using matchForVersionType as ACTIVE) already exists for the asset model.
        public let ifNoneMatch: String?
        /// Specifies the asset model version type (LATEST or ACTIVE) used in  conjunction with If-Match or If-None-Match headers to determine the target ETag for the create operation.
        public let matchForVersionType: AssetModelVersionType?
        /// The ID of the parent composite model in this asset model relationship.
        public let parentAssetModelCompositeModelId: String?

        @inlinable
        public init(assetModelCompositeModelDescription: String? = nil, assetModelCompositeModelExternalId: String? = nil, assetModelCompositeModelId: String? = nil, assetModelCompositeModelName: String, assetModelCompositeModelProperties: [AssetModelPropertyDefinition]? = nil, assetModelCompositeModelType: String, assetModelId: String, clientToken: String? = CreateAssetModelCompositeModelRequest.idempotencyToken(), composedAssetModelId: String? = nil, ifMatch: String? = nil, ifNoneMatch: String? = nil, matchForVersionType: AssetModelVersionType? = nil, parentAssetModelCompositeModelId: String? = nil) {
            self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
            self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelName = assetModelCompositeModelName
            self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
            self.clientToken = clientToken
            self.composedAssetModelId = composedAssetModelId
            self.ifMatch = ifMatch
            self.ifNoneMatch = ifNoneMatch
            self.matchForVersionType = matchForVersionType
            self.parentAssetModelCompositeModelId = parentAssetModelCompositeModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetModelCompositeModelDescription, forKey: .assetModelCompositeModelDescription)
            try container.encodeIfPresent(self.assetModelCompositeModelExternalId, forKey: .assetModelCompositeModelExternalId)
            try container.encodeIfPresent(self.assetModelCompositeModelId, forKey: .assetModelCompositeModelId)
            try container.encode(self.assetModelCompositeModelName, forKey: .assetModelCompositeModelName)
            try container.encodeIfPresent(self.assetModelCompositeModelProperties, forKey: .assetModelCompositeModelProperties)
            try container.encode(self.assetModelCompositeModelType, forKey: .assetModelCompositeModelType)
            request.encodePath(self.assetModelId, key: "assetModelId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.composedAssetModelId, forKey: .composedAssetModelId)
            request.encodeHeader(self.ifMatch, key: "If-Match")
            request.encodeHeader(self.ifNoneMatch, key: "If-None-Match")
            request.encodeHeader(self.matchForVersionType, key: "Match-For-Version-Type")
            try container.encodeIfPresent(self.parentAssetModelCompositeModelId, forKey: .parentAssetModelCompositeModelId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 36)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 36)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, max: 256)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelCompositeModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModelProperties[]")
            }
            try self.validate(self.assetModelCompositeModelType, name: "assetModelCompositeModelType", parent: name, max: 256)
            try self.validate(self.assetModelCompositeModelType, name: "assetModelCompositeModelType", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelType, name: "assetModelCompositeModelType", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.composedAssetModelId, name: "composedAssetModelId", parent: name, max: 139)
            try self.validate(self.composedAssetModelId, name: "composedAssetModelId", parent: name, min: 13)
            try self.validate(self.composedAssetModelId, name: "composedAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.ifMatch, name: "ifMatch", parent: name, pattern: "^[\\w-]{43}$")
            try self.validate(self.ifNoneMatch, name: "ifNoneMatch", parent: name, pattern: "^\\*$")
            try self.validate(self.parentAssetModelCompositeModelId, name: "parentAssetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.parentAssetModelCompositeModelId, name: "parentAssetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.parentAssetModelCompositeModelId, name: "parentAssetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelDescription = "assetModelCompositeModelDescription"
            case assetModelCompositeModelExternalId = "assetModelCompositeModelExternalId"
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelName = "assetModelCompositeModelName"
            case assetModelCompositeModelProperties = "assetModelCompositeModelProperties"
            case assetModelCompositeModelType = "assetModelCompositeModelType"
            case clientToken = "clientToken"
            case composedAssetModelId = "composedAssetModelId"
            case parentAssetModelCompositeModelId = "parentAssetModelCompositeModelId"
        }
    }

    public struct CreateAssetModelCompositeModelResponse: AWSDecodableShape {
        /// The ID of the composed asset model. You can use this ID when you call other IoT SiteWise APIs.
        public let assetModelCompositeModelId: String
        /// The path to the composite model listing the parent composite models.
        public let assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment]
        public let assetModelStatus: AssetModelStatus

        @inlinable
        public init(assetModelCompositeModelId: String, assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment], assetModelStatus: AssetModelStatus) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelPath = assetModelCompositeModelPath
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelPath = "assetModelCompositeModelPath"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct CreateAssetModelRequest: AWSEncodableShape {
        /// The composite models that are part of this asset model. It groups properties (such as attributes, measurements, transforms, and metrics) and child composite models that model parts of your industrial equipment. Each composite model has a type that defines the properties that the composite model supports. Use composite models to define alarms on this asset model.  When creating custom composite models, you need to use CreateAssetModelCompositeModel. For more information, see Creating custom composite models (Components) in the IoT SiteWise User Guide.
        public let assetModelCompositeModels: [AssetModelCompositeModelDefinition]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// An external ID to assign to the asset model. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetModelExternalId: String?
        /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
        /// The ID to assign to the asset model, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let assetModelId: String?
        /// A unique name for the asset model.
        public let assetModelName: String
        /// The property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelPropertyDefinition]?
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelType: AssetModelType?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset model. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(assetModelCompositeModels: [AssetModelCompositeModelDefinition]? = nil, assetModelDescription: String? = nil, assetModelExternalId: String? = nil, assetModelHierarchies: [AssetModelHierarchyDefinition]? = nil, assetModelId: String? = nil, assetModelName: String, assetModelProperties: [AssetModelPropertyDefinition]? = nil, assetModelType: AssetModelType? = nil, clientToken: String? = CreateAssetModelRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelExternalId = assetModelExternalId
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelType = assetModelType
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels = "assetModelCompositeModels"
            case assetModelDescription = "assetModelDescription"
            case assetModelExternalId = "assetModelExternalId"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelId = "assetModelId"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case assetModelType = "assetModelType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The ID of the asset model, in UUID format. You can use this ID when you call other IoT SiteWise API operations.
        public let assetModelId: String
        /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        @inlinable
        public init(assetModelArn: String, assetModelId: String, assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelId = assetModelId
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn = "assetModelArn"
            case assetModelId = "assetModelId"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {
        /// A description for the asset.
        public let assetDescription: String?
        /// An external ID to assign to the asset. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetExternalId: String?
        /// The ID to assign to the asset, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let assetId: String?
        /// The ID of the asset model from which to create the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// A friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(assetDescription: String? = nil, assetExternalId: String? = nil, assetId: String? = nil, assetModelId: String, assetName: String, clientToken: String? = CreateAssetRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetDescription = assetDescription
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, max: 2048)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, min: 1)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, max: 128)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, min: 2)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetDescription = "assetDescription"
            case assetExternalId = "assetExternalId"
            case assetId = "assetId"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The ID of the asset, in UUID format. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise API operations.
        public let assetId: String
        /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        @inlinable
        public init(assetArn: String, assetId: String, assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetId = assetId
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn = "assetArn"
            case assetId = "assetId"
            case assetStatus = "assetStatus"
        }
    }

    public struct CreateBulkImportJobRequest: AWSEncodableShape {
        /// If set to true, ingest new data into IoT SiteWise storage. Measurements with notifications, metrics and transforms are  computed. If set to false, historical data is ingested into IoT SiteWise as is.
        public let adaptiveIngestion: Bool?
        /// If set to true, your data files is deleted from S3, after ingestion into IoT SiteWise storage.
        public let deleteFilesAfterImport: Bool?
        /// The Amazon S3 destination where errors associated with the job creation request are saved.
        public let errorReportLocation: ErrorReportLocation
        /// The files in the specified Amazon S3 bucket that contain your data.
        public let files: [File]
        /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
        public let jobConfiguration: JobConfiguration
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The ARN of the IAM role that allows IoT SiteWise to read Amazon S3 data.
        public let jobRoleArn: String

        @inlinable
        public init(adaptiveIngestion: Bool? = nil, deleteFilesAfterImport: Bool? = nil, errorReportLocation: ErrorReportLocation, files: [File], jobConfiguration: JobConfiguration, jobName: String, jobRoleArn: String) {
            self.adaptiveIngestion = adaptiveIngestion
            self.deleteFilesAfterImport = deleteFilesAfterImport
            self.errorReportLocation = errorReportLocation
            self.files = files
            self.jobConfiguration = jobConfiguration
            self.jobName = jobName
            self.jobRoleArn = jobRoleArn
        }

        public func validate(name: String) throws {
            try self.errorReportLocation.validate(name: "\(name).errorReportLocation")
            try self.files.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, max: 1600)
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, min: 1)
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case adaptiveIngestion = "adaptiveIngestion"
            case deleteFilesAfterImport = "deleteFilesAfterImport"
            case errorReportLocation = "errorReportLocation"
            case files = "files"
            case jobConfiguration = "jobConfiguration"
            case jobName = "jobName"
            case jobRoleArn = "jobRoleArn"
        }
    }

    public struct CreateBulkImportJobResponse: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The status of the bulk import job can be one of following values:    PENDING – IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED – The bulk import job has been canceled.    RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let jobStatus: JobStatus

        @inlinable
        public init(jobId: String, jobName: String, jobStatus: JobStatus) {
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case jobName = "jobName"
            case jobStatus = "jobStatus"
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The dashboard definition specified in a JSON literal.   IoT SiteWise Monitor (Classic) see Create dashboards (CLI)    IoT SiteWise Monitor (AI-aware) see Create dashboards (CLI)    in the IoT SiteWise User Guide
        public let dashboardDefinition: String
        /// A description for the dashboard.
        public let dashboardDescription: String?
        /// A friendly name for the dashboard.
        public let dashboardName: String
        /// The ID of the project in which to create the dashboard.
        public let projectId: String
        /// A list of key-value pairs that contain metadata for the dashboard. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardName: String, projectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardName = dashboardName
            self.projectId = projectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: "^.+$")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardName = "dashboardName"
            case projectId = "projectId"
            case tags = "tags"
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The ID of the dashboard.
        public let dashboardId: String

        @inlinable
        public init(dashboardArn: String, dashboardId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "dashboardArn"
            case dashboardId = "dashboardId"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A description about the dataset, and its functionality.
        public let datasetDescription: String?
        /// The ID of the dataset.
        public let datasetId: String?
        /// The name of the dataset.
        public let datasetName: String
        /// The data source for the dataset.
        public let datasetSource: DatasetSource
        /// A list of key-value pairs that contain metadata for the access policy. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDatasetRequest.idempotencyToken(), datasetDescription: String? = nil, datasetId: String? = nil, datasetName: String, datasetSource: DatasetSource, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetName = datasetName
            self.datasetSource = datasetSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, max: 2048)
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, min: 1)
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, pattern: "^[a-zA-Z0-9 _\\-#$*!@]+$")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 36)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 36)
            try self.validate(self.datasetId, name: "datasetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 256)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.datasetName, name: "datasetName", parent: name, pattern: "^[a-zA-Z0-9 _\\-#$*!@]+$")
            try self.datasetSource.validate(name: "\(name).datasetSource")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case datasetDescription = "datasetDescription"
            case datasetId = "datasetId"
            case datasetName = "datasetName"
            case datasetSource = "datasetSource"
            case tags = "tags"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The ARN of the dataset.  The format is arn:${Partition}:iotsitewise:${Region}:${Account}:dataset/${DatasetId}.
        public let datasetArn: String
        /// The ID of the dataset.
        public let datasetId: String
        /// The status of the dataset. This contains the state and any error messages.  State is CREATING after a successfull call to this API, and any associated error message. The state is  ACTIVE when ready to use.
        public let datasetStatus: DatasetStatus

        @inlinable
        public init(datasetArn: String, datasetId: String, datasetStatus: DatasetStatus) {
            self.datasetArn = datasetArn
            self.datasetId = datasetId
            self.datasetStatus = datasetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case datasetId = "datasetId"
            case datasetStatus = "datasetStatus"
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// A unique name for the gateway.
        public let gatewayName: String
        /// The gateway's platform. You can only specify one platform in a gateway.
        public let gatewayPlatform: GatewayPlatform
        /// The version of the gateway to create. Specify 3 to create an MQTT-enabled, V3 gateway and 2 To create a Classic streams, V2 gateway. If the version isn't specified, a Classic streams, V2 gateway is created by default. We recommend creating an MQTT-enabled, V3 gateway for self-hosted gateways. SiteWise Edge gateways on Siemens Industrial Edge should use gateway version 2. For more information on gateway versions, see  Self-host a SiteWise Edge gateway with IoT Greengrass V2.
        public let gatewayVersion: String?
        /// A list of key-value pairs that contain metadata for the gateway. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(gatewayName: String, gatewayPlatform: GatewayPlatform, gatewayVersion: String? = nil, tags: [String: String]? = nil) {
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.gatewayVersion = gatewayVersion
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.gatewayPlatform.validate(name: "\(name).gatewayPlatform")
            try self.validate(self.gatewayVersion, name: "gatewayVersion", parent: name, max: 1024)
            try self.validate(self.gatewayVersion, name: "gatewayVersion", parent: name, min: 1)
            try self.validate(self.gatewayVersion, name: "gatewayVersion", parent: name, pattern: "^[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case gatewayVersion = "gatewayVersion"
            case tags = "tags"
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise API operations.
        public let gatewayId: String

        @inlinable
        public init(gatewayArn: String, gatewayId: String) {
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.  If you use the IoT Events managed Lambda function to manage your emails, you must verify the sender email address in Amazon SES.
        public let notificationSenderEmail: String?
        /// The service to use to authenticate users to the portal. Choose from the following options:    SSO – The portal uses IAM Identity Center to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see Enabling IAM Identity Center in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.    IAM – The portal uses Identity and Access Management to authenticate users and manage user permissions.   You can't change this value after you create a portal. Default: SSO
        public let portalAuthMode: AuthMode?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A description for the portal.
        public let portalDescription: String?
        /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
        public let portalLogoImageFile: ImageFile?
        /// A friendly name for the portal.
        public let portalName: String
        /// Define the type of portal. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalType: PortalType?
        /// The configuration entry associated with the specific portal type. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalTypeConfiguration: [String: PortalTypeEntry]?
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String
        /// A list of key-value pairs that contain metadata for the portal. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(alarms: Alarms? = nil, clientToken: String? = CreatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalAuthMode: AuthMode? = nil, portalContactEmail: String, portalDescription: String? = nil, portalLogoImageFile: ImageFile? = nil, portalName: String, portalType: PortalType? = nil, portalTypeConfiguration: [String: PortalTypeEntry]? = nil, roleArn: String, tags: [String: String]? = nil) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalAuthMode = portalAuthMode
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalLogoImageFile = portalLogoImageFile
            self.portalName = portalName
            self.portalType = portalType
            self.portalTypeConfiguration = portalTypeConfiguration
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "^[a-zA-Z0-9_\\-\\.\\+]+@[a-zA-Z0-9_\\-\\.\\+]+\\.[a-zA-Z]{2,}$")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "^[a-zA-Z0-9_\\-\\.\\+]+@[a-zA-Z0-9_\\-\\.\\+]+\\.[a-zA-Z]{2,}$")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.portalLogoImageFile?.validate(name: "\(name).portalLogoImageFile")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.portalTypeConfiguration?.forEach {
                try validate($0.key, name: "portalTypeConfiguration.key", parent: name, max: 128)
                try validate($0.key, name: "portalTypeConfiguration.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).portalTypeConfiguration[\"\($0.key)\"]")
            }
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.\\+=,@]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "alarms"
            case clientToken = "clientToken"
            case notificationSenderEmail = "notificationSenderEmail"
            case portalAuthMode = "portalAuthMode"
            case portalContactEmail = "portalContactEmail"
            case portalDescription = "portalDescription"
            case portalLogoImageFile = "portalLogoImageFile"
            case portalName = "portalName"
            case portalType = "portalType"
            case portalTypeConfiguration = "portalTypeConfiguration"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The ID of the created portal.
        public let portalId: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus
        /// The associated IAM Identity Center application ID, if the portal uses IAM Identity Center.
        public let ssoApplicationId: String

        @inlinable
        public init(portalArn: String, portalId: String, portalStartUrl: String, portalStatus: PortalStatus, ssoApplicationId: String) {
            self.portalArn = portalArn
            self.portalId = portalId
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.ssoApplicationId = ssoApplicationId
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case portalId = "portalId"
            case portalStartUrl = "portalStartUrl"
            case portalStatus = "portalStatus"
            case ssoApplicationId = "ssoApplicationId"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal in which to create the project.
        public let portalId: String
        /// A description for the project.
        public let projectDescription: String?
        /// A friendly name for the project.
        public let projectName: String
        /// A list of key-value pairs that contain metadata for the project. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), portalId: String, projectDescription: String? = nil, projectName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.portalId = portalId
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case portalId = "portalId"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case tags = "tags"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The ID of the project.
        public let projectId: String

        @inlinable
        public init(projectArn: String, projectId: String) {
            self.projectArn = projectArn
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectId = "projectId"
        }
    }

    public struct Csv: AWSEncodableShape & AWSDecodableShape {
        /// The column names specified in the .csv file.
        public let columnNames: [ColumnName]

        @inlinable
        public init(columnNames: [ColumnName]) {
            self.columnNames = columnNames
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "columnNames"
        }
    }

    public struct CustomerManagedS3Storage: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        public let roleArn: String
        /// The ARN of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see Amazon S3 resources in the Amazon Simple Storage Service User Guide.
        public let s3ResourceArn: String

        @inlinable
        public init(roleArn: String, s3ResourceArn: String) {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, max: 1600)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, min: 1)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case s3ResourceArn = "s3ResourceArn"
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The date the dashboard was created, in Unix epoch time.
        public let creationDate: Date?
        /// The dashboard's description.
        public let description: String?
        /// The ID of the dashboard.
        public let id: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the dashboard
        public let name: String

        @inlinable
        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
        }
    }

    public struct DataSetReference: AWSDecodableShape {
        /// The ARN of the dataset.  The format is arn:${Partition}:iotsitewise:${Region}:${Account}:dataset/${DatasetId}.
        public let datasetArn: String?
        /// The data source for the dataset.
        public let source: Source?

        @inlinable
        public init(datasetArn: String? = nil, source: Source? = nil) {
            self.datasetArn = datasetArn
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case source = "source"
        }
    }

    public struct DatasetSource: AWSEncodableShape & AWSDecodableShape {
        /// The details of the dataset source associated with the dataset.
        public let sourceDetail: SourceDetail?
        /// The format of the dataset source associated with the dataset.
        public let sourceFormat: DatasetSourceFormat
        /// The type of data source for the dataset.
        public let sourceType: DatasetSourceType

        @inlinable
        public init(sourceDetail: SourceDetail? = nil, sourceFormat: DatasetSourceFormat, sourceType: DatasetSourceType) {
            self.sourceDetail = sourceDetail
            self.sourceFormat = sourceFormat
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.sourceDetail?.validate(name: "\(name).sourceDetail")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDetail = "sourceDetail"
            case sourceFormat = "sourceFormat"
            case sourceType = "sourceType"
        }
    }

    public struct DatasetStatus: AWSDecodableShape {
        public let error: ErrorDetails?
        /// The current status of the dataset.
        public let state: DatasetState

        @inlinable
        public init(error: ErrorDetails? = nil, state: DatasetState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct DatasetSummary: AWSDecodableShape {
        /// The ARN of the dataset.  The format is arn:${Partition}:iotsitewise:${Region}:${Account}:dataset/${DatasetId}.
        public let arn: String
        /// The dataset creation date, in Unix epoch time.
        public let creationDate: Date
        /// A description about the dataset, and its functionality.
        public let description: String
        /// The ID of the dataset.
        public let id: String
        /// The date the dataset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the dataset.
        public let name: String
        /// The status of the dataset. This contains the state and any error messages. The state is  ACTIVE when ready to use.
        public let status: DatasetStatus

        @inlinable
        public init(arn: String, creationDate: Date, description: String, id: String, lastUpdateDate: Date, name: String, status: DatasetStatus) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct Datum: AWSDecodableShape {
        /// Indicates if the data point is an array.
        public let arrayValue: [Datum]?
        /// Indicates if the data point is null.
        public let nullValue: Bool?
        /// Indicates if the data point is a row.
        public let rowValue: Row?
        /// Indicates if the data point is a scalar value such as integer, string, double, or Boolean.
        public let scalarValue: String?

        @inlinable
        public init(arrayValue: [Datum]? = nil, nullValue: Bool? = nil, rowValue: Row? = nil, scalarValue: String? = nil) {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
        }

        private enum CodingKeys: String, CodingKey {
            case arrayValue = "arrayValue"
            case nullValue = "nullValue"
            case rowValue = "rowValue"
            case scalarValue = "scalarValue"
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        /// The ID of the access policy to be deleted.
        public let accessPolicyId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        @inlinable
        public init(accessPolicyId: String, clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPolicyId, key: "accessPolicyId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssetModelCompositeModelRequest: AWSEncodableShape {
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType).    The delete request is rejected if the tag does not match the latest or active version's current entity tag. See Optimistic locking for asset model writes in the IoT SiteWise User Guide.
        public let ifMatch: String?
        /// Accepts * to reject the delete request if an active version  (specified using matchForVersionType as ACTIVE) already exists for the asset model.
        public let ifNoneMatch: String?
        /// Specifies the asset model version type (LATEST or ACTIVE) used in  conjunction with If-Match or If-None-Match headers to determine the target ETag for the delete operation.
        public let matchForVersionType: AssetModelVersionType?

        @inlinable
        public init(assetModelCompositeModelId: String, assetModelId: String, clientToken: String? = DeleteAssetModelCompositeModelRequest.idempotencyToken(), ifMatch: String? = nil, ifNoneMatch: String? = nil, matchForVersionType: AssetModelVersionType? = nil) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelId = assetModelId
            self.clientToken = clientToken
            self.ifMatch = ifMatch
            self.ifNoneMatch = ifNoneMatch
            self.matchForVersionType = matchForVersionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelCompositeModelId, key: "assetModelCompositeModelId")
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeHeader(self.ifMatch, key: "If-Match")
            request.encodeHeader(self.ifNoneMatch, key: "If-None-Match")
            request.encodeHeader(self.matchForVersionType, key: "Match-For-Version-Type")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.ifMatch, name: "ifMatch", parent: name, pattern: "^[\\w-]{43}$")
            try self.validate(self.ifNoneMatch, name: "ifNoneMatch", parent: name, pattern: "^\\*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelCompositeModelResponse: AWSDecodableShape {
        public let assetModelStatus: AssetModelStatus

        @inlinable
        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct DeleteAssetModelRequest: AWSEncodableShape {
        /// The ID of the asset model to delete. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType).    The delete request is rejected if the tag does not match the latest or active version's current entity tag. See Optimistic locking for asset model writes in the IoT SiteWise User Guide.
        public let ifMatch: String?
        /// Accepts * to reject the delete request if an active version  (specified using matchForVersionType as ACTIVE) already exists for the asset model.
        public let ifNoneMatch: String?
        /// Specifies the asset model version type (LATEST or ACTIVE) used in  conjunction with If-Match or If-None-Match headers to determine the target ETag for the delete operation.
        public let matchForVersionType: AssetModelVersionType?

        @inlinable
        public init(assetModelId: String, clientToken: String? = DeleteAssetModelRequest.idempotencyToken(), ifMatch: String? = nil, ifNoneMatch: String? = nil, matchForVersionType: AssetModelVersionType? = nil) {
            self.assetModelId = assetModelId
            self.clientToken = clientToken
            self.ifMatch = ifMatch
            self.ifNoneMatch = ifNoneMatch
            self.matchForVersionType = matchForVersionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeHeader(self.ifMatch, key: "If-Match")
            request.encodeHeader(self.ifNoneMatch, key: "If-None-Match")
            request.encodeHeader(self.matchForVersionType, key: "Match-For-Version-Type")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.ifMatch, name: "ifMatch", parent: name, pattern: "^[\\w-]{43}$")
            try self.validate(self.ifNoneMatch, name: "ifNoneMatch", parent: name, pattern: "^\\*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        @inlinable
        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        /// The ID of the asset to delete. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        @inlinable
        public init(assetId: String, clientToken: String? = DeleteAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        @inlinable
        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus = "assetStatus"
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the dashboard to delete.
        public let dashboardId: String

        @inlinable
        public init(clientToken: String? = DeleteDashboardRequest.idempotencyToken(), dashboardId: String) {
            self.clientToken = clientToken
            self.dashboardId = dashboardId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.dashboardId, key: "dashboardId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the dataset.
        public let datasetId: String

        @inlinable
        public init(clientToken: String? = DeleteDatasetRequest.idempotencyToken(), datasetId: String) {
            self.clientToken = clientToken
            self.datasetId = datasetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.datasetId, key: "datasetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 139)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 13)
            try self.validate(self.datasetId, name: "datasetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatasetResponse: AWSDecodableShape {
        /// The status of the dataset. This contains the state and any error messages.  State is DELETING after a successfull call to this API, and any associated error message.
        public let datasetStatus: DatasetStatus

        @inlinable
        public init(datasetStatus: DatasetStatus) {
            self.datasetStatus = datasetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datasetStatus = "datasetStatus"
        }
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        /// The ID of the gateway to delete.
        public let gatewayId: String

        @inlinable
        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal to delete.
        public let portalId: String

        @inlinable
        public init(clientToken: String? = DeletePortalRequest.idempotencyToken(), portalId: String) {
            self.clientToken = clientToken
            self.portalId = portalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.portalId, key: "portalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        @inlinable
        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus = "portalStatus"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project.
        public let projectId: String

        @inlinable
        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectId: String) {
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTimeSeriesRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String?

        @inlinable
        public init(alias: String? = nil, assetId: String? = nil, clientToken: String? = DeleteTimeSeriesRequest.idempotencyToken(), propertyId: String? = nil) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct DescribeAccessPolicyRequest: AWSEncodableShape {
        /// The ID of the access policy.
        public let accessPolicyId: String

        @inlinable
        public init(accessPolicyId: String) {
            self.accessPolicyId = accessPolicyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPolicyId, key: "accessPolicyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The date the access policy was created, in Unix epoch time.
        public let accessPolicyCreationDate: Date
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity (IAM Identity Center user, IAM Identity Center group, or IAM user) to which this access policy applies.
        public let accessPolicyIdentity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let accessPolicyLastUpdateDate: Date
        /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
        public let accessPolicyResource: Resource

        @inlinable
        public init(accessPolicyArn: String, accessPolicyCreationDate: Date, accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyLastUpdateDate: Date, accessPolicyPermission: Permission, accessPolicyResource: Resource) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyCreationDate = accessPolicyCreationDate
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn = "accessPolicyArn"
            case accessPolicyCreationDate = "accessPolicyCreationDate"
            case accessPolicyId = "accessPolicyId"
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyLastUpdateDate = "accessPolicyLastUpdateDate"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
        }
    }

    public struct DescribeActionRequest: AWSEncodableShape {
        /// The ID of the action.
        public let actionId: String

        @inlinable
        public init(actionId: String) {
            self.actionId = actionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionId, key: "actionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionId, name: "actionId", parent: name, max: 36)
            try self.validate(self.actionId, name: "actionId", parent: name, min: 36)
            try self.validate(self.actionId, name: "actionId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeActionResponse: AWSDecodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String
        /// The ID of the action.
        public let actionId: String
        /// The JSON payload of the action.
        public let actionPayload: ActionPayload
        /// The time the action was executed.
        public let executionTime: Date
        /// The resource the action will be taken on.
        public let targetResource: TargetResource

        @inlinable
        public init(actionDefinitionId: String, actionId: String, actionPayload: ActionPayload, executionTime: Date, targetResource: TargetResource) {
            self.actionDefinitionId = actionDefinitionId
            self.actionId = actionId
            self.actionPayload = actionPayload
            self.executionTime = executionTime
            self.targetResource = targetResource
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionId = "actionId"
            case actionPayload = "actionPayload"
            case executionTime = "executionTime"
            case targetResource = "targetResource"
        }
    }

    public struct DescribeAssetCompositeModelRequest: AWSEncodableShape {
        /// The ID of a composite model on this asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetCompositeModelId: String
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String

        @inlinable
        public init(assetCompositeModelId: String, assetId: String) {
            self.assetCompositeModelId = assetCompositeModelId
            self.assetId = assetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetCompositeModelId, key: "assetCompositeModelId")
            request.encodePath(self.assetId, key: "assetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetCompositeModelId, name: "assetCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetCompositeModelId, name: "assetCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetCompositeModelId, name: "assetCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetCompositeModelResponse: AWSDecodableShape {
        /// The available actions for a composite model on this asset.
        public let actionDefinitions: [ActionDefinition]?
        /// A description for the composite model.
        public let assetCompositeModelDescription: String
        /// An external ID to assign to the asset model. If the composite model is a component-based composite model, or one nested inside a component model, you can only set the external ID using UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public let assetCompositeModelExternalId: String?
        /// The ID of a composite model on this asset.
        public let assetCompositeModelId: String
        /// The unique, friendly name for the composite model.
        public let assetCompositeModelName: String
        /// The path to the composite model listing the parent composite models.
        public let assetCompositeModelPath: [AssetCompositeModelPathSegment]
        /// The property definitions of the composite model that was used to create the asset.
        public let assetCompositeModelProperties: [AssetProperty]
        /// The list of composite model summaries.
        public let assetCompositeModelSummaries: [AssetCompositeModelSummary]
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or AWS/L4E_ANOMALY.
        public let assetCompositeModelType: String
        /// The ID of the asset, in UUID format. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
        public let assetId: String

        @inlinable
        public init(actionDefinitions: [ActionDefinition]? = nil, assetCompositeModelDescription: String, assetCompositeModelExternalId: String? = nil, assetCompositeModelId: String, assetCompositeModelName: String, assetCompositeModelPath: [AssetCompositeModelPathSegment], assetCompositeModelProperties: [AssetProperty], assetCompositeModelSummaries: [AssetCompositeModelSummary], assetCompositeModelType: String, assetId: String) {
            self.actionDefinitions = actionDefinitions
            self.assetCompositeModelDescription = assetCompositeModelDescription
            self.assetCompositeModelExternalId = assetCompositeModelExternalId
            self.assetCompositeModelId = assetCompositeModelId
            self.assetCompositeModelName = assetCompositeModelName
            self.assetCompositeModelPath = assetCompositeModelPath
            self.assetCompositeModelProperties = assetCompositeModelProperties
            self.assetCompositeModelSummaries = assetCompositeModelSummaries
            self.assetCompositeModelType = assetCompositeModelType
            self.assetId = assetId
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitions = "actionDefinitions"
            case assetCompositeModelDescription = "assetCompositeModelDescription"
            case assetCompositeModelExternalId = "assetCompositeModelExternalId"
            case assetCompositeModelId = "assetCompositeModelId"
            case assetCompositeModelName = "assetCompositeModelName"
            case assetCompositeModelPath = "assetCompositeModelPath"
            case assetCompositeModelProperties = "assetCompositeModelProperties"
            case assetCompositeModelSummaries = "assetCompositeModelSummaries"
            case assetCompositeModelType = "assetCompositeModelType"
            case assetId = "assetId"
        }
    }

    public struct DescribeAssetModelCompositeModelRequest: AWSEncodableShape {
        /// The ID of a composite model on this asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelCompositeModelId: String
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The version alias that specifies the latest or active version of the asset model.  The details are returned in the response. The default value is LATEST. See  Asset model versions in the IoT SiteWise User Guide.
        public let assetModelVersion: String?

        @inlinable
        public init(assetModelCompositeModelId: String, assetModelId: String, assetModelVersion: String? = nil) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelId = assetModelId
            self.assetModelVersion = assetModelVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelCompositeModelId, key: "assetModelCompositeModelId")
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.assetModelVersion, key: "assetModelVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelVersion, name: "assetModelVersion", parent: name, pattern: "^(LATEST|ACTIVE)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelCompositeModelResponse: AWSDecodableShape {
        /// The available actions for a composite model on this asset model.
        public let actionDefinitions: [ActionDefinition]?
        /// The description for the composite model.
        public let assetModelCompositeModelDescription: String
        /// The external ID of a composite model on this asset model.
        public let assetModelCompositeModelExternalId: String?
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// The unique, friendly name for the composite model.
        public let assetModelCompositeModelName: String
        /// The path to the composite model listing the parent composite models.
        public let assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment]
        /// The property definitions of the composite model.
        public let assetModelCompositeModelProperties: [AssetModelProperty]
        /// The list of composite model summaries for the composite model.
        public let assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or AWS/L4E_ANOMALY.
        public let assetModelCompositeModelType: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// Metadata for the composition relationship established by using composedAssetModelId in  CreateAssetModelCompositeModel . For instance, an array detailing the path of the composition relationship for this composite model.
        public let compositionDetails: CompositionDetails?

        @inlinable
        public init(actionDefinitions: [ActionDefinition]? = nil, assetModelCompositeModelDescription: String, assetModelCompositeModelExternalId: String? = nil, assetModelCompositeModelId: String, assetModelCompositeModelName: String, assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment], assetModelCompositeModelProperties: [AssetModelProperty], assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary], assetModelCompositeModelType: String, assetModelId: String, compositionDetails: CompositionDetails? = nil) {
            self.actionDefinitions = actionDefinitions
            self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
            self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelName = assetModelCompositeModelName
            self.assetModelCompositeModelPath = assetModelCompositeModelPath
            self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
            self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
            self.compositionDetails = compositionDetails
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitions = "actionDefinitions"
            case assetModelCompositeModelDescription = "assetModelCompositeModelDescription"
            case assetModelCompositeModelExternalId = "assetModelCompositeModelExternalId"
            case assetModelCompositeModelId = "assetModelCompositeModelId"
            case assetModelCompositeModelName = "assetModelCompositeModelName"
            case assetModelCompositeModelPath = "assetModelCompositeModelPath"
            case assetModelCompositeModelProperties = "assetModelCompositeModelProperties"
            case assetModelCompositeModelSummaries = "assetModelCompositeModelSummaries"
            case assetModelCompositeModelType = "assetModelCompositeModelType"
            case assetModelId = "assetModelId"
            case compositionDetails = "compositionDetails"
        }
    }

    public struct DescribeAssetModelRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The version alias that specifies the latest or active version of the asset model.  The details are returned in the response. The default value is LATEST. See  Asset model versions in the IoT SiteWise User Guide.
        public let assetModelVersion: String?
        ///  Whether or not to exclude asset model properties from the response.
        public let excludeProperties: Bool?

        @inlinable
        public init(assetModelId: String, assetModelVersion: String? = nil, excludeProperties: Bool? = nil) {
            self.assetModelId = assetModelId
            self.assetModelVersion = assetModelVersion
            self.excludeProperties = excludeProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.assetModelVersion, key: "assetModelVersion")
            request.encodeQuery(self.excludeProperties, key: "excludeProperties")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelVersion, name: "assetModelVersion", parent: name, pattern: "^(LATEST|ACTIVE)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The list of built-in composite models for the asset model, such as those with those of type AWS/ALARMS.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// The list of the immediate child custom composite model summaries for the asset model.
        public let assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]?
        /// The date the asset model was created, in Unix epoch time.
        public let assetModelCreationDate: Date
        /// The asset model's description.
        public let assetModelDescription: String
        /// The external ID of the asset model, if any.
        public let assetModelExternalId: String?
        /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
        public let assetModelHierarchies: [AssetModelHierarchy]
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let assetModelLastUpdateDate: Date
        /// The name of the asset model.
        public let assetModelName: String
        /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
        public let assetModelProperties: [AssetModelProperty]
        /// The current status of the asset model, which contains a state and any error message.
        public let assetModelStatus: AssetModelStatus
        /// The type of asset model.    ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelType: AssetModelType?
        /// The version of the asset model. See  Asset model versions in the IoT SiteWise User Guide.
        public let assetModelVersion: String?
        /// The entity tag (ETag) is a hash of the retrieved version of the asset model. It's used to make concurrent updates safely to the resource. See Optimistic locking for asset model writes in the IoT SiteWise User Guide.  See  Optimistic locking for asset model writes in the IoT SiteWise User Guide.
        public let eTag: String?

        @inlinable
        public init(assetModelArn: String, assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]? = nil, assetModelCreationDate: Date, assetModelDescription: String, assetModelExternalId: String? = nil, assetModelHierarchies: [AssetModelHierarchy], assetModelId: String, assetModelLastUpdateDate: Date, assetModelName: String, assetModelProperties: [AssetModelProperty], assetModelStatus: AssetModelStatus, assetModelType: AssetModelType? = nil, assetModelVersion: String? = nil, eTag: String? = nil) {
            self.assetModelArn = assetModelArn
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
            self.assetModelCreationDate = assetModelCreationDate
            self.assetModelDescription = assetModelDescription
            self.assetModelExternalId = assetModelExternalId
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelLastUpdateDate = assetModelLastUpdateDate
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelStatus = assetModelStatus
            self.assetModelType = assetModelType
            self.assetModelVersion = assetModelVersion
            self.eTag = eTag
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.assetModelArn = try container.decode(String.self, forKey: .assetModelArn)
            self.assetModelCompositeModels = try container.decodeIfPresent([AssetModelCompositeModel].self, forKey: .assetModelCompositeModels)
            self.assetModelCompositeModelSummaries = try container.decodeIfPresent([AssetModelCompositeModelSummary].self, forKey: .assetModelCompositeModelSummaries)
            self.assetModelCreationDate = try container.decode(Date.self, forKey: .assetModelCreationDate)
            self.assetModelDescription = try container.decode(String.self, forKey: .assetModelDescription)
            self.assetModelExternalId = try container.decodeIfPresent(String.self, forKey: .assetModelExternalId)
            self.assetModelHierarchies = try container.decode([AssetModelHierarchy].self, forKey: .assetModelHierarchies)
            self.assetModelId = try container.decode(String.self, forKey: .assetModelId)
            self.assetModelLastUpdateDate = try container.decode(Date.self, forKey: .assetModelLastUpdateDate)
            self.assetModelName = try container.decode(String.self, forKey: .assetModelName)
            self.assetModelProperties = try container.decode([AssetModelProperty].self, forKey: .assetModelProperties)
            self.assetModelStatus = try container.decode(AssetModelStatus.self, forKey: .assetModelStatus)
            self.assetModelType = try container.decodeIfPresent(AssetModelType.self, forKey: .assetModelType)
            self.assetModelVersion = try container.decodeIfPresent(String.self, forKey: .assetModelVersion)
            self.eTag = try response.decodeHeaderIfPresent(String.self, key: "ETag")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn = "assetModelArn"
            case assetModelCompositeModels = "assetModelCompositeModels"
            case assetModelCompositeModelSummaries = "assetModelCompositeModelSummaries"
            case assetModelCreationDate = "assetModelCreationDate"
            case assetModelDescription = "assetModelDescription"
            case assetModelExternalId = "assetModelExternalId"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelId = "assetModelId"
            case assetModelLastUpdateDate = "assetModelLastUpdateDate"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case assetModelStatus = "assetModelStatus"
            case assetModelType = "assetModelType"
            case assetModelVersion = "assetModelVersion"
        }
    }

    public struct DescribeAssetPropertyRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String

        @inlinable
        public init(assetId: String, propertyId: String) {
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodePath(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetPropertyResponse: AWSDecodableShape {
        /// The external ID of the asset. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetExternalId: String?
        /// The ID of the asset, in UUID format.
        public let assetId: String
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
        public let assetProperty: Property?
        /// The composite model that declares this asset property, if this asset property exists in a composite model.
        public let compositeModel: CompositeModelProperty?

        @inlinable
        public init(assetExternalId: String? = nil, assetId: String, assetModelId: String, assetName: String, assetProperty: Property? = nil, compositeModel: CompositeModelProperty? = nil) {
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperty = assetProperty
            self.compositeModel = compositeModel
        }

        private enum CodingKeys: String, CodingKey {
            case assetExternalId = "assetExternalId"
            case assetId = "assetId"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case assetProperty = "assetProperty"
            case compositeModel = "compositeModel"
        }
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        ///  Whether or not to exclude asset properties from the response.
        public let excludeProperties: Bool?

        @inlinable
        public init(assetId: String, excludeProperties: Bool? = nil) {
            self.assetId = assetId
            self.excludeProperties = excludeProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.excludeProperties, key: "excludeProperties")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The composite models for the asset.
        public let assetCompositeModels: [AssetCompositeModel]?
        /// The list of the immediate child custom composite model summaries for the asset.
        public let assetCompositeModelSummaries: [AssetCompositeModelSummary]?
        /// The date the asset was created, in Unix epoch time.
        public let assetCreationDate: Date
        /// A description for the asset.
        public let assetDescription: String?
        /// The external ID of the asset, if any.
        public let assetExternalId: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let assetHierarchies: [AssetHierarchy]
        /// The ID of the asset, in UUID format.
        public let assetId: String
        /// The date the asset was last updated, in Unix epoch time.
        public let assetLastUpdateDate: Date
        /// The ID of the asset model that was used to create the asset.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
        public let assetProperties: [AssetProperty]
        /// The current status of the asset, which contains a state and any error message.
        public let assetStatus: AssetStatus

        @inlinable
        public init(assetArn: String, assetCompositeModels: [AssetCompositeModel]? = nil, assetCompositeModelSummaries: [AssetCompositeModelSummary]? = nil, assetCreationDate: Date, assetDescription: String? = nil, assetExternalId: String? = nil, assetHierarchies: [AssetHierarchy], assetId: String, assetLastUpdateDate: Date, assetModelId: String, assetName: String, assetProperties: [AssetProperty], assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetCompositeModels = assetCompositeModels
            self.assetCompositeModelSummaries = assetCompositeModelSummaries
            self.assetCreationDate = assetCreationDate
            self.assetDescription = assetDescription
            self.assetExternalId = assetExternalId
            self.assetHierarchies = assetHierarchies
            self.assetId = assetId
            self.assetLastUpdateDate = assetLastUpdateDate
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperties = assetProperties
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn = "assetArn"
            case assetCompositeModels = "assetCompositeModels"
            case assetCompositeModelSummaries = "assetCompositeModelSummaries"
            case assetCreationDate = "assetCreationDate"
            case assetDescription = "assetDescription"
            case assetExternalId = "assetExternalId"
            case assetHierarchies = "assetHierarchies"
            case assetId = "assetId"
            case assetLastUpdateDate = "assetLastUpdateDate"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case assetProperties = "assetProperties"
            case assetStatus = "assetStatus"
        }
    }

    public struct DescribeBulkImportJobRequest: AWSEncodableShape {
        /// The ID of the job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBulkImportJobResponse: AWSDecodableShape {
        /// If set to true, ingest new data into IoT SiteWise storage. Measurements with notifications, metrics and transforms are  computed. If set to false, historical data is ingested into IoT SiteWise as is.
        public let adaptiveIngestion: Bool?
        /// If set to true, your data files is deleted from S3, after ingestion into IoT SiteWise storage.
        public let deleteFilesAfterImport: Bool?
        /// The Amazon S3 destination where errors associated with the job creation request are saved.
        public let errorReportLocation: ErrorReportLocation
        /// The files in the specified Amazon S3 bucket that contain your data.
        public let files: [File]
        /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
        public let jobConfiguration: JobConfiguration
        /// The date the job was created, in Unix epoch TIME.
        public let jobCreationDate: Date
        /// The ID of the job.
        public let jobId: String
        /// The date the job was last updated, in Unix epoch time.
        public let jobLastUpdateDate: Date
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The ARN of the IAM role that allows IoT SiteWise to read Amazon S3 data.
        public let jobRoleArn: String
        /// The status of the bulk import job can be one of following values:    PENDING – IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED – The bulk import job has been canceled.    RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let jobStatus: JobStatus

        @inlinable
        public init(adaptiveIngestion: Bool? = nil, deleteFilesAfterImport: Bool? = nil, errorReportLocation: ErrorReportLocation, files: [File], jobConfiguration: JobConfiguration, jobCreationDate: Date, jobId: String, jobLastUpdateDate: Date, jobName: String, jobRoleArn: String, jobStatus: JobStatus) {
            self.adaptiveIngestion = adaptiveIngestion
            self.deleteFilesAfterImport = deleteFilesAfterImport
            self.errorReportLocation = errorReportLocation
            self.files = files
            self.jobConfiguration = jobConfiguration
            self.jobCreationDate = jobCreationDate
            self.jobId = jobId
            self.jobLastUpdateDate = jobLastUpdateDate
            self.jobName = jobName
            self.jobRoleArn = jobRoleArn
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case adaptiveIngestion = "adaptiveIngestion"
            case deleteFilesAfterImport = "deleteFilesAfterImport"
            case errorReportLocation = "errorReportLocation"
            case files = "files"
            case jobConfiguration = "jobConfiguration"
            case jobCreationDate = "jobCreationDate"
            case jobId = "jobId"
            case jobLastUpdateDate = "jobLastUpdateDate"
            case jobName = "jobName"
            case jobRoleArn = "jobRoleArn"
            case jobStatus = "jobStatus"
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        /// The ID of the dashboard.
        public let dashboardId: String

        @inlinable
        public init(dashboardId: String) {
            self.dashboardId = dashboardId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dashboardId, key: "dashboardId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The date the dashboard was created, in Unix epoch time.
        public let dashboardCreationDate: Date
        /// The dashboard's definition JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// The dashboard's description.
        public let dashboardDescription: String?
        /// The ID of the dashboard.
        public let dashboardId: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let dashboardLastUpdateDate: Date
        /// The name of the dashboard.
        public let dashboardName: String
        /// The ID of the project that the dashboard is in.
        public let projectId: String

        @inlinable
        public init(dashboardArn: String, dashboardCreationDate: Date, dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardLastUpdateDate: Date, dashboardName: String, projectId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardCreationDate = dashboardCreationDate
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardLastUpdateDate = dashboardLastUpdateDate
            self.dashboardName = dashboardName
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "dashboardArn"
            case dashboardCreationDate = "dashboardCreationDate"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardId = "dashboardId"
            case dashboardLastUpdateDate = "dashboardLastUpdateDate"
            case dashboardName = "dashboardName"
            case projectId = "projectId"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The ID of the dataset.
        public let datasetId: String

        @inlinable
        public init(datasetId: String) {
            self.datasetId = datasetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datasetId, key: "datasetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 139)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 13)
            try self.validate(self.datasetId, name: "datasetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// The ARN of the dataset.  The format is arn:${Partition}:iotsitewise:${Region}:${Account}:dataset/${DatasetId}.
        public let datasetArn: String
        /// The dataset creation date, in Unix epoch time.
        public let datasetCreationDate: Date
        /// A description about the dataset, and its functionality.
        public let datasetDescription: String
        /// The ID of the dataset.
        public let datasetId: String
        /// The date the dataset was last updated, in Unix epoch time.
        public let datasetLastUpdateDate: Date
        /// The name of the dataset.
        public let datasetName: String
        /// The data source for the dataset.
        public let datasetSource: DatasetSource
        /// The status of the dataset. This contains the state and any error messages.  State is CREATING after a successfull call to this API, and any associated error message. The state is  ACTIVE when ready to use.
        public let datasetStatus: DatasetStatus
        /// The version of the dataset.
        public let datasetVersion: String?

        @inlinable
        public init(datasetArn: String, datasetCreationDate: Date, datasetDescription: String, datasetId: String, datasetLastUpdateDate: Date, datasetName: String, datasetSource: DatasetSource, datasetStatus: DatasetStatus, datasetVersion: String? = nil) {
            self.datasetArn = datasetArn
            self.datasetCreationDate = datasetCreationDate
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetLastUpdateDate = datasetLastUpdateDate
            self.datasetName = datasetName
            self.datasetSource = datasetSource
            self.datasetStatus = datasetStatus
            self.datasetVersion = datasetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case datasetCreationDate = "datasetCreationDate"
            case datasetDescription = "datasetDescription"
            case datasetId = "datasetId"
            case datasetLastUpdateDate = "datasetLastUpdateDate"
            case datasetName = "datasetName"
            case datasetSource = "datasetSource"
            case datasetStatus = "datasetStatus"
            case datasetVersion = "datasetVersion"
        }
    }

    public struct DescribeDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The key ARN of the customer managed key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct DescribeGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        @inlinable
        public init(capabilityNamespace: String, gatewayId: String) {
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityNamespace, key: "capabilityNamespace")
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The JSON document that defines the gateway capability's configuration. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    NOT_APPLICABLE – Synchronization is not required for this capability configuration. This is most common when integrating partner data sources, because the data integration is handled externally by the partner.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.    UNKNOWN – The synchronization status is currently unknown due to an undetermined or temporary error.
        public let capabilitySyncStatus: CapabilitySyncStatus
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        @inlinable
        public init(capabilityConfiguration: String, capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration = "capabilityConfiguration"
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
            case gatewayId = "gatewayId"
        }
    }

    public struct DescribeGatewayRequest: AWSEncodableShape {
        /// The ID of the gateway device.
        public let gatewayId: String

        @inlinable
        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayResponse: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the gateway.
        public let gatewayName: String
        /// The gateway's platform.
        public let gatewayPlatform: GatewayPlatform?
        /// The version of the gateway. A value of 3 indicates an MQTT-enabled, V3 gateway, while 2 indicates a Classic streams, V2 gateway.
        public let gatewayVersion: String?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        @inlinable
        public init(creationDate: Date, gatewayArn: String, gatewayCapabilitySummaries: [GatewayCapabilitySummary], gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, gatewayVersion: String? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayArn = gatewayArn
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.gatewayVersion = gatewayVersion
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case gatewayArn = "gatewayArn"
            case gatewayCapabilitySummaries = "gatewayCapabilitySummaries"
            case gatewayId = "gatewayId"
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case gatewayVersion = "gatewayVersion"
            case lastUpdateDate = "lastUpdateDate"
        }
    }

    public struct DescribeLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeLoggingOptionsResponse: AWSDecodableShape {
        /// The current logging options.
        public let loggingOptions: LoggingOptions

        @inlinable
        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions = "loggingOptions"
        }
    }

    public struct DescribePortalRequest: AWSEncodableShape {
        /// The ID of the portal.
        public let portalId: String

        @inlinable
        public init(portalId: String) {
            self.portalId = portalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalId, key: "portalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePortalResponse: AWSDecodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
        public let alarms: Alarms?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The service to use to authenticate users to the portal.
        public let portalAuthMode: AuthMode?
        /// The IAM Identity Center application generated client ID (used with IAM Identity Center API operations). IoT SiteWise includes portalClientId for only portals that use IAM Identity Center to authenticate users.
        public let portalClientId: String
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// The date the portal was created, in Unix epoch time.
        public let portalCreationDate: Date
        /// The portal's description.
        public let portalDescription: String?
        /// The ID of the portal.
        public let portalId: String
        /// The date the portal was last updated, in Unix epoch time.
        public let portalLastUpdateDate: Date
        /// The portal's logo image, which is available at a URL.
        public let portalLogoImageLocation: ImageLocation?
        /// The name of the portal.
        public let portalName: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The current status of the portal, which contains a state and any error message.
        public let portalStatus: PortalStatus
        /// Define the type of portal. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalType: PortalType?
        /// The configuration entry associated with the specific portal type. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalTypeConfiguration: [String: PortalTypeEntry]?
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?

        @inlinable
        public init(alarms: Alarms? = nil, notificationSenderEmail: String? = nil, portalArn: String, portalAuthMode: AuthMode? = nil, portalClientId: String, portalContactEmail: String, portalCreationDate: Date, portalDescription: String? = nil, portalId: String, portalLastUpdateDate: Date, portalLogoImageLocation: ImageLocation? = nil, portalName: String, portalStartUrl: String, portalStatus: PortalStatus, portalType: PortalType? = nil, portalTypeConfiguration: [String: PortalTypeEntry]? = nil, roleArn: String? = nil) {
            self.alarms = alarms
            self.notificationSenderEmail = notificationSenderEmail
            self.portalArn = portalArn
            self.portalAuthMode = portalAuthMode
            self.portalClientId = portalClientId
            self.portalContactEmail = portalContactEmail
            self.portalCreationDate = portalCreationDate
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLastUpdateDate = portalLastUpdateDate
            self.portalLogoImageLocation = portalLogoImageLocation
            self.portalName = portalName
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.portalType = portalType
            self.portalTypeConfiguration = portalTypeConfiguration
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "alarms"
            case notificationSenderEmail = "notificationSenderEmail"
            case portalArn = "portalArn"
            case portalAuthMode = "portalAuthMode"
            case portalClientId = "portalClientId"
            case portalContactEmail = "portalContactEmail"
            case portalCreationDate = "portalCreationDate"
            case portalDescription = "portalDescription"
            case portalId = "portalId"
            case portalLastUpdateDate = "portalLastUpdateDate"
            case portalLogoImageLocation = "portalLogoImageLocation"
            case portalName = "portalName"
            case portalStartUrl = "portalStartUrl"
            case portalStatus = "portalStatus"
            case portalType = "portalType"
            case portalTypeConfiguration = "portalTypeConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        /// The ID of the project.
        public let projectId: String

        @inlinable
        public init(projectId: String) {
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The ID of the portal that the project is in.
        public let portalId: String
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The date the project was created, in Unix epoch time.
        public let projectCreationDate: Date
        /// The project's description.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The date the project was last updated, in Unix epoch time.
        public let projectLastUpdateDate: Date
        /// The name of the project.
        public let projectName: String

        @inlinable
        public init(portalId: String, projectArn: String, projectCreationDate: Date, projectDescription: String? = nil, projectId: String, projectLastUpdateDate: Date, projectName: String) {
            self.portalId = portalId
            self.projectArn = projectArn
            self.projectCreationDate = projectCreationDate
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectLastUpdateDate = projectLastUpdateDate
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case portalId = "portalId"
            case projectArn = "projectArn"
            case projectCreationDate = "projectCreationDate"
            case projectDescription = "projectDescription"
            case projectId = "projectId"
            case projectLastUpdateDate = "projectLastUpdateDate"
            case projectName = "projectName"
        }
    }

    public struct DescribeStorageConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Describes the configuration for ingesting NULL and NaN data.  By default the feature is allowed. The feature is disallowed if the value is true.
        public let disallowIngestNullNaN: Bool?
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:    ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// The date the storage configuration was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        /// The number of days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.    MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType
        /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
        public let warmTier: WarmTierState?
        /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
        public let warmTierRetentionPeriod: WarmTierRetentionPeriod?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, disallowIngestNullNaN: Bool? = nil, disassociatedDataStorage: DisassociatedDataStorageState? = nil, lastUpdateDate: Date? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType, warmTier: WarmTierState? = nil, warmTierRetentionPeriod: WarmTierRetentionPeriod? = nil) {
            self.configurationStatus = configurationStatus
            self.disallowIngestNullNaN = disallowIngestNullNaN
            self.disassociatedDataStorage = disassociatedDataStorage
            self.lastUpdateDate = lastUpdateDate
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
            self.warmTier = warmTier
            self.warmTierRetentionPeriod = warmTierRetentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case disallowIngestNullNaN = "disallowIngestNullNaN"
            case disassociatedDataStorage = "disassociatedDataStorage"
            case lastUpdateDate = "lastUpdateDate"
            case multiLayerStorage = "multiLayerStorage"
            case retentionPeriod = "retentionPeriod"
            case storageType = "storageType"
            case warmTier = "warmTier"
            case warmTierRetentionPeriod = "warmTierRetentionPeriod"
        }
    }

    public struct DescribeTimeSeriesRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String?

        @inlinable
        public init(alias: String? = nil, assetId: String? = nil, propertyId: String? = nil) {
            self.alias = alias
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTimeSeriesResponse: AWSDecodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        public let dataType: PropertyDataType
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The ARN of the time series, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
        public let timeSeriesArn: String
        /// The date that the time series was created, in Unix epoch time.
        public let timeSeriesCreationDate: Date
        /// The ID of the time series.
        public let timeSeriesId: String
        /// The date that the time series was last updated, in Unix epoch time.
        public let timeSeriesLastUpdateDate: Date

        @inlinable
        public init(alias: String? = nil, assetId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, propertyId: String? = nil, timeSeriesArn: String, timeSeriesCreationDate: Date, timeSeriesId: String, timeSeriesLastUpdateDate: Date) {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesArn = timeSeriesArn
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case assetId = "assetId"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case propertyId = "propertyId"
            case timeSeriesArn = "timeSeriesArn"
            case timeSeriesCreationDate = "timeSeriesCreationDate"
            case timeSeriesId = "timeSeriesId"
            case timeSeriesLastUpdateDate = "timeSeriesLastUpdateDate"
        }
    }

    public struct DetailedError: AWSDecodableShape {
        /// The error code.
        public let code: DetailedErrorCode
        /// The error message.
        public let message: String

        @inlinable
        public init(code: DetailedErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct DisassociateAssetsRequest: AWSEncodableShape {
        /// The ID of the parent asset from which to disassociate the child asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The ID of the child asset to disassociate. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.) Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        @inlinable
        public init(assetId: String, childAssetId: String, clientToken: String? = DisassociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            try container.encode(self.childAssetId, forKey: .childAssetId)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.hierarchyId, forKey: .hierarchyId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 139)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 13)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 139)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 13)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case clientToken = "clientToken"
            case hierarchyId = "hierarchyId"
        }
    }

    public struct DisassociateTimeSeriesFromAssetPropertyRequest: AWSEncodableShape {
        /// The alias that identifies the time series.
        public let alias: String
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String

        @inlinable
        public init(alias: String, assetId: String, clientToken: String? = DisassociateTimeSeriesFromAssetPropertyRequest.idempotencyToken(), propertyId: String) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        ///  A list of detailed errors.
        public let details: [DetailedError]?
        /// The error message.
        public let message: String

        @inlinable
        public init(code: ErrorCode, details: [DetailedError]? = nil, message: String) {
            self.code = code
            self.details = details
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case details = "details"
            case message = "message"
        }
    }

    public struct ErrorReportLocation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.
        public let bucket: String
        /// Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see Organizing objects using prefixes in the Amazon Simple Storage Service User Guide.
        public let prefix: String

        @inlinable
        public init(bucket: String, prefix: String) {
            self.bucket = bucket
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case prefix = "prefix"
        }
    }

    public struct ExecuteActionRequest: AWSEncodableShape {
        /// The ID of the action definition.
        public let actionDefinitionId: String
        /// The JSON payload of the action.
        public let actionPayload: ActionPayload
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The resource the action will be taken on.
        public let targetResource: TargetResource

        @inlinable
        public init(actionDefinitionId: String, actionPayload: ActionPayload, clientToken: String? = nil, targetResource: TargetResource) {
            self.actionDefinitionId = actionDefinitionId
            self.actionPayload = actionPayload
            self.clientToken = clientToken
            self.targetResource = targetResource
        }

        public func validate(name: String) throws {
            try self.validate(self.actionDefinitionId, name: "actionDefinitionId", parent: name, max: 36)
            try self.validate(self.actionDefinitionId, name: "actionDefinitionId", parent: name, min: 36)
            try self.validate(self.actionDefinitionId, name: "actionDefinitionId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.actionPayload.validate(name: "\(name).actionPayload")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.targetResource.validate(name: "\(name).targetResource")
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinitionId = "actionDefinitionId"
            case actionPayload = "actionPayload"
            case clientToken = "clientToken"
            case targetResource = "targetResource"
        }
    }

    public struct ExecuteActionResponse: AWSDecodableShape {
        /// The ID of the action.
        public let actionId: String

        @inlinable
        public init(actionId: String) {
            self.actionId = actionId
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
        }
    }

    public struct ExecuteQueryRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The maximum number of results to return at one time. The default is 25.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The IoT SiteWise query statement.
        public let queryStatement: String

        @inlinable
        public init(clientToken: String? = ExecuteQueryRequest.idempotencyToken(), maxResults: Int? = nil, nextToken: String? = nil, queryStatement: String) {
            self.clientToken = clientToken
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryStatement = queryStatement
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case queryStatement = "queryStatement"
        }
    }

    public struct ExecuteQueryResponse: AWSDecodableShape {
        /// Represents a single column in the query results.
        public let columns: [ColumnInfo]?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Represents a single row in the query results.
        public let rows: [Row]?

        @inlinable
        public init(columns: [ColumnInfo]? = nil, nextToken: String? = nil, rows: [Row]? = nil) {
            self.columns = columns
            self.nextToken = nextToken
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
            case nextToken = "nextToken"
            case rows = "rows"
        }
    }

    public struct ExpressionVariable: AWSEncodableShape & AWSDecodableShape {
        /// The friendly name of the variable to be used in the expression.
        public let name: String
        /// The variable that identifies an asset property from which to use values.
        public let value: VariableValue

        @inlinable
        public init(name: String, value: VariableValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct File: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket from which data is imported.
        public let bucket: String
        /// The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.
        public let key: String
        /// The version ID to identify a specific version of the Amazon S3 object that contains your data.
        public let versionId: String?

        @inlinable
        public init(bucket: String, key: String, versionId: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
            case versionId = "versionId"
        }
    }

    public struct FileFormat: AWSEncodableShape & AWSDecodableShape {
        /// The file is in .CSV format.
        public let csv: Csv?
        /// The file is in parquet format.
        public let parquet: Parquet?

        @inlinable
        public init(csv: Csv? = nil, parquet: Parquet? = nil) {
            self.csv = csv
            self.parquet = parquet
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "csv"
            case parquet = "parquet"
        }
    }

    public struct ForwardingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The forwarding state for the given property.
        public let state: ForwardingConfigState

        @inlinable
        public init(state: ForwardingConfigState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct GatewayCapabilitySummary: AWSDecodableShape {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    NOT_APPLICABLE – Synchronization is not required for this capability configuration. This is most common when integrating partner data sources, because the data integration is handled externally by the partner.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.    UNKNOWN – The synchronization status is currently unknown due to an undetermined or temporary error.
        public let capabilitySyncStatus: CapabilitySyncStatus

        @inlinable
        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
        }
    }

    public struct GatewayPlatform: AWSEncodableShape & AWSDecodableShape {
        /// A gateway that runs on IoT Greengrass.
        public let greengrass: Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public let greengrassV2: GreengrassV2?
        /// A SiteWise Edge gateway that runs on a Siemens Industrial Edge Device.
        public let siemensIE: SiemensIE?

        @inlinable
        public init(greengrass: Greengrass? = nil, greengrassV2: GreengrassV2? = nil, siemensIE: SiemensIE? = nil) {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
            self.siemensIE = siemensIE
        }

        public func validate(name: String) throws {
            try self.greengrass?.validate(name: "\(name).greengrass")
            try self.greengrassV2?.validate(name: "\(name).greengrassV2")
            try self.siemensIE?.validate(name: "\(name).siemensIE")
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass = "greengrass"
            case greengrassV2 = "greengrassV2"
            case siemensIE = "siemensIE"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the gateway.
        public let gatewayName: String
        public let gatewayPlatform: GatewayPlatform?
        /// The version of the gateway. A value of 3 indicates an MQTT-enabled, V3 gateway, while 2 indicates a Classic streams, V2 gateway.
        public let gatewayVersion: String?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        @inlinable
        public init(creationDate: Date, gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil, gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, gatewayVersion: String? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.gatewayVersion = gatewayVersion
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case gatewayCapabilitySummaries = "gatewayCapabilitySummaries"
            case gatewayId = "gatewayId"
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case gatewayVersion = "gatewayVersion"
            case lastUpdateDate = "lastUpdateDate"
        }
    }

    public struct GetAssetPropertyAggregatesRequest: AWSEncodableShape {
        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 1 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 2500.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        @inlinable
        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aggregateTypes, key: "aggregateTypes")
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.endDate, key: "endDate")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
            request.encodeQuery(self.qualities, key: "qualities")
            request.encodeQuery(self.resolution, key: "resolution")
            request.encodeQuery(self.startDate, key: "startDate")
            request.encodeQuery(self.timeOrdering, key: "timeOrdering")
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 3)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "^1m|15m|1h|1d$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// The requested aggregated values.
        public let aggregatedValues: [AggregatedValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(aggregatedValues: [AggregatedValue], nextToken: String? = nil) {
            self.aggregatedValues = aggregatedValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues = "aggregatedValues"
            case nextToken = "nextToken"
        }
    }

    public struct GetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is equal to 4 MB.   The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        @inlinable
        public init(assetId: String? = nil, endDate: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.endDate, key: "endDate")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
            request.encodeQuery(self.qualities, key: "qualities")
            request.encodeQuery(self.startDate, key: "startDate")
            request.encodeQuery(self.timeOrdering, key: "timeOrdering")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The asset property's value history.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetPropertyValueHistory: [AssetPropertyValue], nextToken: String? = nil) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory = "assetPropertyValueHistory"
            case nextToken = "nextToken"
        }
    }

    public struct GetAssetPropertyValueRequest: AWSEncodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?

        @inlinable
        public init(assetId: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueResponse: AWSDecodableShape {
        /// The current asset property value.
        public let propertyValue: AssetPropertyValue?

        @inlinable
        public init(propertyValue: AssetPropertyValue? = nil) {
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValue = "propertyValue"
        }
    }

    public struct GetInterpolatedAssetPropertyValuesRequest: AWSEncodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String?
        /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let endTimeInSeconds: Int64
        /// The nanosecond offset converted from endTimeInSeconds.
        public let endTimeOffsetInNanos: Int?
        /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
        public let intervalInSeconds: Int64
        /// The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.    If you specify a value for the intervalWindowInSeconds parameter, the value for the type parameter must be LINEAR_INTERPOLATION.   If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.    For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.
        public let intervalWindowInSeconds: Int64?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
        public let quality: Quality
        /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let startTimeInSeconds: Int64
        /// The nanosecond offset converted from startTimeInSeconds.
        public let startTimeOffsetInNanos: Int?
        /// The interpolation type. Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION     LINEAR_INTERPOLATION – Estimates missing data using linear interpolation. For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.    LOCF_INTERPOLATION – Estimates missing data using last observation carried forward interpolation If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found. For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
        public let type: String

        @inlinable
        public init(assetId: String? = nil, endTimeInSeconds: Int64, endTimeOffsetInNanos: Int? = nil, intervalInSeconds: Int64, intervalWindowInSeconds: Int64? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, quality: Quality, startTimeInSeconds: Int64, startTimeOffsetInNanos: Int? = nil, type: String) {
            self.assetId = assetId
            self.endTimeInSeconds = endTimeInSeconds
            self.endTimeOffsetInNanos = endTimeOffsetInNanos
            self.intervalInSeconds = intervalInSeconds
            self.intervalWindowInSeconds = intervalWindowInSeconds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.quality = quality
            self.startTimeInSeconds = startTimeInSeconds
            self.startTimeOffsetInNanos = startTimeOffsetInNanos
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.endTimeInSeconds, key: "endTimeInSeconds")
            request.encodeQuery(self.endTimeOffsetInNanos, key: "endTimeOffsetInNanos")
            request.encodeQuery(self.intervalInSeconds, key: "intervalInSeconds")
            request.encodeQuery(self.intervalWindowInSeconds, key: "intervalWindowInSeconds")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.propertyAlias, key: "propertyAlias")
            request.encodeQuery(self.propertyId, key: "propertyId")
            request.encodeQuery(self.quality, key: "quality")
            request.encodeQuery(self.startTimeInSeconds, key: "startTimeInSeconds")
            request.encodeQuery(self.startTimeOffsetInNanos, key: "startTimeOffsetInNanos")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, max: 9223372036854774)
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, min: 1)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, max: 999999999)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, max: 320000000)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, min: 1)
            try self.validate(self.intervalWindowInSeconds, name: "intervalWindowInSeconds", parent: name, max: 320000000)
            try self.validate(self.intervalWindowInSeconds, name: "intervalWindowInSeconds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, max: 9223372036854774)
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, min: 1)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, max: 999999999)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInterpolatedAssetPropertyValuesResponse: AWSDecodableShape {
        /// The requested interpolated values.
        public let interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue], nextToken: String? = nil) {
            self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case interpolatedAssetPropertyValues = "interpolatedAssetPropertyValues"
            case nextToken = "nextToken"
        }
    }

    public struct Greengrass: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Greengrass group. For more information about how to find a group's ARN, see ListGroups and GetGroup in the IoT Greengrass V1 API Reference.
        public let groupArn: String

        @inlinable
        public init(groupArn: String) {
            self.groupArn = groupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.groupArn, name: "groupArn", parent: name, max: 1600)
            try self.validate(self.groupArn, name: "groupArn", parent: name, min: 1)
            try self.validate(self.groupArn, name: "groupArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupArn = "groupArn"
        }
    }

    public struct GreengrassV2: AWSEncodableShape & AWSDecodableShape {
        /// The operating system of the core device in IoT Greengrass V2.
        public let coreDeviceOperatingSystem: CoreDeviceOperatingSystem?
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        public let coreDeviceThingName: String

        @inlinable
        public init(coreDeviceOperatingSystem: CoreDeviceOperatingSystem? = nil, coreDeviceThingName: String) {
            self.coreDeviceOperatingSystem = coreDeviceOperatingSystem
            self.coreDeviceThingName = coreDeviceThingName
        }

        public func validate(name: String) throws {
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, max: 128)
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, min: 1)
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case coreDeviceOperatingSystem = "coreDeviceOperatingSystem"
            case coreDeviceThingName = "coreDeviceThingName"
        }
    }

    public struct GroupIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The IAM Identity Center ID of the group.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct IAMRoleIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role. For more information, see IAM ARNs in the IAM User Guide.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.\\+=,@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct IAMUserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide.  If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.\\+=,@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Identity: AWSEncodableShape & AWSDecodableShape {
        /// An IAM Identity Center group identity.
        public let group: GroupIdentity?
        /// An IAM role identity.
        public let iamRole: IAMRoleIdentity?
        /// An IAM user identity.
        public let iamUser: IAMUserIdentity?
        /// An IAM Identity Center user identity.
        public let user: UserIdentity?

        @inlinable
        public init(group: GroupIdentity? = nil, iamRole: IAMRoleIdentity? = nil, iamUser: IAMUserIdentity? = nil, user: UserIdentity? = nil) {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }

        public func validate(name: String) throws {
            try self.group?.validate(name: "\(name).group")
            try self.iamRole?.validate(name: "\(name).iamRole")
            try self.iamUser?.validate(name: "\(name).iamUser")
            try self.user?.validate(name: "\(name).user")
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case iamRole = "iamRole"
            case iamUser = "iamUser"
            case user = "user"
        }
    }

    public struct Image: AWSEncodableShape {
        public let file: ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public let id: String?

        @inlinable
        public init(file: ImageFile? = nil, id: String? = nil) {
            self.file = file
            self.id = id
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case id = "id"
        }
    }

    public struct ImageFile: AWSEncodableShape {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        public let data: AWSBase64Data
        /// The file type of the image.
        public let type: ImageFileType

        @inlinable
        public init(data: AWSBase64Data, type: ImageFileType) {
            self.data = data
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 1500000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case type = "type"
        }
    }

    public struct ImageLocation: AWSDecodableShape {
        /// The ID of the image.
        public let id: String
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        public let url: String

        @inlinable
        public init(id: String, url: String) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case url = "url"
        }
    }

    public struct InternalFailureException: AWSDecodableShape {
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InterpolatedAssetPropertyValue: AWSDecodableShape {
        public let timestamp: TimeInNanos
        public let value: Variant

        @inlinable
        public init(timestamp: TimeInNanos, value: Variant) {
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct InvalidRequestException: AWSDecodableShape {
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvocationOutput: AWSDecodableShape {
        /// A list of citations, and related information for the SiteWise Assistant's response.
        public let citations: [Citation]?
        /// The text message of the SiteWise Assistant's response.
        public let message: String?

        @inlinable
        public init(citations: [Citation]? = nil, message: String? = nil) {
            self.citations = citations
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
            case message = "message"
        }
    }

    public struct InvokeAssistantRequest: AWSEncodableShape {
        /// The ID assigned to a conversation. IoT SiteWise automatically generates a unique ID for you, and this parameter is never required.  However, if you prefer to have your own ID, you must specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public let conversationId: String?
        /// Specifies if to turn trace on or not. It is used to track the SiteWise Assistant's  reasoning, and data access process.
        public let enableTrace: Bool?
        /// A text message sent to the SiteWise Assistant by the user.
        public let message: String

        @inlinable
        public init(conversationId: String? = nil, enableTrace: Bool? = nil, message: String) {
            self.conversationId = conversationId
            self.enableTrace = enableTrace
            self.message = message
        }

        public func validate(name: String) throws {
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.message, name: "message", parent: name, max: 10000)
            try self.validate(self.message, name: "message", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case enableTrace = "enableTrace"
            case message = "message"
        }
    }

    public struct InvokeAssistantResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        public let body: AWSEventStream<ResponseStream>
        /// The ID of the conversation, in UUID format. This ID uniquely identifies the conversation within IoT SiteWise.
        public let conversationId: String

        @inlinable
        public init(body: AWSEventStream<ResponseStream>, conversationId: String) {
            self.body = body
            self.conversationId = conversationId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSEventStream<ResponseStream>.self)
            self.conversationId = try response.decodeHeader(String.self, key: "x-amz-iotsitewise-assistant-conversation-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct JobConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file format of the data in S3.
        public let fileFormat: FileFormat

        @inlinable
        public init(fileFormat: FileFormat) {
            self.fileFormat = fileFormat
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The ID of the job.
        public let id: String
        /// The unique name that helps identify the job request.
        public let name: String
        /// The status of the bulk import job can be one of following values:    PENDING – IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED – The bulk import job has been canceled.    RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let status: JobStatus

        @inlinable
        public init(id: String, name: String, status: JobStatus) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct KendraSourceDetail: AWSEncodableShape & AWSDecodableShape {
        /// The knowledgeBaseArn details for the Kendra dataset source.
        public let knowledgeBaseArn: String
        /// The roleARN details for the Kendra dataset source.
        public let roleArn: String

        @inlinable
        public init(knowledgeBaseArn: String, roleArn: String) {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, max: 1600)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, min: 1)
            try self.validate(self.knowledgeBaseArn, name: "knowledgeBaseArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
            case roleArn = "roleArn"
        }
    }

    public struct LimitExceededException: AWSDecodableShape {
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide. This parameter is required if you specify IAM for identityType.
        public let iamArn: String?
        /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
        public let identityId: String?
        /// The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify identityId.
        public let identityType: IdentityType?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the resource. This parameter is required if you specify resourceType.
        public let resourceId: String?
        /// The type of resource (portal or project). This parameter is required if you specify resourceId.
        public let resourceType: ResourceType?

        @inlinable
        public init(iamArn: String? = nil, identityId: String? = nil, identityType: IdentityType? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.iamArn = iamArn
            self.identityId = identityId
            self.identityType = identityType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.iamArn, key: "iamArn")
            request.encodeQuery(self.identityId, key: "identityId")
            request.encodeQuery(self.identityType, key: "identityType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceId, key: "resourceId")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.iamArn, name: "iamArn", parent: name, max: 1600)
            try self.validate(self.iamArn, name: "iamArn", parent: name, min: 1)
            try self.validate(self.iamArn, name: "iamArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.\\+=,@]+$")
            try self.validate(self.identityId, name: "identityId", parent: name, max: 256)
            try self.validate(self.identityId, name: "identityId", parent: name, min: 1)
            try self.validate(self.identityId, name: "identityId", parent: name, pattern: "^\\S+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {
        /// A list that summarizes each access policy.
        public let accessPolicySummaries: [AccessPolicySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(accessPolicySummaries: [AccessPolicySummary], nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries = "accessPolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListActionsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the target resource.
        public let targetResourceId: String
        /// The type of resource.
        public let targetResourceType: TargetResourceType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, targetResourceId: String, targetResourceType: TargetResourceType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetResourceId = targetResourceId
            self.targetResourceType = targetResourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.targetResourceId, key: "targetResourceId")
            request.encodeQuery(self.targetResourceType, key: "targetResourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, max: 139)
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, min: 13)
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListActionsResponse: AWSDecodableShape {
        /// A list that summarizes the actions associated with the specified asset.
        public let actionSummaries: [ActionSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String

        @inlinable
        public init(actionSummaries: [ActionSummary], nextToken: String) {
            self.actionSummaries = actionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionSummaries = "actionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelCompositeModelsRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The version alias that specifies the latest or active version of the asset model.  The details are returned in the response. The default value is LATEST. See  Asset model versions in the IoT SiteWise User Guide.
        public let assetModelVersion: String?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(assetModelId: String, assetModelVersion: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.assetModelVersion = assetModelVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.assetModelVersion, key: "assetModelVersion")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelVersion, name: "assetModelVersion", parent: name, pattern: "^(LATEST|ACTIVE)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelCompositeModelsResponse: AWSDecodableShape {
        /// A list that summarizes each composite model.
        public let assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetModelCompositeModelSummaries: [AssetModelCompositeModelSummary], nextToken: String? = nil) {
            self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelSummaries = "assetModelCompositeModelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelPropertiesRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The version alias that specifies the latest or active version of the asset model.  The details are returned in the response. The default value is LATEST. See  Asset model versions in the IoT SiteWise User Guide.
        public let assetModelVersion: String?
        ///  Filters the requested list of asset model properties. You can choose one of the following options:    ALL – The list includes all asset model properties for a given asset model ID.     BASE – The list includes only base asset model properties for a given asset model ID.    Default: BASE
        public let filter: ListAssetModelPropertiesFilter?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(assetModelId: String, assetModelVersion: String? = nil, filter: ListAssetModelPropertiesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.assetModelVersion = assetModelVersion
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.assetModelVersion, key: "assetModelVersion")
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelVersion, name: "assetModelVersion", parent: name, pattern: "^(LATEST|ACTIVE)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelPropertiesResponse: AWSDecodableShape {
        /// A list that summarizes the properties associated with the specified asset model.
        public let assetModelPropertySummaries: [AssetModelPropertySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetModelPropertySummaries: [AssetModelPropertySummary], nextToken: String? = nil) {
            self.assetModelPropertySummaries = assetModelPropertySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelPropertySummaries = "assetModelPropertySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelsRequest: AWSEncodableShape {
        /// The type of asset model. If you don't provide an assetModelTypes, all types of asset models are returned.    ASSET_MODEL – An asset model that you can use to create assets. Can't be included as a component in another asset model.    COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public let assetModelTypes: [AssetModelType]?
        /// The version alias that specifies the latest or active version of the asset model.  The details are returned in the response. The default value is LATEST. See  Asset model versions in the IoT SiteWise User Guide.
        public let assetModelVersion: String?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(assetModelTypes: [AssetModelType]? = nil, assetModelVersion: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelTypes = assetModelTypes
            self.assetModelVersion = assetModelVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetModelTypes, key: "assetModelTypes")
            request.encodeQuery(self.assetModelVersion, key: "assetModelVersion")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelVersion, name: "assetModelVersion", parent: name, pattern: "^(LATEST|ACTIVE)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelsResponse: AWSDecodableShape {
        /// A list that summarizes each asset model.
        public let assetModelSummaries: [AssetModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetModelSummaries: [AssetModelSummary], nextToken: String? = nil) {
            self.assetModelSummaries = assetModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelSummaries = "assetModelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetPropertiesRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        ///  Filters the requested list of asset properties. You can choose one of the following options:    ALL – The list includes all asset properties for a given asset model ID.     BASE – The list includes only base asset properties for a given asset model ID.    Default: BASE
        public let filter: ListAssetPropertiesFilter?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(assetId: String, filter: ListAssetPropertiesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetId = assetId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetPropertiesResponse: AWSDecodableShape {
        /// A list that summarizes the properties associated with the specified asset.
        public let assetPropertySummaries: [AssetPropertySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetPropertySummaries: [AssetPropertySummary], nextToken: String? = nil) {
            self.assetPropertySummaries = assetPropertySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertySummaries = "assetPropertySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetRelationshipsRequest: AWSEncodableShape {
        /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of traversal to use to identify asset relationships. Choose the following option:    PATH_TO_ROOT – Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
        public let traversalType: TraversalType

        @inlinable
        public init(assetId: String, maxResults: Int? = nil, nextToken: String? = nil, traversalType: TraversalType) {
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalType = traversalType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.traversalType, key: "traversalType")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetRelationshipsResponse: AWSDecodableShape {
        /// A list that summarizes each asset relationship.
        public let assetRelationshipSummaries: [AssetRelationshipSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetRelationshipSummaries: [AssetRelationshipSummary], nextToken: String? = nil) {
            self.assetRelationshipSummaries = assetRelationshipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetRelationshipSummaries = "assetRelationshipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String?
        /// The filter for the requested list of assets. Choose one of the following options:    ALL – The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.    TOP_LEVEL – The list includes only top-level assets in the asset hierarchy tree.   Default: ALL
        public let filter: ListAssetsFilter?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(assetModelId: String? = nil, filter: ListAssetsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {
        /// A list that summarizes each asset.
        public let assetSummaries: [AssetSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetSummaries: [AssetSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries = "assetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssociatedAssetsRequest: AWSEncodableShape {
        /// The ID of the asset to query. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// (Optional) If you don't provide a hierarchyId, all the immediate assets in the traversalDirection will be returned.  The ID of the hierarchy by which child assets are associated to the asset. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.) For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The direction to list associated assets. Choose one of the following options:    CHILD – The list includes all child assets associated to the asset.    PARENT – The list includes the asset's parent asset.   Default: CHILD
        public let traversalDirection: TraversalDirection?

        @inlinable
        public init(assetId: String, hierarchyId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, traversalDirection: TraversalDirection? = nil) {
            self.assetId = assetId
            self.hierarchyId = hierarchyId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalDirection = traversalDirection
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            request.encodeQuery(self.hierarchyId, key: "hierarchyId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.traversalDirection, key: "traversalDirection")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 139)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 13)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedAssetsResponse: AWSDecodableShape {
        /// A list that summarizes the associated assets.
        public let assetSummaries: [AssociatedAssetsSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetSummaries: [AssociatedAssetsSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries = "assetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBulkImportJobsRequest: AWSEncodableShape {
        /// You can use a filter to select the bulk import jobs that you want to retrieve.
        public let filter: ListBulkImportJobsFilter?
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(filter: ListBulkImportJobsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.filter, key: "filter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBulkImportJobsResponse: AWSDecodableShape {
        /// One or more job summaries to list.
        public let jobSummaries: [JobSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(jobSummaries: [JobSummary], nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries = "jobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCompositionRelationshipsRequest: AWSEncodableShape {
        /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(assetModelId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetModelId, key: "assetModelId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCompositionRelationshipsResponse: AWSDecodableShape {
        /// A list that summarizes each composition relationship.
        public let compositionRelationshipSummaries: [CompositionRelationshipSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(compositionRelationshipSummaries: [CompositionRelationshipSummary], nextToken: String? = nil) {
            self.compositionRelationshipSummaries = compositionRelationshipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compositionRelationshipSummaries = "compositionRelationshipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        /// A list that summarizes each dashboard in the project.
        public let dashboardSummaries: [DashboardSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(dashboardSummaries: [DashboardSummary], nextToken: String? = nil) {
            self.dashboardSummaries = dashboardSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaries = "dashboardSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The type of data source for the dataset.
        public let sourceType: DatasetSourceType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sourceType: DatasetSourceType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceType = sourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sourceType, key: "sourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// A list that summarizes the dataset response.
        public let datasetSummaries: [DatasetSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(datasetSummaries: [DatasetSummary], nextToken: String? = nil) {
            self.datasetSummaries = datasetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetSummaries = "datasetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// A list that summarizes each gateway.
        public let gatewaySummaries: [GatewaySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(gatewaySummaries: [GatewaySummary], nextToken: String? = nil) {
            self.gatewaySummaries = gatewaySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewaySummaries = "gatewaySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each portal.
        public let portalSummaries: [PortalSummary]?

        @inlinable
        public init(nextToken: String? = nil, portalSummaries: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portalSummaries = portalSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case portalSummaries = "portalSummaries"
        }
    }

    public struct ListProjectAssetsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectId, key: "projectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectAssetsResponse: AWSDecodableShape {
        /// A list that contains the IDs of each asset associated with the project.
        public let assetIds: [String]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(assetIds: [String], nextToken: String? = nil) {
            self.assetIds = assetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the portal.
        public let portalId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, portalId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalId = portalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.portalId, key: "portalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each project in the portal.
        public let projectSummaries: [ProjectSummary]

        @inlinable
        public init(nextToken: String? = nil, projectSummaries: [ProjectSummary]) {
            self.nextToken = nextToken
            self.projectSummaries = projectSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projectSummaries = "projectSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTimeSeriesRequest: AWSEncodableShape {
        /// The alias prefix of the time series.
        public let aliasPrefix: String?
        /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String?
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of the time series. The time series type can be one of the following values:    ASSOCIATED – The time series is associated with an asset property.    DISASSOCIATED – The time series isn't associated with any asset property.
        public let timeSeriesType: ListTimeSeriesType?

        @inlinable
        public init(aliasPrefix: String? = nil, assetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, timeSeriesType: ListTimeSeriesType? = nil) {
            self.aliasPrefix = aliasPrefix
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.timeSeriesType = timeSeriesType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasPrefix, key: "aliasPrefix")
            request.encodeQuery(self.assetId, key: "assetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.timeSeriesType, key: "timeSeriesType")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasPrefix, name: "aliasPrefix", parent: name, min: 1)
            try self.validate(self.aliasPrefix, name: "aliasPrefix", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTimeSeriesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// One or more time series summaries to list.
        public let timeSeriesSummaries: [TimeSeriesSummary]

        @inlinable
        public init(nextToken: String? = nil, timeSeriesSummaries: [TimeSeriesSummary]) {
            self.nextToken = nextToken
            self.timeSeriesSummaries = timeSeriesSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case timeSeriesSummaries = "TimeSeriesSummaries"
        }
    }

    public struct Location: AWSDecodableShape {
        /// The URI of the location.
        public let uri: String?

        @inlinable
        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct LoggingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The IoT SiteWise logging verbosity level.
        public let level: LoggingLevel

        @inlinable
        public init(level: LoggingLevel) {
            self.level = level
        }

        private enum CodingKeys: String, CodingKey {
            case level = "level"
        }
    }

    public struct Measurement: AWSEncodableShape & AWSDecodableShape {
        /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
        public let processingConfig: MeasurementProcessingConfig?

        @inlinable
        public init(processingConfig: MeasurementProcessingConfig? = nil) {
            self.processingConfig = processingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case processingConfig = "processingConfig"
        }
    }

    public struct MeasurementProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The forwarding configuration for the given measurement property.
        public let forwardingConfig: ForwardingConfig

        @inlinable
        public init(forwardingConfig: ForwardingConfig) {
            self.forwardingConfig = forwardingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case forwardingConfig = "forwardingConfig"
        }
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
        public let processingConfig: MetricProcessingConfig?
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        public let window: MetricWindow

        @inlinable
        public init(expression: String, processingConfig: MetricProcessingConfig? = nil, variables: [ExpressionVariable], window: MetricWindow) {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
            try self.window.validate(name: "\(name).window")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case processingConfig = "processingConfig"
            case variables = "variables"
            case window = "window"
        }
    }

    public struct MetricProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The compute location for the given metric property.
        public let computeLocation: ComputeLocation

        @inlinable
        public init(computeLocation: ComputeLocation) {
            self.computeLocation = computeLocation
        }

        private enum CodingKeys: String, CodingKey {
            case computeLocation = "computeLocation"
        }
    }

    public struct MetricWindow: AWSEncodableShape & AWSDecodableShape {
        /// The tumbling time interval window.
        public let tumbling: TumblingWindow?

        @inlinable
        public init(tumbling: TumblingWindow? = nil) {
            self.tumbling = tumbling
        }

        public func validate(name: String) throws {
            try self.tumbling?.validate(name: "\(name).tumbling")
        }

        private enum CodingKeys: String, CodingKey {
            case tumbling = "tumbling"
        }
    }

    public struct MonitorErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: MonitorErrorCode?
        /// The error message.
        public let message: String?

        @inlinable
        public init(code: MonitorErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct MultiLayerStorage: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about a customer managed Amazon S3 bucket.
        public let customerManagedS3Storage: CustomerManagedS3Storage

        @inlinable
        public init(customerManagedS3Storage: CustomerManagedS3Storage) {
            self.customerManagedS3Storage = customerManagedS3Storage
        }

        public func validate(name: String) throws {
            try self.customerManagedS3Storage.validate(name: "\(name).customerManagedS3Storage")
        }

        private enum CodingKeys: String, CodingKey {
            case customerManagedS3Storage = "customerManagedS3Storage"
        }
    }

    public struct Parquet: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct PortalResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the portal.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct PortalStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: MonitorErrorDetails?
        /// The current state of the portal.
        public let state: PortalState

        @inlinable
        public init(error: MonitorErrorDetails? = nil, state: PortalState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct PortalSummary: AWSDecodableShape {
        /// The date the portal was created, in Unix epoch time.
        public let creationDate: Date?
        /// The portal's description.
        public let description: String?
        /// The ID of the portal.
        public let id: String
        /// The date the portal was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the portal.
        public let name: String
        /// Define the type of portal. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalType: PortalType?
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let startUrl: String
        public let status: PortalStatus

        @inlinable
        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String, portalType: PortalType? = nil, roleArn: String? = nil, startUrl: String, status: PortalStatus) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.portalType = portalType
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case portalType = "portalType"
            case roleArn = "roleArn"
            case startUrl = "startUrl"
            case status = "status"
        }
    }

    public struct PortalTypeEntry: AWSEncodableShape & AWSDecodableShape {
        /// The array of tools associated with the specified portal type. The possible values are ASSISTANT and DASHBOARD.
        public let portalTools: [String]?

        @inlinable
        public init(portalTools: [String]? = nil) {
            self.portalTools = portalTools
        }

        public func validate(name: String) throws {
            try self.portalTools?.forEach {
                try validate($0, name: "portalTools[]", parent: name, max: 256)
                try validate($0, name: "portalTools[]", parent: name, min: 1)
                try validate($0, name: "portalTools[]", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case portalTools = "portalTools"
        }
    }

    public struct PreconditionFailedException: AWSErrorShape {
        public let message: String
        /// The ARN of the resource on which precondition failed with this operation.
        public let resourceArn: String
        /// The ID of the resource on which precondition failed with this operation.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceArn: String, resourceId: String) {
            self.message = message
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct ProjectResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the project.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The date the project was created, in Unix epoch time.
        public let creationDate: Date?
        /// The project's description.
        public let description: String?
        /// The ID of the project.
        public let id: String
        /// The date the project was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the project.
        public let name: String

        @inlinable
        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
        }
    }

    public struct Property: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The property data type.
        public let dataType: PropertyDataType
        /// The external ID of the asset property. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let externalId: String?
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public let path: [AssetPropertyPathSegment]?
        /// The property type (see PropertyType). A property contains one type.
        public let type: PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        @inlinable
        public init(alias: String? = nil, dataType: PropertyDataType, externalId: String? = nil, id: String, name: String, notification: PropertyNotification? = nil, path: [AssetPropertyPathSegment]? = nil, type: PropertyType? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.externalId = externalId
            self.id = id
            self.name = name
            self.notification = notification
            self.path = path
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case dataType = "dataType"
            case externalId = "externalId"
            case id = "id"
            case name = "name"
            case notification = "notification"
            case path = "path"
            case type = "type"
            case unit = "unit"
        }
    }

    public struct PropertyNotification: AWSDecodableShape {
        /// The current notification state.
        public let state: PropertyNotificationState
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        public let topic: String

        @inlinable
        public init(state: PropertyNotificationState, topic: String) {
            self.state = state
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case topic = "topic"
        }
    }

    public struct PropertyType: AWSEncodableShape & AWSDecodableShape {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an IIoT wind turbine.
        public let attribute: Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public let measurement: Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public let metric: Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public let transform: Transform?

        @inlinable
        public init(attribute: Attribute? = nil, measurement: Measurement? = nil, metric: Metric? = nil, transform: Transform? = nil) {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }

        public func validate(name: String) throws {
            try self.attribute?.validate(name: "\(name).attribute")
            try self.metric?.validate(name: "\(name).metric")
            try self.transform?.validate(name: "\(name).transform")
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case measurement = "measurement"
            case metric = "metric"
            case transform = "transform"
        }
    }

    public struct PropertyValueNullValue: AWSEncodableShape & AWSDecodableShape {
        /// The type of null asset property data.
        public let valueType: RawValueType

        @inlinable
        public init(valueType: RawValueType) {
            self.valueType = valueType
        }

        private enum CodingKeys: String, CodingKey {
            case valueType = "valueType"
        }
    }

    public struct PutAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset to update.
        public let assetId: String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property for this entry.
        public let propertyId: String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        public let propertyValues: [AssetPropertyValue]

        @inlinable
        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, propertyValues: [AssetPropertyValue]) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.propertyValues.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case propertyValues = "propertyValues"
        }
    }

    public struct PutDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ID of the customer managed key used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyId: String?

        @inlinable
        public init(encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct PutDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ARN of the KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// The logging options to set.
        public let loggingOptions: LoggingOptions

        @inlinable
        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions = "loggingOptions"
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStorageConfigurationRequest: AWSEncodableShape {
        /// Describes the configuration for ingesting NULL and NaN data.  By default the feature is allowed. The feature is disallowed if the value is true.
        public let disallowIngestNullNaN: Bool?
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:    ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type, you must specify a MultiLayerStorage object.
        public let multiLayerStorage: MultiLayerStorage?
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.    MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType
        /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
        public let warmTier: WarmTierState?
        /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
        public let warmTierRetentionPeriod: WarmTierRetentionPeriod?

        @inlinable
        public init(disallowIngestNullNaN: Bool? = nil, disassociatedDataStorage: DisassociatedDataStorageState? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType, warmTier: WarmTierState? = nil, warmTierRetentionPeriod: WarmTierRetentionPeriod? = nil) {
            self.disallowIngestNullNaN = disallowIngestNullNaN
            self.disassociatedDataStorage = disassociatedDataStorage
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
            self.warmTier = warmTier
            self.warmTierRetentionPeriod = warmTierRetentionPeriod
        }

        public func validate(name: String) throws {
            try self.multiLayerStorage?.validate(name: "\(name).multiLayerStorage")
        }

        private enum CodingKeys: String, CodingKey {
            case disallowIngestNullNaN = "disallowIngestNullNaN"
            case disassociatedDataStorage = "disassociatedDataStorage"
            case multiLayerStorage = "multiLayerStorage"
            case retentionPeriod = "retentionPeriod"
            case storageType = "storageType"
            case warmTier = "warmTier"
            case warmTierRetentionPeriod = "warmTierRetentionPeriod"
        }
    }

    public struct PutStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Describes the configuration for ingesting NULL and NaN data.  By default the feature is allowed. The feature is disallowed if the value is true.
        public let disallowIngestNullNaN: Bool?
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:    ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.    MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType
        /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
        public let warmTier: WarmTierState?
        /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
        public let warmTierRetentionPeriod: WarmTierRetentionPeriod?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, disallowIngestNullNaN: Bool? = nil, disassociatedDataStorage: DisassociatedDataStorageState? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType, warmTier: WarmTierState? = nil, warmTierRetentionPeriod: WarmTierRetentionPeriod? = nil) {
            self.configurationStatus = configurationStatus
            self.disallowIngestNullNaN = disallowIngestNullNaN
            self.disassociatedDataStorage = disassociatedDataStorage
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
            self.warmTier = warmTier
            self.warmTierRetentionPeriod = warmTierRetentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case disallowIngestNullNaN = "disallowIngestNullNaN"
            case disassociatedDataStorage = "disassociatedDataStorage"
            case multiLayerStorage = "multiLayerStorage"
            case retentionPeriod = "retentionPeriod"
            case storageType = "storageType"
            case warmTier = "warmTier"
            case warmTierRetentionPeriod = "warmTierRetentionPeriod"
        }
    }

    public struct Reference: AWSDecodableShape {
        /// Contains the dataset reference information.
        public let dataset: DataSetReference?

        @inlinable
        public init(dataset: DataSetReference? = nil) {
            self.dataset = dataset
        }

        private enum CodingKeys: String, CodingKey {
            case dataset = "dataset"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// A portal resource.
        public let portal: PortalResource?
        /// A project resource.
        public let project: ProjectResource?

        @inlinable
        public init(portal: PortalResource? = nil, project: ProjectResource? = nil) {
            self.portal = portal
            self.project = project
        }

        public func validate(name: String) throws {
            try self.portal?.validate(name: "\(name).portal")
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
            case project = "project"
        }
    }

    public struct ResourceAlreadyExistsException: AWSErrorShape {
        public let message: String
        /// The ARN of the resource that already exists.
        public let resourceArn: String
        /// The ID of the resource that already exists.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceArn: String, resourceId: String) {
            self.message = message
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetentionPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The number of days that your data is kept.  If you specified a value for this parameter, the unlimited parameter must be false.
        public let numberOfDays: Int?
        /// If true, your data is kept indefinitely.  If configured to true, you must not specify a value for the numberOfDays parameter.
        public let unlimited: Bool?

        @inlinable
        public init(numberOfDays: Int? = nil, unlimited: Bool? = nil) {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDays = "numberOfDays"
            case unlimited = "unlimited"
        }
    }

    public struct Row: AWSDecodableShape {
        /// List of data points in a single row of the result set.
        public let data: [Datum]

        @inlinable
        public init(data: [Datum]) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
        }
    }

    public struct SiemensIE: AWSEncodableShape & AWSDecodableShape {
        /// The name of the IoT Thing for your SiteWise Edge gateway.
        public let iotCoreThingName: String

        @inlinable
        public init(iotCoreThingName: String) {
            self.iotCoreThingName = iotCoreThingName
        }

        public func validate(name: String) throws {
            try self.validate(self.iotCoreThingName, name: "iotCoreThingName", parent: name, max: 128)
            try self.validate(self.iotCoreThingName, name: "iotCoreThingName", parent: name, min: 1)
            try self.validate(self.iotCoreThingName, name: "iotCoreThingName", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case iotCoreThingName = "iotCoreThingName"
        }
    }

    public struct Source: AWSDecodableShape {
        /// Contains the ARN of the dataset. If the source is Kendra, it's the ARN of the Kendra index.
        public let arn: String?
        /// Contains the location information where the cited text is originally stored.  For example, if the data source is Kendra, and the text synchronized is from an S3 bucket, then the location refers to an S3 object.
        public let location: Location?

        @inlinable
        public init(arn: String? = nil, location: Location? = nil) {
            self.arn = arn
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case location = "location"
        }
    }

    public struct SourceDetail: AWSEncodableShape & AWSDecodableShape {
        /// Contains details about the Kendra dataset source.
        public let kendra: KendraSourceDetail?

        @inlinable
        public init(kendra: KendraSourceDetail? = nil) {
            self.kendra = kendra
        }

        public func validate(name: String) throws {
            try self.kendra?.validate(name: "\(name).kendra")
        }

        private enum CodingKeys: String, CodingKey {
            case kendra = "kendra"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to tag.
        public let resourceArn: String
        /// A list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset, in UUID format.
        public let assetId: String

        @inlinable
        public init(assetId: String) {
            self.assetId = assetId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TimeInNanos: AWSEncodableShape & AWSDecodableShape {
        /// The nanosecond offset from timeInSeconds.
        public let offsetInNanos: Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        public let timeInSeconds: Int64

        @inlinable
        public init(offsetInNanos: Int? = nil, timeInSeconds: Int64) {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, max: 999999999)
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, min: 0)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, max: 9223372036854774)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case offsetInNanos = "offsetInNanos"
            case timeInSeconds = "timeInSeconds"
        }
    }

    public struct TimeSeriesSummary: AWSDecodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        public let dataType: PropertyDataType
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The ID of the asset property, in UUID format.
        public let propertyId: String?
        /// The ARN of the time series, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
        public let timeSeriesArn: String
        /// The date that the time series was created, in Unix epoch time.
        public let timeSeriesCreationDate: Date
        /// The ID of the time series.
        public let timeSeriesId: String
        /// The date that the time series was last updated, in Unix epoch time.
        public let timeSeriesLastUpdateDate: Date

        @inlinable
        public init(alias: String? = nil, assetId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, propertyId: String? = nil, timeSeriesArn: String, timeSeriesCreationDate: Date, timeSeriesId: String, timeSeriesLastUpdateDate: Date) {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesArn = timeSeriesArn
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case assetId = "assetId"
            case dataType = "dataType"
            case dataTypeSpec = "dataTypeSpec"
            case propertyId = "propertyId"
            case timeSeriesArn = "timeSeriesArn"
            case timeSeriesCreationDate = "timeSeriesCreationDate"
            case timeSeriesId = "timeSeriesId"
            case timeSeriesLastUpdateDate = "timeSeriesLastUpdateDate"
        }
    }

    public struct TooManyTagsException: AWSErrorShape {
        public let message: String?
        /// The name of the resource with too many tags.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct Trace: AWSDecodableShape {
        /// The cited text from the data source.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct Transform: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
        public let processingConfig: TransformProcessingConfig?
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]

        @inlinable
        public init(expression: String, processingConfig: TransformProcessingConfig? = nil, variables: [ExpressionVariable]) {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case processingConfig = "processingConfig"
            case variables = "variables"
        }
    }

    public struct TransformProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The compute location for the given transform property.
        public let computeLocation: ComputeLocation
        public let forwardingConfig: ForwardingConfig?

        @inlinable
        public init(computeLocation: ComputeLocation, forwardingConfig: ForwardingConfig? = nil) {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case computeLocation = "computeLocation"
            case forwardingConfig = "forwardingConfig"
        }
    }

    public struct TumblingWindow: AWSEncodableShape & AWSDecodableShape {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on.  When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        public let interval: String
        /// The offset for the tumbling window. The offset parameter accepts the following:   The offset time. For example, if you specify 18h for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.   If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.     The ISO 8601 format. For example, if you specify PT18H for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.   If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.     The 24-hour clock. For example, if you specify 00:03:00 for offset, 5m for interval, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC).    The offset time zone. For example, if you specify 2021-07-23T18:00-08 for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.   If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.
        public let offset: String?

        @inlinable
        public init(interval: String, offset: String? = nil) {
            self.interval = interval
            self.offset = offset
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, max: 23)
            try self.validate(self.interval, name: "interval", parent: name, min: 2)
            try self.validate(self.offset, name: "offset", parent: name, max: 25)
            try self.validate(self.offset, name: "offset", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "interval"
            case offset = "offset"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to untag.
        public let resourceArn: String
        /// A list of keys for tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        @inlinable
        public init(accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPolicyId, key: "accessPolicyId")
            try container.encode(self.accessPolicyIdentity, forKey: .accessPolicyIdentity)
            try container.encode(self.accessPolicyPermission, forKey: .accessPolicyPermission)
            try container.encode(self.accessPolicyResource, forKey: .accessPolicyResource)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssetModelCompositeModelRequest: AWSEncodableShape {
        /// A description for the composite model.
        public let assetModelCompositeModelDescription: String?
        /// An external ID to assign to the asset model. You can only set the external ID of the asset model if it wasn't set when it was created, or you're setting it to the exact same thing as when it was created.
        public let assetModelCompositeModelExternalId: String?
        /// The ID of a composite model on this asset model.
        public let assetModelCompositeModelId: String
        /// A unique name for the composite model.
        public let assetModelCompositeModelName: String
        /// The property definitions of the composite model. For more information, see  Inline custom composite models in the IoT SiteWise User Guide. You can specify up to 200 properties per composite model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelCompositeModelProperties: [AssetModelProperty]?
        /// The ID of the asset model, in UUID format.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType).    The update request is rejected if the tag does not match the latest or active version's current entity tag. See Optimistic locking for asset model writes in the IoT SiteWise User Guide.
        public let ifMatch: String?
        /// Accepts * to reject the update request if an active version  (specified using matchForVersionType as ACTIVE) already exists for the asset model.
        public let ifNoneMatch: String?
        /// Specifies the asset model version type (LATEST or ACTIVE) used in  conjunction with If-Match or If-None-Match headers to determine the target ETag for the update operation.
        public let matchForVersionType: AssetModelVersionType?

        @inlinable
        public init(assetModelCompositeModelDescription: String? = nil, assetModelCompositeModelExternalId: String? = nil, assetModelCompositeModelId: String, assetModelCompositeModelName: String, assetModelCompositeModelProperties: [AssetModelProperty]? = nil, assetModelId: String, clientToken: String? = UpdateAssetModelCompositeModelRequest.idempotencyToken(), ifMatch: String? = nil, ifNoneMatch: String? = nil, matchForVersionType: AssetModelVersionType? = nil) {
            self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
            self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelName = assetModelCompositeModelName
            self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
            self.assetModelId = assetModelId
            self.clientToken = clientToken
            self.ifMatch = ifMatch
            self.ifNoneMatch = ifNoneMatch
            self.matchForVersionType = matchForVersionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetModelCompositeModelDescription, forKey: .assetModelCompositeModelDescription)
            try container.encodeIfPresent(self.assetModelCompositeModelExternalId, forKey: .assetModelCompositeModelExternalId)
            request.encodePath(self.assetModelCompositeModelId, key: "assetModelCompositeModelId")
            try container.encode(self.assetModelCompositeModelName, forKey: .assetModelCompositeModelName)
            try container.encodeIfPresent(self.assetModelCompositeModelProperties, forKey: .assetModelCompositeModelProperties)
            request.encodePath(self.assetModelId, key: "assetModelId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.ifMatch, key: "If-Match")
            request.encodeHeader(self.ifNoneMatch, key: "If-None-Match")
            request.encodeHeader(self.matchForVersionType, key: "Match-For-Version-Type")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelDescription, name: "assetModelCompositeModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelCompositeModelExternalId, name: "assetModelCompositeModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, max: 139)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, min: 13)
            try self.validate(self.assetModelCompositeModelId, name: "assetModelCompositeModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, max: 256)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, min: 1)
            try self.validate(self.assetModelCompositeModelName, name: "assetModelCompositeModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelCompositeModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModelProperties[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.ifMatch, name: "ifMatch", parent: name, pattern: "^[\\w-]{43}$")
            try self.validate(self.ifNoneMatch, name: "ifNoneMatch", parent: name, pattern: "^\\*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelDescription = "assetModelCompositeModelDescription"
            case assetModelCompositeModelExternalId = "assetModelCompositeModelExternalId"
            case assetModelCompositeModelName = "assetModelCompositeModelName"
            case assetModelCompositeModelProperties = "assetModelCompositeModelProperties"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetModelCompositeModelResponse: AWSDecodableShape {
        /// The path to the composite model listing the parent composite models.
        public let assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment]
        public let assetModelStatus: AssetModelStatus

        @inlinable
        public init(assetModelCompositeModelPath: [AssetModelCompositeModelPathSegment], assetModelStatus: AssetModelStatus) {
            self.assetModelCompositeModelPath = assetModelCompositeModelPath
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelPath = "assetModelCompositeModelPath"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct UpdateAssetModelRequest: AWSEncodableShape {
        /// The composite models that are part of this asset model. It groups properties (such as attributes, measurements, transforms, and metrics) and child composite models that model parts of your industrial equipment. Each composite model has a type that defines the properties that the composite model supports. Use composite models to define alarms on this asset model.  When creating custom composite models, you need to use CreateAssetModelCompositeModel. For more information, see Creating custom composite models (Components) in the IoT SiteWise User Guide.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// An external ID to assign to the asset model. The asset model must not already have an external ID. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetModelExternalId: String?
        /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchy]?
        /// The ID of the asset model to update. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetModelId: String
        /// A unique name for the asset model.
        public let assetModelName: String
        /// The updated property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelProperty]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType).    The update request is rejected if the tag does not match the latest or active version's current entity tag. See Optimistic locking for asset model writes in the IoT SiteWise User Guide.
        public let ifMatch: String?
        /// Accepts * to reject the update request if an active version  (specified using matchForVersionType as ACTIVE) already exists for the asset model.
        public let ifNoneMatch: String?
        /// Specifies the asset model version type (LATEST or ACTIVE) used in  conjunction with If-Match or If-None-Match headers to determine the target ETag for the update operation.
        public let matchForVersionType: AssetModelVersionType?

        @inlinable
        public init(assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelDescription: String? = nil, assetModelExternalId: String? = nil, assetModelHierarchies: [AssetModelHierarchy]? = nil, assetModelId: String, assetModelName: String, assetModelProperties: [AssetModelProperty]? = nil, clientToken: String? = UpdateAssetModelRequest.idempotencyToken(), ifMatch: String? = nil, ifNoneMatch: String? = nil, matchForVersionType: AssetModelVersionType? = nil) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelExternalId = assetModelExternalId
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
            self.ifMatch = ifMatch
            self.ifNoneMatch = ifNoneMatch
            self.matchForVersionType = matchForVersionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetModelCompositeModels, forKey: .assetModelCompositeModels)
            try container.encodeIfPresent(self.assetModelDescription, forKey: .assetModelDescription)
            try container.encodeIfPresent(self.assetModelExternalId, forKey: .assetModelExternalId)
            try container.encodeIfPresent(self.assetModelHierarchies, forKey: .assetModelHierarchies)
            request.encodePath(self.assetModelId, key: "assetModelId")
            try container.encode(self.assetModelName, forKey: .assetModelName)
            try container.encodeIfPresent(self.assetModelProperties, forKey: .assetModelProperties)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.ifMatch, key: "If-Match")
            request.encodeHeader(self.ifNoneMatch, key: "If-None-Match")
            request.encodeHeader(self.matchForVersionType, key: "Match-For-Version-Type")
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 139)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 13)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.ifMatch, name: "ifMatch", parent: name, pattern: "^[\\w-]{43}$")
            try self.validate(self.ifNoneMatch, name: "ifNoneMatch", parent: name, pattern: "^\\*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels = "assetModelCompositeModels"
            case assetModelDescription = "assetModelDescription"
            case assetModelExternalId = "assetModelExternalId"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        @inlinable
        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct UpdateAssetPropertyRequest: AWSEncodableShape {
        /// The ID of the asset to be updated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
        public let propertyAlias: String?
        /// The ID of the asset property to be updated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let propertyId: String
        /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see Interacting with other services in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
        public let propertyNotificationState: PropertyNotificationState?
        /// The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
        public let propertyUnit: String?

        @inlinable
        public init(assetId: String, clientToken: String? = UpdateAssetPropertyRequest.idempotencyToken(), propertyAlias: String? = nil, propertyId: String, propertyNotificationState: PropertyNotificationState? = nil, propertyUnit: String? = nil) {
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyNotificationState = propertyNotificationState
            self.propertyUnit = propertyUnit
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "assetId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.propertyAlias, forKey: .propertyAlias)
            request.encodePath(self.propertyId, key: "propertyId")
            try container.encodeIfPresent(self.propertyNotificationState, forKey: .propertyNotificationState)
            try container.encodeIfPresent(self.propertyUnit, forKey: .propertyUnit)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 139)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 13)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, max: 256)
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, min: 1)
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case propertyAlias = "propertyAlias"
            case propertyNotificationState = "propertyNotificationState"
            case propertyUnit = "propertyUnit"
        }
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        /// A description for the asset.
        public let assetDescription: String?
        /// An external ID to assign to the asset. The asset must not already have an external ID. The external ID must be unique within your Amazon Web Services account. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let assetExternalId: String?
        /// The ID of the asset to update. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see Referencing objects with external IDs in the IoT SiteWise User Guide.
        public let assetId: String
        /// A friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        @inlinable
        public init(assetDescription: String? = nil, assetExternalId: String? = nil, assetId: String, assetName: String, clientToken: String? = UpdateAssetRequest.idempotencyToken()) {
            self.assetDescription = assetDescription
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.assetName = assetName
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetDescription, forKey: .assetDescription)
            try container.encodeIfPresent(self.assetExternalId, forKey: .assetExternalId)
            request.encodePath(self.assetId, key: "assetId")
            try container.encode(self.assetName, forKey: .assetName)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, max: 2048)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, min: 1)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, max: 128)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, min: 2)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 139)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 13)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetDescription = "assetDescription"
            case assetExternalId = "assetExternalId"
            case assetName = "assetName"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        @inlinable
        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus = "assetStatus"
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The new dashboard definition, as specified in a JSON literal.   IoT SiteWise Monitor (Classic) see Create dashboards (CLI)    IoT SiteWise Monitor (AI-aware) see Create dashboards (CLI)    in the IoT SiteWise User Guide
        public let dashboardDefinition: String
        /// A new description for the dashboard.
        public let dashboardDescription: String?
        /// The ID of the dashboard to update.
        public let dashboardId: String
        /// A new friendly name for the dashboard.
        public let dashboardName: String

        @inlinable
        public init(clientToken: String? = UpdateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardName: String) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardName = dashboardName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.dashboardDefinition, forKey: .dashboardDefinition)
            try container.encodeIfPresent(self.dashboardDescription, forKey: .dashboardDescription)
            request.encodePath(self.dashboardId, key: "dashboardId")
            try container.encode(self.dashboardName, forKey: .dashboardName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: "^.+$")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardName = "dashboardName"
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A description about the dataset, and its functionality.
        public let datasetDescription: String?
        /// The ID of the dataset.
        public let datasetId: String
        /// The name of the dataset.
        public let datasetName: String
        /// The data source for the dataset.
        public let datasetSource: DatasetSource

        @inlinable
        public init(clientToken: String? = UpdateDatasetRequest.idempotencyToken(), datasetDescription: String? = nil, datasetId: String, datasetName: String, datasetSource: DatasetSource) {
            self.clientToken = clientToken
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetName = datasetName
            self.datasetSource = datasetSource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.datasetDescription, forKey: .datasetDescription)
            request.encodePath(self.datasetId, key: "datasetId")
            try container.encode(self.datasetName, forKey: .datasetName)
            try container.encode(self.datasetSource, forKey: .datasetSource)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, max: 2048)
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, min: 1)
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, pattern: "^[a-zA-Z0-9 _\\-#$*!@]+$")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 139)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 13)
            try self.validate(self.datasetId, name: "datasetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$|^externalId:[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 256)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.datasetName, name: "datasetName", parent: name, pattern: "^[a-zA-Z0-9 _\\-#$*!@]+$")
            try self.datasetSource.validate(name: "\(name).datasetSource")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case datasetDescription = "datasetDescription"
            case datasetName = "datasetName"
            case datasetSource = "datasetSource"
        }
    }

    public struct UpdateDatasetResponse: AWSDecodableShape {
        /// The ARN of the dataset.  The format is arn:${Partition}:iotsitewise:${Region}:${Account}:dataset/${DatasetId}.
        public let datasetArn: String?
        /// The ID of the dataset.
        public let datasetId: String?
        /// The status of the dataset. This contains the state and any error messages.  State is UPDATING after a successfull call to this API, and any associated error message. The state is  ACTIVE when ready to use.
        public let datasetStatus: DatasetStatus?

        @inlinable
        public init(datasetArn: String? = nil, datasetId: String? = nil, datasetStatus: DatasetStatus? = nil) {
            self.datasetArn = datasetArn
            self.datasetId = datasetId
            self.datasetStatus = datasetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case datasetId = "datasetId"
            case datasetStatus = "datasetStatus"
        }
    }

    public struct UpdateGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        /// The JSON document that defines the configuration for the gateway capability. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway to be updated.
        public let gatewayId: String

        @inlinable
        public init(capabilityConfiguration: String, capabilityNamespace: String, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.capabilityConfiguration, forKey: .capabilityConfiguration)
            try container.encode(self.capabilityNamespace, forKey: .capabilityNamespace)
            request.encodePath(self.gatewayId, key: "gatewayId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, max: 10000000)
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration = "capabilityConfiguration"
            case capabilityNamespace = "capabilityNamespace"
        }
    }

    public struct UpdateGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    NOT_APPLICABLE – Synchronization is not required for this capability configuration. This is most common when integrating partner data sources, because the data integration is handled externally by the partner.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.    UNKNOWN – The synchronization status is currently unknown due to an undetermined or temporary error.   After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        @inlinable
        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        /// The ID of the gateway to update.
        public let gatewayId: String
        /// A unique name for the gateway.
        public let gatewayName: String

        @inlinable
        public init(gatewayId: String, gatewayName: String) {
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayId, key: "gatewayId")
            try container.encode(self.gatewayName, forKey: .gatewayName)
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName = "gatewayName"
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A new description for the portal.
        public let portalDescription: String?
        /// The ID of the portal to update.
        public let portalId: String
        public let portalLogoImage: Image?
        /// A new friendly name for the portal.
        public let portalName: String
        /// Define the type of portal. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalType: PortalType?
        /// The configuration entry associated with the specific portal type. The value for IoT SiteWise Monitor (Classic) is SITEWISE_PORTAL_V1. The value for IoT SiteWise Monitor (AI-aware) is SITEWISE_PORTAL_V2.
        public let portalTypeConfiguration: [String: PortalTypeEntry]?
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String

        @inlinable
        public init(alarms: Alarms? = nil, clientToken: String? = UpdatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalContactEmail: String, portalDescription: String? = nil, portalId: String, portalLogoImage: Image? = nil, portalName: String, portalType: PortalType? = nil, portalTypeConfiguration: [String: PortalTypeEntry]? = nil, roleArn: String) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLogoImage = portalLogoImage
            self.portalName = portalName
            self.portalType = portalType
            self.portalTypeConfiguration = portalTypeConfiguration
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.alarms, forKey: .alarms)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.notificationSenderEmail, forKey: .notificationSenderEmail)
            try container.encode(self.portalContactEmail, forKey: .portalContactEmail)
            try container.encodeIfPresent(self.portalDescription, forKey: .portalDescription)
            request.encodePath(self.portalId, key: "portalId")
            try container.encodeIfPresent(self.portalLogoImage, forKey: .portalLogoImage)
            try container.encode(self.portalName, forKey: .portalName)
            try container.encodeIfPresent(self.portalType, forKey: .portalType)
            try container.encodeIfPresent(self.portalTypeConfiguration, forKey: .portalTypeConfiguration)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "^[a-zA-Z0-9_\\-\\.\\+]+@[a-zA-Z0-9_\\-\\.\\+]+\\.[a-zA-Z]{2,}$")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "^[a-zA-Z0-9_\\-\\.\\+]+@[a-zA-Z0-9_\\-\\.\\+]+\\.[a-zA-Z]{2,}$")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.portalLogoImage?.validate(name: "\(name).portalLogoImage")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.portalTypeConfiguration?.forEach {
                try validate($0.key, name: "portalTypeConfiguration.key", parent: name, max: 128)
                try validate($0.key, name: "portalTypeConfiguration.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).portalTypeConfiguration[\"\($0.key)\"]")
            }
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-zA-Z0-9-:\\/_\\.\\+=,@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarms = "alarms"
            case clientToken = "clientToken"
            case notificationSenderEmail = "notificationSenderEmail"
            case portalContactEmail = "portalContactEmail"
            case portalDescription = "portalDescription"
            case portalLogoImage = "portalLogoImage"
            case portalName = "portalName"
            case portalType = "portalType"
            case portalTypeConfiguration = "portalTypeConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        @inlinable
        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus = "portalStatus"
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A new description for the project.
        public let projectDescription: String?
        /// The ID of the project to update.
        public let projectId: String
        /// A new friendly name for the project.
        public let projectName: String

        @inlinable
        public init(clientToken: String? = UpdateProjectRequest.idempotencyToken(), projectDescription: String? = nil, projectId: String, projectName: String) {
            self.clientToken = clientToken
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.projectDescription, forKey: .projectDescription)
            request.encodePath(self.projectId, key: "projectId")
            try container.encode(self.projectName, forKey: .projectName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The IAM Identity Center ID of the user.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct VariableValue: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. If the hierarchy has an external ID, you can specify externalId: followed by the external ID. For more information, see Using external IDs in the IoT SiteWise User Guide. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model. If the property has an external ID, you can specify externalId: followed by the external ID. For more information, see Using external IDs in the IoT SiteWise User Guide.
        public let propertyId: String?
        /// The path of the property.
        public let propertyPath: [AssetModelPropertyPathSegment]?

        @inlinable
        public init(hierarchyId: String? = nil, propertyId: String? = nil, propertyPath: [AssetModelPropertyPathSegment]? = nil) {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
            self.propertyPath = propertyPath
        }

        public func validate(name: String) throws {
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 256)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 256)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 1)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.propertyPath?.forEach {
                try $0.validate(name: "\(name).propertyPath[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyId = "hierarchyId"
            case propertyId = "propertyId"
            case propertyPath = "propertyPath"
        }
    }

    public struct Variant: AWSEncodableShape & AWSDecodableShape {
        /// Asset property data of type Boolean (true or false).
        public let booleanValue: Bool?
        ///  Asset property data of type double (floating point number). The min value is -10^10.  The max value is 10^10. Double.NaN is allowed.
        public let doubleValue: Double?
        /// Asset property data of type integer (whole number).
        public let integerValue: Int?
        /// The type of null asset property data with BAD and UNCERTAIN qualities.
        public let nullValue: PropertyValueNullValue?
        ///  Asset property data of type string (sequence of characters). The allowed pattern: "^$|[^\u0000-\u001F\u007F]+". The max length is 1024.
        public let stringValue: String?

        @inlinable
        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, integerValue: Int? = nil, nullValue: PropertyValueNullValue? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.nullValue = nullValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case integerValue = "integerValue"
            case nullValue = "nullValue"
            case stringValue = "stringValue"
        }
    }

    public struct WarmTierRetentionPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The number of days the data is stored in the warm tier.
        public let numberOfDays: Int?
        /// If set to true, the data is stored indefinitely in the warm tier.
        public let unlimited: Bool?

        @inlinable
        public init(numberOfDays: Int? = nil, unlimited: Bool? = nil) {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDays = "numberOfDays"
            case unlimited = "unlimited"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTSiteWise
public struct IoTSiteWiseErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictingOperationException = "ConflictingOperationException"
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case preconditionFailedException = "PreconditionFailedException"
        case queryTimeoutException = "QueryTimeoutException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTSiteWise
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
    public static var conflictingOperationException: Self { .init(.conflictingOperationException) }
    /// IoT SiteWise can't process your request right now. Try again later.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters. Check your request and try again.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// You've reached the limit for a resource. For example, this can occur if you're trying to associate more than the allowed number of child assets or attempting to create more than the allowed number of properties for an asset model. For more information, see Quotas in the IoT SiteWise User Guide.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The precondition in one or more of the request-header fields evaluated to FALSE.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The query timed out.
    public static var queryTimeoutException: Self { .init(.queryTimeoutException) }
    /// The resource already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The requested resource can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The requested service is unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Your request exceeded a rate limit. For example, you might have exceeded the number of IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so on. For more information, see Quotas in the IoT SiteWise User Guide.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You've reached the limit for the number of tags allowed for a resource. For more information, see Tag naming limits and requirements in the Amazon Web Services General Reference.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// You are not authorized.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The validation failed for this query.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTSiteWiseErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictingOperationException": IoTSiteWise.ConflictingOperationException.self,
        "PreconditionFailedException": IoTSiteWise.PreconditionFailedException.self,
        "ResourceAlreadyExistsException": IoTSiteWise.ResourceAlreadyExistsException.self,
        "TooManyTagsException": IoTSiteWise.TooManyTagsException.self
    ]
}

extension IoTSiteWiseErrorType: Equatable {
    public static func == (lhs: IoTSiteWiseErrorType, rhs: IoTSiteWiseErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTSiteWiseErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
