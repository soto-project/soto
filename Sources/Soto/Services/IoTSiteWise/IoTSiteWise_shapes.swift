//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension IoTSiteWise {
    // MARK: Enums

    public enum AggregateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case average = "AVERAGE"
        case count = "COUNT"
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        case standardDeviation = "STANDARD_DEVIATION"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AssetErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case propagating = "PROPAGATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AssetRelationshipType: String, CustomStringConvertible, Codable, _SotoSendable {
        case hierarchy = "HIERARCHY"
        public var description: String { return self.rawValue }
    }

    public enum AssetState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AuthMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum BatchEntryCompletionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case error = "ERROR"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyAggregatesErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchGetAssetPropertyValueHistoryErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDeniedException = "AccessDeniedException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        public var description: String { return self.rawValue }
    }

    public enum BatchPutAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDeniedException = "AccessDeniedException"
        case conflictingOperationException = "ConflictingOperationException"
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case timestampOutOfRangeException = "TimestampOutOfRangeException"
        public var description: String { return self.rawValue }
    }

    public enum CapabilitySyncStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case inSync = "IN_SYNC"
        case outOfSync = "OUT_OF_SYNC"
        case syncFailed = "SYNC_FAILED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum ColumnName: String, CustomStringConvertible, Codable, _SotoSendable {
        case alias = "ALIAS"
        case assetId = "ASSET_ID"
        case dataType = "DATA_TYPE"
        case propertyId = "PROPERTY_ID"
        case quality = "QUALITY"
        case timestampNanoOffset = "TIMESTAMP_NANO_OFFSET"
        case timestampSeconds = "TIMESTAMP_SECONDS"
        case value = "VALUE"
        public var description: String { return self.rawValue }
    }

    public enum ComputeLocation: String, CustomStringConvertible, Codable, _SotoSendable {
        case cloud = "CLOUD"
        case edge = "EDGE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DetailedErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case incompatibleComputeLocation = "INCOMPATIBLE_COMPUTE_LOCATION"
        case incompatibleForwardingConfiguration = "INCOMPATIBLE_FORWARDING_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum DisassociatedDataStorageState: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case kmsBasedEncryption = "KMS_BASED_ENCRYPTION"
        case sitewiseDefaultEncryption = "SITEWISE_DEFAULT_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalFailure = "INTERNAL_FAILURE"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ForwardingConfigState: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, _SotoSendable {
        case group = "GROUP"
        case iam = "IAM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ImageFileType: String, CustomStringConvertible, Codable, _SotoSendable {
        case png = "PNG"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetModelPropertiesFilter: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case base = "BASE"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetPropertiesFilter: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case base = "BASE"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetsFilter: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case topLevel = "TOP_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum ListBulkImportJobsFilter: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithFailures = "COMPLETED_WITH_FAILURES"
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ListTimeSeriesType: String, CustomStringConvertible, Codable, _SotoSendable {
        case associated = "ASSOCIATED"
        case disassociated = "DISASSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable, _SotoSendable {
        case error = "ERROR"
        case info = "INFO"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum MonitorErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalFailure = "INTERNAL_FAILURE"
        case limitExceeded = "LIMIT_EXCEEDED"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable, _SotoSendable {
        case administrator = "ADMINISTRATOR"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PortalState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PropertyDataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `struct` = "STRUCT"
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum PropertyNotificationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Quality: String, CustomStringConvertible, Codable, _SotoSendable {
        case bad = "BAD"
        case good = "GOOD"
        case uncertain = "UNCERTAIN"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case portal = "PORTAL"
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case multiLayerStorage = "MULTI_LAYER_STORAGE"
        case sitewiseDefaultStorage = "SITEWISE_DEFAULT_STORAGE"
        public var description: String { return self.rawValue }
    }

    public enum TimeOrdering: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TraversalDirection: String, CustomStringConvertible, Codable, _SotoSendable {
        case child = "CHILD"
        case parent = "PARENT"
        public var description: String { return self.rawValue }
    }

    public enum TraversalType: String, CustomStringConvertible, Codable, _SotoSendable {
        case pathToRoot = "PATH_TO_ROOT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPolicySummary: AWSDecodableShape {
        /// The date the access policy was created, in Unix epoch time.
        public let creationDate: Date?
        /// The ID of the access policy.
        public let id: String
        /// The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).
        public let identity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let permission: Permission
        /// The IoT SiteWise Monitor resource (a portal or project).
        public let resource: Resource

        public init(creationDate: Date? = nil, id: String, identity: Identity, lastUpdateDate: Date? = nil, permission: Permission, resource: Resource) {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case id
            case identity
            case lastUpdateDate
            case permission
            case resource
        }
    }

    public struct AggregatedValue: AWSDecodableShape {
        /// The quality of the aggregated data.
        public let quality: Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        public let timestamp: Date
        /// The value of the aggregates.
        public let value: Aggregates

        public init(quality: Quality? = nil, timestamp: Date, value: Aggregates) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case quality
            case timestamp
            case value
        }
    }

    public struct Aggregates: AWSDecodableShape {
        /// The average (mean) value of the time series over a time interval window.
        public let average: Double?
        /// The count of data points in the time series over a time interval window.
        public let count: Double?
        /// The maximum value of the time series over a time interval window.
        public let maximum: Double?
        /// The minimum value of the time series over a time interval window.
        public let minimum: Double?
        /// The standard deviation of the time series over a time interval window.
        public let standardDeviation: Double?
        /// The sum of the time series over a time interval window.
        public let sum: Double?

        public init(average: Double? = nil, count: Double? = nil, maximum: Double? = nil, minimum: Double? = nil, standardDeviation: Double? = nil, sum: Double? = nil) {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case average
            case count
            case maximum
            case minimum
            case standardDeviation
            case sum
        }
    }

    public struct Alarms: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        public let alarmRoleArn: String
        /// The ARN of the Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the IoT Events Developer Guide.
        public let notificationLambdaArn: String?

        public init(alarmRoleArn: String, notificationLambdaArn: String? = nil) {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, max: 1600)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, min: 1)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, pattern: ".*")
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, max: 1600)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, min: 1)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmRoleArn
            case notificationLambdaArn
        }
    }

    public struct AssetCompositeModel: AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        ///  The ID of the asset composite model.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset properties that this composite model defines.
        public let properties: [AssetProperty]
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, id: String? = nil, name: String, properties: [AssetProperty], type: String) {
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case id
            case name
            case properties
            case type
        }
    }

    public struct AssetErrorDetails: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The error code.
        public let code: AssetErrorCode
        /// The error message.
        public let message: String

        public init(assetId: String, code: AssetErrorCode, message: String) {
            self.assetId = assetId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case code
            case message
        }
    }

    public struct AssetHierarchy: AWSDecodableShape {
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The hierarchy name provided in the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(id: String? = nil, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
        }
    }

    public struct AssetHierarchyInfo: AWSDecodableShape {
        /// The ID of the child asset in this asset relationship.
        public let childAssetId: String?
        /// The ID of the parent asset in this asset relationship.
        public let parentAssetId: String?

        public init(childAssetId: String? = nil, parentAssetId: String? = nil) {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId
            case parentAssetId
        }
    }

    public struct AssetModelCompositeModel: AWSEncodableShape & AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        ///  The ID of the asset model composite model.
        public let id: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, id: String? = nil, name: String, properties: [AssetModelProperty]? = nil, type: String) {
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case id
            case name
            case properties
            case type
        }
    }

    public struct AssetModelCompositeModelDefinition: AWSEncodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, name: String, properties: [AssetModelPropertyDefinition]? = nil, type: String) {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case properties
            case type
        }
    }

    public struct AssetModelHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset model. All assets in this hierarchy must be instances of the childAssetModelId asset model.
        public let childAssetModelId: String
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The name of the asset model hierarchy that you specify by using the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(childAssetModelId: String, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId
            case id
            case name
        }
    }

    public struct AssetModelHierarchyDefinition: AWSEncodableShape {
        /// The ID of an asset model for this hierarchy.
        public let childAssetModelId: String
        /// The name of the asset model hierarchy definition (as specified in the CreateAssetModel or UpdateAssetModel API operation).
        public let name: String

        public init(childAssetModelId: String, name: String) {
            self.childAssetModelId = childAssetModelId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId
            case name
        }
    }

    public struct AssetModelProperty: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the asset model property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The ID of the asset model property.
        public let id: String?
        /// The name of the asset model property.
        public let name: String
        /// The property type (see PropertyType).
        public let type: PropertyType
        /// The unit of the asset model property, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, id: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType
            case dataTypeSpec
            case id
            case name
            case type
            case unit
        }
    }

    public struct AssetModelPropertyDefinition: AWSEncodableShape {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The name of the property definition.
        public let name: String
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        public let type: PropertyType
        /// The unit of the property definition, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.name = name
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType
            case dataTypeSpec
            case name
            case type
            case unit
        }
    }

    public struct AssetModelPropertySummary: AWSDecodableShape {
        ///  The ID of the composite model that contains the asset model property.
        public let assetModelCompositeModelId: String?
        /// The data type of the property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The ID of the property.
        public let id: String?
        /// The name of the property.
        public let name: String
        public let type: PropertyType
        /// The unit (such as Newtons or RPM) of the property.
        public let unit: String?

        public init(assetModelCompositeModelId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, id: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModelId
            case dataType
            case dataTypeSpec
            case id
            case name
            case type
            case unit
        }
    }

    public struct AssetModelStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current state of the asset model.
        public let state: AssetModelState

        public init(error: ErrorDetails? = nil, state: AssetModelState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct AssetModelSummary: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let arn: String
        /// The date the asset model was created, in Unix epoch time.
        public let creationDate: Date
        /// The asset model description.
        public let description: String
        /// The ID of the asset model (used with IoT SiteWise APIs).
        public let id: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset model.
        public let name: String
        /// The current status of the asset model.
        public let status: AssetModelStatus

        public init(arn: String, creationDate: Date, description: String, id: String, lastUpdateDate: Date, name: String, status: AssetModelStatus) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
            case status
        }
    }

    public struct AssetProperty: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The data type of the asset property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, id: String, name: String, notification: PropertyNotification? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.notification = notification
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case dataType
            case dataTypeSpec
            case id
            case name
            case notification
            case unit
        }
    }

    public struct AssetPropertySummary: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        ///  The ID of the composite model that contains the asset property.
        public let assetCompositeModelId: String?
        /// The ID of the property.
        public let id: String?
        public let notification: PropertyNotification?
        ///  The unit of measure (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, assetCompositeModelId: String? = nil, id: String? = nil, notification: PropertyNotification? = nil, unit: String? = nil) {
            self.alias = alias
            self.assetCompositeModelId = assetCompositeModelId
            self.id = id
            self.notification = notification
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case assetCompositeModelId
            case id
            case notification
            case unit
        }
    }

    public struct AssetPropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// The quality of the asset property value.
        public let quality: Quality?
        /// The timestamp of the asset property value.
        public let timestamp: TimeInNanos
        /// The value of the asset property (see Variant).
        public let value: Variant

        public init(quality: Quality? = nil, timestamp: TimeInNanos, value: Variant) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.timestamp.validate(name: "\(name).timestamp")
        }

        private enum CodingKeys: String, CodingKey {
            case quality
            case timestamp
            case value
        }
    }

    public struct AssetRelationshipSummary: AWSDecodableShape {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public let hierarchyInfo: AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:    HIERARCHY â€“ The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        public let relationshipType: AssetRelationshipType

        public init(hierarchyInfo: AssetHierarchyInfo? = nil, relationshipType: AssetRelationshipType) {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyInfo
            case relationshipType
        }
    }

    public struct AssetStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current status of the asset.
        public let state: AssetState

        public init(error: ErrorDetails? = nil, state: AssetState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct AssetSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create this asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A description for the asset.
        public let description: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, description: String? = nil, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case assetModelId
            case creationDate
            case description
            case hierarchies
            case id
            case lastUpdateDate
            case name
            case status
        }
    }

    public struct AssociateAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId"))
        ]

        /// The ID of the parent asset.
        public let assetId: String
        /// The ID of the child asset to be associated.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = AssociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId
            case clientToken
            case hierarchyId
        }
    }

    public struct AssociateTimeSeriesToAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alias", location: .querystring("alias")),
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId"))
        ]

        /// The alias that identifies the time series.
        public let alias: String
        /// The ID of the asset in which the asset property was created.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property.
        public let propertyId: String

        public init(alias: String, assetId: String, clientToken: String? = AssociateTimeSeriesToAssetPropertyRequest.idempotencyToken(), propertyId: String) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct AssociatedAssetsSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create the asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A description for the asset.
        public let description: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, description: String? = nil, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case assetModelId
            case creationDate
            case description
            case hierarchies
            case id
            case lastUpdateDate
            case name
            case status
        }
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see Updating attribute values in the IoT SiteWise User Guide.
        public let defaultValue: String?

        public init(defaultValue: String? = nil) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue
        }
    }

    public struct BatchAssociateProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri("projectId"))
        ]

        /// The IDs of the assets to be associated to the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project to which to associate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchAssociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds
            case clientToken
        }
    }

    public struct BatchAssociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchDisassociateProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri("projectId"))
        ]

        /// The IDs of the assets to be disassociated from the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project from which to disassociate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchDisassociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds
            case clientToken
        }
    }

    public struct BatchDisassociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchGetAssetPropertyAggregatesEntry: AWSEncodableShape {
        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "^1m|1h|1d$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateTypes
            case assetId
            case endDate
            case entryId
            case propertyAlias
            case propertyId
            case qualities
            case resolution
            case startDate
            case timeOrdering
        }
    }

    public struct BatchGetAssetPropertyAggregatesErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyAggregatesErrorCode
        /// The associated error message.
        public let errorMessage: String

        public init(entryId: String, errorCode: BatchGetAssetPropertyAggregatesErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId
            case errorCode
            case errorMessage
        }
    }

    public struct BatchGetAssetPropertyAggregatesErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyAggregatesErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        public init(errorCode: BatchGetAssetPropertyAggregatesErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorTimestamp
        }
    }

    public struct BatchGetAssetPropertyAggregatesRequest: AWSEncodableShape {
        /// The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyAggregatesEntry]
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is less than 1 MB.   The number of data points in the result set is less than the value of maxResults. The maximum value of maxResults is 4000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(entries: [BatchGetAssetPropertyAggregatesEntry], maxResults: Int? = nil, nextToken: String? = nil) {
            self.entries = entries
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries
            case maxResults
            case nextToken
        }
    }

    public struct BatchGetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyAggregatesErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request.  because these entries had been completely processed by previous paginated requests.  Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyAggregatesSkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyAggregatesSuccessEntry]

        public init(errorEntries: [BatchGetAssetPropertyAggregatesErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyAggregatesSkippedEntry], successEntries: [BatchGetAssetPropertyAggregatesSuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
            case nextToken
            case skippedEntries
            case successEntries
        }
    }

    public struct BatchGetAssetPropertyAggregatesSkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyAggregates API.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyAggregatesErrorInfo?

        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyAggregatesErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus
            case entryId
            case errorInfo
        }
    }

    public struct BatchGetAssetPropertyAggregatesSuccessEntry: AWSDecodableShape {
        /// The requested aggregated asset property values (for example, average, minimum, and maximum).
        public let aggregatedValues: [AggregatedValue]
        /// The ID of the entry.
        public let entryId: String

        public init(aggregatedValues: [AggregatedValue], entryId: String) {
            self.aggregatedValues = aggregatedValues
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues
            case entryId
        }
    }

    public struct BatchGetAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?

        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case entryId
            case propertyAlias
            case propertyId
        }
    }

    public struct BatchGetAssetPropertyValueErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String

        public init(entryId: String, errorCode: BatchGetAssetPropertyValueErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId
            case errorCode
            case errorMessage
        }
    }

    public struct BatchGetAssetPropertyValueErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        public init(errorCode: BatchGetAssetPropertyValueErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorTimestamp
        }
    }

    public struct BatchGetAssetPropertyValueHistoryEntry: AWSEncodableShape {
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The ID of the entry.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(assetId: String? = nil, endDate: Date? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case endDate
            case entryId
            case propertyAlias
            case propertyId
            case qualities
            case startDate
            case timeOrdering
        }
    }

    public struct BatchGetAssetPropertyValueHistoryErrorEntry: AWSDecodableShape {
        /// The ID of the entry.
        public let entryId: String
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueHistoryErrorCode
        /// The associated error message.
        public let errorMessage: String

        public init(entryId: String, errorCode: BatchGetAssetPropertyValueHistoryErrorCode, errorMessage: String) {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entryId
            case errorCode
            case errorMessage
        }
    }

    public struct BatchGetAssetPropertyValueHistoryErrorInfo: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchGetAssetPropertyValueHistoryErrorCode
        /// The date the error occurred, in Unix epoch time.
        public let errorTimestamp: Date

        public init(errorCode: BatchGetAssetPropertyValueHistoryErrorCode, errorTimestamp: Date) {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorTimestamp
        }
    }

    public struct BatchGetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        /// The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyValueHistoryEntry]
        /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.   The size of the result set is less than 1 MB.   The number of data points in the result set is less than the value of maxResults. The maximum value of maxResults is 4000.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(entries: [BatchGetAssetPropertyValueHistoryEntry], maxResults: Int? = nil, nextToken: String? = nil) {
            self.entries = entries
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries
            case maxResults
            case nextToken
        }
    }

    public struct BatchGetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyValueHistoryErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request.  because these entries had been completely processed by previous paginated requests.  Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyValueHistorySkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyValueHistorySuccessEntry]

        public init(errorEntries: [BatchGetAssetPropertyValueHistoryErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyValueHistorySkippedEntry], successEntries: [BatchGetAssetPropertyValueHistorySuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
            case nextToken
            case skippedEntries
            case successEntries
        }
    }

    public struct BatchGetAssetPropertyValueHistorySkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyValueHistory API.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyValueHistoryErrorInfo?

        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyValueHistoryErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus
            case entryId
            case errorInfo
        }
    }

    public struct BatchGetAssetPropertyValueHistorySuccessEntry: AWSDecodableShape {
        /// The requested historical values for the specified asset property.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The ID of the entry.
        public let entryId: String

        public init(assetPropertyValueHistory: [AssetPropertyValue], entryId: String) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory
            case entryId
        }
    }

    public struct BatchGetAssetPropertyValueRequest: AWSEncodableShape {
        /// The list of asset property value entries for the batch get request. You can specify up to 16 entries per request.
        public let entries: [BatchGetAssetPropertyValueEntry]
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(entries: [BatchGetAssetPropertyValueEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries
            case nextToken
        }
    }

    public struct BatchGetAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchGetAssetPropertyValueErrorEntry]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list of entries that were not processed by this batch request.  because these entries had been completely processed by previous paginated requests.  Each skipped entry contains the entryId of the entry that skipped.
        public let skippedEntries: [BatchGetAssetPropertyValueSkippedEntry]
        /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
        public let successEntries: [BatchGetAssetPropertyValueSuccessEntry]

        public init(errorEntries: [BatchGetAssetPropertyValueErrorEntry], nextToken: String? = nil, skippedEntries: [BatchGetAssetPropertyValueSkippedEntry], successEntries: [BatchGetAssetPropertyValueSuccessEntry]) {
            self.errorEntries = errorEntries
            self.nextToken = nextToken
            self.skippedEntries = skippedEntries
            self.successEntries = successEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
            case nextToken
            case skippedEntries
            case successEntries
        }
    }

    public struct BatchGetAssetPropertyValueSkippedEntry: AWSDecodableShape {
        /// The completion status of each entry that is associated with the BatchGetAssetPropertyValue request.
        public let completionStatus: BatchEntryCompletionStatus
        /// The ID of the entry.
        public let entryId: String
        /// The error information, such as the error code and the timestamp.
        public let errorInfo: BatchGetAssetPropertyValueErrorInfo?

        public init(completionStatus: BatchEntryCompletionStatus, entryId: String, errorInfo: BatchGetAssetPropertyValueErrorInfo? = nil) {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus
            case entryId
            case errorInfo
        }
    }

    public struct BatchGetAssetPropertyValueSuccessEntry: AWSDecodableShape {
        public let assetPropertyValue: AssetPropertyValue?
        /// The ID of the entry.
        public let entryId: String

        public init(assetPropertyValue: AssetPropertyValue? = nil, entryId: String) {
            self.assetPropertyValue = assetPropertyValue
            self.entryId = entryId
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValue
            case entryId
        }
    }

    public struct BatchPutAssetPropertyError: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchPutAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String
        /// A list of timestamps for each  error, if any.
        public let timestamps: [TimeInNanos]

        public init(errorCode: BatchPutAssetPropertyValueErrorCode, errorMessage: String, timestamps: [TimeInNanos]) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case timestamps
        }
    }

    public struct BatchPutAssetPropertyErrorEntry: AWSDecodableShape {
        /// The ID of the failed entry.
        public let entryId: String
        /// The list of update property value errors.
        public let errors: [BatchPutAssetPropertyError]

        public init(entryId: String, errors: [BatchPutAssetPropertyError]) {
            self.entryId = entryId
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case entryId
            case errors
        }
    }

    public struct BatchPutAssetPropertyValueRequest: AWSEncodableShape {
        /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
        public let entries: [PutAssetPropertyValueEntry]

        public init(entries: [PutAssetPropertyValueEntry]) {
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries
        }
    }

    public struct BatchPutAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchPutAssetPropertyErrorEntry]

        public init(errorEntries: [BatchPutAssetPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
        }
    }

    public struct CompositeModelProperty: AWSDecodableShape {
        public let assetProperty: Property
        ///  The ID of the composite model that contains the property.
        public let id: String?
        /// The name of the property.
        public let name: String
        /// The type of the composite model that defines this property.
        public let type: String

        public init(assetProperty: Property, id: String? = nil, name: String, type: String) {
            self.assetProperty = assetProperty
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assetProperty
            case id
            case name
            case type
        }
    }

    public struct ConfigurationErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        /// The error message.
        public let message: String

        public init(code: ErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct ConfigurationStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ConfigurationErrorDetails?
        /// The current state of the configuration.
        public let state: ConfigurationState

        public init(error: ConfigurationErrorDetails? = nil, state: ConfigurationState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {
        /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the access policy. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity
            case accessPolicyPermission
            case accessPolicyResource
            case clientToken
            case tags
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyArn: String, accessPolicyId: String) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyId = accessPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn
            case accessPolicyId
        }
    }

    public struct CreateAssetModelRequest: AWSEncodableShape {
        /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
        public let assetModelCompositeModels: [AssetModelCompositeModelDefinition]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelPropertyDefinition]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset model. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetModelCompositeModels: [AssetModelCompositeModelDefinition]? = nil, assetModelDescription: String? = nil, assetModelHierarchies: [AssetModelHierarchyDefinition]? = nil, assetModelName: String, assetModelProperties: [AssetModelPropertyDefinition]? = nil, clientToken: String? = CreateAssetModelRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels
            case assetModelDescription
            case assetModelHierarchies
            case assetModelName
            case assetModelProperties
            case clientToken
            case tags
        }
    }

    public struct CreateAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The ID of the asset model. You can use this ID when you call other IoT SiteWise APIs.
        public let assetModelId: String
        /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelId: String, assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelId = assetModelId
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn
            case assetModelId
            case assetModelStatus
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {
        /// A description for the asset.
        public let assetDescription: String?
        /// The ID of the asset model from which to create the asset.
        public let assetModelId: String
        /// A friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetDescription: String? = nil, assetModelId: String, assetName: String, clientToken: String? = CreateAssetRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetDescription = assetDescription
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, max: 2048)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, min: 1)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetDescription
            case assetModelId
            case assetName
            case clientToken
            case tags
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The ID of the asset. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
        public let assetId: String
        /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetId: String, assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetId = assetId
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn
            case assetId
            case assetStatus
        }
    }

    public struct CreateBulkImportJobRequest: AWSEncodableShape {
        /// The Amazon S3 destination where errors associated with the job creation request are saved.
        public let errorReportLocation: ErrorReportLocation
        /// The files in the specified Amazon S3 bucket that contain your data.
        public let files: [File]
        /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
        public let jobConfiguration: JobConfiguration
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The ARN of the IAM role that allows IoT SiteWise to read Amazon S3 data.
        public let jobRoleArn: String

        public init(errorReportLocation: ErrorReportLocation, files: [File], jobConfiguration: JobConfiguration, jobName: String, jobRoleArn: String) {
            self.errorReportLocation = errorReportLocation
            self.files = files
            self.jobConfiguration = jobConfiguration
            self.jobName = jobName
            self.jobRoleArn = jobRoleArn
        }

        public func validate(name: String) throws {
            try self.errorReportLocation.validate(name: "\(name).errorReportLocation")
            try self.files.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.validate(self.jobName, name: "jobName", parent: name, max: 256)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, max: 1600)
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, min: 1)
            try self.validate(self.jobRoleArn, name: "jobRoleArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorReportLocation
            case files
            case jobConfiguration
            case jobName
            case jobRoleArn
        }
    }

    public struct CreateBulkImportJobResponse: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The status of the bulk import job can be one of following values.    PENDING â€“ IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED â€“ The bulk import job has been canceled.    RUNNING â€“ IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED â€“ IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED â€“ IoT SiteWise couldn't process your request to import data from Amazon S3.  You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES â€“ IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let jobStatus: JobStatus

        public init(jobId: String, jobName: String, jobStatus: JobStatus) {
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
            case jobName
            case jobStatus
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The dashboard definition specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A description for the dashboard.
        public let dashboardDescription: String?
        /// A friendly name for the dashboard.
        public let dashboardName: String
        /// The ID of the project in which to create the dashboard.
        public let projectId: String
        /// A list of key-value pairs that contain metadata for the dashboard. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardName: String, projectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardName = dashboardName
            self.projectId = projectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204_800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: "^.+$")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case dashboardDefinition
            case dashboardDescription
            case dashboardName
            case projectId
            case tags
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardArn: String, dashboardId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn
            case dashboardId
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// A unique, friendly name for the gateway.
        public let gatewayName: String
        /// The gateway's platform. You can only specify one platform in a gateway.
        public let gatewayPlatform: GatewayPlatform
        /// A list of key-value pairs that contain metadata for the gateway. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(gatewayName: String, gatewayPlatform: GatewayPlatform, tags: [String: String]? = nil) {
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.gatewayPlatform.validate(name: "\(name).gatewayPlatform")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName
            case gatewayPlatform
            case tags
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise APIs.
        public let gatewayId: String

        public init(gatewayArn: String, gatewayId: String) {
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn
            case gatewayId
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.  You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.  For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.  If you use the IoT Events managed Lambda function to manage your emails, you must verify the sender email address in Amazon SES.
        public let notificationSenderEmail: String?
        /// The service to use to authenticate users to the portal. Choose from the following options:    SSO â€“ The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see Enabling IAM Identity Center in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.    IAM â€“ The portal uses Identity and Access Management to authenticate users and manage user permissions.   You can't change this value after you create a portal. Default: SSO
        public let portalAuthMode: AuthMode?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A description for the portal.
        public let portalDescription: String?
        /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
        public let portalLogoImageFile: ImageFile?
        /// A friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String
        /// A list of key-value pairs that contain metadata for the portal. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(alarms: Alarms? = nil, clientToken: String? = CreatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalAuthMode: AuthMode? = nil, portalContactEmail: String, portalDescription: String? = nil, portalLogoImageFile: ImageFile? = nil, portalName: String, roleArn: String, tags: [String: String]? = nil) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalAuthMode = portalAuthMode
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalLogoImageFile = portalLogoImageFile
            self.portalName = portalName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.portalLogoImageFile?.validate(name: "\(name).portalLogoImageFile")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alarms
            case clientToken
            case notificationSenderEmail
            case portalAuthMode
            case portalContactEmail
            case portalDescription
            case portalLogoImageFile
            case portalName
            case roleArn
            case tags
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The ID of the created portal.
        public let portalId: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the  IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus
        /// The associated IAM Identity Center application ID, if the portal uses IAM Identity Center.
        public let ssoApplicationId: String

        public init(portalArn: String, portalId: String, portalStartUrl: String, portalStatus: PortalStatus, ssoApplicationId: String) {
            self.portalArn = portalArn
            self.portalId = portalId
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.ssoApplicationId = ssoApplicationId
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn
            case portalId
            case portalStartUrl
            case portalStatus
            case ssoApplicationId
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal in which to create the project.
        public let portalId: String
        /// A description for the project.
        public let projectDescription: String?
        /// A friendly name for the project.
        public let projectName: String
        /// A list of key-value pairs that contain metadata for the project. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), portalId: String, projectDescription: String? = nil, projectName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.portalId = portalId
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case portalId
            case projectDescription
            case projectName
            case tags
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The ID of the project.
        public let projectId: String

        public init(projectArn: String, projectId: String) {
            self.projectArn = projectArn
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn
            case projectId
        }
    }

    public struct Csv: AWSEncodableShape & AWSDecodableShape {
        /// The column names specified in the .csv file.
        public let columnNames: [ColumnName]?

        public init(columnNames: [ColumnName]? = nil) {
            self.columnNames = columnNames
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames
        }
    }

    public struct CustomerManagedS3Storage: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        public let roleArn: String
        /// The ARN of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see Amazon S3 resources in the Amazon Simple Storage Service User Guide.
        public let s3ResourceArn: String

        public init(roleArn: String, s3ResourceArn: String) {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, max: 1600)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, min: 1)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn
            case s3ResourceArn
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The date the dashboard was created, in Unix epoch time.
        public let creationDate: Date?
        /// The dashboard's description.
        public let description: String?
        /// The ID of the dashboard.
        public let id: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the dashboard
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri("accessPolicyId")),
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken"))
        ]

        /// The ID of the access policy to be deleted.
        public let accessPolicyId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri("assetModelId")),
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken"))
        ]

        /// The ID of the asset model to delete.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelId: String, clientToken: String? = DeleteAssetModelRequest.idempotencyToken()) {
            self.assetModelId = assetModelId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken"))
        ]

        /// The ID of the asset to delete.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetId: String, clientToken: String? = DeleteAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("dashboardId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the dashboard to delete.
        public let dashboardId: String

        public init(clientToken: String? = DeleteDashboardRequest.idempotencyToken(), dashboardId: String) {
            self.clientToken = clientToken
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri("gatewayId"))
        ]

        /// The ID of the gateway to delete.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "portalId", location: .uri("portalId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal to delete.
        public let portalId: String

        public init(clientToken: String? = DeletePortalRequest.idempotencyToken(), portalId: String) {
            self.clientToken = clientToken
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "projectId", location: .uri("projectId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectId: String) {
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTimeSeriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alias", location: .querystring("alias")),
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId"))
        ]

        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property.
        public let propertyId: String?

        public init(alias: String? = nil, assetId: String? = nil, clientToken: String? = DeleteTimeSeriesRequest.idempotencyToken(), propertyId: String? = nil) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct DescribeAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri("accessPolicyId"))
        ]

        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyId: String) {
            self.accessPolicyId = accessPolicyId
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The date the access policy was created, in Unix epoch time.
        public let accessPolicyCreationDate: Date
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity (IAM Identity Center user, IAM Identity Center group, or IAM user) to which this access policy applies.
        public let accessPolicyIdentity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let accessPolicyLastUpdateDate: Date
        /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
        public let accessPolicyResource: Resource

        public init(accessPolicyArn: String, accessPolicyCreationDate: Date, accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyLastUpdateDate: Date, accessPolicyPermission: Permission, accessPolicyResource: Resource) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyCreationDate = accessPolicyCreationDate
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn
            case accessPolicyCreationDate
            case accessPolicyId
            case accessPolicyIdentity
            case accessPolicyLastUpdateDate
            case accessPolicyPermission
            case accessPolicyResource
        }
    }

    public struct DescribeAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri("assetModelId")),
            AWSMemberEncoding(label: "excludeProperties", location: .querystring("excludeProperties"))
        ]

        /// The ID of the asset model.
        public let assetModelId: String
        ///  Whether or not to exclude asset model properties from the response.
        public let excludeProperties: Bool?

        public init(assetModelId: String, excludeProperties: Bool? = nil) {
            self.assetModelId = assetModelId
            self.excludeProperties = excludeProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The list of composite asset models for the asset model.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// The date the asset model was created, in Unix epoch time.
        public let assetModelCreationDate: Date
        /// The asset model's description.
        public let assetModelDescription: String
        /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
        public let assetModelHierarchies: [AssetModelHierarchy]
        /// The ID of the asset model.
        public let assetModelId: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let assetModelLastUpdateDate: Date
        /// The name of the asset model.
        public let assetModelName: String
        /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
        public let assetModelProperties: [AssetModelProperty]
        /// The current status of the asset model, which contains a state and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelCreationDate: Date, assetModelDescription: String, assetModelHierarchies: [AssetModelHierarchy], assetModelId: String, assetModelLastUpdateDate: Date, assetModelName: String, assetModelProperties: [AssetModelProperty], assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelCreationDate = assetModelCreationDate
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelLastUpdateDate = assetModelLastUpdateDate
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn
            case assetModelCompositeModels
            case assetModelCreationDate
            case assetModelDescription
            case assetModelHierarchies
            case assetModelId
            case assetModelLastUpdateDate
            case assetModelName
            case assetModelProperties
            case assetModelStatus
        }
    }

    public struct DescribeAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "propertyId", location: .uri("propertyId"))
        ]

        /// The ID of the asset.
        public let assetId: String
        /// The ID of the asset property.
        public let propertyId: String

        public init(assetId: String, propertyId: String) {
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetPropertyResponse: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The ID of the asset model.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
        public let assetProperty: Property?
        /// The composite asset model that declares this asset property, if this asset property exists in a composite model.
        public let compositeModel: CompositeModelProperty?

        public init(assetId: String, assetModelId: String, assetName: String, assetProperty: Property? = nil, compositeModel: CompositeModelProperty? = nil) {
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperty = assetProperty
            self.compositeModel = compositeModel
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case assetModelId
            case assetName
            case assetProperty
            case compositeModel
        }
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "excludeProperties", location: .querystring("excludeProperties"))
        ]

        /// The ID of the asset.
        public let assetId: String
        ///  Whether or not to exclude asset properties from the response.
        public let excludeProperties: Bool?

        public init(assetId: String, excludeProperties: Bool? = nil) {
            self.assetId = assetId
            self.excludeProperties = excludeProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The composite models for the asset.
        public let assetCompositeModels: [AssetCompositeModel]?
        /// The date the asset was created, in Unix epoch time.
        public let assetCreationDate: Date
        /// A description for the asset.
        public let assetDescription: String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let assetHierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let assetId: String
        /// The date the asset was last updated, in Unix epoch time.
        public let assetLastUpdateDate: Date
        /// The ID of the asset model that was used to create the asset.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
        public let assetProperties: [AssetProperty]
        /// The current status of the asset, which contains a state and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetCompositeModels: [AssetCompositeModel]? = nil, assetCreationDate: Date, assetDescription: String? = nil, assetHierarchies: [AssetHierarchy], assetId: String, assetLastUpdateDate: Date, assetModelId: String, assetName: String, assetProperties: [AssetProperty], assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetCompositeModels = assetCompositeModels
            self.assetCreationDate = assetCreationDate
            self.assetDescription = assetDescription
            self.assetHierarchies = assetHierarchies
            self.assetId = assetId
            self.assetLastUpdateDate = assetLastUpdateDate
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperties = assetProperties
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn
            case assetCompositeModels
            case assetCreationDate
            case assetDescription
            case assetHierarchies
            case assetId
            case assetLastUpdateDate
            case assetModelId
            case assetName
            case assetProperties
            case assetStatus
        }
    }

    public struct DescribeBulkImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri("jobId"))
        ]

        /// The ID of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBulkImportJobResponse: AWSDecodableShape {
        /// The Amazon S3 destination where errors associated with the job creation request are saved.
        public let errorReportLocation: ErrorReportLocation
        /// The files in the specified Amazon S3 bucket that contain your data.
        public let files: [File]
        /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
        public let jobConfiguration: JobConfiguration
        /// The date the job was created, in Unix epoch TIME.
        public let jobCreationDate: Date
        /// The ID of the job.
        public let jobId: String
        /// The date the job was last updated, in Unix epoch time.
        public let jobLastUpdateDate: Date
        /// The unique name that helps identify the job request.
        public let jobName: String
        /// The ARN of the IAM role that allows IoT SiteWise to read Amazon S3 data.
        public let jobRoleArn: String
        /// The status of the bulk import job can be one of following values.    PENDING â€“ IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED â€“ The bulk import job has been canceled.    RUNNING â€“ IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED â€“ IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED â€“ IoT SiteWise couldn't process your request to import data from Amazon S3.  You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES â€“ IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let jobStatus: JobStatus

        public init(errorReportLocation: ErrorReportLocation, files: [File], jobConfiguration: JobConfiguration, jobCreationDate: Date, jobId: String, jobLastUpdateDate: Date, jobName: String, jobRoleArn: String, jobStatus: JobStatus) {
            self.errorReportLocation = errorReportLocation
            self.files = files
            self.jobConfiguration = jobConfiguration
            self.jobCreationDate = jobCreationDate
            self.jobId = jobId
            self.jobLastUpdateDate = jobLastUpdateDate
            self.jobName = jobName
            self.jobRoleArn = jobRoleArn
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case errorReportLocation
            case files
            case jobConfiguration
            case jobCreationDate
            case jobId
            case jobLastUpdateDate
            case jobName
            case jobRoleArn
            case jobStatus
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dashboardId", location: .uri("dashboardId"))
        ]

        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardId: String) {
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The date the dashboard was created, in Unix epoch time.
        public let dashboardCreationDate: Date
        /// The dashboard's definition JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// The dashboard's description.
        public let dashboardDescription: String?
        /// The ID of the dashboard.
        public let dashboardId: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let dashboardLastUpdateDate: Date
        /// The name of the dashboard.
        public let dashboardName: String
        /// The ID of the project that the dashboard is in.
        public let projectId: String

        public init(dashboardArn: String, dashboardCreationDate: Date, dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardLastUpdateDate: Date, dashboardName: String, projectId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardCreationDate = dashboardCreationDate
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardLastUpdateDate = dashboardLastUpdateDate
            self.dashboardName = dashboardName
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn
            case dashboardCreationDate
            case dashboardDefinition
            case dashboardDescription
            case dashboardId
            case dashboardLastUpdateDate
            case dashboardName
            case projectId
        }
    }

    public struct DescribeDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The key ARN of the customer managed key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case encryptionType
            case kmsKeyArn
        }
    }

    public struct DescribeGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "capabilityNamespace", location: .uri("capabilityNamespace")),
            AWSMemberEncoding(label: "gatewayId", location: .uri("gatewayId"))
        ]

        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityNamespace: String, gatewayId: String) {
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The JSON document that defines the gateway capability's configuration. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC â€“ The gateway is running the capability configuration.    OUT_OF_SYNC â€“ The gateway hasn't received the capability configuration.    SYNC_FAILED â€“ The gateway rejected the capability configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration
            case capabilityNamespace
            case capabilitySyncStatus
            case gatewayId
        }
    }

    public struct DescribeGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri("gatewayId"))
        ]

        /// The ID of the gateway device.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayResponse: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the gateway.
        public let gatewayName: String
        /// The gateway's platform.
        public let gatewayPlatform: GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayArn: String, gatewayCapabilitySummaries: [GatewayCapabilitySummary], gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayArn = gatewayArn
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case gatewayArn
            case gatewayCapabilitySummaries
            case gatewayId
            case gatewayName
            case gatewayPlatform
            case lastUpdateDate
        }
    }

    public struct DescribeLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeLoggingOptionsResponse: AWSDecodableShape {
        /// The current logging options.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions
        }
    }

    public struct DescribePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri("portalId"))
        ]

        /// The ID of the portal.
        public let portalId: String

        public init(portalId: String) {
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePortalResponse: AWSDecodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
        public let alarms: Alarms?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The service to use to authenticate users to the portal.
        public let portalAuthMode: AuthMode?
        /// The IAM Identity Center application generated client ID (used with IAM Identity Center APIs). IoT SiteWise includes portalClientId for only portals that use IAM Identity Center to authenticate users.
        public let portalClientId: String
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// The date the portal was created, in Unix epoch time.
        public let portalCreationDate: Date
        /// The portal's description.
        public let portalDescription: String?
        /// The ID of the portal.
        public let portalId: String
        /// The date the portal was last updated, in Unix epoch time.
        public let portalLastUpdateDate: Date
        /// The portal's logo image, which is available at a URL.
        public let portalLogoImageLocation: ImageLocation?
        /// The name of the portal.
        public let portalName: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the  IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The current status of the portal, which contains a state and any error message.
        public let portalStatus: PortalStatus
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?

        public init(alarms: Alarms? = nil, notificationSenderEmail: String? = nil, portalArn: String, portalAuthMode: AuthMode? = nil, portalClientId: String, portalContactEmail: String, portalCreationDate: Date, portalDescription: String? = nil, portalId: String, portalLastUpdateDate: Date, portalLogoImageLocation: ImageLocation? = nil, portalName: String, portalStartUrl: String, portalStatus: PortalStatus, roleArn: String? = nil) {
            self.alarms = alarms
            self.notificationSenderEmail = notificationSenderEmail
            self.portalArn = portalArn
            self.portalAuthMode = portalAuthMode
            self.portalClientId = portalClientId
            self.portalContactEmail = portalContactEmail
            self.portalCreationDate = portalCreationDate
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLastUpdateDate = portalLastUpdateDate
            self.portalLogoImageLocation = portalLogoImageLocation
            self.portalName = portalName
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case alarms
            case notificationSenderEmail
            case portalArn
            case portalAuthMode
            case portalClientId
            case portalContactEmail
            case portalCreationDate
            case portalDescription
            case portalId
            case portalLastUpdateDate
            case portalLogoImageLocation
            case portalName
            case portalStartUrl
            case portalStatus
            case roleArn
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri("projectId"))
        ]

        /// The ID of the project.
        public let projectId: String

        public init(projectId: String) {
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The ID of the portal that the project is in.
        public let portalId: String
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The date the project was created, in Unix epoch time.
        public let projectCreationDate: Date
        /// The project's description.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The date the project was last updated, in Unix epoch time.
        public let projectLastUpdateDate: Date
        /// The name of the project.
        public let projectName: String

        public init(portalId: String, projectArn: String, projectCreationDate: Date, projectDescription: String? = nil, projectId: String, projectLastUpdateDate: Date, projectName: String) {
            self.portalId = portalId
            self.projectArn = projectArn
            self.projectCreationDate = projectCreationDate
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectLastUpdateDate = projectLastUpdateDate
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case portalId
            case projectArn
            case projectCreationDate
            case projectDescription
            case projectId
            case projectLastUpdateDate
            case projectName
        }
    }

    public struct DescribeStorageConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties.  The disassociatedDataStorage can be one of the following values:    ENABLED â€“ IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED â€“ IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams  in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// The date the storage configuration was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data.  The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE â€“ IoT SiteWise saves your data into the hot tier.  The hot tier is a service-managed database.    MULTI_LAYER_STORAGE â€“ IoT SiteWise saves your data in both the cold tier and the hot tier.  The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType

        public init(configurationStatus: ConfigurationStatus, disassociatedDataStorage: DisassociatedDataStorageState? = nil, lastUpdateDate: Date? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType) {
            self.configurationStatus = configurationStatus
            self.disassociatedDataStorage = disassociatedDataStorage
            self.lastUpdateDate = lastUpdateDate
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case disassociatedDataStorage
            case lastUpdateDate
            case multiLayerStorage
            case retentionPeriod
            case storageType
        }
    }

    public struct DescribeTimeSeriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alias", location: .querystring("alias")),
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId"))
        ]

        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The ID of the asset property.
        public let propertyId: String?

        public init(alias: String? = nil, assetId: String? = nil, propertyId: String? = nil) {
            self.alias = alias
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTimeSeriesResponse: AWSDecodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        public let dataType: PropertyDataType
        /// The data type of the structure for this time series. This parameter is required for time series  that have the STRUCT data type. The options for this parameter depend on the type of the composite model  in which you created the asset property that is associated with your time series.  Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The date that the time series was created, in Unix epoch time.
        public let timeSeriesCreationDate: Date
        /// The ID of the time series.
        public let timeSeriesId: String
        /// The date that the time series was last updated, in Unix epoch time.
        public let timeSeriesLastUpdateDate: Date

        public init(alias: String? = nil, assetId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, propertyId: String? = nil, timeSeriesCreationDate: Date, timeSeriesId: String, timeSeriesLastUpdateDate: Date) {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case assetId
            case dataType
            case dataTypeSpec
            case propertyId
            case timeSeriesCreationDate
            case timeSeriesId
            case timeSeriesLastUpdateDate
        }
    }

    public struct DetailedError: AWSDecodableShape {
        /// The error code.
        public let code: DetailedErrorCode
        /// The error message.
        public let message: String

        public init(code: DetailedErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct DisassociateAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId"))
        ]

        /// The ID of the parent asset from which to disassociate the child asset.
        public let assetId: String
        /// The ID of the child asset to disassociate.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = DisassociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId
            case clientToken
            case hierarchyId
        }
    }

    public struct DisassociateTimeSeriesFromAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alias", location: .querystring("alias")),
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId"))
        ]

        /// The alias that identifies the time series.
        public let alias: String
        /// The ID of the asset in which the asset property was created.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the asset property.
        public let propertyId: String

        public init(alias: String, assetId: String, clientToken: String? = DisassociateTimeSeriesFromAssetPropertyRequest.idempotencyToken(), propertyId: String) {
            self.alias = alias
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        ///  A list of detailed errors.
        public let details: [DetailedError]?
        /// The error message.
        public let message: String

        public init(code: ErrorCode, details: [DetailedError]? = nil, message: String) {
            self.code = code
            self.details = details
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case details
            case message
        }
    }

    public struct ErrorReportLocation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.
        public let bucket: String
        /// Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see Organizing objects using prefixes in the Amazon Simple Storage Service User Guide.
        public let prefix: String

        public init(bucket: String, prefix: String) {
            self.bucket = bucket
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case prefix
        }
    }

    public struct ExpressionVariable: AWSEncodableShape & AWSDecodableShape {
        /// The friendly name of the variable to be used in the expression.
        public let name: String
        /// The variable that identifies an asset property from which to use values.
        public let value: VariableValue

        public init(name: String, value: VariableValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct File: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket from which data is imported.
        public let bucket: String
        /// The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.
        public let key: String
        /// The version ID to identify a specific version of the Amazon S3 object that contains your data.
        public let versionId: String?

        public init(bucket: String, key: String, versionId: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case key
            case versionId
        }
    }

    public struct FileFormat: AWSEncodableShape & AWSDecodableShape {
        /// The .csv file format.
        public let csv: Csv?

        public init(csv: Csv? = nil) {
            self.csv = csv
        }

        private enum CodingKeys: String, CodingKey {
            case csv
        }
    }

    public struct ForwardingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The forwarding state for the given property.
        public let state: ForwardingConfigState

        public init(state: ForwardingConfigState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct GatewayCapabilitySummary: AWSDecodableShape {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC â€“ The gateway is running the capability configuration.    OUT_OF_SYNC â€“ The gateway hasn't received the capability configuration.    SYNC_FAILED â€“ The gateway rejected the capability configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace
            case capabilitySyncStatus
        }
    }

    public struct GatewayPlatform: AWSEncodableShape & AWSDecodableShape {
        /// A gateway that runs on IoT Greengrass.
        public let greengrass: Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public let greengrassV2: GreengrassV2?

        public init(greengrass: Greengrass? = nil, greengrassV2: GreengrassV2? = nil) {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
        }

        public func validate(name: String) throws {
            try self.greengrass?.validate(name: "\(name).greengrass")
            try self.greengrassV2?.validate(name: "\(name).greengrassV2")
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass
            case greengrassV2
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the asset.
        public let gatewayName: String
        public let gatewayPlatform: GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil, gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case gatewayCapabilitySummaries
            case gatewayId
            case gatewayName
            case gatewayPlatform
            case lastUpdateDate
        }
    }

    public struct GetAssetPropertyAggregatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aggregateTypes", location: .querystring("aggregateTypes")),
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "endDate", location: .querystring("endDate")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring("propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId")),
            AWSMemberEncoding(label: "qualities", location: .querystring("qualities")),
            AWSMemberEncoding(label: "resolution", location: .querystring("resolution")),
            AWSMemberEncoding(label: "startDate", location: .querystring("startDate")),
            AWSMemberEncoding(label: "timeOrdering", location: .querystring("timeOrdering"))
        ]

        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The maximum number of results to return for each paginated request. Default: 100
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "^1m|1h|1d$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// The requested aggregated values.
        public let aggregatedValues: [AggregatedValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(aggregatedValues: [AggregatedValue], nextToken: String? = nil) {
            self.aggregatedValues = aggregatedValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues
            case nextToken
        }
    }

    public struct GetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "endDate", location: .querystring("endDate")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring("propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId")),
            AWSMemberEncoding(label: "qualities", location: .querystring("qualities")),
            AWSMemberEncoding(label: "startDate", location: .querystring("startDate")),
            AWSMemberEncoding(label: "timeOrdering", location: .querystring("timeOrdering"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The maximum number of results to return for each paginated request. Default: 100
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(assetId: String? = nil, endDate: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The asset property's value history.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetPropertyValueHistory: [AssetPropertyValue], nextToken: String? = nil) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory
            case nextToken
        }
    }

    public struct GetAssetPropertyValueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring("propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?

        public init(assetId: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueResponse: AWSDecodableShape {
        /// The current asset property value.
        public let propertyValue: AssetPropertyValue?

        public init(propertyValue: AssetPropertyValue? = nil) {
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValue
        }
    }

    public struct GetInterpolatedAssetPropertyValuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "endTimeInSeconds", location: .querystring("endTimeInSeconds")),
            AWSMemberEncoding(label: "endTimeOffsetInNanos", location: .querystring("endTimeOffsetInNanos")),
            AWSMemberEncoding(label: "intervalInSeconds", location: .querystring("intervalInSeconds")),
            AWSMemberEncoding(label: "intervalWindowInSeconds", location: .querystring("intervalWindowInSeconds")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring("propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring("propertyId")),
            AWSMemberEncoding(label: "quality", location: .querystring("quality")),
            AWSMemberEncoding(label: "startTimeInSeconds", location: .querystring("startTimeInSeconds")),
            AWSMemberEncoding(label: "startTimeOffsetInNanos", location: .querystring("startTimeOffsetInNanos")),
            AWSMemberEncoding(label: "type", location: .querystring("type"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let endTimeInSeconds: Int64
        /// The nanosecond offset converted from endTimeInSeconds.
        public let endTimeOffsetInNanos: Int?
        /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
        public let intervalInSeconds: Int64
        /// The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.    If you specify a value for the intervalWindowInSeconds parameter, the value for the type parameter must be LINEAR_INTERPOLATION.   If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.    For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.
        public let intervalWindowInSeconds: Int64?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
        public let quality: Quality
        /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let startTimeInSeconds: Int64
        /// The nanosecond offset converted from startTimeInSeconds.
        public let startTimeOffsetInNanos: Int?
        /// The interpolation type. Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION     LINEAR_INTERPOLATION â€“ Estimates missing data using linear interpolation. For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.    LOCF_INTERPOLATION â€“ Estimates missing data using last observation carried forward interpolation If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found. For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
        public let type: String

        public init(assetId: String? = nil, endTimeInSeconds: Int64, endTimeOffsetInNanos: Int? = nil, intervalInSeconds: Int64, intervalWindowInSeconds: Int64? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, quality: Quality, startTimeInSeconds: Int64, startTimeOffsetInNanos: Int? = nil, type: String) {
            self.assetId = assetId
            self.endTimeInSeconds = endTimeInSeconds
            self.endTimeOffsetInNanos = endTimeOffsetInNanos
            self.intervalInSeconds = intervalInSeconds
            self.intervalWindowInSeconds = intervalWindowInSeconds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.quality = quality
            self.startTimeInSeconds = startTimeInSeconds
            self.startTimeOffsetInNanos = startTimeOffsetInNanos
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, max: 9_223_372_036_854_774)
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, min: 1)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, max: 999_999_999)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, max: 320_000_000)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, min: 1)
            try self.validate(self.intervalWindowInSeconds, name: "intervalWindowInSeconds", parent: name, max: 320_000_000)
            try self.validate(self.intervalWindowInSeconds, name: "intervalWindowInSeconds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, max: 9_223_372_036_854_774)
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, min: 1)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, max: 999_999_999)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInterpolatedAssetPropertyValuesResponse: AWSDecodableShape {
        /// The requested interpolated values.
        public let interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue], nextToken: String? = nil) {
            self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case interpolatedAssetPropertyValues
            case nextToken
        }
    }

    public struct Greengrass: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Greengrass group. For more information about how to find a group's ARN, see ListGroups and GetGroup in the IoT Greengrass API Reference.
        public let groupArn: String

        public init(groupArn: String) {
            self.groupArn = groupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.groupArn, name: "groupArn", parent: name, max: 1600)
            try self.validate(self.groupArn, name: "groupArn", parent: name, min: 1)
            try self.validate(self.groupArn, name: "groupArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case groupArn
        }
    }

    public struct GreengrassV2: AWSEncodableShape & AWSDecodableShape {
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        public let coreDeviceThingName: String

        public init(coreDeviceThingName: String) {
            self.coreDeviceThingName = coreDeviceThingName
        }

        public func validate(name: String) throws {
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, max: 128)
            try self.validate(self.coreDeviceThingName, name: "coreDeviceThingName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case coreDeviceThingName
        }
    }

    public struct GroupIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The IAM Identity Center ID of the group.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct IAMRoleIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role. For more information, see IAM ARNs in the IAM User Guide.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct IAMUserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide.  If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct Identity: AWSEncodableShape & AWSDecodableShape {
        /// An IAM Identity Center group identity.
        public let group: GroupIdentity?
        /// An IAM role identity.
        public let iamRole: IAMRoleIdentity?
        /// An IAM user identity.
        public let iamUser: IAMUserIdentity?
        /// An IAM Identity Center user identity.
        public let user: UserIdentity?

        public init(group: GroupIdentity? = nil, iamRole: IAMRoleIdentity? = nil, iamUser: IAMUserIdentity? = nil, user: UserIdentity? = nil) {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }

        public func validate(name: String) throws {
            try self.group?.validate(name: "\(name).group")
            try self.iamRole?.validate(name: "\(name).iamRole")
            try self.iamUser?.validate(name: "\(name).iamUser")
            try self.user?.validate(name: "\(name).user")
        }

        private enum CodingKeys: String, CodingKey {
            case group
            case iamRole
            case iamUser
            case user
        }
    }

    public struct Image: AWSEncodableShape {
        public let file: ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public let id: String?

        public init(file: ImageFile? = nil, id: String? = nil) {
            self.file = file
            self.id = id
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case id
        }
    }

    public struct ImageFile: AWSEncodableShape {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        public let data: AWSBase64Data
        /// The file type of the image.
        public let type: ImageFileType

        public init(data: AWSBase64Data, type: ImageFileType) {
            self.data = data
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 1_500_000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data
            case type
        }
    }

    public struct ImageLocation: AWSDecodableShape {
        /// The ID of the image.
        public let id: String
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        public let url: String

        public init(id: String, url: String) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case url
        }
    }

    public struct InterpolatedAssetPropertyValue: AWSDecodableShape {
        public let timestamp: TimeInNanos
        public let value: Variant

        public init(timestamp: TimeInNanos, value: Variant) {
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp
            case value
        }
    }

    public struct JobConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file format of the data in Amazon S3.
        public let fileFormat: FileFormat

        public init(fileFormat: FileFormat) {
            self.fileFormat = fileFormat
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The ID of the job.
        public let id: String
        /// The unique name that helps identify the job request.
        public let name: String
        /// The status of the bulk import job can be one of following values.    PENDING â€“ IoT SiteWise is waiting for the current bulk import job to finish.    CANCELLED â€“ The bulk import job has been canceled.    RUNNING â€“ IoT SiteWise is processing your request to import your data from Amazon S3.    COMPLETED â€“ IoT SiteWise successfully completed your request to import data from Amazon S3.    FAILED â€“ IoT SiteWise couldn't process your request to import data from Amazon S3.  You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.    COMPLETED_WITH_FAILURES â€“ IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        public let status: JobStatus

        public init(id: String, name: String, status: JobStatus) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case status
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "iamArn", location: .querystring("iamArn")),
            AWSMemberEncoding(label: "identityId", location: .querystring("identityId")),
            AWSMemberEncoding(label: "identityType", location: .querystring("identityType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "resourceId", location: .querystring("resourceId")),
            AWSMemberEncoding(label: "resourceType", location: .querystring("resourceType"))
        ]

        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide. This parameter is required if you specify IAM for identityType.
        public let iamArn: String?
        /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
        public let identityId: String?
        /// The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify identityId.
        public let identityType: IdentityType?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the resource. This parameter is required if you specify resourceType.
        public let resourceId: String?
        /// The type of resource (portal or project). This parameter is required if you specify resourceId.
        public let resourceType: ResourceType?

        public init(iamArn: String? = nil, identityId: String? = nil, identityType: IdentityType? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.iamArn = iamArn
            self.identityId = identityId
            self.identityType = identityType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.iamArn, name: "iamArn", parent: name, max: 1600)
            try self.validate(self.iamArn, name: "iamArn", parent: name, min: 1)
            try self.validate(self.iamArn, name: "iamArn", parent: name, pattern: ".*")
            try self.validate(self.identityId, name: "identityId", parent: name, max: 256)
            try self.validate(self.identityId, name: "identityId", parent: name, min: 1)
            try self.validate(self.identityId, name: "identityId", parent: name, pattern: "^\\S+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {
        /// A list that summarizes each access policy.
        public let accessPolicySummaries: [AccessPolicySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(accessPolicySummaries: [AccessPolicySummary], nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries
            case nextToken
        }
    }

    public struct ListAssetModelPropertiesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri("assetModelId")),
            AWSMemberEncoding(label: "filter", location: .querystring("filter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The ID of the asset model.
        public let assetModelId: String
        ///  Filters the requested list of asset model properties. You can choose one of the following options:    ALL â€“ The list includes all asset model properties for a given asset model ID.     BASE â€“ The list includes only base asset model properties for a given asset model ID.    Default: BASE
        public let filter: ListAssetModelPropertiesFilter?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String, filter: ListAssetModelPropertiesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelPropertiesResponse: AWSDecodableShape {
        /// A list that summarizes the properties associated with the specified asset model.
        public let assetModelPropertySummaries: [AssetModelPropertySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelPropertySummaries: [AssetModelPropertySummary], nextToken: String? = nil) {
            self.assetModelPropertySummaries = assetModelPropertySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelPropertySummaries
            case nextToken
        }
    }

    public struct ListAssetModelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelsResponse: AWSDecodableShape {
        /// A list that summarizes each asset model.
        public let assetModelSummaries: [AssetModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelSummaries: [AssetModelSummary], nextToken: String? = nil) {
            self.assetModelSummaries = assetModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelSummaries
            case nextToken
        }
    }

    public struct ListAssetPropertiesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "filter", location: .querystring("filter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The ID of the asset.
        public let assetId: String
        ///  Filters the requested list of asset properties. You can choose one of the following options:    ALL â€“ The list includes all asset properties for a given asset model ID.     BASE â€“ The list includes only base asset properties for a given asset model ID.    Default: BASE
        public let filter: ListAssetPropertiesFilter?
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetId: String, filter: ListAssetPropertiesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetId = assetId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetPropertiesResponse: AWSDecodableShape {
        /// A list that summarizes the properties associated with the specified asset.
        public let assetPropertySummaries: [AssetPropertySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetPropertySummaries: [AssetPropertySummary], nextToken: String? = nil) {
            self.assetPropertySummaries = assetPropertySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertySummaries
            case nextToken
        }
    }

    public struct ListAssetRelationshipsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "traversalType", location: .querystring("traversalType"))
        ]

        /// The ID of the asset.
        public let assetId: String
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of traversal to use to identify asset relationships. Choose the following option:    PATH_TO_ROOT â€“ Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
        public let traversalType: TraversalType

        public init(assetId: String, maxResults: Int? = nil, nextToken: String? = nil, traversalType: TraversalType) {
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalType = traversalType
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetRelationshipsResponse: AWSDecodableShape {
        /// A list that summarizes each asset relationship.
        public let assetRelationshipSummaries: [AssetRelationshipSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetRelationshipSummaries: [AssetRelationshipSummary], nextToken: String? = nil) {
            self.assetRelationshipSummaries = assetRelationshipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetRelationshipSummaries
            case nextToken
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .querystring("assetModelId")),
            AWSMemberEncoding(label: "filter", location: .querystring("filter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter.
        public let assetModelId: String?
        /// The filter for the requested list of assets. Choose one of the following options:    ALL â€“ The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.    TOP_LEVEL â€“ The list includes only top-level assets in the asset hierarchy tree.   Default: ALL
        public let filter: ListAssetsFilter?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String? = nil, filter: ListAssetsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {
        /// A list that summarizes each asset.
        public let assetSummaries: [AssetSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssetSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries
            case nextToken
        }
    }

    public struct ListAssociatedAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "hierarchyId", location: .querystring("hierarchyId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "traversalDirection", location: .querystring("traversalDirection"))
        ]

        /// The ID of the asset to query.
        public let assetId: String
        /// The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the DescribeAsset or DescribeAssetModel operations. This parameter is required if you choose CHILD for traversalDirection. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The direction to list associated assets. Choose one of the following options:    CHILD â€“ The list includes all child assets associated to the asset. The hierarchyId parameter is required if you choose CHILD.    PARENT â€“ The list includes the asset's parent asset.   Default: CHILD
        public let traversalDirection: TraversalDirection?

        public init(assetId: String, hierarchyId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, traversalDirection: TraversalDirection? = nil) {
            self.assetId = assetId
            self.hierarchyId = hierarchyId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalDirection = traversalDirection
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedAssetsResponse: AWSDecodableShape {
        /// A list that summarizes the associated assets.
        public let assetSummaries: [AssociatedAssetsSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssociatedAssetsSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries
            case nextToken
        }
    }

    public struct ListBulkImportJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "filter", location: .querystring("filter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// You can use a filter to select the bulk import jobs that you want to retrieve.
        public let filter: ListBulkImportJobsFilter?
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(filter: ListBulkImportJobsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBulkImportJobsResponse: AWSDecodableShape {
        /// One or more job summaries to list.
        public let jobSummaries: [JobSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(jobSummaries: [JobSummary], nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries
            case nextToken
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "projectId", location: .querystring("projectId"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        /// A list that summarizes each dashboard in the project.
        public let dashboardSummaries: [DashboardSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(dashboardSummaries: [DashboardSummary], nextToken: String? = nil) {
            self.dashboardSummaries = dashboardSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaries
            case nextToken
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// A list that summarizes each gateway.
        public let gatewaySummaries: [GatewaySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(gatewaySummaries: [GatewaySummary], nextToken: String? = nil) {
            self.gatewaySummaries = gatewaySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewaySummaries
            case nextToken
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each portal.
        public let portalSummaries: [PortalSummary]?

        public init(nextToken: String? = nil, portalSummaries: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portalSummaries = portalSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case portalSummaries
        }
    }

    public struct ListProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "projectId", location: .uri("projectId"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectAssetsResponse: AWSDecodableShape {
        /// A list that contains the IDs of each asset associated with the project.
        public let assetIds: [String]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetIds: [String], nextToken: String? = nil) {
            self.assetIds = assetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds
            case nextToken
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "portalId", location: .querystring("portalId"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the portal.
        public let portalId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, portalId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each project in the portal.
        public let projectSummaries: [ProjectSummary]

        public init(nextToken: String? = nil, projectSummaries: [ProjectSummary]) {
            self.nextToken = nextToken
            self.projectSummaries = projectSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case projectSummaries
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring("resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListTimeSeriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasPrefix", location: .querystring("aliasPrefix")),
            AWSMemberEncoding(label: "assetId", location: .querystring("assetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "timeSeriesType", location: .querystring("timeSeriesType"))
        ]

        /// The alias prefix of the time series.
        public let aliasPrefix: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of the time series. The time series type can be one of the following values:    ASSOCIATED â€“ The time series is associated with an asset property.    DISASSOCIATED â€“ The time series isn't associated with any asset property.
        public let timeSeriesType: ListTimeSeriesType?

        public init(aliasPrefix: String? = nil, assetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, timeSeriesType: ListTimeSeriesType? = nil) {
            self.aliasPrefix = aliasPrefix
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.timeSeriesType = timeSeriesType
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasPrefix, name: "aliasPrefix", parent: name, min: 1)
            try self.validate(self.aliasPrefix, name: "aliasPrefix", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTimeSeriesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// One or more time series summaries to list.
        public let timeSeriesSummaries: [TimeSeriesSummary]

        public init(nextToken: String? = nil, timeSeriesSummaries: [TimeSeriesSummary]) {
            self.nextToken = nextToken
            self.timeSeriesSummaries = timeSeriesSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case timeSeriesSummaries = "TimeSeriesSummaries"
        }
    }

    public struct LoggingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The IoT SiteWise logging verbosity level.
        public let level: LoggingLevel

        public init(level: LoggingLevel) {
            self.level = level
        }

        private enum CodingKeys: String, CodingKey {
            case level
        }
    }

    public struct Measurement: AWSEncodableShape & AWSDecodableShape {
        /// The processing configuration for the given measurement property.  You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud.  By default, measurements are forwarded to the cloud.
        public let processingConfig: MeasurementProcessingConfig?

        public init(processingConfig: MeasurementProcessingConfig? = nil) {
            self.processingConfig = processingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case processingConfig
        }
    }

    public struct MeasurementProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The forwarding configuration for the given measurement property.
        public let forwardingConfig: ForwardingConfig

        public init(forwardingConfig: ForwardingConfig) {
            self.forwardingConfig = forwardingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case forwardingConfig
        }
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The processing configuration for the given metric property.  You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud.  By default, metrics are forwarded to the cloud.
        public let processingConfig: MetricProcessingConfig?
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        public let window: MetricWindow

        public init(expression: String, processingConfig: MetricProcessingConfig? = nil, variables: [ExpressionVariable], window: MetricWindow) {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
            try self.window.validate(name: "\(name).window")
        }

        private enum CodingKeys: String, CodingKey {
            case expression
            case processingConfig
            case variables
            case window
        }
    }

    public struct MetricProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The compute location for the given metric property.
        public let computeLocation: ComputeLocation

        public init(computeLocation: ComputeLocation) {
            self.computeLocation = computeLocation
        }

        private enum CodingKeys: String, CodingKey {
            case computeLocation
        }
    }

    public struct MetricWindow: AWSEncodableShape & AWSDecodableShape {
        /// The tumbling time interval window.
        public let tumbling: TumblingWindow?

        public init(tumbling: TumblingWindow? = nil) {
            self.tumbling = tumbling
        }

        public func validate(name: String) throws {
            try self.tumbling?.validate(name: "\(name).tumbling")
        }

        private enum CodingKeys: String, CodingKey {
            case tumbling
        }
    }

    public struct MonitorErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: MonitorErrorCode?
        /// The error message.
        public let message: String?

        public init(code: MonitorErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct MultiLayerStorage: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about a customer managed Amazon S3 bucket.
        public let customerManagedS3Storage: CustomerManagedS3Storage

        public init(customerManagedS3Storage: CustomerManagedS3Storage) {
            self.customerManagedS3Storage = customerManagedS3Storage
        }

        public func validate(name: String) throws {
            try self.customerManagedS3Storage.validate(name: "\(name).customerManagedS3Storage")
        }

        private enum CodingKeys: String, CodingKey {
            case customerManagedS3Storage
        }
    }

    public struct PortalResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the portal.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct PortalStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: MonitorErrorDetails?
        /// The current state of the portal.
        public let state: PortalState

        public init(error: MonitorErrorDetails? = nil, state: PortalState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct PortalSummary: AWSDecodableShape {
        /// The date the portal was created, in Unix epoch time.
        public let creationDate: Date?
        /// The portal's description.
        public let description: String?
        /// The ID of the portal.
        public let id: String
        /// The date the portal was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the portal.
        public let name: String
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the  IoT SiteWise console to get a URL that you can use to access the portal.
        public let startUrl: String
        public let status: PortalStatus

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String, roleArn: String? = nil, startUrl: String, status: PortalStatus) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
            case roleArn
            case startUrl
            case status
        }
    }

    public struct ProjectResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the project.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The date the project was created, in Unix epoch time.
        public let creationDate: Date?
        /// The project's description.
        public let description: String?
        /// The ID of the project.
        public let id: String
        /// The date the project was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the project.
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
        }
    }

    public struct Property: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The property data type.
        public let dataType: PropertyDataType
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The property type (see PropertyType). A property contains one type.
        public let type: PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, id: String, name: String, notification: PropertyNotification? = nil, type: PropertyType? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case dataType
            case id
            case name
            case notification
            case type
            case unit
        }
    }

    public struct PropertyNotification: AWSDecodableShape {
        /// The current notification state.
        public let state: PropertyNotificationState
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        public let topic: String

        public init(state: PropertyNotificationState, topic: String) {
            self.state = state
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case state
            case topic
        }
    }

    public struct PropertyType: AWSEncodableShape & AWSDecodableShape {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an IIoT wind turbine.
        public let attribute: Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public let measurement: Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public let metric: Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public let transform: Transform?

        public init(attribute: Attribute? = nil, measurement: Measurement? = nil, metric: Metric? = nil, transform: Transform? = nil) {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }

        public func validate(name: String) throws {
            try self.attribute?.validate(name: "\(name).attribute")
            try self.metric?.validate(name: "\(name).metric")
            try self.transform?.validate(name: "\(name).transform")
        }

        private enum CodingKeys: String, CodingKey {
            case attribute
            case measurement
            case metric
            case transform
        }
    }

    public struct PutAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset to update.
        public let assetId: String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property for this entry.
        public let propertyId: String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        public let propertyValues: [AssetPropertyValue]

        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, propertyValues: [AssetPropertyValue]) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.propertyValues.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case entryId
            case propertyAlias
            case propertyId
            case propertyValues
        }
    }

    public struct PutDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ID of the customer managed key used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyId: String?

        public init(encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
            case kmsKeyId
        }
    }

    public struct PutDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ARN of the KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case encryptionType
            case kmsKeyArn
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// The logging options to set.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStorageConfigurationRequest: AWSEncodableShape {
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties.  The disassociatedDataStorage can be one of the following values:    ENABLED â€“ IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED â€“ IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams  in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type,  you must specify a MultiLayerStorage object.
        public let multiLayerStorage: MultiLayerStorage?
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data.  The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE â€“ IoT SiteWise saves your data into the hot tier.  The hot tier is a service-managed database.    MULTI_LAYER_STORAGE â€“ IoT SiteWise saves your data in both the cold tier and the hot tier.  The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType

        public init(disassociatedDataStorage: DisassociatedDataStorageState? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType) {
            self.disassociatedDataStorage = disassociatedDataStorage
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.multiLayerStorage?.validate(name: "\(name).multiLayerStorage")
            try self.retentionPeriod?.validate(name: "\(name).retentionPeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case disassociatedDataStorage
            case multiLayerStorage
            case retentionPeriod
            case storageType
        }
    }

    public struct PutStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties.  The disassociatedDataStorage can be one of the following values:    ENABLED â€“ IoT SiteWise accepts time series that aren't associated with asset properties.  After the disassociatedDataStorage is enabled, you can't disable it.     DISABLED â€“ IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.   For more information, see Data streams  in the IoT SiteWise User Guide.
        public let disassociatedDataStorage: DisassociatedDataStorageState?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        public let retentionPeriod: RetentionPeriod?
        /// The storage tier that you specified for your data.  The storageType parameter can be one of the following values:    SITEWISE_DEFAULT_STORAGE â€“ IoT SiteWise saves your data into the hot tier.  The hot tier is a service-managed database.    MULTI_LAYER_STORAGE â€“ IoT SiteWise saves your data in both the cold tier and the hot tier.  The cold tier is a customer-managed Amazon S3 bucket.
        public let storageType: StorageType

        public init(configurationStatus: ConfigurationStatus, disassociatedDataStorage: DisassociatedDataStorageState? = nil, multiLayerStorage: MultiLayerStorage? = nil, retentionPeriod: RetentionPeriod? = nil, storageType: StorageType) {
            self.configurationStatus = configurationStatus
            self.disassociatedDataStorage = disassociatedDataStorage
            self.multiLayerStorage = multiLayerStorage
            self.retentionPeriod = retentionPeriod
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case disassociatedDataStorage
            case multiLayerStorage
            case retentionPeriod
            case storageType
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// A portal resource.
        public let portal: PortalResource?
        /// A project resource.
        public let project: ProjectResource?

        public init(portal: PortalResource? = nil, project: ProjectResource? = nil) {
            self.portal = portal
            self.project = project
        }

        public func validate(name: String) throws {
            try self.portal?.validate(name: "\(name).portal")
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case portal
            case project
        }
    }

    public struct RetentionPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The number of days that your data is kept.  If you specified a value for this parameter, the unlimited parameter must be false.
        public let numberOfDays: Int?
        /// If true, your data is kept indefinitely.  If configured to true, you must not specify a value for the numberOfDays parameter.
        public let unlimited: Bool?

        public init(numberOfDays: Int? = nil, unlimited: Bool? = nil) {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDays, name: "numberOfDays", parent: name, min: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDays
            case unlimited
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring("resourceArn"))
        ]

        /// The ARN of the resource to tag.
        public let resourceArn: String
        /// A list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeInNanos: AWSEncodableShape & AWSDecodableShape {
        /// The nanosecond offset from timeInSeconds.
        public let offsetInNanos: Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        public let timeInSeconds: Int64

        public init(offsetInNanos: Int? = nil, timeInSeconds: Int64) {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, max: 999_999_999)
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, min: 0)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, max: 9_223_372_036_854_774)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case offsetInNanos
            case timeInSeconds
        }
    }

    public struct TimeSeriesSummary: AWSDecodableShape {
        /// The alias that identifies the time series.
        public let alias: String?
        /// The ID of the asset in which the asset property was created.
        public let assetId: String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        public let dataType: PropertyDataType
        /// The data type of the structure for this time series. This parameter is required for time series  that have the STRUCT data type. The options for this parameter depend on the type of the composite model  in which you created the asset property that is associated with your time series.  Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The date that the time series was created, in Unix epoch time.
        public let timeSeriesCreationDate: Date
        /// The ID of the time series.
        public let timeSeriesId: String
        /// The date that the time series was last updated, in Unix epoch time.
        public let timeSeriesLastUpdateDate: Date

        public init(alias: String? = nil, assetId: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, propertyId: String? = nil, timeSeriesCreationDate: Date, timeSeriesId: String, timeSeriesLastUpdateDate: Date) {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case assetId
            case dataType
            case dataTypeSpec
            case propertyId
            case timeSeriesCreationDate
            case timeSeriesId
            case timeSeriesLastUpdateDate
        }
    }

    public struct Transform: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The processing configuration for the given transform property.  You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud.  You can also configure transforms to be computed at the edge or in the cloud.
        public let processingConfig: TransformProcessingConfig?
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]

        public init(expression: String, processingConfig: TransformProcessingConfig? = nil, variables: [ExpressionVariable]) {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression
            case processingConfig
            case variables
        }
    }

    public struct TransformProcessingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The compute location for the given transform property.
        public let computeLocation: ComputeLocation
        public let forwardingConfig: ForwardingConfig?

        public init(computeLocation: ComputeLocation, forwardingConfig: ForwardingConfig? = nil) {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case computeLocation
            case forwardingConfig
        }
    }

    public struct TumblingWindow: AWSEncodableShape & AWSDecodableShape {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on.  When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        public let interval: String
        /// The offset for the tumbling window. The offset parameter accepts the following:   The offset time. For example, if you specify 18h for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.   If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.     The ISO 8601 format. For example, if you specify PT18H for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.   If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.     The 24-hour clock. For example, if you specify 00:03:00 for offset, 5m for interval, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC).    The offset time zone. For example, if you specify 2021-07-23T18:00-08 for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:   If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.   If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.
        public let offset: String?

        public init(interval: String, offset: String? = nil) {
            self.interval = interval
            self.offset = offset
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, max: 23)
            try self.validate(self.interval, name: "interval", parent: name, min: 2)
            try self.validate(self.offset, name: "offset", parent: name, max: 25)
            try self.validate(self.offset, name: "offset", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case interval
            case offset
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource to untag.
        public let resourceArn: String
        /// A list of keys for tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri("accessPolicyId"))
        ]

        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity
            case accessPolicyPermission
            case accessPolicyResource
            case clientToken
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri("assetModelId"))
        ]

        /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchy]?
        /// The ID of the asset model to update.
        public let assetModelId: String
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The updated property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelProperty]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelDescription: String? = nil, assetModelHierarchies: [AssetModelHierarchy]? = nil, assetModelId: String, assetModelName: String, assetModelProperties: [AssetModelProperty]? = nil, clientToken: String? = UpdateAssetModelRequest.idempotencyToken()) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels
            case assetModelDescription
            case assetModelHierarchies
            case assetModelName
            case assetModelProperties
            case clientToken
        }
    }

    public struct UpdateAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus
        }
    }

    public struct UpdateAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId")),
            AWSMemberEncoding(label: "propertyId", location: .uri("propertyId"))
        ]

        /// The ID of the asset to be updated.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
        public let propertyAlias: String?
        /// The ID of the asset property to be updated.
        public let propertyId: String
        /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see Interacting with other services in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
        public let propertyNotificationState: PropertyNotificationState?
        /// The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
        public let propertyUnit: String?

        public init(assetId: String, clientToken: String? = UpdateAssetPropertyRequest.idempotencyToken(), propertyAlias: String? = nil, propertyId: String, propertyNotificationState: PropertyNotificationState? = nil, propertyUnit: String? = nil) {
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyNotificationState = propertyNotificationState
            self.propertyUnit = propertyUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, max: 256)
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, min: 1)
            try self.validate(self.propertyUnit, name: "propertyUnit", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case propertyAlias
            case propertyNotificationState
            case propertyUnit
        }
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri("assetId"))
        ]

        /// A description for the asset.
        public let assetDescription: String?
        /// The ID of the asset to update.
        public let assetId: String
        /// A friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetDescription: String? = nil, assetId: String, assetName: String, clientToken: String? = UpdateAssetRequest.idempotencyToken()) {
            self.assetDescription = assetDescription
            self.assetId = assetId
            self.assetName = assetName
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, max: 2048)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, min: 1)
            try self.validate(self.assetDescription, name: "assetDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetDescription
            case assetName
            case clientToken
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dashboardId", location: .uri("dashboardId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The new dashboard definition, as specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A new description for the dashboard.
        public let dashboardDescription: String?
        /// The ID of the dashboard to update.
        public let dashboardId: String
        /// A new friendly name for the dashboard.
        public let dashboardName: String

        public init(clientToken: String? = UpdateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardName: String) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardName = dashboardName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204_800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: "^.+$")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case dashboardDefinition
            case dashboardDescription
            case dashboardName
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri("gatewayId"))
        ]

        /// The JSON document that defines the configuration for the gateway capability. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway to be updated.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, max: 104_857_600)
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration
            case capabilityNamespace
        }
    }

    public struct UpdateGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC â€“ The gateway is running the capability configuration.    OUT_OF_SYNC â€“ The gateway hasn't received the capability configuration.    SYNC_FAILED â€“ The gateway rejected the capability configuration.   After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace
            case capabilitySyncStatus
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri("gatewayId"))
        ]

        /// The ID of the gateway to update.
        public let gatewayId: String
        /// A unique, friendly name for the gateway.
        public let gatewayName: String

        public init(gatewayId: String, gatewayName: String) {
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri("portalId"))
        ]

        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.  You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.  For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A new description for the portal.
        public let portalDescription: String?
        /// The ID of the portal to update.
        public let portalId: String
        public let portalLogoImage: Image?
        /// A new friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String

        public init(alarms: Alarms? = nil, clientToken: String? = UpdatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalContactEmail: String, portalDescription: String? = nil, portalId: String, portalLogoImage: Image? = nil, portalName: String, roleArn: String) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLogoImage = portalLogoImage
            self.portalName = portalName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "^[^@]+@[^@]+$")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.portalLogoImage?.validate(name: "\(name).portalLogoImage")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case alarms
            case clientToken
            case notificationSenderEmail
            case portalContactEmail
            case portalDescription
            case portalLogoImage
            case portalName
            case roleArn
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri("projectId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A new description for the project.
        public let projectDescription: String?
        /// The ID of the project to update.
        public let projectId: String
        /// A new friendly name for the project.
        public let projectName: String

        public init(clientToken: String? = UpdateProjectRequest.idempotencyToken(), projectDescription: String? = nil, projectId: String, projectName: String) {
            self.clientToken = clientToken
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^\\S{36,64}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case projectDescription
            case projectName
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The IAM Identity Center ID of the user.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct VariableValue: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model.
        public let propertyId: String

        public init(hierarchyId: String? = nil, propertyId: String) {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 256)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 256)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 1)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyId
            case propertyId
        }
    }

    public struct Variant: AWSEncodableShape & AWSDecodableShape {
        /// Asset property data of type Boolean (true or false).
        public let booleanValue: Bool?
        /// Asset property data of type double (floating point number).
        public let doubleValue: Double?
        /// Asset property data of type integer (whole number).
        public let integerValue: Int?
        /// Asset property data of type string (sequence of characters).
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, integerValue: Int? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue
            case doubleValue
            case integerValue
            case stringValue
        }
    }
}

// MARK: - Errors

/// Error enum for IoTSiteWise
public struct IoTSiteWiseErrorType: AWSErrorType {
    enum Code: String {
        case conflictingOperationException = "ConflictingOperationException"
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTSiteWise
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Your request has conflicting operations. This can occur if you&#39;re trying to perform more than one operation on the same resource at the same time.
    public static var conflictingOperationException: Self { .init(.conflictingOperationException) }
    /// IoT SiteWise can&#39;t process your request right now. Try again later.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The request isn&#39;t valid. This can occur if your request contains malformed JSON or unsupported characters. Check your request and try again.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// You&#39;ve reached the limit for a resource. For example, this can occur if you&#39;re trying to associate more than the allowed number of child assets or attempting to create more than the allowed number of properties for an asset model. For more information, see Quotas in the IoT SiteWise User Guide.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The requested resource can&#39;t be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The requested service is unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Your request exceeded a rate limit. For example, you might have exceeded the number of IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so on. For more information, see Quotas in the IoT SiteWise User Guide.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You&#39;ve reached the limit for the number of tags allowed for a resource. For more information, see Tag naming limits and requirements in the Amazon Web Services General Reference.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// You are not authorized.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension IoTSiteWiseErrorType: Equatable {
    public static func == (lhs: IoTSiteWiseErrorType, rhs: IoTSiteWiseErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTSiteWiseErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
