//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension IoTSiteWise {
    // MARK: Enums

    public enum AggregateType: String, CustomStringConvertible, Codable {
        case average = "AVERAGE"
        case count = "COUNT"
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        case standardDeviation = "STANDARD_DEVIATION"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AssetErrorCode: String, CustomStringConvertible, Codable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case propagating = "PROPAGATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AssetRelationshipType: String, CustomStringConvertible, Codable {
        case hierarchy = "HIERARCHY"
        public var description: String { return self.rawValue }
    }

    public enum AssetState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AuthMode: String, CustomStringConvertible, Codable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum BatchPutAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable {
        case accessdeniedexception = "AccessDeniedException"
        case conflictingoperationexception = "ConflictingOperationException"
        case internalfailureexception = "InternalFailureException"
        case invalidrequestexception = "InvalidRequestException"
        case limitexceededexception = "LimitExceededException"
        case resourcenotfoundexception = "ResourceNotFoundException"
        case serviceunavailableexception = "ServiceUnavailableException"
        case throttlingexception = "ThrottlingException"
        case timestampoutofrangeexception = "TimestampOutOfRangeException"
        public var description: String { return self.rawValue }
    }

    public enum CapabilitySyncStatus: String, CustomStringConvertible, Codable {
        case inSync = "IN_SYNC"
        case outOfSync = "OUT_OF_SYNC"
        case syncFailed = "SYNC_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case kmsBasedEncryption = "KMS_BASED_ENCRYPTION"
        case sitewiseDefaultEncryption = "SITEWISE_DEFAULT_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable {
        case internalFailure = "INTERNAL_FAILURE"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable {
        case group = "GROUP"
        case iam = "IAM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ImageFileType: String, CustomStringConvertible, Codable {
        case png = "PNG"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetsFilter: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case topLevel = "TOP_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable {
        case error = "ERROR"
        case info = "INFO"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum MonitorErrorCode: String, CustomStringConvertible, Codable {
        case internalFailure = "INTERNAL_FAILURE"
        case limitExceeded = "LIMIT_EXCEEDED"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable {
        case administrator = "ADMINISTRATOR"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PortalState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PropertyDataType: String, CustomStringConvertible, Codable {
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case string = "STRING"
        case `struct` = "STRUCT"
        public var description: String { return self.rawValue }
    }

    public enum PropertyNotificationState: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Quality: String, CustomStringConvertible, Codable {
        case bad = "BAD"
        case good = "GOOD"
        case uncertain = "UNCERTAIN"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case portal = "PORTAL"
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable {
        case multiLayerStorage = "MULTI_LAYER_STORAGE"
        case sitewiseDefaultStorage = "SITEWISE_DEFAULT_STORAGE"
        public var description: String { return self.rawValue }
    }

    public enum TimeOrdering: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TraversalDirection: String, CustomStringConvertible, Codable {
        case child = "CHILD"
        case parent = "PARENT"
        public var description: String { return self.rawValue }
    }

    public enum TraversalType: String, CustomStringConvertible, Codable {
        case pathToRoot = "PATH_TO_ROOT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPolicySummary: AWSDecodableShape {
        /// The date the access policy was created, in Unix epoch time.
        public let creationDate: Date?
        /// The ID of the access policy.
        public let id: String
        /// The identity (an Amazon Web Services SSO user, an Amazon Web Services SSO group, or an IAM user).
        public let identity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let permission: Permission
        /// The IoT SiteWise Monitor resource (a portal or project).
        public let resource: Resource

        public init(creationDate: Date? = nil, id: String, identity: Identity, lastUpdateDate: Date? = nil, permission: Permission, resource: Resource) {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case id
            case identity
            case lastUpdateDate
            case permission
            case resource
        }
    }

    public struct AggregatedValue: AWSDecodableShape {
        /// The quality of the aggregated data.
        public let quality: Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        public let timestamp: Date
        /// The value of the aggregates.
        public let value: Aggregates

        public init(quality: Quality? = nil, timestamp: Date, value: Aggregates) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case quality
            case timestamp
            case value
        }
    }

    public struct Aggregates: AWSDecodableShape {
        /// The average (mean) value of the time series over a time interval window.
        public let average: Double?
        /// The count of data points in the time series over a time interval window.
        public let count: Double?
        /// The maximum value of the time series over a time interval window.
        public let maximum: Double?
        /// The minimum value of the time series over a time interval window.
        public let minimum: Double?
        /// The standard deviation of the time series over a time interval window.
        public let standardDeviation: Double?
        /// The sum of the time series over a time interval window.
        public let sum: Double?

        public init(average: Double? = nil, count: Double? = nil, maximum: Double? = nil, minimum: Double? = nil, standardDeviation: Double? = nil, sum: Double? = nil) {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case average
            case count
            case maximum
            case minimum
            case standardDeviation
            case sum
        }
    }

    public struct Alarms: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        public let alarmRoleArn: String
        /// The ARN of the Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the IoT Events Developer Guide.
        public let notificationLambdaArn: String?

        public init(alarmRoleArn: String, notificationLambdaArn: String? = nil) {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, max: 1600)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, min: 1)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, pattern: ".*")
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, max: 1600)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, min: 1)
            try self.validate(self.notificationLambdaArn, name: "notificationLambdaArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmRoleArn
            case notificationLambdaArn
        }
    }

    public struct AssetCompositeModel: AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The name of the composite model.
        public let name: String
        /// The asset properties that this composite model defines.
        public let properties: [AssetProperty]
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, name: String, properties: [AssetProperty], type: String) {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case properties
            case type
        }
    }

    public struct AssetErrorDetails: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The error code.
        public let code: AssetErrorCode
        /// The error message.
        public let message: String

        public init(assetId: String, code: AssetErrorCode, message: String) {
            self.assetId = assetId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case code
            case message
        }
    }

    public struct AssetHierarchy: AWSDecodableShape {
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The hierarchy name provided in the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(id: String? = nil, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
        }
    }

    public struct AssetHierarchyInfo: AWSDecodableShape {
        /// The ID of the child asset in this asset relationship.
        public let childAssetId: String?
        /// The ID of the parent asset in this asset relationship.
        public let parentAssetId: String?

        public init(childAssetId: String? = nil, parentAssetId: String? = nil) {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId
            case parentAssetId
        }
    }

    public struct AssetModelCompositeModel: AWSEncodableShape & AWSDecodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, name: String, properties: [AssetModelProperty]? = nil, type: String) {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case properties
            case type
        }
    }

    public struct AssetModelCompositeModelDefinition: AWSEncodableShape {
        /// The description of the composite model.
        public let description: String?
        /// The name of the composite model.
        public let name: String
        /// The asset property definitions for this composite model.
        public let properties: [AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        public let type: String

        public init(description: String? = nil, name: String, properties: [AssetModelPropertyDefinition]? = nil, type: String) {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.properties?.forEach {
                try $0.validate(name: "\(name).properties[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case properties
            case type
        }
    }

    public struct AssetModelHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the asset model. All assets in this hierarchy must be instances of the childAssetModelId asset model.
        public let childAssetModelId: String
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The name of the asset model hierarchy that you specify by using the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(childAssetModelId: String, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId
            case id
            case name
        }
    }

    public struct AssetModelHierarchyDefinition: AWSEncodableShape {
        /// The ID of an asset model for this hierarchy.
        public let childAssetModelId: String
        /// The name of the asset model hierarchy definition (as specified in the CreateAssetModel or UpdateAssetModel API operation).
        public let name: String

        public init(childAssetModelId: String, name: String) {
            self.childAssetModelId = childAssetModelId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId
            case name
        }
    }

    public struct AssetModelProperty: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the asset model property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The ID of the asset model property.
        public let id: String?
        /// The name of the asset model property.
        public let name: String
        /// The property type (see PropertyType).
        public let type: PropertyType
        /// The unit of the asset model property, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, id: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType
            case dataTypeSpec
            case id
            case name
            case type
            case unit
        }
    }

    public struct AssetModelPropertyDefinition: AWSEncodableShape {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public let dataTypeSpec: String?
        /// The name of the property definition.
        public let name: String
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        public let type: PropertyType
        /// The unit of the property definition, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, dataTypeSpec: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.name = name
            self.type = type
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, max: 256)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, min: 1)
            try self.validate(self.dataTypeSpec, name: "dataTypeSpec", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.type.validate(name: "\(name).type")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType
            case dataTypeSpec
            case name
            case type
            case unit
        }
    }

    public struct AssetModelStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current state of the asset model.
        public let state: AssetModelState

        public init(error: ErrorDetails? = nil, state: AssetModelState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct AssetModelSummary: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let arn: String
        /// The date the asset model was created, in Unix epoch time.
        public let creationDate: Date
        /// The asset model description.
        public let description: String
        /// The ID of the asset model (used with IoT SiteWise APIs).
        public let id: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset model.
        public let name: String
        /// The current status of the asset model.
        public let status: AssetModelStatus

        public init(arn: String, creationDate: Date, description: String, id: String, lastUpdateDate: Date, name: String, status: AssetModelStatus) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
            case status
        }
    }

    public struct AssetProperty: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The data type of the asset property.
        public let dataType: PropertyDataType
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public let dataTypeSpec: String?
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, dataTypeSpec: String? = nil, id: String, name: String, notification: PropertyNotification? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.notification = notification
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case dataType
            case dataTypeSpec
            case id
            case name
            case notification
            case unit
        }
    }

    public struct AssetPropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// The quality of the asset property value.
        public let quality: Quality?
        /// The timestamp of the asset property value.
        public let timestamp: TimeInNanos
        /// The value of the asset property (see Variant).
        public let value: Variant

        public init(quality: Quality? = nil, timestamp: TimeInNanos, value: Variant) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.timestamp.validate(name: "\(name).timestamp")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case quality
            case timestamp
            case value
        }
    }

    public struct AssetRelationshipSummary: AWSDecodableShape {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public let hierarchyInfo: AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:    HIERARCHY – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        public let relationshipType: AssetRelationshipType

        public init(hierarchyInfo: AssetHierarchyInfo? = nil, relationshipType: AssetRelationshipType) {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyInfo
            case relationshipType
        }
    }

    public struct AssetStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current status of the asset.
        public let state: AssetState

        public init(error: ErrorDetails? = nil, state: AssetState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct AssetSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create this asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case assetModelId
            case creationDate
            case hierarchies
            case id
            case lastUpdateDate
            case name
            case status
        }
    }

    public struct AssociateAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the parent asset.
        public let assetId: String
        /// The ID of the child asset to be associated.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = AssociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId
            case clientToken
            case hierarchyId
        }
    }

    public struct AssociatedAssetsSummary: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let arn: String
        /// The ID of the asset model used to create the asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case assetModelId
            case creationDate
            case hierarchies
            case id
            case lastUpdateDate
            case name
            case status
        }
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see Updating attribute values in the IoT SiteWise User Guide.
        public let defaultValue: String?

        public init(defaultValue: String? = nil) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue
        }
    }

    public struct BatchAssociateProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The IDs of the assets to be associated to the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project to which to associate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchAssociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds
            case clientToken
        }
    }

    public struct BatchAssociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchDisassociateProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The IDs of the assets to be disassociated from the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project from which to disassociate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchDisassociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds
            case clientToken
        }
    }

    public struct BatchDisassociateProjectAssetsResponse: AWSDecodableShape {
        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchPutAssetPropertyError: AWSDecodableShape {
        /// The error code.
        public let errorCode: BatchPutAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String
        /// A list of timestamps for each error, if any.
        public let timestamps: [TimeInNanos]

        public init(errorCode: BatchPutAssetPropertyValueErrorCode, errorMessage: String, timestamps: [TimeInNanos]) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case timestamps
        }
    }

    public struct BatchPutAssetPropertyErrorEntry: AWSDecodableShape {
        /// The ID of the failed entry.
        public let entryId: String
        /// The list of update property value errors.
        public let errors: [BatchPutAssetPropertyError]

        public init(entryId: String, errors: [BatchPutAssetPropertyError]) {
            self.entryId = entryId
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case entryId
            case errors
        }
    }

    public struct BatchPutAssetPropertyValueRequest: AWSEncodableShape {
        /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
        public let entries: [PutAssetPropertyValueEntry]

        public init(entries: [PutAssetPropertyValueEntry]) {
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries
        }
    }

    public struct BatchPutAssetPropertyValueResponse: AWSDecodableShape {
        /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchPutAssetPropertyErrorEntry]

        public init(errorEntries: [BatchPutAssetPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
        }
    }

    public struct CompositeModelProperty: AWSDecodableShape {
        public let assetProperty: Property
        /// The name of the property.
        public let name: String
        /// The type of the composite model that defines this property.
        public let type: String

        public init(assetProperty: Property, name: String, type: String) {
            self.assetProperty = assetProperty
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assetProperty
            case name
            case type
        }
    }

    public struct ConfigurationErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        /// The error message.
        public let message: String

        public init(code: ErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct ConfigurationStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: ConfigurationErrorDetails?
        /// The current state of the configuration.
        public let state: ConfigurationState

        public init(error: ConfigurationErrorDetails? = nil, state: ConfigurationState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {
        /// The identity for this access policy. Choose an Amazon Web Services SSO user, an Amazon Web Services SSO group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the access policy. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity
            case accessPolicyPermission
            case accessPolicyResource
            case clientToken
            case tags
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyArn: String, accessPolicyId: String) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyId = accessPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn
            case accessPolicyId
        }
    }

    public struct CreateAssetModelRequest: AWSEncodableShape {
        /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
        public let assetModelCompositeModels: [AssetModelCompositeModelDefinition]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelPropertyDefinition]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset model. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetModelCompositeModels: [AssetModelCompositeModelDefinition]? = nil, assetModelDescription: String? = nil, assetModelHierarchies: [AssetModelHierarchyDefinition]? = nil, assetModelName: String, assetModelProperties: [AssetModelPropertyDefinition]? = nil, clientToken: String? = CreateAssetModelRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels
            case assetModelDescription
            case assetModelHierarchies
            case assetModelName
            case assetModelProperties
            case clientToken
            case tags
        }
    }

    public struct CreateAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The ID of the asset model. You can use this ID when you call other IoT SiteWise APIs.
        public let assetModelId: String
        /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelId: String, assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelId = assetModelId
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn
            case assetModelId
            case assetModelStatus
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {
        /// The ID of the asset model from which to create the asset.
        public let assetModelId: String
        /// A unique, friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetModelId: String, assetName: String, clientToken: String? = CreateAssetRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelId
            case assetName
            case clientToken
            case tags
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The ID of the asset. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
        public let assetId: String
        /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetId: String, assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetId = assetId
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn
            case assetId
            case assetStatus
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The dashboard definition specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A description for the dashboard.
        public let dashboardDescription: String?
        /// A friendly name for the dashboard.
        public let dashboardName: String
        /// The ID of the project in which to create the dashboard.
        public let projectId: String
        /// A list of key-value pairs that contain metadata for the dashboard. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardName: String, projectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardName = dashboardName
            self.projectId = projectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204_800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, min: 0)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: ".+")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case dashboardDefinition
            case dashboardDescription
            case dashboardName
            case projectId
            case tags
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardArn: String, dashboardId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn
            case dashboardId
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// A unique, friendly name for the gateway.
        public let gatewayName: String
        /// The gateway's platform. You can only specify one platform in a gateway.
        public let gatewayPlatform: GatewayPlatform
        /// A list of key-value pairs that contain metadata for the gateway. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(gatewayName: String, gatewayPlatform: GatewayPlatform, tags: [String: String]? = nil) {
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.gatewayPlatform.validate(name: "\(name).gatewayPlatform")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName
            case gatewayPlatform
            case tags
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise APIs.
        public let gatewayId: String

        public init(gatewayArn: String, gatewayId: String) {
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn
            case gatewayId
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.  If you use the IoT Events managed Lambda function to manage your emails, you must verify the sender email address in Amazon SES.
        public let notificationSenderEmail: String?
        /// The service to use to authenticate users to the portal. Choose from the following options:    SSO – The portal uses Amazon Web Services Single Sign On to authenticate users and manage user permissions. Before you can create a portal that uses Amazon Web Services SSO, you must enable Amazon Web Services SSO. For more information, see Enabling Amazon Web Services SSO in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.    IAM – The portal uses Identity and Access Management to authenticate users and manage user permissions. This option is only available in the China Regions.   You can't change this value after you create a portal. Default: SSO
        public let portalAuthMode: AuthMode?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A description for the portal.
        public let portalDescription: String?
        /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
        public let portalLogoImageFile: ImageFile?
        /// A friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String
        /// A list of key-value pairs that contain metadata for the portal. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(alarms: Alarms? = nil, clientToken: String? = CreatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalAuthMode: AuthMode? = nil, portalContactEmail: String, portalDescription: String? = nil, portalLogoImageFile: ImageFile? = nil, portalName: String, roleArn: String, tags: [String: String]? = nil) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalAuthMode = portalAuthMode
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalLogoImageFile = portalLogoImageFile
            self.portalName = portalName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "[^@]+@[^@]+")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "[^@]+@[^@]+")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.portalLogoImageFile?.validate(name: "\(name).portalLogoImageFile")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case alarms
            case clientToken
            case notificationSenderEmail
            case portalAuthMode
            case portalContactEmail
            case portalDescription
            case portalLogoImageFile
            case portalName
            case roleArn
            case tags
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The ID of the created portal.
        public let portalId: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use Amazon Web Services SSO for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus
        /// The associated Amazon Web Services SSO application ID, if the portal uses Amazon Web Services SSO.
        public let ssoApplicationId: String

        public init(portalArn: String, portalId: String, portalStartUrl: String, portalStatus: PortalStatus, ssoApplicationId: String) {
            self.portalArn = portalArn
            self.portalId = portalId
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.ssoApplicationId = ssoApplicationId
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn
            case portalId
            case portalStartUrl
            case portalStatus
            case ssoApplicationId
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal in which to create the project.
        public let portalId: String
        /// A description for the project.
        public let projectDescription: String?
        /// A friendly name for the project.
        public let projectName: String
        /// A list of key-value pairs that contain metadata for the project. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), portalId: String, projectDescription: String? = nil, projectName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.portalId = portalId
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case portalId
            case projectDescription
            case projectName
            case tags
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The ID of the project.
        public let projectId: String

        public init(projectArn: String, projectId: String) {
            self.projectArn = projectArn
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn
            case projectId
        }
    }

    public struct CustomerManagedS3Storage: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        public let roleArn: String
        /// The ARN of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see Amazon S3 resources in the Amazon Simple Storage Service User Guide.
        public let s3ResourceArn: String

        public init(roleArn: String, s3ResourceArn: String) {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, max: 1600)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, min: 1)
            try self.validate(self.s3ResourceArn, name: "s3ResourceArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn
            case s3ResourceArn
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The date the dashboard was created, in Unix epoch time.
        public let creationDate: Date?
        /// The dashboard's description.
        public let description: String?
        /// The ID of the dashboard.
        public let id: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the dashboard
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri(locationName: "accessPolicyId")),
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The ID of the access policy to be deleted.
        public let accessPolicyId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri(locationName: "assetModelId")),
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The ID of the asset model to delete.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelId: String, clientToken: String? = DeleteAssetModelRequest.idempotencyToken()) {
            self.assetModelId = assetModelId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")),
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The ID of the asset to delete.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetId: String, clientToken: String? = DeleteAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "dashboardId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the dashboard to delete.
        public let dashboardId: String

        public init(clientToken: String? = DeleteDashboardRequest.idempotencyToken(), dashboardId: String) {
            self.clientToken = clientToken
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The ID of the gateway to delete.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")),
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal to delete.
        public let portalId: String

        public init(clientToken: String? = DeletePortalRequest.idempotencyToken(), portalId: String) {
            self.clientToken = clientToken
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")),
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectId: String) {
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri(locationName: "accessPolicyId"))
        ]

        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyId: String) {
            self.accessPolicyId = accessPolicyId
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccessPolicyResponse: AWSDecodableShape {
        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
        public let accessPolicyArn: String
        /// The date the access policy was created, in Unix epoch time.
        public let accessPolicyCreationDate: Date
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity (Amazon Web Services SSO user, Amazon Web Services SSO group, or IAM user) to which this access policy applies.
        public let accessPolicyIdentity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let accessPolicyLastUpdateDate: Date
        /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
        public let accessPolicyResource: Resource

        public init(accessPolicyArn: String, accessPolicyCreationDate: Date, accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyLastUpdateDate: Date, accessPolicyPermission: Permission, accessPolicyResource: Resource) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyCreationDate = accessPolicyCreationDate
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn
            case accessPolicyCreationDate
            case accessPolicyId
            case accessPolicyIdentity
            case accessPolicyLastUpdateDate
            case accessPolicyPermission
            case accessPolicyResource
        }
    }

    public struct DescribeAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri(locationName: "assetModelId"))
        ]

        /// The ID of the asset model.
        public let assetModelId: String

        public init(assetModelId: String) {
            self.assetModelId = assetModelId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelResponse: AWSDecodableShape {
        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        public let assetModelArn: String
        /// The list of composite asset models for the asset model.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// The date the asset model was created, in Unix epoch time.
        public let assetModelCreationDate: Date
        /// The asset model's description.
        public let assetModelDescription: String
        /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
        public let assetModelHierarchies: [AssetModelHierarchy]
        /// The ID of the asset model.
        public let assetModelId: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let assetModelLastUpdateDate: Date
        /// The name of the asset model.
        public let assetModelName: String
        /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
        public let assetModelProperties: [AssetModelProperty]
        /// The current status of the asset model, which contains a state and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelCreationDate: Date, assetModelDescription: String, assetModelHierarchies: [AssetModelHierarchy], assetModelId: String, assetModelLastUpdateDate: Date, assetModelName: String, assetModelProperties: [AssetModelProperty], assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelCreationDate = assetModelCreationDate
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelLastUpdateDate = assetModelLastUpdateDate
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn
            case assetModelCompositeModels
            case assetModelCreationDate
            case assetModelDescription
            case assetModelHierarchies
            case assetModelId
            case assetModelLastUpdateDate
            case assetModelName
            case assetModelProperties
            case assetModelStatus
        }
    }

    public struct DescribeAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")),
            AWSMemberEncoding(label: "propertyId", location: .uri(locationName: "propertyId"))
        ]

        /// The ID of the asset.
        public let assetId: String
        /// The ID of the asset property.
        public let propertyId: String

        public init(assetId: String, propertyId: String) {
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetPropertyResponse: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The ID of the asset model.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
        public let assetProperty: Property?
        /// The composite asset model that declares this asset property, if this asset property exists in a composite model.
        public let compositeModel: CompositeModelProperty?

        public init(assetId: String, assetModelId: String, assetName: String, assetProperty: Property? = nil, compositeModel: CompositeModelProperty? = nil) {
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperty = assetProperty
            self.compositeModel = compositeModel
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case assetModelId
            case assetName
            case assetProperty
            case compositeModel
        }
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the asset.
        public let assetId: String

        public init(assetId: String) {
            self.assetId = assetId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {
        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        public let assetArn: String
        /// The composite models for the asset.
        public let assetCompositeModels: [AssetCompositeModel]?
        /// The date the asset was created, in Unix epoch time.
        public let assetCreationDate: Date
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let assetHierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let assetId: String
        /// The date the asset was last updated, in Unix epoch time.
        public let assetLastUpdateDate: Date
        /// The ID of the asset model that was used to create the asset.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
        public let assetProperties: [AssetProperty]
        /// The current status of the asset, which contains a state and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetCompositeModels: [AssetCompositeModel]? = nil, assetCreationDate: Date, assetHierarchies: [AssetHierarchy], assetId: String, assetLastUpdateDate: Date, assetModelId: String, assetName: String, assetProperties: [AssetProperty], assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetCompositeModels = assetCompositeModels
            self.assetCreationDate = assetCreationDate
            self.assetHierarchies = assetHierarchies
            self.assetId = assetId
            self.assetLastUpdateDate = assetLastUpdateDate
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperties = assetProperties
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn
            case assetCompositeModels
            case assetCreationDate
            case assetHierarchies
            case assetId
            case assetLastUpdateDate
            case assetModelId
            case assetName
            case assetProperties
            case assetStatus
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "dashboardId"))
        ]

        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardId: String) {
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
        public let dashboardArn: String
        /// The date the dashboard was created, in Unix epoch time.
        public let dashboardCreationDate: Date
        /// The dashboard's definition JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// The dashboard's description.
        public let dashboardDescription: String?
        /// The ID of the dashboard.
        public let dashboardId: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let dashboardLastUpdateDate: Date
        /// The name of the dashboard.
        public let dashboardName: String
        /// The ID of the project that the dashboard is in.
        public let projectId: String

        public init(dashboardArn: String, dashboardCreationDate: Date, dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardLastUpdateDate: Date, dashboardName: String, projectId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardCreationDate = dashboardCreationDate
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardLastUpdateDate = dashboardLastUpdateDate
            self.dashboardName = dashboardName
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn
            case dashboardCreationDate
            case dashboardDefinition
            case dashboardDescription
            case dashboardId
            case dashboardLastUpdateDate
            case dashboardName
            case projectId
        }
    }

    public struct DescribeDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The key ARN of the customer managed customer master key (CMK) used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case encryptionType
            case kmsKeyArn
        }
    }

    public struct DescribeGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "capabilityNamespace", location: .uri(locationName: "capabilityNamespace")),
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityNamespace: String, gatewayId: String) {
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The JSON document that defines the gateway capability's configuration. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration
            case capabilityNamespace
            case capabilitySyncStatus
            case gatewayId
        }
    }

    public struct DescribeGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The ID of the gateway device.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayResponse: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
        public let gatewayArn: String
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the gateway.
        public let gatewayName: String
        /// The gateway's platform.
        public let gatewayPlatform: GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayArn: String, gatewayCapabilitySummaries: [GatewayCapabilitySummary], gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayArn = gatewayArn
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case gatewayArn
            case gatewayCapabilitySummaries
            case gatewayId
            case gatewayName
            case gatewayPlatform
            case lastUpdateDate
        }
    }

    public struct DescribeLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeLoggingOptionsResponse: AWSDecodableShape {
        /// The current logging options.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions
        }
    }

    public struct DescribePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId"))
        ]

        /// The ID of the portal.
        public let portalId: String

        public init(portalId: String) {
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePortalResponse: AWSDecodableShape {
        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
        public let alarms: Alarms?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
        public let portalArn: String
        /// The service to use to authenticate users to the portal.
        public let portalAuthMode: AuthMode?
        /// The Amazon Web Services SSO application generated client ID (used with Amazon Web Services SSO APIs). IoT SiteWise includes portalClientId for only portals that use Amazon Web Services SSO to authenticate users.
        public let portalClientId: String
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// The date the portal was created, in Unix epoch time.
        public let portalCreationDate: Date
        /// The portal's description.
        public let portalDescription: String?
        /// The ID of the portal.
        public let portalId: String
        /// The date the portal was last updated, in Unix epoch time.
        public let portalLastUpdateDate: Date
        /// The portal's logo image, which is available at a URL.
        public let portalLogoImageLocation: ImageLocation?
        /// The name of the portal.
        public let portalName: String
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use Amazon Web Services SSO for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The current status of the portal, which contains a state and any error message.
        public let portalStatus: PortalStatus
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?

        public init(alarms: Alarms? = nil, notificationSenderEmail: String? = nil, portalArn: String, portalAuthMode: AuthMode? = nil, portalClientId: String, portalContactEmail: String, portalCreationDate: Date, portalDescription: String? = nil, portalId: String, portalLastUpdateDate: Date, portalLogoImageLocation: ImageLocation? = nil, portalName: String, portalStartUrl: String, portalStatus: PortalStatus, roleArn: String? = nil) {
            self.alarms = alarms
            self.notificationSenderEmail = notificationSenderEmail
            self.portalArn = portalArn
            self.portalAuthMode = portalAuthMode
            self.portalClientId = portalClientId
            self.portalContactEmail = portalContactEmail
            self.portalCreationDate = portalCreationDate
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLastUpdateDate = portalLastUpdateDate
            self.portalLogoImageLocation = portalLogoImageLocation
            self.portalName = portalName
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case alarms
            case notificationSenderEmail
            case portalArn
            case portalAuthMode
            case portalClientId
            case portalContactEmail
            case portalCreationDate
            case portalDescription
            case portalId
            case portalLastUpdateDate
            case portalLogoImageLocation
            case portalName
            case portalStartUrl
            case portalStatus
            case roleArn
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The ID of the project.
        public let projectId: String

        public init(projectId: String) {
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The ID of the portal that the project is in.
        public let portalId: String
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
        public let projectArn: String
        /// The date the project was created, in Unix epoch time.
        public let projectCreationDate: Date
        /// The project's description.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The date the project was last updated, in Unix epoch time.
        public let projectLastUpdateDate: Date
        /// The name of the project.
        public let projectName: String

        public init(portalId: String, projectArn: String, projectCreationDate: Date, projectDescription: String? = nil, projectId: String, projectLastUpdateDate: Date, projectName: String) {
            self.portalId = portalId
            self.projectArn = projectArn
            self.projectCreationDate = projectCreationDate
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectLastUpdateDate = projectLastUpdateDate
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case portalId
            case projectArn
            case projectCreationDate
            case projectDescription
            case projectId
            case projectLastUpdateDate
            case projectName
        }
    }

    public struct DescribeStorageConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// The date the storage configuration was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        /// The type of storage that you specified for your data. The storage type can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise replicates your data into a service managed database.    MULTI_LAYER_STORAGE – IoT SiteWise replicates your data into a service managed database and saves a copy of your raw data and metadata in an Amazon S3 object that you specified.
        public let storageType: StorageType

        public init(configurationStatus: ConfigurationStatus, lastUpdateDate: Date? = nil, multiLayerStorage: MultiLayerStorage? = nil, storageType: StorageType) {
            self.configurationStatus = configurationStatus
            self.lastUpdateDate = lastUpdateDate
            self.multiLayerStorage = multiLayerStorage
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case lastUpdateDate
            case multiLayerStorage
            case storageType
        }
    }

    public struct DisassociateAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the parent asset from which to disassociate the child asset.
        public let assetId: String
        /// The ID of the child asset to disassociate.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = DisassociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId
            case clientToken
            case hierarchyId
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode
        /// The error message.
        public let message: String

        public init(code: ErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct ExpressionVariable: AWSEncodableShape & AWSDecodableShape {
        /// The friendly name of the variable to be used in the expression.
        public let name: String
        /// The variable that identifies an asset property from which to use values.
        public let value: VariableValue

        public init(name: String, value: VariableValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct GatewayCapabilitySummary: AWSDecodableShape {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace
            case capabilitySyncStatus
        }
    }

    public struct GatewayPlatform: AWSEncodableShape & AWSDecodableShape {
        /// A gateway that runs on IoT Greengrass.
        public let greengrass: Greengrass

        public init(greengrass: Greengrass) {
            self.greengrass = greengrass
        }

        public func validate(name: String) throws {
            try self.greengrass.validate(name: "\(name).greengrass")
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the asset.
        public let gatewayName: String
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil, gatewayId: String, gatewayName: String, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case gatewayCapabilitySummaries
            case gatewayId
            case gatewayName
            case lastUpdateDate
        }
    }

    public struct GetAssetPropertyAggregatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aggregateTypes", location: .querystring(locationName: "aggregateTypes")),
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")),
            AWSMemberEncoding(label: "endDate", location: .querystring(locationName: "endDate")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId")),
            AWSMemberEncoding(label: "qualities", location: .querystring(locationName: "qualities")),
            AWSMemberEncoding(label: "resolution", location: .querystring(locationName: "resolution")),
            AWSMemberEncoding(label: "startDate", location: .querystring(locationName: "startDate")),
            AWSMemberEncoding(label: "timeOrdering", location: .querystring(locationName: "timeOrdering"))
        ]

        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The maximum number of results to return for each paginated request. Default: 100
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "1m|1h|1d")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyAggregatesResponse: AWSDecodableShape {
        /// The requested aggregated values.
        public let aggregatedValues: [AggregatedValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(aggregatedValues: [AggregatedValue], nextToken: String? = nil) {
            self.aggregatedValues = aggregatedValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues
            case nextToken
        }
    }

    public struct GetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")),
            AWSMemberEncoding(label: "endDate", location: .querystring(locationName: "endDate")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId")),
            AWSMemberEncoding(label: "qualities", location: .querystring(locationName: "qualities")),
            AWSMemberEncoding(label: "startDate", location: .querystring(locationName: "startDate")),
            AWSMemberEncoding(label: "timeOrdering", location: .querystring(locationName: "timeOrdering"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The maximum number of results to return for each paginated request. Default: 100
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public let timeOrdering: TimeOrdering?

        public init(assetId: String? = nil, endDate: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The asset property's value history.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetPropertyValueHistory: [AssetPropertyValue], nextToken: String? = nil) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory
            case nextToken
        }
    }

    public struct GetAssetPropertyValueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?

        public init(assetId: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueResponse: AWSDecodableShape {
        /// The current asset property value.
        public let propertyValue: AssetPropertyValue?

        public init(propertyValue: AssetPropertyValue? = nil) {
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValue
        }
    }

    public struct GetInterpolatedAssetPropertyValuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")),
            AWSMemberEncoding(label: "endTimeInSeconds", location: .querystring(locationName: "endTimeInSeconds")),
            AWSMemberEncoding(label: "endTimeOffsetInNanos", location: .querystring(locationName: "endTimeOffsetInNanos")),
            AWSMemberEncoding(label: "intervalInSeconds", location: .querystring(locationName: "intervalInSeconds")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")),
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId")),
            AWSMemberEncoding(label: "quality", location: .querystring(locationName: "quality")),
            AWSMemberEncoding(label: "startTimeInSeconds", location: .querystring(locationName: "startTimeInSeconds")),
            AWSMemberEncoding(label: "startTimeOffsetInNanos", location: .querystring(locationName: "startTimeOffsetInNanos")),
            AWSMemberEncoding(label: "type", location: .querystring(locationName: "type"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let endTimeInSeconds: Int64
        /// The nanosecond offset converted from endTimeInSeconds.
        public let endTimeOffsetInNanos: Int?
        /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
        public let intervalInSeconds: Int64
        /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
        public let quality: Quality
        /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
        public let startTimeInSeconds: Int64
        /// The nanosecond offset converted from startTimeInSeconds.
        public let startTimeOffsetInNanos: Int?
        /// The interpolation type. Valid values: LINEAR_INTERPOLATION
        public let type: String

        public init(assetId: String? = nil, endTimeInSeconds: Int64, endTimeOffsetInNanos: Int? = nil, intervalInSeconds: Int64, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, quality: Quality, startTimeInSeconds: Int64, startTimeOffsetInNanos: Int? = nil, type: String) {
            self.assetId = assetId
            self.endTimeInSeconds = endTimeInSeconds
            self.endTimeOffsetInNanos = endTimeOffsetInNanos
            self.intervalInSeconds = intervalInSeconds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.quality = quality
            self.startTimeInSeconds = startTimeInSeconds
            self.startTimeOffsetInNanos = startTimeOffsetInNanos
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, max: 31_556_889_864_403_199)
            try self.validate(self.endTimeInSeconds, name: "endTimeInSeconds", parent: name, min: 1)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, max: 999_999_999)
            try self.validate(self.endTimeOffsetInNanos, name: "endTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, max: 320_000_000)
            try self.validate(self.intervalInSeconds, name: "intervalInSeconds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, max: 31_556_889_864_403_199)
            try self.validate(self.startTimeInSeconds, name: "startTimeInSeconds", parent: name, min: 1)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, max: 999_999_999)
            try self.validate(self.startTimeOffsetInNanos, name: "startTimeOffsetInNanos", parent: name, min: 0)
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInterpolatedAssetPropertyValuesResponse: AWSDecodableShape {
        /// The requested interpolated values.
        public let interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue], nextToken: String? = nil) {
            self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case interpolatedAssetPropertyValues
            case nextToken
        }
    }

    public struct Greengrass: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Greengrass group. For more information about how to find a group's ARN, see ListGroups and GetGroup in the IoT Greengrass API Reference.
        public let groupArn: String

        public init(groupArn: String) {
            self.groupArn = groupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.groupArn, name: "groupArn", parent: name, max: 1600)
            try self.validate(self.groupArn, name: "groupArn", parent: name, min: 1)
            try self.validate(self.groupArn, name: "groupArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case groupArn
        }
    }

    public struct GroupIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services SSO ID of the group.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct IAMRoleIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role. For more information, see IAM ARNs in the IAM User Guide.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct IAMUserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide.  If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct Identity: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Web Services SSO group identity.
        public let group: GroupIdentity?
        /// An IAM role identity.
        public let iamRole: IAMRoleIdentity?
        /// An IAM user identity.
        public let iamUser: IAMUserIdentity?
        /// An Amazon Web Services SSO user identity.
        public let user: UserIdentity?

        public init(group: GroupIdentity? = nil, iamRole: IAMRoleIdentity? = nil, iamUser: IAMUserIdentity? = nil, user: UserIdentity? = nil) {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }

        public func validate(name: String) throws {
            try self.group?.validate(name: "\(name).group")
            try self.iamRole?.validate(name: "\(name).iamRole")
            try self.iamUser?.validate(name: "\(name).iamUser")
            try self.user?.validate(name: "\(name).user")
        }

        private enum CodingKeys: String, CodingKey {
            case group
            case iamRole
            case iamUser
            case user
        }
    }

    public struct Image: AWSEncodableShape {
        public let file: ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public let id: String?

        public init(file: ImageFile? = nil, id: String? = nil) {
            self.file = file
            self.id = id
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case id
        }
    }

    public struct ImageFile: AWSEncodableShape {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        public let data: Data
        /// The file type of the image.
        public let type: ImageFileType

        public init(data: Data, type: ImageFileType) {
            self.data = data
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 1_500_000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data
            case type
        }
    }

    public struct ImageLocation: AWSDecodableShape {
        /// The ID of the image.
        public let id: String
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        public let url: String

        public init(id: String, url: String) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case url
        }
    }

    public struct InterpolatedAssetPropertyValue: AWSDecodableShape {
        public let timestamp: TimeInNanos
        public let value: Variant

        public init(timestamp: TimeInNanos, value: Variant) {
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp
            case value
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "iamArn", location: .querystring(locationName: "iamArn")),
            AWSMemberEncoding(label: "identityId", location: .querystring(locationName: "identityId")),
            AWSMemberEncoding(label: "identityType", location: .querystring(locationName: "identityType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "resourceId", location: .querystring(locationName: "resourceId")),
            AWSMemberEncoding(label: "resourceType", location: .querystring(locationName: "resourceType"))
        ]

        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide. This parameter is required if you specify IAM for identityType.
        public let iamArn: String?
        /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
        public let identityId: String?
        /// The type of identity (Amazon Web Services SSO user, Amazon Web Services SSO group, or IAM user). This parameter is required if you specify identityId.
        public let identityType: IdentityType?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the resource. This parameter is required if you specify resourceType.
        public let resourceId: String?
        /// The type of resource (portal or project). This parameter is required if you specify resourceId.
        public let resourceType: ResourceType?

        public init(iamArn: String? = nil, identityId: String? = nil, identityType: IdentityType? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.iamArn = iamArn
            self.identityId = identityId
            self.identityType = identityType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.iamArn, name: "iamArn", parent: name, max: 1600)
            try self.validate(self.iamArn, name: "iamArn", parent: name, min: 1)
            try self.validate(self.iamArn, name: "iamArn", parent: name, pattern: ".*")
            try self.validate(self.identityId, name: "identityId", parent: name, max: 256)
            try self.validate(self.identityId, name: "identityId", parent: name, min: 1)
            try self.validate(self.identityId, name: "identityId", parent: name, pattern: "\\S+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {
        /// A list that summarizes each access policy.
        public let accessPolicySummaries: [AccessPolicySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(accessPolicySummaries: [AccessPolicySummary], nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries
            case nextToken
        }
    }

    public struct ListAssetModelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelsResponse: AWSDecodableShape {
        /// A list that summarizes each asset model.
        public let assetModelSummaries: [AssetModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelSummaries: [AssetModelSummary], nextToken: String? = nil) {
            self.assetModelSummaries = assetModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelSummaries
            case nextToken
        }
    }

    public struct ListAssetRelationshipsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "traversalType", location: .querystring(locationName: "traversalType"))
        ]

        /// The ID of the asset.
        public let assetId: String
        /// The maximum number of results to return for each paginated request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The type of traversal to use to identify asset relationships. Choose the following option:    PATH_TO_ROOT – Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
        public let traversalType: TraversalType

        public init(assetId: String, maxResults: Int? = nil, nextToken: String? = nil, traversalType: TraversalType) {
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalType = traversalType
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetRelationshipsResponse: AWSDecodableShape {
        /// A list that summarizes each asset relationship.
        public let assetRelationshipSummaries: [AssetRelationshipSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetRelationshipSummaries: [AssetRelationshipSummary], nextToken: String? = nil) {
            self.assetRelationshipSummaries = assetRelationshipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetRelationshipSummaries
            case nextToken
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .querystring(locationName: "assetModelId")),
            AWSMemberEncoding(label: "filter", location: .querystring(locationName: "filter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter.
        public let assetModelId: String?
        /// The filter for the requested list of assets. Choose one of the following options:    ALL – The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.    TOP_LEVEL – The list includes only top-level assets in the asset hierarchy tree.   Default: ALL
        public let filter: ListAssetsFilter?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String? = nil, filter: ListAssetsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {
        /// A list that summarizes each asset.
        public let assetSummaries: [AssetSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssetSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries
            case nextToken
        }
    }

    public struct ListAssociatedAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")),
            AWSMemberEncoding(label: "hierarchyId", location: .querystring(locationName: "hierarchyId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "traversalDirection", location: .querystring(locationName: "traversalDirection"))
        ]

        /// The ID of the asset to query.
        public let assetId: String
        /// The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the DescribeAsset or DescribeAssetModel operations. This parameter is required if you choose CHILD for traversalDirection. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The direction to list associated assets. Choose one of the following options:    CHILD – The list includes all child assets associated to the asset. The hierarchyId parameter is required if you choose CHILD.    PARENT – The list includes the asset's parent asset.   Default: CHILD
        public let traversalDirection: TraversalDirection?

        public init(assetId: String, hierarchyId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, traversalDirection: TraversalDirection? = nil) {
            self.assetId = assetId
            self.hierarchyId = hierarchyId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalDirection = traversalDirection
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedAssetsResponse: AWSDecodableShape {
        /// A list that summarizes the associated assets.
        public let assetSummaries: [AssociatedAssetsSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssociatedAssetsSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries
            case nextToken
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "projectId", location: .querystring(locationName: "projectId"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        /// A list that summarizes each dashboard in the project.
        public let dashboardSummaries: [DashboardSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(dashboardSummaries: [DashboardSummary], nextToken: String? = nil) {
            self.dashboardSummaries = dashboardSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaries
            case nextToken
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// A list that summarizes each gateway.
        public let gatewaySummaries: [GatewaySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(gatewaySummaries: [GatewaySummary], nextToken: String? = nil) {
            self.gatewaySummaries = gatewaySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewaySummaries
            case nextToken
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each portal.
        public let portalSummaries: [PortalSummary]?

        public init(nextToken: String? = nil, portalSummaries: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portalSummaries = portalSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case portalSummaries
        }
    }

    public struct ListProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectAssetsResponse: AWSDecodableShape {
        /// A list that contains the IDs of each asset associated with the project.
        public let assetIds: [String]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetIds: [String], nextToken: String? = nil) {
            self.assetIds = assetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds
            case nextToken
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "portalId", location: .querystring(locationName: "portalId"))
        ]

        /// The maximum number of results to return for each paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the portal.
        public let portalId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, portalId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each project in the portal.
        public let projectSummaries: [ProjectSummary]

        public init(nextToken: String? = nil, projectSummaries: [ProjectSummary]) {
            self.nextToken = nextToken
            self.projectSummaries = projectSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case projectSummaries
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct LoggingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The IoT SiteWise logging verbosity level.
        public let level: LoggingLevel

        public init(level: LoggingLevel) {
            self.level = level
        }

        private enum CodingKeys: String, CodingKey {
            case level
        }
    }

    public struct Measurement: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        public let window: MetricWindow

        public init(expression: String, variables: [ExpressionVariable], window: MetricWindow) {
            self.expression = expression
            self.variables = variables
            self.window = window
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
            try self.window.validate(name: "\(name).window")
        }

        private enum CodingKeys: String, CodingKey {
            case expression
            case variables
            case window
        }
    }

    public struct MetricWindow: AWSEncodableShape & AWSDecodableShape {
        /// The tumbling time interval window.
        public let tumbling: TumblingWindow?

        public init(tumbling: TumblingWindow? = nil) {
            self.tumbling = tumbling
        }

        public func validate(name: String) throws {
            try self.tumbling?.validate(name: "\(name).tumbling")
        }

        private enum CodingKeys: String, CodingKey {
            case tumbling
        }
    }

    public struct MonitorErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: MonitorErrorCode?
        /// The error message.
        public let message: String?

        public init(code: MonitorErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct MultiLayerStorage: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about a customer managed Amazon S3 bucket.
        public let customerManagedS3Storage: CustomerManagedS3Storage

        public init(customerManagedS3Storage: CustomerManagedS3Storage) {
            self.customerManagedS3Storage = customerManagedS3Storage
        }

        public func validate(name: String) throws {
            try self.customerManagedS3Storage.validate(name: "\(name).customerManagedS3Storage")
        }

        private enum CodingKeys: String, CodingKey {
            case customerManagedS3Storage
        }
    }

    public struct PortalResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the portal.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct PortalStatus: AWSDecodableShape {
        /// Contains associated error information, if any.
        public let error: MonitorErrorDetails?
        /// The current state of the portal.
        public let state: PortalState

        public init(error: MonitorErrorDetails? = nil, state: PortalState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct PortalSummary: AWSDecodableShape {
        /// The date the portal was created, in Unix epoch time.
        public let creationDate: Date?
        /// The portal's description.
        public let description: String?
        /// The ID of the portal.
        public let id: String
        /// The date the portal was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the portal.
        public let name: String
        /// The ARN of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use Amazon Web Services SSO for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        public let startUrl: String
        public let status: PortalStatus

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String, roleArn: String? = nil, startUrl: String, status: PortalStatus) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
            case roleArn
            case startUrl
            case status
        }
    }

    public struct ProjectResource: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the project.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The date the project was created, in Unix epoch time.
        public let creationDate: Date?
        /// The project's description.
        public let description: String?
        /// The ID of the project.
        public let id: String
        /// The date the project was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the project.
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case description
            case id
            case lastUpdateDate
            case name
        }
    }

    public struct Property: AWSDecodableShape {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let alias: String?
        /// The property data type.
        public let dataType: PropertyDataType
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The property type (see PropertyType). A property contains one type.
        public let type: PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, id: String, name: String, notification: PropertyNotification? = nil, type: PropertyType? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.type = type
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case dataType
            case id
            case name
            case notification
            case type
            case unit
        }
    }

    public struct PropertyNotification: AWSDecodableShape {
        /// The current notification state.
        public let state: PropertyNotificationState
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        public let topic: String

        public init(state: PropertyNotificationState, topic: String) {
            self.state = state
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case state
            case topic
        }
    }

    public struct PropertyType: AWSEncodableShape & AWSDecodableShape {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an IIoT wind turbine.
        public let attribute: Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public let measurement: Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public let metric: Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public let transform: Transform?

        public init(attribute: Attribute? = nil, measurement: Measurement? = nil, metric: Metric? = nil, transform: Transform? = nil) {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }

        public func validate(name: String) throws {
            try self.attribute?.validate(name: "\(name).attribute")
            try self.metric?.validate(name: "\(name).metric")
            try self.transform?.validate(name: "\(name).transform")
        }

        private enum CodingKeys: String, CodingKey {
            case attribute
            case measurement
            case metric
            case transform
        }
    }

    public struct PutAssetPropertyValueEntry: AWSEncodableShape {
        /// The ID of the asset to update.
        public let assetId: String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        public let entryId: String
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property for this entry.
        public let propertyId: String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        public let propertyValues: [AssetPropertyValue]

        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, propertyValues: [AssetPropertyValue]) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.propertyValues.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetId
            case entryId
            case propertyAlias
            case propertyId
            case propertyValues
        }
    }

    public struct PutDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ID of the customer managed customer master key (CMK) used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyId: String?

        public init(encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
            case kmsKeyId
        }
    }

    public struct PutDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key ARN of the KMS CMK used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case encryptionType
            case kmsKeyArn
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// The logging options to set.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStorageConfigurationRequest: AWSEncodableShape {
        /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type, you must specify a MultiLayerStorage object.
        public let multiLayerStorage: MultiLayerStorage?
        /// The type of storage that you specified for your data. The storage type can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise replicates your data into a service managed database.    MULTI_LAYER_STORAGE – IoT SiteWise replicates your data into a service managed database and saves a copy of your raw data and metadata in an Amazon S3 object that you specified.
        public let storageType: StorageType

        public init(multiLayerStorage: MultiLayerStorage? = nil, storageType: StorageType) {
            self.multiLayerStorage = multiLayerStorage
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.multiLayerStorage?.validate(name: "\(name).multiLayerStorage")
        }

        private enum CodingKeys: String, CodingKey {
            case multiLayerStorage
            case storageType
        }
    }

    public struct PutStorageConfigurationResponse: AWSDecodableShape {
        public let configurationStatus: ConfigurationStatus
        /// Contains information about the storage destination.
        public let multiLayerStorage: MultiLayerStorage?
        /// The type of storage that you specified for your data. The storage type can be one of the following values:    SITEWISE_DEFAULT_STORAGE – IoT SiteWise replicates your data into a service managed database.    MULTI_LAYER_STORAGE – IoT SiteWise replicates your data into a service managed database and saves a copy of your raw data and metadata in an Amazon S3 object that you specified.
        public let storageType: StorageType

        public init(configurationStatus: ConfigurationStatus, multiLayerStorage: MultiLayerStorage? = nil, storageType: StorageType) {
            self.configurationStatus = configurationStatus
            self.multiLayerStorage = multiLayerStorage
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus
            case multiLayerStorage
            case storageType
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// A portal resource.
        public let portal: PortalResource?
        /// A project resource.
        public let project: ProjectResource?

        public init(portal: PortalResource? = nil, project: ProjectResource? = nil) {
            self.portal = portal
            self.project = project
        }

        public func validate(name: String) throws {
            try self.portal?.validate(name: "\(name).portal")
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case portal
            case project
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the resource to tag.
        public let resourceArn: String
        /// A list of key-value pairs that contain metadata for the resource. For more information, see Tagging your IoT SiteWise resources in the IoT SiteWise User Guide.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeInNanos: AWSEncodableShape & AWSDecodableShape {
        /// The nanosecond offset from timeInSeconds.
        public let offsetInNanos: Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        public let timeInSeconds: Int64

        public init(offsetInNanos: Int? = nil, timeInSeconds: Int64) {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, max: 999_999_999)
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, min: 0)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, max: 31_556_889_864_403_199)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case offsetInNanos
            case timeInSeconds
        }
    }

    public struct Transform: AWSEncodableShape & AWSDecodableShape {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the IoT SiteWise User Guide.
        public let expression: String
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]

        public init(expression: String, variables: [ExpressionVariable]) {
            self.expression = expression
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression
            case variables
        }
    }

    public struct TumblingWindow: AWSEncodableShape & AWSDecodableShape {
        /// The time interval for the tumbling window. Note that w represents weeks, d represents days, h represents hours, and m represents minutes. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on.  When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        public let interval: String

        public init(interval: String) {
            self.interval = interval
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, max: 3)
            try self.validate(self.interval, name: "interval", parent: name, min: 2)
            try self.validate(self.interval, name: "interval", parent: name, pattern: "1w|1d|1h|15m|5m|1m")
        }

        private enum CodingKeys: String, CodingKey {
            case interval
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the resource to untag.
        public let resourceArn: String
        /// A list of keys for tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri(locationName: "accessPolicyId"))
        ]

        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity for this access policy. Choose an Amazon Web Services SSO user, an Amazon Web Services SSO group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity
            case accessPolicyPermission
            case accessPolicyResource
            case clientToken
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri(locationName: "assetModelId"))
        ]

        /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
        public let assetModelCompositeModels: [AssetModelCompositeModel]?
        /// A description for the asset model.
        public let assetModelDescription: String?
        /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchy]?
        /// The ID of the asset model to update.
        public let assetModelId: String
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The updated property definitions of the asset model. For more information, see Asset properties in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelProperty]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelCompositeModels: [AssetModelCompositeModel]? = nil, assetModelDescription: String? = nil, assetModelHierarchies: [AssetModelHierarchy]? = nil, assetModelId: String, assetModelName: String, assetModelProperties: [AssetModelProperty]? = nil, clientToken: String? = UpdateAssetModelRequest.idempotencyToken()) {
            self.assetModelCompositeModels = assetModelCompositeModels
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.assetModelCompositeModels?.forEach {
                try $0.validate(name: "\(name).assetModelCompositeModels[]")
            }
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelCompositeModels
            case assetModelDescription
            case assetModelHierarchies
            case assetModelName
            case assetModelProperties
            case clientToken
        }
    }

    public struct UpdateAssetModelResponse: AWSDecodableShape {
        /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus
        }
    }

    public struct UpdateAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")),
            AWSMemberEncoding(label: "propertyId", location: .uri(locationName: "propertyId"))
        ]

        /// The ID of the asset to be updated.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
        public let propertyAlias: String?
        /// The ID of the asset property to be updated.
        public let propertyId: String
        /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see Interacting with other services in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
        public let propertyNotificationState: PropertyNotificationState?

        public init(assetId: String, clientToken: String? = UpdateAssetPropertyRequest.idempotencyToken(), propertyAlias: String? = nil, propertyId: String, propertyNotificationState: PropertyNotificationState? = nil) {
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyNotificationState = propertyNotificationState
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case propertyAlias
            case propertyNotificationState
        }
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the asset to update.
        public let assetId: String
        /// A unique, friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetId: String, assetName: String, clientToken: String? = UpdateAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.assetName = assetName
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: String, CodingKey {
            case assetName
            case clientToken
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {
        /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "dashboardId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The new dashboard definition, as specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A new description for the dashboard.
        public let dashboardDescription: String?
        /// The ID of the dashboard to update.
        public let dashboardId: String
        /// A new friendly name for the dashboard.
        public let dashboardName: String

        public init(clientToken: String? = UpdateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardName: String) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardName = dashboardName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204_800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, min: 0)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: ".+")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case dashboardDefinition
            case dashboardDescription
            case dashboardName
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The JSON document that defines the configuration for the gateway capability. For more information, see Configuring data sources (CLI) in the IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway to be updated.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, max: 104_857_600)
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration
            case capabilityNamespace
        }
    }

    public struct UpdateGatewayCapabilityConfigurationResponse: AWSDecodableShape {
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.   After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace
            case capabilitySyncStatus
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The ID of the gateway to update.
        public let gatewayId: String
        /// A unique, friendly name for the gateway.
        public let gatewayName: String

        public init(gatewayId: String, gatewayName: String) {
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId"))
        ]

        /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see Monitoring with alarms in the IoT SiteWise Application Guide.
        public let alarms: Alarms?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The email address that sends alarm notifications.
        public let notificationSenderEmail: String?
        /// The Amazon Web Services administrator's contact email address.
        public let portalContactEmail: String
        /// A new description for the portal.
        public let portalDescription: String?
        /// The ID of the portal to update.
        public let portalId: String
        public let portalLogoImage: Image?
        /// A new friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see Using service roles for IoT SiteWise Monitor in the IoT SiteWise User Guide.
        public let roleArn: String

        public init(alarms: Alarms? = nil, clientToken: String? = UpdatePortalRequest.idempotencyToken(), notificationSenderEmail: String? = nil, portalContactEmail: String, portalDescription: String? = nil, portalId: String, portalLogoImage: Image? = nil, portalName: String, roleArn: String) {
            self.alarms = alarms
            self.clientToken = clientToken
            self.notificationSenderEmail = notificationSenderEmail
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLogoImage = portalLogoImage
            self.portalName = portalName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.alarms?.validate(name: "\(name).alarms")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, max: 255)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, min: 1)
            try self.validate(self.notificationSenderEmail, name: "notificationSenderEmail", parent: name, pattern: "[^@]+@[^@]+")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "[^@]+@[^@]+")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.portalLogoImage?.validate(name: "\(name).portalLogoImage")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case alarms
            case clientToken
            case notificationSenderEmail
            case portalContactEmail
            case portalDescription
            case portalLogoImage
            case portalName
            case roleArn
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {
        /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A new description for the project.
        public let projectDescription: String?
        /// The ID of the project to update.
        public let projectId: String
        /// A new friendly name for the project.
        public let projectName: String

        public init(clientToken: String? = UpdateProjectRequest.idempotencyToken(), projectDescription: String? = nil, projectId: String, projectName: String) {
            self.clientToken = clientToken
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case projectDescription
            case projectName
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserIdentity: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services SSO ID of the user.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct VariableValue: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see Asset hierarchies in the IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model.
        public let propertyId: String

        public init(hierarchyId: String? = nil, propertyId: String) {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 256)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 256)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 1)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyId
            case propertyId
        }
    }

    public struct Variant: AWSEncodableShape & AWSDecodableShape {
        /// Asset property data of type Boolean (true or false).
        public let booleanValue: Bool?
        /// Asset property data of type double (floating point number).
        public let doubleValue: Double?
        /// Asset property data of type integer (whole number).
        public let integerValue: Int?
        /// Asset property data of type string (sequence of characters).
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, integerValue: Int? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue
            case doubleValue
            case integerValue
            case stringValue
        }
    }
}
