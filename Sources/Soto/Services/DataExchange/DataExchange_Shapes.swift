//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension DataExchange {
    // MARK: Enums

    public enum AssetType: String, CustomStringConvertible, Codable {
        case s3Snapshot = "S3_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum Code: String, CustomStringConvertible, Codable {
        case accessDeniedException = "ACCESS_DENIED_EXCEPTION"
        case internalServerException = "INTERNAL_SERVER_EXCEPTION"
        case malwareDetected = "MALWARE_DETECTED"
        case malwareScanEncryptedFile = "MALWARE_SCAN_ENCRYPTED_FILE"
        case resourceNotFoundException = "RESOURCE_NOT_FOUND_EXCEPTION"
        case serviceQuotaExceededException = "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
        case validationException = "VALIDATION_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum JobErrorLimitName: String, CustomStringConvertible, Codable {
        case assetSizeInGb = "Asset size in GB"
        case assetsPerRevision = "Assets per revision"
        public var description: String { return self.rawValue }
    }

    public enum JobErrorResourceTypes: String, CustomStringConvertible, Codable {
        case asset = "ASSET"
        case revision = "REVISION"
        public var description: String { return self.rawValue }
    }

    public enum Origin: String, CustomStringConvertible, Codable {
        case entitled = "ENTITLED"
        case owned = "OWNED"
        public var description: String { return self.rawValue }
    }

    public enum ServerSideEncryptionTypes: String, CustomStringConvertible, Codable {
        case aes256 = "AES256"
        case awsKms = "aws:kms"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        case timedOut = "TIMED_OUT"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case exportAssetToSignedUrl = "EXPORT_ASSET_TO_SIGNED_URL"
        case exportAssetsToS3 = "EXPORT_ASSETS_TO_S3"
        case exportRevisionsToS3 = "EXPORT_REVISIONS_TO_S3"
        case importAssetFromSignedUrl = "IMPORT_ASSET_FROM_SIGNED_URL"
        case importAssetsFromS3 = "IMPORT_ASSETS_FROM_S3"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssetDestinationEntry: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the asset.
        public let assetId: String
        /// The S3 bucket that is the destination for the asset.
        public let bucket: String
        /// The name of the object in Amazon S3 for the asset.
        public let key: String?

        public init(assetId: String, bucket: String, key: String? = nil) {
            self.assetId = assetId
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct AssetDetails: AWSDecodableShape {
        public let s3SnapshotAsset: S3SnapshotAsset?

        public init(s3SnapshotAsset: S3SnapshotAsset? = nil) {
            self.s3SnapshotAsset = s3SnapshotAsset
        }

        private enum CodingKeys: String, CodingKey {
            case s3SnapshotAsset = "S3SnapshotAsset"
        }
    }

    public struct AssetEntry: AWSDecodableShape {
        /// The ARN for the asset.
        public let arn: String
        /// Information about the asset, including its size.
        public let assetDetails: AssetDetails
        /// The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.
        public let assetType: AssetType
        /// The date and time that the asset was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier for the data set associated with this asset.
        public let dataSetId: String
        /// The unique identifier for the asset.
        public let id: String
        /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.
        public let name: String
        /// The unique identifier for the revision associated with this asset.
        public let revisionId: String
        /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
        public let sourceId: String?
        /// The date and time that the asset was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(arn: String, assetDetails: AssetDetails, assetType: AssetType, createdAt: Date, dataSetId: String, id: String, name: String, revisionId: String, sourceId: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetDetails = "AssetDetails"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case id = "Id"
            case name = "Name"
            case revisionId = "RevisionId"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AssetSourceEntry: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket that's part of the source of the asset.
        public let bucket: String
        /// The name of the object in Amazon S3 for the asset.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct CancelJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "JobId"))
        ]

        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateDataSetRequest: AWSEncodableShape {
        /// The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.
        public let assetType: AssetType
        /// A description for the data set. This value can be up to 16,348 characters long.
        public let description: String
        /// The name of the data set.
        public let name: String
        /// A data set tag is an optional label that you can assign to a data set when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
        public let tags: [String: String]?

        public init(assetType: AssetType, description: String, name: String, tags: [String: String]? = nil) {
            self.assetType = assetType
            self.description = description
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assetType = "AssetType"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateDataSetResponse: AWSDecodableShape {
        public let arn: String?
        public let assetType: AssetType?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let description: String?
        public let id: String?
        public let name: String?
        public let origin: Origin?
        public let originDetails: OriginDetails?
        public let sourceId: String?
        public let tags: [String: String]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, origin: Origin? = nil, originDetails: OriginDetails? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// The details for the CreateJob request.
        public let details: RequestDetails
        /// The type of job to be created.
        public let type: `Type`

        public init(details: RequestDetails, type: `Type`) {
            self.details = details
            self.type = type
        }

        public func validate(name: String) throws {
            try self.details.validate(name: "\(name).details")
        }

        private enum CodingKeys: String, CodingKey {
            case details = "Details"
            case type = "Type"
        }
    }

    public struct CreateJobResponse: AWSDecodableShape {
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let details: ResponseDetails?
        public let errors: [JobError]?
        public let id: String?
        public let state: State?
        public let type: `Type`?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, createdAt: Date? = nil, details: ResponseDetails? = nil, errors: [JobError]? = nil, id: String? = nil, state: State? = nil, type: `Type`? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case details = "Details"
            case errors = "Errors"
            case id = "Id"
            case state = "State"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        /// An optional comment about the revision.
        public let comment: String?
        public let dataSetId: String
        /// A revision tag is an optional label that you can assign to a revision when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
        public let tags: [String: String]?

        public init(comment: String? = nil, dataSetId: String, tags: [String: String]? = nil) {
            self.comment = comment
            self.dataSetId = dataSetId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 16384)
            try self.validate(self.comment, name: "comment", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case tags = "Tags"
        }
    }

    public struct CreateRevisionResponse: AWSDecodableShape {
        public let arn: String?
        public let comment: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let dataSetId: String?
        public let finalized: Bool?
        public let id: String?
        public let sourceId: String?
        public let tags: [String: String]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct DataSetEntry: AWSDecodableShape {
        /// The ARN for the data set.
        public let arn: String
        /// The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.
        public let assetType: AssetType
        /// The date and time that the data set was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description for the data set.
        public let description: String
        /// The unique identifier for the data set.
        public let id: String
        /// The name of the data set.
        public let name: String
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        public let origin: Origin
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public let originDetails: OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public let sourceId: String?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(arn: String, assetType: AssetType, createdAt: Date, description: String, id: String, name: String, origin: Origin, originDetails: OriginDetails? = nil, sourceId: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "AssetId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        public let assetId: String
        public let dataSetId: String
        public let revisionId: String

        public init(assetId: String, dataSetId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        public let dataSetId: String

        public init(dataSetId: String) {
            self.dataSetId = dataSetId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        public let dataSetId: String
        public let revisionId: String

        public init(dataSetId: String, revisionId: String) {
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Details: AWSDecodableShape {
        public let importAssetFromSignedUrlJobErrorDetails: ImportAssetFromSignedUrlJobErrorDetails?
        public let importAssetsFromS3JobErrorDetails: [AssetSourceEntry]?

        public init(importAssetFromSignedUrlJobErrorDetails: ImportAssetFromSignedUrlJobErrorDetails? = nil, importAssetsFromS3JobErrorDetails: [AssetSourceEntry]? = nil) {
            self.importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails
            self.importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case importAssetFromSignedUrlJobErrorDetails = "ImportAssetFromSignedUrlJobErrorDetails"
            case importAssetsFromS3JobErrorDetails = "ImportAssetsFromS3JobErrorDetails"
        }
    }

    public struct ExportAssetToSignedUrlRequestDetails: AWSEncodableShape {
        /// The unique identifier for the asset that is exported to a signed URL.
        public let assetId: String
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this export request.
        public let revisionId: String

        public init(assetId: String, dataSetId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct ExportAssetToSignedUrlResponseDetails: AWSDecodableShape {
        /// The unique identifier for the asset associated with this export job.
        public let assetId: String
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this export response.
        public let revisionId: String
        /// The signed URL for the export request.
        public let signedUrl: String?
        /// The date and time that the signed URL expires, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var signedUrlExpiresAt: Date?

        public init(assetId: String, dataSetId: String, revisionId: String, signedUrl: String? = nil, signedUrlExpiresAt: Date? = nil) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
            case signedUrl = "SignedUrl"
            case signedUrlExpiresAt = "SignedUrlExpiresAt"
        }
    }

    public struct ExportAssetsToS3RequestDetails: AWSEncodableShape {
        /// The destination for the asset.
        public let assetDestinations: [AssetDestinationEntry]
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration for the export job.
        public let encryption: ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export request.
        public let revisionId: String

        public init(assetDestinations: [AssetDestinationEntry], dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionId: String) {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetDestinations = "AssetDestinations"
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionId = "RevisionId"
        }
    }

    public struct ExportAssetsToS3ResponseDetails: AWSDecodableShape {
        /// The destination in Amazon S3 where the asset is exported.
        public let assetDestinations: [AssetDestinationEntry]
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration of the export job.
        public let encryption: ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export response.
        public let revisionId: String

        public init(assetDestinations: [AssetDestinationEntry], dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionId: String) {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetDestinations = "AssetDestinations"
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionId = "RevisionId"
        }
    }

    public struct ExportRevisionsToS3RequestDetails: AWSEncodableShape {
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration for the export job.
        public let encryption: ExportServerSideEncryption?
        /// The destination for the revision.
        public let revisionDestinations: [RevisionDestinationEntry]

        public init(dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionDestinations: [RevisionDestinationEntry]) {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionDestinations = revisionDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionDestinations = "RevisionDestinations"
        }
    }

    public struct ExportRevisionsToS3ResponseDetails: AWSDecodableShape {
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration of the export job.
        public let encryption: ExportServerSideEncryption?
        /// The destination in Amazon S3 where the revision is exported.
        public let revisionDestinations: [RevisionDestinationEntry]

        public init(dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionDestinations: [RevisionDestinationEntry]) {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionDestinations = revisionDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionDestinations = "RevisionDestinations"
        }
    }

    public struct ExportServerSideEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the the AWS KMS key you want to use to encrypt the Amazon S3 objects. This parameter is required if you choose aws:kms as an encryption type.
        public let kmsKeyArn: String?
        /// The type of server side encryption used for encrypting the objects in Amazon S3.
        public let type: ServerSideEncryptionTypes

        public init(kmsKeyArn: String? = nil, type: ServerSideEncryptionTypes) {
            self.kmsKeyArn = kmsKeyArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case type = "Type"
        }
    }

    public struct GetAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "AssetId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        public let assetId: String
        public let dataSetId: String
        public let revisionId: String

        public init(assetId: String, dataSetId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetResponse: AWSDecodableShape {
        public let arn: String?
        public let assetDetails: AssetDetails?
        public let assetType: AssetType?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let dataSetId: String?
        public let id: String?
        public let name: String?
        public let revisionId: String?
        public let sourceId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, assetDetails: AssetDetails? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, dataSetId: String? = nil, id: String? = nil, name: String? = nil, revisionId: String? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetDetails = "AssetDetails"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case id = "Id"
            case name = "Name"
            case revisionId = "RevisionId"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        public let dataSetId: String

        public init(dataSetId: String) {
            self.dataSetId = dataSetId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSetResponse: AWSDecodableShape {
        public let arn: String?
        public let assetType: AssetType?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let description: String?
        public let id: String?
        public let name: String?
        public let origin: Origin?
        public let originDetails: OriginDetails?
        public let sourceId: String?
        public let tags: [String: String]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, origin: Origin? = nil, originDetails: OriginDetails? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "JobId"))
        ]

        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobResponse: AWSDecodableShape {
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let details: ResponseDetails?
        public let errors: [JobError]?
        public let id: String?
        public let state: State?
        public let type: `Type`?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, createdAt: Date? = nil, details: ResponseDetails? = nil, errors: [JobError]? = nil, id: String? = nil, state: State? = nil, type: `Type`? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case details = "Details"
            case errors = "Errors"
            case id = "Id"
            case state = "State"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        public let dataSetId: String
        public let revisionId: String

        public init(dataSetId: String, revisionId: String) {
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRevisionResponse: AWSDecodableShape {
        public let arn: String?
        public let comment: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let dataSetId: String?
        public let finalized: Bool?
        public let id: String?
        public let sourceId: String?
        public let tags: [String: String]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ImportAssetFromSignedUrlJobErrorDetails: AWSDecodableShape {
        public let assetName: String

        public init(assetName: String) {
            self.assetName = assetName
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
        }
    }

    public struct ImportAssetFromSignedUrlRequestDetails: AWSEncodableShape {
        /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name.
        public let assetName: String
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        public let md5Hash: String
        /// The unique identifier for the revision associated with this import request.
        public let revisionId: String

        public init(assetName: String, dataSetId: String, md5Hash: String, revisionId: String) {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.md5Hash, name: "md5Hash", parent: name, max: 24)
            try self.validate(self.md5Hash, name: "md5Hash", parent: name, min: 24)
            try self.validate(self.md5Hash, name: "md5Hash", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
            case dataSetId = "DataSetId"
            case md5Hash = "Md5Hash"
            case revisionId = "RevisionId"
        }
    }

    public struct ImportAssetFromSignedUrlResponseDetails: AWSDecodableShape {
        /// The name for the asset associated with this import response.
        public let assetName: String
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        public let md5Hash: String?
        /// The unique identifier for the revision associated with this import response.
        public let revisionId: String
        /// The signed URL.
        public let signedUrl: String?
        /// The time and date at which the signed URL expires, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var signedUrlExpiresAt: Date?

        public init(assetName: String, dataSetId: String, md5Hash: String? = nil, revisionId: String, signedUrl: String? = nil, signedUrlExpiresAt: Date? = nil) {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
            case dataSetId = "DataSetId"
            case md5Hash = "Md5Hash"
            case revisionId = "RevisionId"
            case signedUrl = "SignedUrl"
            case signedUrlExpiresAt = "SignedUrlExpiresAt"
        }
    }

    public struct ImportAssetsFromS3RequestDetails: AWSEncodableShape {
        /// Is a list of S3 bucket and object key pairs.
        public let assetSources: [AssetSourceEntry]
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import request.
        public let revisionId: String

        public init(assetSources: [AssetSourceEntry], dataSetId: String, revisionId: String) {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSources = "AssetSources"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct ImportAssetsFromS3ResponseDetails: AWSDecodableShape {
        /// Is a list of Amazon S3 bucket and object key pairs.
        public let assetSources: [AssetSourceEntry]
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import response.
        public let revisionId: String

        public init(assetSources: [AssetSourceEntry], dataSetId: String, revisionId: String) {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSources = "AssetSources"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct JobEntry: AWSDecodableShape {
        /// The ARN for the job.
        public let arn: String
        /// The date and time that the job was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Details of the operation to be performed by the job, such as export destination details or import source details.
        public let details: ResponseDetails
        /// Errors for jobs.
        public let errors: [JobError]?
        /// The unique identifier for the job.
        public let id: String
        /// The state of the job.
        public let state: State
        /// The job type.
        public let type: `Type`
        /// The date and time that the job was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(arn: String, createdAt: Date, details: ResponseDetails, errors: [JobError]? = nil, id: String, state: State, type: `Type`, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case details = "Details"
            case errors = "Errors"
            case id = "Id"
            case state = "State"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct JobError: AWSDecodableShape {
        /// The code for the job error.
        public let code: Code
        public let details: Details?
        /// The name of the limit that was reached.
        public let limitName: JobErrorLimitName?
        /// The value of the exceeded limit.
        public let limitValue: Double?
        /// The message related to the job error.
        public let message: String
        /// The unique identifier for the resource related to the error.
        public let resourceId: String?
        /// The type of resource related to the error.
        public let resourceType: JobErrorResourceTypes?

        public init(code: Code, details: Details? = nil, limitName: JobErrorLimitName? = nil, limitValue: Double? = nil, message: String, resourceId: String? = nil, resourceType: JobErrorResourceTypes? = nil) {
            self.code = code
            self.details = details
            self.limitName = limitName
            self.limitValue = limitValue
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case details = "Details"
            case limitName = "LimitName"
            case limitValue = "LimitValue"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ListDataSetRevisionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let dataSetId: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetRevisionsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let revisions: [RevisionEntry]?

        public init(nextToken: String? = nil, revisions: [RevisionEntry]? = nil) {
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case revisions = "Revisions"
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "origin", location: .querystring(locationName: "origin"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let origin: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, origin: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        public let dataSets: [DataSetEntry]?
        public let nextToken: String?

        public init(dataSets: [DataSetEntry]? = nil, nextToken: String? = nil) {
            self.dataSets = dataSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets = "DataSets"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .querystring(locationName: "dataSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "revisionId", location: .querystring(locationName: "revisionId"))
        ]

        public let dataSetId: String?
        public let maxResults: Int?
        public let nextToken: String?
        public let revisionId: String?

        public init(dataSetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, revisionId: String? = nil) {
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResponse: AWSDecodableShape {
        public let jobs: [JobEntry]?
        public let nextToken: String?

        public init(jobs: [JobEntry]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListRevisionAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        public let dataSetId: String
        public let maxResults: Int?
        public let nextToken: String?
        public let revisionId: String

        public init(dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil, revisionId: String) {
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRevisionAssetsResponse: AWSDecodableShape {
        public let assets: [AssetEntry]?
        public let nextToken: String?

        public init(assets: [AssetEntry]? = nil, nextToken: String? = nil) {
            self.assets = assets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct OriginDetails: AWSDecodableShape {
        public let productId: String

        public init(productId: String) {
            self.productId = productId
        }

        private enum CodingKeys: String, CodingKey {
            case productId = "ProductId"
        }
    }

    public struct RequestDetails: AWSEncodableShape {
        /// Details about the export to Amazon S3 request.
        public let exportAssetsToS3: ExportAssetsToS3RequestDetails?
        /// Details about the export to signed URL request.
        public let exportAssetToSignedUrl: ExportAssetToSignedUrlRequestDetails?
        /// Details about the export to Amazon S3 request.
        public let exportRevisionsToS3: ExportRevisionsToS3RequestDetails?
        /// Details about the import from signed URL request.
        public let importAssetFromSignedUrl: ImportAssetFromSignedUrlRequestDetails?
        /// Details about the import from Amazon S3 request.
        public let importAssetsFromS3: ImportAssetsFromS3RequestDetails?

        public init(exportAssetsToS3: ExportAssetsToS3RequestDetails? = nil, exportAssetToSignedUrl: ExportAssetToSignedUrlRequestDetails? = nil, exportRevisionsToS3: ExportRevisionsToS3RequestDetails? = nil, importAssetFromSignedUrl: ImportAssetFromSignedUrlRequestDetails? = nil, importAssetsFromS3: ImportAssetsFromS3RequestDetails? = nil) {
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromS3 = importAssetsFromS3
        }

        public func validate(name: String) throws {
            try self.importAssetFromSignedUrl?.validate(name: "\(name).importAssetFromSignedUrl")
        }

        private enum CodingKeys: String, CodingKey {
            case exportAssetsToS3 = "ExportAssetsToS3"
            case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
            case exportRevisionsToS3 = "ExportRevisionsToS3"
            case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
            case importAssetsFromS3 = "ImportAssetsFromS3"
        }
    }

    public struct ResponseDetails: AWSDecodableShape {
        /// Details for the export to Amazon S3 response.
        public let exportAssetsToS3: ExportAssetsToS3ResponseDetails?
        /// Details for the export to signed URL response.
        public let exportAssetToSignedUrl: ExportAssetToSignedUrlResponseDetails?
        /// Details for the export revisions to Amazon S3 response.
        public let exportRevisionsToS3: ExportRevisionsToS3ResponseDetails?
        /// Details for the import from signed URL response.
        public let importAssetFromSignedUrl: ImportAssetFromSignedUrlResponseDetails?
        /// Details for the import from Amazon S3 response.
        public let importAssetsFromS3: ImportAssetsFromS3ResponseDetails?

        public init(exportAssetsToS3: ExportAssetsToS3ResponseDetails? = nil, exportAssetToSignedUrl: ExportAssetToSignedUrlResponseDetails? = nil, exportRevisionsToS3: ExportRevisionsToS3ResponseDetails? = nil, importAssetFromSignedUrl: ImportAssetFromSignedUrlResponseDetails? = nil, importAssetsFromS3: ImportAssetsFromS3ResponseDetails? = nil) {
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromS3 = importAssetsFromS3
        }

        private enum CodingKeys: String, CodingKey {
            case exportAssetsToS3 = "ExportAssetsToS3"
            case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
            case exportRevisionsToS3 = "ExportRevisionsToS3"
            case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
            case importAssetsFromS3 = "ImportAssetsFromS3"
        }
    }

    public struct RevisionDestinationEntry: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket that is the destination for the assets in the revision.
        public let bucket: String
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see Key patterns when exporting revisions.
        public let keyPattern: String?
        /// The unique identifier for the revision.
        public let revisionId: String

        public init(bucket: String, keyPattern: String? = nil, revisionId: String) {
            self.bucket = bucket
            self.keyPattern = keyPattern
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case keyPattern = "KeyPattern"
            case revisionId = "RevisionId"
        }
    }

    public struct RevisionEntry: AWSDecodableShape {
        /// The ARN for the revision.
        public let arn: String
        /// An optional comment about the revision.
        public let comment: String?
        /// The date and time that the revision was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier for the data set associated with this revision.
        public let dataSetId: String
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public let finalized: Bool?
        /// The unique identifier for the revision.
        public let id: String
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public let sourceId: String?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(arn: String, comment: String? = nil, createdAt: Date, dataSetId: String, finalized: Bool? = nil, id: String, sourceId: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct S3SnapshotAsset: AWSDecodableShape {
        /// The size of the S3 object that is the object.
        public let size: Double

        public init(size: Double) {
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
        }
    }

    public struct StartJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "JobId"))
        ]

        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "AssetId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        public let assetId: String
        public let dataSetId: String
        /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.
        public let name: String
        public let revisionId: String

        public init(assetId: String, dataSetId: String, name: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.name = name
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {
        public let arn: String?
        public let assetDetails: AssetDetails?
        public let assetType: AssetType?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let dataSetId: String?
        public let id: String?
        public let name: String?
        public let revisionId: String?
        public let sourceId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, assetDetails: AssetDetails? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, dataSetId: String? = nil, id: String? = nil, name: String? = nil, revisionId: String? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetDetails = "AssetDetails"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case id = "Id"
            case name = "Name"
            case revisionId = "RevisionId"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct UpdateDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        public let dataSetId: String
        /// The description for the data set.
        public let description: String?
        /// The name of the data set.
        public let name: String?

        public init(dataSetId: String, description: String? = nil, name: String? = nil) {
            self.dataSetId = dataSetId
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateDataSetResponse: AWSDecodableShape {
        public let arn: String?
        public let assetType: AssetType?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let description: String?
        public let id: String?
        public let name: String?
        public let origin: Origin?
        public let originDetails: OriginDetails?
        public let sourceId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, origin: Origin? = nil, originDetails: OriginDetails? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct UpdateRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "revisionId", location: .uri(locationName: "RevisionId"))
        ]

        /// An optional comment about the revision.
        public let comment: String?
        public let dataSetId: String
        /// Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.
        public let finalized: Bool?
        public let revisionId: String

        public init(comment: String? = nil, dataSetId: String, finalized: Bool? = nil, revisionId: String) {
            self.comment = comment
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 16384)
            try self.validate(self.comment, name: "comment", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case finalized = "Finalized"
        }
    }

    public struct UpdateRevisionResponse: AWSDecodableShape {
        public let arn: String?
        public let comment: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let dataSetId: String?
        public let finalized: Bool?
        public let id: String?
        public let sourceId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }
}
