//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DataExchange {
    // MARK: Enums

    public enum AcceptanceStateFilterValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case pendingReceiverAcceptance = "PENDING_RECEIVER_ACCEPTANCE"
        public var description: String { return self.rawValue }
    }

    public enum AssetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apiGatewayApi = "API_GATEWAY_API"
        case lakeFormationDataPermission = "LAKE_FORMATION_DATA_PERMISSION"
        case redshiftDataShare = "REDSHIFT_DATA_SHARE"
        case s3DataAccess = "S3_DATA_ACCESS"
        case s3Snapshot = "S3_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum Code: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "ACCESS_DENIED_EXCEPTION"
        case internalServerException = "INTERNAL_SERVER_EXCEPTION"
        case malwareDetected = "MALWARE_DETECTED"
        case malwareScanEncryptedFile = "MALWARE_SCAN_ENCRYPTED_FILE"
        case resourceNotFoundException = "RESOURCE_NOT_FOUND_EXCEPTION"
        case serviceQuotaExceededException = "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
        case validationException = "VALIDATION_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum DataGrantAcceptanceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case pendingReceiverAcceptance = "PENDING_RECEIVER_ACCEPTANCE"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseLFTagPolicyPermission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case describe = "DESCRIBE"
        public var description: String { return self.rawValue }
    }

    public enum ExceptionCause: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case insufficientS3BucketPolicy = "InsufficientS3BucketPolicy"
        case s3AccessDenied = "S3AccessDenied"
        public var description: String { return self.rawValue }
    }

    public enum GrantDistributionScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsOrganization = "AWS_ORGANIZATION"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum JobErrorLimitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsLakeFormationDataPermissionAssetsPerRevision = "AWS Lake Formation data permission assets per revision"
        case amazonRedshiftDatashareAssetsPerRevision = "Amazon Redshift datashare assets per revision"
        case amazonS3DataAccessAssetsPerRevision = "Amazon S3 data access assets per revision"
        case assetSizeInGB = "Asset size in GB"
        case assetsPerRevision = "Assets per revision"
        public var description: String { return self.rawValue }
    }

    public enum JobErrorResourceTypes: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case dataSet = "DATA_SET"
        case revision = "REVISION"
        public var description: String { return self.rawValue }
    }

    public enum LFPermission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case describe = "DESCRIBE"
        case select = "SELECT"
        public var description: String { return self.rawValue }
    }

    public enum LFResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case database = "DATABASE"
        case table = "TABLE"
        public var description: String { return self.rawValue }
    }

    public enum LakeFormationDataPermissionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lfTagPolicy = "LFTagPolicy"
        public var description: String { return self.rawValue }
    }

    public enum LimitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsLakeFormationDataPermissionAssetsPerRevision = "AWS Lake Formation data permission assets per revision"
        case activeAndPendingDataGrants = "Active and pending data grants"
        case amazonAPIGatewayAPIAssetsPerRevision = "Amazon API Gateway API assets per revision"
        case amazonRedshiftDatashareAssetsPerImportJobFromRedshift = "Amazon Redshift datashare assets per import job from Redshift"
        case amazonRedshiftDatashareAssetsPerRevision = "Amazon Redshift datashare assets per revision"
        case amazonS3DataAccessAssetsPerRevision = "Amazon S3 data access assets per revision"
        case assetPerExportJobFromAmazonS3 = "Asset per export job from Amazon S3"
        case assetSizeInGB = "Asset size in GB"
        case assetsPerImportJobFromAmazonS3 = "Assets per import job from Amazon S3"
        case assetsPerRevision = "Assets per revision"
        case autoExportEventActionsPerDataSet = "Auto export event actions per data set"
        case concurrentInProgressJobsToCreateAmazonS3DataAccessAssetsFromS3Buckets = "Concurrent in progress jobs to create Amazon S3 data access assets from S3 buckets"
        case concurrentInProgressJobsToExportAssetsToAmazonS3 = "Concurrent in progress jobs to export assets to Amazon S3"
        case concurrentInProgressJobsToExportAssetsToASignedURL = "Concurrent in progress jobs to export assets to a signed URL"
        case concurrentInProgressJobsToExportRevisionsToAmazonS3 = "Concurrent in progress jobs to export revisions to Amazon S3"
        case concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares = "Concurrent in progress jobs to import assets from Amazon Redshift datashares"
        case concurrentInProgressJobsToImportAssetsFromAmazonS3 = "Concurrent in progress jobs to import assets from Amazon S3"
        case concurrentInProgressJobsToImportAssetsFromASignedURL = "Concurrent in progress jobs to import assets from a signed URL"
        case concurrentInProgressJobsToImportAssetsFromAnAPIGatewayAPI = "Concurrent in progress jobs to import assets from an API Gateway API"
        case concurrentInProgressJobsToImportAssetsFromAnAWSLakeFormationTagPolicy = "Concurrent in progress jobs to import assets from an AWS Lake Formation tag policy"
        case dataSetsPerAccount = "Data sets per account"
        case dataSetsPerProduct = "Data sets per product"
        case eventActionsPerAccount = "Event actions per account"
        case pendingDataGrantsPerConsumer = "Pending data grants per consumer"
        case productsPerAccount = "Products per account"
        case revisionsPerAWSLakeFormationDataPermissionDataSet = "Revisions per AWS Lake Formation data permission data set"
        case revisionsPerAmazonAPIGatewayAPIDataSet = "Revisions per Amazon API Gateway API data set"
        case revisionsPerAmazonRedshiftDatashareDataSet = "Revisions per Amazon Redshift datashare data set"
        case revisionsPerAmazonS3DataAccessDataSet = "Revisions per Amazon S3 data access data set"
        case revisionsPerDataSet = "Revisions per data set"
        public var description: String { return self.rawValue }
    }

    public enum NotificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataDelay = "DATA_DELAY"
        case dataUpdate = "DATA_UPDATE"
        case deprecation = "DEPRECATION"
        case schemaChange = "SCHEMA_CHANGE"
        public var description: String { return self.rawValue }
    }

    public enum Origin: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case entitled = "ENTITLED"
        case owned = "OWNED"
        public var description: String { return self.rawValue }
    }

    public enum ProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rest = "REST"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case dataGrant = "DATA_GRANT"
        case dataSet = "DATA_SET"
        case eventAction = "EVENT_ACTION"
        case job = "JOB"
        case revision = "REVISION"
        public var description: String { return self.rawValue }
    }

    public enum SchemaChangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "ADD"
        case modify = "MODIFY"
        case remove = "REMOVE"
        public var description: String { return self.rawValue }
    }

    public enum ServerSideEncryptionTypes: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes256 = "AES256"
        case awsKms = "aws:kms"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        case timedOut = "TIMED_OUT"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum TableTagPolicyLFPermission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case describe = "DESCRIBE"
        case select = "SELECT"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createS3DataAccessFromS3Bucket = "CREATE_S3_DATA_ACCESS_FROM_S3_BUCKET"
        case exportAssetsToS3 = "EXPORT_ASSETS_TO_S3"
        case exportAssetToSignedUrl = "EXPORT_ASSET_TO_SIGNED_URL"
        case exportRevisionsToS3 = "EXPORT_REVISIONS_TO_S3"
        case importAssetsFromLakeFormationTagPolicy = "IMPORT_ASSETS_FROM_LAKE_FORMATION_TAG_POLICY"
        case importAssetsFromRedshiftDataShares = "IMPORT_ASSETS_FROM_REDSHIFT_DATA_SHARES"
        case importAssetsFromS3 = "IMPORT_ASSETS_FROM_S3"
        case importAssetFromApiGatewayApi = "IMPORT_ASSET_FROM_API_GATEWAY_API"
        case importAssetFromSignedUrl = "IMPORT_ASSET_FROM_SIGNED_URL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptDataGrantRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the data grant to accept.
        public let dataGrantArn: String

        @inlinable
        public init(dataGrantArn: String) {
            self.dataGrantArn = dataGrantArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataGrantArn, key: "DataGrantArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataGrantArn, name: "dataGrantArn", parent: name, pattern: "^arn:aws:dataexchange:[\\-a-z0-9]*:(\\d{12}):data-grants\\/[a-zA-Z0-9]{30,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptDataGrantResponse: AWSDecodableShape {
        /// The acceptance state of the data grant.
        public let acceptanceState: DataGrantAcceptanceState
        /// The timestamp of when the data grant was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The Amazon Resource Name (ARN) of the accepted data grant.
        public let arn: String
        /// The timestamp of when the data grant was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the data set associated to the data grant.
        public let dataSetId: String
        /// The description of the accepted data grant.
        public let description: String?
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The distribution scope for the data grant.
        public let grantDistributionScope: GrantDistributionScope
        /// The ID of the data grant.
        public let id: String
        /// The name of the accepted data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The Amazon Web Services account ID of the data grant sender.
        public let senderPrincipal: String?
        /// The timestamp of when the data grant was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(acceptanceState: DataGrantAcceptanceState, acceptedAt: Date? = nil, arn: String, createdAt: Date, dataSetId: String, description: String? = nil, endsAt: Date? = nil, grantDistributionScope: GrantDistributionScope, id: String, name: String, receiverPrincipal: String, senderPrincipal: String? = nil, updatedAt: Date) {
            self.acceptanceState = acceptanceState
            self.acceptedAt = acceptedAt
            self.arn = arn
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.description = description
            self.endsAt = endsAt
            self.grantDistributionScope = grantDistributionScope
            self.id = id
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.senderPrincipal = senderPrincipal
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceState = "AcceptanceState"
            case acceptedAt = "AcceptedAt"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case description = "Description"
            case endsAt = "EndsAt"
            case grantDistributionScope = "GrantDistributionScope"
            case id = "Id"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case senderPrincipal = "SenderPrincipal"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// Details for the export revision to Amazon S3 action.
        public let exportRevisionToS3: AutoExportRevisionToS3RequestDetails?

        @inlinable
        public init(exportRevisionToS3: AutoExportRevisionToS3RequestDetails? = nil) {
            self.exportRevisionToS3 = exportRevisionToS3
        }

        private enum CodingKeys: String, CodingKey {
            case exportRevisionToS3 = "ExportRevisionToS3"
        }
    }

    public struct ApiGatewayApiAsset: AWSDecodableShape {
        /// The API description of the API asset.
        public let apiDescription: String?
        /// The API endpoint of the API asset.
        public let apiEndpoint: String?
        /// The unique identifier of the API asset.
        public let apiId: String?
        /// The API key of the API asset.
        public let apiKey: String?
        /// The API name of the API asset.
        public let apiName: String?
        /// The download URL of the API specification of the API asset.
        public let apiSpecificationDownloadUrl: String?
        /// The date and time that the upload URL expires, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var apiSpecificationDownloadUrlExpiresAt: Date?
        /// The protocol type of the API asset.
        public let protocolType: ProtocolType?
        /// The stage of the API asset.
        public let stage: String?

        @inlinable
        public init(apiDescription: String? = nil, apiEndpoint: String? = nil, apiId: String? = nil, apiKey: String? = nil, apiName: String? = nil, apiSpecificationDownloadUrl: String? = nil, apiSpecificationDownloadUrlExpiresAt: Date? = nil, protocolType: ProtocolType? = nil, stage: String? = nil) {
            self.apiDescription = apiDescription
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationDownloadUrl = apiSpecificationDownloadUrl
            self.apiSpecificationDownloadUrlExpiresAt = apiSpecificationDownloadUrlExpiresAt
            self.protocolType = protocolType
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiDescription = "ApiDescription"
            case apiEndpoint = "ApiEndpoint"
            case apiId = "ApiId"
            case apiKey = "ApiKey"
            case apiName = "ApiName"
            case apiSpecificationDownloadUrl = "ApiSpecificationDownloadUrl"
            case apiSpecificationDownloadUrlExpiresAt = "ApiSpecificationDownloadUrlExpiresAt"
            case protocolType = "ProtocolType"
            case stage = "Stage"
        }
    }

    public struct AssetDestinationEntry: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the asset.
        public let assetId: String
        /// The Amazon S3 bucket that is the destination for the asset.
        public let bucket: String
        /// The name of the object in Amazon S3 for the asset.
        public let key: String?

        @inlinable
        public init(assetId: String, bucket: String, key: String? = nil) {
            self.assetId = assetId
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct AssetDetails: AWSDecodableShape {
        /// Information about the API Gateway API asset.
        public let apiGatewayApiAsset: ApiGatewayApiAsset?
        /// The AWS Lake Formation data permission that is the asset.
        public let lakeFormationDataPermissionAsset: LakeFormationDataPermissionAsset?
        /// The Amazon Redshift datashare that is the asset.
        public let redshiftDataShareAsset: RedshiftDataShareAsset?
        /// The Amazon S3 data access that is the asset.
        public let s3DataAccessAsset: S3DataAccessAsset?
        /// The Amazon S3 object that is the asset.
        public let s3SnapshotAsset: S3SnapshotAsset?

        @inlinable
        public init(apiGatewayApiAsset: ApiGatewayApiAsset? = nil, lakeFormationDataPermissionAsset: LakeFormationDataPermissionAsset? = nil, redshiftDataShareAsset: RedshiftDataShareAsset? = nil, s3DataAccessAsset: S3DataAccessAsset? = nil, s3SnapshotAsset: S3SnapshotAsset? = nil) {
            self.apiGatewayApiAsset = apiGatewayApiAsset
            self.lakeFormationDataPermissionAsset = lakeFormationDataPermissionAsset
            self.redshiftDataShareAsset = redshiftDataShareAsset
            self.s3DataAccessAsset = s3DataAccessAsset
            self.s3SnapshotAsset = s3SnapshotAsset
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayApiAsset = "ApiGatewayApiAsset"
            case lakeFormationDataPermissionAsset = "LakeFormationDataPermissionAsset"
            case redshiftDataShareAsset = "RedshiftDataShareAsset"
            case s3DataAccessAsset = "S3DataAccessAsset"
            case s3SnapshotAsset = "S3SnapshotAsset"
        }
    }

    public struct AssetEntry: AWSDecodableShape {
        /// The ARN for the asset.
        public let arn: String
        /// Details about the asset.
        public let assetDetails: AssetDetails
        /// The type of asset that is added to a data set.
        public let assetType: AssetType
        /// The date and time that the asset was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier for the data set associated with this asset.
        public let dataSetId: String
        /// The unique identifier for the asset.
        public let id: String
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in LF-tag policy" or "Table(s) included in LF-tag policy" are used as the asset name.
        public let name: String
        /// The unique identifier for the revision associated with this asset.
        public let revisionId: String
        /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
        public let sourceId: String?
        /// The date and time that the asset was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, assetDetails: AssetDetails, assetType: AssetType, createdAt: Date, dataSetId: String, id: String, name: String, revisionId: String, sourceId: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetDetails = "AssetDetails"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case id = "Id"
            case name = "Name"
            case revisionId = "RevisionId"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AssetSourceEntry: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket that's part of the source of the asset.
        public let bucket: String
        /// The name of the object in Amazon S3 for the asset.
        public let key: String

        @inlinable
        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct AutoExportRevisionDestinationEntry: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket that is the destination for the event action.
        public let bucket: String
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see Key patterns when exporting revisions.
        public let keyPattern: String?

        @inlinable
        public init(bucket: String, keyPattern: String? = nil) {
            self.bucket = bucket
            self.keyPattern = keyPattern
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case keyPattern = "KeyPattern"
        }
    }

    public struct AutoExportRevisionToS3RequestDetails: AWSEncodableShape & AWSDecodableShape {
        /// Encryption configuration for the auto export job.
        public let encryption: ExportServerSideEncryption?
        /// A revision destination is the Amazon S3 bucket folder destination to where the export will be sent.
        public let revisionDestination: AutoExportRevisionDestinationEntry

        @inlinable
        public init(encryption: ExportServerSideEncryption? = nil, revisionDestination: AutoExportRevisionDestinationEntry) {
            self.encryption = encryption
            self.revisionDestination = revisionDestination
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "Encryption"
            case revisionDestination = "RevisionDestination"
        }
    }

    public struct CancelJobRequest: AWSEncodableShape {
        /// The unique identifier for a job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConflictException: AWSErrorShape {
        /// The request couldn't be completed because it conflicted with the current state of the resource.
        public let message: String
        /// The unique identifier for the resource with the conflict.
        public let resourceId: String?
        /// The type of the resource with the conflict.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateDataGrantRequest: AWSEncodableShape {
        /// The description of the data grant.
        public let description: String?
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The distribution scope of the data grant.
        public let grantDistributionScope: GrantDistributionScope
        /// The name of the data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The ID of the data set used to create the data grant.
        public let sourceDataSetId: String
        /// The tags to add to the data grant. A tag is a key-value pair.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, endsAt: Date? = nil, grantDistributionScope: GrantDistributionScope, name: String, receiverPrincipal: String, sourceDataSetId: String, tags: [String: String]? = nil) {
            self.description = description
            self.endsAt = endsAt
            self.grantDistributionScope = grantDistributionScope
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.sourceDataSetId = sourceDataSetId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.receiverPrincipal, name: "receiverPrincipal", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case endsAt = "EndsAt"
            case grantDistributionScope = "GrantDistributionScope"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case sourceDataSetId = "SourceDataSetId"
            case tags = "Tags"
        }
    }

    public struct CreateDataGrantResponse: AWSDecodableShape {
        /// The acceptance state of the data grant.
        public let acceptanceState: DataGrantAcceptanceState
        /// The timestamp of when the data grant was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The Amazon Resource Name (ARN) of the data grant.
        public let arn: String
        /// The timestamp of when the data grant was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the data set associated to the data grant.
        public let dataSetId: String
        /// The description of the data grant.
        public let description: String?
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The distribution scope for the data grant.
        public let grantDistributionScope: GrantDistributionScope
        /// The ID of the data grant.
        public let id: String
        /// The name of the data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The Amazon Web Services account ID of the data grant sender.
        public let senderPrincipal: String
        /// The ID of the data set used to create the data grant.
        public let sourceDataSetId: String
        /// The tags associated to the data grant. A tag is a key-value pair.
        public let tags: [String: String]?
        /// The timestamp of when the data grant was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(acceptanceState: DataGrantAcceptanceState, acceptedAt: Date? = nil, arn: String, createdAt: Date, dataSetId: String, description: String? = nil, endsAt: Date? = nil, grantDistributionScope: GrantDistributionScope, id: String, name: String, receiverPrincipal: String, senderPrincipal: String, sourceDataSetId: String, tags: [String: String]? = nil, updatedAt: Date) {
            self.acceptanceState = acceptanceState
            self.acceptedAt = acceptedAt
            self.arn = arn
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.description = description
            self.endsAt = endsAt
            self.grantDistributionScope = grantDistributionScope
            self.id = id
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.senderPrincipal = senderPrincipal
            self.sourceDataSetId = sourceDataSetId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceState = "AcceptanceState"
            case acceptedAt = "AcceptedAt"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case description = "Description"
            case endsAt = "EndsAt"
            case grantDistributionScope = "GrantDistributionScope"
            case id = "Id"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case senderPrincipal = "SenderPrincipal"
            case sourceDataSetId = "SourceDataSetId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateDataSetRequest: AWSEncodableShape {
        /// The type of asset that is added to a data set.
        public let assetType: AssetType
        /// A description for the data set. This value can be up to 16,348 characters long.
        public let description: String
        /// The name of the data set.
        public let name: String
        /// A data set tag is an optional label that you can assign to a data set when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
        public let tags: [String: String]?

        @inlinable
        public init(assetType: AssetType, description: String, name: String, tags: [String: String]? = nil) {
            self.assetType = assetType
            self.description = description
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assetType = "AssetType"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateDataSetResponse: AWSDecodableShape {
        /// The ARN for the data set.
        public let arn: String?
        /// The type of asset that is added to a data set.
        public let assetType: AssetType?
        /// The date and time that the data set was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description for the data set.
        public let description: String?
        /// The unique identifier for the data set.
        public let id: String?
        /// The name of the data set.
        public let name: String?
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        public let origin: Origin?
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public let originDetails: OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public let sourceId: String?
        /// The tags for the data set.
        public let tags: [String: String]?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, origin: Origin? = nil, originDetails: OriginDetails? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateEventActionRequest: AWSEncodableShape {
        /// What occurs after a certain event.
        public let action: Action
        /// What occurs to start an action.
        public let event: Event

        @inlinable
        public init(action: Action, event: Event) {
            self.action = action
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case event = "Event"
        }
    }

    public struct CreateEventActionResponse: AWSDecodableShape {
        /// What occurs after a certain event.
        public let action: Action?
        /// The ARN for the event action.
        public let arn: String?
        /// The date and time that the event action was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// What occurs to start an action.
        public let event: Event?
        /// The unique identifier for the event action.
        public let id: String?
        /// The date and time that the event action was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(action: Action? = nil, arn: String? = nil, createdAt: Date? = nil, event: Event? = nil, id: String? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.event = event
            self.id = id
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case event = "Event"
            case id = "Id"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// The details for the CreateJob request.
        public let details: RequestDetails
        /// The type of job to be created.
        public let type: `Type`

        @inlinable
        public init(details: RequestDetails, type: `Type`) {
            self.details = details
            self.type = type
        }

        public func validate(name: String) throws {
            try self.details.validate(name: "\(name).details")
        }

        private enum CodingKeys: String, CodingKey {
            case details = "Details"
            case type = "Type"
        }
    }

    public struct CreateJobResponse: AWSDecodableShape {
        /// The ARN for the job.
        public let arn: String?
        /// The date and time that the job was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// Details about the job.
        public let details: ResponseDetails?
        /// The errors associated with jobs.
        public let errors: [JobError]?
        /// The unique identifier for the job.
        public let id: String?
        /// The state of the job.
        public let state: State?
        /// The job type.
        public let type: `Type`?
        /// The date and time that the job was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, details: ResponseDetails? = nil, errors: [JobError]? = nil, id: String? = nil, state: State? = nil, type: `Type`? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case details = "Details"
            case errors = "Errors"
            case id = "Id"
            case state = "State"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateRevisionRequest: AWSEncodableShape {
        /// An optional comment about the revision.
        public let comment: String?
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// A revision tag is an optional label that you can assign to a revision when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
        public let tags: [String: String]?

        @inlinable
        public init(comment: String? = nil, dataSetId: String, tags: [String: String]? = nil) {
            self.comment = comment
            self.dataSetId = dataSetId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.comment, forKey: .comment)
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 16384)
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case tags = "Tags"
        }
    }

    public struct CreateRevisionResponse: AWSDecodableShape {
        /// The ARN for the revision.
        public let arn: String?
        /// An optional comment about the revision.
        public let comment: String?
        /// The date and time that the revision was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The unique identifier for the data set associated with the data set revision.
        public let dataSetId: String?
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public let finalized: Bool?
        /// The unique identifier for the revision.
        public let id: String?
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public let revocationComment: String?
        /// A status indicating that subscribers' access to the revision was revoked.
        public let revoked: Bool?
        /// The date and time that the revision was revoked, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var revokedAt: Date?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public let sourceId: String?
        /// The tags for the revision.
        public let tags: [String: String]?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, revocationComment: String? = nil, revoked: Bool? = nil, revokedAt: Date? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.revocationComment = revocationComment
            self.revoked = revoked
            self.revokedAt = revokedAt
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case revocationComment = "RevocationComment"
            case revoked = "Revoked"
            case revokedAt = "RevokedAt"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateS3DataAccessFromS3BucketRequestDetails: AWSEncodableShape {
        /// Details about the S3 data access source asset.
        public let assetSource: S3DataAccessAssetSourceEntry
        /// The unique identifier for the data set associated with the creation of this Amazon S3 data access.
        public let dataSetId: String
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(assetSource: S3DataAccessAssetSourceEntry, dataSetId: String, revisionId: String) {
            self.assetSource = assetSource
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.assetSource.validate(name: "\(name).assetSource")
        }

        private enum CodingKeys: String, CodingKey {
            case assetSource = "AssetSource"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct CreateS3DataAccessFromS3BucketResponseDetails: AWSDecodableShape {
        /// Details about the asset source from an Amazon S3 bucket.
        public let assetSource: S3DataAccessAssetSourceEntry
        /// The unique identifier for this data set.
        public let dataSetId: String
        /// The unique identifier for the revision.
        public let revisionId: String

        @inlinable
        public init(assetSource: S3DataAccessAssetSourceEntry, dataSetId: String, revisionId: String) {
            self.assetSource = assetSource
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSource = "AssetSource"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct DataGrantSummaryEntry: AWSDecodableShape {
        /// The acceptance state of the data grant.
        public let acceptanceState: DataGrantAcceptanceState
        /// The timestamp of when the data grant was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The Amazon Resource Name (ARN) of the data grant.
        public let arn: String
        /// The timestamp of when the data grant was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the data set associated to the data grant.
        public let dataSetId: String
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The ID of the data grant.
        public let id: String
        /// The name of the data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The Amazon Web Services account ID of the data grant sender.
        public let senderPrincipal: String
        /// The ID of the data set used to create the data grant.
        public let sourceDataSetId: String
        /// The timestamp of when the data grant was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(acceptanceState: DataGrantAcceptanceState, acceptedAt: Date? = nil, arn: String, createdAt: Date, dataSetId: String, endsAt: Date? = nil, id: String, name: String, receiverPrincipal: String, senderPrincipal: String, sourceDataSetId: String, updatedAt: Date) {
            self.acceptanceState = acceptanceState
            self.acceptedAt = acceptedAt
            self.arn = arn
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.endsAt = endsAt
            self.id = id
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.senderPrincipal = senderPrincipal
            self.sourceDataSetId = sourceDataSetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceState = "AcceptanceState"
            case acceptedAt = "AcceptedAt"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case endsAt = "EndsAt"
            case id = "Id"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case senderPrincipal = "SenderPrincipal"
            case sourceDataSetId = "SourceDataSetId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct DataSetEntry: AWSDecodableShape {
        /// The ARN for the data set.
        public let arn: String
        /// The type of asset that is added to a data set.
        public let assetType: AssetType
        /// The date and time that the data set was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description for the data set.
        public let description: String
        /// The unique identifier for the data set.
        public let id: String
        /// The name of the data set.
        public let name: String
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        public let origin: Origin
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public let originDetails: OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public let sourceId: String?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, assetType: AssetType, createdAt: Date, description: String, id: String, name: String, origin: Origin, originDetails: OriginDetails? = nil, sourceId: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct DataUpdateRequestDetails: AWSEncodableShape {
        /// A datetime in the past when the data was updated. This typically means that the underlying resource supporting the data set was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dataUpdatedAt: Date?

        @inlinable
        public init(dataUpdatedAt: Date? = nil) {
            self.dataUpdatedAt = dataUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataUpdatedAt = "DataUpdatedAt"
        }
    }

    public struct DatabaseLFTagPolicy: AWSDecodableShape {
        /// A list of LF-tag conditions that apply to database resources.
        public let expression: [LFTag]

        @inlinable
        public init(expression: [LFTag]) {
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct DatabaseLFTagPolicyAndPermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of LF-tag conditions that apply to database resources.
        public let expression: [LFTag]
        /// The permissions granted to subscribers on database resources.
        public let permissions: [DatabaseLFTagPolicyPermission]

        @inlinable
        public init(expression: [LFTag], permissions: [DatabaseLFTagPolicyPermission]) {
            self.expression = expression
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case permissions = "Permissions"
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        /// The unique identifier for an asset.
        public let assetId: String
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(assetId: String, dataSetId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "AssetId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataGrantRequest: AWSEncodableShape {
        /// The ID of the data grant to delete.
        public let dataGrantId: String

        @inlinable
        public init(dataGrantId: String) {
            self.dataGrantId = dataGrantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataGrantId, key: "DataGrantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataGrantId, name: "dataGrantId", parent: name, pattern: "^[a-zA-Z0-9]{30,40}$|^arn:aws:dataexchange:[\\-a-z0-9]*:(\\d{12}):data-grants\\/[a-zA-Z0-9]{30,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSetRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String

        @inlinable
        public init(dataSetId: String) {
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventActionRequest: AWSEncodableShape {
        /// The unique identifier for the event action.
        public let eventActionId: String

        @inlinable
        public init(eventActionId: String) {
            self.eventActionId = eventActionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventActionId, key: "EventActionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRevisionRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(dataSetId: String, revisionId: String) {
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeprecationRequestDetails: AWSEncodableShape {
        /// A datetime in the future when the data set will be deprecated.
        @CustomCoding<ISO8601DateCoder>
        public var deprecationAt: Date

        @inlinable
        public init(deprecationAt: Date) {
            self.deprecationAt = deprecationAt
        }

        private enum CodingKeys: String, CodingKey {
            case deprecationAt = "DeprecationAt"
        }
    }

    public struct Details: AWSDecodableShape {
        /// Information about the job error.
        public let importAssetFromSignedUrlJobErrorDetails: ImportAssetFromSignedUrlJobErrorDetails?
        /// Details about the job error.
        public let importAssetsFromS3JobErrorDetails: [AssetSourceEntry]?

        @inlinable
        public init(importAssetFromSignedUrlJobErrorDetails: ImportAssetFromSignedUrlJobErrorDetails? = nil, importAssetsFromS3JobErrorDetails: [AssetSourceEntry]? = nil) {
            self.importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails
            self.importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case importAssetFromSignedUrlJobErrorDetails = "ImportAssetFromSignedUrlJobErrorDetails"
            case importAssetsFromS3JobErrorDetails = "ImportAssetsFromS3JobErrorDetails"
        }
    }

    public struct Event: AWSEncodableShape & AWSDecodableShape {
        /// What occurs to start the revision publish action.
        public let revisionPublished: RevisionPublished?

        @inlinable
        public init(revisionPublished: RevisionPublished? = nil) {
            self.revisionPublished = revisionPublished
        }

        private enum CodingKeys: String, CodingKey {
            case revisionPublished = "RevisionPublished"
        }
    }

    public struct EventActionEntry: AWSDecodableShape {
        /// What occurs after a certain event.
        public let action: Action
        /// The Amazon Resource Name (ARN) for the event action.
        public let arn: String
        /// The date and time that the event action was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// What occurs to start an action.
        public let event: Event
        /// The unique identifier for the event action.
        public let id: String
        /// The date and time that the event action was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(action: Action, arn: String, createdAt: Date, event: Event, id: String, updatedAt: Date) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.event = event
            self.id = id
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case event = "Event"
            case id = "Id"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ExportAssetToSignedUrlRequestDetails: AWSEncodableShape {
        /// The unique identifier for the asset that is exported to a signed URL.
        public let assetId: String
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this export request.
        public let revisionId: String

        @inlinable
        public init(assetId: String, dataSetId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct ExportAssetToSignedUrlResponseDetails: AWSDecodableShape {
        /// The unique identifier for the asset associated with this export job.
        public let assetId: String
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this export response.
        public let revisionId: String
        /// The signed URL for the export request.
        public let signedUrl: String?
        /// The date and time that the signed URL expires, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var signedUrlExpiresAt: Date?

        @inlinable
        public init(assetId: String, dataSetId: String, revisionId: String, signedUrl: String? = nil, signedUrlExpiresAt: Date? = nil) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
            case signedUrl = "SignedUrl"
            case signedUrlExpiresAt = "SignedUrlExpiresAt"
        }
    }

    public struct ExportAssetsToS3RequestDetails: AWSEncodableShape {
        /// The destination for the asset.
        public let assetDestinations: [AssetDestinationEntry]
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration for the export job.
        public let encryption: ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export request.
        public let revisionId: String

        @inlinable
        public init(assetDestinations: [AssetDestinationEntry], dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionId: String) {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetDestinations = "AssetDestinations"
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionId = "RevisionId"
        }
    }

    public struct ExportAssetsToS3ResponseDetails: AWSDecodableShape {
        /// The destination in Amazon S3 where the asset is exported.
        public let assetDestinations: [AssetDestinationEntry]
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration of the export job.
        public let encryption: ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export response.
        public let revisionId: String

        @inlinable
        public init(assetDestinations: [AssetDestinationEntry], dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionId: String) {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetDestinations = "AssetDestinations"
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionId = "RevisionId"
        }
    }

    public struct ExportRevisionsToS3RequestDetails: AWSEncodableShape {
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration for the export job.
        public let encryption: ExportServerSideEncryption?
        /// The destination for the revision.
        public let revisionDestinations: [RevisionDestinationEntry]

        @inlinable
        public init(dataSetId: String, encryption: ExportServerSideEncryption? = nil, revisionDestinations: [RevisionDestinationEntry]) {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionDestinations = revisionDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case revisionDestinations = "RevisionDestinations"
        }
    }

    public struct ExportRevisionsToS3ResponseDetails: AWSDecodableShape {
        /// The unique identifier for the data set associated with this export job.
        public let dataSetId: String
        /// Encryption configuration of the export job.
        public let encryption: ExportServerSideEncryption?
        /// The Amazon Resource Name (ARN) of the event action.
        public let eventActionArn: String?
        /// The destination in Amazon S3 where the revision is exported.
        public let revisionDestinations: [RevisionDestinationEntry]

        @inlinable
        public init(dataSetId: String, encryption: ExportServerSideEncryption? = nil, eventActionArn: String? = nil, revisionDestinations: [RevisionDestinationEntry]) {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.eventActionArn = eventActionArn
            self.revisionDestinations = revisionDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case encryption = "Encryption"
            case eventActionArn = "EventActionArn"
            case revisionDestinations = "RevisionDestinations"
        }
    }

    public struct ExportServerSideEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AWS KMS key you want to use to encrypt the Amazon S3 objects. This parameter is required if you choose aws:kms as an encryption type.
        public let kmsKeyArn: String?
        /// The type of server side encryption used for encrypting the objects in Amazon S3.
        public let type: ServerSideEncryptionTypes

        @inlinable
        public init(kmsKeyArn: String? = nil, type: ServerSideEncryptionTypes) {
            self.kmsKeyArn = kmsKeyArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case type = "Type"
        }
    }

    public struct GetAssetRequest: AWSEncodableShape {
        /// The unique identifier for an asset.
        public let assetId: String
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(assetId: String, dataSetId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "AssetId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetResponse: AWSDecodableShape {
        /// The ARN for the asset.
        public let arn: String?
        /// Details about the asset.
        public let assetDetails: AssetDetails?
        /// The type of asset that is added to a data set.
        public let assetType: AssetType?
        /// The date and time that the asset was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The unique identifier for the data set associated with this asset.
        public let dataSetId: String?
        /// The unique identifier for the asset.
        public let id: String?
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in the LF-tag policy" or "Table(s) included in the LF-tag policy" are used as the asset name.
        public let name: String?
        /// The unique identifier for the revision associated with this asset.
        public let revisionId: String?
        /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
        public let sourceId: String?
        /// The date and time that the asset was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, assetDetails: AssetDetails? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, dataSetId: String? = nil, id: String? = nil, name: String? = nil, revisionId: String? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetDetails = "AssetDetails"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case id = "Id"
            case name = "Name"
            case revisionId = "RevisionId"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetDataGrantRequest: AWSEncodableShape {
        /// The ID of the data grant.
        public let dataGrantId: String

        @inlinable
        public init(dataGrantId: String) {
            self.dataGrantId = dataGrantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataGrantId, key: "DataGrantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataGrantId, name: "dataGrantId", parent: name, pattern: "^[a-zA-Z0-9]{30,40}$|^arn:aws:dataexchange:[\\-a-z0-9]*:(\\d{12}):data-grants\\/[a-zA-Z0-9]{30,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataGrantResponse: AWSDecodableShape {
        /// The acceptance state of the data grant.
        public let acceptanceState: DataGrantAcceptanceState
        /// The timestamp of when the data grant was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The Amazon Resource Name (ARN) of the data grant.
        public let arn: String
        /// The timestamp of when the data grant was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the data set associated to the data grant.
        public let dataSetId: String
        /// The description of the data grant.
        public let description: String?
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The distribution scope for the data grant.
        public let grantDistributionScope: GrantDistributionScope
        /// The ID of the data grant.
        public let id: String
        /// The name of the data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The Amazon Web Services account ID of the data grant sender.
        public let senderPrincipal: String
        /// The ID of the data set used to create the data grant.
        public let sourceDataSetId: String
        /// The tags associated to the data grant. A tag is a key-value pair.
        public let tags: [String: String]?
        /// The timestamp of when the data grant was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(acceptanceState: DataGrantAcceptanceState, acceptedAt: Date? = nil, arn: String, createdAt: Date, dataSetId: String, description: String? = nil, endsAt: Date? = nil, grantDistributionScope: GrantDistributionScope, id: String, name: String, receiverPrincipal: String, senderPrincipal: String, sourceDataSetId: String, tags: [String: String]? = nil, updatedAt: Date) {
            self.acceptanceState = acceptanceState
            self.acceptedAt = acceptedAt
            self.arn = arn
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.description = description
            self.endsAt = endsAt
            self.grantDistributionScope = grantDistributionScope
            self.id = id
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.senderPrincipal = senderPrincipal
            self.sourceDataSetId = sourceDataSetId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceState = "AcceptanceState"
            case acceptedAt = "AcceptedAt"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case description = "Description"
            case endsAt = "EndsAt"
            case grantDistributionScope = "GrantDistributionScope"
            case id = "Id"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case senderPrincipal = "SenderPrincipal"
            case sourceDataSetId = "SourceDataSetId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetDataSetRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String

        @inlinable
        public init(dataSetId: String) {
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSetResponse: AWSDecodableShape {
        /// The ARN for the data set.
        public let arn: String?
        /// The type of asset that is added to a data set.
        public let assetType: AssetType?
        /// The date and time that the data set was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description for the data set.
        public let description: String?
        /// The unique identifier for the data set.
        public let id: String?
        /// The name of the data set.
        public let name: String?
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        public let origin: Origin?
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public let originDetails: OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public let sourceId: String?
        /// The tags for the data set.
        public let tags: [String: String]?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, origin: Origin? = nil, originDetails: OriginDetails? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetEventActionRequest: AWSEncodableShape {
        /// The unique identifier for the event action.
        public let eventActionId: String

        @inlinable
        public init(eventActionId: String) {
            self.eventActionId = eventActionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventActionId, key: "EventActionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventActionResponse: AWSDecodableShape {
        /// What occurs after a certain event.
        public let action: Action?
        /// The ARN for the event action.
        public let arn: String?
        /// The date and time that the event action was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// What occurs to start an action.
        public let event: Event?
        /// The unique identifier for the event action.
        public let id: String?
        /// The date and time that the event action was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(action: Action? = nil, arn: String? = nil, createdAt: Date? = nil, event: Event? = nil, id: String? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.event = event
            self.id = id
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case event = "Event"
            case id = "Id"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// The unique identifier for a job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobResponse: AWSDecodableShape {
        /// The ARN for the job.
        public let arn: String?
        /// The date and time that the job was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// Details about the job.
        public let details: ResponseDetails?
        /// The errors associated with jobs.
        public let errors: [JobError]?
        /// The unique identifier for the job.
        public let id: String?
        /// The state of the job.
        public let state: State?
        /// The job type.
        public let type: `Type`?
        /// The date and time that the job was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, details: ResponseDetails? = nil, errors: [JobError]? = nil, id: String? = nil, state: State? = nil, type: `Type`? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case details = "Details"
            case errors = "Errors"
            case id = "Id"
            case state = "State"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetReceivedDataGrantRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the data grant.
        public let dataGrantArn: String

        @inlinable
        public init(dataGrantArn: String) {
            self.dataGrantArn = dataGrantArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataGrantArn, key: "DataGrantArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataGrantArn, name: "dataGrantArn", parent: name, pattern: "^arn:aws:dataexchange:[\\-a-z0-9]*:(\\d{12}):data-grants\\/[a-zA-Z0-9]{30,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReceivedDataGrantResponse: AWSDecodableShape {
        /// The acceptance state of the data grant.
        public let acceptanceState: DataGrantAcceptanceState
        /// The timestamp of when the data grant was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The Amazon Resource Name (ARN) of the data grant.
        public let arn: String
        /// The timestamp of when the data grant was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the data set associated to the data grant.
        public let dataSetId: String
        /// The description of the data grant.
        public let description: String?
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The distribution scope for the data grant.
        public let grantDistributionScope: GrantDistributionScope
        /// The ID of the data grant.
        public let id: String
        /// The name of the data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The Amazon Web Services account ID of the data grant sender.
        public let senderPrincipal: String?
        /// The timestamp of when the data grant was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(acceptanceState: DataGrantAcceptanceState, acceptedAt: Date? = nil, arn: String, createdAt: Date, dataSetId: String, description: String? = nil, endsAt: Date? = nil, grantDistributionScope: GrantDistributionScope, id: String, name: String, receiverPrincipal: String, senderPrincipal: String? = nil, updatedAt: Date) {
            self.acceptanceState = acceptanceState
            self.acceptedAt = acceptedAt
            self.arn = arn
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.description = description
            self.endsAt = endsAt
            self.grantDistributionScope = grantDistributionScope
            self.id = id
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.senderPrincipal = senderPrincipal
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceState = "AcceptanceState"
            case acceptedAt = "AcceptedAt"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case description = "Description"
            case endsAt = "EndsAt"
            case grantDistributionScope = "GrantDistributionScope"
            case id = "Id"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case senderPrincipal = "SenderPrincipal"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetRevisionRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(dataSetId: String, revisionId: String) {
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRevisionResponse: AWSDecodableShape {
        /// The ARN for the revision.
        public let arn: String?
        /// An optional comment about the revision.
        public let comment: String?
        /// The date and time that the revision was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The unique identifier for the data set associated with the data set revision.
        public let dataSetId: String?
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public let finalized: Bool?
        /// The unique identifier for the revision.
        public let id: String?
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public let revocationComment: String?
        /// A status indicating that subscribers' access to the revision was revoked.
        public let revoked: Bool?
        /// The date and time that the revision was revoked, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var revokedAt: Date?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public let sourceId: String?
        /// The tags for the revision.
        public let tags: [String: String]?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, revocationComment: String? = nil, revoked: Bool? = nil, revokedAt: Date? = nil, sourceId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.revocationComment = revocationComment
            self.revoked = revoked
            self.revokedAt = revokedAt
            self.sourceId = sourceId
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case revocationComment = "RevocationComment"
            case revoked = "Revoked"
            case revokedAt = "RevokedAt"
            case sourceId = "SourceId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ImportAssetFromApiGatewayApiRequestDetails: AWSEncodableShape {
        /// The API description. Markdown supported.
        public let apiDescription: String?
        /// The API Gateway API ID.
        public let apiId: String
        /// The API Gateway API key.
        public let apiKey: String?
        /// The API name.
        public let apiName: String
        /// The Base64-encoded MD5 hash of the OpenAPI 3.0 JSON API specification file. It is used to ensure the integrity of the file.
        public let apiSpecificationMd5Hash: String
        /// The data set ID.
        public let dataSetId: String
        /// The protocol type.
        public let protocolType: ProtocolType
        /// The revision ID.
        public let revisionId: String
        /// The API stage.
        public let stage: String

        @inlinable
        public init(apiDescription: String? = nil, apiId: String, apiKey: String? = nil, apiName: String, apiSpecificationMd5Hash: String, dataSetId: String, protocolType: ProtocolType, revisionId: String, stage: String) {
            self.apiDescription = apiDescription
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationMd5Hash = apiSpecificationMd5Hash
            self.dataSetId = dataSetId
            self.protocolType = protocolType
            self.revisionId = revisionId
            self.stage = stage
        }

        public func validate(name: String) throws {
            try self.validate(self.apiSpecificationMd5Hash, name: "apiSpecificationMd5Hash", parent: name, max: 24)
            try self.validate(self.apiSpecificationMd5Hash, name: "apiSpecificationMd5Hash", parent: name, min: 24)
            try self.validate(self.apiSpecificationMd5Hash, name: "apiSpecificationMd5Hash", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiDescription = "ApiDescription"
            case apiId = "ApiId"
            case apiKey = "ApiKey"
            case apiName = "ApiName"
            case apiSpecificationMd5Hash = "ApiSpecificationMd5Hash"
            case dataSetId = "DataSetId"
            case protocolType = "ProtocolType"
            case revisionId = "RevisionId"
            case stage = "Stage"
        }
    }

    public struct ImportAssetFromApiGatewayApiResponseDetails: AWSDecodableShape {
        /// The API description.
        public let apiDescription: String?
        /// The API ID.
        public let apiId: String
        /// The API key.
        public let apiKey: String?
        /// The API name.
        public let apiName: String
        /// The Base64-encoded Md5 hash for the API asset, used to ensure the integrity of the API at that location.
        public let apiSpecificationMd5Hash: String
        /// The upload URL of the API specification.
        public let apiSpecificationUploadUrl: String
        /// The date and time that the upload URL expires, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var apiSpecificationUploadUrlExpiresAt: Date
        /// The data set ID.
        public let dataSetId: String
        /// The protocol type.
        public let protocolType: ProtocolType
        /// The revision ID.
        public let revisionId: String
        /// The API stage.
        public let stage: String

        @inlinable
        public init(apiDescription: String? = nil, apiId: String, apiKey: String? = nil, apiName: String, apiSpecificationMd5Hash: String, apiSpecificationUploadUrl: String, apiSpecificationUploadUrlExpiresAt: Date, dataSetId: String, protocolType: ProtocolType, revisionId: String, stage: String) {
            self.apiDescription = apiDescription
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationMd5Hash = apiSpecificationMd5Hash
            self.apiSpecificationUploadUrl = apiSpecificationUploadUrl
            self.apiSpecificationUploadUrlExpiresAt = apiSpecificationUploadUrlExpiresAt
            self.dataSetId = dataSetId
            self.protocolType = protocolType
            self.revisionId = revisionId
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiDescription = "ApiDescription"
            case apiId = "ApiId"
            case apiKey = "ApiKey"
            case apiName = "ApiName"
            case apiSpecificationMd5Hash = "ApiSpecificationMd5Hash"
            case apiSpecificationUploadUrl = "ApiSpecificationUploadUrl"
            case apiSpecificationUploadUrlExpiresAt = "ApiSpecificationUploadUrlExpiresAt"
            case dataSetId = "DataSetId"
            case protocolType = "ProtocolType"
            case revisionId = "RevisionId"
            case stage = "Stage"
        }
    }

    public struct ImportAssetFromSignedUrlJobErrorDetails: AWSDecodableShape {
        /// Details about the job error.
        public let assetName: String

        @inlinable
        public init(assetName: String) {
            self.assetName = assetName
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
        }
    }

    public struct ImportAssetFromSignedUrlRequestDetails: AWSEncodableShape {
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name.
        public let assetName: String
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        public let md5Hash: String
        /// The unique identifier for the revision associated with this import request.
        public let revisionId: String

        @inlinable
        public init(assetName: String, dataSetId: String, md5Hash: String, revisionId: String) {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.md5Hash, name: "md5Hash", parent: name, max: 24)
            try self.validate(self.md5Hash, name: "md5Hash", parent: name, min: 24)
            try self.validate(self.md5Hash, name: "md5Hash", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
            case dataSetId = "DataSetId"
            case md5Hash = "Md5Hash"
            case revisionId = "RevisionId"
        }
    }

    public struct ImportAssetFromSignedUrlResponseDetails: AWSDecodableShape {
        /// The name for the asset associated with this import job.
        public let assetName: String
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        public let md5Hash: String?
        /// The unique identifier for the revision associated with this import response.
        public let revisionId: String
        /// The signed URL.
        public let signedUrl: String?
        /// The time and date at which the signed URL expires, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var signedUrlExpiresAt: Date?

        @inlinable
        public init(assetName: String, dataSetId: String, md5Hash: String? = nil, revisionId: String, signedUrl: String? = nil, signedUrlExpiresAt: Date? = nil) {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
            case dataSetId = "DataSetId"
            case md5Hash = "Md5Hash"
            case revisionId = "RevisionId"
            case signedUrl = "SignedUrl"
            case signedUrlExpiresAt = "SignedUrlExpiresAt"
        }
    }

    public struct ImportAssetsFromLakeFormationTagPolicyRequestDetails: AWSEncodableShape {
        /// The identifier for the AWS Glue Data Catalog.
        public let catalogId: String
        /// A structure for the database object.
        public let database: DatabaseLFTagPolicyAndPermissions?
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import job.
        public let revisionId: String
        /// The IAM role's ARN that allows AWS Data Exchange to assume the role and grant and revoke permissions of subscribers to AWS Lake Formation data permissions.
        public let roleArn: String
        /// A structure for the table object.
        public let table: TableLFTagPolicyAndPermissions?

        @inlinable
        public init(catalogId: String, database: DatabaseLFTagPolicyAndPermissions? = nil, dataSetId: String, revisionId: String, roleArn: String, table: TableLFTagPolicyAndPermissions? = nil) {
            self.catalogId = catalogId
            self.database = database
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.roleArn = roleArn
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 12)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 12)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "/^[\\d]{12}$/")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::(\\d{12}):role\\/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case database = "Database"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
            case roleArn = "RoleArn"
            case table = "Table"
        }
    }

    public struct ImportAssetsFromLakeFormationTagPolicyResponseDetails: AWSDecodableShape {
        /// The identifier for the AWS Glue Data Catalog.
        public let catalogId: String
        /// A structure for the database object.
        public let database: DatabaseLFTagPolicyAndPermissions?
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import job.
        public let revisionId: String
        /// The IAM role's ARN that allows AWS Data Exchange to assume the role and grant and revoke permissions to AWS Lake Formation data permissions.
        public let roleArn: String
        /// A structure for the table object.
        public let table: TableLFTagPolicyAndPermissions?

        @inlinable
        public init(catalogId: String, database: DatabaseLFTagPolicyAndPermissions? = nil, dataSetId: String, revisionId: String, roleArn: String, table: TableLFTagPolicyAndPermissions? = nil) {
            self.catalogId = catalogId
            self.database = database
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.roleArn = roleArn
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case database = "Database"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
            case roleArn = "RoleArn"
            case table = "Table"
        }
    }

    public struct ImportAssetsFromRedshiftDataSharesRequestDetails: AWSEncodableShape {
        /// A list of Amazon Redshift datashare assets.
        public let assetSources: [RedshiftDataShareAssetSourceEntry]
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import job.
        public let revisionId: String

        @inlinable
        public init(assetSources: [RedshiftDataShareAssetSourceEntry], dataSetId: String, revisionId: String) {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSources = "AssetSources"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct ImportAssetsFromRedshiftDataSharesResponseDetails: AWSDecodableShape {
        /// A list of Amazon Redshift datashare asset sources.
        public let assetSources: [RedshiftDataShareAssetSourceEntry]
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import job.
        public let revisionId: String

        @inlinable
        public init(assetSources: [RedshiftDataShareAssetSourceEntry], dataSetId: String, revisionId: String) {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSources = "AssetSources"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct ImportAssetsFromS3RequestDetails: AWSEncodableShape {
        /// Is a list of Amazon S3 bucket and object key pairs.
        public let assetSources: [AssetSourceEntry]
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import request.
        public let revisionId: String

        @inlinable
        public init(assetSources: [AssetSourceEntry], dataSetId: String, revisionId: String) {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSources = "AssetSources"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct ImportAssetsFromS3ResponseDetails: AWSDecodableShape {
        /// Is a list of Amazon S3 bucket and object key pairs.
        public let assetSources: [AssetSourceEntry]
        /// The unique identifier for the data set associated with this import job.
        public let dataSetId: String
        /// The unique identifier for the revision associated with this import response.
        public let revisionId: String

        @inlinable
        public init(assetSources: [AssetSourceEntry], dataSetId: String, revisionId: String) {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetSources = "AssetSources"
            case dataSetId = "DataSetId"
            case revisionId = "RevisionId"
        }
    }

    public struct JobEntry: AWSDecodableShape {
        /// The ARN for the job.
        public let arn: String
        /// The date and time that the job was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Details of the operation to be performed by the job, such as export destination details or import source details.
        public let details: ResponseDetails
        /// Errors for jobs.
        public let errors: [JobError]?
        /// The unique identifier for the job.
        public let id: String
        /// The state of the job.
        public let state: State
        /// The job type.
        public let type: `Type`
        /// The date and time that the job was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, details: ResponseDetails, errors: [JobError]? = nil, id: String, state: State, type: `Type`, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case details = "Details"
            case errors = "Errors"
            case id = "Id"
            case state = "State"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct JobError: AWSDecodableShape {
        /// The code for the job error.
        public let code: Code
        /// The details about the job error.
        public let details: Details?
        /// The name of the limit that was reached.
        public let limitName: JobErrorLimitName?
        /// The value of the exceeded limit.
        public let limitValue: Double?
        /// The message related to the job error.
        public let message: String
        /// The unique identifier for the resource related to the error.
        public let resourceId: String?
        /// The type of resource related to the error.
        public let resourceType: JobErrorResourceTypes?

        @inlinable
        public init(code: Code, details: Details? = nil, limitName: JobErrorLimitName? = nil, limitValue: Double? = nil, message: String, resourceId: String? = nil, resourceType: JobErrorResourceTypes? = nil) {
            self.code = code
            self.details = details
            self.limitName = limitName
            self.limitValue = limitValue
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case details = "Details"
            case limitName = "LimitName"
            case limitValue = "LimitValue"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct KmsKeyToGrant: AWSEncodableShape & AWSDecodableShape {
        /// The AWS KMS CMK (Key Management System Customer Managed Key) used to encrypt S3 objects in the shared S3 Bucket. AWS Data exchange will create a KMS grant for each subscriber to allow them to access and decrypt their entitled data that is encrypted using this KMS key specified.
        public let kmsKeyArn: String

        @inlinable
        public init(kmsKeyArn: String) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct LFResourceDetails: AWSDecodableShape {
        /// Details about the database resource included in the AWS Lake Formation data permission.
        public let database: DatabaseLFTagPolicy?
        /// Details about the table resource included in the AWS Lake Formation data permission.
        public let table: TableLFTagPolicy?

        @inlinable
        public init(database: DatabaseLFTagPolicy? = nil, table: TableLFTagPolicy? = nil) {
            self.database = database
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case table = "Table"
        }
    }

    public struct LFTag: AWSEncodableShape & AWSDecodableShape {
        /// The key name for the LF-tag.
        public let tagKey: String
        /// A list of LF-tag values.
        public let tagValues: [String]

        @inlinable
        public init(tagKey: String, tagValues: [String]) {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "TagKey"
            case tagValues = "TagValues"
        }
    }

    public struct LFTagPolicyDetails: AWSDecodableShape {
        /// The identifier for the AWS Glue Data Catalog.
        public let catalogId: String
        /// Details for the Lake Formation Resources included in the LF-tag policy.
        public let resourceDetails: LFResourceDetails
        /// The resource type for which the LF-tag policy applies.
        public let resourceType: LFResourceType

        @inlinable
        public init(catalogId: String, resourceDetails: LFResourceDetails, resourceType: LFResourceType) {
            self.catalogId = catalogId
            self.resourceDetails = resourceDetails
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case resourceDetails = "ResourceDetails"
            case resourceType = "ResourceType"
        }
    }

    public struct LakeFormationDataPermissionAsset: AWSDecodableShape {
        /// Details about the AWS Lake Formation data permission.
        public let lakeFormationDataPermissionDetails: LakeFormationDataPermissionDetails
        /// The data permission type.
        public let lakeFormationDataPermissionType: LakeFormationDataPermissionType
        /// The permissions granted to the subscribers on the resource.
        public let permissions: [LFPermission]
        /// The IAM role's ARN that allows AWS Data Exchange to assume the role and grant and revoke permissions to AWS Lake Formation data permissions.
        public let roleArn: String?

        @inlinable
        public init(lakeFormationDataPermissionDetails: LakeFormationDataPermissionDetails, lakeFormationDataPermissionType: LakeFormationDataPermissionType, permissions: [LFPermission], roleArn: String? = nil) {
            self.lakeFormationDataPermissionDetails = lakeFormationDataPermissionDetails
            self.lakeFormationDataPermissionType = lakeFormationDataPermissionType
            self.permissions = permissions
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case lakeFormationDataPermissionDetails = "LakeFormationDataPermissionDetails"
            case lakeFormationDataPermissionType = "LakeFormationDataPermissionType"
            case permissions = "Permissions"
            case roleArn = "RoleArn"
        }
    }

    public struct LakeFormationDataPermissionDetails: AWSDecodableShape {
        /// Details about the LF-tag policy.
        public let lfTagPolicy: LFTagPolicyDetails?

        @inlinable
        public init(lfTagPolicy: LFTagPolicyDetails? = nil) {
            self.lfTagPolicy = lfTagPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case lfTagPolicy = "LFTagPolicy"
        }
    }

    public struct LakeFormationTagPolicyDetails: AWSEncodableShape {
        /// The underlying Glue database that the notification is referring to.
        public let database: String?
        /// The underlying Glue table that the notification is referring to.
        public let table: String?

        @inlinable
        public init(database: String? = nil, table: String? = nil) {
            self.database = database
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case table = "Table"
        }
    }

    public struct ListDataGrantsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataGrantsResponse: AWSDecodableShape {
        /// An object that contains a list of data grant information.
        public let dataGrantSummaries: [DataGrantSummaryEntry]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(dataGrantSummaries: [DataGrantSummaryEntry]? = nil, nextToken: String? = nil) {
            self.dataGrantSummaries = dataGrantSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataGrantSummaries = "DataGrantSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataSetRevisionsRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The maximum number of results returned by a single call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetRevisionsResponse: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The asset objects listed by the request.
        public let revisions: [RevisionEntry]?

        @inlinable
        public init(nextToken: String? = nil, revisions: [RevisionEntry]? = nil) {
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case revisions = "Revisions"
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        /// The maximum number of results returned by a single call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        public let origin: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, origin: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        /// The data set objects listed by the request.
        public let dataSets: [DataSetEntry]?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(dataSets: [DataSetEntry]? = nil, nextToken: String? = nil) {
            self.dataSets = dataSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets = "DataSets"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventActionsRequest: AWSEncodableShape {
        /// The unique identifier for the event source.
        public let eventSourceId: String?
        /// The maximum number of results returned by a single call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(eventSourceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.eventSourceId = eventSourceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.eventSourceId, key: "eventSourceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventActionsResponse: AWSDecodableShape {
        /// The event action objects listed by the request.
        public let eventActions: [EventActionEntry]?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(eventActions: [EventActionEntry]? = nil, nextToken: String? = nil) {
            self.eventActions = eventActions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventActions = "EventActions"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String?
        /// The maximum number of results returned by a single call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The unique identifier for a revision.
        public let revisionId: String?

        @inlinable
        public init(dataSetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, revisionId: String? = nil) {
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.dataSetId, key: "dataSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.revisionId, key: "revisionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResponse: AWSDecodableShape {
        /// The jobs listed by the request.
        public let jobs: [JobEntry]?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(jobs: [JobEntry]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListReceivedDataGrantsRequest: AWSEncodableShape {
        /// The acceptance state of the data grants to list.
        public let acceptanceState: [AcceptanceStateFilterValue]?
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(acceptanceState: [AcceptanceStateFilterValue]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.acceptanceState = acceptanceState
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.acceptanceState, key: "acceptanceState")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReceivedDataGrantsResponse: AWSDecodableShape {
        /// An object that contains a list of received data grant information.
        public let dataGrantSummaries: [ReceivedDataGrantSummariesEntry]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(dataGrantSummaries: [ReceivedDataGrantSummariesEntry]? = nil, nextToken: String? = nil) {
            self.dataGrantSummaries = dataGrantSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataGrantSummaries = "DataGrantSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListRevisionAssetsRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The maximum number of results returned by a single call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil, revisionId: String) {
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRevisionAssetsResponse: AWSDecodableShape {
        /// The asset objects listed by the request.
        public let assets: [AssetEntry]?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(assets: [AssetEntry]? = nil, nextToken: String? = nil) {
            self.assets = assets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A label that consists of a customer-defined key and an optional value.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NotificationDetails: AWSEncodableShape {
        /// Extra details specific to a data update type notification.
        public let dataUpdate: DataUpdateRequestDetails?
        /// Extra details specific to a deprecation type notification.
        public let deprecation: DeprecationRequestDetails?
        /// Extra details specific to a schema change type notification.
        public let schemaChange: SchemaChangeRequestDetails?

        @inlinable
        public init(dataUpdate: DataUpdateRequestDetails? = nil, deprecation: DeprecationRequestDetails? = nil, schemaChange: SchemaChangeRequestDetails? = nil) {
            self.dataUpdate = dataUpdate
            self.deprecation = deprecation
            self.schemaChange = schemaChange
        }

        private enum CodingKeys: String, CodingKey {
            case dataUpdate = "DataUpdate"
            case deprecation = "Deprecation"
            case schemaChange = "SchemaChange"
        }
    }

    public struct OriginDetails: AWSDecodableShape {
        /// The ID of the data grant.
        public let dataGrantId: String?
        /// The product ID of the origin of the data set.
        public let productId: String?

        @inlinable
        public init(dataGrantId: String? = nil, productId: String? = nil) {
            self.dataGrantId = dataGrantId
            self.productId = productId
        }

        private enum CodingKeys: String, CodingKey {
            case dataGrantId = "DataGrantId"
            case productId = "ProductId"
        }
    }

    public struct ReceivedDataGrantSummariesEntry: AWSDecodableShape {
        /// The acceptance state of the data grant.
        public let acceptanceState: DataGrantAcceptanceState
        /// The timestamp of when the data grant was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The Amazon Resource Name (ARN) of the data grant.
        public let arn: String
        /// The timestamp of when the data grant was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the data set associated to the data grant.
        public let dataSetId: String
        /// The timestamp of when access to the associated data set ends.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endsAt: Date?
        /// The ID of the data grant.
        public let id: String
        /// The name of the data grant.
        public let name: String
        /// The Amazon Web Services account ID of the data grant receiver.
        public let receiverPrincipal: String
        /// The Amazon Web Services account ID of the data grant sender.
        public let senderPrincipal: String
        /// The timestamp of when the data grant was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(acceptanceState: DataGrantAcceptanceState, acceptedAt: Date? = nil, arn: String, createdAt: Date, dataSetId: String, endsAt: Date? = nil, id: String, name: String, receiverPrincipal: String, senderPrincipal: String, updatedAt: Date) {
            self.acceptanceState = acceptanceState
            self.acceptedAt = acceptedAt
            self.arn = arn
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.endsAt = endsAt
            self.id = id
            self.name = name
            self.receiverPrincipal = receiverPrincipal
            self.senderPrincipal = senderPrincipal
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceState = "AcceptanceState"
            case acceptedAt = "AcceptedAt"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case endsAt = "EndsAt"
            case id = "Id"
            case name = "Name"
            case receiverPrincipal = "ReceiverPrincipal"
            case senderPrincipal = "SenderPrincipal"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct RedshiftDataShareAsset: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the datashare asset.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct RedshiftDataShareAssetSourceEntry: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the datashare asset.
        public let dataShareArn: String

        @inlinable
        public init(dataShareArn: String) {
            self.dataShareArn = dataShareArn
        }

        private enum CodingKeys: String, CodingKey {
            case dataShareArn = "DataShareArn"
        }
    }

    public struct RedshiftDataShareDetails: AWSEncodableShape {
        /// The ARN of the underlying Redshift data share that is being affected by this notification.
        public let arn: String
        /// The database name in the Redshift data share that is being affected by this notification.
        public let database: String
        /// A function name in the Redshift database that is being affected by this notification.
        public let function: String?
        /// A schema name in the Redshift database that is being affected by this notification.
        public let schema: String?
        /// A table name in the Redshift database that is being affected by this notification.
        public let table: String?
        /// A view name in the Redshift database that is being affected by this notification.
        public let view: String?

        @inlinable
        public init(arn: String, database: String, function: String? = nil, schema: String? = nil, table: String? = nil, view: String? = nil) {
            self.arn = arn
            self.database = database
            self.function = function
            self.schema = schema
            self.table = table
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case database = "Database"
            case function = "Function"
            case schema = "Schema"
            case table = "Table"
            case view = "View"
        }
    }

    public struct RequestDetails: AWSEncodableShape {
        /// Details of the request to create S3 data access from the Amazon S3 bucket.
        public let createS3DataAccessFromS3Bucket: CreateS3DataAccessFromS3BucketRequestDetails?
        /// Details about the export to Amazon S3 request.
        public let exportAssetsToS3: ExportAssetsToS3RequestDetails?
        /// Details about the export to signed URL request.
        public let exportAssetToSignedUrl: ExportAssetToSignedUrlRequestDetails?
        /// Details about the export to Amazon S3 request.
        public let exportRevisionsToS3: ExportRevisionsToS3RequestDetails?
        /// Details about the import from signed URL request.
        public let importAssetFromApiGatewayApi: ImportAssetFromApiGatewayApiRequestDetails?
        /// Details about the import from Amazon S3 request.
        public let importAssetFromSignedUrl: ImportAssetFromSignedUrlRequestDetails?
        /// Request details for the ImportAssetsFromLakeFormationTagPolicy job.
        public let importAssetsFromLakeFormationTagPolicy: ImportAssetsFromLakeFormationTagPolicyRequestDetails?
        /// Details from an import from Amazon Redshift datashare request.
        public let importAssetsFromRedshiftDataShares: ImportAssetsFromRedshiftDataSharesRequestDetails?
        /// Details about the import asset from API Gateway API request.
        public let importAssetsFromS3: ImportAssetsFromS3RequestDetails?

        @inlinable
        public init(createS3DataAccessFromS3Bucket: CreateS3DataAccessFromS3BucketRequestDetails? = nil, exportAssetsToS3: ExportAssetsToS3RequestDetails? = nil, exportAssetToSignedUrl: ExportAssetToSignedUrlRequestDetails? = nil, exportRevisionsToS3: ExportRevisionsToS3RequestDetails? = nil, importAssetFromApiGatewayApi: ImportAssetFromApiGatewayApiRequestDetails? = nil, importAssetFromSignedUrl: ImportAssetFromSignedUrlRequestDetails? = nil, importAssetsFromLakeFormationTagPolicy: ImportAssetsFromLakeFormationTagPolicyRequestDetails? = nil, importAssetsFromRedshiftDataShares: ImportAssetsFromRedshiftDataSharesRequestDetails? = nil, importAssetsFromS3: ImportAssetsFromS3RequestDetails? = nil) {
            self.createS3DataAccessFromS3Bucket = createS3DataAccessFromS3Bucket
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromApiGatewayApi = importAssetFromApiGatewayApi
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromLakeFormationTagPolicy = importAssetsFromLakeFormationTagPolicy
            self.importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares
            self.importAssetsFromS3 = importAssetsFromS3
        }

        public func validate(name: String) throws {
            try self.createS3DataAccessFromS3Bucket?.validate(name: "\(name).createS3DataAccessFromS3Bucket")
            try self.importAssetFromApiGatewayApi?.validate(name: "\(name).importAssetFromApiGatewayApi")
            try self.importAssetFromSignedUrl?.validate(name: "\(name).importAssetFromSignedUrl")
            try self.importAssetsFromLakeFormationTagPolicy?.validate(name: "\(name).importAssetsFromLakeFormationTagPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case createS3DataAccessFromS3Bucket = "CreateS3DataAccessFromS3Bucket"
            case exportAssetsToS3 = "ExportAssetsToS3"
            case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
            case exportRevisionsToS3 = "ExportRevisionsToS3"
            case importAssetFromApiGatewayApi = "ImportAssetFromApiGatewayApi"
            case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
            case importAssetsFromLakeFormationTagPolicy = "ImportAssetsFromLakeFormationTagPolicy"
            case importAssetsFromRedshiftDataShares = "ImportAssetsFromRedshiftDataShares"
            case importAssetsFromS3 = "ImportAssetsFromS3"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// The resource couldn't be found.
        public let message: String
        /// The unique identifier for the resource that couldn't be found.
        public let resourceId: String?
        /// The type of resource that couldn't be found.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ResponseDetails: AWSDecodableShape {
        /// Response details from the CreateS3DataAccessFromS3Bucket job.
        public let createS3DataAccessFromS3Bucket: CreateS3DataAccessFromS3BucketResponseDetails?
        /// Details for the export to Amazon S3 response.
        public let exportAssetsToS3: ExportAssetsToS3ResponseDetails?
        /// Details for the export to signed URL response.
        public let exportAssetToSignedUrl: ExportAssetToSignedUrlResponseDetails?
        /// Details for the export revisions to Amazon S3 response.
        public let exportRevisionsToS3: ExportRevisionsToS3ResponseDetails?
        /// The response details.
        public let importAssetFromApiGatewayApi: ImportAssetFromApiGatewayApiResponseDetails?
        /// Details for the import from signed URL response.
        public let importAssetFromSignedUrl: ImportAssetFromSignedUrlResponseDetails?
        /// Response details from the ImportAssetsFromLakeFormationTagPolicy job.
        public let importAssetsFromLakeFormationTagPolicy: ImportAssetsFromLakeFormationTagPolicyResponseDetails?
        /// Details from an import from Amazon Redshift datashare response.
        public let importAssetsFromRedshiftDataShares: ImportAssetsFromRedshiftDataSharesResponseDetails?
        /// Details for the import from Amazon S3 response.
        public let importAssetsFromS3: ImportAssetsFromS3ResponseDetails?

        @inlinable
        public init(createS3DataAccessFromS3Bucket: CreateS3DataAccessFromS3BucketResponseDetails? = nil, exportAssetsToS3: ExportAssetsToS3ResponseDetails? = nil, exportAssetToSignedUrl: ExportAssetToSignedUrlResponseDetails? = nil, exportRevisionsToS3: ExportRevisionsToS3ResponseDetails? = nil, importAssetFromApiGatewayApi: ImportAssetFromApiGatewayApiResponseDetails? = nil, importAssetFromSignedUrl: ImportAssetFromSignedUrlResponseDetails? = nil, importAssetsFromLakeFormationTagPolicy: ImportAssetsFromLakeFormationTagPolicyResponseDetails? = nil, importAssetsFromRedshiftDataShares: ImportAssetsFromRedshiftDataSharesResponseDetails? = nil, importAssetsFromS3: ImportAssetsFromS3ResponseDetails? = nil) {
            self.createS3DataAccessFromS3Bucket = createS3DataAccessFromS3Bucket
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromApiGatewayApi = importAssetFromApiGatewayApi
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromLakeFormationTagPolicy = importAssetsFromLakeFormationTagPolicy
            self.importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares
            self.importAssetsFromS3 = importAssetsFromS3
        }

        private enum CodingKeys: String, CodingKey {
            case createS3DataAccessFromS3Bucket = "CreateS3DataAccessFromS3Bucket"
            case exportAssetsToS3 = "ExportAssetsToS3"
            case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
            case exportRevisionsToS3 = "ExportRevisionsToS3"
            case importAssetFromApiGatewayApi = "ImportAssetFromApiGatewayApi"
            case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
            case importAssetsFromLakeFormationTagPolicy = "ImportAssetsFromLakeFormationTagPolicy"
            case importAssetsFromRedshiftDataShares = "ImportAssetsFromRedshiftDataShares"
            case importAssetsFromS3 = "ImportAssetsFromS3"
        }
    }

    public struct RevisionDestinationEntry: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket that is the destination for the assets in the revision.
        public let bucket: String
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see Key patterns when exporting revisions.
        public let keyPattern: String?
        /// The unique identifier for the revision.
        public let revisionId: String

        @inlinable
        public init(bucket: String, keyPattern: String? = nil, revisionId: String) {
            self.bucket = bucket
            self.keyPattern = keyPattern
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case keyPattern = "KeyPattern"
            case revisionId = "RevisionId"
        }
    }

    public struct RevisionEntry: AWSDecodableShape {
        /// The ARN for the revision.
        public let arn: String
        /// An optional comment about the revision.
        public let comment: String?
        /// The date and time that the revision was created, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier for the data set associated with the data set revision.
        public let dataSetId: String
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public let finalized: Bool?
        /// The unique identifier for the revision.
        public let id: String
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public let revocationComment: String?
        /// A status indicating that subscribers' access to the revision was revoked.
        public let revoked: Bool?
        /// The date and time that the revision was revoked, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var revokedAt: Date?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public let sourceId: String?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, comment: String? = nil, createdAt: Date, dataSetId: String, finalized: Bool? = nil, id: String, revocationComment: String? = nil, revoked: Bool? = nil, revokedAt: Date? = nil, sourceId: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.revocationComment = revocationComment
            self.revoked = revoked
            self.revokedAt = revokedAt
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case revocationComment = "RevocationComment"
            case revoked = "Revoked"
            case revokedAt = "RevokedAt"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct RevisionPublished: AWSEncodableShape & AWSDecodableShape {
        /// The data set ID of the published revision.
        public let dataSetId: String

        @inlinable
        public init(dataSetId: String) {
            self.dataSetId = dataSetId
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
        }
    }

    public struct RevokeRevisionRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The unique identifier for a revision.
        public let revisionId: String
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public let revocationComment: String

        @inlinable
        public init(dataSetId: String, revisionId: String, revocationComment: String) {
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.revocationComment = revocationComment
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.revisionId, key: "RevisionId")
            try container.encode(self.revocationComment, forKey: .revocationComment)
        }

        public func validate(name: String) throws {
            try self.validate(self.revocationComment, name: "revocationComment", parent: name, max: 512)
            try self.validate(self.revocationComment, name: "revocationComment", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case revocationComment = "RevocationComment"
        }
    }

    public struct RevokeRevisionResponse: AWSDecodableShape {
        /// The ARN for the revision.
        public let arn: String?
        /// An optional comment about the revision.
        public let comment: String?
        /// The date and time that the revision was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The unique identifier for the data set associated with the data set revision.
        public let dataSetId: String?
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public let finalized: Bool?
        /// The unique identifier for the revision.
        public let id: String?
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public let revocationComment: String?
        /// A status indicating that subscribers' access to the revision was revoked.
        public let revoked: Bool?
        /// The date and time that the revision was revoked, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var revokedAt: Date?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public let sourceId: String?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, revocationComment: String? = nil, revoked: Bool? = nil, revokedAt: Date? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.revocationComment = revocationComment
            self.revoked = revoked
            self.revokedAt = revokedAt
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case revocationComment = "RevocationComment"
            case revoked = "Revoked"
            case revokedAt = "RevokedAt"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct S3DataAccessAsset: AWSDecodableShape {
        /// The Amazon S3 bucket hosting data to be shared in the S3 data access.
        public let bucket: String
        /// The Amazon S3 bucket used for hosting shared data in the Amazon S3 data access.
        public let keyPrefixes: [String]?
        /// S3 keys made available using this asset.
        public let keys: [String]?
        ///  List of AWS KMS CMKs (Key Management System Customer Managed Keys) and ARNs used to encrypt S3 objects being shared in this S3 Data Access asset. Providers must include all AWS KMS keys used to encrypt these shared S3 objects.
        public let kmsKeysToGrant: [KmsKeyToGrant]?
        /// The automatically-generated bucket-style alias for your Amazon S3 Access Point. Customers can access their entitled data using the S3 Access Point alias.
        public let s3AccessPointAlias: String?
        /// The ARN for your Amazon S3 Access Point. Customers can also access their entitled data using the S3 Access Point ARN.
        public let s3AccessPointArn: String?

        @inlinable
        public init(bucket: String, keyPrefixes: [String]? = nil, keys: [String]? = nil, kmsKeysToGrant: [KmsKeyToGrant]? = nil, s3AccessPointAlias: String? = nil, s3AccessPointArn: String? = nil) {
            self.bucket = bucket
            self.keyPrefixes = keyPrefixes
            self.keys = keys
            self.kmsKeysToGrant = kmsKeysToGrant
            self.s3AccessPointAlias = s3AccessPointAlias
            self.s3AccessPointArn = s3AccessPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case keyPrefixes = "KeyPrefixes"
            case keys = "Keys"
            case kmsKeysToGrant = "KmsKeysToGrant"
            case s3AccessPointAlias = "S3AccessPointAlias"
            case s3AccessPointArn = "S3AccessPointArn"
        }
    }

    public struct S3DataAccessAssetSourceEntry: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket used for hosting shared data in the Amazon S3 data access.
        public let bucket: String
        /// Organizes Amazon S3 asset key prefixes stored in an Amazon S3 bucket.
        public let keyPrefixes: [String]?
        /// The keys used to create the Amazon S3 data access.
        public let keys: [String]?
        /// List of AWS KMS CMKs (Key Management System Customer Managed Keys) and ARNs used to encrypt S3 objects being shared in this S3 Data Access asset.
        public let kmsKeysToGrant: [KmsKeyToGrant]?

        @inlinable
        public init(bucket: String, keyPrefixes: [String]? = nil, keys: [String]? = nil, kmsKeysToGrant: [KmsKeyToGrant]? = nil) {
            self.bucket = bucket
            self.keyPrefixes = keyPrefixes
            self.keys = keys
            self.kmsKeysToGrant = kmsKeysToGrant
        }

        public func validate(name: String) throws {
            try self.kmsKeysToGrant?.forEach {
                try $0.validate(name: "\(name).kmsKeysToGrant[]")
            }
            try self.validate(self.kmsKeysToGrant, name: "kmsKeysToGrant", parent: name, max: 10)
            try self.validate(self.kmsKeysToGrant, name: "kmsKeysToGrant", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case keyPrefixes = "KeyPrefixes"
            case keys = "Keys"
            case kmsKeysToGrant = "KmsKeysToGrant"
        }
    }

    public struct S3DataAccessDetails: AWSEncodableShape {
        /// A list of the key prefixes affected by this notification. This can have up to 50 entries.
        public let keyPrefixes: [String]?
        /// A list of the keys affected by this notification. This can have up to 50 entries.
        public let keys: [String]?

        @inlinable
        public init(keyPrefixes: [String]? = nil, keys: [String]? = nil) {
            self.keyPrefixes = keyPrefixes
            self.keys = keys
        }

        private enum CodingKeys: String, CodingKey {
            case keyPrefixes = "KeyPrefixes"
            case keys = "Keys"
        }
    }

    public struct S3SnapshotAsset: AWSDecodableShape {
        /// The size of the Amazon S3 object that is the object.
        public let size: Double

        @inlinable
        public init(size: Double) {
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
        }
    }

    public struct SchemaChangeDetails: AWSEncodableShape {
        /// Description of what's changing about this field. This value can be up to 512 characters long.
        public let description: String?
        /// Name of the changing field. This value can be up to 255 characters long.
        public let name: String
        /// Is the field being added, removed, or modified?
        public let type: SchemaChangeType

        @inlinable
        public init(description: String? = nil, name: String, type: SchemaChangeType) {
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct SchemaChangeRequestDetails: AWSEncodableShape {
        /// List of schema changes happening in the scope of this notification. This can have up to 100 entries.
        public let changes: [SchemaChangeDetails]?
        /// A date in the future when the schema change is taking effect.
        @CustomCoding<ISO8601DateCoder>
        public var schemaChangeAt: Date

        @inlinable
        public init(changes: [SchemaChangeDetails]? = nil, schemaChangeAt: Date) {
            self.changes = changes
            self.schemaChangeAt = schemaChangeAt
        }

        private enum CodingKeys: String, CodingKey {
            case changes = "Changes"
            case schemaChangeAt = "SchemaChangeAt"
        }
    }

    public struct ScopeDetails: AWSEncodableShape {
        /// Underlying LF resources that will be affected by this notification.
        public let lakeFormationTagPolicies: [LakeFormationTagPolicyDetails]?
        /// Underlying Redshift resources that will be affected by this notification.
        public let redshiftDataShares: [RedshiftDataShareDetails]?
        /// Underlying S3 resources that will be affected by this notification.
        public let s3DataAccesses: [S3DataAccessDetails]?

        @inlinable
        public init(lakeFormationTagPolicies: [LakeFormationTagPolicyDetails]? = nil, redshiftDataShares: [RedshiftDataShareDetails]? = nil, s3DataAccesses: [S3DataAccessDetails]? = nil) {
            self.lakeFormationTagPolicies = lakeFormationTagPolicies
            self.redshiftDataShares = redshiftDataShares
            self.s3DataAccesses = s3DataAccesses
        }

        private enum CodingKeys: String, CodingKey {
            case lakeFormationTagPolicies = "LakeFormationTagPolicies"
            case redshiftDataShares = "RedshiftDataShares"
            case s3DataAccesses = "S3DataAccesses"
        }
    }

    public struct SendApiAssetRequest: AWSEncodableShape {
        /// Asset ID value for the API request.
        public let assetId: String
        /// The request body.
        public let body: String?
        /// Data set ID value for the API request.
        public let dataSetId: String
        /// HTTP method value for the API request. Alternatively, you can use the appropriate verb in your request.
        public let method: String?
        /// URI path value for the API request. Alternatively, you can set the URI path directly by invoking /v1/{pathValue}.
        public let path: String?
        /// Attach query string parameters to the end of the URI (for example, /v1/examplePath?exampleParam=exampleValue).
        public let queryStringParameters: [String: String]?
        /// Any header value prefixed with x-amzn-dataexchange-header- will have that stripped before sending the Asset API request. Use this when you want to override a header that AWS Data Exchange uses. Alternatively, you can use the header without a prefix to the HTTP request.
        public let requestHeaders: [String: String]?
        /// Revision ID value for the API request.
        public let revisionId: String

        @inlinable
        public init(assetId: String, body: String? = nil, dataSetId: String, method: String? = nil, path: String? = nil, queryStringParameters: [String: String]? = nil, requestHeaders: [String: String]? = nil, revisionId: String) {
            self.assetId = assetId
            self.body = body
            self.dataSetId = dataSetId
            self.method = method
            self.path = path
            self.queryStringParameters = queryStringParameters
            self.requestHeaders = requestHeaders
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.assetId, key: "x-amzn-dataexchange-asset-id")
            try container.encode(self.body)
            request.encodeHeader(self.dataSetId, key: "x-amzn-dataexchange-data-set-id")
            request.encodeHeader(self.method, key: "x-amzn-dataexchange-http-method")
            request.encodeHeader(self.path, key: "x-amzn-dataexchange-path")
            request.encodeQuery(self.queryStringParameters)
            request.encodeHeader(self.requestHeaders, key: "x-amzn-dataexchange-header-")
            request.encodeHeader(self.revisionId, key: "x-amzn-dataexchange-revision-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SendApiAssetResponse: AWSDecodableShape {
        /// The response body from the underlying API tracked by the API asset.
        public let body: String
        /// The response headers from the underlying API tracked by the API asset.
        public let responseHeaders: [String: String]?

        @inlinable
        public init(body: String, responseHeaders: [String: String]? = nil) {
            self.body = body
            self.responseHeaders = responseHeaders
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(String.self)
            self.responseHeaders = try response.decodeHeaderIfPresent([String: String].self, key: "")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SendDataSetNotificationRequest: AWSEncodableShape {
        /// Idempotency key for the notification, this key allows us to deduplicate notifications that are sent in quick succession erroneously.
        public let clientToken: String?
        /// Free-form text field for providers to add information about their notifications.
        public let comment: String?
        /// Affected data set of the notification.
        public let dataSetId: String
        /// Extra details specific to this notification type.
        public let details: NotificationDetails?
        /// Affected scope of this notification such as the underlying resources affected by the notification event.
        public let scope: ScopeDetails?
        /// The type of the notification. Describing the kind of event the notification is alerting you to.
        public let type: NotificationType

        @inlinable
        public init(clientToken: String? = SendDataSetNotificationRequest.idempotencyToken(), comment: String? = nil, dataSetId: String, details: NotificationDetails? = nil, scope: ScopeDetails? = nil, type: NotificationType) {
            self.clientToken = clientToken
            self.comment = comment
            self.dataSetId = dataSetId
            self.details = details
            self.scope = scope
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.comment, forKey: .comment)
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encodeIfPresent(self.details, forKey: .details)
            try container.encodeIfPresent(self.scope, forKey: .scope)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]{1,64}$")
            try self.validate(self.comment, name: "comment", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case comment = "Comment"
            case details = "Details"
            case scope = "Scope"
            case type = "Type"
        }
    }

    public struct SendDataSetNotificationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceLimitExceededException: AWSErrorShape {
        /// The name of the limit that was reached.
        public let limitName: LimitName?
        /// The value of the exceeded limit.
        public let limitValue: Double?
        /// The request has exceeded the quotas imposed by the service.
        public let message: String

        @inlinable
        public init(limitName: LimitName? = nil, limitValue: Double? = nil, message: String) {
            self.limitName = limitName
            self.limitValue = limitValue
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case limitName = "LimitName"
            case limitValue = "LimitValue"
            case message = "Message"
        }
    }

    public struct StartJobRequest: AWSEncodableShape {
        /// The unique identifier for a job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TableLFTagPolicy: AWSDecodableShape {
        /// A list of LF-tag conditions that apply to table resources.
        public let expression: [LFTag]

        @inlinable
        public init(expression: [LFTag]) {
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct TableLFTagPolicyAndPermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of LF-tag conditions that apply to table resources.
        public let expression: [LFTag]
        /// The permissions granted to subscribers on table resources.
        public let permissions: [TableTagPolicyLFPermission]

        @inlinable
        public init(expression: [LFTag], permissions: [TableTagPolicyLFPermission]) {
            self.expression = expression
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case permissions = "Permissions"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
        public let resourceArn: String
        /// A label that consists of a customer-defined key and an optional value.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
        public let resourceArn: String
        /// The key tags.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        /// The unique identifier for an asset.
        public let assetId: String
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in the LF-tag policy" or "Table(s) included in LF-tag policy" are used as the name.
        public let name: String
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(assetId: String, dataSetId: String, name: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.name = name
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetId, key: "AssetId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {
        /// The ARN for the asset.
        public let arn: String?
        /// Details about the asset.
        public let assetDetails: AssetDetails?
        /// The type of asset that is added to a data set.
        public let assetType: AssetType?
        /// The date and time that the asset was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The unique identifier for the data set associated with this asset.
        public let dataSetId: String?
        /// The unique identifier for the asset.
        public let id: String?
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in the LF-tag policy"- or "Table(s) included in LF-tag policy" are used as the asset name.
        public let name: String?
        /// The unique identifier for the revision associated with this asset.
        public let revisionId: String?
        /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
        public let sourceId: String?
        /// The date and time that the asset was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, assetDetails: AssetDetails? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, dataSetId: String? = nil, id: String? = nil, name: String? = nil, revisionId: String? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetDetails = "AssetDetails"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case id = "Id"
            case name = "Name"
            case revisionId = "RevisionId"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct UpdateDataSetRequest: AWSEncodableShape {
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// The description for the data set.
        public let description: String?
        /// The name of the data set.
        public let name: String?

        @inlinable
        public init(dataSetId: String, description: String? = nil, name: String? = nil) {
            self.dataSetId = dataSetId
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateDataSetResponse: AWSDecodableShape {
        /// The ARN for the data set.
        public let arn: String?
        /// The type of asset that is added to a data set.
        public let assetType: AssetType?
        /// The date and time that the data set was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description for the data set.
        public let description: String?
        /// The unique identifier for the data set.
        public let id: String?
        /// The name of the data set.
        public let name: String?
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        public let origin: Origin?
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public let originDetails: OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public let sourceId: String?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, assetType: AssetType? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, origin: Origin? = nil, originDetails: OriginDetails? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetType = "AssetType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case origin = "Origin"
            case originDetails = "OriginDetails"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct UpdateEventActionRequest: AWSEncodableShape {
        /// What occurs after a certain event.
        public let action: Action?
        /// The unique identifier for the event action.
        public let eventActionId: String

        @inlinable
        public init(action: Action? = nil, eventActionId: String) {
            self.action = action
            self.eventActionId = eventActionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.action, forKey: .action)
            request.encodePath(self.eventActionId, key: "EventActionId")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
        }
    }

    public struct UpdateEventActionResponse: AWSDecodableShape {
        /// What occurs after a certain event.
        public let action: Action?
        /// The ARN for the event action.
        public let arn: String?
        /// The date and time that the event action was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// What occurs to start an action.
        public let event: Event?
        /// The unique identifier for the event action.
        public let id: String?
        /// The date and time that the event action was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(action: Action? = nil, arn: String? = nil, createdAt: Date? = nil, event: Event? = nil, id: String? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.event = event
            self.id = id
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case event = "Event"
            case id = "Id"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct UpdateRevisionRequest: AWSEncodableShape {
        /// An optional comment about the revision.
        public let comment: String?
        /// The unique identifier for a data set.
        public let dataSetId: String
        /// Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.
        public let finalized: Bool?
        /// The unique identifier for a revision.
        public let revisionId: String

        @inlinable
        public init(comment: String? = nil, dataSetId: String, finalized: Bool? = nil, revisionId: String) {
            self.comment = comment
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.comment, forKey: .comment)
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encodeIfPresent(self.finalized, forKey: .finalized)
            request.encodePath(self.revisionId, key: "RevisionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 16384)
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case finalized = "Finalized"
        }
    }

    public struct UpdateRevisionResponse: AWSDecodableShape {
        /// The ARN for the revision.
        public let arn: String?
        /// An optional comment about the revision.
        public let comment: String?
        /// The date and time that the revision was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The unique identifier for the data set associated with the data set revision.
        public let dataSetId: String?
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public let finalized: Bool?
        /// The unique identifier for the revision.
        public let id: String?
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public let revocationComment: String?
        /// A status indicating that subscribers' access to the revision was revoked.
        public let revoked: Bool?
        /// The date and time that the revision was revoked, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var revokedAt: Date?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public let sourceId: String?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, comment: String? = nil, createdAt: Date? = nil, dataSetId: String? = nil, finalized: Bool? = nil, id: String? = nil, revocationComment: String? = nil, revoked: Bool? = nil, revokedAt: Date? = nil, sourceId: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.revocationComment = revocationComment
            self.revoked = revoked
            self.revokedAt = revokedAt
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case comment = "Comment"
            case createdAt = "CreatedAt"
            case dataSetId = "DataSetId"
            case finalized = "Finalized"
            case id = "Id"
            case revocationComment = "RevocationComment"
            case revoked = "Revoked"
            case revokedAt = "RevokedAt"
            case sourceId = "SourceId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The unique identifier for the resource that couldn't be found.
        public let exceptionCause: ExceptionCause?
        /// The message that informs you about what was invalid about the request.
        public let message: String

        @inlinable
        public init(exceptionCause: ExceptionCause? = nil, message: String) {
            self.exceptionCause = exceptionCause
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionCause = "ExceptionCause"
            case message = "Message"
        }
    }
}

// MARK: - Errors

/// Error enum for DataExchange
public struct DataExchangeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceLimitExceededException = "ServiceLimitExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DataExchange
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access to the resource is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request couldn't be completed because it conflicted with the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// An exception occurred with the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource couldn't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request has exceeded the quotas imposed by the service.
    public static var serviceLimitExceededException: Self { .init(.serviceLimitExceededException) }
    /// The limit on the number of requests per second was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request was invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension DataExchangeErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": DataExchange.ConflictException.self,
        "ResourceNotFoundException": DataExchange.ResourceNotFoundException.self,
        "ServiceLimitExceededException": DataExchange.ServiceLimitExceededException.self,
        "ValidationException": DataExchange.ValidationException.self
    ]
}

extension DataExchangeErrorType: Equatable {
    public static func == (lhs: DataExchangeErrorType, rhs: DataExchangeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DataExchangeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
