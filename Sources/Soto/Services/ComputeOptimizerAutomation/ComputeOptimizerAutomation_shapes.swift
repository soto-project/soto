//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ComputeOptimizerAutomation {
    // MARK: Enums

    public enum AutomationEventFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "AccountId"
        case eventStatus = "EventStatus"
        case eventType = "EventType"
        case resourceType = "ResourceType"
        public var description: String { return self.rawValue }
    }

    public enum AutomationRuleFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "AccountId"
        case name = "Name"
        case organizationConfigurationRuleApplyOrder = "OrganizationConfigurationRuleApplyOrder"
        case recommendedActionType = "RecommendedActionType"
        case ruleType = "RuleType"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case numericEquals = "NumericEquals"
        case numericGreaterThan = "NumericGreaterThan"
        case numericGreaterThanEquals = "NumericGreaterThanEquals"
        case numericLessThan = "NumericLessThan"
        case numericLessThanEquals = "NumericLessThanEquals"
        case numericNotEquals = "NumericNotEquals"
        case stringEquals = "StringEquals"
        case stringEqualsIgnoreCase = "StringEqualsIgnoreCase"
        case stringLike = "StringLike"
        case stringNotEquals = "StringNotEquals"
        case stringNotEqualsIgnoreCase = "StringNotEqualsIgnoreCase"
        case stringNotLike = "StringNotLike"
        public var description: String { return self.rawValue }
    }

    public enum EnrollmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case failed = "Failed"
        case inactive = "Inactive"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum EventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "Cancelled"
        case complete = "Complete"
        case failed = "Failed"
        case inProgress = "InProgress"
        case ready = "Ready"
        case rollbackComplete = "RollbackComplete"
        case rollbackFailed = "RollbackFailed"
        case rollbackInProgress = "RollbackInProgress"
        case rollbackReady = "RollbackReady"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case snapshotAndDeleteUnattachedEbsVolume = "SnapshotAndDeleteUnattachedEbsVolume"
        case upgradeEbsVolumeType = "UpgradeEbsVolumeType"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationRuleMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anyAllowed = "AnyAllowed"
        case noneAllowed = "NoneAllowed"
        public var description: String { return self.rawValue }
    }

    public enum RecommendedActionFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "AccountId"
        case currentResourceDetailsEbsVolumeType = "CurrentResourceDetailsEbsVolumeType"
        case lookBackPeriodInDays = "LookBackPeriodInDays"
        case recommendedActionType = "RecommendedActionType"
        case resourceId = "ResourceId"
        case resourceTagsKey = "ResourceTagsKey"
        case resourceTagsValue = "ResourceTagsValue"
        case resourceType = "ResourceType"
        case restartNeeded = "RestartNeeded"
        public var description: String { return self.rawValue }
    }

    public enum RecommendedActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case snapshotAndDeleteUnattachedEbsVolume = "SnapshotAndDeleteUnattachedEbsVolume"
        case upgradeEbsVolumeType = "UpgradeEbsVolumeType"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebsVolume = "EbsVolume"
        public var description: String { return self.rawValue }
    }

    public enum RuleApplyOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterAccountRules = "AfterAccountRules"
        case beforeAccountRules = "BeforeAccountRules"
        public var description: String { return self.rawValue }
    }

    public enum RuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum RuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountRule = "AccountRule"
        case organizationalRule = "OrganizationRule"
        public var description: String { return self.rawValue }
    }

    public enum SavingsEstimationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterDiscount = "AfterDiscount"
        case beforeDiscount = "BeforeDiscount"
        public var description: String { return self.rawValue }
    }

    public enum StepStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "Complete"
        case failed = "Failed"
        case inProgress = "InProgress"
        case ready = "Ready"
        public var description: String { return self.rawValue }
    }

    public enum StepType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createEbsSnapshot = "CreateEbsSnapshot"
        case createEbsVolume = "CreateEbsVolume"
        case deleteEbsVolume = "DeleteEbsVolume"
        case modifyEbsVolume = "ModifyEbsVolume"
        public var description: String { return self.rawValue }
    }

    public enum SummaryDimensionKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eventStatus = "EventStatus"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountInfo: AWSDecodableShape {
        ///  The ID of the Amazon Web Services account.
        public let accountId: String
        /// The timestamp when the account's Automation enrollment status was last updated.
        public let lastUpdatedTimestamp: Date
        /// Specifies whether the management account can create Automation rules that implement optimization actions for this account.
        public let organizationRuleMode: OrganizationRuleMode
        ///  The enrollment status of the account: Active, Inactive, Pending, or Failed.
        public let status: EnrollmentStatus
        /// The reason for the current Automation enrollment status.
        public let statusReason: String?

        @inlinable
        public init(accountId: String, lastUpdatedTimestamp: Date, organizationRuleMode: OrganizationRuleMode, status: EnrollmentStatus, statusReason: String? = nil) {
            self.accountId = accountId
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.organizationRuleMode = organizationRuleMode
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case organizationRuleMode = "organizationRuleMode"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct AssociateAccountsRequest: AWSEncodableShape {
        ///  The IDs of the member accounts to associate. You can specify up to 50 account IDs.
        public let accountIds: [String]
        ///  A unique identifier to ensure idempotency of the request. Valid for 24 hours after creation.
        public let clientToken: String?

        @inlinable
        public init(accountIds: [String], clientToken: String? = AssociateAccountsRequest.idempotencyToken()) {
            self.accountIds = accountIds
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case clientToken = "clientToken"
        }
    }

    public struct AssociateAccountsResponse: AWSDecodableShape {
        ///  The IDs of the member accounts that were successfully associated.
        public let accountIds: [String]?
        ///  Any errors that occurred during the association process.
        public let errors: [String]?

        @inlinable
        public init(accountIds: [String]? = nil, errors: [String]? = nil) {
            self.accountIds = accountIds
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case errors = "errors"
        }
    }

    public struct AutomationEvent: AWSDecodableShape {
        ///  The Amazon Web Services account ID associated with the automation event.
        public let accountId: String?
        ///  The timestamp when the automation event completed.
        public let completedTimestamp: Date?
        /// The timestamp when the automation event was created.
        public let createdTimestamp: Date?
        ///  The estimated monthly cost savings associated with this automation event.
        public let estimatedMonthlySavings: EstimatedMonthlySavings?
        ///  A description of the automation event.
        public let eventDescription: String?
        ///  The unique identifier for the automation event.
        public let eventId: String?
        ///  The current status of the automation event.
        public let eventStatus: EventStatus?
        ///  The reason for the current event status.
        public let eventStatusReason: String?
        ///  The type of automation event.
        public let eventType: EventType?
        ///  The ID of the recommended action associated with this automation event.
        public let recommendedActionId: String?
        ///  The Amazon Web Services Region where the automation event occurred.
        public let region: String?
        ///  The Amazon Resource Name (ARN) of the resource affected by the automation event.
        public let resourceArn: String?
        ///  The ID of the resource affected by the automation event.
        public let resourceId: String?
        ///  The type of resource affected by the automation event.
        public let resourceType: ResourceType?
        ///  The ID of the automation rule that triggered this event.
        public let ruleId: String?

        @inlinable
        public init(accountId: String? = nil, completedTimestamp: Date? = nil, createdTimestamp: Date? = nil, estimatedMonthlySavings: EstimatedMonthlySavings? = nil, eventDescription: String? = nil, eventId: String? = nil, eventStatus: EventStatus? = nil, eventStatusReason: String? = nil, eventType: EventType? = nil, recommendedActionId: String? = nil, region: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil, ruleId: String? = nil) {
            self.accountId = accountId
            self.completedTimestamp = completedTimestamp
            self.createdTimestamp = createdTimestamp
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.eventDescription = eventDescription
            self.eventId = eventId
            self.eventStatus = eventStatus
            self.eventStatusReason = eventStatusReason
            self.eventType = eventType
            self.recommendedActionId = recommendedActionId
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case completedTimestamp = "completedTimestamp"
            case createdTimestamp = "createdTimestamp"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case eventDescription = "eventDescription"
            case eventId = "eventId"
            case eventStatus = "eventStatus"
            case eventStatusReason = "eventStatusReason"
            case eventType = "eventType"
            case recommendedActionId = "recommendedActionId"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case ruleId = "ruleId"
        }
    }

    public struct AutomationEventFilter: AWSEncodableShape {
        ///  The name of the filter to apply.
        public let name: AutomationEventFilterName
        ///  The values to use for the specified filter.
        public let values: [String]

        @inlinable
        public init(name: AutomationEventFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\.\\*\\?\\s]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct AutomationEventStep: AWSDecodableShape {
        /// The timestamp when this automation event step completed execution.
        public let completedTimestamp: Date?
        public let estimatedMonthlySavings: EstimatedMonthlySavings?
        ///  The ID of the automation event this step belongs to.
        public let eventId: String?
        /// The unique identifier of the resource being acted upon in this step.
        public let resourceId: String?
        /// The timestamp when this automation event step started execution.
        public let startTimestamp: Date?
        ///  The unique identifier for this step.
        public let stepId: String?
        ///  The current status of the step.
        public let stepStatus: StepStatus?
        ///  The type of step.
        public let stepType: StepType?

        @inlinable
        public init(completedTimestamp: Date? = nil, estimatedMonthlySavings: EstimatedMonthlySavings? = nil, eventId: String? = nil, resourceId: String? = nil, startTimestamp: Date? = nil, stepId: String? = nil, stepStatus: StepStatus? = nil, stepType: StepType? = nil) {
            self.completedTimestamp = completedTimestamp
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.eventId = eventId
            self.resourceId = resourceId
            self.startTimestamp = startTimestamp
            self.stepId = stepId
            self.stepStatus = stepStatus
            self.stepType = stepType
        }

        private enum CodingKeys: String, CodingKey {
            case completedTimestamp = "completedTimestamp"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case eventId = "eventId"
            case resourceId = "resourceId"
            case startTimestamp = "startTimestamp"
            case stepId = "stepId"
            case stepStatus = "stepStatus"
            case stepType = "stepType"
        }
    }

    public struct AutomationEventSummary: AWSDecodableShape {
        /// The dimensions used to group this summary, such as event status.
        public let dimensions: [SummaryDimension]?
        /// The key identifier for this summary grouping.
        public let key: String?
        /// The time period covered by this summary, with inclusive start time and exclusive end time.
        public let timePeriod: TimePeriod?
        /// The aggregated totals for this summary, including event count and estimated savings.
        public let total: SummaryTotals?

        @inlinable
        public init(dimensions: [SummaryDimension]? = nil, key: String? = nil, timePeriod: TimePeriod? = nil, total: SummaryTotals? = nil) {
            self.dimensions = dimensions
            self.key = key
            self.timePeriod = timePeriod
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "dimensions"
            case key = "key"
            case timePeriod = "timePeriod"
            case total = "total"
        }
    }

    public struct AutomationRule: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account ID that owns this automation rule.
        public let accountId: String?
        /// The timestamp when the automation rule was created.
        public let createdTimestamp: Date?
        /// A description of the automation rule.
        public let description: String?
        /// The timestamp when the automation rule was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The name of the automation rule.
        public let name: String?
        /// Configuration settings for organization-wide rules.
        public let organizationConfiguration: OrganizationConfiguration?
        /// A string representation of a decimal number between 0 and 1 (having up to 30 digits after the decimal point) that determines the priority of the rule. When multiple rules match the same recommended action, Compute Optimizer assigns the action to the rule with the lowest priority value (highest priority), even if that rule is scheduled to run later than other matching rules.
        public let priority: String?
        /// List of recommended action types that this rule can execute.
        public let recommendedActionTypes: [RecommendedActionType]?
        /// The Amazon Resource Name (ARN) of the automation rule.
        public let ruleArn: String?
        /// The unique identifier of the automation rule.
        public let ruleId: String?
        /// The revision number of the automation rule.
        public let ruleRevision: Int64?
        /// The type of automation rule (OrganizationRule or AccountRule).
        public let ruleType: RuleType?
        /// The schedule configuration for when the automation rule should execute.
        public let schedule: Schedule?
        /// The current status of the automation rule (Active or Inactive).
        public let status: RuleStatus?

        @inlinable
        public init(accountId: String? = nil, createdTimestamp: Date? = nil, description: String? = nil, lastUpdatedTimestamp: Date? = nil, name: String? = nil, organizationConfiguration: OrganizationConfiguration? = nil, priority: String? = nil, recommendedActionTypes: [RecommendedActionType]? = nil, ruleArn: String? = nil, ruleId: String? = nil, ruleRevision: Int64? = nil, ruleType: RuleType? = nil, schedule: Schedule? = nil, status: RuleStatus? = nil) {
            self.accountId = accountId
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.ruleRevision = ruleRevision
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case createdTimestamp = "createdTimestamp"
            case description = "description"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case name = "name"
            case organizationConfiguration = "organizationConfiguration"
            case priority = "priority"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleArn = "ruleArn"
            case ruleId = "ruleId"
            case ruleRevision = "ruleRevision"
            case ruleType = "ruleType"
            case schedule = "schedule"
            case status = "status"
        }
    }

    public struct CreateAutomationRuleRequest: AWSEncodableShape {
        ///  A unique identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time.
        public let criteria: Criteria?
        ///  A description of the automation rule.
        public let description: String?
        ///  The name of the automation rule.
        public let name: String
        ///  Configuration for organization-level rules. Required for OrganizationRule type.
        public let organizationConfiguration: OrganizationConfiguration?
        /// A string representation of a decimal number between 0 and 1 (having up to 30 digits after the decimal point) that determines the priority of the rule. When multiple rules match the same recommended action, Compute Optimizer assigns the action to the rule with the lowest priority value (highest priority), even if that rule is scheduled to run later than other matching rules.
        public let priority: String?
        ///  The types of recommended actions this rule will automate.
        public let recommendedActionTypes: [RecommendedActionType]
        ///  The type of rule.   Only the management account or a delegated administrator can set the ruleType to be OrganizationRule.
        public let ruleType: RuleType
        ///  The schedule for when the rule should run.
        public let schedule: Schedule
        /// The status of the rule
        public let status: RuleStatus
        ///  The tags to associate with the rule.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateAutomationRuleRequest.idempotencyToken(), criteria: Criteria? = nil, description: String? = nil, name: String, organizationConfiguration: OrganizationConfiguration? = nil, priority: String? = nil, recommendedActionTypes: [RecommendedActionType], ruleType: RuleType, schedule: Schedule, status: RuleStatus, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.criteria = criteria
            self.description = description
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.criteria?.validate(name: "\(name).criteria")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9_\\-\\s@\\.]*$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]*$")
            try self.organizationConfiguration?.validate(name: "\(name).organizationConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case criteria = "criteria"
            case description = "description"
            case name = "name"
            case organizationConfiguration = "organizationConfiguration"
            case priority = "priority"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleType = "ruleType"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateAutomationRuleResponse: AWSDecodableShape {
        /// The timestamp when the automation rule was created.
        public let createdTimestamp: Date?
        public let criteria: Criteria?
        /// A description of the automation rule. Can be up to 1024 characters long and contain alphanumeric characters, underscores, hyphens, spaces, and certain special characters.
        public let description: String?
        /// The name of the automation rule. Must be 1-128 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let name: String?
        /// Configuration settings for organization-wide rules, including rule application order and target account IDs.
        public let organizationConfiguration: OrganizationConfiguration?
        /// The priority level of the automation rule, used to determine execution order when multiple rules apply to the same resource.
        public let priority: String?
        /// List of recommended action types that this rule can execute, such as SnapshotAndDeleteUnattachedEbsVolume or UpgradeEbsVolumeType.
        public let recommendedActionTypes: [RecommendedActionType]?
        ///  The Amazon Resource Name (ARN) of the created rule.
        public let ruleArn: String?
        ///  The unique identifier of the created rule.
        public let ruleId: String?
        /// The revision number of the automation rule. This is incremented each time the rule is updated.
        public let ruleRevision: Int64?
        /// The type of automation rule. Can be either OrganizationRule for organization-wide rules or AccountRule for account-specific rules.
        public let ruleType: RuleType?
        /// The schedule configuration for when the automation rule should execute, including cron expression, timezone, and execution window.
        public let schedule: Schedule?
        /// The current status of the automation rule. Can be Active or Inactive.
        public let status: RuleStatus?
        /// A list of key-value pairs used to categorize and organize the automation rule. Maximum of 200 tags allowed.
        public let tags: [Tag]?

        @inlinable
        public init(createdTimestamp: Date? = nil, criteria: Criteria? = nil, description: String? = nil, name: String? = nil, organizationConfiguration: OrganizationConfiguration? = nil, priority: String? = nil, recommendedActionTypes: [RecommendedActionType]? = nil, ruleArn: String? = nil, ruleId: String? = nil, ruleRevision: Int64? = nil, ruleType: RuleType? = nil, schedule: Schedule? = nil, status: RuleStatus? = nil, tags: [Tag]? = nil) {
            self.createdTimestamp = createdTimestamp
            self.criteria = criteria
            self.description = description
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.ruleRevision = ruleRevision
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case criteria = "criteria"
            case description = "description"
            case name = "name"
            case organizationConfiguration = "organizationConfiguration"
            case priority = "priority"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleArn = "ruleArn"
            case ruleId = "ruleId"
            case ruleRevision = "ruleRevision"
            case ruleType = "ruleType"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct Criteria: AWSEncodableShape & AWSDecodableShape {
        /// Filter criteria for EBS volume sizes in gibibytes (GiB).
        public let ebsVolumeSizeInGib: [IntegerCriteriaCondition]?
        /// Filter criteria for EBS volume types, such as gp2, gp3, io1, io2, st1, or sc1.
        public let ebsVolumeType: [StringCriteriaCondition]?
        /// Filter criteria for estimated monthly cost savings from the recommended action.
        public let estimatedMonthlySavings: [DoubleCriteriaCondition]?
        /// Filter criteria for the lookback period in days used to analyze resource utilization.
        public let lookBackPeriodInDays: [IntegerCriteriaCondition]?
        /// Filter criteria for Amazon Web Services regions where resources must be located.
        public let region: [StringCriteriaCondition]?
        /// Filter criteria for specific resource ARNs to include or exclude.
        public let resourceArn: [StringCriteriaCondition]?
        /// Filter criteria for resource tags, allowing filtering by tag key and value combinations.
        public let resourceTag: [ResourceTagsCriteriaCondition]?
        /// Filter criteria indicating whether the recommended action requires a resource restart.
        public let restartNeeded: [StringCriteriaCondition]?

        @inlinable
        public init(ebsVolumeSizeInGib: [IntegerCriteriaCondition]? = nil, ebsVolumeType: [StringCriteriaCondition]? = nil, estimatedMonthlySavings: [DoubleCriteriaCondition]? = nil, lookBackPeriodInDays: [IntegerCriteriaCondition]? = nil, region: [StringCriteriaCondition]? = nil, resourceArn: [StringCriteriaCondition]? = nil, resourceTag: [ResourceTagsCriteriaCondition]? = nil, restartNeeded: [StringCriteriaCondition]? = nil) {
            self.ebsVolumeSizeInGib = ebsVolumeSizeInGib
            self.ebsVolumeType = ebsVolumeType
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.region = region
            self.resourceArn = resourceArn
            self.resourceTag = resourceTag
            self.restartNeeded = restartNeeded
        }

        public func validate(name: String) throws {
            try self.ebsVolumeType?.forEach {
                try $0.validate(name: "\(name).ebsVolumeType[]")
            }
            try self.region?.forEach {
                try $0.validate(name: "\(name).region[]")
            }
            try self.resourceArn?.forEach {
                try $0.validate(name: "\(name).resourceArn[]")
            }
            try self.resourceTag?.forEach {
                try $0.validate(name: "\(name).resourceTag[]")
            }
            try self.restartNeeded?.forEach {
                try $0.validate(name: "\(name).restartNeeded[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumeSizeInGib = "ebsVolumeSizeInGib"
            case ebsVolumeType = "ebsVolumeType"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case lookBackPeriodInDays = "lookBackPeriodInDays"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceTag = "resourceTag"
            case restartNeeded = "restartNeeded"
        }
    }

    public struct DeleteAutomationRuleRequest: AWSEncodableShape {
        ///  A unique identifier to ensure idempotency of the request.
        public let clientToken: String?
        ///  The ARN of the rule to delete.
        public let ruleArn: String
        ///  The revision number of the rule to delete.
        public let ruleRevision: Int64

        @inlinable
        public init(clientToken: String? = DeleteAutomationRuleRequest.idempotencyToken(), ruleArn: String, ruleRevision: Int64) {
            self.clientToken = clientToken
            self.ruleArn = ruleArn
            self.ruleRevision = ruleRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.validate(self.ruleArn, name: "ruleArn", parent: name, pattern: "^arn:aws:compute-optimizer::[0-9]{12}:automation-rule/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case ruleArn = "ruleArn"
            case ruleRevision = "ruleRevision"
        }
    }

    public struct DeleteAutomationRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateAccountsRequest: AWSEncodableShape {
        ///  The IDs of the member accounts to disassociate.
        public let accountIds: [String]
        ///  A unique identifier to ensure idempotency of the request.
        public let clientToken: String?

        @inlinable
        public init(accountIds: [String], clientToken: String? = DisassociateAccountsRequest.idempotencyToken()) {
            self.accountIds = accountIds
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case clientToken = "clientToken"
        }
    }

    public struct DisassociateAccountsResponse: AWSDecodableShape {
        ///  The IDs of the member accounts that were successfully disassociated.
        public let accountIds: [String]?
        ///  Any errors that occurred during the disassociation process.
        public let errors: [String]?

        @inlinable
        public init(accountIds: [String]? = nil, errors: [String]? = nil) {
            self.accountIds = accountIds
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case errors = "errors"
        }
    }

    public struct DoubleCriteriaCondition: AWSEncodableShape & AWSDecodableShape {
        /// The comparison operator to use, such as equals, greater than, less than, etc.
        public let comparison: ComparisonOperator?
        /// The list of double values to compare against using the specified comparison operator.
        public let values: [Double]?

        @inlinable
        public init(comparison: ComparisonOperator? = nil, values: [Double]? = nil) {
            self.comparison = comparison
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case values = "values"
        }
    }

    public struct EbsVolume: AWSDecodableShape {
        /// The configuration details of the EBS volume, including type, size, IOPS, and throughput.
        public let configuration: EbsVolumeConfiguration?

        @inlinable
        public init(configuration: EbsVolumeConfiguration? = nil) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct EbsVolumeConfiguration: AWSDecodableShape {
        /// The number of I/O operations per second (IOPS) provisioned for the volume.
        public let iops: Int?
        /// The size of the EBS volume in gibibytes (GiB).
        public let sizeInGib: Int?
        /// The throughput in MiB/s provisioned for the volume (applicable to gp3, io1, and io2bx volumes).
        public let throughput: Int?
        /// The EBS volume type, such as gp2, gp3, io1, io2, st1, or sc1.
        public let type: String?

        @inlinable
        public init(iops: Int? = nil, sizeInGib: Int? = nil, throughput: Int? = nil, type: String? = nil) {
            self.iops = iops
            self.sizeInGib = sizeInGib
            self.throughput = throughput
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case iops = "iops"
            case sizeInGib = "sizeInGib"
            case throughput = "throughput"
            case type = "type"
        }
    }

    public struct EstimatedMonthlySavings: AWSDecodableShape {
        ///  The estimated monthly savings after applying any discounts.
        public let afterDiscountSavings: Double
        ///  The estimated monthly savings before applying any discounts.
        public let beforeDiscountSavings: Double
        ///  The currency of the estimated savings.
        public let currency: String
        /// The mode used to calculate savings, either BeforeDiscount or AfterDiscount.
        public let savingsEstimationMode: SavingsEstimationMode

        @inlinable
        public init(afterDiscountSavings: Double, beforeDiscountSavings: Double, currency: String, savingsEstimationMode: SavingsEstimationMode) {
            self.afterDiscountSavings = afterDiscountSavings
            self.beforeDiscountSavings = beforeDiscountSavings
            self.currency = currency
            self.savingsEstimationMode = savingsEstimationMode
        }

        private enum CodingKeys: String, CodingKey {
            case afterDiscountSavings = "afterDiscountSavings"
            case beforeDiscountSavings = "beforeDiscountSavings"
            case currency = "currency"
            case savingsEstimationMode = "savingsEstimationMode"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter field to apply.
        public let name: AutomationRuleFilterName
        /// The list of values to filter by for the specified filter field.
        public let values: [String]

        @inlinable
        public init(name: AutomationRuleFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\.\\*\\?\\s]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct GetAutomationEventRequest: AWSEncodableShape {
        ///  The ID of the automation event to retrieve.
        public let eventId: String

        @inlinable
        public init(eventId: String) {
            self.eventId = eventId
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9A-Za-z]{16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
        }
    }

    public struct GetAutomationEventResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID associated with the automation event.
        public let accountId: String?
        /// The timestamp when the automation event completed.
        public let completedTimestamp: Date?
        /// The timestamp when the automation event was created.
        public let createdTimestamp: Date?
        public let estimatedMonthlySavings: EstimatedMonthlySavings?
        /// A description of the automation event.
        public let eventDescription: String?
        /// The ID of the automation event to retrieve.
        public let eventId: String?
        /// The current status of the automation event.
        public let eventStatus: EventStatus?
        /// The reason for the current event status.
        public let eventStatusReason: String?
        /// The type of automation event.
        public let eventType: EventType?
        /// The ID of the recommended action associated with this automation event.
        public let recommendedActionId: String?
        /// The Amazon Web Services Region where the automation event occurred.
        public let region: String?
        /// The Amazon Resource Name (ARN) of the resource affected by the automation event.
        public let resourceArn: String?
        /// The ID of the resource affected by the automation event.
        public let resourceId: String?
        /// The type of resource affected by the automation event.
        public let resourceType: ResourceType?
        /// The ID of the automation rule that triggered this event.
        public let ruleId: String?

        @inlinable
        public init(accountId: String? = nil, completedTimestamp: Date? = nil, createdTimestamp: Date? = nil, estimatedMonthlySavings: EstimatedMonthlySavings? = nil, eventDescription: String? = nil, eventId: String? = nil, eventStatus: EventStatus? = nil, eventStatusReason: String? = nil, eventType: EventType? = nil, recommendedActionId: String? = nil, region: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil, ruleId: String? = nil) {
            self.accountId = accountId
            self.completedTimestamp = completedTimestamp
            self.createdTimestamp = createdTimestamp
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.eventDescription = eventDescription
            self.eventId = eventId
            self.eventStatus = eventStatus
            self.eventStatusReason = eventStatusReason
            self.eventType = eventType
            self.recommendedActionId = recommendedActionId
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case completedTimestamp = "completedTimestamp"
            case createdTimestamp = "createdTimestamp"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case eventDescription = "eventDescription"
            case eventId = "eventId"
            case eventStatus = "eventStatus"
            case eventStatusReason = "eventStatusReason"
            case eventType = "eventType"
            case recommendedActionId = "recommendedActionId"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case ruleId = "ruleId"
        }
    }

    public struct GetAutomationRuleRequest: AWSEncodableShape {
        ///  The ARN of the rule to retrieve.
        public let ruleArn: String

        @inlinable
        public init(ruleArn: String) {
            self.ruleArn = ruleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleArn, name: "ruleArn", parent: name, pattern: "^arn:aws:compute-optimizer::[0-9]{12}:automation-rule/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "ruleArn"
        }
    }

    public struct GetAutomationRuleResponse: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account ID that owns this automation rule.
        public let accountId: String?
        /// The timestamp when the automation rule was created.
        public let createdTimestamp: Date?
        public let criteria: Criteria?
        /// A description of the automation rule.
        public let description: String?
        /// The timestamp when the automation rule was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The name of the automation rule.
        public let name: String?
        public let organizationConfiguration: OrganizationConfiguration?
        /// A string representation of a decimal number between 0 and 1 (having up to 30 digits after the decimal point) that determines the priority of the rule.
        public let priority: String?
        /// List of recommended action types that this rule can execute.
        public let recommendedActionTypes: [RecommendedActionType]?
        /// The Amazon Resource Name (ARN) of the automation rule.
        public let ruleArn: String?
        /// The unique identifier of the automation rule.
        public let ruleId: String?
        /// The revision number of the automation rule.
        public let ruleRevision: Int64?
        /// The type of automation rule.
        public let ruleType: RuleType?
        public let schedule: Schedule?
        /// The current status of the automation rule (Active or Inactive).
        public let status: RuleStatus?
        /// The tags associated with the automation rule.
        public let tags: [Tag]?

        @inlinable
        public init(accountId: String? = nil, createdTimestamp: Date? = nil, criteria: Criteria? = nil, description: String? = nil, lastUpdatedTimestamp: Date? = nil, name: String? = nil, organizationConfiguration: OrganizationConfiguration? = nil, priority: String? = nil, recommendedActionTypes: [RecommendedActionType]? = nil, ruleArn: String? = nil, ruleId: String? = nil, ruleRevision: Int64? = nil, ruleType: RuleType? = nil, schedule: Schedule? = nil, status: RuleStatus? = nil, tags: [Tag]? = nil) {
            self.accountId = accountId
            self.createdTimestamp = createdTimestamp
            self.criteria = criteria
            self.description = description
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.ruleRevision = ruleRevision
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case createdTimestamp = "createdTimestamp"
            case criteria = "criteria"
            case description = "description"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case name = "name"
            case organizationConfiguration = "organizationConfiguration"
            case priority = "priority"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleArn = "ruleArn"
            case ruleId = "ruleId"
            case ruleRevision = "ruleRevision"
            case ruleType = "ruleType"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetEnrollmentConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEnrollmentConfigurationResponse: AWSDecodableShape {
        ///  The timestamp of the last update to the enrollment configuration.
        public let lastUpdatedTimestamp: Date?
        /// Specifies whether the management account can create Automation rules that implement optimization actions for this account.
        public let organizationRuleMode: OrganizationRuleMode?
        ///  The current enrollment status.
        public let status: EnrollmentStatus
        ///  The reason for the current enrollment status.
        public let statusReason: String?

        @inlinable
        public init(lastUpdatedTimestamp: Date? = nil, organizationRuleMode: OrganizationRuleMode? = nil, status: EnrollmentStatus, statusReason: String? = nil) {
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.organizationRuleMode = organizationRuleMode
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case organizationRuleMode = "organizationRuleMode"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct IntegerCriteriaCondition: AWSEncodableShape & AWSDecodableShape {
        /// The comparison operator to use, such as equals, greater than, less than, etc.
        public let comparison: ComparisonOperator?
        /// The list of integer values to compare against using the specified comparison operator.
        public let values: [Int]?

        @inlinable
        public init(comparison: ComparisonOperator? = nil, values: [Int]? = nil) {
            self.comparison = comparison
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case values = "values"
        }
    }

    public struct ListAccountsRequest: AWSEncodableShape {
        ///  The maximum number of results to return in a single call.
        public let maxResults: Int?
        ///  The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAccountsResponse: AWSDecodableShape {
        ///  The list of accounts in your organization enrolled in Compute Optimizer
        public let accounts: [AccountInfo]
        ///  The token to use to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(accounts: [AccountInfo], nextToken: String? = nil) {
            self.accounts = accounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case nextToken = "nextToken"
        }
    }

    public struct ListAutomationEventStepsRequest: AWSEncodableShape {
        ///  The ID of the automation event.
        public let eventId: String
        /// The maximum number of automation event steps to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?

        @inlinable
        public init(eventId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.eventId = eventId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9A-Za-z]{16}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAutomationEventStepsResponse: AWSDecodableShape {
        ///  The list of steps for the specified automation event.
        public let automationEventSteps: [AutomationEventStep]?
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?

        @inlinable
        public init(automationEventSteps: [AutomationEventStep]? = nil, nextToken: String? = nil) {
            self.automationEventSteps = automationEventSteps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case automationEventSteps = "automationEventSteps"
            case nextToken = "nextToken"
        }
    }

    public struct ListAutomationEventSummariesRequest: AWSEncodableShape {
        /// The end date for filtering automation event summaries, exclusive. Events created before this date will be included.
        public let endDateExclusive: String?
        ///  The filters to apply to the list of automation event summaries.
        public let filters: [AutomationEventFilter]?
        /// The maximum number of automation event summaries to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?
        /// The start date for filtering automation event summaries, inclusive. Events created on or after this date will be included.
        public let startDateInclusive: String?

        @inlinable
        public init(endDateExclusive: String? = nil, filters: [AutomationEventFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, startDateInclusive: String? = nil) {
            self.endDateExclusive = endDateExclusive
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startDateInclusive = startDateInclusive
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endDateExclusive = "endDateExclusive"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case startDateInclusive = "startDateInclusive"
        }
    }

    public struct ListAutomationEventSummariesResponse: AWSDecodableShape {
        ///  The list of automation event summaries that match the specified criteria.
        public let automationEventSummaries: [AutomationEventSummary]?
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?

        @inlinable
        public init(automationEventSummaries: [AutomationEventSummary]? = nil, nextToken: String? = nil) {
            self.automationEventSummaries = automationEventSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case automationEventSummaries = "automationEventSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAutomationEventsRequest: AWSEncodableShape {
        ///  The end of the time range to query for events.
        public let endTimeExclusive: Date?
        ///  The filters to apply to the list of automation events.
        public let filters: [AutomationEventFilter]?
        ///  The maximum number of results to return in a single call.
        public let maxResults: Int?
        ///  The token for the next page of results.
        public let nextToken: String?
        ///  The start of the time range to query for events.
        public let startTimeInclusive: Date?

        @inlinable
        public init(endTimeExclusive: Date? = nil, filters: [AutomationEventFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTimeInclusive: Date? = nil) {
            self.endTimeExclusive = endTimeExclusive
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeInclusive = startTimeInclusive
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeExclusive = "endTimeExclusive"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case startTimeInclusive = "startTimeInclusive"
        }
    }

    public struct ListAutomationEventsResponse: AWSDecodableShape {
        ///  The list of automation events that match the specified criteria.
        public let automationEvents: [AutomationEvent]?
        ///  The token to use to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(automationEvents: [AutomationEvent]? = nil, nextToken: String? = nil) {
            self.automationEvents = automationEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case automationEvents = "automationEvents"
            case nextToken = "nextToken"
        }
    }

    public struct ListAutomationRulePreviewRequest: AWSEncodableShape {
        /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time.
        public let criteria: Criteria?
        /// The maximum number of automation rule preview results to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?
        ///  The organizational scope for the rule preview.
        public let organizationScope: OrganizationScope?
        ///  The types of recommended actions to include in the preview.
        public let recommendedActionTypes: [RecommendedActionType]
        ///  The type of rule.   Only the management account or a delegated administrator can set the ruleType to be OrganizationRule.
        public let ruleType: RuleType

        @inlinable
        public init(criteria: Criteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationScope: OrganizationScope? = nil, recommendedActionTypes: [RecommendedActionType], ruleType: RuleType) {
            self.criteria = criteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationScope = organizationScope
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleType = ruleType
        }

        public func validate(name: String) throws {
            try self.criteria?.validate(name: "\(name).criteria")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.organizationScope?.validate(name: "\(name).organizationScope")
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case organizationScope = "organizationScope"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleType = "ruleType"
        }
    }

    public struct ListAutomationRulePreviewResponse: AWSDecodableShape {
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?
        ///  The list of actions that would be taken based on the specified criteria.
        public let previewResults: [PreviewResult]?

        @inlinable
        public init(nextToken: String? = nil, previewResults: [PreviewResult]? = nil) {
            self.nextToken = nextToken
            self.previewResults = previewResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case previewResults = "previewResults"
        }
    }

    public struct ListAutomationRulePreviewSummariesRequest: AWSEncodableShape {
        public let criteria: Criteria?
        /// The maximum number of automation rule preview summaries to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?
        /// The organizational scope for the rule preview.
        public let organizationScope: OrganizationScope?
        /// The types of recommended actions to include in the preview.
        public let recommendedActionTypes: [RecommendedActionType]
        /// The type of rule.
        public let ruleType: RuleType

        @inlinable
        public init(criteria: Criteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationScope: OrganizationScope? = nil, recommendedActionTypes: [RecommendedActionType], ruleType: RuleType) {
            self.criteria = criteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationScope = organizationScope
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleType = ruleType
        }

        public func validate(name: String) throws {
            try self.criteria?.validate(name: "\(name).criteria")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
            try self.organizationScope?.validate(name: "\(name).organizationScope")
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case organizationScope = "organizationScope"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleType = "ruleType"
        }
    }

    public struct ListAutomationRulePreviewSummariesResponse: AWSDecodableShape {
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?
        /// The list of automation rule preview summaries that match the specified criteria.
        public let previewResultSummaries: [PreviewResultSummary]?

        @inlinable
        public init(nextToken: String? = nil, previewResultSummaries: [PreviewResultSummary]? = nil) {
            self.nextToken = nextToken
            self.previewResultSummaries = previewResultSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case previewResultSummaries = "previewResultSummaries"
        }
    }

    public struct ListAutomationRulesRequest: AWSEncodableShape {
        ///  The filters to apply to the list of automation rules.
        public let filters: [Filter]?
        /// The maximum number of automation rules to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAutomationRulesResponse: AWSDecodableShape {
        ///  The list of automation rules that match the specified criteria.
        public let automationRules: [AutomationRule]?
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?

        @inlinable
        public init(automationRules: [AutomationRule]? = nil, nextToken: String? = nil) {
            self.automationRules = automationRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case automationRules = "automationRules"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendedActionSummariesRequest: AWSEncodableShape {
        /// A list of filters to apply when retrieving recommended action summaries. Filters can be based on resource type, action type, account ID, and other criteria.
        public let filters: [RecommendedActionFilter]?
        /// The maximum number of recommended action summaries to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?

        @inlinable
        public init(filters: [RecommendedActionFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendedActionSummariesResponse: AWSDecodableShape {
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?
        ///  The summary of recommended actions that match the specified criteria.
        public let recommendedActionSummaries: [RecommendedActionSummary]?

        @inlinable
        public init(nextToken: String? = nil, recommendedActionSummaries: [RecommendedActionSummary]? = nil) {
            self.nextToken = nextToken
            self.recommendedActionSummaries = recommendedActionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recommendedActionSummaries = "recommendedActionSummaries"
        }
    }

    public struct ListRecommendedActionsRequest: AWSEncodableShape {
        ///  The filters to apply to the list of recommended actions.
        public let filters: [RecommendedActionFilter]?
        /// The maximum number of recommended actions to return in a single response. Valid range is 1-1000.
        public let maxResults: Int?
        /// A token used for pagination to retrieve the next set of results when the response is truncated.
        public let nextToken: String?

        @inlinable
        public init(filters: [RecommendedActionFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9+/=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendedActionsResponse: AWSDecodableShape {
        /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
        public let nextToken: String?
        ///  The list of recommended actions that match the specified criteria.
        public let recommendedActions: [RecommendedAction]?

        @inlinable
        public init(nextToken: String? = nil, recommendedActions: [RecommendedAction]? = nil) {
            self.nextToken = nextToken
            self.recommendedActions = recommendedActions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recommendedActions = "recommendedActions"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The ARN of the resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:compute-optimizer::[0-9]{12}:automation-rule/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The list of tags associated with the specified resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct OrganizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// List of specific Amazon Web Services account IDs where the organization rule should be applied.
        public let accountIds: [String]?
        /// Specifies when organization rules should be applied relative to account rules.
        public let ruleApplyOrder: RuleApplyOrder?

        @inlinable
        public init(accountIds: [String]? = nil, ruleApplyOrder: RuleApplyOrder? = nil) {
            self.accountIds = accountIds
            self.ruleApplyOrder = ruleApplyOrder
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case ruleApplyOrder = "ruleApplyOrder"
        }
    }

    public struct OrganizationScope: AWSEncodableShape {
        /// List of Amazon Web Services account IDs to include in the organization scope.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct PreviewResult: AWSDecodableShape {
        /// The Amazon Web Services account ID associated with the resource.
        public let accountId: String?
        public let currentResourceDetails: ResourceDetails?
        /// A summary of the resource's current configuration.
        public let currentResourceSummary: String?
        public let estimatedMonthlySavings: EstimatedMonthlySavings?
        /// The number of days of historical data used to analyze the resource.
        public let lookBackPeriodInDays: Int?
        /// The ID of the recommended action being previewed.
        public let recommendedActionId: String?
        /// The type of recommended action being previewed.
        public let recommendedActionType: RecommendedActionType?
        public let recommendedResourceDetails: ResourceDetails?
        /// A summary of the resource's recommended configuration.
        public let recommendedResourceSummary: String?
        /// The Amazon Web Services Region where the resource is located.
        public let region: String?
        /// The Amazon Resource Name (ARN) of the resource affected by the recommended action.
        public let resourceArn: String?
        /// The ID of the resource affected by the recommended action.
        public let resourceId: String?
        /// The tags associated with the resource.
        public let resourceTags: [Tag]?
        /// The type of resource being evaluated.
        public let resourceType: ResourceType?
        /// Indicates whether implementing the recommended action requires a resource restart.
        public let restartNeeded: Bool?

        @inlinable
        public init(accountId: String? = nil, currentResourceDetails: ResourceDetails? = nil, currentResourceSummary: String? = nil, estimatedMonthlySavings: EstimatedMonthlySavings? = nil, lookBackPeriodInDays: Int? = nil, recommendedActionId: String? = nil, recommendedActionType: RecommendedActionType? = nil, recommendedResourceDetails: ResourceDetails? = nil, recommendedResourceSummary: String? = nil, region: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceTags: [Tag]? = nil, resourceType: ResourceType? = nil, restartNeeded: Bool? = nil) {
            self.accountId = accountId
            self.currentResourceDetails = currentResourceDetails
            self.currentResourceSummary = currentResourceSummary
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.recommendedActionId = recommendedActionId
            self.recommendedActionType = recommendedActionType
            self.recommendedResourceDetails = recommendedResourceDetails
            self.recommendedResourceSummary = recommendedResourceSummary
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.restartNeeded = restartNeeded
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case currentResourceDetails = "currentResourceDetails"
            case currentResourceSummary = "currentResourceSummary"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case lookBackPeriodInDays = "lookBackPeriodInDays"
            case recommendedActionId = "recommendedActionId"
            case recommendedActionType = "recommendedActionType"
            case recommendedResourceDetails = "recommendedResourceDetails"
            case recommendedResourceSummary = "recommendedResourceSummary"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case restartNeeded = "restartNeeded"
        }
    }

    public struct PreviewResultSummary: AWSDecodableShape {
        /// The key identifier for this preview result summary.
        public let key: String
        public let total: RulePreviewTotal

        @inlinable
        public init(key: String, total: RulePreviewTotal) {
            self.key = key
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case total = "total"
        }
    }

    public struct RecommendedAction: AWSDecodableShape {
        /// The Amazon Web Services account ID that owns the resource.
        public let accountId: String?
        public let currentResourceDetails: ResourceDetails?
        /// A summary of the resource's current configuration.
        public let currentResourceSummary: String?
        public let estimatedMonthlySavings: EstimatedMonthlySavings?
        /// The number of days of historical data used to generate the recommendation.
        public let lookBackPeriodInDays: Int?
        /// The unique identifier of the recommended action.
        public let recommendedActionId: String?
        /// The type of action being recommended.
        public let recommendedActionType: RecommendedActionType?
        public let recommendedResourceDetails: ResourceDetails?
        /// A summary of the resource's recommended configuration.
        public let recommendedResourceSummary: String?
        /// The Amazon Web Services Region where the resource is located.
        public let region: String?
        /// The Amazon Resource Name (ARN) of the resource that the recommendation applies to.
        public let resourceArn: String?
        /// The ID of the resource that the recommendation applies to.
        public let resourceId: String?
        /// The tags associated with the resource.
        public let resourceTags: [Tag]?
        /// The type of resource being evaluated.
        public let resourceType: ResourceType?
        /// Indicates whether implementing the recommended action requires a resource restart.
        public let restartNeeded: Bool?

        @inlinable
        public init(accountId: String? = nil, currentResourceDetails: ResourceDetails? = nil, currentResourceSummary: String? = nil, estimatedMonthlySavings: EstimatedMonthlySavings? = nil, lookBackPeriodInDays: Int? = nil, recommendedActionId: String? = nil, recommendedActionType: RecommendedActionType? = nil, recommendedResourceDetails: ResourceDetails? = nil, recommendedResourceSummary: String? = nil, region: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceTags: [Tag]? = nil, resourceType: ResourceType? = nil, restartNeeded: Bool? = nil) {
            self.accountId = accountId
            self.currentResourceDetails = currentResourceDetails
            self.currentResourceSummary = currentResourceSummary
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.recommendedActionId = recommendedActionId
            self.recommendedActionType = recommendedActionType
            self.recommendedResourceDetails = recommendedResourceDetails
            self.recommendedResourceSummary = recommendedResourceSummary
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.restartNeeded = restartNeeded
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case currentResourceDetails = "currentResourceDetails"
            case currentResourceSummary = "currentResourceSummary"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case lookBackPeriodInDays = "lookBackPeriodInDays"
            case recommendedActionId = "recommendedActionId"
            case recommendedActionType = "recommendedActionType"
            case recommendedResourceDetails = "recommendedResourceDetails"
            case recommendedResourceSummary = "recommendedResourceSummary"
            case region = "region"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case restartNeeded = "restartNeeded"
        }
    }

    public struct RecommendedActionFilter: AWSEncodableShape {
        /// The name of the filter field to apply.
        public let name: RecommendedActionFilterName
        /// List of filter values to match against the specified filter name. Used to narrow down recommended actions based on specific criteria.
        public let values: [String]

        @inlinable
        public init(name: RecommendedActionFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\.\\*\\?\\s]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct RecommendedActionSummary: AWSDecodableShape {
        /// The grouping key used to categorize the recommended actions in this summary.
        public let key: String
        /// Aggregate totals for the recommended actions in this group, including count and estimated savings.
        public let total: RecommendedActionTotal

        @inlinable
        public init(key: String, total: RecommendedActionTotal) {
            self.key = key
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case total = "total"
        }
    }

    public struct RecommendedActionTotal: AWSDecodableShape {
        public let estimatedMonthlySavings: EstimatedMonthlySavings
        /// The total number of recommended actions in this group.
        public let recommendedActionCount: Int

        @inlinable
        public init(estimatedMonthlySavings: EstimatedMonthlySavings, recommendedActionCount: Int) {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.recommendedActionCount = recommendedActionCount
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case recommendedActionCount = "recommendedActionCount"
        }
    }

    public struct ResourceTagsCriteriaCondition: AWSEncodableShape & AWSDecodableShape {
        /// The comparison operator used to evaluate the tag criteria, such as equals, not equals, or contains.
        public let comparison: ComparisonOperator?
        /// The tag key to use for comparison when filtering resources.
        public let key: String?
        /// List of tag values to compare against when filtering resources.
        public let values: [String]?

        @inlinable
        public init(comparison: ComparisonOperator? = nil, key: String? = nil, values: [String]? = nil) {
            self.comparison = comparison
            self.key = key
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 512)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 512)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case key = "key"
            case values = "values"
        }
    }

    public struct RollbackAutomationEventRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let clientToken: String?
        ///  The ID of the automation event to roll back.
        public let eventId: String

        @inlinable
        public init(clientToken: String? = RollbackAutomationEventRequest.idempotencyToken(), eventId: String) {
            self.clientToken = clientToken
            self.eventId = eventId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9A-Za-z]{16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case eventId = "eventId"
        }
    }

    public struct RollbackAutomationEventResponse: AWSDecodableShape {
        ///  The ID of the automation event being rolled back.
        public let eventId: String?
        ///  The current status of the rollback operation.
        public let eventStatus: EventStatus?

        @inlinable
        public init(eventId: String? = nil, eventStatus: EventStatus? = nil) {
            self.eventId = eventId
            self.eventStatus = eventStatus
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case eventStatus = "eventStatus"
        }
    }

    public struct RulePreviewTotal: AWSDecodableShape {
        public let estimatedMonthlySavings: EstimatedMonthlySavings
        /// The total number of recommended actions matching the rule preview configuration.
        public let recommendedActionCount: Int

        @inlinable
        public init(estimatedMonthlySavings: EstimatedMonthlySavings, recommendedActionCount: Int) {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.recommendedActionCount = recommendedActionCount
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMonthlySavings = "estimatedMonthlySavings"
            case recommendedActionCount = "recommendedActionCount"
        }
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {
        /// The time window in minutes during which the automation rule can start implementing recommended actions.
        public let executionWindowInMinutes: Int?
        /// The expression that defines when the schedule runs. cron expression is supported. A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year)  You can schedule rules to run at most once per day. Your cron expression must use specific values (not wildcards) for the minutes and hours fields. For example: (30 12 * * *) runs daily at 12:30 PM UTC.
        public let scheduleExpression: String?
        /// The timezone to use when interpreting the schedule expression.
        public let scheduleExpressionTimezone: String?

        @inlinable
        public init(executionWindowInMinutes: Int? = nil, scheduleExpression: String? = nil, scheduleExpressionTimezone: String? = nil) {
            self.executionWindowInMinutes = executionWindowInMinutes
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
        }

        private enum CodingKeys: String, CodingKey {
            case executionWindowInMinutes = "executionWindowInMinutes"
            case scheduleExpression = "scheduleExpression"
            case scheduleExpressionTimezone = "scheduleExpressionTimezone"
        }
    }

    public struct StartAutomationEventRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let clientToken: String?
        ///  The ID of the recommended action to automate.
        public let recommendedActionId: String

        @inlinable
        public init(clientToken: String? = StartAutomationEventRequest.idempotencyToken(), recommendedActionId: String) {
            self.clientToken = clientToken
            self.recommendedActionId = recommendedActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.validate(self.recommendedActionId, name: "recommendedActionId", parent: name, pattern: "^[0-9A-Za-z]{16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case recommendedActionId = "recommendedActionId"
        }
    }

    public struct StartAutomationEventResponse: AWSDecodableShape {
        /// The ID of the automation event.
        public let eventId: String?
        /// The current status of the automation event.
        public let eventStatus: EventStatus?
        /// The ID of the recommended action being automated.
        public let recommendedActionId: String?

        @inlinable
        public init(eventId: String? = nil, eventStatus: EventStatus? = nil, recommendedActionId: String? = nil) {
            self.eventId = eventId
            self.eventStatus = eventStatus
            self.recommendedActionId = recommendedActionId
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case eventStatus = "eventStatus"
            case recommendedActionId = "recommendedActionId"
        }
    }

    public struct StringCriteriaCondition: AWSEncodableShape & AWSDecodableShape {
        /// The comparison operator used to evaluate the string criteria, such as equals, not equals, or contains.
        public let comparison: ComparisonOperator?
        /// List of string values to compare against when applying the criteria condition.
        public let values: [String]?

        @inlinable
        public init(comparison: ComparisonOperator? = nil, values: [String]? = nil) {
            self.comparison = comparison
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 512)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@\\*\\?]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case values = "values"
        }
    }

    public struct SummaryDimension: AWSDecodableShape {
        /// The dimension key used for categorizing summary data.
        public let key: SummaryDimensionKey
        /// The specific value for this dimension key used in the summary grouping.
        public let value: String

        @inlinable
        public init(key: SummaryDimensionKey, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct SummaryTotals: AWSDecodableShape {
        /// The total number of automation events in this summary group.
        public let automationEventCount: Int?
        public let estimatedMonthlySavings: EstimatedMonthlySavings?

        @inlinable
        public init(automationEventCount: Int? = nil, estimatedMonthlySavings: EstimatedMonthlySavings? = nil) {
            self.automationEventCount = automationEventCount
            self.estimatedMonthlySavings = estimatedMonthlySavings
        }

        private enum CodingKeys: String, CodingKey {
            case automationEventCount = "automationEventCount"
            case estimatedMonthlySavings = "estimatedMonthlySavings"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key, which can be up to 128 characters long.
        public let key: String
        /// The tag value, which can be up to 256 characters long.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\w\\s\\.\\-\\:\\/\\=\\+\\@]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let clientToken: String?
        ///  The ARN of the resource to tag.
        public let resourceArn: String
        /// The revision number of the automation rule to tag. This ensures you're tagging the correct version of the rule.
        public let ruleRevision: Int64
        ///  The tags to add to the resource.
        public let tags: [Tag]

        @inlinable
        public init(clientToken: String? = TagResourceRequest.idempotencyToken(), resourceArn: String, ruleRevision: Int64, tags: [Tag]) {
            self.clientToken = clientToken
            self.resourceArn = resourceArn
            self.ruleRevision = ruleRevision
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:compute-optimizer::[0-9]{12}:automation-rule/[a-zA-Z0-9_-]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceArn = "resourceArn"
            case ruleRevision = "ruleRevision"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimePeriod: AWSDecodableShape {
        /// The end time of the period, exclusive. Events before this time are included.
        public let endTimeExclusive: Date?
        /// The start time of the period, inclusive. Events at or after this time are included.
        public let startTimeInclusive: Date?

        @inlinable
        public init(endTimeExclusive: Date? = nil, startTimeInclusive: Date? = nil) {
            self.endTimeExclusive = endTimeExclusive
            self.startTimeInclusive = startTimeInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeExclusive = "endTimeExclusive"
            case startTimeInclusive = "startTimeInclusive"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let clientToken: String?
        ///  The ARN of the resource to untag.
        public let resourceArn: String
        /// The revision number of the automation rule to untag. This ensures you're untagging the correct version of the rule.
        public let ruleRevision: Int64
        ///  The keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(clientToken: String? = UntagResourceRequest.idempotencyToken(), resourceArn: String, ruleRevision: Int64, tagKeys: [String]) {
            self.clientToken = clientToken
            self.resourceArn = resourceArn
            self.ruleRevision = ruleRevision
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:compute-optimizer::[0-9]{12}:automation-rule/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceArn = "resourceArn"
            case ruleRevision = "ruleRevision"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAutomationRuleRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let clientToken: String?
        public let criteria: Criteria?
        /// The updated description of the automation rule. Can be up to 1024 characters long and contain alphanumeric characters, underscores, hyphens, spaces, and certain special characters.
        public let description: String?
        /// The updated name of the automation rule. Must be 1-128 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let name: String?
        /// Updated configuration settings for organization-wide rules, including rule application order and target account IDs.
        public let organizationConfiguration: OrganizationConfiguration?
        /// The updated priority level of the automation rule, used to determine execution order when multiple rules apply to the same resource.
        public let priority: String?
        /// Updated list of recommended action types that this rule can execute, such as SnapshotAndDeleteUnattachedEbsVolume or UpgradeEbsVolumeType.
        public let recommendedActionTypes: [RecommendedActionType]?
        ///  The ARN of the rule to update.
        public let ruleArn: String
        ///  The revision number of the rule to update.
        public let ruleRevision: Int64
        /// The updated type of automation rule. Can be either OrganizationRule for organization-wide rules or AccountRule for account-specific rules.
        public let ruleType: RuleType?
        /// The updated schedule configuration for when the automation rule should execute, including cron expression, timezone, and execution window.
        public let schedule: Schedule?
        /// The updated status of the automation rule. Can be Active or Inactive.
        public let status: RuleStatus?

        @inlinable
        public init(clientToken: String? = UpdateAutomationRuleRequest.idempotencyToken(), criteria: Criteria? = nil, description: String? = nil, name: String? = nil, organizationConfiguration: OrganizationConfiguration? = nil, priority: String? = nil, recommendedActionTypes: [RecommendedActionType]? = nil, ruleArn: String, ruleRevision: Int64, ruleType: RuleType? = nil, schedule: Schedule? = nil, status: RuleStatus? = nil) {
            self.clientToken = clientToken
            self.criteria = criteria
            self.description = description
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleArn = ruleArn
            self.ruleRevision = ruleRevision
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
            try self.criteria?.validate(name: "\(name).criteria")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9_\\-\\s@\\.]*$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]*$")
            try self.organizationConfiguration?.validate(name: "\(name).organizationConfiguration")
            try self.validate(self.ruleArn, name: "ruleArn", parent: name, pattern: "^arn:aws:compute-optimizer::[0-9]{12}:automation-rule/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case criteria = "criteria"
            case description = "description"
            case name = "name"
            case organizationConfiguration = "organizationConfiguration"
            case priority = "priority"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleArn = "ruleArn"
            case ruleRevision = "ruleRevision"
            case ruleType = "ruleType"
            case schedule = "schedule"
            case status = "status"
        }
    }

    public struct UpdateAutomationRuleResponse: AWSDecodableShape {
        /// The timestamp when the automation rule was originally created.
        public let createdTimestamp: Date?
        public let criteria: Criteria?
        /// The updated description of the automation rule.
        public let description: String?
        /// The timestamp when the automation rule was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The updated name of the automation rule.
        public let name: String?
        /// The updated organization configuration settings.
        public let organizationConfiguration: OrganizationConfiguration?
        /// The updated priority level of the automation rule.
        public let priority: String?
        /// The updated list of recommended action types.
        public let recommendedActionTypes: [RecommendedActionType]?
        ///  The ARN of the updated rule.
        public let ruleArn: String?
        ///  The new revision number of the updated rule.
        public let ruleRevision: Int64?
        /// The updated type of automation rule.
        public let ruleType: RuleType?
        /// The updated schedule configuration.
        public let schedule: Schedule?
        /// The updated status of the automation rule.
        public let status: RuleStatus?

        @inlinable
        public init(createdTimestamp: Date? = nil, criteria: Criteria? = nil, description: String? = nil, lastUpdatedTimestamp: Date? = nil, name: String? = nil, organizationConfiguration: OrganizationConfiguration? = nil, priority: String? = nil, recommendedActionTypes: [RecommendedActionType]? = nil, ruleArn: String? = nil, ruleRevision: Int64? = nil, ruleType: RuleType? = nil, schedule: Schedule? = nil, status: RuleStatus? = nil) {
            self.createdTimestamp = createdTimestamp
            self.criteria = criteria
            self.description = description
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleArn = ruleArn
            self.ruleRevision = ruleRevision
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case criteria = "criteria"
            case description = "description"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case name = "name"
            case organizationConfiguration = "organizationConfiguration"
            case priority = "priority"
            case recommendedActionTypes = "recommendedActionTypes"
            case ruleArn = "ruleArn"
            case ruleRevision = "ruleRevision"
            case ruleType = "ruleType"
            case schedule = "schedule"
            case status = "status"
        }
    }

    public struct UpdateEnrollmentConfigurationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
        public let clientToken: String?
        /// The desired enrollment status.    Active - Enables the Automation feature for your account.   Inactive - Disables the Automation feature for your account and stops all of your automation rules. If you opt in again later, all rules will be inactive, and you must enable the rules you want to run. You must wait at least 24 hours after opting out to opt in again.    The Pending and Failed options cannot be used to update the enrollment status of an account. They are returned in the response of a request to update the enrollment status of an account. If you are a member account, your account must be disassociated from your organizations management account before you can disable Automation. Contact your administrator to make this change.
        public let status: EnrollmentStatus

        @inlinable
        public init(clientToken: String? = UpdateEnrollmentConfigurationRequest.idempotencyToken(), status: EnrollmentStatus) {
            self.clientToken = clientToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_-]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case status = "status"
        }
    }

    public struct UpdateEnrollmentConfigurationResponse: AWSDecodableShape {
        ///  The timestamp when the enrollment configuration was last updated.
        public let lastUpdatedTimestamp: Date
        ///  The updated enrollment status.
        public let status: EnrollmentStatus
        ///  The reason for the updated enrollment status.
        public let statusReason: String?

        @inlinable
        public init(lastUpdatedTimestamp: Date, status: EnrollmentStatus, statusReason: String? = nil) {
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// Detailed configuration information specific to EBS volumes, including volume type, size, IOPS, and throughput settings.
        public let ebsVolume: EbsVolume?

        @inlinable
        public init(ebsVolume: EbsVolume? = nil) {
            self.ebsVolume = ebsVolume
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolume = "ebsVolume"
        }
    }
}

// MARK: - Errors

/// Error enum for ComputeOptimizerAutomation
public struct ComputeOptimizerAutomationErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case forbiddenException = "ForbiddenException"
        case idempotencyTokenInUseException = "IdempotencyTokenInUseException"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case internalServerException = "InternalServerException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case notManagementAccountException = "NotManagementAccountException"
        case optInRequiredException = "OptInRequiredException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ComputeOptimizerAutomation
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  You do not have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  You are not authorized to perform this action.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    ///  The specified client token is already in use.
    public static var idempotencyTokenInUseException: Self { .init(.idempotencyTokenInUseException) }
    /// Exception thrown when the same client token is used with different parameters, indicating a mismatch in idempotent request parameters.
    public static var idempotentParameterMismatchException: Self { .init(.idempotentParameterMismatchException) }
    ///  An internal error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  One or more parameter values are not valid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    ///  The operation can only be performed by a management account.
    public static var notManagementAccountException: Self { .init(.notManagementAccountException) }
    ///  The account must be opted in to Compute Optimizer Automation before performing this action.
    public static var optInRequiredException: Self { .init(.optInRequiredException) }
    ///  The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The request would exceed service quotas.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  The service is temporarily unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    ///  The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
}

extension ComputeOptimizerAutomationErrorType: Equatable {
    public static func == (lhs: ComputeOptimizerAutomationErrorType, rhs: ComputeOptimizerAutomationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ComputeOptimizerAutomationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
