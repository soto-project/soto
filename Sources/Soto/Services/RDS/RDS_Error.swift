//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

/// Error enum for RDS
public struct RDSErrorType: AWSErrorType {
    enum Code: String {
        case authorizationAlreadyExistsFault = "AuthorizationAlreadyExists"
        case authorizationNotFoundFault = "AuthorizationNotFound"
        case authorizationQuotaExceededFault = "AuthorizationQuotaExceeded"
        case backupPolicyNotFoundFault = "BackupPolicyNotFoundFault"
        case certificateNotFoundFault = "CertificateNotFound"
        case customAvailabilityZoneAlreadyExistsFault = "CustomAvailabilityZoneAlreadyExists"
        case customAvailabilityZoneNotFoundFault = "CustomAvailabilityZoneNotFound"
        case customAvailabilityZoneQuotaExceededFault = "CustomAvailabilityZoneQuotaExceeded"
        case customDBEngineVersionAlreadyExistsFault = "CustomDBEngineVersionAlreadyExistsFault"
        case customDBEngineVersionNotFoundFault = "CustomDBEngineVersionNotFoundFault"
        case customDBEngineVersionQuotaExceededFault = "CustomDBEngineVersionQuotaExceededFault"
        case dbClusterAlreadyExistsFault = "DBClusterAlreadyExistsFault"
        case dbClusterBacktrackNotFoundFault = "DBClusterBacktrackNotFoundFault"
        case dbClusterEndpointAlreadyExistsFault = "DBClusterEndpointAlreadyExistsFault"
        case dbClusterEndpointNotFoundFault = "DBClusterEndpointNotFoundFault"
        case dbClusterEndpointQuotaExceededFault = "DBClusterEndpointQuotaExceededFault"
        case dbClusterNotFoundFault = "DBClusterNotFoundFault"
        case dbClusterParameterGroupNotFoundFault = "DBClusterParameterGroupNotFound"
        case dbClusterQuotaExceededFault = "DBClusterQuotaExceededFault"
        case dbClusterRoleAlreadyExistsFault = "DBClusterRoleAlreadyExists"
        case dbClusterRoleNotFoundFault = "DBClusterRoleNotFound"
        case dbClusterRoleQuotaExceededFault = "DBClusterRoleQuotaExceeded"
        case dbClusterSnapshotAlreadyExistsFault = "DBClusterSnapshotAlreadyExistsFault"
        case dbClusterSnapshotNotFoundFault = "DBClusterSnapshotNotFoundFault"
        case dbInstanceAlreadyExistsFault = "DBInstanceAlreadyExists"
        case dbInstanceAutomatedBackupNotFoundFault = "DBInstanceAutomatedBackupNotFound"
        case dbInstanceAutomatedBackupQuotaExceededFault = "DBInstanceAutomatedBackupQuotaExceeded"
        case dbInstanceNotFoundFault = "DBInstanceNotFound"
        case dbInstanceRoleAlreadyExistsFault = "DBInstanceRoleAlreadyExists"
        case dbInstanceRoleNotFoundFault = "DBInstanceRoleNotFound"
        case dbInstanceRoleQuotaExceededFault = "DBInstanceRoleQuotaExceeded"
        case dbLogFileNotFoundFault = "DBLogFileNotFoundFault"
        case dbParameterGroupAlreadyExistsFault = "DBParameterGroupAlreadyExists"
        case dbParameterGroupNotFoundFault = "DBParameterGroupNotFound"
        case dbParameterGroupQuotaExceededFault = "DBParameterGroupQuotaExceeded"
        case dbProxyAlreadyExistsFault = "DBProxyAlreadyExistsFault"
        case dbProxyEndpointAlreadyExistsFault = "DBProxyEndpointAlreadyExistsFault"
        case dbProxyEndpointNotFoundFault = "DBProxyEndpointNotFoundFault"
        case dbProxyEndpointQuotaExceededFault = "DBProxyEndpointQuotaExceededFault"
        case dbProxyNotFoundFault = "DBProxyNotFoundFault"
        case dbProxyQuotaExceededFault = "DBProxyQuotaExceededFault"
        case dbProxyTargetAlreadyRegisteredFault = "DBProxyTargetAlreadyRegisteredFault"
        case dbProxyTargetGroupNotFoundFault = "DBProxyTargetGroupNotFoundFault"
        case dbProxyTargetNotFoundFault = "DBProxyTargetNotFoundFault"
        case dbSecurityGroupAlreadyExistsFault = "DBSecurityGroupAlreadyExists"
        case dbSecurityGroupNotFoundFault = "DBSecurityGroupNotFound"
        case dbSecurityGroupNotSupportedFault = "DBSecurityGroupNotSupported"
        case dbSecurityGroupQuotaExceededFault = "QuotaExceeded.DBSecurityGroup"
        case dbSnapshotAlreadyExistsFault = "DBSnapshotAlreadyExists"
        case dbSnapshotNotFoundFault = "DBSnapshotNotFound"
        case dbSubnetGroupAlreadyExistsFault = "DBSubnetGroupAlreadyExists"
        case dbSubnetGroupDoesNotCoverEnoughAZs = "DBSubnetGroupDoesNotCoverEnoughAZs"
        case dbSubnetGroupNotAllowedFault = "DBSubnetGroupNotAllowedFault"
        case dbSubnetGroupNotFoundFault = "DBSubnetGroupNotFoundFault"
        case dbSubnetGroupQuotaExceededFault = "DBSubnetGroupQuotaExceeded"
        case dbSubnetQuotaExceededFault = "DBSubnetQuotaExceededFault"
        case dbUpgradeDependencyFailureFault = "DBUpgradeDependencyFailure"
        case domainNotFoundFault = "DomainNotFoundFault"
        case eventSubscriptionQuotaExceededFault = "EventSubscriptionQuotaExceeded"
        case exportTaskAlreadyExistsFault = "ExportTaskAlreadyExists"
        case exportTaskNotFoundFault = "ExportTaskNotFound"
        case globalClusterAlreadyExistsFault = "GlobalClusterAlreadyExistsFault"
        case globalClusterNotFoundFault = "GlobalClusterNotFoundFault"
        case globalClusterQuotaExceededFault = "GlobalClusterQuotaExceededFault"
        case iamRoleMissingPermissionsFault = "IamRoleMissingPermissions"
        case iamRoleNotFoundFault = "IamRoleNotFound"
        case installationMediaAlreadyExistsFault = "InstallationMediaAlreadyExists"
        case installationMediaNotFoundFault = "InstallationMediaNotFound"
        case instanceQuotaExceededFault = "InstanceQuotaExceeded"
        case insufficientAvailableIPsInSubnetFault = "InsufficientAvailableIPsInSubnetFault"
        case insufficientDBClusterCapacityFault = "InsufficientDBClusterCapacityFault"
        case insufficientDBInstanceCapacityFault = "InsufficientDBInstanceCapacity"
        case insufficientStorageClusterCapacityFault = "InsufficientStorageClusterCapacity"
        case invalidCustomDBEngineVersionStateFault = "InvalidCustomDBEngineVersionStateFault"
        case invalidDBClusterCapacityFault = "InvalidDBClusterCapacityFault"
        case invalidDBClusterEndpointStateFault = "InvalidDBClusterEndpointStateFault"
        case invalidDBClusterSnapshotStateFault = "InvalidDBClusterSnapshotStateFault"
        case invalidDBClusterStateFault = "InvalidDBClusterStateFault"
        case invalidDBInstanceAutomatedBackupStateFault = "InvalidDBInstanceAutomatedBackupState"
        case invalidDBInstanceStateFault = "InvalidDBInstanceState"
        case invalidDBParameterGroupStateFault = "InvalidDBParameterGroupState"
        case invalidDBProxyEndpointStateFault = "InvalidDBProxyEndpointStateFault"
        case invalidDBProxyStateFault = "InvalidDBProxyStateFault"
        case invalidDBSecurityGroupStateFault = "InvalidDBSecurityGroupState"
        case invalidDBSnapshotStateFault = "InvalidDBSnapshotState"
        case invalidDBSubnetGroupFault = "InvalidDBSubnetGroupFault"
        case invalidDBSubnetGroupStateFault = "InvalidDBSubnetGroupStateFault"
        case invalidDBSubnetStateFault = "InvalidDBSubnetStateFault"
        case invalidEventSubscriptionStateFault = "InvalidEventSubscriptionState"
        case invalidExportOnlyFault = "InvalidExportOnly"
        case invalidExportSourceStateFault = "InvalidExportSourceState"
        case invalidExportTaskStateFault = "InvalidExportTaskStateFault"
        case invalidGlobalClusterStateFault = "InvalidGlobalClusterStateFault"
        case invalidOptionGroupStateFault = "InvalidOptionGroupStateFault"
        case invalidRestoreFault = "InvalidRestoreFault"
        case invalidS3BucketFault = "InvalidS3BucketFault"
        case invalidSubnet = "InvalidSubnet"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case kmsKeyNotAccessibleFault = "KMSKeyNotAccessibleFault"
        case optionGroupAlreadyExistsFault = "OptionGroupAlreadyExistsFault"
        case optionGroupNotFoundFault = "OptionGroupNotFoundFault"
        case optionGroupQuotaExceededFault = "OptionGroupQuotaExceededFault"
        case pointInTimeRestoreNotEnabledFault = "PointInTimeRestoreNotEnabled"
        case provisionedIopsNotAvailableInAZFault = "ProvisionedIopsNotAvailableInAZFault"
        case reservedDBInstanceAlreadyExistsFault = "ReservedDBInstanceAlreadyExists"
        case reservedDBInstanceNotFoundFault = "ReservedDBInstanceNotFound"
        case reservedDBInstanceQuotaExceededFault = "ReservedDBInstanceQuotaExceeded"
        case reservedDBInstancesOfferingNotFoundFault = "ReservedDBInstancesOfferingNotFound"
        case resourceNotFoundFault = "ResourceNotFoundFault"
        case sharedSnapshotQuotaExceededFault = "SharedSnapshotQuotaExceeded"
        case snapshotQuotaExceededFault = "SnapshotQuotaExceeded"
        case snsInvalidTopicFault = "SNSInvalidTopic"
        case snsNoAuthorizationFault = "SNSNoAuthorization"
        case snsTopicArnNotFoundFault = "SNSTopicArnNotFound"
        case sourceNotFoundFault = "SourceNotFound"
        case storageQuotaExceededFault = "StorageQuotaExceeded"
        case storageTypeNotSupportedFault = "StorageTypeNotSupported"
        case subnetAlreadyInUse = "SubnetAlreadyInUse"
        case subscriptionAlreadyExistFault = "SubscriptionAlreadyExist"
        case subscriptionCategoryNotFoundFault = "SubscriptionCategoryNotFound"
        case subscriptionNotFoundFault = "SubscriptionNotFound"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RDS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified CIDR IP range or Amazon EC2 security group is already authorized for the specified DB security group.
    public static var authorizationAlreadyExistsFault: Self { .init(.authorizationAlreadyExistsFault) }
    /// The specified CIDR IP range or Amazon EC2 security group might not be authorized for the specified DB security group. Or, RDS might not be authorized to perform necessary actions using IAM on your behalf.
    public static var authorizationNotFoundFault: Self { .init(.authorizationNotFoundFault) }
    /// The DB security group authorization quota has been reached.
    public static var authorizationQuotaExceededFault: Self { .init(.authorizationQuotaExceededFault) }
    public static var backupPolicyNotFoundFault: Self { .init(.backupPolicyNotFoundFault) }
    ///  CertificateIdentifier doesn't refer to an existing certificate.
    public static var certificateNotFoundFault: Self { .init(.certificateNotFoundFault) }
    ///  CustomAvailabilityZoneName is already used by an existing custom Availability Zone.
    public static var customAvailabilityZoneAlreadyExistsFault: Self { .init(.customAvailabilityZoneAlreadyExistsFault) }
    ///  CustomAvailabilityZoneId doesn't refer to an existing custom Availability Zone identifier.
    public static var customAvailabilityZoneNotFoundFault: Self { .init(.customAvailabilityZoneNotFoundFault) }
    /// You have exceeded the maximum number of custom Availability Zones.
    public static var customAvailabilityZoneQuotaExceededFault: Self { .init(.customAvailabilityZoneQuotaExceededFault) }
    /// A CEV with the specified name already exists.
    public static var customDBEngineVersionAlreadyExistsFault: Self { .init(.customDBEngineVersionAlreadyExistsFault) }
    /// The specified CEV was not found.
    public static var customDBEngineVersionNotFoundFault: Self { .init(.customDBEngineVersionNotFoundFault) }
    /// You have exceeded your CEV quota.
    public static var customDBEngineVersionQuotaExceededFault: Self { .init(.customDBEngineVersionQuotaExceededFault) }
    /// The user already has a DB cluster with the given identifier.
    public static var dbClusterAlreadyExistsFault: Self { .init(.dbClusterAlreadyExistsFault) }
    ///  BacktrackIdentifier doesn't refer to an existing backtrack.
    public static var dbClusterBacktrackNotFoundFault: Self { .init(.dbClusterBacktrackNotFoundFault) }
    /// The specified custom endpoint can't be created because it already exists.
    public static var dbClusterEndpointAlreadyExistsFault: Self { .init(.dbClusterEndpointAlreadyExistsFault) }
    /// The specified custom endpoint doesn't exist.
    public static var dbClusterEndpointNotFoundFault: Self { .init(.dbClusterEndpointNotFoundFault) }
    /// The cluster already has the maximum number of custom endpoints.
    public static var dbClusterEndpointQuotaExceededFault: Self { .init(.dbClusterEndpointQuotaExceededFault) }
    ///  DBClusterIdentifier doesn't refer to an existing DB cluster.
    public static var dbClusterNotFoundFault: Self { .init(.dbClusterNotFoundFault) }
    ///  DBClusterParameterGroupName doesn't refer to an existing DB cluster parameter group.
    public static var dbClusterParameterGroupNotFoundFault: Self { .init(.dbClusterParameterGroupNotFoundFault) }
    /// The user attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.
    public static var dbClusterQuotaExceededFault: Self { .init(.dbClusterQuotaExceededFault) }
    /// The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.
    public static var dbClusterRoleAlreadyExistsFault: Self { .init(.dbClusterRoleAlreadyExistsFault) }
    /// The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.
    public static var dbClusterRoleNotFoundFault: Self { .init(.dbClusterRoleNotFoundFault) }
    /// You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.
    public static var dbClusterRoleQuotaExceededFault: Self { .init(.dbClusterRoleQuotaExceededFault) }
    /// The user already has a DB cluster snapshot with the given identifier.
    public static var dbClusterSnapshotAlreadyExistsFault: Self { .init(.dbClusterSnapshotAlreadyExistsFault) }
    ///  DBClusterSnapshotIdentifier doesn't refer to an existing DB cluster snapshot.
    public static var dbClusterSnapshotNotFoundFault: Self { .init(.dbClusterSnapshotNotFoundFault) }
    /// The user already has a DB instance with the given identifier.
    public static var dbInstanceAlreadyExistsFault: Self { .init(.dbInstanceAlreadyExistsFault) }
    /// No automated backup for this DB instance was found.
    public static var dbInstanceAutomatedBackupNotFoundFault: Self { .init(.dbInstanceAutomatedBackupNotFoundFault) }
    /// The quota for retained automated backups was exceeded. This prevents you from retaining any additional automated backups. The retained automated backups  quota is the same as your DB Instance quota.
    public static var dbInstanceAutomatedBackupQuotaExceededFault: Self { .init(.dbInstanceAutomatedBackupQuotaExceededFault) }
    ///  DBInstanceIdentifier doesn't refer to an existing DB instance.
    public static var dbInstanceNotFoundFault: Self { .init(.dbInstanceNotFoundFault) }
    /// The specified RoleArn or FeatureName value is already associated with the DB instance.
    public static var dbInstanceRoleAlreadyExistsFault: Self { .init(.dbInstanceRoleAlreadyExistsFault) }
    /// The specified RoleArn value doesn't match the specified feature for the DB instance.
    public static var dbInstanceRoleNotFoundFault: Self { .init(.dbInstanceRoleNotFoundFault) }
    /// You can't associate any more Amazon Web Services Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.
    public static var dbInstanceRoleQuotaExceededFault: Self { .init(.dbInstanceRoleQuotaExceededFault) }
    ///  LogFileName doesn't refer to an existing DB log file.
    public static var dbLogFileNotFoundFault: Self { .init(.dbLogFileNotFoundFault) }
    /// A DB parameter group with the same name exists.
    public static var dbParameterGroupAlreadyExistsFault: Self { .init(.dbParameterGroupAlreadyExistsFault) }
    ///  DBParameterGroupName doesn't refer to an existing DB parameter group.
    public static var dbParameterGroupNotFoundFault: Self { .init(.dbParameterGroupNotFoundFault) }
    /// The request would result in the user exceeding the allowed number of DB parameter groups.
    public static var dbParameterGroupQuotaExceededFault: Self { .init(.dbParameterGroupQuotaExceededFault) }
    /// The specified proxy name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyAlreadyExistsFault: Self { .init(.dbProxyAlreadyExistsFault) }
    /// The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyEndpointAlreadyExistsFault: Self { .init(.dbProxyEndpointAlreadyExistsFault) }
    /// The DB proxy endpoint doesn't exist.
    public static var dbProxyEndpointNotFoundFault: Self { .init(.dbProxyEndpointNotFoundFault) }
    /// The DB proxy already has the maximum number of endpoints.
    public static var dbProxyEndpointQuotaExceededFault: Self { .init(.dbProxyEndpointQuotaExceededFault) }
    /// The specified proxy name doesn't correspond to a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyNotFoundFault: Self { .init(.dbProxyNotFoundFault) }
    /// Your Amazon Web Services account already has the maximum number of proxies in the specified Amazon Web Services Region.
    public static var dbProxyQuotaExceededFault: Self { .init(.dbProxyQuotaExceededFault) }
    /// The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.
    public static var dbProxyTargetAlreadyRegisteredFault: Self { .init(.dbProxyTargetAlreadyRegisteredFault) }
    /// The specified target group isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyTargetGroupNotFoundFault: Self { .init(.dbProxyTargetGroupNotFoundFault) }
    /// The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyTargetNotFoundFault: Self { .init(.dbProxyTargetNotFoundFault) }
    ///  A DB security group with the name specified in DBSecurityGroupName already exists.
    public static var dbSecurityGroupAlreadyExistsFault: Self { .init(.dbSecurityGroupAlreadyExistsFault) }
    ///  DBSecurityGroupName doesn't refer to an existing DB security group.
    public static var dbSecurityGroupNotFoundFault: Self { .init(.dbSecurityGroupNotFoundFault) }
    /// A DB security group isn't allowed for this action.
    public static var dbSecurityGroupNotSupportedFault: Self { .init(.dbSecurityGroupNotSupportedFault) }
    /// The request would result in the user exceeding the allowed number of DB security groups.
    public static var dbSecurityGroupQuotaExceededFault: Self { .init(.dbSecurityGroupQuotaExceededFault) }
    ///  DBSnapshotIdentifier is already used by an existing snapshot.
    public static var dbSnapshotAlreadyExistsFault: Self { .init(.dbSnapshotAlreadyExistsFault) }
    ///  DBSnapshotIdentifier doesn't refer to an existing DB snapshot.
    public static var dbSnapshotNotFoundFault: Self { .init(.dbSnapshotNotFoundFault) }
    ///  DBSubnetGroupName is already used by an existing DB subnet group.
    public static var dbSubnetGroupAlreadyExistsFault: Self { .init(.dbSubnetGroupAlreadyExistsFault) }
    /// Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.
    public static var dbSubnetGroupDoesNotCoverEnoughAZs: Self { .init(.dbSubnetGroupDoesNotCoverEnoughAZs) }
    /// The DBSubnetGroup shouldn't be specified while creating read replicas that lie in the same region as the source instance.
    public static var dbSubnetGroupNotAllowedFault: Self { .init(.dbSubnetGroupNotAllowedFault) }
    ///  DBSubnetGroupName doesn't refer to an existing DB subnet group.
    public static var dbSubnetGroupNotFoundFault: Self { .init(.dbSubnetGroupNotFoundFault) }
    /// The request would result in the user exceeding the allowed number of DB subnet groups.
    public static var dbSubnetGroupQuotaExceededFault: Self { .init(.dbSubnetGroupQuotaExceededFault) }
    /// The request would result in the user exceeding the allowed number of subnets in a DB subnet groups.
    public static var dbSubnetQuotaExceededFault: Self { .init(.dbSubnetQuotaExceededFault) }
    /// The DB upgrade failed because a resource the DB depends on can't be modified.
    public static var dbUpgradeDependencyFailureFault: Self { .init(.dbUpgradeDependencyFailureFault) }
    ///  Domain doesn't refer to an existing Active Directory domain.
    public static var domainNotFoundFault: Self { .init(.domainNotFoundFault) }
    /// You have reached the maximum number of event subscriptions.
    public static var eventSubscriptionQuotaExceededFault: Self { .init(.eventSubscriptionQuotaExceededFault) }
    /// You can't start an export task that's already running.
    public static var exportTaskAlreadyExistsFault: Self { .init(.exportTaskAlreadyExistsFault) }
    /// The export task doesn't exist.
    public static var exportTaskNotFoundFault: Self { .init(.exportTaskNotFoundFault) }
    /// The GlobalClusterIdentifier already exists. Choose a new global database identifier (unique name) to create a new global database cluster.
    public static var globalClusterAlreadyExistsFault: Self { .init(.globalClusterAlreadyExistsFault) }
    /// The GlobalClusterIdentifier doesn't refer to an existing global database cluster.
    public static var globalClusterNotFoundFault: Self { .init(.globalClusterNotFoundFault) }
    /// The number of global database clusters for this account is already at the maximum allowed.
    public static var globalClusterQuotaExceededFault: Self { .init(.globalClusterQuotaExceededFault) }
    /// The IAM role requires additional permissions to export to an Amazon S3 bucket.
    public static var iamRoleMissingPermissionsFault: Self { .init(.iamRoleMissingPermissionsFault) }
    /// The IAM role is missing for exporting to an Amazon S3 bucket.
    public static var iamRoleNotFoundFault: Self { .init(.iamRoleNotFoundFault) }
    /// The specified installation medium has already been imported.
    public static var installationMediaAlreadyExistsFault: Self { .init(.installationMediaAlreadyExistsFault) }
    ///  InstallationMediaID doesn't refer to an existing installation medium.
    public static var installationMediaNotFoundFault: Self { .init(.installationMediaNotFoundFault) }
    /// The request would result in the user exceeding the allowed number of DB instances.
    public static var instanceQuotaExceededFault: Self { .init(.instanceQuotaExceededFault) }
    /// The requested operation can't be performed because there aren't enough available IP addresses  in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required  from the subnets.
    public static var insufficientAvailableIPsInSubnetFault: Self { .init(.insufficientAvailableIPsInSubnetFault) }
    /// The DB cluster doesn't have enough capacity for the current operation.
    public static var insufficientDBClusterCapacityFault: Self { .init(.insufficientDBClusterCapacityFault) }
    /// The specified DB instance class isn't available in the specified Availability Zone.
    public static var insufficientDBInstanceCapacityFault: Self { .init(.insufficientDBInstanceCapacityFault) }
    /// There is insufficient storage available for the current action. You might be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.
    public static var insufficientStorageClusterCapacityFault: Self { .init(.insufficientStorageClusterCapacityFault) }
    /// You can't delete the CEV.
    public static var invalidCustomDBEngineVersionStateFault: Self { .init(.invalidCustomDBEngineVersionStateFault) }
    ///  Capacity isn't a valid Aurora Serverless DB cluster capacity. Valid capacity values are 2, 4, 8, 16,  32, 64, 128, and 256.
    public static var invalidDBClusterCapacityFault: Self { .init(.invalidDBClusterCapacityFault) }
    /// The requested operation can't be performed on the endpoint while the endpoint is in this state.
    public static var invalidDBClusterEndpointStateFault: Self { .init(.invalidDBClusterEndpointStateFault) }
    /// The supplied value isn't a valid DB cluster snapshot state.
    public static var invalidDBClusterSnapshotStateFault: Self { .init(.invalidDBClusterSnapshotStateFault) }
    /// The requested operation can't be performed while the cluster is in this state.
    public static var invalidDBClusterStateFault: Self { .init(.invalidDBClusterStateFault) }
    /// The automated backup is in an invalid state.  	    For example, this automated backup is associated with an active instance.
    public static var invalidDBInstanceAutomatedBackupStateFault: Self { .init(.invalidDBInstanceAutomatedBackupStateFault) }
    /// The DB instance isn't in a valid state.
    public static var invalidDBInstanceStateFault: Self { .init(.invalidDBInstanceStateFault) }
    /// The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you can't delete it when the parameter group is in this state.
    public static var invalidDBParameterGroupStateFault: Self { .init(.invalidDBParameterGroupStateFault) }
    /// You can't perform this operation while the DB proxy endpoint is in a particular state.
    public static var invalidDBProxyEndpointStateFault: Self { .init(.invalidDBProxyEndpointStateFault) }
    /// The requested operation can't be performed while the proxy is in this state.
    public static var invalidDBProxyStateFault: Self { .init(.invalidDBProxyStateFault) }
    /// The state of the DB security group doesn't allow deletion.
    public static var invalidDBSecurityGroupStateFault: Self { .init(.invalidDBSecurityGroupStateFault) }
    /// The state of the DB snapshot doesn't allow deletion.
    public static var invalidDBSnapshotStateFault: Self { .init(.invalidDBSnapshotStateFault) }
    /// The DBSubnetGroup doesn't belong to the same VPC as that of an existing cross-region read replica of the same source instance.
    public static var invalidDBSubnetGroupFault: Self { .init(.invalidDBSubnetGroupFault) }
    /// The DB subnet group cannot be deleted because it's in use.
    public static var invalidDBSubnetGroupStateFault: Self { .init(.invalidDBSubnetGroupStateFault) }
    ///  The DB subnet isn't in the available state.
    public static var invalidDBSubnetStateFault: Self { .init(.invalidDBSubnetStateFault) }
    /// This error can occur if someone else is modifying a subscription. You should retry the action.
    public static var invalidEventSubscriptionStateFault: Self { .init(.invalidEventSubscriptionStateFault) }
    /// The export is invalid for exporting to an Amazon S3 bucket.
    public static var invalidExportOnlyFault: Self { .init(.invalidExportOnlyFault) }
    /// The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.
    public static var invalidExportSourceStateFault: Self { .init(.invalidExportSourceStateFault) }
    /// You can't cancel an export task that has completed.
    public static var invalidExportTaskStateFault: Self { .init(.invalidExportTaskStateFault) }
    /// The global cluster is in an invalid state and can't perform the requested operation.
    public static var invalidGlobalClusterStateFault: Self { .init(.invalidGlobalClusterStateFault) }
    ///  The option group isn't in the available state.
    public static var invalidOptionGroupStateFault: Self { .init(.invalidOptionGroupStateFault) }
    /// Cannot restore from VPC backup to non-VPC DB instance.
    public static var invalidRestoreFault: Self { .init(.invalidRestoreFault) }
    /// The specified Amazon S3 bucket name can't be found or Amazon RDS isn't authorized to access the specified Amazon S3 bucket. Verify the SourceS3BucketName and S3IngestionRoleArn values and try again.
    public static var invalidS3BucketFault: Self { .init(.invalidS3BucketFault) }
    /// The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    /// The DB subnet group doesn't cover all Availability Zones after it's created because of users' change.
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    /// An error occurred accessing an Amazon Web Services KMS key.
    public static var kmsKeyNotAccessibleFault: Self { .init(.kmsKeyNotAccessibleFault) }
    /// The option group you are trying to create already exists.
    public static var optionGroupAlreadyExistsFault: Self { .init(.optionGroupAlreadyExistsFault) }
    /// The specified option group could not be found.
    public static var optionGroupNotFoundFault: Self { .init(.optionGroupNotFoundFault) }
    /// The quota of 20 option groups was exceeded for this Amazon Web Services account.
    public static var optionGroupQuotaExceededFault: Self { .init(.optionGroupQuotaExceededFault) }
    ///  SourceDBInstanceIdentifier refers to a DB instance with BackupRetentionPeriod equal to 0.
    public static var pointInTimeRestoreNotEnabledFault: Self { .init(.pointInTimeRestoreNotEnabledFault) }
    /// Provisioned IOPS not available in the specified Availability Zone.
    public static var provisionedIopsNotAvailableInAZFault: Self { .init(.provisionedIopsNotAvailableInAZFault) }
    /// User already has a reservation with the given identifier.
    public static var reservedDBInstanceAlreadyExistsFault: Self { .init(.reservedDBInstanceAlreadyExistsFault) }
    /// The specified reserved DB Instance not found.
    public static var reservedDBInstanceNotFoundFault: Self { .init(.reservedDBInstanceNotFoundFault) }
    /// Request would exceed the user's DB Instance quota.
    public static var reservedDBInstanceQuotaExceededFault: Self { .init(.reservedDBInstanceQuotaExceededFault) }
    /// Specified offering does not exist.
    public static var reservedDBInstancesOfferingNotFoundFault: Self { .init(.reservedDBInstancesOfferingNotFoundFault) }
    /// The specified resource ID was not found.
    public static var resourceNotFoundFault: Self { .init(.resourceNotFoundFault) }
    /// You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.
    public static var sharedSnapshotQuotaExceededFault: Self { .init(.sharedSnapshotQuotaExceededFault) }
    /// The request would result in the user exceeding the allowed number of DB snapshots.
    public static var snapshotQuotaExceededFault: Self { .init(.snapshotQuotaExceededFault) }
    /// SNS has responded that there is a problem with the SND topic specified.
    public static var snsInvalidTopicFault: Self { .init(.snsInvalidTopicFault) }
    /// You do not have permission to publish to the SNS topic ARN.
    public static var snsNoAuthorizationFault: Self { .init(.snsNoAuthorizationFault) }
    /// The SNS topic ARN does not exist.
    public static var snsTopicArnNotFoundFault: Self { .init(.snsTopicArnNotFoundFault) }
    /// The requested source could not be found.
    public static var sourceNotFoundFault: Self { .init(.sourceNotFoundFault) }
    /// The request would result in the user exceeding the allowed amount of storage available across all DB instances.
    public static var storageQuotaExceededFault: Self { .init(.storageQuotaExceededFault) }
    /// Storage of the StorageType specified can't be associated with the DB instance.
    public static var storageTypeNotSupportedFault: Self { .init(.storageTypeNotSupportedFault) }
    /// The DB subnet is already in use in the Availability Zone.
    public static var subnetAlreadyInUse: Self { .init(.subnetAlreadyInUse) }
    /// The supplied subscription name already exists.
    public static var subscriptionAlreadyExistFault: Self { .init(.subscriptionAlreadyExistFault) }
    /// The supplied category does not exist.
    public static var subscriptionCategoryNotFoundFault: Self { .init(.subscriptionCategoryNotFoundFault) }
    /// The subscription name does not exist.
    public static var subscriptionNotFoundFault: Self { .init(.subscriptionNotFoundFault) }
}

extension RDSErrorType: Equatable {
    public static func == (lhs: RDSErrorType, rhs: RDSErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RDSErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
