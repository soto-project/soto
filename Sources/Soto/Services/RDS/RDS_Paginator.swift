//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension RDS {
    ///  Lists the set of CA certificates provided by Amazon RDS for this Amazon Web Services account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCertificatesPaginator<Result>(
        _ input: DescribeCertificatesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CertificateMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCertificates,
            inputKey: \DescribeCertificatesMessage.marker,
            outputKey: \CertificateMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCertificatesPaginator(
        _ input: DescribeCertificatesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CertificateMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCertificates,
            inputKey: \DescribeCertificatesMessage.marker,
            outputKey: \CertificateMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about custom Availability Zones (AZs). A custom AZ is an on-premises AZ that is integrated with a VMware vSphere cluster. For more information about RDS on VMware, see the  RDS on VMware User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCustomAvailabilityZonesPaginator<Result>(
        _ input: DescribeCustomAvailabilityZonesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CustomAvailabilityZoneMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCustomAvailabilityZones,
            inputKey: \DescribeCustomAvailabilityZonesMessage.marker,
            outputKey: \CustomAvailabilityZoneMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCustomAvailabilityZonesPaginator(
        _ input: DescribeCustomAvailabilityZonesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CustomAvailabilityZoneMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCustomAvailabilityZones,
            inputKey: \DescribeCustomAvailabilityZonesMessage.marker,
            outputKey: \CustomAvailabilityZoneMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about backtracks for a DB cluster. For more information on Amazon Aurora, see  What Is Amazon Aurora? in the Amazon Aurora User Guide.   This action only applies to Aurora MySQL DB clusters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBClusterBacktracksPaginator<Result>(
        _ input: DescribeDBClusterBacktracksMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBClusterBacktrackMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBClusterBacktracks,
            inputKey: \DescribeDBClusterBacktracksMessage.marker,
            outputKey: \DBClusterBacktrackMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBClusterBacktracksPaginator(
        _ input: DescribeDBClusterBacktracksMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBClusterBacktrackMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBClusterBacktracks,
            inputKey: \DescribeDBClusterBacktracksMessage.marker,
            outputKey: \DBClusterBacktrackMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about endpoints for an Amazon Aurora DB cluster.  This action only applies to Aurora DB clusters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBClusterEndpointsPaginator<Result>(
        _ input: DescribeDBClusterEndpointsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBClusterEndpointMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBClusterEndpoints,
            inputKey: \DescribeDBClusterEndpointsMessage.marker,
            outputKey: \DBClusterEndpointMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBClusterEndpointsPaginator(
        _ input: DescribeDBClusterEndpointsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBClusterEndpointMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBClusterEndpoints,
            inputKey: \DescribeDBClusterEndpointsMessage.marker,
            outputKey: \DBClusterEndpointMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of DBClusterParameterGroup descriptions. If a DBClusterParameterGroupName parameter is specified, the list will contain only the description of the specified DB cluster parameter group.  For more information on Amazon Aurora, see  What Is Amazon Aurora? in the Amazon Aurora User Guide.   This action only applies to Aurora DB clusters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBClusterParameterGroupsPaginator<Result>(
        _ input: DescribeDBClusterParameterGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBClusterParameterGroupsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBClusterParameterGroups,
            inputKey: \DescribeDBClusterParameterGroupsMessage.marker,
            outputKey: \DBClusterParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBClusterParameterGroupsPaginator(
        _ input: DescribeDBClusterParameterGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBClusterParameterGroupsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBClusterParameterGroups,
            inputKey: \DescribeDBClusterParameterGroupsMessage.marker,
            outputKey: \DBClusterParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns the detailed parameter list for a particular DB cluster parameter group. For more information on Amazon Aurora, see  What Is Amazon Aurora? in the Amazon Aurora User Guide.   This action only applies to Aurora DB clusters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBClusterParametersPaginator<Result>(
        _ input: DescribeDBClusterParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBClusterParameterGroupDetails, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBClusterParameters,
            inputKey: \DescribeDBClusterParametersMessage.marker,
            outputKey: \DBClusterParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBClusterParametersPaginator(
        _ input: DescribeDBClusterParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBClusterParameterGroupDetails, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBClusterParameters,
            inputKey: \DescribeDBClusterParametersMessage.marker,
            outputKey: \DBClusterParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about DB cluster snapshots. This API action supports pagination. For more information on Amazon Aurora, see  What Is Amazon Aurora? in the Amazon Aurora User Guide.   This action only applies to Aurora DB clusters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBClusterSnapshotsPaginator<Result>(
        _ input: DescribeDBClusterSnapshotsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBClusterSnapshotMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBClusterSnapshots,
            inputKey: \DescribeDBClusterSnapshotsMessage.marker,
            outputKey: \DBClusterSnapshotMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBClusterSnapshotsPaginator(
        _ input: DescribeDBClusterSnapshotsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBClusterSnapshotMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBClusterSnapshots,
            inputKey: \DescribeDBClusterSnapshotsMessage.marker,
            outputKey: \DBClusterSnapshotMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about provisioned Aurora DB clusters. This API supports pagination. For more information on Amazon Aurora, see  What Is Amazon Aurora? in the Amazon Aurora User Guide.   This operation can also return information for Amazon Neptune DB instances and Amazon DocumentDB instances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBClustersPaginator<Result>(
        _ input: DescribeDBClustersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBClusterMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBClusters,
            inputKey: \DescribeDBClustersMessage.marker,
            outputKey: \DBClusterMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBClustersPaginator(
        _ input: DescribeDBClustersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBClusterMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBClusters,
            inputKey: \DescribeDBClustersMessage.marker,
            outputKey: \DBClusterMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of the available DB engines.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBEngineVersionsPaginator<Result>(
        _ input: DescribeDBEngineVersionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBEngineVersionMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBEngineVersions,
            inputKey: \DescribeDBEngineVersionsMessage.marker,
            outputKey: \DBEngineVersionMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBEngineVersionsPaginator(
        _ input: DescribeDBEngineVersionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBEngineVersionMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBEngineVersions,
            inputKey: \DescribeDBEngineVersionsMessage.marker,
            outputKey: \DBEngineVersionMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Displays backups for both current and deleted instances. For example, use this operation to find details about automated backups for previously deleted instances. Current instances with retention periods greater than zero (0) are returned for both the DescribeDBInstanceAutomatedBackups and DescribeDBInstances operations. All parameters are optional.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBInstanceAutomatedBackupsPaginator<Result>(
        _ input: DescribeDBInstanceAutomatedBackupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBInstanceAutomatedBackupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBInstanceAutomatedBackups,
            inputKey: \DescribeDBInstanceAutomatedBackupsMessage.marker,
            outputKey: \DBInstanceAutomatedBackupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBInstanceAutomatedBackupsPaginator(
        _ input: DescribeDBInstanceAutomatedBackupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBInstanceAutomatedBackupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBInstanceAutomatedBackups,
            inputKey: \DescribeDBInstanceAutomatedBackupsMessage.marker,
            outputKey: \DBInstanceAutomatedBackupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about provisioned RDS instances. This API supports pagination.  This operation can also return information for Amazon Neptune DB instances and Amazon DocumentDB instances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBInstancesPaginator<Result>(
        _ input: DescribeDBInstancesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBInstanceMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBInstances,
            inputKey: \DescribeDBInstancesMessage.marker,
            outputKey: \DBInstanceMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBInstancesPaginator(
        _ input: DescribeDBInstancesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBInstanceMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBInstances,
            inputKey: \DescribeDBInstancesMessage.marker,
            outputKey: \DBInstanceMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of DB log files for the DB instance.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBLogFilesPaginator<Result>(
        _ input: DescribeDBLogFilesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDBLogFilesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBLogFiles,
            inputKey: \DescribeDBLogFilesMessage.marker,
            outputKey: \DescribeDBLogFilesResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBLogFilesPaginator(
        _ input: DescribeDBLogFilesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDBLogFilesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBLogFiles,
            inputKey: \DescribeDBLogFilesMessage.marker,
            outputKey: \DescribeDBLogFilesResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of DBParameterGroup descriptions. If a DBParameterGroupName is specified, the list will contain only the description of the specified DB parameter group.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBParameterGroupsPaginator<Result>(
        _ input: DescribeDBParameterGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBParameterGroupsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBParameterGroups,
            inputKey: \DescribeDBParameterGroupsMessage.marker,
            outputKey: \DBParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBParameterGroupsPaginator(
        _ input: DescribeDBParameterGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBParameterGroupsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBParameterGroups,
            inputKey: \DescribeDBParameterGroupsMessage.marker,
            outputKey: \DBParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns the detailed parameter list for a particular DB parameter group.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBParametersPaginator<Result>(
        _ input: DescribeDBParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBParameterGroupDetails, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBParameters,
            inputKey: \DescribeDBParametersMessage.marker,
            outputKey: \DBParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBParametersPaginator(
        _ input: DescribeDBParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBParameterGroupDetails, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBParameters,
            inputKey: \DescribeDBParametersMessage.marker,
            outputKey: \DBParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about DB proxies.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBProxiesPaginator<Result>(
        _ input: DescribeDBProxiesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDBProxiesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBProxies,
            inputKey: \DescribeDBProxiesRequest.marker,
            outputKey: \DescribeDBProxiesResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBProxiesPaginator(
        _ input: DescribeDBProxiesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDBProxiesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBProxies,
            inputKey: \DescribeDBProxiesRequest.marker,
            outputKey: \DescribeDBProxiesResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about DB proxy endpoints.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBProxyEndpointsPaginator<Result>(
        _ input: DescribeDBProxyEndpointsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDBProxyEndpointsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBProxyEndpoints,
            inputKey: \DescribeDBProxyEndpointsRequest.marker,
            outputKey: \DescribeDBProxyEndpointsResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBProxyEndpointsPaginator(
        _ input: DescribeDBProxyEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDBProxyEndpointsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBProxyEndpoints,
            inputKey: \DescribeDBProxyEndpointsRequest.marker,
            outputKey: \DescribeDBProxyEndpointsResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about DB proxy target groups, represented by DBProxyTargetGroup data structures.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBProxyTargetGroupsPaginator<Result>(
        _ input: DescribeDBProxyTargetGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDBProxyTargetGroupsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBProxyTargetGroups,
            inputKey: \DescribeDBProxyTargetGroupsRequest.marker,
            outputKey: \DescribeDBProxyTargetGroupsResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBProxyTargetGroupsPaginator(
        _ input: DescribeDBProxyTargetGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDBProxyTargetGroupsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBProxyTargetGroups,
            inputKey: \DescribeDBProxyTargetGroupsRequest.marker,
            outputKey: \DescribeDBProxyTargetGroupsResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about DBProxyTarget objects. This API supports pagination.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBProxyTargetsPaginator<Result>(
        _ input: DescribeDBProxyTargetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDBProxyTargetsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBProxyTargets,
            inputKey: \DescribeDBProxyTargetsRequest.marker,
            outputKey: \DescribeDBProxyTargetsResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBProxyTargetsPaginator(
        _ input: DescribeDBProxyTargetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDBProxyTargetsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBProxyTargets,
            inputKey: \DescribeDBProxyTargetsRequest.marker,
            outputKey: \DescribeDBProxyTargetsResponse.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns a list of DBSecurityGroup descriptions. If a DBSecurityGroupName is specified, the list will contain only the descriptions of the specified DB security group.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBSecurityGroupsPaginator<Result>(
        _ input: DescribeDBSecurityGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBSecurityGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBSecurityGroups,
            inputKey: \DescribeDBSecurityGroupsMessage.marker,
            outputKey: \DBSecurityGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBSecurityGroupsPaginator(
        _ input: DescribeDBSecurityGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBSecurityGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBSecurityGroups,
            inputKey: \DescribeDBSecurityGroupsMessage.marker,
            outputKey: \DBSecurityGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about DB snapshots. This API action supports pagination.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBSnapshotsPaginator<Result>(
        _ input: DescribeDBSnapshotsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBSnapshotMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBSnapshots,
            inputKey: \DescribeDBSnapshotsMessage.marker,
            outputKey: \DBSnapshotMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBSnapshotsPaginator(
        _ input: DescribeDBSnapshotsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBSnapshotMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBSnapshots,
            inputKey: \DescribeDBSnapshotsMessage.marker,
            outputKey: \DBSnapshotMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of DBSubnetGroup descriptions. If a DBSubnetGroupName is specified, the list will contain only the descriptions of the specified DBSubnetGroup. For an overview of CIDR ranges, go to the Wikipedia Tutorial.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDBSubnetGroupsPaginator<Result>(
        _ input: DescribeDBSubnetGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DBSubnetGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDBSubnetGroups,
            inputKey: \DescribeDBSubnetGroupsMessage.marker,
            outputKey: \DBSubnetGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDBSubnetGroupsPaginator(
        _ input: DescribeDBSubnetGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DBSubnetGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDBSubnetGroups,
            inputKey: \DescribeDBSubnetGroupsMessage.marker,
            outputKey: \DBSubnetGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns the default engine and system parameter information for the specified database engine.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEngineDefaultParametersPaginator<Result>(
        _ input: DescribeEngineDefaultParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeEngineDefaultParametersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEngineDefaultParameters,
            inputKey: \DescribeEngineDefaultParametersMessage.marker,
            outputKey: \DescribeEngineDefaultParametersResult.engineDefaults?.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEngineDefaultParametersPaginator(
        _ input: DescribeEngineDefaultParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeEngineDefaultParametersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEngineDefaultParameters,
            inputKey: \DescribeEngineDefaultParametersMessage.marker,
            outputKey: \DescribeEngineDefaultParametersResult.engineDefaults?.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all the subscription descriptions for a customer account. The description for a subscription includes SubscriptionName, SNSTopicARN, CustomerID, SourceType, SourceID, CreationTime, and Status. If you specify a SubscriptionName, lists the description for that subscription.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEventSubscriptionsPaginator<Result>(
        _ input: DescribeEventSubscriptionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EventSubscriptionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEventSubscriptions,
            inputKey: \DescribeEventSubscriptionsMessage.marker,
            outputKey: \EventSubscriptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEventSubscriptionsPaginator(
        _ input: DescribeEventSubscriptionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EventSubscriptionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEventSubscriptions,
            inputKey: \DescribeEventSubscriptionsMessage.marker,
            outputKey: \EventSubscriptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns events related to DB instances, DB clusters, DB parameter groups, DB security groups, DB snapshots, and DB cluster snapshots for the past 14 days. Events specific to a particular DB instances, DB clusters, DB parameter groups, DB security groups, DB snapshots, and DB cluster snapshots group can be obtained by providing the name as a parameter.  By default, the past hour of events are returned.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEventsPaginator<Result>(
        _ input: DescribeEventsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EventsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \EventsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEventsPaginator(
        _ input: DescribeEventsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EventsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \EventsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about a snapshot export to Amazon S3. This API operation supports pagination.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeExportTasksPaginator<Result>(
        _ input: DescribeExportTasksMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ExportTasksMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeExportTasks,
            inputKey: \DescribeExportTasksMessage.marker,
            outputKey: \ExportTasksMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeExportTasksPaginator(
        _ input: DescribeExportTasksMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ExportTasksMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeExportTasks,
            inputKey: \DescribeExportTasksMessage.marker,
            outputKey: \ExportTasksMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Returns information about Aurora global database clusters. This API supports pagination.   For more information on Amazon Aurora, see  What Is Amazon Aurora? in the Amazon Aurora User Guide.   This action only applies to Aurora DB clusters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeGlobalClustersPaginator<Result>(
        _ input: DescribeGlobalClustersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GlobalClustersMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeGlobalClusters,
            inputKey: \DescribeGlobalClustersMessage.marker,
            outputKey: \GlobalClustersMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeGlobalClustersPaginator(
        _ input: DescribeGlobalClustersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GlobalClustersMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeGlobalClusters,
            inputKey: \DescribeGlobalClustersMessage.marker,
            outputKey: \GlobalClustersMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the available installation media for a DB engine that requires an on-premises customer provided license, such as Microsoft SQL Server.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstallationMediaPaginator<Result>(
        _ input: DescribeInstallationMediaMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, InstallationMediaMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstallationMedia,
            inputKey: \DescribeInstallationMediaMessage.marker,
            outputKey: \InstallationMediaMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstallationMediaPaginator(
        _ input: DescribeInstallationMediaMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (InstallationMediaMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstallationMedia,
            inputKey: \DescribeInstallationMediaMessage.marker,
            outputKey: \InstallationMediaMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes all available options.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeOptionGroupOptionsPaginator<Result>(
        _ input: DescribeOptionGroupOptionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, OptionGroupOptionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeOptionGroupOptions,
            inputKey: \DescribeOptionGroupOptionsMessage.marker,
            outputKey: \OptionGroupOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeOptionGroupOptionsPaginator(
        _ input: DescribeOptionGroupOptionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (OptionGroupOptionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeOptionGroupOptions,
            inputKey: \DescribeOptionGroupOptionsMessage.marker,
            outputKey: \OptionGroupOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the available option groups.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeOptionGroupsPaginator<Result>(
        _ input: DescribeOptionGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, OptionGroups, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeOptionGroups,
            inputKey: \DescribeOptionGroupsMessage.marker,
            outputKey: \OptionGroups.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeOptionGroupsPaginator(
        _ input: DescribeOptionGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (OptionGroups, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeOptionGroups,
            inputKey: \DescribeOptionGroupsMessage.marker,
            outputKey: \OptionGroups.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of orderable DB instance options for the specified engine.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeOrderableDBInstanceOptionsPaginator<Result>(
        _ input: DescribeOrderableDBInstanceOptionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, OrderableDBInstanceOptionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeOrderableDBInstanceOptions,
            inputKey: \DescribeOrderableDBInstanceOptionsMessage.marker,
            outputKey: \OrderableDBInstanceOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeOrderableDBInstanceOptionsPaginator(
        _ input: DescribeOrderableDBInstanceOptionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (OrderableDBInstanceOptionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeOrderableDBInstanceOptions,
            inputKey: \DescribeOrderableDBInstanceOptionsMessage.marker,
            outputKey: \OrderableDBInstanceOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of resources (for example, DB instances) that have at least one pending maintenance action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePendingMaintenanceActionsPaginator<Result>(
        _ input: DescribePendingMaintenanceActionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, PendingMaintenanceActionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePendingMaintenanceActions,
            inputKey: \DescribePendingMaintenanceActionsMessage.marker,
            outputKey: \PendingMaintenanceActionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePendingMaintenanceActionsPaginator(
        _ input: DescribePendingMaintenanceActionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (PendingMaintenanceActionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePendingMaintenanceActions,
            inputKey: \DescribePendingMaintenanceActionsMessage.marker,
            outputKey: \PendingMaintenanceActionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about reserved DB instances for this account, or about a specified reserved DB instance.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedDBInstancesPaginator<Result>(
        _ input: DescribeReservedDBInstancesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReservedDBInstanceMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedDBInstances,
            inputKey: \DescribeReservedDBInstancesMessage.marker,
            outputKey: \ReservedDBInstanceMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedDBInstancesPaginator(
        _ input: DescribeReservedDBInstancesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReservedDBInstanceMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedDBInstances,
            inputKey: \DescribeReservedDBInstancesMessage.marker,
            outputKey: \ReservedDBInstanceMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists available reserved DB instance offerings.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedDBInstancesOfferingsPaginator<Result>(
        _ input: DescribeReservedDBInstancesOfferingsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReservedDBInstancesOfferingMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedDBInstancesOfferings,
            inputKey: \DescribeReservedDBInstancesOfferingsMessage.marker,
            outputKey: \ReservedDBInstancesOfferingMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedDBInstancesOfferingsPaginator(
        _ input: DescribeReservedDBInstancesOfferingsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReservedDBInstancesOfferingMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedDBInstancesOfferings,
            inputKey: \DescribeReservedDBInstancesOfferingsMessage.marker,
            outputKey: \ReservedDBInstancesOfferingMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of the source Amazon Web Services Regions where the current Amazon Web Services Region can create a read replica, copy a DB snapshot from, or replicate automated backups from. This API action supports pagination.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSourceRegionsPaginator<Result>(
        _ input: DescribeSourceRegionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SourceRegionMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSourceRegions,
            inputKey: \DescribeSourceRegionsMessage.marker,
            outputKey: \SourceRegionMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSourceRegionsPaginator(
        _ input: DescribeSourceRegionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SourceRegionMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSourceRegions,
            inputKey: \DescribeSourceRegionsMessage.marker,
            outputKey: \SourceRegionMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Downloads all or a portion of the specified log file, up to 1 MB in size.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func downloadDBLogFilePortionPaginator<Result>(
        _ input: DownloadDBLogFilePortionMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DownloadDBLogFilePortionDetails, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: downloadDBLogFilePortion,
            inputKey: \DownloadDBLogFilePortionMessage.marker,
            outputKey: \DownloadDBLogFilePortionDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func downloadDBLogFilePortionPaginator(
        _ input: DownloadDBLogFilePortionMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DownloadDBLogFilePortionDetails, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: downloadDBLogFilePortion,
            inputKey: \DownloadDBLogFilePortionMessage.marker,
            outputKey: \DownloadDBLogFilePortionDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension RDS.DescribeCertificatesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeCertificatesMessage {
        return .init(
            certificateIdentifier: self.certificateIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeCustomAvailabilityZonesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeCustomAvailabilityZonesMessage {
        return .init(
            customAvailabilityZoneId: self.customAvailabilityZoneId,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBClusterBacktracksMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBClusterBacktracksMessage {
        return .init(
            backtrackIdentifier: self.backtrackIdentifier,
            dBClusterIdentifier: self.dBClusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBClusterEndpointsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBClusterEndpointsMessage {
        return .init(
            dBClusterEndpointIdentifier: self.dBClusterEndpointIdentifier,
            dBClusterIdentifier: self.dBClusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBClusterParameterGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBClusterParameterGroupsMessage {
        return .init(
            dBClusterParameterGroupName: self.dBClusterParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBClusterParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBClusterParametersMessage {
        return .init(
            dBClusterParameterGroupName: self.dBClusterParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )
    }
}

extension RDS.DescribeDBClusterSnapshotsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBClusterSnapshotsMessage {
        return .init(
            dBClusterIdentifier: self.dBClusterIdentifier,
            dBClusterSnapshotIdentifier: self.dBClusterSnapshotIdentifier,
            filters: self.filters,
            includePublic: self.includePublic,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )
    }
}

extension RDS.DescribeDBClustersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBClustersMessage {
        return .init(
            dBClusterIdentifier: self.dBClusterIdentifier,
            filters: self.filters,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBEngineVersionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBEngineVersionsMessage {
        return .init(
            dBParameterGroupFamily: self.dBParameterGroupFamily,
            defaultOnly: self.defaultOnly,
            engine: self.engine,
            engineVersion: self.engineVersion,
            filters: self.filters,
            includeAll: self.includeAll,
            listSupportedCharacterSets: self.listSupportedCharacterSets,
            listSupportedTimezones: self.listSupportedTimezones,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBInstanceAutomatedBackupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBInstanceAutomatedBackupsMessage {
        return .init(
            dBInstanceAutomatedBackupsArn: self.dBInstanceAutomatedBackupsArn,
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            dbiResourceId: self.dbiResourceId,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBInstancesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBInstancesMessage {
        return .init(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBLogFilesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBLogFilesMessage {
        return .init(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            fileLastWritten: self.fileLastWritten,
            filenameContains: self.filenameContains,
            fileSize: self.fileSize,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBParameterGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBParameterGroupsMessage {
        return .init(
            dBParameterGroupName: self.dBParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBParametersMessage {
        return .init(
            dBParameterGroupName: self.dBParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )
    }
}

extension RDS.DescribeDBProxiesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBProxiesRequest {
        return .init(
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBProxyEndpointsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBProxyEndpointsRequest {
        return .init(
            dBProxyEndpointName: self.dBProxyEndpointName,
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBProxyTargetGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBProxyTargetGroupsRequest {
        return .init(
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            targetGroupName: self.targetGroupName
        )
    }
}

extension RDS.DescribeDBProxyTargetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBProxyTargetsRequest {
        return .init(
            dBProxyName: self.dBProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            targetGroupName: self.targetGroupName
        )
    }
}

extension RDS.DescribeDBSecurityGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBSecurityGroupsMessage {
        return .init(
            dBSecurityGroupName: self.dBSecurityGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeDBSnapshotsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBSnapshotsMessage {
        return .init(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            dbiResourceId: self.dbiResourceId,
            dBSnapshotIdentifier: self.dBSnapshotIdentifier,
            filters: self.filters,
            includePublic: self.includePublic,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )
    }
}

extension RDS.DescribeDBSubnetGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeDBSubnetGroupsMessage {
        return .init(
            dBSubnetGroupName: self.dBSubnetGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeEngineDefaultParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeEngineDefaultParametersMessage {
        return .init(
            dBParameterGroupFamily: self.dBParameterGroupFamily,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeEventSubscriptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeEventSubscriptionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName
        )
    }
}

extension RDS.DescribeEventsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeEventsMessage {
        return .init(
            duration: self.duration,
            endTime: self.endTime,
            eventCategories: self.eventCategories,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )
    }
}

extension RDS.DescribeExportTasksMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeExportTasksMessage {
        return .init(
            exportTaskIdentifier: self.exportTaskIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceArn: self.sourceArn
        )
    }
}

extension RDS.DescribeGlobalClustersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeGlobalClustersMessage {
        return .init(
            filters: self.filters,
            globalClusterIdentifier: self.globalClusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeInstallationMediaMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeInstallationMediaMessage {
        return .init(
            filters: self.filters,
            installationMediaId: self.installationMediaId,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeOptionGroupOptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeOptionGroupOptionsMessage {
        return .init(
            engineName: self.engineName,
            filters: self.filters,
            majorEngineVersion: self.majorEngineVersion,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension RDS.DescribeOptionGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeOptionGroupsMessage {
        return .init(
            engineName: self.engineName,
            filters: self.filters,
            majorEngineVersion: self.majorEngineVersion,
            marker: token,
            maxRecords: self.maxRecords,
            optionGroupName: self.optionGroupName
        )
    }
}

extension RDS.DescribeOrderableDBInstanceOptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeOrderableDBInstanceOptionsMessage {
        return .init(
            availabilityZoneGroup: self.availabilityZoneGroup,
            dBInstanceClass: self.dBInstanceClass,
            engine: self.engine,
            engineVersion: self.engineVersion,
            filters: self.filters,
            licenseModel: self.licenseModel,
            marker: token,
            maxRecords: self.maxRecords,
            vpc: self.vpc
        )
    }
}

extension RDS.DescribePendingMaintenanceActionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribePendingMaintenanceActionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            resourceIdentifier: self.resourceIdentifier
        )
    }
}

extension RDS.DescribeReservedDBInstancesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeReservedDBInstancesMessage {
        return .init(
            dBInstanceClass: self.dBInstanceClass,
            duration: self.duration,
            filters: self.filters,
            leaseId: self.leaseId,
            marker: token,
            maxRecords: self.maxRecords,
            multiAZ: self.multiAZ,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedDBInstanceId: self.reservedDBInstanceId,
            reservedDBInstancesOfferingId: self.reservedDBInstancesOfferingId
        )
    }
}

extension RDS.DescribeReservedDBInstancesOfferingsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeReservedDBInstancesOfferingsMessage {
        return .init(
            dBInstanceClass: self.dBInstanceClass,
            duration: self.duration,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            multiAZ: self.multiAZ,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedDBInstancesOfferingId: self.reservedDBInstancesOfferingId
        )
    }
}

extension RDS.DescribeSourceRegionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DescribeSourceRegionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            regionName: self.regionName
        )
    }
}

extension RDS.DownloadDBLogFilePortionMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> RDS.DownloadDBLogFilePortionMessage {
        return .init(
            dBInstanceIdentifier: self.dBInstanceIdentifier,
            logFileName: self.logFileName,
            marker: token,
            numberOfLines: self.numberOfLines
        )
    }
}
