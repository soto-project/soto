//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension RDS {
    // MARK: Enums

    public enum ActivityStreamMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `async` = "async"
        case sync = "sync"
        public var description: String { return self.rawValue }
    }

    public enum ActivityStreamPolicyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case locked = "locked"
        case lockingPolicy = "locking-policy"
        case unlocked = "unlocked"
        case unlockingPolicy = "unlocking-policy"
        public var description: String { return self.rawValue }
    }

    public enum ActivityStreamStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "started"
        case starting = "starting"
        case stopped = "stopped"
        case stopping = "stopping"
        public var description: String { return self.rawValue }
    }

    public enum ApplyMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case immediate = "immediate"
        case pendingReboot = "pending-reboot"
        public var description: String { return self.rawValue }
    }

    public enum AuditPolicyState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lockedPolicy = "locked"
        case unlockedPolicy = "unlocked"
        public var description: String { return self.rawValue }
    }

    public enum AuthScheme: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case secrets = "SECRETS"
        public var description: String { return self.rawValue }
    }

    public enum AutomationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allPaused = "all-paused"
        case full = "full"
        public var description: String { return self.rawValue }
    }

    public enum ClientPasswordAuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mysqlNativePassword = "MYSQL_NATIVE_PASSWORD"
        case postgresMd5 = "POSTGRES_MD5"
        case postgresScramSha256 = "POSTGRES_SCRAM_SHA_256"
        case sqlServerAuthentication = "SQL_SERVER_AUTHENTICATION"
        public var description: String { return self.rawValue }
    }

    public enum CustomEngineVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "available"
        case inactive = "inactive"
        case inactiveExceptRestore = "inactive-except-restore"
        public var description: String { return self.rawValue }
    }

    public enum DBProxyEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "available"
        case creating = "creating"
        case deleting = "deleting"
        case incompatibleNetwork = "incompatible-network"
        case insufficientResourceLimits = "insufficient-resource-limits"
        case modifying = "modifying"
        public var description: String { return self.rawValue }
    }

    public enum DBProxyEndpointTargetRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case readOnly = "READ_ONLY"
        case readWrite = "READ_WRITE"
        public var description: String { return self.rawValue }
    }

    public enum DBProxyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "available"
        case creating = "creating"
        case deleting = "deleting"
        case incompatibleNetwork = "incompatible-network"
        case insufficientResourceLimits = "insufficient-resource-limits"
        case modifying = "modifying"
        case reactivating = "reactivating"
        case suspended = "suspended"
        case suspending = "suspending"
        public var description: String { return self.rawValue }
    }

    public enum EngineFamily: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mysql = "MYSQL"
        case postgresql = "POSTGRESQL"
        case sqlserver = "SQLSERVER"
        public var description: String { return self.rawValue }
    }

    public enum ExportSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cluster = "CLUSTER"
        case snapshot = "SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum FailoverStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelling = "cancelling"
        case failingOver = "failing-over"
        case pending = "pending"
        public var description: String { return self.rawValue }
    }

    public enum GlobalClusterMemberSynchronizationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "connected"
        case pendingResync = "pending-resync"
        public var description: String { return self.rawValue }
    }

    public enum IAMAuthMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "active"
        case creating = "creating"
        case deleting = "deleting"
        case failed = "failed"
        case modifying = "modifying"
        case needsAttention = "needs_attention"
        case syncing = "syncing"
        public var description: String { return self.rawValue }
    }

    public enum LimitlessDatabaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "active"
        case disabled = "disabled"
        case disabling = "disabling"
        case enabled = "enabled"
        case enabling = "enabling"
        case error = "error"
        case modifyingMaxCapacity = "modifying-max-capacity"
        case notInUse = "not-in-use"
        public var description: String { return self.rawValue }
    }

    public enum LocalWriteForwardingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case disabling = "disabling"
        case enabled = "enabled"
        case enabling = "enabling"
        case requested = "requested"
        public var description: String { return self.rawValue }
    }

    public enum ReplicaMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mounted = "mounted"
        case openReadOnly = "open-read-only"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blueGreenDeployment = "blue-green-deployment"
        case customEngineVersion = "custom-engine-version"
        case dbCluster = "db-cluster"
        case dbClusterSnapshot = "db-cluster-snapshot"
        case dbInstance = "db-instance"
        case dbParameterGroup = "db-parameter-group"
        case dbProxy = "db-proxy"
        case dbSecurityGroup = "db-security-group"
        case dbSnapshot = "db-snapshot"
        public var description: String { return self.rawValue }
    }

    public enum TargetHealthReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authFailure = "AUTH_FAILURE"
        case connectionFailed = "CONNECTION_FAILED"
        case invalidReplicationState = "INVALID_REPLICATION_STATE"
        case pendingProxyCapacity = "PENDING_PROXY_CAPACITY"
        case unreachable = "UNREACHABLE"
        public var description: String { return self.rawValue }
    }

    public enum TargetRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case readOnly = "READ_ONLY"
        case readWrite = "READ_WRITE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum TargetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case registering = "REGISTERING"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum TargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rdsInstance = "RDS_INSTANCE"
        case rdsServerlessEndpoint = "RDS_SERVERLESS_ENDPOINT"
        case trackedCluster = "TRACKED_CLUSTER"
        public var description: String { return self.rawValue }
    }

    public enum WriteForwardingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case disabling = "disabling"
        case enabled = "enabled"
        case enabling = "enabling"
        case unknown = "unknown"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAttributesMessage: AWSDecodableShape {
        public struct _AccountQuotasEncoding: ArrayCoderProperties { public static let member = "AccountQuota" }

        /// A list of AccountQuota objects. Within this list, each quota has a name,  a count of usage toward the quota maximum, and a maximum value for the quota.
        @OptionalCustomCoding<ArrayCoder<_AccountQuotasEncoding, AccountQuota>>
        public var accountQuotas: [AccountQuota]?

        public init(accountQuotas: [AccountQuota]? = nil) {
            self.accountQuotas = accountQuotas
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotas = "AccountQuotas"
        }
    }

    public struct AccountQuota: AWSDecodableShape {
        /// The name of the Amazon RDS quota for this Amazon Web Services account.
        public let accountQuotaName: String?
        /// The maximum allowed value for the quota.
        public let max: Int64?
        /// The amount currently used toward the quota maximum.
        public let used: Int64?

        public init(accountQuotaName: String? = nil, max: Int64? = nil, used: Int64? = nil) {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotaName = "AccountQuotaName"
            case max = "Max"
            case used = "Used"
        }
    }

    public struct AddRoleToDBClusterMessage: AWSEncodableShape {
        /// The name of the DB cluster to associate the IAM role with.
        public let dbClusterIdentifier: String?
        /// The name of the feature for the DB cluster that the IAM role is to be associated with.  For information about supported feature names, see DBEngineVersion.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role to associate with the Aurora DB cluster, for example arn:aws:iam::123456789012:role/AuroraAccessRole.
        public let roleArn: String?

        public init(dbClusterIdentifier: String? = nil, featureName: String? = nil, roleArn: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.featureName = featureName
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
        }
    }

    public struct AddRoleToDBInstanceMessage: AWSEncodableShape {
        /// The name of the DB instance to associate the IAM role with.
        public let dbInstanceIdentifier: String?
        /// The name of the feature for the DB instance that the IAM role is to be associated with.  For information about supported feature names, see DBEngineVersion.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role to associate with the DB instance, for example arn:aws:iam::123456789012:role/AccessRole.
        public let roleArn: String?

        public init(dbInstanceIdentifier: String? = nil, featureName: String? = nil, roleArn: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.featureName = featureName
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
        }
    }

    public struct AddSourceIdentifierToSubscriptionMessage: AWSEncodableShape {
        /// The identifier of the event source to be added. Constraints:   If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.   If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.   If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.   If the source type is a DB security group, a DBSecurityGroupName value must be supplied.   If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.   If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.   If the source type is an RDS Proxy, a DBProxyName value must be supplied.
        public let sourceIdentifier: String?
        /// The name of the RDS event notification subscription you want to add a source identifier to.
        public let subscriptionName: String?

        public init(sourceIdentifier: String? = nil, subscriptionName: String? = nil) {
            self.sourceIdentifier = sourceIdentifier
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case sourceIdentifier = "SourceIdentifier"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct AddSourceIdentifierToSubscriptionResult: AWSDecodableShape {
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct AddTagsToResourceMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The Amazon RDS resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about   creating an ARN,  see  Constructing an RDS Amazon Resource Name (ARN).
        public let resourceName: String?
        /// The tags to be assigned to the Amazon RDS resource.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(resourceName: String? = nil, tags: [Tag]? = nil) {
            self.resourceName = resourceName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "ResourceName"
            case tags = "Tags"
        }
    }

    public struct ApplyPendingMaintenanceActionMessage: AWSEncodableShape {
        /// The pending maintenance action to apply to this resource. Valid Values: system-update, db-upgrade,  hardware-maintenance, ca-certificate-rotation
        public let applyAction: String?
        /// A value that specifies the type of opt-in request, or undoes an opt-in request. An opt-in  request of type immediate can't be undone. Valid Values:    immediate - Apply the maintenance action immediately.    next-maintenance - Apply the maintenance action during the next maintenance window for the resource.    undo-opt-in - Cancel any existing next-maintenance opt-in requests.
        public let optInType: String?
        /// The RDS Amazon Resource Name (ARN) of the resource that the  pending maintenance action applies to. For information about   creating an ARN,  see  Constructing an RDS Amazon Resource Name (ARN).
        public let resourceIdentifier: String?

        public init(applyAction: String? = nil, optInType: String? = nil, resourceIdentifier: String? = nil) {
            self.applyAction = applyAction
            self.optInType = optInType
            self.resourceIdentifier = resourceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case applyAction = "ApplyAction"
            case optInType = "OptInType"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct ApplyPendingMaintenanceActionResult: AWSDecodableShape {
        public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

        public init(resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil) {
            self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
        }
    }

    public struct AuthorizeDBSecurityGroupIngressMessage: AWSEncodableShape {
        /// The IP range to authorize.
        public let cidrip: String?
        /// The name of the DB security group to add authorization to.
        public let dbSecurityGroupName: String?
        /// Id of the EC2 security group to authorize. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
        public let ec2SecurityGroupId: String?
        /// Name of the EC2 security group to authorize. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName  or EC2SecurityGroupId must be provided.
        public let ec2SecurityGroupName: String?
        /// Amazon Web Services account number of the owner of the EC2 security group specified in the EC2SecurityGroupName parameter. The Amazon Web Services access key ID isn't an acceptable value. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
        public let ec2SecurityGroupOwnerId: String?

        public init(cidrip: String? = nil, dbSecurityGroupName: String? = nil, ec2SecurityGroupId: String? = nil, ec2SecurityGroupName: String? = nil, ec2SecurityGroupOwnerId: String? = nil) {
            self.cidrip = cidrip
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
        }

        private enum CodingKeys: String, CodingKey {
            case cidrip = "CIDRIP"
            case dbSecurityGroupName = "DBSecurityGroupName"
            case ec2SecurityGroupId = "EC2SecurityGroupId"
            case ec2SecurityGroupName = "EC2SecurityGroupName"
            case ec2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        }
    }

    public struct AuthorizeDBSecurityGroupIngressResult: AWSDecodableShape {
        public let dbSecurityGroup: DBSecurityGroup?

        public init(dbSecurityGroup: DBSecurityGroup? = nil) {
            self.dbSecurityGroup = dbSecurityGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroup = "DBSecurityGroup"
        }
    }

    public struct AvailabilityZone: AWSDecodableShape {
        /// The name of the Availability Zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AvailableProcessorFeature: AWSDecodableShape {
        /// The allowed values for the processor feature of the DB instance class.
        public let allowedValues: String?
        /// The default value for the processor feature of the DB instance class.
        public let defaultValue: String?
        /// The name of the processor feature. Valid names are coreCount  and threadsPerCore.
        public let name: String?

        public init(allowedValues: String? = nil, defaultValue: String? = nil, name: String? = nil) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case defaultValue = "DefaultValue"
            case name = "Name"
        }
    }

    public struct BacktrackDBClusterMessage: AWSEncodableShape {
        /// The timestamp of the time to backtrack the DB cluster to, specified in ISO 8601 format. For more information about ISO 8601, see the ISO8601 Wikipedia page.   If the specified time isn't a consistent time for the DB cluster,  Aurora automatically chooses the nearest possible consistent time for the DB cluster.  Constraints:   Must contain a valid ISO 8601 timestamp.   Can't contain a timestamp set in the future.   Example: 2017-07-08T18:00Z
        public let backtrackTo: Date?
        /// The DB cluster identifier of the DB cluster to be backtracked. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster1
        public let dbClusterIdentifier: String?
        /// Specifies whether to force the DB cluster to backtrack when binary logging is enabled. Otherwise, an error occurs when binary logging is enabled.
        public let force: Bool?
        /// Specifies whether to backtrack the DB cluster to the earliest possible backtrack time when BacktrackTo is set to a timestamp earlier than the earliest backtrack time. When this parameter is disabled and BacktrackTo is set to a timestamp earlier than the earliest backtrack time, an error occurs.
        public let useEarliestTimeOnPointInTimeUnavailable: Bool?

        public init(backtrackTo: Date? = nil, dbClusterIdentifier: String? = nil, force: Bool? = nil, useEarliestTimeOnPointInTimeUnavailable: Bool? = nil) {
            self.backtrackTo = backtrackTo
            self.dbClusterIdentifier = dbClusterIdentifier
            self.force = force
            self.useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable
        }

        private enum CodingKeys: String, CodingKey {
            case backtrackTo = "BacktrackTo"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case force = "Force"
            case useEarliestTimeOnPointInTimeUnavailable = "UseEarliestTimeOnPointInTimeUnavailable"
        }
    }

    public struct BlueGreenDeployment: AWSDecodableShape {
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The unique identifier of the blue/green deployment.
        public let blueGreenDeploymentIdentifier: String?
        /// The user-supplied name of the blue/green deployment.
        public let blueGreenDeploymentName: String?
        /// The time when the blue/green deployment was created, in Universal Coordinated Time (UTC).
        public let createTime: Date?
        /// The time when the blue/green deployment was deleted, in Universal Coordinated Time (UTC).
        public let deleteTime: Date?
        /// The source database for the blue/green deployment. Before switchover, the source database is the production database in the blue environment.
        public let source: String?
        /// The status of the blue/green deployment. Valid Values:    PROVISIONING - Resources are being created in the green environment.    AVAILABLE - Resources are available in the green environment.    SWITCHOVER_IN_PROGRESS - The deployment is being switched from the blue environment to the  green environment.    SWITCHOVER_COMPLETED - Switchover from the blue environment to the green environment is complete.    INVALID_CONFIGURATION - Resources in the green environment are invalid, so switchover isn't possible.    SWITCHOVER_FAILED - Switchover was attempted but failed.    DELETING - The blue/green deployment is being deleted.
        public let status: String?
        /// Additional information about the status of the blue/green deployment.
        public let statusDetails: String?
        /// The details about each source and target resource in the blue/green deployment.
        @OptionalCustomCoding<StandardArrayCoder<SwitchoverDetail>>
        public var switchoverDetails: [SwitchoverDetail]?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The target database for the blue/green deployment. Before switchover, the target database is the clone database in the green environment.
        public let target: String?
        /// Either tasks to be performed or tasks that have been completed on the target database before switchover.
        @OptionalCustomCoding<StandardArrayCoder<BlueGreenDeploymentTask>>
        public var tasks: [BlueGreenDeploymentTask]?

        public init(blueGreenDeploymentIdentifier: String? = nil, blueGreenDeploymentName: String? = nil, createTime: Date? = nil, deleteTime: Date? = nil, source: String? = nil, status: String? = nil, statusDetails: String? = nil, switchoverDetails: [SwitchoverDetail]? = nil, tagList: [Tag]? = nil, target: String? = nil, tasks: [BlueGreenDeploymentTask]? = nil) {
            self.blueGreenDeploymentIdentifier = blueGreenDeploymentIdentifier
            self.blueGreenDeploymentName = blueGreenDeploymentName
            self.createTime = createTime
            self.deleteTime = deleteTime
            self.source = source
            self.status = status
            self.statusDetails = statusDetails
            self.switchoverDetails = switchoverDetails
            self.tagList = tagList
            self.target = target
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeploymentIdentifier = "BlueGreenDeploymentIdentifier"
            case blueGreenDeploymentName = "BlueGreenDeploymentName"
            case createTime = "CreateTime"
            case deleteTime = "DeleteTime"
            case source = "Source"
            case status = "Status"
            case statusDetails = "StatusDetails"
            case switchoverDetails = "SwitchoverDetails"
            case tagList = "TagList"
            case target = "Target"
            case tasks = "Tasks"
        }
    }

    public struct BlueGreenDeploymentTask: AWSDecodableShape {
        /// The name of the blue/green deployment task.
        public let name: String?
        /// The status of the blue/green deployment task. Valid Values:    PENDING - The resource is being prepared for deployment.    IN_PROGRESS - The resource is being deployed.    COMPLETED - The resource has been deployed.    FAILED - Deployment of the resource failed.
        public let status: String?

        public init(name: String? = nil, status: String? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case status = "Status"
        }
    }

    public struct CancelExportTaskMessage: AWSEncodableShape {
        /// The identifier of the snapshot or cluster export task to cancel.
        public let exportTaskIdentifier: String?

        public init(exportTaskIdentifier: String? = nil) {
            self.exportTaskIdentifier = exportTaskIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case exportTaskIdentifier = "ExportTaskIdentifier"
        }
    }

    public struct Certificate: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The unique key that identifies a certificate.
        public let certificateIdentifier: String?
        /// The type of the certificate.
        public let certificateType: String?
        /// Indicates whether there is an override for the default certificate identifier.
        public let customerOverride: Bool?
        /// If there is an override for the default certificate identifier, when the override expires.
        public let customerOverrideValidTill: Date?
        /// The thumbprint of the certificate.
        public let thumbprint: String?
        /// The starting date from which the certificate is valid.
        public let validFrom: Date?
        /// The final date that the certificate continues to be valid.
        public let validTill: Date?

        public init(certificateArn: String? = nil, certificateIdentifier: String? = nil, certificateType: String? = nil, customerOverride: Bool? = nil, customerOverrideValidTill: Date? = nil, thumbprint: String? = nil, validFrom: Date? = nil, validTill: Date? = nil) {
            self.certificateArn = certificateArn
            self.certificateIdentifier = certificateIdentifier
            self.certificateType = certificateType
            self.customerOverride = customerOverride
            self.customerOverrideValidTill = customerOverrideValidTill
            self.thumbprint = thumbprint
            self.validFrom = validFrom
            self.validTill = validTill
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case certificateIdentifier = "CertificateIdentifier"
            case certificateType = "CertificateType"
            case customerOverride = "CustomerOverride"
            case customerOverrideValidTill = "CustomerOverrideValidTill"
            case thumbprint = "Thumbprint"
            case validFrom = "ValidFrom"
            case validTill = "ValidTill"
        }
    }

    public struct CertificateDetails: AWSDecodableShape {
        /// The CA identifier of the CA certificate used for the DB instance's server certificate.
        public let caIdentifier: String?
        /// The expiration date of the DB instance’s server certificate.
        public let validTill: Date?

        public init(caIdentifier: String? = nil, validTill: Date? = nil) {
            self.caIdentifier = caIdentifier
            self.validTill = validTill
        }

        private enum CodingKeys: String, CodingKey {
            case caIdentifier = "CAIdentifier"
            case validTill = "ValidTill"
        }
    }

    public struct CertificateMessage: AWSDecodableShape {
        public struct _CertificatesEncoding: ArrayCoderProperties { public static let member = "Certificate" }

        /// The list of Certificate objects for the Amazon Web Services account.
        @OptionalCustomCoding<ArrayCoder<_CertificatesEncoding, Certificate>>
        public var certificates: [Certificate]?
        /// The default root CA for new databases created by your Amazon Web Services account. This is either the root CA override  set on your Amazon Web Services account or the system default CA for the Region if no override exists. To override the default CA, use the  ModifyCertificates operation.
        public let defaultCertificateForNewLaunches: String?
        /// An optional pagination token provided by a previous DescribeCertificates request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
        public let marker: String?

        public init(certificates: [Certificate]? = nil, defaultCertificateForNewLaunches: String? = nil, marker: String? = nil) {
            self.certificates = certificates
            self.defaultCertificateForNewLaunches = defaultCertificateForNewLaunches
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "Certificates"
            case defaultCertificateForNewLaunches = "DefaultCertificateForNewLaunches"
            case marker = "Marker"
        }
    }

    public struct CharacterSet: AWSDecodableShape {
        /// The description of the character set.
        public let characterSetDescription: String?
        /// The name of the character set.
        public let characterSetName: String?

        public init(characterSetDescription: String? = nil, characterSetName: String? = nil) {
            self.characterSetDescription = characterSetDescription
            self.characterSetName = characterSetName
        }

        private enum CodingKeys: String, CodingKey {
            case characterSetDescription = "CharacterSetDescription"
            case characterSetName = "CharacterSetName"
        }
    }

    public struct CloudwatchLogsExportConfiguration: AWSEncodableShape {
        /// The list of log types to disable.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var disableLogTypes: [String]?
        /// The list of log types to enable.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableLogTypes: [String]?

        public init(disableLogTypes: [String]? = nil, enableLogTypes: [String]? = nil) {
            self.disableLogTypes = disableLogTypes
            self.enableLogTypes = enableLogTypes
        }

        private enum CodingKeys: String, CodingKey {
            case disableLogTypes = "DisableLogTypes"
            case enableLogTypes = "EnableLogTypes"
        }
    }

    public struct ClusterPendingModifiedValues: AWSDecodableShape {
        /// The allocated storage size in gibibytes (GiB) for all database engines except Amazon Aurora. For Aurora,  AllocatedStorage always returns 1, because Aurora DB cluster storage size isn't fixed, but  instead automatically adjusts as needed.
        public let allocatedStorage: Int?
        /// The number of days for which automatic DB snapshots are retained.
        public let backupRetentionPeriod: Int?
        public let certificateDetails: CertificateDetails?
        /// The DBClusterIdentifier value for the DB cluster.
        public let dbClusterIdentifier: String?
        /// The database engine version.
        public let engineVersion: String?
        /// Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The Provisioned IOPS (I/O operations per second) value. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let iops: Int?
        /// The master credentials for the DB cluster.
        public let masterUserPassword: String?
        public let pendingCloudwatchLogsExports: PendingCloudwatchLogsExports?
        /// Reserved for future use.
        public let rdsCustomClusterConfiguration: RdsCustomClusterConfiguration?
        /// The storage type for the DB cluster.
        public let storageType: String?

        public init(allocatedStorage: Int? = nil, backupRetentionPeriod: Int? = nil, certificateDetails: CertificateDetails? = nil, dbClusterIdentifier: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, iops: Int? = nil, masterUserPassword: String? = nil, pendingCloudwatchLogsExports: PendingCloudwatchLogsExports? = nil, rdsCustomClusterConfiguration: RdsCustomClusterConfiguration? = nil, storageType: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.certificateDetails = certificateDetails
            self.dbClusterIdentifier = dbClusterIdentifier
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.iops = iops
            self.masterUserPassword = masterUserPassword
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
            self.rdsCustomClusterConfiguration = rdsCustomClusterConfiguration
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case certificateDetails = "CertificateDetails"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case iops = "Iops"
            case masterUserPassword = "MasterUserPassword"
            case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
            case rdsCustomClusterConfiguration = "RdsCustomClusterConfiguration"
            case storageType = "StorageType"
        }
    }

    public struct ConnectionPoolConfiguration: AWSEncodableShape {
        /// The number of seconds for a proxy to wait for a connection to become available in the connection pool. This setting only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. For an unlimited wait time, specify 0. Default: 120  Constraints:   Must be between 0 and 3600.
        public let connectionBorrowTimeout: Int?
        /// One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. Default: no initialization query
        public let initQuery: String?
        /// The maximum size of the connection pool for each target in a target group. The value is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. If you specify MaxIdleConnectionsPercent, then you must also include a value for this parameter. Default: 10 for RDS for Microsoft SQL Server, and 100 for all other engines Constraints:   Must be between 1 and 100.
        public let maxConnectionsPercent: Int?
        /// A value that controls how actively the proxy closes idle database connections in the connection pool. The value is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. With a high value, the proxy leaves a high percentage of idle database connections open. A low value causes the proxy to close more idle connections and return them to the database. If you specify this parameter, then you must also include a value for MaxConnectionsPercent. Default: The default value is half of the value of MaxConnectionsPercent. For example, if MaxConnectionsPercent is 80, then the default value of  MaxIdleConnectionsPercent is 40. If the value of MaxConnectionsPercent isn't specified, then for SQL Server, MaxIdleConnectionsPercent is 5, and  for all other engines, the default is 50. Constraints:   Must be between 0 and the value of MaxConnectionsPercent.
        public let maxIdleConnectionsPercent: Int?
        /// Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: no session pinning filters
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var sessionPinningFilters: [String]?

        public init(connectionBorrowTimeout: Int? = nil, initQuery: String? = nil, maxConnectionsPercent: Int? = nil, maxIdleConnectionsPercent: Int? = nil, sessionPinningFilters: [String]? = nil) {
            self.connectionBorrowTimeout = connectionBorrowTimeout
            self.initQuery = initQuery
            self.maxConnectionsPercent = maxConnectionsPercent
            self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
            self.sessionPinningFilters = sessionPinningFilters
        }

        private enum CodingKeys: String, CodingKey {
            case connectionBorrowTimeout = "ConnectionBorrowTimeout"
            case initQuery = "InitQuery"
            case maxConnectionsPercent = "MaxConnectionsPercent"
            case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
            case sessionPinningFilters = "SessionPinningFilters"
        }
    }

    public struct ConnectionPoolConfigurationInfo: AWSDecodableShape {
        /// The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.
        public let connectionBorrowTimeout: Int?
        /// One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. This setting is empty by default. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2.
        public let initQuery: String?
        /// The maximum size of the connection pool for each target in a target group. The value is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        public let maxConnectionsPercent: Int?
        /// Controls how actively the proxy closes idle database connections in the connection pool. The value is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. With a high value, the proxy leaves a high percentage of idle database connections open. A low value causes the proxy to close more idle connections and return them to the database.
        public let maxIdleConnectionsPercent: Int?
        /// Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. This setting is only supported for MySQL engine family databases.  Currently, the only allowed value is EXCLUDE_VARIABLE_SETS.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var sessionPinningFilters: [String]?

        public init(connectionBorrowTimeout: Int? = nil, initQuery: String? = nil, maxConnectionsPercent: Int? = nil, maxIdleConnectionsPercent: Int? = nil, sessionPinningFilters: [String]? = nil) {
            self.connectionBorrowTimeout = connectionBorrowTimeout
            self.initQuery = initQuery
            self.maxConnectionsPercent = maxConnectionsPercent
            self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
            self.sessionPinningFilters = sessionPinningFilters
        }

        private enum CodingKeys: String, CodingKey {
            case connectionBorrowTimeout = "ConnectionBorrowTimeout"
            case initQuery = "InitQuery"
            case maxConnectionsPercent = "MaxConnectionsPercent"
            case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
            case sessionPinningFilters = "SessionPinningFilters"
        }
    }

    public struct ContextAttribute: AWSDecodableShape {
        /// The key of ContextAttribute.
        public let key: String?
        /// The value of ContextAttribute.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct CopyDBClusterParameterGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The identifier or Amazon Resource Name (ARN) for the source DB cluster parameter group. For information about   creating an ARN,  see  Constructing an ARN for Amazon RDS in the Amazon Aurora User Guide. Constraints:   Must specify a valid DB cluster parameter group.
        public let sourceDBClusterParameterGroupIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// A description for the copied DB cluster parameter group.
        public let targetDBClusterParameterGroupDescription: String?
        /// The identifier for the copied DB cluster parameter group. Constraints:   Can't be null, empty, or blank   Must contain from 1 to 255 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: my-cluster-param-group1
        public let targetDBClusterParameterGroupIdentifier: String?

        public init(sourceDBClusterParameterGroupIdentifier: String? = nil, tags: [Tag]? = nil, targetDBClusterParameterGroupDescription: String? = nil, targetDBClusterParameterGroupIdentifier: String? = nil) {
            self.sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier
            self.tags = tags
            self.targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription
            self.targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDBClusterParameterGroupIdentifier = "SourceDBClusterParameterGroupIdentifier"
            case tags = "Tags"
            case targetDBClusterParameterGroupDescription = "TargetDBClusterParameterGroupDescription"
            case targetDBClusterParameterGroupIdentifier = "TargetDBClusterParameterGroupIdentifier"
        }
    }

    public struct CopyDBClusterParameterGroupResult: AWSDecodableShape {
        public let dbClusterParameterGroup: DBClusterParameterGroup?

        public init(dbClusterParameterGroup: DBClusterParameterGroup? = nil) {
            self.dbClusterParameterGroup = dbClusterParameterGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroup = "DBClusterParameterGroup"
        }
    }

    public struct CopyDBClusterSnapshotMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// Specifies whether to copy all tags from the source DB cluster snapshot to the target DB cluster snapshot.  By default, tags are not copied.
        public let copyTags: Bool?
        /// The Amazon Web Services KMS key identifier for an encrypted DB cluster snapshot.  The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS key. If you copy an encrypted DB cluster snapshot from your Amazon Web Services account, you can specify a value for KmsKeyId to encrypt the copy with a new KMS key.  If you don't specify a value for KmsKeyId, then the copy of the DB cluster snapshot is encrypted with the same KMS key as the source DB cluster snapshot. If you copy an encrypted DB cluster snapshot that is shared from another Amazon Web Services account, then you must specify a value for KmsKeyId. To copy an encrypted DB cluster snapshot to another Amazon Web Services Region, you must set KmsKeyId to the Amazon Web Services KMS key identifier  you want to use to encrypt the copy of the DB cluster snapshot in the destination Amazon Web Services Region. KMS keys are specific to the Amazon Web Services  Region that they are created in, and you can't use KMS keys from one Amazon Web Services Region  in another Amazon Web Services Region. If you copy an unencrypted DB cluster snapshot and specify a value for the KmsKeyId parameter,  an error is returned.
        public let kmsKeyId: String?
        /// When you are copying a DB cluster snapshot from one Amazon Web Services GovCloud (US) Region to another, the URL that contains a Signature Version 4 signed request for the CopyDBClusterSnapshot API operation in the Amazon Web Services Region that contains the source DB cluster snapshot to copy. Use the PreSignedUrl parameter when copying an encrypted DB cluster snapshot from another Amazon Web Services Region. Don't specify PreSignedUrl when copying an encrypted DB cluster snapshot in the same Amazon Web Services Region. This setting applies only to Amazon Web Services GovCloud (US) Regions. It's ignored in other Amazon Web Services Regions. The presigned URL must be a valid request for the CopyDBClusterSnapshot API operation that can run in the source Amazon Web Services Region that contains the encrypted DB cluster snapshot to copy. The presigned URL request must contain the following parameter values:    KmsKeyId - The KMS key identifier for the KMS key to use to encrypt the copy of the DB cluster snapshot in the destination Amazon Web Services Region. This is the same identifier for both the CopyDBClusterSnapshot operation that is called in the destination Amazon Web Services Region, and the operation contained in the presigned URL.    DestinationRegion - The name of the Amazon Web Services Region  that the DB cluster snapshot is to be created in.    SourceDBClusterSnapshotIdentifier - The DB cluster snapshot identifier for the encrypted DB cluster  snapshot to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example,  if you are copying an encrypted DB cluster snapshot from the us-west-2 Amazon Web Services Region, then your SourceDBClusterSnapshotIdentifier looks like the following example: arn:aws:rds:us-west-2:123456789012:cluster-snapshot:aurora-cluster1-snapshot-20161115.   To learn how to generate a Signature Version 4 signed request, see   Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and  Signature Version 4 Signing Process.  If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can run in the source Amazon Web Services Region.
        public let preSignedUrl: String?
        /// The identifier of the DB cluster snapshot to copy. This parameter isn't case-sensitive. You can't copy an encrypted, shared DB cluster snapshot from one Amazon Web Services Region to another. Constraints:   Must specify a valid system snapshot in the "available" state.   If the source snapshot is in the same Amazon Web Services Region as the copy, specify a valid DB snapshot identifier.   If the source snapshot is in a different Amazon Web Services Region than the copy, specify a valid DB cluster snapshot ARN. For more information, go to  Copying Snapshots Across Amazon Web Services Regions in the Amazon Aurora User Guide.   Example: my-cluster-snapshot1
        public let sourceDBClusterSnapshotIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The identifier of the new DB cluster snapshot to create from the source DB cluster snapshot. This parameter isn't case-sensitive. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster-snapshot2
        public let targetDBClusterSnapshotIdentifier: String?

        public init(copyTags: Bool? = nil, kmsKeyId: String? = nil, preSignedUrl: String? = nil, sourceDBClusterSnapshotIdentifier: String? = nil, tags: [Tag]? = nil, targetDBClusterSnapshotIdentifier: String? = nil) {
            self.copyTags = copyTags
            self.kmsKeyId = kmsKeyId
            self.preSignedUrl = preSignedUrl
            self.sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier
            self.tags = tags
            self.targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case copyTags = "CopyTags"
            case kmsKeyId = "KmsKeyId"
            case preSignedUrl = "PreSignedUrl"
            case sourceDBClusterSnapshotIdentifier = "SourceDBClusterSnapshotIdentifier"
            case tags = "Tags"
            case targetDBClusterSnapshotIdentifier = "TargetDBClusterSnapshotIdentifier"
        }
    }

    public struct CopyDBClusterSnapshotResult: AWSDecodableShape {
        public let dbClusterSnapshot: DBClusterSnapshot?

        public init(dbClusterSnapshot: DBClusterSnapshot? = nil) {
            self.dbClusterSnapshot = dbClusterSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshot = "DBClusterSnapshot"
        }
    }

    public struct CopyDBParameterGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The identifier or ARN for the source DB parameter group. For information about   creating an ARN,  see  Constructing an ARN for Amazon RDS in the Amazon RDS User Guide. Constraints:   Must specify a valid DB parameter group.
        public let sourceDBParameterGroupIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// A description for the copied DB parameter group.
        public let targetDBParameterGroupDescription: String?
        /// The identifier for the copied DB parameter group. Constraints:   Can't be null, empty, or blank   Must contain from 1 to 255 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: my-db-parameter-group
        public let targetDBParameterGroupIdentifier: String?

        public init(sourceDBParameterGroupIdentifier: String? = nil, tags: [Tag]? = nil, targetDBParameterGroupDescription: String? = nil, targetDBParameterGroupIdentifier: String? = nil) {
            self.sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier
            self.tags = tags
            self.targetDBParameterGroupDescription = targetDBParameterGroupDescription
            self.targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDBParameterGroupIdentifier = "SourceDBParameterGroupIdentifier"
            case tags = "Tags"
            case targetDBParameterGroupDescription = "TargetDBParameterGroupDescription"
            case targetDBParameterGroupIdentifier = "TargetDBParameterGroupIdentifier"
        }
    }

    public struct CopyDBParameterGroupResult: AWSDecodableShape {
        public let dbParameterGroup: DBParameterGroup?

        public init(dbParameterGroup: DBParameterGroup? = nil) {
            self.dbParameterGroup = dbParameterGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroup = "DBParameterGroup"
        }
    }

    public struct CopyDBSnapshotMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// Specifies whether to copy the DB option group associated with the source DB snapshot to the target  Amazon Web Services account and associate with the target DB snapshot. The associated option group can be copied only with  cross-account snapshot copy calls.
        public let copyOptionGroup: Bool?
        /// Specifies whether to copy all tags from the source DB snapshot to the target DB snapshot.  By default, tags aren't copied.
        public let copyTags: Bool?
        /// The Amazon Web Services KMS key identifier for an encrypted DB snapshot.  The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you copy an encrypted DB snapshot from your Amazon Web Services account,  you can specify a value for this parameter to encrypt the copy with a new KMS key.  If you don't specify a value for this parameter,  then the copy of the DB snapshot is encrypted with the same Amazon Web Services KMS key as the source DB snapshot. If you copy an encrypted DB snapshot that is shared from another Amazon Web Services account,  then you must specify a value for this parameter. If you specify this parameter when you copy an unencrypted snapshot,  the copy is encrypted. If you copy an encrypted snapshot to a different Amazon Web Services Region, then you must specify an Amazon Web Services KMS key identifier for the destination Amazon Web Services Region. KMS keys are specific to the Amazon Web Services Region that they are created in, and you can't use KMS keys from one Amazon Web Services Region in another Amazon Web Services Region.
        public let kmsKeyId: String?
        /// The name of an option group to associate with the copy of the snapshot. Specify this option if you are copying a snapshot from one Amazon Web Services Region to another, and your DB instance uses a nondefault option group.  If your source DB instance uses Transparent Data Encryption for Oracle or Microsoft SQL Server,  you must specify this option when copying across Amazon Web Services Regions.  For more information, see  Option group considerations in the Amazon RDS User Guide.
        public let optionGroupName: String?
        /// When you are copying a snapshot from one Amazon Web Services GovCloud (US) Region to another,  the URL that contains a Signature Version 4 signed request for the CopyDBSnapshot API  operation in the source Amazon Web Services Region that contains the source DB snapshot to copy. This setting applies only to Amazon Web Services GovCloud (US) Regions. It's ignored in other Amazon Web Services Regions. You must specify this parameter when you copy an encrypted DB snapshot from another Amazon Web Services Region by using the Amazon RDS API. Don't specify PreSignedUrl when you are  copying an encrypted DB snapshot in the same Amazon Web Services Region. The presigned URL must be a valid request for the CopyDBClusterSnapshot API operation that can run in the source Amazon Web Services Region that contains the encrypted DB cluster snapshot to copy. The presigned URL request must contain the following parameter values:    DestinationRegion - The Amazon Web Services Region that the encrypted DB snapshot is copied to. This Amazon Web Services Region is the same one where the CopyDBSnapshot operation is called that contains this presigned URL. For example, if you copy an encrypted DB snapshot from the us-west-2 Amazon Web Services Region to the us-east-1 Amazon Web Services Region, then you call the CopyDBSnapshot operation in the us-east-1 Amazon Web Services Region and provide a presigned URL that contains a call to the CopyDBSnapshot operation in the us-west-2 Amazon Web Services Region. For this example, the DestinationRegion in the presigned URL must be set to the us-east-1 Amazon Web Services Region.    KmsKeyId - The KMS key identifier for the KMS key to use to encrypt the copy of the DB snapshot in the destination Amazon Web Services Region. This is the same identifier for both the CopyDBSnapshot operation that is called in the destination Amazon Web Services Region, and the operation contained in the presigned URL.    SourceDBSnapshotIdentifier - The DB snapshot identifier for the encrypted snapshot to be copied.  This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region.  For example, if you are copying an encrypted DB snapshot from the us-west-2 Amazon Web Services Region, then your SourceDBSnapshotIdentifier looks like the following example: arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20161115.   To learn how to generate a Signature Version 4 signed request, see  Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and Signature Version 4 Signing Process.  If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can run in the source Amazon Web Services Region.
        public let preSignedUrl: String?
        /// The identifier for the source DB snapshot. If the source snapshot is in the same Amazon Web Services Region as the copy, specify a valid DB snapshot identifier. For example, you might specify rds:mysql-instance1-snapshot-20130805. If the source snapshot is in a different Amazon Web Services Region than the copy, specify a valid DB snapshot ARN. For example, you might specify arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805. If you are copying from a shared manual DB snapshot,  this parameter must be the Amazon Resource Name (ARN) of the shared DB snapshot. If you are copying an encrypted snapshot this parameter must be in the ARN format for the source Amazon Web Services Region. Constraints:   Must specify a valid system snapshot in the "available" state.   Example: rds:mydb-2012-04-02-00-01  Example: arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805
        public let sourceDBSnapshotIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The external custom Availability Zone (CAZ) identifier for the target CAZ. Example: rds-caz-aiqhTgQv.
        public let targetCustomAvailabilityZone: String?
        /// The identifier for the copy of the snapshot. Constraints:   Can't be null, empty, or blank   Must contain from 1 to 255 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: my-db-snapshot
        public let targetDBSnapshotIdentifier: String?

        public init(copyOptionGroup: Bool? = nil, copyTags: Bool? = nil, kmsKeyId: String? = nil, optionGroupName: String? = nil, preSignedUrl: String? = nil, sourceDBSnapshotIdentifier: String? = nil, tags: [Tag]? = nil, targetCustomAvailabilityZone: String? = nil, targetDBSnapshotIdentifier: String? = nil) {
            self.copyOptionGroup = copyOptionGroup
            self.copyTags = copyTags
            self.kmsKeyId = kmsKeyId
            self.optionGroupName = optionGroupName
            self.preSignedUrl = preSignedUrl
            self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
            self.tags = tags
            self.targetCustomAvailabilityZone = targetCustomAvailabilityZone
            self.targetDBSnapshotIdentifier = targetDBSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case copyOptionGroup = "CopyOptionGroup"
            case copyTags = "CopyTags"
            case kmsKeyId = "KmsKeyId"
            case optionGroupName = "OptionGroupName"
            case preSignedUrl = "PreSignedUrl"
            case sourceDBSnapshotIdentifier = "SourceDBSnapshotIdentifier"
            case tags = "Tags"
            case targetCustomAvailabilityZone = "TargetCustomAvailabilityZone"
            case targetDBSnapshotIdentifier = "TargetDBSnapshotIdentifier"
        }
    }

    public struct CopyDBSnapshotResult: AWSDecodableShape {
        public let dbSnapshot: DBSnapshot?

        public init(dbSnapshot: DBSnapshot? = nil) {
            self.dbSnapshot = dbSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshot = "DBSnapshot"
        }
    }

    public struct CopyOptionGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The identifier for the source option group. Constraints:   Must specify a valid option group.
        public let sourceOptionGroupIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The description for the copied option group.
        public let targetOptionGroupDescription: String?
        /// The identifier for the copied option group. Constraints:   Can't be null, empty, or blank   Must contain from 1 to 255 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: my-option-group
        public let targetOptionGroupIdentifier: String?

        public init(sourceOptionGroupIdentifier: String? = nil, tags: [Tag]? = nil, targetOptionGroupDescription: String? = nil, targetOptionGroupIdentifier: String? = nil) {
            self.sourceOptionGroupIdentifier = sourceOptionGroupIdentifier
            self.tags = tags
            self.targetOptionGroupDescription = targetOptionGroupDescription
            self.targetOptionGroupIdentifier = targetOptionGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case sourceOptionGroupIdentifier = "SourceOptionGroupIdentifier"
            case tags = "Tags"
            case targetOptionGroupDescription = "TargetOptionGroupDescription"
            case targetOptionGroupIdentifier = "TargetOptionGroupIdentifier"
        }
    }

    public struct CopyOptionGroupResult: AWSDecodableShape {
        public let optionGroup: OptionGroup?

        public init(optionGroup: OptionGroup? = nil) {
            self.optionGroup = optionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroup = "OptionGroup"
        }
    }

    public struct CreateBlueGreenDeploymentRequest: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The name of the blue/green deployment. Constraints:   Can't be the same as an existing blue/green deployment name in the same account and Amazon Web Services Region.
        public let blueGreenDeploymentName: String?
        /// The Amazon Resource Name (ARN) of the source production database. Specify the database that you want to clone. The blue/green deployment creates this database in  the green environment. You can make updates to the database in the green environment, such as an engine  version upgrade. When you are ready, you can switch the database in the green environment to be the  production database.
        public let source: String?
        /// Tags to assign to the blue/green deployment.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The DB cluster parameter group associated with the Aurora DB cluster in the green environment. To test parameter changes, specify a DB cluster parameter group that is different from the one associated  with the source DB cluster.
        public let targetDBClusterParameterGroupName: String?
        /// Specify the DB instance class for the databases in the green environment. This parameter only applies to RDS DB instances, because DB instances within an Aurora DB cluster can have multiple different instance classes. If you're creating a blue/green deployment from an Aurora DB cluster, don't specify this parameter. After the green environment is created, you can individually modify the instance classes  of the DB instances within the green DB cluster.
        public let targetDBInstanceClass: String?
        /// The DB parameter group associated with the DB instance in the green environment. To test parameter changes, specify a DB parameter group that is different from the one associated  with the source DB instance.
        public let targetDBParameterGroupName: String?
        /// The engine version of the database in the green environment. Specify the engine version to upgrade to in the green environment.
        public let targetEngineVersion: String?
        /// Whether to upgrade the storage file system configuration on the green database. This option migrates the green DB instance from the older 32-bit file system to the preferred configuration. For more information, see Upgrading the storage file system for a DB instance.
        public let upgradeTargetStorageConfig: Bool?

        public init(blueGreenDeploymentName: String? = nil, source: String? = nil, tags: [Tag]? = nil, targetDBClusterParameterGroupName: String? = nil, targetDBInstanceClass: String? = nil, targetDBParameterGroupName: String? = nil, targetEngineVersion: String? = nil, upgradeTargetStorageConfig: Bool? = nil) {
            self.blueGreenDeploymentName = blueGreenDeploymentName
            self.source = source
            self.tags = tags
            self.targetDBClusterParameterGroupName = targetDBClusterParameterGroupName
            self.targetDBInstanceClass = targetDBInstanceClass
            self.targetDBParameterGroupName = targetDBParameterGroupName
            self.targetEngineVersion = targetEngineVersion
            self.upgradeTargetStorageConfig = upgradeTargetStorageConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.blueGreenDeploymentName, name: "blueGreenDeploymentName", parent: name, max: 60)
            try self.validate(self.blueGreenDeploymentName, name: "blueGreenDeploymentName", parent: name, min: 1)
            try self.validate(self.blueGreenDeploymentName, name: "blueGreenDeploymentName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.source, name: "source", parent: name, max: 2048)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^arn:[A-Za-z][0-9A-Za-z-:._]*$")
            try self.validate(self.targetDBClusterParameterGroupName, name: "targetDBClusterParameterGroupName", parent: name, max: 255)
            try self.validate(self.targetDBClusterParameterGroupName, name: "targetDBClusterParameterGroupName", parent: name, min: 1)
            try self.validate(self.targetDBClusterParameterGroupName, name: "targetDBClusterParameterGroupName", parent: name, pattern: "^[A-Za-z](?!.*--)[0-9A-Za-z-]*[^-]|^default(?!.*--)(?!.*\\.\\.)[0-9A-Za-z-.]*[^-]$")
            try self.validate(self.targetDBInstanceClass, name: "targetDBInstanceClass", parent: name, max: 20)
            try self.validate(self.targetDBInstanceClass, name: "targetDBInstanceClass", parent: name, min: 5)
            try self.validate(self.targetDBInstanceClass, name: "targetDBInstanceClass", parent: name, pattern: "^db\\.[0-9a-z]{2,6}\\.[0-9a-z]{4,9}$")
            try self.validate(self.targetDBParameterGroupName, name: "targetDBParameterGroupName", parent: name, max: 255)
            try self.validate(self.targetDBParameterGroupName, name: "targetDBParameterGroupName", parent: name, min: 1)
            try self.validate(self.targetDBParameterGroupName, name: "targetDBParameterGroupName", parent: name, pattern: "^[A-Za-z](?!.*--)[0-9A-Za-z-]*[^-]|^default(?!.*--)(?!.*\\.\\.)[0-9A-Za-z-.]*[^-]$")
            try self.validate(self.targetEngineVersion, name: "targetEngineVersion", parent: name, max: 64)
            try self.validate(self.targetEngineVersion, name: "targetEngineVersion", parent: name, min: 1)
            try self.validate(self.targetEngineVersion, name: "targetEngineVersion", parent: name, pattern: "^[0-9A-Za-z-_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeploymentName = "BlueGreenDeploymentName"
            case source = "Source"
            case tags = "Tags"
            case targetDBClusterParameterGroupName = "TargetDBClusterParameterGroupName"
            case targetDBInstanceClass = "TargetDBInstanceClass"
            case targetDBParameterGroupName = "TargetDBParameterGroupName"
            case targetEngineVersion = "TargetEngineVersion"
            case upgradeTargetStorageConfig = "UpgradeTargetStorageConfig"
        }
    }

    public struct CreateBlueGreenDeploymentResponse: AWSDecodableShape {
        public let blueGreenDeployment: BlueGreenDeployment?

        public init(blueGreenDeployment: BlueGreenDeployment? = nil) {
            self.blueGreenDeployment = blueGreenDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeployment = "BlueGreenDeployment"
        }
    }

    public struct CreateCustomDBEngineVersionMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The name of an Amazon S3 bucket that contains database installation files for your CEV. For example, a valid  bucket name is my-custom-installation-files.
        public let databaseInstallationFilesS3BucketName: String?
        /// The Amazon S3 directory that contains the database installation files for your CEV. For example, a valid  bucket name is 123456789012/cev1. If this setting isn't specified, no prefix is assumed.
        public let databaseInstallationFilesS3Prefix: String?
        /// An optional description of your CEV.
        public let description: String?
        /// The database engine to use for your custom engine version (CEV). The only supported value is  custom-oracle-ee.
        public let engine: String?
        /// The name of your CEV. The name format is 19.customized_string. For example, a valid CEV name is 19.my_cev1. This setting is required for RDS Custom for Oracle, but optional for Amazon RDS. The combination of Engine and EngineVersion is unique per customer per Region.
        public let engineVersion: String?
        /// The ID of the Amazon Machine Image (AMI). For RDS Custom for SQL Server, an AMI ID is required  to create a CEV. For RDS Custom for Oracle, the default is the most recent AMI available,  but you can specify an AMI ID that was used in a different Oracle CEV. Find the AMIs  used by your CEVs by calling the DescribeDBEngineVersions operation.
        public let imageId: String?
        /// The Amazon Web Services KMS key identifier for an encrypted CEV. A symmetric encryption KMS key is required for  RDS Custom, but optional for Amazon RDS. If you have an existing symmetric encryption KMS key in your account, you can use it with RDS Custom.  No further action is necessary. If you don't already have a symmetric encryption KMS key in your account,  follow the instructions in  Creating a symmetric encryption KMS key in the Amazon Web Services Key Management Service Developer Guide. You can choose the same symmetric encryption key when you create a CEV and a DB instance, or choose different keys.
        public let kmsKeyId: String?
        /// The CEV manifest, which is a JSON document that describes the installation .zip files stored in Amazon S3.  Specify the name/value pairs in a file or a quoted string. RDS Custom applies the patches in the order in which  they are listed. The following JSON fields are valid:  MediaImportTemplateVersion  Version of the CEV manifest. The date is in the format YYYY-MM-DD.  databaseInstallationFileNames  Ordered list of installation files for the CEV.  opatchFileNames  Ordered list of OPatch installers used for the Oracle DB engine.  psuRuPatchFileNames  The PSU and RU patches for this CEV.  OtherPatchFileNames  The patches that are not in the list of PSU and RU patches.  Amazon RDS applies these patches after applying the PSU and RU patches.   For more information, see  Creating the CEV manifest in the Amazon RDS User Guide.
        public let manifest: String?
        /// The ARN of a CEV to use as a source for creating a new CEV. You can specify a different Amazon Machine Imagine (AMI) by using either Source or UseAwsProvidedLatestImage. You can't specify a different JSON manifest when you specify SourceCustomDbEngineVersionIdentifier.
        public let sourceCustomDbEngineVersionIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// Specifies whether to use the latest service-provided Amazon Machine Image (AMI) for the CEV. If you specify UseAwsProvidedLatestImage, you can't also specify ImageId.
        public let useAwsProvidedLatestImage: Bool?

        public init(databaseInstallationFilesS3BucketName: String? = nil, databaseInstallationFilesS3Prefix: String? = nil, description: String? = nil, engine: String? = nil, engineVersion: String? = nil, imageId: String? = nil, kmsKeyId: String? = nil, manifest: String? = nil, sourceCustomDbEngineVersionIdentifier: String? = nil, tags: [Tag]? = nil, useAwsProvidedLatestImage: Bool? = nil) {
            self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
            self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.imageId = imageId
            self.kmsKeyId = kmsKeyId
            self.manifest = manifest
            self.sourceCustomDbEngineVersionIdentifier = sourceCustomDbEngineVersionIdentifier
            self.tags = tags
            self.useAwsProvidedLatestImage = useAwsProvidedLatestImage
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseInstallationFilesS3BucketName, name: "databaseInstallationFilesS3BucketName", parent: name, max: 63)
            try self.validate(self.databaseInstallationFilesS3BucketName, name: "databaseInstallationFilesS3BucketName", parent: name, min: 3)
            try self.validate(self.databaseInstallationFilesS3BucketName, name: "databaseInstallationFilesS3BucketName", parent: name, pattern: ".*")
            try self.validate(self.databaseInstallationFilesS3Prefix, name: "databaseInstallationFilesS3Prefix", parent: name, max: 255)
            try self.validate(self.databaseInstallationFilesS3Prefix, name: "databaseInstallationFilesS3Prefix", parent: name, min: 1)
            try self.validate(self.databaseInstallationFilesS3Prefix, name: "databaseInstallationFilesS3Prefix", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.engine, name: "engine", parent: name, max: 35)
            try self.validate(self.engine, name: "engine", parent: name, min: 1)
            try self.validate(self.engine, name: "engine", parent: name, pattern: "^[A-Za-z0-9-]{1,35}$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 60)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 1)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^[a-z0-9_.-]{1,60}$")
            try self.validate(self.imageId, name: "imageId", parent: name, max: 255)
            try self.validate(self.imageId, name: "imageId", parent: name, min: 1)
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: ".*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[a-zA-Z0-9_:\\-\\/]+$")
            try self.validate(self.manifest, name: "manifest", parent: name, max: 51000)
            try self.validate(self.manifest, name: "manifest", parent: name, min: 1)
            try self.validate(self.manifest, name: "manifest", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.sourceCustomDbEngineVersionIdentifier, name: "sourceCustomDbEngineVersionIdentifier", parent: name, max: 255)
            try self.validate(self.sourceCustomDbEngineVersionIdentifier, name: "sourceCustomDbEngineVersionIdentifier", parent: name, min: 1)
            try self.validate(self.sourceCustomDbEngineVersionIdentifier, name: "sourceCustomDbEngineVersionIdentifier", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
            case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
            case description = "Description"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case imageId = "ImageId"
            case kmsKeyId = "KMSKeyId"
            case manifest = "Manifest"
            case sourceCustomDbEngineVersionIdentifier = "SourceCustomDbEngineVersionIdentifier"
            case tags = "Tags"
            case useAwsProvidedLatestImage = "UseAwsProvidedLatestImage"
        }
    }

    public struct CreateDBClusterEndpointMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The identifier to use for the new endpoint. This parameter is stored as a lowercase string.
        public let dbClusterEndpointIdentifier: String?
        /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
        public let dbClusterIdentifier: String?
        /// The type of the endpoint, one of: READER, WRITER, ANY.
        public let endpointType: String?
        /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. This parameter is relevant only if the list of static members is empty.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var excludedMembers: [String]?
        /// List of DB instance identifiers that are part of the custom endpoint group.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var staticMembers: [String]?
        /// The tags to be assigned to the Amazon RDS resource.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbClusterEndpointIdentifier: String? = nil, dbClusterIdentifier: String? = nil, endpointType: String? = nil, excludedMembers: [String]? = nil, staticMembers: [String]? = nil, tags: [Tag]? = nil) {
            self.dbClusterEndpointIdentifier = dbClusterEndpointIdentifier
            self.dbClusterIdentifier = dbClusterIdentifier
            self.endpointType = endpointType
            self.excludedMembers = excludedMembers
            self.staticMembers = staticMembers
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case endpointType = "EndpointType"
            case excludedMembers = "ExcludedMembers"
            case staticMembers = "StaticMembers"
            case tags = "Tags"
        }
    }

    public struct CreateDBClusterMessage: AWSEncodableShape {
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster. Valid for Cluster Type: Multi-AZ DB clusters only This setting is required to create a Multi-AZ DB cluster.
        public let allocatedStorage: Int?
        /// Specifies whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window.  By default, minor engine upgrades are applied automatically. Valid for Cluster Type: Multi-AZ DB clusters only
        public let autoMinorVersionUpgrade: Bool?
        /// A list of Availability Zones (AZs) where DB instances in the DB cluster can be created. For information on Amazon Web Services Regions and Availability Zones, see  Choosing the Regions and  Availability Zones in the Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters only
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, String>>
        public var availabilityZones: [String]?
        /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Valid for Cluster Type: Aurora MySQL DB clusters only Default: 0  Constraints:   If specified, this value must be set to a number from 0 to 259,200 (72 hours).
        public let backtrackWindow: Int64?
        /// The number of days for which automated backups are retained. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Default: 1  Constraints:   Must be a value from 1 to 35.
        public let backupRetentionPeriod: Int?
        /// The CA certificate identifier to use for the DB cluster's server certificate. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide. Valid for Cluster Type: Multi-AZ DB clusters
        public let caCertificateIdentifier: String?
        /// The name of the character set (CharacterSet) to associate the DB cluster with. Valid for Cluster Type: Aurora DB clusters only
        public let characterSetName: String?
        /// Specifies whether to copy all tags from the DB cluster to snapshots of the DB cluster.  The default is not to copy them. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let copyTagsToSnapshot: Bool?
        /// The name for your database of up to 64 alphanumeric characters. If you don't provide a name, Amazon RDS doesn't create a database in the DB cluster you are creating. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let databaseName: String?
        /// The identifier for this DB cluster. This parameter is stored as a lowercase string. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must contain from 1 to 63 (for Aurora DB clusters) or 1 to 52 (for Multi-AZ DB clusters) letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster1
        public let dbClusterIdentifier: String?
        /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see DB instance class in the Amazon RDS User Guide. This setting is required to create a Multi-AZ DB cluster. Valid for Cluster Type: Multi-AZ DB clusters only
        public let dbClusterInstanceClass: String?
        /// The name of the DB cluster parameter group to associate with this DB cluster. If you don't specify a value, then  the default DB cluster parameter group for the specified DB engine and version is used. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   If supplied, must match the name of an existing DB cluster parameter group.
        public let dbClusterParameterGroupName: String?
        /// A DB subnet group to associate with this DB cluster. This setting is required to create a Multi-AZ DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must match the name of an existing DB subnet group.   Must not be default.   Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Reserved for future use.
        public let dbSystemId: String?
        /// Specifies whether the DB cluster has deletion protection enabled.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to create the DB cluster in. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster. For more information, see Kerberos authentication in the Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters only
        public let domain: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. Valid for Cluster Type: Aurora DB clusters only
        public let domainIAMRoleName: String?
        /// The list of log types that need to be enabled for exporting to CloudWatch Logs. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters The following values are valid for each DB engine:   Aurora MySQL - audit | error | general | slowquery    Aurora PostgreSQL - postgresql    RDS for MySQL - error | general | slowquery    RDS for PostgreSQL - postgresql | upgrade    For more information about exporting CloudWatch Logs for Amazon RDS, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. For more information about exporting CloudWatch Logs for Amazon Aurora, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable this DB cluster to forward write operations to the primary cluster of a global cluster (Aurora global database). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database. You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter enabled, a secondary cluster can forward writes to the current primary cluster, and the resulting changes are replicated back to this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is demoted by a global cluster API operation, but it does nothing until then. Valid for Cluster Type: Aurora DB clusters only
        public let enableGlobalWriteForwarding: Bool?
        /// Specifies whether to enable the HTTP endpoint for the DB cluster. By default, the HTTP endpoint  isn't enabled. When enabled, the HTTP endpoint provides a connectionless web service API (RDS Data API) for running SQL queries on the DB cluster. You can also query your database from inside the RDS console with the RDS query editor. RDS Data API is supported with the following DB clusters:   Aurora PostgreSQL Serverless v2 and provisioned   Aurora PostgreSQL and Aurora MySQL Serverless v1   For more information, see Using RDS Data API in the  Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters only
        public let enableHttpEndpoint: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see   IAM Database Authentication in the Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters only
        public let enableIAMDatabaseAuthentication: Bool?
        /// Specifies whether to enable Aurora Limitless Database. You must enable Aurora Limitless Database to create a DB shard group. Valid for: Aurora DB clusters only
        public let enableLimitlessDatabase: Bool?
        /// Specifies whether read replicas can forward write operations to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances. Valid for: Aurora DB clusters only
        public let enableLocalWriteForwarding: Bool?
        /// Specifies whether to turn on Performance Insights for the DB cluster. For more information, see  Using Amazon Performance Insights in the Amazon RDS User Guide. Valid for Cluster Type: Multi-AZ DB clusters only
        public let enablePerformanceInsights: Bool?
        /// The database engine to use for this DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Valid Values: aurora-mysql | aurora-postgresql | mysql | postgres
        public let engine: String?
        /// The DB engine mode of the DB cluster, either provisioned or serverless. The serverless engine mode only applies for Aurora Serverless v1 DB clusters. For information about limitations and requirements for Serverless DB clusters, see the  following sections in the Amazon Aurora User Guide:    Limitations of Aurora Serverless v1     Requirements for Aurora Serverless v2    Valid for Cluster Type: Aurora DB clusters only
        public let engineMode: String?
        /// The version number of the database engine to use. To list all of the available engine versions for Aurora MySQL version 2 (5.7-compatible) and version 3 (MySQL 8.0-compatible), use the following command:  aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"  You can supply either 5.7 or 8.0 to use the default engine version for Aurora MySQL version 2 or version 3, respectively. To list all of the available engine versions for Aurora PostgreSQL, use the following command:  aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for RDS for MySQL, use the following command:  aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for RDS for PostgreSQL, use the following command:  aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"  For information about a specific engine, see the following topics:   Aurora MySQL - see Database engine updates for Amazon Aurora MySQL in the  Amazon Aurora User Guide.   Aurora PostgreSQL - see Amazon Aurora PostgreSQL releases and engine versions in the  Amazon Aurora User Guide.   RDS for MySQL - see Amazon RDS for MySQL in the Amazon RDS User Guide.   RDS for PostgreSQL - see Amazon RDS for PostgreSQL in the Amazon RDS User Guide.   Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let engineVersion: String?
        /// The global cluster ID of an Aurora cluster that becomes the primary cluster in the new global database cluster. Valid for Cluster Type: Aurora DB clusters only
        public let globalClusterIdentifier: String?
        /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated  for each DB instance in the Multi-AZ DB cluster. For information about valid IOPS values, see Provisioned IOPS storage in the Amazon RDS User Guide. This setting is required to create a Multi-AZ DB cluster. Valid for Cluster Type: Multi-AZ DB clusters only Constraints:   Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
        public let iops: Int?
        /// The Amazon Web Services KMS key identifier for an encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. When a KMS key isn't specified in KmsKeyId:   If ReplicationSourceIdentifier identifies an encrypted source, then Amazon RDS uses the KMS key used to encrypt the source. Otherwise, Amazon RDS uses your default KMS key.   If the StorageEncrypted parameter is enabled and ReplicationSourceIdentifier isn't specified, then Amazon RDS uses your default KMS key.   There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. If you create a read replica of an encrypted DB cluster in another Amazon Web Services Region, make sure to set KmsKeyId to a KMS key identifier that is valid in the destination Amazon Web Services Region. This KMS key is used to encrypt the read replica in that Amazon Web Services Region. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let kmsKeyId: String?
        /// Specifies whether to manage the master user password with Amazon Web Services Secrets Manager. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide and Password management with Amazon Web Services Secrets Manager  in the Amazon Aurora User Guide.  Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword  is specified.
        public let manageMasterUserPassword: Bool?
        /// The name of the master user for the DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must be 1 to 16 letters or numbers.   First character must be a letter.   Can't be a reserved word for the chosen database engine.
        public let masterUsername: String?
        /// The password for the master database user. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must contain from 8 to 41 characters.   Can contain any printable ASCII character except "/", """, or "@".   Can't be specified if ManageMasterUserPassword is turned on.
        public let masterUserPassword: String?
        /// The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and  managed in Amazon Web Services Secrets Manager. This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets  Manager for the DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If you don't specify MasterUserSecretKmsKeyId, then the aws/secretsmanager  KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't  use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer  managed KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let masterUserSecretKmsKeyId: String?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off  collecting Enhanced Monitoring metrics, specify 0. If MonitoringRoleArn is specified, also set MonitoringInterval to a value other than 0. Valid for Cluster Type: Multi-AZ DB clusters only Valid Values: 0 | 1 | 5 | 10 | 15 | 30 | 60  Default: 0
        public let monitoringInterval: Int?
        /// The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.  An example is arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see Setting  up and enabling Enhanced Monitoring in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn value. Valid for Cluster Type: Multi-AZ DB clusters only
        public let monitoringRoleArn: String?
        /// The network type of the DB cluster. The network type is determined by the DBSubnetGroup specified for the DB cluster.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon Aurora User Guide.  Valid for Cluster Type: Aurora DB clusters only Valid Values: IPV4 | DUAL
        public let networkType: String?
        /// The option group to associate the DB cluster with. DB clusters are associated with a default option group that can't be modified.
        public let optionGroupName: String?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS  uses your default KMS key. There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Valid for Cluster Type: Multi-AZ DB clusters only
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. Valid for Cluster Type: Multi-AZ DB clusters only Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days If you specify a retention period that isn't valid, such as 94,  Amazon RDS issues an error.
        public let performanceInsightsRetentionPeriod: Int?
        /// The port number on which the instances in the DB cluster accept connections. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Valid Values: 1150-65535  Default:   RDS for MySQL and Aurora MySQL - 3306    RDS for PostgreSQL and Aurora PostgreSQL - 5432
        public let port: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region.  To view the time blocks available, see   Backup window in the Amazon Aurora User Guide. Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see   Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide. Constraints:   Must be in the format ddd:hh24:mi-ddd:hh24:mi.   Days must be one of Mon | Tue | Wed | Thu | Fri | Sat | Sun.   Must be in Universal Coordinated Time (UTC).   Must be at least 30 minutes.
        public let preferredMaintenanceWindow: String?
        /// When you are replicating a DB cluster from one Amazon Web Services GovCloud (US) Region to another, an URL that contains a Signature Version 4 signed request for the CreateDBCluster operation to be called in the source Amazon Web Services Region where the DB cluster is replicated from. Specify PreSignedUrl only when you are performing cross-Region replication from an encrypted DB cluster. The presigned URL must be a valid request for the CreateDBCluster API operation that can run in the source Amazon Web Services Region that contains the encrypted DB cluster to copy. The presigned URL request must contain the following parameter values:    KmsKeyId - The KMS key identifier for the KMS key to use to encrypt the copy of the DB cluster in the destination Amazon Web Services Region. This should refer to the same KMS key for both the CreateDBCluster operation that is called in the destination Amazon Web Services Region, and the operation contained in the presigned URL.    DestinationRegion - The name of the Amazon Web Services Region that Aurora read replica will be created in.    ReplicationSourceIdentifier - The DB cluster identifier for the encrypted DB cluster to be copied.  This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are copying an  encrypted DB cluster from the us-west-2 Amazon Web Services Region, then your ReplicationSourceIdentifier would look like Example: arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1.   To learn how to generate a Signature Version 4 signed request, see   Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and  Signature Version 4 Signing Process.  If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can run in the source Amazon Web Services Region.  Valid for Cluster Type: Aurora DB clusters only
        public let preSignedUrl: String?
        /// Specifies whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Valid for Cluster Type: Multi-AZ DB clusters only Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:   If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB cluster is private.   If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.   If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:   If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB cluster is private.   If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.
        public let publiclyAccessible: Bool?
        /// Reserved for future use.
        public let rdsCustomClusterConfiguration: RdsCustomClusterConfiguration?
        /// The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let replicationSourceIdentifier: String?
        /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster. Valid for Cluster Type: Aurora DB clusters only
        public let scalingConfiguration: ScalingConfiguration?
        public let serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration?
        /// Specifies whether the DB cluster is encrypted. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let storageEncrypted: Bool?
        /// The storage type to associate with the DB cluster. For information on storage types for Aurora DB clusters, see Storage configurations for Amazon Aurora DB clusters. For information on storage types for Multi-AZ DB clusters, see Settings for creating Multi-AZ DB clusters. This setting is required to create a Multi-AZ DB cluster. When specified for a Multi-AZ DB cluster, a value for the Iops parameter is required. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Valid Values:   Aurora DB clusters - aurora | aurora-iopt1    Multi-AZ DB clusters - io1 | io2 | gp3    Default:   Aurora DB clusters - aurora    Multi-AZ DB clusters - io1     When you create an Aurora DB cluster with the storage type set to aurora-iopt1, the storage type is returned in the response. The storage type isn't returned when you set it to aurora.
        public let storageType: String?
        /// Tags to assign to the DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// A list of EC2 VPC security groups to associate with this DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZones: [String]? = nil, backtrackWindow: Int64? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, characterSetName: String? = nil, copyTagsToSnapshot: Bool? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, dbClusterInstanceClass: String? = nil, dbClusterParameterGroupName: String? = nil, dbSubnetGroupName: String? = nil, dbSystemId: String? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainIAMRoleName: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableGlobalWriteForwarding: Bool? = nil, enableHttpEndpoint: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, enableLimitlessDatabase: Bool? = nil, enableLocalWriteForwarding: Bool? = nil, enablePerformanceInsights: Bool? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, globalClusterIdentifier: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, manageMasterUserPassword: Bool? = nil, masterUsername: String? = nil, masterUserPassword: String? = nil, masterUserSecretKmsKeyId: String? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, networkType: String? = nil, optionGroupName: String? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, preSignedUrl: String? = nil, publiclyAccessible: Bool? = nil, rdsCustomClusterConfiguration: RdsCustomClusterConfiguration? = nil, replicationSourceIdentifier: String? = nil, scalingConfiguration: ScalingConfiguration? = nil, serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration? = nil, storageEncrypted: Bool? = nil, storageType: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZones = availabilityZones
            self.backtrackWindow = backtrackWindow
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterInstanceClass = dbClusterInstanceClass
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dbSystemId = dbSystemId
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainIAMRoleName = domainIAMRoleName
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
            self.enableHttpEndpoint = enableHttpEndpoint
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.enableLimitlessDatabase = enableLimitlessDatabase
            self.enableLocalWriteForwarding = enableLocalWriteForwarding
            self.enablePerformanceInsights = enablePerformanceInsights
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.globalClusterIdentifier = globalClusterIdentifier
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.manageMasterUserPassword = manageMasterUserPassword
            self.masterUsername = masterUsername
            self.masterUserPassword = masterUserPassword
            self.masterUserSecretKmsKeyId = masterUserSecretKmsKeyId
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.preSignedUrl = preSignedUrl
            self.publiclyAccessible = publiclyAccessible
            self.rdsCustomClusterConfiguration = rdsCustomClusterConfiguration
            self.replicationSourceIdentifier = replicationSourceIdentifier
            self.scalingConfiguration = scalingConfiguration
            self.serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZones = "AvailabilityZones"
            case backtrackWindow = "BacktrackWindow"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case characterSetName = "CharacterSetName"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case databaseName = "DatabaseName"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterInstanceClass = "DBClusterInstanceClass"
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dbSystemId = "DBSystemId"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainIAMRoleName = "DomainIAMRoleName"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableGlobalWriteForwarding = "EnableGlobalWriteForwarding"
            case enableHttpEndpoint = "EnableHttpEndpoint"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case enableLimitlessDatabase = "EnableLimitlessDatabase"
            case enableLocalWriteForwarding = "EnableLocalWriteForwarding"
            case enablePerformanceInsights = "EnablePerformanceInsights"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case manageMasterUserPassword = "ManageMasterUserPassword"
            case masterUsername = "MasterUsername"
            case masterUserPassword = "MasterUserPassword"
            case masterUserSecretKmsKeyId = "MasterUserSecretKmsKeyId"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case preSignedUrl = "PreSignedUrl"
            case publiclyAccessible = "PubliclyAccessible"
            case rdsCustomClusterConfiguration = "RdsCustomClusterConfiguration"
            case replicationSourceIdentifier = "ReplicationSourceIdentifier"
            case scalingConfiguration = "ScalingConfiguration"
            case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
            case storageEncrypted = "StorageEncrypted"
            case storageType = "StorageType"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct CreateDBClusterParameterGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The name of the DB cluster parameter group. Constraints:   Must not match the name of an existing DB cluster parameter group.    This value is stored as a lowercase string.
        public let dbClusterParameterGroupName: String?
        /// The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster  parameter group family, and can be applied only to a DB cluster running a database engine and engine version compatible with that DB cluster parameter group family.  Aurora MySQL  Example: aurora-mysql5.7, aurora-mysql8.0   Aurora PostgreSQL  Example: aurora-postgresql14   RDS for MySQL  Example: mysql8.0   RDS for PostgreSQL  Example: postgres13  To list all of the available parameter group families for a DB engine, use the following command:  aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine   For example, to list all of the available parameter group families for the Aurora PostgreSQL DB engine, use the following command:  aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine aurora-postgresql   The output contains duplicates.  The following are the valid DB engine values:    aurora-mysql     aurora-postgresql     mysql     postgres
        public let dbParameterGroupFamily: String?
        /// The description for the DB cluster parameter group.
        public let description: String?
        /// Tags to assign to the DB cluster parameter group.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbClusterParameterGroupName: String? = nil, dbParameterGroupFamily: String? = nil, description: String? = nil, tags: [Tag]? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.description = description
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case description = "Description"
            case tags = "Tags"
        }
    }

    public struct CreateDBClusterParameterGroupResult: AWSDecodableShape {
        public let dbClusterParameterGroup: DBClusterParameterGroup?

        public init(dbClusterParameterGroup: DBClusterParameterGroup? = nil) {
            self.dbClusterParameterGroup = dbClusterParameterGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroup = "DBClusterParameterGroup"
        }
    }

    public struct CreateDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct CreateDBClusterSnapshotMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The identifier of the DB cluster to create a snapshot for. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing DBCluster.   Example: my-cluster1
        public let dbClusterIdentifier: String?
        /// The identifier of the DB cluster snapshot. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster1-snapshot1
        public let dbClusterSnapshotIdentifier: String?
        /// The tags to be assigned to the DB cluster snapshot.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbClusterIdentifier: String? = nil, dbClusterSnapshotIdentifier: String? = nil, tags: [Tag]? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
            case tags = "Tags"
        }
    }

    public struct CreateDBClusterSnapshotResult: AWSDecodableShape {
        public let dbClusterSnapshot: DBClusterSnapshot?

        public init(dbClusterSnapshot: DBClusterSnapshot? = nil) {
            self.dbClusterSnapshot = dbClusterSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshot = "DBClusterSnapshot"
        }
    }

    public struct CreateDBInstanceMessage: AWSEncodableShape {
        public struct _DBSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroupName" }
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage in gibibytes (GiB) to allocate for the DB instance. This setting doesn't apply to Amazon Aurora DB instances. Aurora cluster volumes automatically grow as the amount of data in your  database increases, though you are only charged for the space that you use in an Aurora cluster volume.  Amazon RDS Custom  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp2, gp3): Must be an integer from 40 to 65536 for RDS Custom for Oracle,  16384 for RDS Custom for SQL Server.   Provisioned IOPS storage (io1, io2): Must be an integer from 40 to 65536 for RDS Custom for Oracle,  16384 for RDS Custom for SQL Server.    RDS for Db2  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp3): Must be an integer from 20 to 65536.   Provisioned IOPS storage (io1, io2): Must be an integer from 100 to 65536.    RDS for MariaDB  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.   Provisioned IOPS storage (io1, io2): Must be an integer from 100 to 65536.   Magnetic storage (standard): Must be an integer from 5 to 3072.    RDS for MySQL  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.   Provisioned IOPS storage (io1, io2): Must be an integer from 100 to 65536.   Magnetic storage (standard): Must be an integer from 5 to 3072.    RDS for Oracle  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.   Provisioned IOPS storage (io1, io2): Must be an integer from 100 to 65536.   Magnetic storage (standard): Must be an integer from 10 to 3072.    RDS for PostgreSQL  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp2, gp3): Must be an integer from 20 to 65536.   Provisioned IOPS storage (io1, io2): Must be an integer from 100 to 65536.   Magnetic storage (standard): Must be an integer from 5 to 3072.    RDS for SQL Server  Constraints to the amount of storage for each storage type are the following:   General Purpose (SSD) storage (gp2, gp3):   Enterprise and Standard editions: Must be an integer from 20 to 16384.   Web and Express editions: Must be an integer from 20 to 16384.     Provisioned IOPS storage (io1, io2):   Enterprise and Standard editions: Must be an integer from 100 to 16384.   Web and Express editions: Must be an integer from 100 to 16384.     Magnetic storage (standard):   Enterprise and Standard editions: Must be an integer from 20 to 1024.   Web and Express editions: Must be an integer from 20 to 1024.
        public let allocatedStorage: Int?
        /// Specifies whether minor engine upgrades are applied automatically to the DB instance during the maintenance window.  By default, minor engine upgrades are applied automatically. If you create an RDS Custom DB instance, you must set AutoMinorVersionUpgrade to  false.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone (AZ) where the database will be created. For information on Amazon Web Services Regions and Availability Zones, see  Regions and Availability Zones. For Amazon Aurora, each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these  Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one. Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region. Constraints:   The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment.   The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint.   Example: us-east-1d
        public let availabilityZone: String?
        /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables  backups. Setting this parameter to 0 disables automated backups. This setting doesn't apply to Amazon Aurora DB instances. The retention period for automated backups is managed by the DB cluster. Default: 1  Constraints:   Must be a value from 0 to 35.   Can't be set to 0 if the DB instance is a source to read replicas.   Can't be set to 0 for an RDS Custom for Oracle DB instance.
        public let backupRetentionPeriod: Int?
        /// The location for storing automated backups and manual snapshots. Valid Values:    outposts (Amazon Web Services Outposts)    region (Amazon Web Services Region)   Default: region  For more information, see Working  with Amazon RDS on Amazon Web Services Outposts in the Amazon RDS User Guide.
        public let backupTarget: String?
        /// The CA certificate identifier to use for the DB instance's server certificate. This setting doesn't apply to RDS Custom DB instances. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide and   Using SSL/TLS to encrypt a connection to a DB cluster in the Amazon Aurora  User Guide.
        public let caCertificateIdentifier: String?
        /// For supported engines, the character set (CharacterSet) to associate the DB instance with. This setting doesn't apply to the following DB instances:   Amazon Aurora - The character set is managed by the DB cluster. For more information, see CreateDBCluster.   RDS Custom - However, if you need to change the character set,  you can change it on the database itself.
        public let characterSetName: String?
        /// Specifies whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. This setting doesn't apply to Amazon Aurora DB instances. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
        public let copyTagsToSnapshot: Bool?
        /// The instance profile associated with the underlying Amazon EC2 instance of an  RDS Custom DB instance. This setting is required for RDS Custom. Constraints:   The profile must exist in your account.   The profile must have an IAM role that Amazon EC2 has permissions to assume.   The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.   For the list of permissions required for the IAM role, see   Configure IAM and your VPC in the Amazon RDS User Guide.
        public let customIamInstanceProfile: String?
        /// The identifier of the DB cluster that this DB instance will belong to. This setting doesn't apply to RDS Custom DB instances.
        public let dbClusterIdentifier: String?
        /// The compute and memory capacity of the DB instance, for example db.m5.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB instance  classes in the Amazon RDS User Guide or  Aurora  DB instance classes in the Amazon Aurora User Guide.
        public let dbInstanceClass: String?
        /// The identifier for this DB instance. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: mydbinstance
        public let dbInstanceIdentifier: String?
        /// The meaning of this parameter differs according to the database engine you use.  Amazon Aurora MySQL  The name of the database to create when the primary DB instance of the Aurora MySQL DB cluster is created. If this parameter isn't specified for an Aurora MySQL DB cluster, no database is created  in the DB cluster. Constraints:   Must contain 1 to 64 alphanumeric characters.   Can't be a word reserved by the database engine.    Amazon Aurora PostgreSQL  The name of the database to create when the primary DB instance of the Aurora PostgreSQL DB cluster is created. If this parameter isn't specified for an Aurora PostgreSQL DB cluster,  a database named postgres is created in the DB cluster. Constraints:   It must contain 1 to 63 alphanumeric characters.   Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0 to 9).   Can't be a word reserved by the database engine.    Amazon RDS Custom for Oracle  The Oracle System ID (SID) of the created RDS Custom DB instance. If you don't specify a value, the default value is ORCL for non-CDBs and RDSCDB for CDBs. Default: ORCL  Constraints:   Must contain 1 to 8 alphanumeric characters.   Must contain a letter.   Can't be a word reserved by the database engine.    Amazon RDS Custom for SQL Server  Not applicable. Must be null.  RDS for Db2  The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. In some cases, we recommend that you don't add a database name. For more information, see Additional considerations in the Amazon RDS User Guide. Constraints:   Must contain 1 to 64 letters or numbers.   Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).   Can't be a word reserved by the specified database engine.    RDS for MariaDB  The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. Constraints:   Must contain 1 to 64 letters or numbers.   Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).   Can't be a word reserved by the specified database engine.    RDS for MySQL  The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. Constraints:   Must contain 1 to 64 letters or numbers.   Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).   Can't be a word reserved by the specified database engine.    RDS for Oracle  The Oracle System ID (SID) of the created DB instance. If you don't specify a value,  the default value is ORCL. You can't specify the  string null, or any other reserved word, for DBName. Default: ORCL  Constraints:   Can't be longer than 8 characters.    RDS for PostgreSQL  The name of the database to create when the DB instance is created. If this parameter isn't specified, a database named postgres  is created in the DB instance. Constraints:   Must contain 1 to 63 letters, numbers, or underscores.   Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).   Can't be a word reserved by the specified database engine.    RDS for SQL Server  Not applicable. Must be null.
        public let dbName: String?
        /// The name of the DB parameter group to associate with this DB instance. If you don't specify a value, then  Amazon RDS uses the default DB parameter group for the specified DB engine and version. This setting doesn't apply to RDS Custom DB instances. Constraints:   Must be 1 to 255 letters, numbers, or hyphens.   The first character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.
        public let dbParameterGroupName: String?
        /// A list of DB security groups to associate with this DB instance. This setting applies to the legacy EC2-Classic platform, which is no longer used to create  new DB instances. Use the VpcSecurityGroupIds setting instead.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupsEncoding, String>>
        public var dbSecurityGroups: [String]?
        /// A DB subnet group to associate with this DB instance. Constraints:   Must match the name of an existing DB subnet group.   Must not be default.   Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// The Oracle system identifier (SID), which is the name of the Oracle database instance that  manages your database files. In this context, the term "Oracle database instance" refers exclusively  to the system global area (SGA) and Oracle background processes. If you don't specify a SID,  the value defaults to RDSCDB. The Oracle SID is also the name of your CDB.
        public let dbSystemId: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        public let dedicatedLogVolume: Bool?
        /// Specifies whether the DB instance has deletion protection enabled.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. For more information, see   Deleting a DB Instance. This setting doesn't apply to Amazon Aurora DB instances. You can enable or disable deletion protection for the DB cluster.  For more information, see CreateDBCluster. DB instances in a DB  cluster can be deleted even when deletion protection is enabled for the DB cluster.
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to create the DB instance in. Currently, you can create only Db2, MySQL, Microsoft SQL  Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. For more information, see  Kerberos Authentication in the Amazon RDS User Guide. This setting doesn't apply to the following DB instances:   Amazon Aurora (The domain is managed by the DB cluster.)   RDS Custom
        public let domain: String?
        /// The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Example: arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456
        public let domainAuthSecretArn: String?
        /// The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:   Two IP addresses must be provided.  If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: 123.124.125.126,234.235.236.237
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var domainDnsIps: [String]?
        /// The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:   Can't be longer than 64 characters.   Example: mymanagedADtest.mymanagedAD.mydomain
        public let domainFqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to the following DB instances:   Amazon Aurora (The domain is managed by the DB cluster.)   RDS Custom
        public let domainIAMRoleName: String?
        /// The Active Directory organizational unit for your DB instance to join. Constraints:   Must be in the distinguished name format.   Can't be longer than 64 characters.   Example: OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain
        public let domainOu: String?
        /// The list of log types to enable for exporting to CloudWatch Logs. For more information, see   Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. This setting doesn't apply to the following DB instances:   Amazon Aurora (CloudWatch Logs exports are managed by the DB cluster.)   RDS Custom   The following values are valid for each DB engine:   RDS for Db2 - diag.log | notify.log    RDS for MariaDB - audit | error | general | slowquery    RDS for Microsoft SQL Server - agent | error    RDS for MySQL - audit | error | general | slowquery    RDS for Oracle - alert | audit | listener | trace | oemagent    RDS for PostgreSQL - postgresql | upgrade
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide. For more information about CoIPs, see Customer-owned IP addresses  in the Amazon Web Services Outposts User Guide.
        public let enableCustomerOwnedIp: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see   IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide. This setting doesn't apply to the following DB instances:   Amazon Aurora (Mapping Amazon Web Services IAM accounts to database accounts is managed by the DB cluster.)   RDS Custom
        public let enableIAMDatabaseAuthentication: Bool?
        /// Specifies whether to enable Performance Insights for the DB instance. For more information, see  Using Amazon Performance Insights in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let enablePerformanceInsights: Bool?
        /// The database engine to use for this DB instance. Not every database engine is available in every Amazon Web Services Region. Valid Values:    aurora-mysql (for Aurora MySQL DB instances)    aurora-postgresql (for Aurora PostgreSQL DB instances)    custom-oracle-ee (for RDS Custom for Oracle DB instances)    custom-oracle-ee-cdb (for RDS Custom for Oracle DB instances)    custom-sqlserver-ee (for RDS Custom for SQL Server DB instances)    custom-sqlserver-se (for RDS Custom for SQL Server DB instances)    custom-sqlserver-web (for RDS Custom for SQL Server DB instances)    db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engine: String?
        /// The version number of the database engine to use. This setting doesn't apply to Amazon Aurora DB instances. The version number of the database engine the DB instance uses is managed by the DB cluster. For a list of valid engine versions, use the DescribeDBEngineVersions operation. The following are the database engines and links to information about the major and minor versions that are available with  Amazon RDS. Not every database engine is available for every Amazon Web Services Region.  Amazon RDS Custom for Oracle  A custom engine version (CEV) that you have previously created. This setting is required for RDS Custom for Oracle. The CEV  name has the following format: 19.customized_string. A valid CEV name is   19.my_cev1. For more information, see  Creating an RDS Custom for Oracle DB instance in the Amazon RDS User Guide.  Amazon RDS Custom for SQL Server  See RDS Custom for SQL Server general requirements  in the Amazon RDS User Guide.  RDS for Db2  For information, see Db2 on Amazon RDS versions in the  Amazon RDS User Guide.  RDS for MariaDB  For information, see MariaDB on Amazon RDS versions in the  Amazon RDS User Guide.  RDS for Microsoft SQL Server  For information, see Microsoft SQL Server versions on Amazon RDS in the  Amazon RDS User Guide.  RDS for MySQL  For information, see MySQL on Amazon RDS versions in the  Amazon RDS User Guide.  RDS for Oracle  For information, see Oracle Database Engine release notes in the  Amazon RDS User Guide.  RDS for PostgreSQL  For information, see Amazon RDS for PostgreSQL versions and extensions in the  Amazon RDS User Guide.
        public let engineVersion: String?
        /// The amount of Provisioned IOPS (input/output operations per second) to initially allocate for the DB instance. For information about valid IOPS values, see  Amazon RDS DB instance storage  in the Amazon RDS User Guide. This setting doesn't apply to Amazon Aurora DB instances. Storage is managed by the DB cluster. Constraints:   For RDS for Db2, MariaDB, MySQL, Oracle, and PostgreSQL - Must be a multiple between .5 and 50  of the storage amount for the DB instance.   For RDS for SQL Server - Must be a multiple between 1 and 50 of the storage amount for the DB instance.
        public let iops: Int?
        /// The Amazon Web Services KMS key identifier for an encrypted DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. This setting doesn't apply to Amazon Aurora DB instances. The Amazon Web Services KMS key identifier is managed by the DB cluster. For more information, see CreateDBCluster. If StorageEncrypted is enabled, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS uses your default KMS key. There is a   default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. For Amazon RDS Custom, a KMS key is required for DB instances. For most RDS engines, if you leave this parameter empty  while enabling StorageEncrypted, the engine uses the default KMS key. However, RDS Custom  doesn't use the default key when this parameter is empty. You must explicitly specify a key.
        public let kmsKeyId: String?
        /// The license model information for this DB instance. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances. Valid Values:   RDS for Db2 - bring-your-own-license    RDS for MariaDB - general-public-license    RDS for Microsoft SQL Server - license-included    RDS for MySQL - general-public-license    RDS for Oracle - bring-your-own-license | license-included    RDS for PostgreSQL - postgresql-license
        public let licenseModel: String?
        /// Specifies whether to manage the master user password with Amazon Web Services Secrets Manager. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide.  Constraints:   Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword  is specified.
        public let manageMasterUserPassword: Bool?
        /// The name for the master user. This setting doesn't apply to Amazon Aurora DB instances. The name for the master user is managed by the DB cluster. This setting is required for RDS DB instances. Constraints:   Must be 1 to 16 letters, numbers, or underscores.   First character must be a letter.   Can't be a reserved word for the chosen database engine.
        public let masterUsername: String?
        /// The password for the master user. This setting doesn't apply to Amazon Aurora DB instances. The password for the master user is managed by the DB cluster. Constraints:   Can't be specified if ManageMasterUserPassword is turned on.   Can include any printable ASCII character except "/", """, or "@". For RDS for Oracle, can't include the "&" (ampersand) or  the "'" (single quotes) character.   Length Constraints:   RDS for Db2 - Must contain from 8 to 255 characters.   RDS for MariaDB - Must contain from 8 to 41 characters.   RDS for Microsoft SQL Server - Must contain from 8 to 128 characters.   RDS for MySQL - Must contain from 8 to 41 characters.   RDS for Oracle - Must contain from 8 to 30 characters.   RDS for PostgreSQL - Must contain from 8 to 128 characters.
        public let masterUserPassword: String?
        /// The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and  managed in Amazon Web Services Secrets Manager. This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets  Manager for the DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If you don't specify MasterUserSecretKmsKeyId, then the aws/secretsmanager  KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't  use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer  managed KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let masterUserSecretKmsKeyId: String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see   Managing capacity automatically with Amazon RDS storage autoscaling  in the Amazon RDS User Guide. This setting doesn't apply to the following DB instances:   Amazon Aurora (Storage is managed by the DB cluster.)   RDS Custom
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for  the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. If MonitoringRoleArn is specified, then you must set MonitoringInterval to a value other than 0. This setting doesn't apply to RDS Custom DB instances. Valid Values: 0 | 1 | 5 | 10 | 15 | 30 | 60  Default: 0
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see Setting Up and Enabling Enhanced Monitoring  in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value. This setting doesn't apply to RDS Custom DB instances.
        public let monitoringRoleArn: String?
        /// Specifies whether the DB instance is a Multi-AZ deployment. You can't set  the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment. This setting doesn't apply to the following DB instances:   Amazon Aurora (DB instance Availability Zones (AZs) are managed by the DB cluster.)   RDS Custom
        public let multiAZ: Bool?
        /// Specifies whether to use the multi-tenant configuration or the single-tenant configuration (default). This parameter only applies to RDS for Oracle container database (CDB) engines. Note the following restrictions:    The DB engine that you specify in the request must support the multi-tenant configuration. If you attempt to enable the multi-tenant configuration on a DB engine that doesn't support it, the request fails.   If you specify the multi-tenant configuration when you create your DB instance, you can't later modify this DB instance to use the single-tenant configuration.
        public let multiTenant: Bool?
        /// The name of the NCHAR character set for the Oracle DB instance. This setting doesn't apply to RDS Custom DB instances.
        public let ncharCharacterSetName: String?
        /// The network type of the DB instance. The network type is determined by the DBSubnetGroup specified for the DB instance.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.  Valid Values: IPV4 | DUAL
        public let networkType: String?
        /// The option group to associate the DB instance with. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed  from an option group. Also, that option group can't be removed from a DB instance after it is  associated with a DB instance. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        public let optionGroupName: String?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS  uses your default KMS key. There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. This setting doesn't apply to RDS Custom DB instances.
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. This setting doesn't apply to RDS Custom DB instances. Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days If you specify a retention period that isn't valid, such as 94,  Amazon RDS returns an error.
        public let performanceInsightsRetentionPeriod: Int?
        /// The port number on which the database accepts connections. This setting doesn't apply to Aurora DB instances. The port number is managed by the cluster. Valid Values: 1150-65535  Default:   RDS for Db2 - 50000    RDS for MariaDB - 3306    RDS for Microsoft SQL Server - 1433    RDS for MySQL - 3306    RDS for Oracle - 1521    RDS for PostgreSQL - 5432    Constraints:   For RDS for Microsoft SQL Server, the value can't be 1234, 1434, 3260, 3343, 3389, 47001, or 49152-49156.
        public let port: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. For more information, see Backup window in the Amazon RDS User Guide. This setting doesn't apply to Amazon Aurora DB instances. The daily time range for creating automated backups is managed by the DB cluster. Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?
        /// The time range each week during which system maintenance can occur.  For more information, see Amazon RDS Maintenance Window  in the Amazon RDS User Guide.  The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. Constraints:   Must be in the format ddd:hh24:mi-ddd:hh24:mi.   The day values must be mon | tue | wed | thu | fri | sat | sun.    Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred backup window.   Must be at least 30 minutes.
        public let preferredMaintenanceWindow: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// The order of priority in which an Aurora Replica is promoted to the primary instance  after a failure of the existing primary instance. For more information,  see  Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide. This setting doesn't apply to RDS Custom DB instances. Default: 1  Valid Values: 0 - 15
        public let promotionTier: Int?
        /// Specifies whether the DB instance is publicly accessible. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from  within the DB instance's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB instance's VPC.  Access to the DB instance is ultimately controlled by the security group it uses.  That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:   If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB instance is private.   If the default VPC in the target Region has an internet gateway attached to it, the DB instance is public.   If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:   If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB instance is private.   If the subnets are part of a VPC that has an internet gateway attached to it, the DB instance is public.
        public let publiclyAccessible: Bool?
        /// Specifes whether the DB instance is encrypted. By default, it isn't encrypted. For RDS Custom DB instances, either enable this setting or leave it unset. Otherwise, Amazon RDS reports an error. This setting doesn't apply to Amazon Aurora DB instances. The encryption for DB instances is managed by the DB cluster.
        public let storageEncrypted: Bool?
        /// The storage throughput value for the DB instance. This setting applies only to the gp3 storage type. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        public let storageThroughput: Int?
        /// The storage type to associate with the DB instance. If you specify io1, io2, or gp3, you must also include a value for the Iops parameter. This setting doesn't apply to Amazon Aurora DB instances. Storage is managed by the DB cluster. Valid Values: gp2 | gp3 | io1 | io2 | standard  Default: io1, if the Iops parameter is specified. Otherwise, gp2.
        public let storageType: String?
        /// Tags to assign to the DB instance.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        public let tdeCredentialArn: String?
        /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom DB instances.
        public let tdeCredentialPassword: String?
        /// The time zone of the DB instance.  The time zone parameter is currently supported only by Microsoft SQL Server.
        public let timezone: String?
        /// A list of Amazon EC2 VPC security groups to associate with this DB instance. This setting doesn't apply to Amazon Aurora DB instances. The associated list of EC2 VPC security groups is managed by the DB cluster. Default: The default EC2 VPC security group for the DB subnet group's VPC.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, backupRetentionPeriod: Int? = nil, backupTarget: String? = nil, caCertificateIdentifier: String? = nil, characterSetName: String? = nil, copyTagsToSnapshot: Bool? = nil, customIamInstanceProfile: String? = nil, dbClusterIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbName: String? = nil, dbParameterGroupName: String? = nil, dbSecurityGroups: [String]? = nil, dbSubnetGroupName: String? = nil, dbSystemId: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainAuthSecretArn: String? = nil, domainDnsIps: [String]? = nil, domainFqdn: String? = nil, domainIAMRoleName: String? = nil, domainOu: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableCustomerOwnedIp: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, enablePerformanceInsights: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, manageMasterUserPassword: Bool? = nil, masterUsername: String? = nil, masterUserPassword: String? = nil, masterUserSecretKmsKeyId: String? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAZ: Bool? = nil, multiTenant: Bool? = nil, ncharCharacterSetName: String? = nil, networkType: String? = nil, optionGroupName: String? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, processorFeatures: [ProcessorFeature]? = nil, promotionTier: Int? = nil, publiclyAccessible: Bool? = nil, storageEncrypted: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tags: [Tag]? = nil, tdeCredentialArn: String? = nil, tdeCredentialPassword: String? = nil, timezone: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.backupTarget = backupTarget
            self.caCertificateIdentifier = caCertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customIamInstanceProfile = customIamInstanceProfile
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbName = dbName
            self.dbParameterGroupName = dbParameterGroupName
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dbSystemId = dbSystemId
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainAuthSecretArn = domainAuthSecretArn
            self.domainDnsIps = domainDnsIps
            self.domainFqdn = domainFqdn
            self.domainIAMRoleName = domainIAMRoleName
            self.domainOu = domainOu
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableCustomerOwnedIp = enableCustomerOwnedIp
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.enablePerformanceInsights = enablePerformanceInsights
            self.engine = engine
            self.engineVersion = engineVersion
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.manageMasterUserPassword = manageMasterUserPassword
            self.masterUsername = masterUsername
            self.masterUserPassword = masterUserPassword
            self.masterUserSecretKmsKeyId = masterUserSecretKmsKeyId
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.multiTenant = multiTenant
            self.ncharCharacterSetName = ncharCharacterSetName
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.storageEncrypted = storageEncrypted
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tags = tags
            self.tdeCredentialArn = tdeCredentialArn
            self.tdeCredentialPassword = tdeCredentialPassword
            self.timezone = timezone
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case backupTarget = "BackupTarget"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case characterSetName = "CharacterSetName"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case customIamInstanceProfile = "CustomIamInstanceProfile"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbName = "DBName"
            case dbParameterGroupName = "DBParameterGroupName"
            case dbSecurityGroups = "DBSecurityGroups"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dbSystemId = "DBSystemId"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainAuthSecretArn = "DomainAuthSecretArn"
            case domainDnsIps = "DomainDnsIps"
            case domainFqdn = "DomainFqdn"
            case domainIAMRoleName = "DomainIAMRoleName"
            case domainOu = "DomainOu"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case enablePerformanceInsights = "EnablePerformanceInsights"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case manageMasterUserPassword = "ManageMasterUserPassword"
            case masterUsername = "MasterUsername"
            case masterUserPassword = "MasterUserPassword"
            case masterUserSecretKmsKeyId = "MasterUserSecretKmsKeyId"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAZ = "MultiAZ"
            case multiTenant = "MultiTenant"
            case ncharCharacterSetName = "NcharCharacterSetName"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case processorFeatures = "ProcessorFeatures"
            case promotionTier = "PromotionTier"
            case publiclyAccessible = "PubliclyAccessible"
            case storageEncrypted = "StorageEncrypted"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tags = "Tags"
            case tdeCredentialArn = "TdeCredentialArn"
            case tdeCredentialPassword = "TdeCredentialPassword"
            case timezone = "Timezone"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct CreateDBInstanceReadReplicaMessage: AWSEncodableShape {
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage (in gibibytes) to allocate initially for the read replica. Follow the allocation rules specified in CreateDBInstance.  Be sure to allocate enough storage for your read replica so that the create operation can succeed. You can also allocate additional storage for future growth.
        public let allocatedStorage: Int?
        /// Specifies whether to automatically apply minor engine upgrades to the read replica during the maintenance window. This setting doesn't apply to RDS Custom DB instances. Default: Inherits the value from the source DB instance.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone (AZ) where the read replica will be created. Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region. Example: us-east-1d
        public let availabilityZone: String?
        /// Specifies whether to copy all tags from the read replica to snapshots of the read replica. By default, tags aren't copied.
        public let copyTagsToSnapshot: Bool?
        /// The instance profile associated with the underlying Amazon EC2 instance of an  RDS Custom DB instance. The instance profile must meet the following requirements:   The profile must exist in your account.   The profile must have an IAM role that Amazon EC2 has permissions to assume.   The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.   For the list of permissions required for the IAM role, see   Configure IAM and your VPC in the Amazon RDS User Guide. This setting is required for RDS Custom DB instances.
        public let customIamInstanceProfile: String?
        /// The compute and memory capacity of the read replica, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB Instance Class in the Amazon RDS User Guide. Default: Inherits the value from the source DB instance.
        public let dbInstanceClass: String?
        /// The DB instance identifier of the read replica. This identifier is the unique key that identifies a DB instance. This parameter is stored as a lowercase string.
        public let dbInstanceIdentifier: String?
        /// The name of the DB parameter group to associate with this DB instance. If you don't specify a value for DBParameterGroupName, then Amazon RDS uses the DBParameterGroup of the source DB instance for a same Region read replica, or the default DBParameterGroup for the specified DB engine for a cross-Region read replica. Specifying a parameter group for this operation is only supported for MySQL DB instances for cross-Region read replicas and for Oracle DB instances. It isn't supported for MySQL DB instances for same Region read replicas or for RDS Custom. Constraints:   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.
        public let dbParameterGroupName: String?
        /// A DB subnet group for the DB instance. The new DB instance is created in the VPC associated with the DB subnet group. If no DB subnet group is specified, then the new DB instance isn't created in a VPC. Constraints:   If supplied, must match the name of an existing DB subnet group.   The specified DB subnet group must be in the same Amazon Web Services Region in which the operation is running.   All read replicas in one Amazon Web Services Region that are created from the same source DB instance must either:   Specify DB subnet groups from the same VPC. All these read replicas are created in the same VPC.   Not specify a DB subnet group. All these read replicas are created outside of any VPC.     Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        public let dedicatedLogVolume: Bool?
        /// Specifies whether to enable deletion protection for the DB instance.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. For more information, see   Deleting a DB Instance.
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL  Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see  Kerberos Authentication in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let domain: String?
        /// The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Example: arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456
        public let domainAuthSecretArn: String?
        /// The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:   Two IP addresses must be provided.  If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: 123.124.125.126,234.235.236.237
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var domainDnsIps: [String]?
        /// The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:   Can't be longer than 64 characters.   Example: mymanagedADtest.mymanagedAD.mydomain
        public let domainFqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to RDS Custom DB instances.
        public let domainIAMRoleName: String?
        /// The Active Directory organizational unit for your DB instance to join. Constraints:   Must be in the distinguished name format.   Can't be longer than 64 characters.   Example: OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain
        public let domainOu: String?
        /// The list of logs that the new DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see  Publishing Database Logs to Amazon CloudWatch Logs  in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts read replica. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the read replica from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide. For more information about CoIPs, see Customer-owned IP addresses  in the Amazon Web Services Outposts User Guide.
        public let enableCustomerOwnedIp: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information about IAM database authentication, see   IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let enableIAMDatabaseAuthentication: Bool?
        /// Specifies whether to enable Performance Insights for the read replica. For more information, see Using Amazon Performance Insights in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let enablePerformanceInsights: Bool?
        /// The amount of Provisioned IOPS (input/output operations per second) to initially allocate for the DB instance.
        public let iops: Int?
        /// The Amazon Web Services KMS key identifier for an encrypted read replica. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you create an encrypted read replica in the same Amazon Web Services Region as the source DB instance or Multi-AZ DB cluster, don't specify a value for this parameter. A read replica in the same Amazon Web Services Region is always encrypted with the same KMS key as the source DB instance or cluster. If you create an encrypted read replica in a different Amazon Web Services Region, then you must specify a KMS key identifier for the destination Amazon Web Services Region. KMS keys are specific to the Amazon Web Services Region that they are created in, and you can't use KMS keys from one Amazon Web Services Region in another Amazon Web Services Region. You can't create an encrypted read replica from an unencrypted DB instance or Multi-AZ DB cluster. This setting doesn't apply to RDS Custom, which uses the same KMS key as the primary  replica.
        public let kmsKeyId: String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see   Managing capacity automatically with Amazon RDS storage autoscaling  in the Amazon RDS User Guide.
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the read replica. To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0. If MonitoringRoleArn is specified, then you must set MonitoringInterval to a value other than 0. This setting doesn't apply to RDS Custom DB instances. Valid Values: 0, 1, 5, 10, 15, 30, 60  Default: 0
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, go to To  create an IAM role for Amazon RDS Enhanced Monitoring in the Amazon RDS User Guide. If MonitoringInterval is set to a value other than 0, then you must  supply a MonitoringRoleArn value. This setting doesn't apply to RDS Custom DB instances.
        public let monitoringRoleArn: String?
        /// Specifies whether the read replica is in a Multi-AZ deployment. You can create a read replica as a Multi-AZ DB instance. RDS creates a standby of your replica in another Availability Zone for failover support for the replica. Creating your read replica as a Multi-AZ DB instance is independent of whether the source is a Multi-AZ DB instance or a Multi-AZ DB cluster. This setting doesn't apply to RDS Custom DB instances.
        public let multiAZ: Bool?
        /// The network type of the DB instance. Valid Values:    IPV4     DUAL    The network type is determined by the DBSubnetGroup specified for read replica.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.
        public let networkType: String?
        /// The option group to associate the DB instance with. If not specified, RDS uses the option group associated with the source DB instance or cluster.  For SQL Server, you must use the option group associated with the source.  This setting doesn't apply to RDS Custom DB instances.
        public let optionGroupName: String?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS  uses your default KMS key. There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. This setting doesn't apply to RDS Custom DB instances.
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. This setting doesn't apply to RDS Custom DB instances. Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days If you specify a retention period that isn't valid, such as 94,  Amazon RDS returns an error.
        public let performanceInsightsRetentionPeriod: Int?
        /// The port number that the DB instance uses for connections. Valid Values: 1150-65535  Default: Inherits the value from the source DB instance.
        public let port: Int?
        /// When you are creating a read replica from one Amazon Web Services GovCloud (US) Region to another or from one China Amazon Web Services Region to another, the URL that contains a Signature Version 4 signed request for the CreateDBInstanceReadReplica API operation in the source Amazon Web Services Region that contains the source DB instance. This setting applies only to Amazon Web Services GovCloud (US) Regions and  China Amazon Web Services Regions. It's ignored in other Amazon Web Services Regions. This setting applies only when replicating from a source DB instance. Source DB clusters aren't supported in Amazon Web Services GovCloud (US) Regions and China Amazon Web Services Regions. You must specify this parameter when you create an encrypted read replica from another Amazon Web Services Region by using the Amazon RDS API. Don't specify PreSignedUrl when you are creating an encrypted read replica in the same Amazon Web Services Region. The presigned URL must be a valid request for the CreateDBInstanceReadReplica API operation that can run in the source Amazon Web Services Region that contains the encrypted source DB instance. The presigned URL request must contain the following parameter values:    DestinationRegion - The Amazon Web Services Region that the encrypted read replica is created in. This Amazon Web Services Region is the same one where the CreateDBInstanceReadReplica operation is called that contains this presigned URL. For example, if you create an encrypted DB instance in the us-west-1 Amazon Web Services Region, from a source DB instance in the us-east-2 Amazon Web Services Region, then you call the CreateDBInstanceReadReplica operation in the us-east-1 Amazon Web Services Region and provide a presigned URL that contains a call to the CreateDBInstanceReadReplica operation in the us-west-2 Amazon Web Services Region. For this example, the DestinationRegion in the presigned URL must be set to the us-east-1 Amazon Web Services Region.    KmsKeyId - The KMS key identifier for the key to use to encrypt the read replica in the destination Amazon Web Services Region. This is the same identifier for both the CreateDBInstanceReadReplica operation that is called in the destination Amazon Web Services Region, and the operation contained in the presigned URL.    SourceDBInstanceIdentifier - The DB instance identifier for the encrypted DB instance to be replicated. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are creating an encrypted read replica from a DB instance in the us-west-2 Amazon Web Services Region, then your SourceDBInstanceIdentifier looks like the following example: arn:aws:rds:us-west-2:123456789012:instance:mysql-instance1-20161115.   To learn how to generate a Signature Version 4 signed request, see  Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and Signature Version 4 Signing Process.  If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can run in the source Amazon Web Services Region.  SourceRegion isn't supported for SQL Server, because Amazon RDS for SQL Server  doesn't support cross-Region read replicas.  This setting doesn't apply to RDS Custom DB instances.
        public let preSignedUrl: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom DB instances.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// Specifies whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see CreateDBInstance.
        public let publiclyAccessible: Bool?
        /// The open mode of the replica database: mounted or read-only.  This parameter is only supported for Oracle DB instances.  Mounted DB replicas are included in Oracle Database Enterprise Edition. The main use case for mounted replicas is cross-Region disaster recovery. The primary database doesn't use Active Data Guard to transmit information to the mounted replica. Because it doesn't accept user connections, a mounted replica can't serve a read-only workload. You can create a combination of mounted and read-only DB replicas for the same primary DB instance. For more information, see Working with Oracle Read Replicas for Amazon RDS  in the Amazon RDS User Guide. For RDS Custom, you must specify this parameter and set it to mounted. The value won't be set by default.  After replica creation, you can manage the open mode manually.
        public let replicaMode: ReplicaMode?
        /// The identifier of the Multi-AZ DB cluster that will act as the source for the read replica. Each DB cluster can have up to 15 read replicas. Constraints:   Must be the identifier of an existing Multi-AZ DB cluster.   Can't be specified if the SourceDBInstanceIdentifier parameter is also specified.   The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0.   The source DB cluster must be in the same Amazon Web Services Region as the read replica. Cross-Region replication isn't supported.
        public let sourceDBClusterIdentifier: String?
        /// The identifier of the DB instance that will act as the source for the read replica. Each DB instance can have up to 15 read replicas, with the exception of Oracle and SQL Server, which can have up to five. Constraints:   Must be the identifier of an existing Db2, MariaDB, MySQL, Oracle, PostgreSQL, or SQL Server DB instance.   Can't be specified if the SourceDBClusterIdentifier parameter is also specified.   For the limitations of Oracle read replicas, see Version and licensing considerations for RDS for Oracle replicas in the Amazon RDS User Guide.   For the limitations of SQL Server read replicas, see Read replica limitations with SQL Server in the Amazon RDS User Guide.   The specified DB instance must have automatic backups enabled, that is, its backup retention period must be greater than 0.   If the source DB instance is in the same Amazon Web Services Region as the read replica, specify a valid DB instance identifier.   If the source DB instance is in a different Amazon Web Services Region from the read replica, specify a valid DB instance ARN. For more information, see Constructing an ARN for Amazon RDS in the Amazon RDS User Guide. This doesn't apply to SQL Server or RDS Custom, which don't support cross-Region replicas.
        public let sourceDBInstanceIdentifier: String?
        /// Specifies the storage throughput value for the read replica. This setting doesn't apply to RDS Custom or Amazon Aurora DB instances.
        public let storageThroughput: Int?
        /// The storage type to associate with the read replica. If you specify io1, io2, or gp3, you must also include a value for the Iops parameter. Valid Values: gp2 | gp3 | io1 | io2 | standard  Default: io1 if the Iops parameter is specified. Otherwise, gp2.
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// Whether to upgrade the storage file system configuration on the read replica. This option migrates the read replica from the old storage file system layout to the preferred layout.
        public let upgradeStorageConfig: Bool?
        /// Specifies whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom DB instances.
        public let useDefaultProcessorFeatures: Bool?
        /// A list of Amazon EC2 VPC security groups to associate with the read replica. This setting doesn't apply to RDS Custom DB instances. Default: The default EC2 VPC security group for the DB subnet group's VPC.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, copyTagsToSnapshot: Bool? = nil, customIamInstanceProfile: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbParameterGroupName: String? = nil, dbSubnetGroupName: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainAuthSecretArn: String? = nil, domainDnsIps: [String]? = nil, domainFqdn: String? = nil, domainIAMRoleName: String? = nil, domainOu: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableCustomerOwnedIp: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, enablePerformanceInsights: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, optionGroupName: String? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, port: Int? = nil, preSignedUrl: String? = nil, processorFeatures: [ProcessorFeature]? = nil, publiclyAccessible: Bool? = nil, replicaMode: ReplicaMode? = nil, sourceDBClusterIdentifier: String? = nil, sourceDBInstanceIdentifier: String? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tags: [Tag]? = nil, upgradeStorageConfig: Bool? = nil, useDefaultProcessorFeatures: Bool? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customIamInstanceProfile = customIamInstanceProfile
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbParameterGroupName = dbParameterGroupName
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainAuthSecretArn = domainAuthSecretArn
            self.domainDnsIps = domainDnsIps
            self.domainFqdn = domainFqdn
            self.domainIAMRoleName = domainIAMRoleName
            self.domainOu = domainOu
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableCustomerOwnedIp = enableCustomerOwnedIp
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.enablePerformanceInsights = enablePerformanceInsights
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preSignedUrl = preSignedUrl
            self.processorFeatures = processorFeatures
            self.publiclyAccessible = publiclyAccessible
            self.replicaMode = replicaMode
            self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
            self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tags = tags
            self.upgradeStorageConfig = upgradeStorageConfig
            self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case customIamInstanceProfile = "CustomIamInstanceProfile"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbParameterGroupName = "DBParameterGroupName"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainAuthSecretArn = "DomainAuthSecretArn"
            case domainDnsIps = "DomainDnsIps"
            case domainFqdn = "DomainFqdn"
            case domainIAMRoleName = "DomainIAMRoleName"
            case domainOu = "DomainOu"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case enablePerformanceInsights = "EnablePerformanceInsights"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case port = "Port"
            case preSignedUrl = "PreSignedUrl"
            case processorFeatures = "ProcessorFeatures"
            case publiclyAccessible = "PubliclyAccessible"
            case replicaMode = "ReplicaMode"
            case sourceDBClusterIdentifier = "SourceDBClusterIdentifier"
            case sourceDBInstanceIdentifier = "SourceDBInstanceIdentifier"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tags = "Tags"
            case upgradeStorageConfig = "UpgradeStorageConfig"
            case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct CreateDBInstanceReadReplicaResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct CreateDBInstanceResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct CreateDBParameterGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a database engine and engine version compatible with that DB parameter group family. To list all of the available parameter group families for a DB engine, use the following command:  aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine   For example, to list all of the available parameter group families for the MySQL DB engine, use the following command:  aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine mysql   The output contains duplicates.  The following are the valid DB engine values:    aurora-mysql     aurora-postgresql     db2-ae     db2-se     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let dbParameterGroupFamily: String?
        /// The name of the DB parameter group. Constraints:   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens    This value is stored as a lowercase string.
        public let dbParameterGroupName: String?
        /// The description for the DB parameter group.
        public let description: String?
        /// Tags to assign to the DB parameter group.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbParameterGroupFamily: String? = nil, dbParameterGroupName: String? = nil, description: String? = nil, tags: [Tag]? = nil) {
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.dbParameterGroupName = dbParameterGroupName
            self.description = description
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case dbParameterGroupName = "DBParameterGroupName"
            case description = "Description"
            case tags = "Tags"
        }
    }

    public struct CreateDBParameterGroupResult: AWSDecodableShape {
        public let dbParameterGroup: DBParameterGroup?

        public init(dbParameterGroup: DBParameterGroup? = nil) {
            self.dbParameterGroup = dbParameterGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroup = "DBParameterGroup"
        }
    }

    public struct CreateDBProxyEndpointRequest: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The name of the DB proxy endpoint to create.
        public let dbProxyEndpointName: String?
        /// The name of the DB proxy associated with the DB proxy endpoint that you create.
        public let dbProxyName: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The role of the DB proxy endpoint. The role determines whether the endpoint can be used for read/write or only read operations. The default is READ_WRITE. The only role that proxies for RDS for Microsoft SQL Server  support is READ_WRITE.
        public let targetRole: DBProxyEndpointTargetRole?
        /// The VPC security group IDs for the DB proxy endpoint that you create. You can specify a different set of security group IDs than for the original DB proxy. The default is the default security group for the VPC.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSecurityGroupIds: [String]?
        /// The VPC subnet IDs for the DB proxy endpoint that you create. You can specify a different set of subnet IDs than for the original DB proxy.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSubnetIds: [String]?

        public init(dbProxyEndpointName: String? = nil, dbProxyName: String? = nil, tags: [Tag]? = nil, targetRole: DBProxyEndpointTargetRole? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]? = nil) {
            self.dbProxyEndpointName = dbProxyEndpointName
            self.dbProxyName = dbProxyName
            self.tags = tags
            self.targetRole = targetRole
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, max: 63)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, min: 1)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.dbProxyName, name: "dbProxyName", parent: name, max: 63)
            try self.validate(self.dbProxyName, name: "dbProxyName", parent: name, min: 1)
            try self.validate(self.dbProxyName, name: "dbProxyName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpointName = "DBProxyEndpointName"
            case dbProxyName = "DBProxyName"
            case tags = "Tags"
            case targetRole = "TargetRole"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
            case vpcSubnetIds = "VpcSubnetIds"
        }
    }

    public struct CreateDBProxyEndpointResponse: AWSDecodableShape {
        /// The DBProxyEndpoint object that is created by the API operation. The DB proxy endpoint that you create might provide capabilities such as read/write or read-only operations, or using a different VPC than the proxy's default VPC.
        public let dbProxyEndpoint: DBProxyEndpoint?

        public init(dbProxyEndpoint: DBProxyEndpoint? = nil) {
            self.dbProxyEndpoint = dbProxyEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpoint = "DBProxyEndpoint"
        }
    }

    public struct CreateDBProxyRequest: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The authorization mechanism that the proxy uses.
        @OptionalCustomCoding<StandardArrayCoder<UserAuthConfig>>
        public var auth: [UserAuthConfig]?
        /// The identifier for the proxy. This name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        public let dbProxyName: String?
        /// Specifies whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
        public let debugLogging: Bool?
        /// The kinds of databases that the proxy can connect to.  This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. For Aurora MySQL, RDS for MariaDB, and RDS for MySQL databases, specify MYSQL.  For Aurora PostgreSQL and RDS for PostgreSQL databases, specify POSTGRESQL. For RDS for Microsoft SQL Server, specify  SQLSERVER.
        public let engineFamily: EngineFamily?
        /// The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
        public let idleClientTimeout: Int?
        /// Specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy.
        public let requireTLS: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in Amazon Web Services Secrets Manager.
        public let roleArn: String?
        /// An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// One or more VPC security group IDs to associate with the new proxy.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSecurityGroupIds: [String]?
        /// One or more VPC subnet IDs to associate with the new proxy.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSubnetIds: [String]?

        public init(auth: [UserAuthConfig]? = nil, dbProxyName: String? = nil, debugLogging: Bool? = nil, engineFamily: EngineFamily? = nil, idleClientTimeout: Int? = nil, requireTLS: Bool? = nil, roleArn: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]? = nil) {
            self.auth = auth
            self.dbProxyName = dbProxyName
            self.debugLogging = debugLogging
            self.engineFamily = engineFamily
            self.idleClientTimeout = idleClientTimeout
            self.requireTLS = requireTLS
            self.roleArn = roleArn
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case auth = "Auth"
            case dbProxyName = "DBProxyName"
            case debugLogging = "DebugLogging"
            case engineFamily = "EngineFamily"
            case idleClientTimeout = "IdleClientTimeout"
            case requireTLS = "RequireTLS"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
            case vpcSubnetIds = "VpcSubnetIds"
        }
    }

    public struct CreateDBProxyResponse: AWSDecodableShape {
        /// The DBProxy structure corresponding to the new proxy.
        public let dbProxy: DBProxy?

        public init(dbProxy: DBProxy? = nil) {
            self.dbProxy = dbProxy
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxy = "DBProxy"
        }
    }

    public struct CreateDBSecurityGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The description for the DB security group.
        public let dbSecurityGroupDescription: String?
        /// The name for the DB security group. This value is stored as a lowercase string. Constraints:   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Must not be "Default"   Example: mysecuritygroup
        public let dbSecurityGroupName: String?
        /// Tags to assign to the DB security group.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbSecurityGroupDescription: String? = nil, dbSecurityGroupName: String? = nil, tags: [Tag]? = nil) {
            self.dbSecurityGroupDescription = dbSecurityGroupDescription
            self.dbSecurityGroupName = dbSecurityGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupDescription = "DBSecurityGroupDescription"
            case dbSecurityGroupName = "DBSecurityGroupName"
            case tags = "Tags"
        }
    }

    public struct CreateDBSecurityGroupResult: AWSDecodableShape {
        public let dbSecurityGroup: DBSecurityGroup?

        public init(dbSecurityGroup: DBSecurityGroup? = nil) {
            self.dbSecurityGroup = dbSecurityGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroup = "DBSecurityGroup"
        }
    }

    public struct CreateDBShardGroupMessage: AWSEncodableShape {
        /// Specifies whether to create standby instances for the DB shard group. Valid values are the following:   0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.   1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.   2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.
        public let computeRedundancy: Int?
        /// The name of the primary DB cluster for the DB shard group.
        public let dbClusterIdentifier: String?
        /// The name of the DB shard group.
        public let dbShardGroupIdentifier: String?
        /// The maximum capacity of the DB shard group in Aurora capacity units (ACUs).
        public let maxACU: Double?
        /// Specifies whether the DB shard group is publicly accessible. When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from  within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC.  Access to the DB shard group is ultimately controlled by the security group it uses.  That public access is not permitted if the security group assigned to the DB shard group doesn't permit it. When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:   If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.   If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.   If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:   If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.   If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.
        public let publiclyAccessible: Bool?

        public init(computeRedundancy: Int? = nil, dbClusterIdentifier: String? = nil, dbShardGroupIdentifier: String? = nil, maxACU: Double? = nil, publiclyAccessible: Bool? = nil) {
            self.computeRedundancy = computeRedundancy
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
            self.maxACU = maxACU
            self.publiclyAccessible = publiclyAccessible
        }

        private enum CodingKeys: String, CodingKey {
            case computeRedundancy = "ComputeRedundancy"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbShardGroupIdentifier = "DBShardGroupIdentifier"
            case maxACU = "MaxACU"
            case publiclyAccessible = "PubliclyAccessible"
        }
    }

    public struct CreateDBSnapshotMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The identifier of the DB instance that you want to create the snapshot of. Constraints:   Must match the identifier of an existing DBInstance.
        public let dbInstanceIdentifier: String?
        /// The identifier for the DB snapshot. Constraints:   Can't be null, empty, or blank   Must contain from 1 to 255 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: my-snapshot-id
        public let dbSnapshotIdentifier: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbInstanceIdentifier: String? = nil, dbSnapshotIdentifier: String? = nil, tags: [Tag]? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case tags = "Tags"
        }
    }

    public struct CreateDBSnapshotResult: AWSDecodableShape {
        public let dbSnapshot: DBSnapshot?

        public init(dbSnapshot: DBSnapshot? = nil) {
            self.dbSnapshot = dbSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshot = "DBSnapshot"
        }
    }

    public struct CreateDBSubnetGroupMessage: AWSEncodableShape {
        public struct _SubnetIdsEncoding: ArrayCoderProperties { public static let member = "SubnetIdentifier" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The description for the DB subnet group.
        public let dbSubnetGroupDescription: String?
        /// The name for the DB subnet group. This value is stored as a lowercase string. Constraints:   Must contain no more than 255 letters, numbers, periods, underscores, spaces, or hyphens.   Must not be default.   First character must be a letter.   Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// The EC2 Subnet IDs for the DB subnet group.
        @OptionalCustomCoding<ArrayCoder<_SubnetIdsEncoding, String>>
        public var subnetIds: [String]?
        /// Tags to assign to the DB subnet group.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbSubnetGroupDescription: String? = nil, dbSubnetGroupName: String? = nil, subnetIds: [String]? = nil, tags: [Tag]? = nil) {
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetIds = subnetIds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupDescription = "DBSubnetGroupDescription"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case subnetIds = "SubnetIds"
            case tags = "Tags"
        }
    }

    public struct CreateDBSubnetGroupResult: AWSDecodableShape {
        public let dbSubnetGroup: DBSubnetGroup?

        public init(dbSubnetGroup: DBSubnetGroup? = nil) {
            self.dbSubnetGroup = dbSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroup = "DBSubnetGroup"
        }
    }

    public struct CreateEventSubscriptionMessage: AWSEncodableShape {
        public struct _EventCategoriesEncoding: ArrayCoderProperties { public static let member = "EventCategory" }
        public struct _SourceIdsEncoding: ArrayCoderProperties { public static let member = "SourceId" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// Specifies whether to activate the subscription. If the event notification subscription isn't activated, the subscription is created but not active.
        public let enabled: Bool?
        /// A list of event categories for a particular source type (SourceType) that you want to subscribe to. You can see a list of the categories for a given source type in the "Amazon RDS event categories and event messages" section of the  Amazon RDS User Guide or the  Amazon Aurora User Guide . You can also see this list by using the DescribeEventCategories operation.
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesEncoding, String>>
        public var eventCategories: [String]?
        /// The Amazon Resource Name (ARN) of the SNS topic created for event notification. SNS automatically creates the ARN when you create a topic and subscribe to it.  RDS doesn't support FIFO (first in, first out) topics. For more information, see Message ordering and deduplication (FIFO topics) in the Amazon Simple Notification Service Developer Guide.
        public let snsTopicArn: String?
        /// The list of identifiers of the event sources for which events are returned. If not specified, then all sources are included in the response.  An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens. Constraints:   If SourceIds are supplied, SourceType must also be provided.   If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.   If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.   If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.   If the source type is a DB security group, a DBSecurityGroupName value must be supplied.   If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.   If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.   If the source type is an RDS Proxy, a DBProxyName value must be supplied.
        @OptionalCustomCoding<ArrayCoder<_SourceIdsEncoding, String>>
        public var sourceIds: [String]?
        /// The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, you set this parameter to db-instance. For RDS Proxy events, specify db-proxy. If this value isn't specified, all events are returned. Valid Values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot | db-proxy
        public let sourceType: String?
        /// The name of the subscription. Constraints: The name must be less than 255 characters.
        public let subscriptionName: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String? = nil, sourceIds: [String]? = nil, sourceType: String? = nil, subscriptionName: String? = nil, tags: [Tag]? = nil) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceIds = sourceIds
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceIds = "SourceIds"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
            case tags = "Tags"
        }
    }

    public struct CreateEventSubscriptionResult: AWSDecodableShape {
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct CreateGlobalClusterMessage: AWSEncodableShape {
        /// The name for your database of up to 64 alphanumeric characters. If you don't specify a name, Amazon Aurora doesn't create a database in the global database cluster. Constraints:   Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the database name from the source DB cluster.
        public let databaseName: String?
        /// Specifies whether to enable deletion protection for the new global database cluster. The global database can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The database engine to use for this global database cluster. Valid Values: aurora-mysql | aurora-postgresql  Constraints:   Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the engine of the source DB cluster.
        public let engine: String?
        /// The engine version to use for this global database cluster. Constraints:   Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the engine version of the source DB cluster.
        public let engineVersion: String?
        /// The cluster identifier for this global database cluster. This parameter is stored as a lowercase string.
        public let globalClusterIdentifier: String?
        /// The Amazon Resource Name (ARN) to use as the primary cluster of the global database. If you provide a value for this parameter, don't specify values for the following settings because Amazon Aurora uses the values from the specified source DB cluster:    DatabaseName     Engine     EngineVersion     StorageEncrypted
        public let sourceDBClusterIdentifier: String?
        /// Specifies whether to enable storage encryption for the new global database cluster. Constraints:   Can't be specified if SourceDBClusterIdentifier is specified. In this case, Amazon Aurora uses the setting from the source DB cluster.
        public let storageEncrypted: Bool?

        public init(databaseName: String? = nil, deletionProtection: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, globalClusterIdentifier: String? = nil, sourceDBClusterIdentifier: String? = nil, storageEncrypted: Bool? = nil) {
            self.databaseName = databaseName
            self.deletionProtection = deletionProtection
            self.engine = engine
            self.engineVersion = engineVersion
            self.globalClusterIdentifier = globalClusterIdentifier
            self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
            self.storageEncrypted = storageEncrypted
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case deletionProtection = "DeletionProtection"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case sourceDBClusterIdentifier = "SourceDBClusterIdentifier"
            case storageEncrypted = "StorageEncrypted"
        }
    }

    public struct CreateGlobalClusterResult: AWSDecodableShape {
        public let globalCluster: GlobalCluster?

        public init(globalCluster: GlobalCluster? = nil) {
            self.globalCluster = globalCluster
        }

        private enum CodingKeys: String, CodingKey {
            case globalCluster = "GlobalCluster"
        }
    }

    public struct CreateIntegrationMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// An optional set of non-secret key–value pairs that contains additional contextual information about the data. For more information, see Encryption context in the Amazon Web Services Key Management Service Developer Guide. You can only include this parameter if you specify the KMSKeyId parameter.
        @OptionalCustomCoding<StandardDictionaryCoder<String, String>>
        public var additionalEncryptionContext: [String: String]?
        /// Data filtering options for the integration. For more information, see  Data filtering for Aurora zero-ETL integrations with Amazon Redshift.  Valid for: Integrations with Aurora MySQL source DB clusters only
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// The name of the integration.
        public let integrationName: String?
        /// The Amazon Web Services Key Management System (Amazon Web Services KMS) key identifier for the key to use to encrypt the integration. If you don't specify an encryption key, RDS uses a default Amazon Web Services owned key.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the database to use as the source for replication.
        public let sourceArn: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The ARN of the Redshift data warehouse to use as the target for replication.
        public let targetArn: String?

        public init(additionalEncryptionContext: [String: String]? = nil, dataFilter: String? = nil, description: String? = nil, integrationName: String? = nil, kmsKeyId: String? = nil, sourceArn: String? = nil, tags: [Tag]? = nil, targetArn: String? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.dataFilter = dataFilter
            self.description = description
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.tags = tags
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, max: 25600)
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, min: 1)
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, pattern: "^[a-zA-Z0-9_ \"\\\\\\-$,*.:?+\\/]*$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.integrationName, name: "integrationName", parent: name, max: 63)
            try self.validate(self.integrationName, name: "integrationName", parent: name, min: 1)
            try self.validate(self.integrationName, name: "integrationName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 255)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 1)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:rds(-[a-z]*)?:[a-z0-9\\-]*:[0-9]*:(cluster|db):[a-z][a-z0-9]*(-[a-z0-9]+)*$")
            try self.validate(self.targetArn, name: "targetArn", parent: name, max: 2048)
            try self.validate(self.targetArn, name: "targetArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case dataFilter = "DataFilter"
            case description = "Description"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KMSKeyId"
            case sourceArn = "SourceArn"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct CreateOptionGroupMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The name of the engine to associate this option group with. Valid Values:    db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engineName: String?
        /// Specifies the major version of the engine that this option group should be associated with.
        public let majorEngineVersion: String?
        /// The description of the option group.
        public let optionGroupDescription: String?
        /// Specifies the name of the option group to be created. Constraints:   Must be 1 to 255 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: myoptiongroup
        public let optionGroupName: String?
        /// Tags to assign to the option group.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(engineName: String? = nil, majorEngineVersion: String? = nil, optionGroupDescription: String? = nil, optionGroupName: String? = nil, tags: [Tag]? = nil) {
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.optionGroupDescription = optionGroupDescription
            self.optionGroupName = optionGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case engineName = "EngineName"
            case majorEngineVersion = "MajorEngineVersion"
            case optionGroupDescription = "OptionGroupDescription"
            case optionGroupName = "OptionGroupName"
            case tags = "Tags"
        }
    }

    public struct CreateOptionGroupResult: AWSDecodableShape {
        public let optionGroup: OptionGroup?

        public init(optionGroup: OptionGroup? = nil) {
            self.optionGroup = optionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroup = "OptionGroup"
        }
    }

    public struct CreateTenantDatabaseMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The character set for your tenant database. If you don't specify a value, the character set name defaults to AL32UTF8.
        public let characterSetName: String?
        /// The user-supplied DB instance identifier. RDS creates your tenant database in this DB instance. This parameter isn't case-sensitive.
        public let dbInstanceIdentifier: String?
        /// The name for the master user account in your tenant database. RDS creates this user account in the tenant database and grants privileges to the master user. This parameter is case-sensitive. Constraints:   Must be 1 to 16 letters, numbers, or underscores.   First character must be a letter.   Can't be a reserved word for the chosen database engine.
        public let masterUsername: String?
        /// The password for the master user in your tenant database. Constraints:   Must be 8 to 30 characters.   Can include any printable ASCII character except forward slash (/), double quote ("), at symbol (@), ampersand (&), or single quote (').
        public let masterUserPassword: String?
        /// The NCHAR value for the tenant database.
        public let ncharCharacterSetName: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The user-supplied name of the tenant database that you want to create in your DB instance. This parameter has the same constraints as DBName in CreateDBInstance.
        public let tenantDBName: String?

        public init(characterSetName: String? = nil, dbInstanceIdentifier: String? = nil, masterUsername: String? = nil, masterUserPassword: String? = nil, ncharCharacterSetName: String? = nil, tags: [Tag]? = nil, tenantDBName: String? = nil) {
            self.characterSetName = characterSetName
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.masterUsername = masterUsername
            self.masterUserPassword = masterUserPassword
            self.ncharCharacterSetName = ncharCharacterSetName
            self.tags = tags
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case characterSetName = "CharacterSetName"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case masterUsername = "MasterUsername"
            case masterUserPassword = "MasterUserPassword"
            case ncharCharacterSetName = "NcharCharacterSetName"
            case tags = "Tags"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct CreateTenantDatabaseResult: AWSDecodableShape {
        public let tenantDatabase: TenantDatabase?

        public init(tenantDatabase: TenantDatabase? = nil) {
            self.tenantDatabase = tenantDatabase
        }

        private enum CodingKeys: String, CodingKey {
            case tenantDatabase = "TenantDatabase"
        }
    }

    public struct CustomDBEngineVersionAMI: AWSDecodableShape {
        /// A value that indicates the ID of the AMI.
        public let imageId: String?
        /// A value that indicates the status of a custom engine version (CEV).
        public let status: String?

        public init(imageId: String? = nil, status: String? = nil) {
            self.imageId = imageId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "ImageId"
            case status = "Status"
        }
    }

    public struct DBCluster: AWSDecodableShape {
        public struct _AssociatedRolesEncoding: ArrayCoderProperties { public static let member = "DBClusterRole" }
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }
        public struct _DBClusterMembersEncoding: ArrayCoderProperties { public static let member = "DBClusterMember" }
        public struct _DBClusterOptionGroupMembershipsEncoding: ArrayCoderProperties { public static let member = "DBClusterOptionGroup" }
        public struct _DomainMembershipsEncoding: ArrayCoderProperties { public static let member = "DomainMembership" }
        public struct _ReadReplicaIdentifiersEncoding: ArrayCoderProperties { public static let member = "ReadReplicaIdentifier" }
        public struct _StatusInfosEncoding: ArrayCoderProperties { public static let member = "DBClusterStatusInfo" }
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupMembership" }

        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public let activityStreamKinesisStreamName: String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let activityStreamKmsKeyId: String?
        /// The mode of the database activity stream. Database events such as a change or access generate an activity stream event. The database session can handle these events either synchronously or asynchronously.
        public let activityStreamMode: ActivityStreamMode?
        /// The status of the database activity stream.
        public let activityStreamStatus: ActivityStreamStatus?
        /// For all database engines except Amazon Aurora, AllocatedStorage specifies the allocated storage size in gibibytes (GiB).  For Aurora, AllocatedStorage always returns 1, because Aurora DB cluster storage size isn't fixed, but instead automatically adjusts as needed.
        public let allocatedStorage: Int?
        /// A list of the Amazon Web Services Identity and Access Management (IAM) roles that are associated with the DB cluster.  IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf.
        @OptionalCustomCoding<ArrayCoder<_AssociatedRolesEncoding, DBClusterRole>>
        public var associatedRoles: [DBClusterRole]?
        /// The time when a stopped DB cluster is restarted automatically.
        public let automaticRestartTime: Date?
        /// Indicates whether minor version patches are applied automatically. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let autoMinorVersionUpgrade: Bool?
        /// The list of Availability Zones (AZs) where instances in the DB cluster can be created.
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, String>>
        public var availabilityZones: [String]?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public let awsBackupRecoveryPointArn: String?
        /// The number of change records stored for Backtrack.
        public let backtrackConsumedChangeRecords: Int64?
        /// The target backtrack window, in seconds. If this value is set to 0, backtracking is disabled for the DB cluster. Otherwise, backtracking is enabled.
        public let backtrackWindow: Int64?
        /// The number of days for which automatic DB snapshots are retained.
        public let backupRetentionPeriod: Int?
        /// The current capacity of an Aurora Serverless v1 DB cluster. The capacity is 0 (zero)  when the cluster is paused. For more information about Aurora Serverless v1, see Using Amazon Aurora Serverless v1 in the  Amazon Aurora User Guide.
        public let capacity: Int?
        public let certificateDetails: CertificateDetails?
        /// If present, specifies the name of the character set that this cluster is associated with.
        public let characterSetName: String?
        /// The ID of the clone group with which the DB cluster is associated.
        public let cloneGroupId: String?
        /// The time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public let clusterCreateTime: Date?
        /// Indicates whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public let copyTagsToSnapshot: Bool?
        /// Indicates whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public let crossAccountClone: Bool?
        /// The custom endpoints associated with the DB cluster.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var customEndpoints: [String]?
        /// The name of the initial database that was specified for the DB cluster when it was created, if one was provided. This same name is returned for the life of the DB cluster.
        public let databaseName: String?
        /// The Amazon Resource Name (ARN) for the DB cluster.
        public let dbClusterArn: String?
        /// The user-supplied identifier for the DB cluster. This identifier is the unique key that identifies a DB cluster.
        public let dbClusterIdentifier: String?
        /// The name of the compute and memory capacity class of the DB instance. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let dbClusterInstanceClass: String?
        /// The list of DB instances that make up the DB cluster.
        @OptionalCustomCoding<ArrayCoder<_DBClusterMembersEncoding, DBClusterMember>>
        public var dbClusterMembers: [DBClusterMember]?
        /// The list of option group memberships for this DB cluster.
        @OptionalCustomCoding<ArrayCoder<_DBClusterOptionGroupMembershipsEncoding, DBClusterOptionGroupStatus>>
        public var dbClusterOptionGroupMemberships: [DBClusterOptionGroupStatus]?
        /// The name of the DB cluster parameter group for the DB cluster.
        public let dbClusterParameterGroup: String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB cluster. This identifier is found in Amazon Web Services CloudTrail log entries whenever  the KMS key for the DB cluster is accessed.
        public let dbClusterResourceId: String?
        /// Information about the subnet group associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public let dbSubnetGroup: String?
        /// Reserved for future use.
        public let dbSystemId: String?
        /// Indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The Active Directory Domain membership records associated with the DB cluster.
        @OptionalCustomCoding<ArrayCoder<_DomainMembershipsEncoding, DomainMembership>>
        public var domainMemberships: [DomainMembership]?
        /// The earliest time to which a DB cluster can be backtracked.
        public let earliestBacktrackTime: Date?
        /// The earliest time to which a database can be restored with point-in-time restore.
        public let earliestRestorableTime: Date?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs. Log types vary by DB engine. For information about the log types for each DB engine, see Amazon RDS Database Log Files in the Amazon Aurora User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enabledCloudwatchLogsExports: [String]?
        /// The connection endpoint for the primary instance of the DB cluster.
        public let endpoint: String?
        /// The database engine used for this DB cluster.
        public let engine: String?
        /// The DB engine mode of the DB cluster, either provisioned or serverless. For more information, see  CreateDBCluster.
        public let engineMode: String?
        /// The version of the database engine.
        public let engineVersion: String?
        /// Indicates whether write forwarding is enabled for a secondary cluster in an Aurora global database. Because write forwarding takes time to enable, check the value of GlobalWriteForwardingStatus to confirm that the request has completed before using the write forwarding feature for this cluster.
        public let globalWriteForwardingRequested: Bool?
        /// The status of write forwarding for a secondary cluster in an Aurora global database.
        public let globalWriteForwardingStatus: WriteForwardingStatus?
        /// The ID that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Indicates whether the HTTP endpoint is enabled for an Aurora DB cluster. When enabled, the HTTP endpoint provides a connectionless web service API (RDS Data API) for running SQL queries on the DB cluster. You can also query your database from inside the RDS console with the RDS query editor. For more information, see Using RDS Data API in the  Amazon Aurora User Guide.
        public let httpEndpointEnabled: Bool?
        /// Indicates whether the mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The next time you can modify the DB cluster to use the aurora-iopt1 storage type. This setting is only for Aurora DB clusters.
        public let ioOptimizedNextAllowedModificationTime: Date?
        /// The Provisioned IOPS (I/O operations per second) value. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let iops: Int?
        /// If StorageEncrypted is enabled, the Amazon Web Services KMS key identifier for the encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// The latest time to which a database can be restored with point-in-time restore.
        public let latestRestorableTime: Date?
        /// The details for Aurora Limitless Database.
        public let limitlessDatabase: LimitlessDatabase?
        /// Indicates whether an Aurora DB cluster has in-cluster write forwarding enabled, not enabled, requested, or is in the process  of enabling it.
        public let localWriteForwardingStatus: LocalWriteForwardingStatus?
        /// The master username for the DB cluster.
        public let masterUsername: String?
        /// The secret managed by RDS in Amazon Web Services Secrets Manager for the master user password. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide and Password management with Amazon Web Services Secrets Manager  in the Amazon Aurora User Guide.
        public let masterUserSecret: MasterUserSecret?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let monitoringRoleArn: String?
        /// Indicates whether the DB cluster has instances in multiple Availability Zones.
        public let multiAZ: Bool?
        /// The network type of the DB instance. The network type is determined by the DBSubnetGroup specified for the DB cluster.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon Aurora User Guide.  This setting is only for Aurora DB clusters. Valid Values: IPV4 | DUAL
        public let networkType: String?
        /// Information about pending changes to the DB cluster. This information is returned only when there are pending changes. Specific changes are identified by subelements.
        public let pendingModifiedValues: ClusterPendingModifiedValues?
        /// The progress of the operation as a percentage.
        public let percentProgress: String?
        /// Indicates whether Performance Insights is enabled for the DB cluster. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let performanceInsightsEnabled: Bool?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. This setting is only for non-Aurora Multi-AZ DB clusters. Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days
        public let performanceInsightsRetentionPeriod: Int?
        /// The port that the database engine is listening on.
        public let port: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
        public let preferredMaintenanceWindow: String?
        /// Indicates whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. For more information, see CreateDBCluster. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let publiclyAccessible: Bool?
        /// Reserved for future use.
        public let rdsCustomClusterConfiguration: RdsCustomClusterConfiguration?
        /// The reader endpoint for the DB cluster. The reader endpoint for a DB cluster load-balances  connections across the Aurora Replicas that are available in a DB cluster. As clients request new connections  to the reader endpoint, Aurora distributes the connection requests among the Aurora Replicas in the DB cluster.  This functionality can help balance your read workload across multiple Aurora Replicas in your DB cluster. If a failover occurs, and the Aurora Replica that you are connected to is promoted  to be the primary instance, your connection is dropped. To  continue sending your read workload to other Aurora Replicas in the cluster, you can then reconnect to the reader endpoint.
        public let readerEndpoint: String?
        /// Contains one or more identifiers of the read replicas associated with this DB cluster.
        @OptionalCustomCoding<ArrayCoder<_ReadReplicaIdentifiersEncoding, String>>
        public var readReplicaIdentifiers: [String]?
        /// The identifier of the source DB cluster if this DB cluster is a read replica.
        public let replicationSourceIdentifier: String?
        public let scalingConfigurationInfo: ScalingConfigurationInfo?
        public let serverlessV2ScalingConfiguration: ServerlessV2ScalingConfigurationInfo?
        /// The current state of this DB cluster.
        public let status: String?
        /// Reserved for future use.
        @OptionalCustomCoding<ArrayCoder<_StatusInfosEncoding, DBClusterStatusInfo>>
        public var statusInfos: [DBClusterStatusInfo]?
        /// Indicates whether the DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// The storage throughput for the DB cluster. The throughput is automatically set based on the IOPS that you provision, and is not configurable. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let storageThroughput: Int?
        /// The storage type associated with the DB cluster.
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The list of VPC security groups that the DB cluster belongs to.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupsEncoding, VpcSecurityGroupMembership>>
        public var vpcSecurityGroups: [VpcSecurityGroupMembership]?

        public init(activityStreamKinesisStreamName: String? = nil, activityStreamKmsKeyId: String? = nil, activityStreamMode: ActivityStreamMode? = nil, activityStreamStatus: ActivityStreamStatus? = nil, allocatedStorage: Int? = nil, associatedRoles: [DBClusterRole]? = nil, automaticRestartTime: Date? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZones: [String]? = nil, awsBackupRecoveryPointArn: String? = nil, backtrackConsumedChangeRecords: Int64? = nil, backtrackWindow: Int64? = nil, backupRetentionPeriod: Int? = nil, capacity: Int? = nil, certificateDetails: CertificateDetails? = nil, characterSetName: String? = nil, cloneGroupId: String? = nil, clusterCreateTime: Date? = nil, copyTagsToSnapshot: Bool? = nil, crossAccountClone: Bool? = nil, customEndpoints: [String]? = nil, databaseName: String? = nil, dbClusterArn: String? = nil, dbClusterIdentifier: String? = nil, dbClusterInstanceClass: String? = nil, dbClusterMembers: [DBClusterMember]? = nil, dbClusterOptionGroupMemberships: [DBClusterOptionGroupStatus]? = nil, dbClusterParameterGroup: String? = nil, dbClusterResourceId: String? = nil, dbSubnetGroup: String? = nil, dbSystemId: String? = nil, deletionProtection: Bool? = nil, domainMemberships: [DomainMembership]? = nil, earliestBacktrackTime: Date? = nil, earliestRestorableTime: Date? = nil, enabledCloudwatchLogsExports: [String]? = nil, endpoint: String? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, globalWriteForwardingRequested: Bool? = nil, globalWriteForwardingStatus: WriteForwardingStatus? = nil, hostedZoneId: String? = nil, httpEndpointEnabled: Bool? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, ioOptimizedNextAllowedModificationTime: Date? = nil, iops: Int? = nil, kmsKeyId: String? = nil, latestRestorableTime: Date? = nil, limitlessDatabase: LimitlessDatabase? = nil, localWriteForwardingStatus: LocalWriteForwardingStatus? = nil, masterUsername: String? = nil, masterUserSecret: MasterUserSecret? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, pendingModifiedValues: ClusterPendingModifiedValues? = nil, percentProgress: String? = nil, performanceInsightsEnabled: Bool? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, rdsCustomClusterConfiguration: RdsCustomClusterConfiguration? = nil, readerEndpoint: String? = nil, readReplicaIdentifiers: [String]? = nil, replicationSourceIdentifier: String? = nil, scalingConfigurationInfo: ScalingConfigurationInfo? = nil, serverlessV2ScalingConfiguration: ServerlessV2ScalingConfigurationInfo? = nil, status: String? = nil, statusInfos: [DBClusterStatusInfo]? = nil, storageEncrypted: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tagList: [Tag]? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil) {
            self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
            self.activityStreamKmsKeyId = activityStreamKmsKeyId
            self.activityStreamMode = activityStreamMode
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.automaticRestartTime = automaticRestartTime
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZones = availabilityZones
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backtrackConsumedChangeRecords = backtrackConsumedChangeRecords
            self.backtrackWindow = backtrackWindow
            self.backupRetentionPeriod = backupRetentionPeriod
            self.capacity = capacity
            self.certificateDetails = certificateDetails
            self.characterSetName = characterSetName
            self.cloneGroupId = cloneGroupId
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.databaseName = databaseName
            self.dbClusterArn = dbClusterArn
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterInstanceClass = dbClusterInstanceClass
            self.dbClusterMembers = dbClusterMembers
            self.dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships
            self.dbClusterParameterGroup = dbClusterParameterGroup
            self.dbClusterResourceId = dbClusterResourceId
            self.dbSubnetGroup = dbSubnetGroup
            self.dbSystemId = dbSystemId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.earliestBacktrackTime = earliestBacktrackTime
            self.earliestRestorableTime = earliestRestorableTime
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.globalWriteForwardingRequested = globalWriteForwardingRequested
            self.globalWriteForwardingStatus = globalWriteForwardingStatus
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.ioOptimizedNextAllowedModificationTime = ioOptimizedNextAllowedModificationTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.limitlessDatabase = limitlessDatabase
            self.localWriteForwardingStatus = localWriteForwardingStatus
            self.masterUsername = masterUsername
            self.masterUserSecret = masterUserSecret
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.pendingModifiedValues = pendingModifiedValues
            self.percentProgress = percentProgress
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.rdsCustomClusterConfiguration = rdsCustomClusterConfiguration
            self.readerEndpoint = readerEndpoint
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.replicationSourceIdentifier = replicationSourceIdentifier
            self.scalingConfigurationInfo = scalingConfigurationInfo
            self.serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration
            self.status = status
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tagList = tagList
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
            case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
            case activityStreamMode = "ActivityStreamMode"
            case activityStreamStatus = "ActivityStreamStatus"
            case allocatedStorage = "AllocatedStorage"
            case associatedRoles = "AssociatedRoles"
            case automaticRestartTime = "AutomaticRestartTime"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZones = "AvailabilityZones"
            case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
            case backtrackConsumedChangeRecords = "BacktrackConsumedChangeRecords"
            case backtrackWindow = "BacktrackWindow"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case capacity = "Capacity"
            case certificateDetails = "CertificateDetails"
            case characterSetName = "CharacterSetName"
            case cloneGroupId = "CloneGroupId"
            case clusterCreateTime = "ClusterCreateTime"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case crossAccountClone = "CrossAccountClone"
            case customEndpoints = "CustomEndpoints"
            case databaseName = "DatabaseName"
            case dbClusterArn = "DBClusterArn"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterInstanceClass = "DBClusterInstanceClass"
            case dbClusterMembers = "DBClusterMembers"
            case dbClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
            case dbClusterParameterGroup = "DBClusterParameterGroup"
            case dbClusterResourceId = "DbClusterResourceId"
            case dbSubnetGroup = "DBSubnetGroup"
            case dbSystemId = "DBSystemId"
            case deletionProtection = "DeletionProtection"
            case domainMemberships = "DomainMemberships"
            case earliestBacktrackTime = "EarliestBacktrackTime"
            case earliestRestorableTime = "EarliestRestorableTime"
            case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case globalWriteForwardingRequested = "GlobalWriteForwardingRequested"
            case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
            case hostedZoneId = "HostedZoneId"
            case httpEndpointEnabled = "HttpEndpointEnabled"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case ioOptimizedNextAllowedModificationTime = "IOOptimizedNextAllowedModificationTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case latestRestorableTime = "LatestRestorableTime"
            case limitlessDatabase = "LimitlessDatabase"
            case localWriteForwardingStatus = "LocalWriteForwardingStatus"
            case masterUsername = "MasterUsername"
            case masterUserSecret = "MasterUserSecret"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case pendingModifiedValues = "PendingModifiedValues"
            case percentProgress = "PercentProgress"
            case performanceInsightsEnabled = "PerformanceInsightsEnabled"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case rdsCustomClusterConfiguration = "RdsCustomClusterConfiguration"
            case readerEndpoint = "ReaderEndpoint"
            case readReplicaIdentifiers = "ReadReplicaIdentifiers"
            case replicationSourceIdentifier = "ReplicationSourceIdentifier"
            case scalingConfigurationInfo = "ScalingConfigurationInfo"
            case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
            case status = "Status"
            case statusInfos = "StatusInfos"
            case storageEncrypted = "StorageEncrypted"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tagList = "TagList"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct DBClusterAutomatedBackup: AWSDecodableShape {
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }

        /// For all database engines except Amazon Aurora, AllocatedStorage specifies the allocated storage size in gibibytes (GiB).  For Aurora, AllocatedStorage always returns 1, because Aurora DB cluster storage size isn't fixed, but instead automatically adjusts as needed.
        public let allocatedStorage: Int?
        /// The Availability Zones where instances in the DB cluster can be created. For information on Amazon Web Services Regions and Availability Zones, see  Regions and Availability Zones.
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, String>>
        public var availabilityZones: [String]?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public let awsBackupRecoveryPointArn: String?
        /// The retention period for the automated backups.
        public let backupRetentionPeriod: Int?
        /// The time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public let clusterCreateTime: Date?
        /// The Amazon Resource Name (ARN) for the source DB cluster.
        public let dbClusterArn: String?
        /// The Amazon Resource Name (ARN) for the automated backups.
        public let dbClusterAutomatedBackupsArn: String?
        /// The identifier for the source DB cluster, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbClusterIdentifier: String?
        /// The resource ID for the source DB cluster, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbClusterResourceId: String?
        /// The name of the database engine for this automated backup.
        public let engine: String?
        /// The engine mode of the database engine for the automated backup.
        public let engineMode: String?
        /// The version of the database engine for the automated backup.
        public let engineVersion: String?
        /// Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The IOPS (I/O operations per second) value for the automated backup. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let iops: Int?
        /// The Amazon Web Services KMS key ID for an automated backup. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// The license model information for this DB cluster automated backup.
        public let licenseModel: String?
        /// The master user name of the automated backup.
        public let masterUsername: String?
        /// The port number that the automated backup used for connections. Default: Inherits from the source DB cluster Valid Values: 1150-65535
        public let port: Int?
        /// The Amazon Web Services Region associated with the automated backup.
        public let region: String?
        public let restoreWindow: RestoreWindow?
        /// A list of status information for an automated backup:    retained - Automated backups for deleted clusters.
        public let status: String?
        /// Indicates whether the source DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// The storage throughput for the automated backup. The throughput is automatically set based on the IOPS that you provision, and is not configurable. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let storageThroughput: Int?
        /// The storage type associated with the DB cluster. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let storageType: String?
        /// The VPC ID associated with the DB cluster.
        public let vpcId: String?

        public init(allocatedStorage: Int? = nil, availabilityZones: [String]? = nil, awsBackupRecoveryPointArn: String? = nil, backupRetentionPeriod: Int? = nil, clusterCreateTime: Date? = nil, dbClusterArn: String? = nil, dbClusterAutomatedBackupsArn: String? = nil, dbClusterIdentifier: String? = nil, dbClusterResourceId: String? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, port: Int? = nil, region: String? = nil, restoreWindow: RestoreWindow? = nil, status: String? = nil, storageEncrypted: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backupRetentionPeriod = backupRetentionPeriod
            self.clusterCreateTime = clusterCreateTime
            self.dbClusterArn = dbClusterArn
            self.dbClusterAutomatedBackupsArn = dbClusterAutomatedBackupsArn
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterResourceId = dbClusterResourceId
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.port = port
            self.region = region
            self.restoreWindow = restoreWindow
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZones = "AvailabilityZones"
            case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case clusterCreateTime = "ClusterCreateTime"
            case dbClusterArn = "DBClusterArn"
            case dbClusterAutomatedBackupsArn = "DBClusterAutomatedBackupsArn"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterResourceId = "DbClusterResourceId"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case port = "Port"
            case region = "Region"
            case restoreWindow = "RestoreWindow"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case vpcId = "VpcId"
        }
    }

    public struct DBClusterAutomatedBackupMessage: AWSDecodableShape {
        public struct _DBClusterAutomatedBackupsEncoding: ArrayCoderProperties { public static let member = "DBClusterAutomatedBackup" }

        /// A list of DBClusterAutomatedBackup backups.
        @OptionalCustomCoding<ArrayCoder<_DBClusterAutomatedBackupsEncoding, DBClusterAutomatedBackup>>
        public var dbClusterAutomatedBackups: [DBClusterAutomatedBackup]?
        /// The pagination token provided in the previous request. If this parameter is specified the response includes only  records beyond the marker, up to MaxRecords.
        public let marker: String?

        public init(dbClusterAutomatedBackups: [DBClusterAutomatedBackup]? = nil, marker: String? = nil) {
            self.dbClusterAutomatedBackups = dbClusterAutomatedBackups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterAutomatedBackups = "DBClusterAutomatedBackups"
            case marker = "Marker"
        }
    }

    public struct DBClusterBacktrack: AWSDecodableShape {
        /// The timestamp of the time from which the DB cluster was backtracked.
        public let backtrackedFrom: Date?
        /// Contains the backtrack identifier.
        public let backtrackIdentifier: String?
        /// The timestamp of the time at which the backtrack was requested.
        public let backtrackRequestCreationTime: Date?
        /// The timestamp of the time to which the DB cluster was backtracked.
        public let backtrackTo: Date?
        /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
        public let dbClusterIdentifier: String?
        /// The status of the backtrack. This property returns one of the following values:    applying - The backtrack is currently being applied to or rolled back from the DB cluster.    completed - The backtrack has successfully been applied to or rolled back from the DB cluster.    failed - An error occurred while the backtrack was applied to or rolled back from the DB cluster.    pending - The backtrack is currently pending application to or rollback from the DB cluster.
        public let status: String?

        public init(backtrackedFrom: Date? = nil, backtrackIdentifier: String? = nil, backtrackRequestCreationTime: Date? = nil, backtrackTo: Date? = nil, dbClusterIdentifier: String? = nil, status: String? = nil) {
            self.backtrackedFrom = backtrackedFrom
            self.backtrackIdentifier = backtrackIdentifier
            self.backtrackRequestCreationTime = backtrackRequestCreationTime
            self.backtrackTo = backtrackTo
            self.dbClusterIdentifier = dbClusterIdentifier
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case backtrackedFrom = "BacktrackedFrom"
            case backtrackIdentifier = "BacktrackIdentifier"
            case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
            case backtrackTo = "BacktrackTo"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case status = "Status"
        }
    }

    public struct DBClusterBacktrackMessage: AWSDecodableShape {
        public struct _DBClusterBacktracksEncoding: ArrayCoderProperties { public static let member = "DBClusterBacktrack" }

        /// Contains a list of backtracks for the user.
        @OptionalCustomCoding<ArrayCoder<_DBClusterBacktracksEncoding, DBClusterBacktrack>>
        public var dbClusterBacktracks: [DBClusterBacktrack]?
        /// A pagination token that can be used in a later DescribeDBClusterBacktracks request.
        public let marker: String?

        public init(dbClusterBacktracks: [DBClusterBacktrack]? = nil, marker: String? = nil) {
            self.dbClusterBacktracks = dbClusterBacktracks
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterBacktracks = "DBClusterBacktracks"
            case marker = "Marker"
        }
    }

    public struct DBClusterCapacityInfo: AWSDecodableShape {
        /// The current capacity of the DB cluster.
        public let currentCapacity: Int?
        /// A user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
        public let dbClusterIdentifier: String?
        /// A value that specifies the capacity that the DB cluster scales to next.
        public let pendingCapacity: Int?
        /// The number of seconds before a call to ModifyCurrentDBClusterCapacity times out.
        public let secondsBeforeTimeout: Int?
        /// The timeout action of a call to ModifyCurrentDBClusterCapacity, either  ForceApplyCapacityChange or RollbackCapacityChange.
        public let timeoutAction: String?

        public init(currentCapacity: Int? = nil, dbClusterIdentifier: String? = nil, pendingCapacity: Int? = nil, secondsBeforeTimeout: Int? = nil, timeoutAction: String? = nil) {
            self.currentCapacity = currentCapacity
            self.dbClusterIdentifier = dbClusterIdentifier
            self.pendingCapacity = pendingCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.timeoutAction = timeoutAction
        }

        private enum CodingKeys: String, CodingKey {
            case currentCapacity = "CurrentCapacity"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case pendingCapacity = "PendingCapacity"
            case secondsBeforeTimeout = "SecondsBeforeTimeout"
            case timeoutAction = "TimeoutAction"
        }
    }

    public struct DBClusterEndpoint: AWSDecodableShape {
        /// The type associated with a custom endpoint. One of: READER, WRITER, ANY.
        public let customEndpointType: String?
        /// The Amazon Resource Name (ARN) for the endpoint.
        public let dbClusterEndpointArn: String?
        /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
        public let dbClusterEndpointIdentifier: String?
        /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
        public let dbClusterEndpointResourceIdentifier: String?
        /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
        public let dbClusterIdentifier: String?
        /// The DNS address of the endpoint.
        public let endpoint: String?
        /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
        public let endpointType: String?
        /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var excludedMembers: [String]?
        /// List of DB instance identifiers that are part of the custom endpoint group.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var staticMembers: [String]?
        /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster, such as a writer endpoint for a read-only secondary cluster in a global database.
        public let status: String?

        public init(customEndpointType: String? = nil, dbClusterEndpointArn: String? = nil, dbClusterEndpointIdentifier: String? = nil, dbClusterEndpointResourceIdentifier: String? = nil, dbClusterIdentifier: String? = nil, endpoint: String? = nil, endpointType: String? = nil, excludedMembers: [String]? = nil, staticMembers: [String]? = nil, status: String? = nil) {
            self.customEndpointType = customEndpointType
            self.dbClusterEndpointArn = dbClusterEndpointArn
            self.dbClusterEndpointIdentifier = dbClusterEndpointIdentifier
            self.dbClusterEndpointResourceIdentifier = dbClusterEndpointResourceIdentifier
            self.dbClusterIdentifier = dbClusterIdentifier
            self.endpoint = endpoint
            self.endpointType = endpointType
            self.excludedMembers = excludedMembers
            self.staticMembers = staticMembers
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case customEndpointType = "CustomEndpointType"
            case dbClusterEndpointArn = "DBClusterEndpointArn"
            case dbClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
            case dbClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case endpoint = "Endpoint"
            case endpointType = "EndpointType"
            case excludedMembers = "ExcludedMembers"
            case staticMembers = "StaticMembers"
            case status = "Status"
        }
    }

    public struct DBClusterEndpointMessage: AWSDecodableShape {
        public struct _DBClusterEndpointsEncoding: ArrayCoderProperties { public static let member = "DBClusterEndpointList" }

        /// Contains the details of the endpoints associated with the cluster and matching any filter conditions.
        @OptionalCustomCoding<ArrayCoder<_DBClusterEndpointsEncoding, DBClusterEndpoint>>
        public var dbClusterEndpoints: [DBClusterEndpoint]?
        /// An optional pagination token provided by a previous DescribeDBClusterEndpoints request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbClusterEndpoints: [DBClusterEndpoint]? = nil, marker: String? = nil) {
            self.dbClusterEndpoints = dbClusterEndpoints
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterEndpoints = "DBClusterEndpoints"
            case marker = "Marker"
        }
    }

    public struct DBClusterMember: AWSDecodableShape {
        /// Specifies the status of the DB cluster parameter group for this member of the DB cluster.
        public let dbClusterParameterGroupStatus: String?
        /// Specifies the instance identifier for this member of the DB cluster.
        public let dbInstanceIdentifier: String?
        /// Indicates whether the cluster member is the primary DB instance for the DB cluster.
        public let isClusterWriter: Bool?
        /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance  after a failure of the existing primary instance. For more information,  see  Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide.
        public let promotionTier: Int?

        public init(dbClusterParameterGroupStatus: String? = nil, dbInstanceIdentifier: String? = nil, isClusterWriter: Bool? = nil, promotionTier: Int? = nil) {
            self.dbClusterParameterGroupStatus = dbClusterParameterGroupStatus
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupStatus = "DBClusterParameterGroupStatus"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case isClusterWriter = "IsClusterWriter"
            case promotionTier = "PromotionTier"
        }
    }

    public struct DBClusterMessage: AWSDecodableShape {
        public struct _DBClustersEncoding: ArrayCoderProperties { public static let member = "DBCluster" }

        /// Contains a list of DB clusters for the user.
        @OptionalCustomCoding<ArrayCoder<_DBClustersEncoding, DBCluster>>
        public var dbClusters: [DBCluster]?
        /// A pagination token that can be used in a later DescribeDBClusters request.
        public let marker: String?

        public init(dbClusters: [DBCluster]? = nil, marker: String? = nil) {
            self.dbClusters = dbClusters
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusters = "DBClusters"
            case marker = "Marker"
        }
    }

    public struct DBClusterOptionGroupStatus: AWSDecodableShape {
        /// Specifies the name of the DB cluster option group.
        public let dbClusterOptionGroupName: String?
        /// Specifies the status of the DB cluster option group.
        public let status: String?

        public init(dbClusterOptionGroupName: String? = nil, status: String? = nil) {
            self.dbClusterOptionGroupName = dbClusterOptionGroupName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterOptionGroupName = "DBClusterOptionGroupName"
            case status = "Status"
        }
    }

    public struct DBClusterParameterGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the DB cluster parameter group.
        public let dbClusterParameterGroupArn: String?
        /// The name of the DB cluster parameter group.
        public let dbClusterParameterGroupName: String?
        /// The name of the DB parameter group family that this DB cluster parameter group is compatible with.
        public let dbParameterGroupFamily: String?
        /// Provides the customer-specified description for this DB cluster parameter group.
        public let description: String?

        public init(dbClusterParameterGroupArn: String? = nil, dbClusterParameterGroupName: String? = nil, dbParameterGroupFamily: String? = nil, description: String? = nil) {
            self.dbClusterParameterGroupArn = dbClusterParameterGroupArn
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupArn = "DBClusterParameterGroupArn"
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case description = "Description"
        }
    }

    public struct DBClusterParameterGroupDetails: AWSDecodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// An optional pagination token provided by a previous DescribeDBClusterParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// Provides a list of parameters for the DB cluster parameter group.
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?

        public init(marker: String? = nil, parameters: [Parameter]? = nil) {
            self.marker = marker
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case parameters = "Parameters"
        }
    }

    public struct DBClusterParameterGroupNameMessage: AWSDecodableShape {
        /// The name of the DB cluster parameter group. Constraints:   Must be 1 to 255 letters or numbers.   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens    This value is stored as a lowercase string.
        public let dbClusterParameterGroupName: String?

        public init(dbClusterParameterGroupName: String? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
        }
    }

    public struct DBClusterParameterGroupsMessage: AWSDecodableShape {
        public struct _DBClusterParameterGroupsEncoding: ArrayCoderProperties { public static let member = "DBClusterParameterGroup" }

        /// A list of DB cluster parameter groups.
        @OptionalCustomCoding<ArrayCoder<_DBClusterParameterGroupsEncoding, DBClusterParameterGroup>>
        public var dbClusterParameterGroups: [DBClusterParameterGroup]?
        /// An optional pagination token provided by a previous DescribeDBClusterParameterGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbClusterParameterGroups: [DBClusterParameterGroup]? = nil, marker: String? = nil) {
            self.dbClusterParameterGroups = dbClusterParameterGroups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroups = "DBClusterParameterGroups"
            case marker = "Marker"
        }
    }

    public struct DBClusterRole: AWSDecodableShape {
        /// The name of the feature associated with the Amazon Web Services Identity and Access Management (IAM) role. For information about supported feature names, see DBEngineVersion.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
        public let roleArn: String?
        /// Describes the state of association between the IAM role and the DB cluster. The Status property returns one of the following values:    ACTIVE - the IAM role ARN is associated with the DB cluster and can be used to access other Amazon Web Services on your behalf.    PENDING - the IAM role ARN is being associated with the DB cluster.    INVALID - the IAM role ARN is associated with the DB cluster, but the DB cluster is unable to assume the IAM role in order to access other Amazon Web Services on your behalf.
        public let status: String?

        public init(featureName: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct DBClusterSnapshot: AWSDecodableShape {
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The allocated storage size of the DB cluster snapshot in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// The list of Availability Zones (AZs) where instances in the DB cluster snapshot can be restored.
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, String>>
        public var availabilityZones: [String]?
        /// The time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public let clusterCreateTime: Date?
        /// The DB cluster identifier of the DB cluster that this DB cluster snapshot was created from.
        public let dbClusterIdentifier: String?
        /// The resource ID of the DB cluster that this DB cluster snapshot was created from.
        public let dbClusterResourceId: String?
        /// The Amazon Resource Name (ARN) for the DB cluster snapshot.
        public let dbClusterSnapshotArn: String?
        /// The identifier for the DB cluster snapshot.
        public let dbClusterSnapshotIdentifier: String?
        /// Reserved for future use.
        public let dbSystemId: String?
        /// The name of the database engine for this DB cluster snapshot.
        public let engine: String?
        /// The engine mode of the database engine for this DB cluster snapshot.
        public let engineMode: String?
        /// The version of the database engine for this DB cluster snapshot.
        public let engineVersion: String?
        /// Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// If StorageEncrypted is true, the Amazon Web Services KMS key identifier for the encrypted DB cluster snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// The license model information for this DB cluster snapshot.
        public let licenseModel: String?
        /// The master username for this DB cluster snapshot.
        public let masterUsername: String?
        /// The percentage of the estimated data that has been transferred.
        public let percentProgress: Int?
        /// The port that the DB cluster was listening on at the time of the snapshot.
        public let port: Int?
        /// The time when the snapshot was taken, in Universal Coordinated Time (UTC).
        public let snapshotCreateTime: Date?
        /// The type of the DB cluster snapshot.
        public let snapshotType: String?
        /// If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.
        public let sourceDBClusterSnapshotArn: String?
        /// The status of this DB cluster snapshot. Valid statuses are the following:    available     copying     creating
        public let status: String?
        /// Indicates whether the DB cluster snapshot is encrypted.
        public let storageEncrypted: Bool?
        /// The storage throughput for the DB cluster snapshot. The throughput is automatically set based on the IOPS that you provision, and is not configurable. This setting is only for non-Aurora Multi-AZ DB clusters.
        public let storageThroughput: Int?
        /// The storage type associated with the DB cluster snapshot. This setting is only for Aurora DB clusters.
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The VPC ID associated with the DB cluster snapshot.
        public let vpcId: String?

        public init(allocatedStorage: Int? = nil, availabilityZones: [String]? = nil, clusterCreateTime: Date? = nil, dbClusterIdentifier: String? = nil, dbClusterResourceId: String? = nil, dbClusterSnapshotArn: String? = nil, dbClusterSnapshotIdentifier: String? = nil, dbSystemId: String? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, percentProgress: Int? = nil, port: Int? = nil, snapshotCreateTime: Date? = nil, snapshotType: String? = nil, sourceDBClusterSnapshotArn: String? = nil, status: String? = nil, storageEncrypted: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tagList: [Tag]? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterResourceId = dbClusterResourceId
            self.dbClusterSnapshotArn = dbClusterSnapshotArn
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.dbSystemId = dbSystemId
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tagList = tagList
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZones = "AvailabilityZones"
            case clusterCreateTime = "ClusterCreateTime"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterResourceId = "DbClusterResourceId"
            case dbClusterSnapshotArn = "DBClusterSnapshotArn"
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
            case dbSystemId = "DBSystemId"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case percentProgress = "PercentProgress"
            case port = "Port"
            case snapshotCreateTime = "SnapshotCreateTime"
            case snapshotType = "SnapshotType"
            case sourceDBClusterSnapshotArn = "SourceDBClusterSnapshotArn"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tagList = "TagList"
            case vpcId = "VpcId"
        }
    }

    public struct DBClusterSnapshotAttribute: AWSDecodableShape {
        public struct _AttributeValuesEncoding: ArrayCoderProperties { public static let member = "AttributeValue" }

        /// The name of the manual DB cluster snapshot attribute. The attribute named restore refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot. For more information,  see the ModifyDBClusterSnapshotAttribute API action.
        public let attributeName: String?
        /// The value(s) for the manual DB cluster snapshot attribute. If the AttributeName field is set to restore, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB cluster snapshot. If a value of all is in the list, then the manual DB cluster snapshot is public and available for any Amazon Web Services account to copy or restore.
        @OptionalCustomCoding<ArrayCoder<_AttributeValuesEncoding, String>>
        public var attributeValues: [String]?

        public init(attributeName: String? = nil, attributeValues: [String]? = nil) {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeValues = "AttributeValues"
        }
    }

    public struct DBClusterSnapshotAttributesResult: AWSDecodableShape {
        public struct _DBClusterSnapshotAttributesEncoding: ArrayCoderProperties { public static let member = "DBClusterSnapshotAttribute" }

        /// The list of attributes and values for the manual DB cluster snapshot.
        @OptionalCustomCoding<ArrayCoder<_DBClusterSnapshotAttributesEncoding, DBClusterSnapshotAttribute>>
        public var dbClusterSnapshotAttributes: [DBClusterSnapshotAttribute]?
        /// The identifier of the manual DB cluster snapshot that the attributes apply to.
        public let dbClusterSnapshotIdentifier: String?

        public init(dbClusterSnapshotAttributes: [DBClusterSnapshotAttribute]? = nil, dbClusterSnapshotIdentifier: String? = nil) {
            self.dbClusterSnapshotAttributes = dbClusterSnapshotAttributes
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshotAttributes = "DBClusterSnapshotAttributes"
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        }
    }

    public struct DBClusterSnapshotMessage: AWSDecodableShape {
        public struct _DBClusterSnapshotsEncoding: ArrayCoderProperties { public static let member = "DBClusterSnapshot" }

        /// Provides a list of DB cluster snapshots for the user.
        @OptionalCustomCoding<ArrayCoder<_DBClusterSnapshotsEncoding, DBClusterSnapshot>>
        public var dbClusterSnapshots: [DBClusterSnapshot]?
        /// An optional pagination token provided by a previous DescribeDBClusterSnapshots request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbClusterSnapshots: [DBClusterSnapshot]? = nil, marker: String? = nil) {
            self.dbClusterSnapshots = dbClusterSnapshots
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshots = "DBClusterSnapshots"
            case marker = "Marker"
        }
    }

    public struct DBClusterStatusInfo: AWSDecodableShape {
        /// Reserved for future use.
        public let message: String?
        /// Reserved for future use.
        public let normal: Bool?
        /// Reserved for future use.
        public let status: String?
        /// Reserved for future use.
        public let statusType: String?

        public init(message: String? = nil, normal: Bool? = nil, status: String? = nil, statusType: String? = nil) {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case normal = "Normal"
            case status = "Status"
            case statusType = "StatusType"
        }
    }

    public struct DBEngineVersion: AWSDecodableShape {
        public struct _SupportedCharacterSetsEncoding: ArrayCoderProperties { public static let member = "CharacterSet" }
        public struct _SupportedNcharCharacterSetsEncoding: ArrayCoderProperties { public static let member = "CharacterSet" }
        public struct _SupportedTimezonesEncoding: ArrayCoderProperties { public static let member = "Timezone" }
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _ValidUpgradeTargetEncoding: ArrayCoderProperties { public static let member = "UpgradeTarget" }

        /// The creation time of the DB engine version.
        public let createTime: Date?
        /// JSON string that lists the installation files and parameters that RDS Custom uses to create a custom engine version (CEV).  RDS Custom applies the patches in the order in which they're listed in the manifest. You can set the Oracle home, Oracle base,  and UNIX/Linux user and group using the installation parameters. For more information,  see JSON fields in the CEV manifest in the Amazon RDS User Guide.
        public let customDBEngineVersionManifest: String?
        /// The name of the Amazon S3 bucket that contains your database installation files.
        public let databaseInstallationFilesS3BucketName: String?
        /// The Amazon S3 directory that contains the database installation files.  If not specified, then no prefix is assumed.
        public let databaseInstallationFilesS3Prefix: String?
        /// The description of the database engine.
        public let dbEngineDescription: String?
        /// A value that indicates the source media provider of the AMI based on the usage operation.  Applicable for RDS Custom for SQL Server.
        public let dbEngineMediaType: String?
        /// The ARN of the custom engine version.
        public let dbEngineVersionArn: String?
        /// The description of the database engine version.
        public let dbEngineVersionDescription: String?
        /// The name of the DB parameter group family for the database engine.
        public let dbParameterGroupFamily: String?
        /// The default character set for new instances of this engine version, if the CharacterSetName parameter of the CreateDBInstance API isn't specified.
        public let defaultCharacterSet: CharacterSet?
        /// The name of the database engine.
        public let engine: String?
        /// The version number of the database engine.
        public let engineVersion: String?
        /// The types of logs that the database engine has available for export to CloudWatch Logs.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var exportableLogTypes: [String]?
        /// The EC2 image
        public let image: CustomDBEngineVersionAMI?
        /// The Amazon Web Services KMS key identifier for an encrypted CEV. This parameter is required for  RDS Custom, but optional for Amazon RDS.
        public let kmsKeyId: String?
        /// The major engine version of the CEV.
        public let majorEngineVersion: String?
        /// The status of the DB engine version, either available or deprecated.
        public let status: String?
        /// A list of the supported CA certificate identifiers. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide and   Using SSL/TLS to encrypt a connection to a DB cluster in the Amazon Aurora  User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedCACertificateIdentifiers: [String]?
        /// A list of the character sets supported by this engine for the CharacterSetName parameter of the CreateDBInstance operation.
        @OptionalCustomCoding<ArrayCoder<_SupportedCharacterSetsEncoding, CharacterSet>>
        public var supportedCharacterSets: [CharacterSet]?
        /// A list of the supported DB engine modes.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedEngineModes: [String]?
        /// A list of features supported by the DB engine. The supported features vary by DB engine and DB engine version. To determine the supported features for a specific DB engine and DB engine version using the CLI,  use the following command:  aws rds describe-db-engine-versions --engine  --engine-version   For example, to determine the supported features for RDS for PostgreSQL version 13.3 using the CLI,  use the following command:  aws rds describe-db-engine-versions --engine postgres --engine-version 13.3  The supported features are listed under SupportedFeatureNames in the output.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedFeatureNames: [String]?
        /// A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.
        @OptionalCustomCoding<ArrayCoder<_SupportedNcharCharacterSetsEncoding, CharacterSet>>
        public var supportedNcharCharacterSets: [CharacterSet]?
        /// A list of the time zones supported by this engine for the Timezone parameter of the CreateDBInstance action.
        @OptionalCustomCoding<ArrayCoder<_SupportedTimezonesEncoding, Timezone>>
        public var supportedTimezones: [Timezone]?
        /// Indicates whether the engine version supports Babelfish for Aurora PostgreSQL.
        public let supportsBabelfish: Bool?
        /// Indicates whether the engine version supports rotating the server certificate without  rebooting the DB instance.
        public let supportsCertificateRotationWithoutRestart: Bool?
        /// Indicates whether you can use Aurora global databases with a specific DB engine version.
        public let supportsGlobalDatabases: Bool?
        /// Indicates whether the DB engine version supports zero-ETL integrations with Amazon Redshift.
        public let supportsIntegrations: Bool?
        /// Indicates whether the DB engine version supports forwarding write operations from reader DB instances  to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances. Valid for: Aurora DB clusters only
        public let supportsLocalWriteForwarding: Bool?
        /// Indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.
        public let supportsLogExportsToCloudwatchLogs: Bool?
        /// Indicates whether you can use Aurora parallel query with a specific DB engine version.
        public let supportsParallelQuery: Bool?
        /// Indicates whether the database engine version supports read replicas.
        public let supportsReadReplica: Bool?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// A list of engine versions that this database engine version can be upgraded to.
        @OptionalCustomCoding<ArrayCoder<_ValidUpgradeTargetEncoding, UpgradeTarget>>
        public var validUpgradeTarget: [UpgradeTarget]?

        public init(createTime: Date? = nil, customDBEngineVersionManifest: String? = nil, databaseInstallationFilesS3BucketName: String? = nil, databaseInstallationFilesS3Prefix: String? = nil, dbEngineDescription: String? = nil, dbEngineMediaType: String? = nil, dbEngineVersionArn: String? = nil, dbEngineVersionDescription: String? = nil, dbParameterGroupFamily: String? = nil, defaultCharacterSet: CharacterSet? = nil, engine: String? = nil, engineVersion: String? = nil, exportableLogTypes: [String]? = nil, image: CustomDBEngineVersionAMI? = nil, kmsKeyId: String? = nil, majorEngineVersion: String? = nil, status: String? = nil, supportedCACertificateIdentifiers: [String]? = nil, supportedCharacterSets: [CharacterSet]? = nil, supportedEngineModes: [String]? = nil, supportedFeatureNames: [String]? = nil, supportedNcharCharacterSets: [CharacterSet]? = nil, supportedTimezones: [Timezone]? = nil, supportsBabelfish: Bool? = nil, supportsCertificateRotationWithoutRestart: Bool? = nil, supportsGlobalDatabases: Bool? = nil, supportsIntegrations: Bool? = nil, supportsLocalWriteForwarding: Bool? = nil, supportsLogExportsToCloudwatchLogs: Bool? = nil, supportsParallelQuery: Bool? = nil, supportsReadReplica: Bool? = nil, tagList: [Tag]? = nil, validUpgradeTarget: [UpgradeTarget]? = nil) {
            self.createTime = createTime
            self.customDBEngineVersionManifest = customDBEngineVersionManifest
            self.databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName
            self.databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix
            self.dbEngineDescription = dbEngineDescription
            self.dbEngineMediaType = dbEngineMediaType
            self.dbEngineVersionArn = dbEngineVersionArn
            self.dbEngineVersionDescription = dbEngineVersionDescription
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.defaultCharacterSet = defaultCharacterSet
            self.engine = engine
            self.engineVersion = engineVersion
            self.exportableLogTypes = exportableLogTypes
            self.image = image
            self.kmsKeyId = kmsKeyId
            self.majorEngineVersion = majorEngineVersion
            self.status = status
            self.supportedCACertificateIdentifiers = supportedCACertificateIdentifiers
            self.supportedCharacterSets = supportedCharacterSets
            self.supportedEngineModes = supportedEngineModes
            self.supportedFeatureNames = supportedFeatureNames
            self.supportedNcharCharacterSets = supportedNcharCharacterSets
            self.supportedTimezones = supportedTimezones
            self.supportsBabelfish = supportsBabelfish
            self.supportsCertificateRotationWithoutRestart = supportsCertificateRotationWithoutRestart
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsIntegrations = supportsIntegrations
            self.supportsLocalWriteForwarding = supportsLocalWriteForwarding
            self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
            self.supportsParallelQuery = supportsParallelQuery
            self.supportsReadReplica = supportsReadReplica
            self.tagList = tagList
            self.validUpgradeTarget = validUpgradeTarget
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case customDBEngineVersionManifest = "CustomDBEngineVersionManifest"
            case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
            case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
            case dbEngineDescription = "DBEngineDescription"
            case dbEngineMediaType = "DBEngineMediaType"
            case dbEngineVersionArn = "DBEngineVersionArn"
            case dbEngineVersionDescription = "DBEngineVersionDescription"
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case defaultCharacterSet = "DefaultCharacterSet"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case exportableLogTypes = "ExportableLogTypes"
            case image = "Image"
            case kmsKeyId = "KMSKeyId"
            case majorEngineVersion = "MajorEngineVersion"
            case status = "Status"
            case supportedCACertificateIdentifiers = "SupportedCACertificateIdentifiers"
            case supportedCharacterSets = "SupportedCharacterSets"
            case supportedEngineModes = "SupportedEngineModes"
            case supportedFeatureNames = "SupportedFeatureNames"
            case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
            case supportedTimezones = "SupportedTimezones"
            case supportsBabelfish = "SupportsBabelfish"
            case supportsCertificateRotationWithoutRestart = "SupportsCertificateRotationWithoutRestart"
            case supportsGlobalDatabases = "SupportsGlobalDatabases"
            case supportsIntegrations = "SupportsIntegrations"
            case supportsLocalWriteForwarding = "SupportsLocalWriteForwarding"
            case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
            case supportsParallelQuery = "SupportsParallelQuery"
            case supportsReadReplica = "SupportsReadReplica"
            case tagList = "TagList"
            case validUpgradeTarget = "ValidUpgradeTarget"
        }
    }

    public struct DBEngineVersionMessage: AWSDecodableShape {
        public struct _DBEngineVersionsEncoding: ArrayCoderProperties { public static let member = "DBEngineVersion" }

        /// A list of DBEngineVersion elements.
        @OptionalCustomCoding<ArrayCoder<_DBEngineVersionsEncoding, DBEngineVersion>>
        public var dbEngineVersions: [DBEngineVersion]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbEngineVersions: [DBEngineVersion]? = nil, marker: String? = nil) {
            self.dbEngineVersions = dbEngineVersions
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbEngineVersions = "DBEngineVersions"
            case marker = "Marker"
        }
    }

    public struct DBInstance: AWSDecodableShape {
        public struct _AssociatedRolesEncoding: ArrayCoderProperties { public static let member = "DBInstanceRole" }
        public struct _DBInstanceAutomatedBackupsReplicationsEncoding: ArrayCoderProperties { public static let member = "DBInstanceAutomatedBackupsReplication" }
        public struct _DBParameterGroupsEncoding: ArrayCoderProperties { public static let member = "DBParameterGroup" }
        public struct _DBSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroup" }
        public struct _DomainMembershipsEncoding: ArrayCoderProperties { public static let member = "DomainMembership" }
        public struct _OptionGroupMembershipsEncoding: ArrayCoderProperties { public static let member = "OptionGroupMembership" }
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _ReadReplicaDBClusterIdentifiersEncoding: ArrayCoderProperties { public static let member = "ReadReplicaDBClusterIdentifier" }
        public struct _ReadReplicaDBInstanceIdentifiersEncoding: ArrayCoderProperties { public static let member = "ReadReplicaDBInstanceIdentifier" }
        public struct _StatusInfosEncoding: ArrayCoderProperties { public static let member = "DBInstanceStatusInfo" }
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupMembership" }

        /// Indicates whether engine-native audit fields are included in the database activity stream.
        public let activityStreamEngineNativeAuditFieldsIncluded: Bool?
        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public let activityStreamKinesisStreamName: String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream.  The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let activityStreamKmsKeyId: String?
        /// The mode of the database activity stream. Database events such as a change or access generate  an activity stream event. RDS for Oracle always handles these events asynchronously.
        public let activityStreamMode: ActivityStreamMode?
        /// The status of the policy state of the activity stream.
        public let activityStreamPolicyStatus: ActivityStreamPolicyStatus?
        /// The status of the database activity stream.
        public let activityStreamStatus: ActivityStreamStatus?
        /// The amount of storage in gibibytes (GiB) allocated for the DB instance.
        public let allocatedStorage: Int?
        /// The Amazon Web Services Identity and Access Management (IAM) roles associated with the DB instance.
        @OptionalCustomCoding<ArrayCoder<_AssociatedRolesEncoding, DBInstanceRole>>
        public var associatedRoles: [DBInstanceRole]?
        /// The time when a stopped DB instance is restarted automatically.
        public let automaticRestartTime: Date?
        /// The automation mode of the RDS Custom DB instance: full or all paused.  If full, the DB instance automates monitoring and instance recovery. If  all paused, the instance pauses automation for the duration set by  --resume-full-automation-mode-minutes.
        public let automationMode: AutomationMode?
        /// Indicates whether minor version patches are applied automatically.
        public let autoMinorVersionUpgrade: Bool?
        /// The name of the Availability Zone where the DB instance is located.
        public let availabilityZone: String?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public let awsBackupRecoveryPointArn: String?
        /// The number of days for which automatic DB snapshots are retained.
        public let backupRetentionPeriod: Int?
        /// The location where automated backups and manual snapshots are stored: Amazon Web Services Outposts or the Amazon Web Services Region.
        public let backupTarget: String?
        /// The identifier of the CA certificate for this DB instance. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide and   Using SSL/TLS to encrypt a connection to a DB cluster in the Amazon Aurora  User Guide.
        public let caCertificateIdentifier: String?
        /// The details of the DB instance's server certificate.
        public let certificateDetails: CertificateDetails?
        /// If present, specifies the name of the character set that this instance is associated with.
        public let characterSetName: String?
        /// Indicates whether tags are copied from the DB instance to snapshots of the DB instance. This setting doesn't apply to Amazon Aurora DB instances. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting. For more information, see DBCluster.
        public let copyTagsToSnapshot: Bool?
        /// Indicates whether a customer-owned IP address (CoIP) is enabled for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide. For more information about CoIPs, see Customer-owned IP addresses  in the Amazon Web Services Outposts User Guide.
        public let customerOwnedIpEnabled: Bool?
        /// The instance profile associated with the underlying Amazon EC2 instance of an  RDS Custom DB instance. The instance profile must meet the following requirements:   The profile must exist in your account.   The profile must have an IAM role that Amazon EC2 has permissions to assume.   The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.   For the list of permissions required for the IAM role, see   Configure IAM and your VPC in the Amazon RDS User Guide.
        public let customIamInstanceProfile: String?
        /// If the DB instance is a member of a DB cluster, indicates the name of the DB cluster that the DB instance is a member of.
        public let dbClusterIdentifier: String?
        /// The Amazon Resource Name (ARN) for the DB instance.
        public let dbInstanceArn: String?
        /// The list of replicated automated backups associated with the DB instance.
        @OptionalCustomCoding<ArrayCoder<_DBInstanceAutomatedBackupsReplicationsEncoding, DBInstanceAutomatedBackupsReplication>>
        public var dbInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]?
        /// The name of the compute and memory capacity class of the DB instance.
        public let dbInstanceClass: String?
        /// The user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public let dbInstanceIdentifier: String?
        /// The port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public let dbInstancePort: Int?
        /// The current state of this database. For information about DB instance statuses, see Viewing DB instance status  in the Amazon RDS User Guide.
        public let dbInstanceStatus: String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in Amazon Web Services CloudTrail log  entries whenever the Amazon Web Services KMS key for the DB instance is accessed.
        public let dbiResourceId: String?
        /// The initial database name that you provided (if required) when you created the DB instance. This name is returned for the life of your DB instance. For an RDS for Oracle CDB instance, the name identifies the PDB rather than the CDB.
        public let dbName: String?
        /// The list of DB parameter groups applied to this DB instance.
        @OptionalCustomCoding<ArrayCoder<_DBParameterGroupsEncoding, DBParameterGroupStatus>>
        public var dbParameterGroups: [DBParameterGroupStatus]?
        /// A list of DB security group elements containing  DBSecurityGroup.Name and DBSecurityGroup.Status subelements.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupsEncoding, DBSecurityGroupMembership>>
        public var dbSecurityGroups: [DBSecurityGroupMembership]?
        /// Information about the subnet group associated with the DB instance, including the name, description, and subnets in the subnet group.
        public let dbSubnetGroup: DBSubnetGroup?
        /// The Oracle system ID (Oracle SID) for a container database (CDB). The Oracle SID is also the name of the CDB. This setting is only valid for RDS Custom DB instances.
        public let dbSystemId: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        public let dedicatedLogVolume: Bool?
        /// Indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. For more information, see   Deleting a DB Instance.
        public let deletionProtection: Bool?
        /// The Active Directory Domain membership records associated with the DB instance.
        @OptionalCustomCoding<ArrayCoder<_DomainMembershipsEncoding, DomainMembership>>
        public var domainMemberships: [DomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs. Log types vary by DB engine. For information about the log types for each DB engine, see Monitoring Amazon RDS log files in the Amazon RDS User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enabledCloudwatchLogsExports: [String]?
        /// The connection endpoint for the DB instance.  The endpoint might not be shown for instances with the status of creating.
        public let endpoint: Endpoint?
        /// The database engine used for this DB instance.
        public let engine: String?
        /// The version of the database engine.
        public let engineVersion: String?
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log stream that receives the Enhanced Monitoring metrics data for the DB instance.
        public let enhancedMonitoringResourceArn: String?
        /// Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled for the DB instance. For a list of engine versions that support IAM database authentication, see  IAM database authentication in the Amazon RDS User Guide and IAM  database authentication in Aurora in the Amazon Aurora User Guide.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The date and time when the DB instance was created.
        public let instanceCreateTime: Date?
        /// The Provisioned IOPS (I/O operations per second) value for the DB instance.
        public let iops: Int?
        /// Indicates whether an upgrade is recommended for the storage file system configuration on the DB instance. To migrate to the preferred configuration, you can either create a blue/green deployment, or create a read replica from the DB instance. For more information, see Upgrading the storage file system for a DB instance.
        public let isStorageConfigUpgradeAvailable: Bool?
        /// If StorageEncrypted is enabled, the Amazon Web Services KMS key identifier  for the encrypted DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// The latest time to which a database in this DB instance can be restored with point-in-time restore.
        public let latestRestorableTime: Date?
        /// The license model information for this DB instance. This setting doesn't apply to RDS Custom DB instances.
        public let licenseModel: String?
        /// The listener connection endpoint for SQL Server Always On.
        public let listenerEndpoint: Endpoint?
        /// The master username for the DB instance.
        public let masterUsername: String?
        /// The secret managed by RDS in Amazon Web Services Secrets Manager for the master user password. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide.
        public let masterUserSecret: MasterUserSecret?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
        public let monitoringRoleArn: String?
        /// Indicates whether the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom DB instances.
        public let multiAZ: Bool?
        /// Specifies whether the DB instance is in the multi-tenant configuration (TRUE) or the single-tenant configuration (FALSE).
        public let multiTenant: Bool?
        /// The name of the NCHAR character set for the Oracle DB instance. This character set specifies the Unicode encoding for data stored in table columns of type NCHAR, NCLOB, or NVARCHAR2.
        public let ncharCharacterSetName: String?
        /// The network type of the DB instance. The network type is determined by the DBSubnetGroup specified for the DB instance.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide and   Working with a DB instance in a VPC in the  Amazon Aurora User Guide.  Valid Values: IPV4 | DUAL
        public let networkType: String?
        /// The list of option group memberships for this DB instance.
        @OptionalCustomCoding<ArrayCoder<_OptionGroupMembershipsEncoding, OptionGroupMembership>>
        public var optionGroupMemberships: [OptionGroupMembership]?
        /// Information about pending changes to the DB instance. This information is returned only when there are pending changes. Specific changes are identified by subelements.
        public let pendingModifiedValues: PendingModifiedValues?
        /// The progress of the storage optimization operation as a percentage.
        public let percentProgress: String?
        /// Indicates whether Performance Insights is enabled for the DB instance.
        public let performanceInsightsEnabled: Bool?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days
        public let performanceInsightsRetentionPeriod: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
        public let preferredMaintenanceWindow: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// The order of priority in which an Aurora Replica is promoted to the primary instance  after a failure of the existing primary instance. For more information,  see  Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide.
        public let promotionTier: Int?
        /// Indicates whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see CreateDBInstance.
        public let publiclyAccessible: Bool?
        /// The identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica. For example, when you create an Aurora read replica of an RDS for MySQL DB instance, the Aurora MySQL DB cluster for the Aurora read replica is shown. This output doesn't contain information about cross-Region Aurora read replicas.  Currently, each RDS DB instance can have only one Aurora read replica.
        @OptionalCustomCoding<ArrayCoder<_ReadReplicaDBClusterIdentifiersEncoding, String>>
        public var readReplicaDBClusterIdentifiers: [String]?
        /// The identifiers of the read replicas associated with this DB instance.
        @OptionalCustomCoding<ArrayCoder<_ReadReplicaDBInstanceIdentifiersEncoding, String>>
        public var readReplicaDBInstanceIdentifiers: [String]?
        /// The identifier of the source DB cluster if this DB instance is a read replica.
        public let readReplicaSourceDBClusterIdentifier: String?
        /// The identifier of the source DB instance if this DB instance is a read replica.
        public let readReplicaSourceDBInstanceIdentifier: String?
        /// The open mode of an Oracle read replica. The default is open-read-only.  For more information, see Working with Oracle Read Replicas for Amazon RDS  in the Amazon RDS User Guide.  This attribute is only supported in RDS for Oracle.
        public let replicaMode: ReplicaMode?
        /// The number of minutes to pause the automation. When the time period ends, RDS Custom resumes full automation.  The minimum value is 60 (default). The maximum value is 1,440.
        public let resumeFullAutomationModeTime: Date?
        /// If present, specifies the name of the secondary Availability Zone for a DB instance with multi-AZ support.
        public let secondaryAvailabilityZone: String?
        /// The status of a read replica. If the DB instance isn't a read replica, the value is blank.
        @OptionalCustomCoding<ArrayCoder<_StatusInfosEncoding, DBInstanceStatusInfo>>
        public var statusInfos: [DBInstanceStatusInfo]?
        /// Indicates whether the DB instance is encrypted.
        public let storageEncrypted: Bool?
        /// The storage throughput for the DB instance. This setting applies only to the gp3 storage type.
        public let storageThroughput: Int?
        /// The storage type associated with the DB instance.
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the DB instance. In most cases, the Timezone element is empty. Timezone content appears only for Microsoft SQL Server DB instances  that were created with a time zone specified.
        public let timezone: String?
        /// The list of Amazon EC2 VPC security groups that the DB instance belongs to.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupsEncoding, VpcSecurityGroupMembership>>
        public var vpcSecurityGroups: [VpcSecurityGroupMembership]?

        public init(activityStreamEngineNativeAuditFieldsIncluded: Bool? = nil, activityStreamKinesisStreamName: String? = nil, activityStreamKmsKeyId: String? = nil, activityStreamMode: ActivityStreamMode? = nil, activityStreamPolicyStatus: ActivityStreamPolicyStatus? = nil, activityStreamStatus: ActivityStreamStatus? = nil, allocatedStorage: Int? = nil, associatedRoles: [DBInstanceRole]? = nil, automaticRestartTime: Date? = nil, automationMode: AutomationMode? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, awsBackupRecoveryPointArn: String? = nil, backupRetentionPeriod: Int? = nil, backupTarget: String? = nil, caCertificateIdentifier: String? = nil, certificateDetails: CertificateDetails? = nil, characterSetName: String? = nil, copyTagsToSnapshot: Bool? = nil, customerOwnedIpEnabled: Bool? = nil, customIamInstanceProfile: String? = nil, dbClusterIdentifier: String? = nil, dbInstanceArn: String? = nil, dbInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbInstancePort: Int? = nil, dbInstanceStatus: String? = nil, dbiResourceId: String? = nil, dbName: String? = nil, dbParameterGroups: [DBParameterGroupStatus]? = nil, dbSecurityGroups: [DBSecurityGroupMembership]? = nil, dbSubnetGroup: DBSubnetGroup? = nil, dbSystemId: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, domainMemberships: [DomainMembership]? = nil, enabledCloudwatchLogsExports: [String]? = nil, endpoint: Endpoint? = nil, engine: String? = nil, engineVersion: String? = nil, enhancedMonitoringResourceArn: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: Date? = nil, iops: Int? = nil, isStorageConfigUpgradeAvailable: Bool? = nil, kmsKeyId: String? = nil, latestRestorableTime: Date? = nil, licenseModel: String? = nil, listenerEndpoint: Endpoint? = nil, masterUsername: String? = nil, masterUserSecret: MasterUserSecret? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAZ: Bool? = nil, multiTenant: Bool? = nil, ncharCharacterSetName: String? = nil, networkType: String? = nil, optionGroupMemberships: [OptionGroupMembership]? = nil, pendingModifiedValues: PendingModifiedValues? = nil, percentProgress: String? = nil, performanceInsightsEnabled: Bool? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, processorFeatures: [ProcessorFeature]? = nil, promotionTier: Int? = nil, publiclyAccessible: Bool? = nil, readReplicaDBClusterIdentifiers: [String]? = nil, readReplicaDBInstanceIdentifiers: [String]? = nil, readReplicaSourceDBClusterIdentifier: String? = nil, readReplicaSourceDBInstanceIdentifier: String? = nil, replicaMode: ReplicaMode? = nil, resumeFullAutomationModeTime: Date? = nil, secondaryAvailabilityZone: String? = nil, statusInfos: [DBInstanceStatusInfo]? = nil, storageEncrypted: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tagList: [Tag]? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil) {
            self.activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncluded
            self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
            self.activityStreamKmsKeyId = activityStreamKmsKeyId
            self.activityStreamMode = activityStreamMode
            self.activityStreamPolicyStatus = activityStreamPolicyStatus
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.automaticRestartTime = automaticRestartTime
            self.automationMode = automationMode
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backupRetentionPeriod = backupRetentionPeriod
            self.backupTarget = backupTarget
            self.caCertificateIdentifier = caCertificateIdentifier
            self.certificateDetails = certificateDetails
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customerOwnedIpEnabled = customerOwnedIpEnabled
            self.customIamInstanceProfile = customIamInstanceProfile
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceArn = dbInstanceArn
            self.dbInstanceAutomatedBackupsReplications = dbInstanceAutomatedBackupsReplications
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbInstancePort = dbInstancePort
            self.dbInstanceStatus = dbInstanceStatus
            self.dbiResourceId = dbiResourceId
            self.dbName = dbName
            self.dbParameterGroups = dbParameterGroups
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroup = dbSubnetGroup
            self.dbSystemId = dbSystemId
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.isStorageConfigUpgradeAvailable = isStorageConfigUpgradeAvailable
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.masterUserSecret = masterUserSecret
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.multiTenant = multiTenant
            self.ncharCharacterSetName = ncharCharacterSetName
            self.networkType = networkType
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.percentProgress = percentProgress
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBClusterIdentifier = readReplicaSourceDBClusterIdentifier
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.replicaMode = replicaMode
            self.resumeFullAutomationModeTime = resumeFullAutomationModeTime
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tagList = tagList
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case activityStreamEngineNativeAuditFieldsIncluded = "ActivityStreamEngineNativeAuditFieldsIncluded"
            case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
            case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
            case activityStreamMode = "ActivityStreamMode"
            case activityStreamPolicyStatus = "ActivityStreamPolicyStatus"
            case activityStreamStatus = "ActivityStreamStatus"
            case allocatedStorage = "AllocatedStorage"
            case associatedRoles = "AssociatedRoles"
            case automaticRestartTime = "AutomaticRestartTime"
            case automationMode = "AutomationMode"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case backupTarget = "BackupTarget"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case certificateDetails = "CertificateDetails"
            case characterSetName = "CharacterSetName"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case customerOwnedIpEnabled = "CustomerOwnedIpEnabled"
            case customIamInstanceProfile = "CustomIamInstanceProfile"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbInstanceArn = "DBInstanceArn"
            case dbInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbInstancePort = "DbInstancePort"
            case dbInstanceStatus = "DBInstanceStatus"
            case dbiResourceId = "DbiResourceId"
            case dbName = "DBName"
            case dbParameterGroups = "DBParameterGroups"
            case dbSecurityGroups = "DBSecurityGroups"
            case dbSubnetGroup = "DBSubnetGroup"
            case dbSystemId = "DBSystemId"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case domainMemberships = "DomainMemberships"
            case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case isStorageConfigUpgradeAvailable = "IsStorageConfigUpgradeAvailable"
            case kmsKeyId = "KmsKeyId"
            case latestRestorableTime = "LatestRestorableTime"
            case licenseModel = "LicenseModel"
            case listenerEndpoint = "ListenerEndpoint"
            case masterUsername = "MasterUsername"
            case masterUserSecret = "MasterUserSecret"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAZ = "MultiAZ"
            case multiTenant = "MultiTenant"
            case ncharCharacterSetName = "NcharCharacterSetName"
            case networkType = "NetworkType"
            case optionGroupMemberships = "OptionGroupMemberships"
            case pendingModifiedValues = "PendingModifiedValues"
            case percentProgress = "PercentProgress"
            case performanceInsightsEnabled = "PerformanceInsightsEnabled"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case processorFeatures = "ProcessorFeatures"
            case promotionTier = "PromotionTier"
            case publiclyAccessible = "PubliclyAccessible"
            case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
            case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
            case readReplicaSourceDBClusterIdentifier = "ReadReplicaSourceDBClusterIdentifier"
            case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
            case replicaMode = "ReplicaMode"
            case resumeFullAutomationModeTime = "ResumeFullAutomationModeTime"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case statusInfos = "StatusInfos"
            case storageEncrypted = "StorageEncrypted"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tagList = "TagList"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct DBInstanceAutomatedBackup: AWSDecodableShape {
        public struct _DBInstanceAutomatedBackupsReplicationsEncoding: ArrayCoderProperties { public static let member = "DBInstanceAutomatedBackupsReplication" }

        /// The allocated storage size for the the automated backup in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// The Availability Zone that the automated backup was created in. For information on Amazon Web Services Regions and Availability Zones, see  Regions and Availability Zones.
        public let availabilityZone: String?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public let awsBackupRecoveryPointArn: String?
        /// The retention period for the automated backups.
        public let backupRetentionPeriod: Int?
        /// The location where automated backups are stored: Amazon Web Services Outposts or the Amazon Web Services Region.
        public let backupTarget: String?
        /// The Amazon Resource Name (ARN) for the automated backups.
        public let dbInstanceArn: String?
        /// The Amazon Resource Name (ARN) for the replicated automated backups.
        public let dbInstanceAutomatedBackupsArn: String?
        /// The list of replications to different Amazon Web Services Regions associated with the automated backup.
        @OptionalCustomCoding<ArrayCoder<_DBInstanceAutomatedBackupsReplicationsEncoding, DBInstanceAutomatedBackupsReplication>>
        public var dbInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbInstanceIdentifier: String?
        /// The resource ID for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbiResourceId: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        public let dedicatedLogVolume: Bool?
        /// Indicates whether the automated backup is encrypted.
        public let encrypted: Bool?
        /// The name of the database engine for this automated backup.
        public let engine: String?
        /// The version of the database engine for the automated backup.
        public let engineVersion: String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled,  and otherwise false.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The date and time when the DB instance was created.
        public let instanceCreateTime: Date?
        /// The IOPS (I/O operations per second) value for the automated backup.
        public let iops: Int?
        /// The Amazon Web Services KMS key ID for an automated backup. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// The license model information for the automated backup.
        public let licenseModel: String?
        /// The master user name of an automated backup.
        public let masterUsername: String?
        /// Specifies whether the automatic backup is for a DB instance in the multi-tenant configuration (TRUE) or the single-tenant configuration (FALSE).
        public let multiTenant: Bool?
        /// The option group the automated backup is associated with. If omitted, the default option group for the engine specified is used.
        public let optionGroupName: String?
        /// The port number that the automated backup used for connections. Default: Inherits from the source DB instance Valid Values: 1150-65535
        public let port: Int?
        /// The Amazon Web Services Region associated with the automated backup.
        public let region: String?
        /// The earliest and latest time a DB instance can be restored to.
        public let restoreWindow: RestoreWindow?
        /// A list of status information for an automated backup:    active - Automated backups for current instances.    retained - Automated backups for deleted instances.    creating - Automated backups that are waiting for the first automated snapshot to be available.
        public let status: String?
        /// The storage throughput for the automated backup.
        public let storageThroughput: Int?
        /// The storage type associated with the automated backup.
        public let storageType: String?
        /// The ARN from the key store with which the automated backup is associated for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the automated backup. In most cases, the Timezone element is empty. Timezone content appears only for Microsoft SQL Server DB instances  that were created with a time zone specified.
        public let timezone: String?
        /// The VPC ID associated with the DB instance.
        public let vpcId: String?

        public init(allocatedStorage: Int? = nil, availabilityZone: String? = nil, awsBackupRecoveryPointArn: String? = nil, backupRetentionPeriod: Int? = nil, backupTarget: String? = nil, dbInstanceArn: String? = nil, dbInstanceAutomatedBackupsArn: String? = nil, dbInstanceAutomatedBackupsReplications: [DBInstanceAutomatedBackupsReplication]? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dedicatedLogVolume: Bool? = nil, encrypted: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: Date? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, multiTenant: Bool? = nil, optionGroupName: String? = nil, port: Int? = nil, region: String? = nil, restoreWindow: RestoreWindow? = nil, status: String? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backupRetentionPeriod = backupRetentionPeriod
            self.backupTarget = backupTarget
            self.dbInstanceArn = dbInstanceArn
            self.dbInstanceAutomatedBackupsArn = dbInstanceAutomatedBackupsArn
            self.dbInstanceAutomatedBackupsReplications = dbInstanceAutomatedBackupsReplications
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dedicatedLogVolume = dedicatedLogVolume
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.multiTenant = multiTenant
            self.optionGroupName = optionGroupName
            self.port = port
            self.region = region
            self.restoreWindow = restoreWindow
            self.status = status
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZone = "AvailabilityZone"
            case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case backupTarget = "BackupTarget"
            case dbInstanceArn = "DBInstanceArn"
            case dbInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
            case dbInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case encrypted = "Encrypted"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case multiTenant = "MultiTenant"
            case optionGroupName = "OptionGroupName"
            case port = "Port"
            case region = "Region"
            case restoreWindow = "RestoreWindow"
            case status = "Status"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcId = "VpcId"
        }
    }

    public struct DBInstanceAutomatedBackupMessage: AWSDecodableShape {
        public struct _DBInstanceAutomatedBackupsEncoding: ArrayCoderProperties { public static let member = "DBInstanceAutomatedBackup" }

        /// A list of DBInstanceAutomatedBackup instances.
        @OptionalCustomCoding<ArrayCoder<_DBInstanceAutomatedBackupsEncoding, DBInstanceAutomatedBackup>>
        public var dbInstanceAutomatedBackups: [DBInstanceAutomatedBackup]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbInstanceAutomatedBackups: [DBInstanceAutomatedBackup]? = nil, marker: String? = nil) {
            self.dbInstanceAutomatedBackups = dbInstanceAutomatedBackups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackups = "DBInstanceAutomatedBackups"
            case marker = "Marker"
        }
    }

    public struct DBInstanceAutomatedBackupsReplication: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replicated automated backups.
        public let dbInstanceAutomatedBackupsArn: String?

        public init(dbInstanceAutomatedBackupsArn: String? = nil) {
            self.dbInstanceAutomatedBackupsArn = dbInstanceAutomatedBackupsArn
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
        }
    }

    public struct DBInstanceMessage: AWSDecodableShape {
        public struct _DBInstancesEncoding: ArrayCoderProperties { public static let member = "DBInstance" }

        /// A list of DBInstance instances.
        @OptionalCustomCoding<ArrayCoder<_DBInstancesEncoding, DBInstance>>
        public var dbInstances: [DBInstance]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
        public let marker: String?

        public init(dbInstances: [DBInstance]? = nil, marker: String? = nil) {
            self.dbInstances = dbInstances
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstances = "DBInstances"
            case marker = "Marker"
        }
    }

    public struct DBInstanceRole: AWSDecodableShape {
        /// The name of the feature associated with the Amazon Web Services Identity and Access Management (IAM) role. For information about supported feature names, see DBEngineVersion.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
        public let roleArn: String?
        /// Information about the state of association between the IAM role and the DB instance. The Status property returns one of the following values:    ACTIVE - the IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.    PENDING - the IAM role ARN is being associated with the DB instance.    INVALID - the IAM role ARN is associated with the DB instance, but the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        public let status: String?

        public init(featureName: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct DBInstanceStatusInfo: AWSDecodableShape {
        /// Details of the error if there is an error for the instance. If the instance isn't in an error state, this value is blank.
        public let message: String?
        /// Indicates whether the instance is operating normally (TRUE) or is in an error state (FALSE).
        public let normal: Bool?
        /// The status of the DB instance. For a StatusType of read replica, the values can be replicating, replication stop point set, replication stop point reached, error, stopped, or terminated.
        public let status: String?
        /// This value is currently "read replication."
        public let statusType: String?

        public init(message: String? = nil, normal: Bool? = nil, status: String? = nil, statusType: String? = nil) {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case normal = "Normal"
            case status = "Status"
            case statusType = "StatusType"
        }
    }

    public struct DBParameterGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the DB parameter group.
        public let dbParameterGroupArn: String?
        /// The name of the DB parameter group family that this DB parameter group is compatible with.
        public let dbParameterGroupFamily: String?
        /// The name of the DB parameter group.
        public let dbParameterGroupName: String?
        /// Provides the customer-specified description for this DB parameter group.
        public let description: String?

        public init(dbParameterGroupArn: String? = nil, dbParameterGroupFamily: String? = nil, dbParameterGroupName: String? = nil, description: String? = nil) {
            self.dbParameterGroupArn = dbParameterGroupArn
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.dbParameterGroupName = dbParameterGroupName
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupArn = "DBParameterGroupArn"
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case dbParameterGroupName = "DBParameterGroupName"
            case description = "Description"
        }
    }

    public struct DBParameterGroupDetails: AWSDecodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A list of Parameter values.
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?

        public init(marker: String? = nil, parameters: [Parameter]? = nil) {
            self.marker = marker
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case parameters = "Parameters"
        }
    }

    public struct DBParameterGroupNameMessage: AWSDecodableShape {
        /// The name of the DB parameter group.
        public let dbParameterGroupName: String?

        public init(dbParameterGroupName: String? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
        }
    }

    public struct DBParameterGroupStatus: AWSDecodableShape {
        /// The name of the DB parameter group.
        public let dbParameterGroupName: String?
        /// The status of parameter updates.
        public let parameterApplyStatus: String?

        public init(dbParameterGroupName: String? = nil, parameterApplyStatus: String? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
            case parameterApplyStatus = "ParameterApplyStatus"
        }
    }

    public struct DBParameterGroupsMessage: AWSDecodableShape {
        public struct _DBParameterGroupsEncoding: ArrayCoderProperties { public static let member = "DBParameterGroup" }

        /// A list of DBParameterGroup instances.
        @OptionalCustomCoding<ArrayCoder<_DBParameterGroupsEncoding, DBParameterGroup>>
        public var dbParameterGroups: [DBParameterGroup]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbParameterGroups: [DBParameterGroup]? = nil, marker: String? = nil) {
            self.dbParameterGroups = dbParameterGroups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroups = "DBParameterGroups"
            case marker = "Marker"
        }
    }

    public struct DBProxy: AWSDecodableShape {
        /// One or more data structures specifying the authorization mechanism to connect to the associated RDS DB instance or Aurora DB cluster.
        @OptionalCustomCoding<StandardArrayCoder<UserAuthConfigInfo>>
        public var auth: [UserAuthConfigInfo]?
        /// The date and time when the proxy was first created.
        public let createdDate: Date?
        /// The Amazon Resource Name (ARN) for the proxy.
        public let dbProxyArn: String?
        /// The identifier for the proxy. This name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
        public let dbProxyName: String?
        /// Indicates whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
        public let debugLogging: Bool?
        /// The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the connection string for a database client application.
        public let endpoint: String?
        /// The kinds of databases that the proxy can connect to. This value determines which database network protocol  the proxy recognizes when it interprets network traffic to and from the database. MYSQL supports Aurora MySQL,  RDS for MariaDB, and RDS for MySQL databases. POSTGRESQL supports Aurora PostgreSQL and RDS for PostgreSQL databases.  SQLSERVER supports RDS for Microsoft SQL Server databases.
        public let engineFamily: String?
        /// The number of seconds a connection to the proxy can have no activity before the proxy drops the client connection. The proxy keeps the underlying database connection open and puts it back into the connection pool for reuse by later connection requests. Default: 1800 (30 minutes) Constraints: 1 to 28,800
        public let idleClientTimeout: Int?
        /// Indicates whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
        public let requireTLS: Bool?
        /// The Amazon Resource Name (ARN) for the IAM role that the proxy uses to access Amazon Secrets Manager.
        public let roleArn: String?
        /// The current status of this proxy. A status of available means the proxy is ready to handle requests. Other values indicate that you must wait for the proxy to be ready, or take some action to resolve an issue.
        public let status: DBProxyStatus?
        /// The date and time when the proxy was last updated.
        public let updatedDate: Date?
        /// Provides the VPC ID of the DB proxy.
        public let vpcId: String?
        /// Provides a list of VPC security groups that the proxy belongs to.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSecurityGroupIds: [String]?
        /// The EC2 subnet IDs for the proxy.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSubnetIds: [String]?

        public init(auth: [UserAuthConfigInfo]? = nil, createdDate: Date? = nil, dbProxyArn: String? = nil, dbProxyName: String? = nil, debugLogging: Bool? = nil, endpoint: String? = nil, engineFamily: String? = nil, idleClientTimeout: Int? = nil, requireTLS: Bool? = nil, roleArn: String? = nil, status: DBProxyStatus? = nil, updatedDate: Date? = nil, vpcId: String? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]? = nil) {
            self.auth = auth
            self.createdDate = createdDate
            self.dbProxyArn = dbProxyArn
            self.dbProxyName = dbProxyName
            self.debugLogging = debugLogging
            self.endpoint = endpoint
            self.engineFamily = engineFamily
            self.idleClientTimeout = idleClientTimeout
            self.requireTLS = requireTLS
            self.roleArn = roleArn
            self.status = status
            self.updatedDate = updatedDate
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case auth = "Auth"
            case createdDate = "CreatedDate"
            case dbProxyArn = "DBProxyArn"
            case dbProxyName = "DBProxyName"
            case debugLogging = "DebugLogging"
            case endpoint = "Endpoint"
            case engineFamily = "EngineFamily"
            case idleClientTimeout = "IdleClientTimeout"
            case requireTLS = "RequireTLS"
            case roleArn = "RoleArn"
            case status = "Status"
            case updatedDate = "UpdatedDate"
            case vpcId = "VpcId"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
            case vpcSubnetIds = "VpcSubnetIds"
        }
    }

    public struct DBProxyEndpoint: AWSDecodableShape {
        /// The date and time when the DB proxy endpoint was first created.
        public let createdDate: Date?
        /// The Amazon Resource Name (ARN) for the DB proxy endpoint.
        public let dbProxyEndpointArn: String?
        /// The name for the DB proxy endpoint. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        public let dbProxyEndpointName: String?
        /// The identifier for the DB proxy that is associated with this DB proxy endpoint.
        public let dbProxyName: String?
        /// The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the connection string for a database client application.
        public let endpoint: String?
        /// Indicates whether this endpoint is the default endpoint for the associated DB proxy. Default DB proxy endpoints always have read/write capability. Other endpoints that you associate with the DB proxy can be either read/write or read-only.
        public let isDefault: Bool?
        /// The current status of this DB proxy endpoint. A status of available means the endpoint is ready to handle requests. Other values indicate that you must wait for the endpoint to be ready, or take some action to resolve an issue.
        public let status: DBProxyEndpointStatus?
        /// A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations.
        public let targetRole: DBProxyEndpointTargetRole?
        /// Provides the VPC ID of the DB proxy endpoint.
        public let vpcId: String?
        /// Provides a list of VPC security groups that the DB proxy endpoint belongs to.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSecurityGroupIds: [String]?
        /// The EC2 subnet IDs for the DB proxy endpoint.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSubnetIds: [String]?

        public init(createdDate: Date? = nil, dbProxyEndpointArn: String? = nil, dbProxyEndpointName: String? = nil, dbProxyName: String? = nil, endpoint: String? = nil, isDefault: Bool? = nil, status: DBProxyEndpointStatus? = nil, targetRole: DBProxyEndpointTargetRole? = nil, vpcId: String? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]? = nil) {
            self.createdDate = createdDate
            self.dbProxyEndpointArn = dbProxyEndpointArn
            self.dbProxyEndpointName = dbProxyEndpointName
            self.dbProxyName = dbProxyName
            self.endpoint = endpoint
            self.isDefault = isDefault
            self.status = status
            self.targetRole = targetRole
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case dbProxyEndpointArn = "DBProxyEndpointArn"
            case dbProxyEndpointName = "DBProxyEndpointName"
            case dbProxyName = "DBProxyName"
            case endpoint = "Endpoint"
            case isDefault = "IsDefault"
            case status = "Status"
            case targetRole = "TargetRole"
            case vpcId = "VpcId"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
            case vpcSubnetIds = "VpcSubnetIds"
        }
    }

    public struct DBProxyTarget: AWSDecodableShape {
        /// The writer endpoint for the RDS DB instance or Aurora DB cluster.
        public let endpoint: String?
        /// The port that the RDS Proxy uses to connect to the target RDS DB instance or Aurora DB cluster.
        public let port: Int?
        /// The identifier representing the target. It can be the instance identifier for an RDS DB instance, or the cluster identifier for an Aurora DB cluster.
        public let rdsResourceId: String?
        /// A value that indicates whether the target of the proxy can be used for read/write or read-only operations.
        public let role: TargetRole?
        /// The Amazon Resource Name (ARN) for the RDS DB instance or Aurora DB cluster.
        public let targetArn: String?
        /// Information about the connection health of the RDS Proxy target.
        public let targetHealth: TargetHealth?
        /// The DB cluster identifier when the target represents an Aurora DB cluster. This field is blank when the target represents an RDS DB instance.
        public let trackedClusterId: String?
        /// Specifies the kind of database, such as an RDS DB instance or an Aurora DB cluster, that the target represents.
        public let type: TargetType?

        public init(endpoint: String? = nil, port: Int? = nil, rdsResourceId: String? = nil, role: TargetRole? = nil, targetArn: String? = nil, targetHealth: TargetHealth? = nil, trackedClusterId: String? = nil, type: TargetType? = nil) {
            self.endpoint = endpoint
            self.port = port
            self.rdsResourceId = rdsResourceId
            self.role = role
            self.targetArn = targetArn
            self.targetHealth = targetHealth
            self.trackedClusterId = trackedClusterId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case port = "Port"
            case rdsResourceId = "RdsResourceId"
            case role = "Role"
            case targetArn = "TargetArn"
            case targetHealth = "TargetHealth"
            case trackedClusterId = "TrackedClusterId"
            case type = "Type"
        }
    }

    public struct DBProxyTargetGroup: AWSDecodableShape {
        /// The settings that determine the size and behavior of the connection pool for the target group.
        public let connectionPoolConfig: ConnectionPoolConfigurationInfo?
        /// The date and time when the target group was first created.
        public let createdDate: Date?
        /// The identifier for the RDS proxy associated with this target group.
        public let dbProxyName: String?
        /// Indicates whether this target group is the first one used for connection requests by the associated proxy. Because each proxy is currently associated with a single target group, currently this setting is always true.
        public let isDefault: Bool?
        /// The current status of this target group. A status of available means the target group is correctly associated with a database. Other values indicate that you must wait for the target group to be ready, or take some action to resolve an issue.
        public let status: String?
        /// The Amazon Resource Name (ARN) representing the target group.
        public let targetGroupArn: String?
        /// The identifier for the target group. This name must be unique for all target groups owned by your Amazon Web Services account in the specified Amazon Web Services Region.
        public let targetGroupName: String?
        /// The date and time when the target group was last updated.
        public let updatedDate: Date?

        public init(connectionPoolConfig: ConnectionPoolConfigurationInfo? = nil, createdDate: Date? = nil, dbProxyName: String? = nil, isDefault: Bool? = nil, status: String? = nil, targetGroupArn: String? = nil, targetGroupName: String? = nil, updatedDate: Date? = nil) {
            self.connectionPoolConfig = connectionPoolConfig
            self.createdDate = createdDate
            self.dbProxyName = dbProxyName
            self.isDefault = isDefault
            self.status = status
            self.targetGroupArn = targetGroupArn
            self.targetGroupName = targetGroupName
            self.updatedDate = updatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPoolConfig = "ConnectionPoolConfig"
            case createdDate = "CreatedDate"
            case dbProxyName = "DBProxyName"
            case isDefault = "IsDefault"
            case status = "Status"
            case targetGroupArn = "TargetGroupArn"
            case targetGroupName = "TargetGroupName"
            case updatedDate = "UpdatedDate"
        }
    }

    public struct DBRecommendation: AWSDecodableShape {
        /// Additional information about the recommendation. The information might contain markdown.
        public let additionalInfo: String?
        /// The category of the recommendation. Valid values:    performance efficiency     security     reliability     cost optimization     operational excellence     sustainability
        public let category: String?
        /// The time when the recommendation was created. For example, 2023-09-28T01:13:53.931000+00:00.
        public let createdTime: Date?
        /// A detailed description of the recommendation. The description might contain markdown.
        public let description: String?
        /// A short description of the issue identified for this recommendation. The description might contain markdown.
        public let detection: String?
        /// A short description that explains the possible impact of an issue.
        public let impact: String?
        /// Details of the issue that caused the recommendation.
        public let issueDetails: IssueDetails?
        /// A link to documentation that provides additional information about the recommendation.
        @OptionalCustomCoding<StandardArrayCoder<DocLink>>
        public var links: [DocLink]?
        /// The reason why this recommendation was created. The information might contain markdown.
        public let reason: String?
        /// A short description of the recommendation to resolve an issue. The description might contain markdown.
        public let recommendation: String?
        /// The unique identifier of the recommendation.
        public let recommendationId: String?
        /// A list of recommended actions.
        @OptionalCustomCoding<StandardArrayCoder<RecommendedAction>>
        public var recommendedActions: [RecommendedAction]?
        /// The Amazon Resource Name (ARN) of the RDS resource associated with the recommendation.
        public let resourceArn: String?
        /// The severity level of the recommendation. The severity level can help you decide the  urgency with which to address the recommendation. Valid values:    high     medium     low     informational
        public let severity: String?
        /// The Amazon Web Services service that generated the recommendations.
        public let source: String?
        /// The current status of the recommendation. Valid values:    active - The recommendations which are ready for you to apply.    pending - The applied or scheduled recommendations which are in progress.    resolved - The recommendations which are completed.    dismissed - The recommendations that you dismissed.
        public let status: String?
        /// A short description of the recommendation type. The description might contain markdown.
        public let typeDetection: String?
        /// A value that indicates the type of recommendation. This value determines how the description is rendered.
        public let typeId: String?
        /// A short description that summarizes the recommendation to fix all the issues of the recommendation type. The description might contain markdown.
        public let typeRecommendation: String?
        /// The time when the recommendation was last updated.
        public let updatedTime: Date?

        public init(additionalInfo: String? = nil, category: String? = nil, createdTime: Date? = nil, description: String? = nil, detection: String? = nil, impact: String? = nil, issueDetails: IssueDetails? = nil, links: [DocLink]? = nil, reason: String? = nil, recommendation: String? = nil, recommendationId: String? = nil, recommendedActions: [RecommendedAction]? = nil, resourceArn: String? = nil, severity: String? = nil, source: String? = nil, status: String? = nil, typeDetection: String? = nil, typeId: String? = nil, typeRecommendation: String? = nil, updatedTime: Date? = nil) {
            self.additionalInfo = additionalInfo
            self.category = category
            self.createdTime = createdTime
            self.description = description
            self.detection = detection
            self.impact = impact
            self.issueDetails = issueDetails
            self.links = links
            self.reason = reason
            self.recommendation = recommendation
            self.recommendationId = recommendationId
            self.recommendedActions = recommendedActions
            self.resourceArn = resourceArn
            self.severity = severity
            self.source = source
            self.status = status
            self.typeDetection = typeDetection
            self.typeId = typeId
            self.typeRecommendation = typeRecommendation
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInfo = "AdditionalInfo"
            case category = "Category"
            case createdTime = "CreatedTime"
            case description = "Description"
            case detection = "Detection"
            case impact = "Impact"
            case issueDetails = "IssueDetails"
            case links = "Links"
            case reason = "Reason"
            case recommendation = "Recommendation"
            case recommendationId = "RecommendationId"
            case recommendedActions = "RecommendedActions"
            case resourceArn = "ResourceArn"
            case severity = "Severity"
            case source = "Source"
            case status = "Status"
            case typeDetection = "TypeDetection"
            case typeId = "TypeId"
            case typeRecommendation = "TypeRecommendation"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct DBRecommendationMessage: AWSDecodableShape {
        public let dbRecommendation: DBRecommendation?

        public init(dbRecommendation: DBRecommendation? = nil) {
            self.dbRecommendation = dbRecommendation
        }

        private enum CodingKeys: String, CodingKey {
            case dbRecommendation = "DBRecommendation"
        }
    }

    public struct DBRecommendationsMessage: AWSDecodableShape {
        /// A list of recommendations which is returned from DescribeDBRecommendations API request.
        @OptionalCustomCoding<StandardArrayCoder<DBRecommendation>>
        public var dbRecommendations: [DBRecommendation]?
        /// An optional pagination token provided by a previous DBRecommendationsMessage request.  This token can be used  later in a DescribeDBRecomendations request.
        public let marker: String?

        public init(dbRecommendations: [DBRecommendation]? = nil, marker: String? = nil) {
            self.dbRecommendations = dbRecommendations
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbRecommendations = "DBRecommendations"
            case marker = "Marker"
        }
    }

    public struct DBSecurityGroup: AWSDecodableShape {
        public struct _EC2SecurityGroupsEncoding: ArrayCoderProperties { public static let member = "EC2SecurityGroup" }
        public struct _IPRangesEncoding: ArrayCoderProperties { public static let member = "IPRange" }

        /// The Amazon Resource Name (ARN) for the DB security group.
        public let dbSecurityGroupArn: String?
        /// Provides the description of the DB security group.
        public let dbSecurityGroupDescription: String?
        /// Specifies the name of the DB security group.
        public let dbSecurityGroupName: String?
        /// Contains a list of EC2SecurityGroup elements.
        @OptionalCustomCoding<ArrayCoder<_EC2SecurityGroupsEncoding, EC2SecurityGroup>>
        public var ec2SecurityGroups: [EC2SecurityGroup]?
        /// Contains a list of IPRange elements.
        @OptionalCustomCoding<ArrayCoder<_IPRangesEncoding, IPRange>>
        public var ipRanges: [IPRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public let ownerId: String?
        /// Provides the VpcId of the DB security group.
        public let vpcId: String?

        public init(dbSecurityGroupArn: String? = nil, dbSecurityGroupDescription: String? = nil, dbSecurityGroupName: String? = nil, ec2SecurityGroups: [EC2SecurityGroup]? = nil, ipRanges: [IPRange]? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.dbSecurityGroupArn = dbSecurityGroupArn
            self.dbSecurityGroupDescription = dbSecurityGroupDescription
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroups = ec2SecurityGroups
            self.ipRanges = ipRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupArn = "DBSecurityGroupArn"
            case dbSecurityGroupDescription = "DBSecurityGroupDescription"
            case dbSecurityGroupName = "DBSecurityGroupName"
            case ec2SecurityGroups = "EC2SecurityGroups"
            case ipRanges = "IPRanges"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct DBSecurityGroupMembership: AWSDecodableShape {
        /// The name of the DB security group.
        public let dbSecurityGroupName: String?
        /// The status of the DB security group.
        public let status: String?

        public init(dbSecurityGroupName: String? = nil, status: String? = nil) {
            self.dbSecurityGroupName = dbSecurityGroupName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupName = "DBSecurityGroupName"
            case status = "Status"
        }
    }

    public struct DBSecurityGroupMessage: AWSDecodableShape {
        public struct _DBSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroup" }

        /// A list of DBSecurityGroup instances.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupsEncoding, DBSecurityGroup>>
        public var dbSecurityGroups: [DBSecurityGroup]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbSecurityGroups: [DBSecurityGroup]? = nil, marker: String? = nil) {
            self.dbSecurityGroups = dbSecurityGroups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroups = "DBSecurityGroups"
            case marker = "Marker"
        }
    }

    public struct DBShardGroup: AWSDecodableShape {
        /// Specifies whether to create standby instances for the DB shard group. Valid values are the following:   0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.   1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.   2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.
        public let computeRedundancy: Int?
        /// The name of the primary DB cluster for the DB shard group.
        public let dbClusterIdentifier: String?
        /// The name of the DB shard group.
        public let dbShardGroupIdentifier: String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB shard group.
        public let dbShardGroupResourceId: String?
        /// The connection endpoint for the DB shard group.
        public let endpoint: String?
        /// The maximum capacity of the DB shard group in Aurora capacity units (ACUs).
        public let maxACU: Double?
        /// Indicates whether the DB shard group is publicly accessible. When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it. When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address. For more information, see CreateDBShardGroup. This setting is only for Aurora Limitless Database.
        public let publiclyAccessible: Bool?
        /// The status of the DB shard group.
        public let status: String?

        public init(computeRedundancy: Int? = nil, dbClusterIdentifier: String? = nil, dbShardGroupIdentifier: String? = nil, dbShardGroupResourceId: String? = nil, endpoint: String? = nil, maxACU: Double? = nil, publiclyAccessible: Bool? = nil, status: String? = nil) {
            self.computeRedundancy = computeRedundancy
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
            self.dbShardGroupResourceId = dbShardGroupResourceId
            self.endpoint = endpoint
            self.maxACU = maxACU
            self.publiclyAccessible = publiclyAccessible
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case computeRedundancy = "ComputeRedundancy"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbShardGroupIdentifier = "DBShardGroupIdentifier"
            case dbShardGroupResourceId = "DBShardGroupResourceId"
            case endpoint = "Endpoint"
            case maxACU = "MaxACU"
            case publiclyAccessible = "PubliclyAccessible"
            case status = "Status"
        }
    }

    public struct DBSnapshot: AWSDecodableShape {
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// Specifies the allocated storage size in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// Specifies the name of the Availability Zone the DB instance was located in at the time of the DB snapshot.
        public let availabilityZone: String?
        /// Specifies the DB instance identifier of the DB instance this DB snapshot was created from.
        public let dbInstanceIdentifier: String?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbiResourceId: String?
        /// The Amazon Resource Name (ARN) for the DB snapshot.
        public let dbSnapshotArn: String?
        /// Specifies the identifier for the DB snapshot.
        public let dbSnapshotIdentifier: String?
        /// The Oracle system identifier (SID), which is the name of the Oracle database instance that  manages your database files. The Oracle SID is also the name of your CDB.
        public let dbSystemId: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        public let dedicatedLogVolume: Bool?
        /// Indicates whether the DB snapshot is encrypted.
        public let encrypted: Bool?
        /// Specifies the name of the database engine.
        public let engine: String?
        /// Specifies the version of the database engine.
        public let engineVersion: String?
        /// Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.
        public let instanceCreateTime: Date?
        /// Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public let iops: Int?
        /// If Encrypted is true, the Amazon Web Services KMS key identifier  for the encrypted DB snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// License model information for the restored DB instance.
        public let licenseModel: String?
        /// Provides the master username for the DB snapshot.
        public let masterUsername: String?
        /// Indicates whether the snapshot is of a DB instance using the multi-tenant configuration (TRUE) or the single-tenant configuration (FALSE).
        public let multiTenant: Bool?
        /// Provides the option group name for the DB snapshot.
        public let optionGroupName: String?
        /// Specifies the time of the CreateDBSnapshot operation in Coordinated Universal Time (UTC). Doesn't change when the snapshot is copied.
        public let originalSnapshotCreateTime: Date?
        /// The percentage of the estimated data that has been transferred.
        public let percentProgress: Int?
        /// Specifies the port that the database engine was listening on at the time of the snapshot.
        public let port: Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance when the DB snapshot was created.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// Specifies when the snapshot was taken in Coordinated Universal Time (UTC). Changes for the copy when the snapshot is copied.
        public let snapshotCreateTime: Date?
        /// The timestamp of the most recent transaction applied to the database that you're backing up.  Thus, if you restore a snapshot, SnapshotDatabaseTime is the most recent transaction in the restored DB instance.  In contrast, originalSnapshotCreateTime specifies the system time that the snapshot completed. If you back up a read replica, you can determine the replica lag by comparing SnapshotDatabaseTime  with originalSnapshotCreateTime. For example, if originalSnapshotCreateTime is two hours later than  SnapshotDatabaseTime, then the replica lag is two hours.
        public let snapshotDatabaseTime: Date?
        /// Specifies where manual snapshots are stored: Amazon Web Services Outposts or the Amazon Web Services Region.
        public let snapshotTarget: String?
        /// Provides the type of the DB snapshot.
        public let snapshotType: String?
        /// The DB snapshot Amazon Resource Name (ARN) that the DB snapshot was copied from. It only has a value in the case of a cross-account or cross-Region copy.
        public let sourceDBSnapshotIdentifier: String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public let sourceRegion: String?
        /// Specifies the status of this DB snapshot.
        public let status: String?
        /// Specifies the storage throughput for the DB snapshot.
        public let storageThroughput: Int?
        /// Specifies the storage type associated with DB snapshot.
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the DB snapshot. In most cases, the Timezone element is empty. Timezone content appears only for snapshots taken from  Microsoft SQL Server DB instances  that were created with a time zone specified.
        public let timezone: String?
        /// Provides the VPC ID associated with the DB snapshot.
        public let vpcId: String?

        public init(allocatedStorage: Int? = nil, availabilityZone: String? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dbSnapshotArn: String? = nil, dbSnapshotIdentifier: String? = nil, dbSystemId: String? = nil, dedicatedLogVolume: Bool? = nil, encrypted: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: Date? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, multiTenant: Bool? = nil, optionGroupName: String? = nil, originalSnapshotCreateTime: Date? = nil, percentProgress: Int? = nil, port: Int? = nil, processorFeatures: [ProcessorFeature]? = nil, snapshotCreateTime: Date? = nil, snapshotDatabaseTime: Date? = nil, snapshotTarget: String? = nil, snapshotType: String? = nil, sourceDBSnapshotIdentifier: String? = nil, sourceRegion: String? = nil, status: String? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tagList: [Tag]? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dbSnapshotArn = dbSnapshotArn
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.dbSystemId = dbSystemId
            self.dedicatedLogVolume = dedicatedLogVolume
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.multiTenant = multiTenant
            self.optionGroupName = optionGroupName
            self.originalSnapshotCreateTime = originalSnapshotCreateTime
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotDatabaseTime = snapshotDatabaseTime
            self.snapshotTarget = snapshotTarget
            self.snapshotType = snapshotType
            self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tagList = tagList
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZone = "AvailabilityZone"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dbSnapshotArn = "DBSnapshotArn"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case dbSystemId = "DBSystemId"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case encrypted = "Encrypted"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case multiTenant = "MultiTenant"
            case optionGroupName = "OptionGroupName"
            case originalSnapshotCreateTime = "OriginalSnapshotCreateTime"
            case percentProgress = "PercentProgress"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case snapshotCreateTime = "SnapshotCreateTime"
            case snapshotDatabaseTime = "SnapshotDatabaseTime"
            case snapshotTarget = "SnapshotTarget"
            case snapshotType = "SnapshotType"
            case sourceDBSnapshotIdentifier = "SourceDBSnapshotIdentifier"
            case sourceRegion = "SourceRegion"
            case status = "Status"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tagList = "TagList"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcId = "VpcId"
        }
    }

    public struct DBSnapshotAttribute: AWSDecodableShape {
        public struct _AttributeValuesEncoding: ArrayCoderProperties { public static let member = "AttributeValue" }

        /// The name of the manual DB snapshot attribute. The attribute named restore refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot. For more information,  see the ModifyDBSnapshotAttribute API action.
        public let attributeName: String?
        /// The value or values for the manual DB snapshot attribute. If the AttributeName field is set to restore, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB snapshot. If a value of all is in the list, then the manual DB snapshot is public and available for any Amazon Web Services account to copy or restore.
        @OptionalCustomCoding<ArrayCoder<_AttributeValuesEncoding, String>>
        public var attributeValues: [String]?

        public init(attributeName: String? = nil, attributeValues: [String]? = nil) {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeValues = "AttributeValues"
        }
    }

    public struct DBSnapshotAttributesResult: AWSDecodableShape {
        public struct _DBSnapshotAttributesEncoding: ArrayCoderProperties { public static let member = "DBSnapshotAttribute" }

        /// The list of attributes and values for the manual DB snapshot.
        @OptionalCustomCoding<ArrayCoder<_DBSnapshotAttributesEncoding, DBSnapshotAttribute>>
        public var dbSnapshotAttributes: [DBSnapshotAttribute]?
        /// The identifier of the manual DB snapshot that the attributes apply to.
        public let dbSnapshotIdentifier: String?

        public init(dbSnapshotAttributes: [DBSnapshotAttribute]? = nil, dbSnapshotIdentifier: String? = nil) {
            self.dbSnapshotAttributes = dbSnapshotAttributes
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotAttributes = "DBSnapshotAttributes"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
        }
    }

    public struct DBSnapshotMessage: AWSDecodableShape {
        public struct _DBSnapshotsEncoding: ArrayCoderProperties { public static let member = "DBSnapshot" }

        /// A list of DBSnapshot instances.
        @OptionalCustomCoding<ArrayCoder<_DBSnapshotsEncoding, DBSnapshot>>
        public var dbSnapshots: [DBSnapshot]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbSnapshots: [DBSnapshot]? = nil, marker: String? = nil) {
            self.dbSnapshots = dbSnapshots
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshots = "DBSnapshots"
            case marker = "Marker"
        }
    }

    public struct DBSnapshotTenantDatabase: AWSDecodableShape {
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The name of the character set of a tenant database.
        public let characterSetName: String?
        /// The ID for the DB instance that contains the tenant databases.
        public let dbInstanceIdentifier: String?
        /// The resource identifier of the source CDB instance. This identifier can't be changed and is unique to an Amazon Web Services Region.
        public let dbiResourceId: String?
        /// The identifier for the snapshot of the DB instance.
        public let dbSnapshotIdentifier: String?
        /// The Amazon Resource Name (ARN) for the snapshot tenant database.
        public let dbSnapshotTenantDatabaseARN: String?
        /// The name of the database engine.
        public let engineName: String?
        /// The master username of the tenant database.
        public let masterUsername: String?
        /// The NCHAR character set name of the tenant database.
        public let ncharCharacterSetName: String?
        /// The type of DB snapshot.
        public let snapshotType: String?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The time the DB snapshot was taken, specified in Coordinated Universal Time (UTC). If you copy the snapshot, the creation time changes.
        public let tenantDatabaseCreateTime: Date?
        /// The resource ID of the tenant database.
        public let tenantDatabaseResourceId: String?
        /// The name of the tenant database.
        public let tenantDBName: String?

        public init(characterSetName: String? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dbSnapshotIdentifier: String? = nil, dbSnapshotTenantDatabaseARN: String? = nil, engineName: String? = nil, masterUsername: String? = nil, ncharCharacterSetName: String? = nil, snapshotType: String? = nil, tagList: [Tag]? = nil, tenantDatabaseCreateTime: Date? = nil, tenantDatabaseResourceId: String? = nil, tenantDBName: String? = nil) {
            self.characterSetName = characterSetName
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.dbSnapshotTenantDatabaseARN = dbSnapshotTenantDatabaseARN
            self.engineName = engineName
            self.masterUsername = masterUsername
            self.ncharCharacterSetName = ncharCharacterSetName
            self.snapshotType = snapshotType
            self.tagList = tagList
            self.tenantDatabaseCreateTime = tenantDatabaseCreateTime
            self.tenantDatabaseResourceId = tenantDatabaseResourceId
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case characterSetName = "CharacterSetName"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case dbSnapshotTenantDatabaseARN = "DBSnapshotTenantDatabaseARN"
            case engineName = "EngineName"
            case masterUsername = "MasterUsername"
            case ncharCharacterSetName = "NcharCharacterSetName"
            case snapshotType = "SnapshotType"
            case tagList = "TagList"
            case tenantDatabaseCreateTime = "TenantDatabaseCreateTime"
            case tenantDatabaseResourceId = "TenantDatabaseResourceId"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct DBSnapshotTenantDatabasesMessage: AWSDecodableShape {
        public struct _DBSnapshotTenantDatabasesEncoding: ArrayCoderProperties { public static let member = "DBSnapshotTenantDatabase" }

        /// A list of DB snapshot tenant databases.
        @OptionalCustomCoding<ArrayCoder<_DBSnapshotTenantDatabasesEncoding, DBSnapshotTenantDatabase>>
        public var dbSnapshotTenantDatabases: [DBSnapshotTenantDatabase]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbSnapshotTenantDatabases: [DBSnapshotTenantDatabase]? = nil, marker: String? = nil) {
            self.dbSnapshotTenantDatabases = dbSnapshotTenantDatabases
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotTenantDatabases = "DBSnapshotTenantDatabases"
            case marker = "Marker"
        }
    }

    public struct DBSubnetGroup: AWSDecodableShape {
        public struct _SubnetsEncoding: ArrayCoderProperties { public static let member = "Subnet" }

        /// The Amazon Resource Name (ARN) for the DB subnet group.
        public let dbSubnetGroupArn: String?
        /// Provides the description of the DB subnet group.
        public let dbSubnetGroupDescription: String?
        /// The name of the DB subnet group.
        public let dbSubnetGroupName: String?
        /// Provides the status of the DB subnet group.
        public let subnetGroupStatus: String?
        /// Contains a list of Subnet elements.
        @OptionalCustomCoding<ArrayCoder<_SubnetsEncoding, Subnet>>
        public var subnets: [Subnet]?
        /// The network type of the DB subnet group. Valid values:    IPV4     DUAL    A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedNetworkTypes: [String]?
        /// Provides the VpcId of the DB subnet group.
        public let vpcId: String?

        public init(dbSubnetGroupArn: String? = nil, dbSubnetGroupDescription: String? = nil, dbSubnetGroupName: String? = nil, subnetGroupStatus: String? = nil, subnets: [Subnet]? = nil, supportedNetworkTypes: [String]? = nil, vpcId: String? = nil) {
            self.dbSubnetGroupArn = dbSubnetGroupArn
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.supportedNetworkTypes = supportedNetworkTypes
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupArn = "DBSubnetGroupArn"
            case dbSubnetGroupDescription = "DBSubnetGroupDescription"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case supportedNetworkTypes = "SupportedNetworkTypes"
            case vpcId = "VpcId"
        }
    }

    public struct DBSubnetGroupMessage: AWSDecodableShape {
        public struct _DBSubnetGroupsEncoding: ArrayCoderProperties { public static let member = "DBSubnetGroup" }

        /// A list of DBSubnetGroup instances.
        @OptionalCustomCoding<ArrayCoder<_DBSubnetGroupsEncoding, DBSubnetGroup>>
        public var dbSubnetGroups: [DBSubnetGroup]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbSubnetGroups: [DBSubnetGroup]? = nil, marker: String? = nil) {
            self.dbSubnetGroups = dbSubnetGroups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroups = "DBSubnetGroups"
            case marker = "Marker"
        }
    }

    public struct DeleteBlueGreenDeploymentRequest: AWSEncodableShape {
        /// The unique identifier of the blue/green deployment to delete. This parameter isn't case-sensitive. Constraints:    Must match an existing blue/green deployment identifier.
        public let blueGreenDeploymentIdentifier: String?
        /// Specifies whether to delete the resources in the green environment. You can't specify this option if the blue/green deployment status is SWITCHOVER_COMPLETED.
        public let deleteTarget: Bool?

        public init(blueGreenDeploymentIdentifier: String? = nil, deleteTarget: Bool? = nil) {
            self.blueGreenDeploymentIdentifier = blueGreenDeploymentIdentifier
            self.deleteTarget = deleteTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, max: 255)
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, min: 1)
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeploymentIdentifier = "BlueGreenDeploymentIdentifier"
            case deleteTarget = "DeleteTarget"
        }
    }

    public struct DeleteBlueGreenDeploymentResponse: AWSDecodableShape {
        public let blueGreenDeployment: BlueGreenDeployment?

        public init(blueGreenDeployment: BlueGreenDeployment? = nil) {
            self.blueGreenDeployment = blueGreenDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeployment = "BlueGreenDeployment"
        }
    }

    public struct DeleteCustomDBEngineVersionMessage: AWSEncodableShape {
        /// The database engine. The only supported engines are custom-oracle-ee and custom-oracle-ee-cdb.
        public let engine: String?
        /// The custom engine version (CEV) for your DB instance. This option is required for  RDS Custom, but optional for Amazon RDS. The combination of Engine and  EngineVersion is unique per customer per Amazon Web Services Region.
        public let engineVersion: String?

        public init(engine: String? = nil, engineVersion: String? = nil) {
            self.engine = engine
            self.engineVersion = engineVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.engine, name: "engine", parent: name, max: 35)
            try self.validate(self.engine, name: "engine", parent: name, min: 1)
            try self.validate(self.engine, name: "engine", parent: name, pattern: "^[A-Za-z0-9-]{1,35}$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 60)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 1)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^[a-z0-9_.-]{1,60}$")
        }

        private enum CodingKeys: String, CodingKey {
            case engine = "Engine"
            case engineVersion = "EngineVersion"
        }
    }

    public struct DeleteDBClusterAutomatedBackupMessage: AWSEncodableShape {
        /// The identifier for the source DB cluster, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbClusterResourceId: String?

        public init(dbClusterResourceId: String? = nil) {
            self.dbClusterResourceId = dbClusterResourceId
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterResourceId = "DbClusterResourceId"
        }
    }

    public struct DeleteDBClusterAutomatedBackupResult: AWSDecodableShape {
        public let dbClusterAutomatedBackup: DBClusterAutomatedBackup?

        public init(dbClusterAutomatedBackup: DBClusterAutomatedBackup? = nil) {
            self.dbClusterAutomatedBackup = dbClusterAutomatedBackup
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterAutomatedBackup = "DBClusterAutomatedBackup"
        }
    }

    public struct DeleteDBClusterEndpointMessage: AWSEncodableShape {
        /// The identifier associated with the custom endpoint. This parameter is stored as a lowercase string.
        public let dbClusterEndpointIdentifier: String?

        public init(dbClusterEndpointIdentifier: String? = nil) {
            self.dbClusterEndpointIdentifier = dbClusterEndpointIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        }
    }

    public struct DeleteDBClusterMessage: AWSEncodableShape {
        /// The DB cluster identifier for the DB cluster to be deleted. This parameter isn't case-sensitive. Constraints:   Must match an existing DBClusterIdentifier.
        public let dbClusterIdentifier: String?
        /// Specifies whether to remove automated backups immediately after the DB cluster is deleted. This parameter isn't case-sensitive. The default is to remove  automated backups immediately after the DB cluster is deleted.
        public let deleteAutomatedBackups: Bool?
        /// The DB cluster snapshot identifier of the new DB cluster snapshot created when SkipFinalSnapshot is disabled.  Specifying this parameter and also skipping the creation of a final DB cluster snapshot  with the SkipFinalShapshot parameter results in an error.  Constraints:   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens
        public let finalDBSnapshotIdentifier: String?
        /// Specifies whether to skip the creation of a final DB cluster snapshot before the DB cluster is deleted. If skip is specified, no DB cluster snapshot is created. If skip isn't specified, a DB cluster snapshot  is created before the DB cluster is deleted. By default, skip isn't specified, and the DB cluster snapshot is created.  By default, this parameter is disabled.  You must specify a FinalDBSnapshotIdentifier parameter if SkipFinalSnapshot is disabled.
        public let skipFinalSnapshot: Bool?

        public init(dbClusterIdentifier: String? = nil, deleteAutomatedBackups: Bool? = nil, finalDBSnapshotIdentifier: String? = nil, skipFinalSnapshot: Bool? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.deleteAutomatedBackups = deleteAutomatedBackups
            self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
            self.skipFinalSnapshot = skipFinalSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case deleteAutomatedBackups = "DeleteAutomatedBackups"
            case finalDBSnapshotIdentifier = "FinalDBSnapshotIdentifier"
            case skipFinalSnapshot = "SkipFinalSnapshot"
        }
    }

    public struct DeleteDBClusterParameterGroupMessage: AWSEncodableShape {
        /// The name of the DB cluster parameter group. Constraints:   Must be the name of an existing DB cluster parameter group.   You can't delete a default DB cluster parameter group.   Can't be associated with any DB clusters.
        public let dbClusterParameterGroupName: String?

        public init(dbClusterParameterGroupName: String? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
        }
    }

    public struct DeleteDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct DeleteDBClusterSnapshotMessage: AWSEncodableShape {
        /// The identifier of the DB cluster snapshot to delete. Constraints: Must be the name of an existing DB cluster snapshot in the available state.
        public let dbClusterSnapshotIdentifier: String?

        public init(dbClusterSnapshotIdentifier: String? = nil) {
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        }
    }

    public struct DeleteDBClusterSnapshotResult: AWSDecodableShape {
        public let dbClusterSnapshot: DBClusterSnapshot?

        public init(dbClusterSnapshot: DBClusterSnapshot? = nil) {
            self.dbClusterSnapshot = dbClusterSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshot = "DBClusterSnapshot"
        }
    }

    public struct DeleteDBInstanceAutomatedBackupMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the automated backups to delete, for example, arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE. This setting doesn't apply to RDS Custom.
        public let dbInstanceAutomatedBackupsArn: String?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public let dbiResourceId: String?

        public init(dbInstanceAutomatedBackupsArn: String? = nil, dbiResourceId: String? = nil) {
            self.dbInstanceAutomatedBackupsArn = dbInstanceAutomatedBackupsArn
            self.dbiResourceId = dbiResourceId
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
            case dbiResourceId = "DbiResourceId"
        }
    }

    public struct DeleteDBInstanceAutomatedBackupResult: AWSDecodableShape {
        public let dbInstanceAutomatedBackup: DBInstanceAutomatedBackup?

        public init(dbInstanceAutomatedBackup: DBInstanceAutomatedBackup? = nil) {
            self.dbInstanceAutomatedBackup = dbInstanceAutomatedBackup
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
        }
    }

    public struct DeleteDBInstanceMessage: AWSEncodableShape {
        /// The DB instance identifier for the DB instance to be deleted. This parameter isn't case-sensitive. Constraints:   Must match the name of an existing DB instance.
        public let dbInstanceIdentifier: String?
        /// Specifies whether to remove automated backups immediately after the DB instance is deleted. This parameter isn't case-sensitive. The default is to remove  automated backups immediately after the DB instance is deleted.
        public let deleteAutomatedBackups: Bool?
        /// The DBSnapshotIdentifier of the new DBSnapshot created when the SkipFinalSnapshot parameter is disabled.  If you enable this parameter and also enable SkipFinalShapshot, the command results in an error.  This setting doesn't apply to RDS Custom. Constraints:   Must be 1 to 255 letters or numbers.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Can't be specified when deleting a read replica.
        public let finalDBSnapshotIdentifier: String?
        /// Specifies whether to skip the creation of a final DB snapshot before deleting the instance. If you enable this parameter, RDS doesn't create a DB snapshot. If you don't enable this parameter,  RDS creates a DB snapshot before the DB instance is deleted. By default, skip isn't enabled,  and the DB snapshot is created.  If you don't enable this parameter, you must specify the FinalDBSnapshotIdentifier parameter.  When a DB instance is in a failure state and has a status of failed, incompatible-restore,  or incompatible-network, RDS can delete the instance only if you enable this parameter. If you delete a read replica or an RDS Custom instance, you must enable this setting. This setting is required for RDS Custom.
        public let skipFinalSnapshot: Bool?

        public init(dbInstanceIdentifier: String? = nil, deleteAutomatedBackups: Bool? = nil, finalDBSnapshotIdentifier: String? = nil, skipFinalSnapshot: Bool? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.deleteAutomatedBackups = deleteAutomatedBackups
            self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
            self.skipFinalSnapshot = skipFinalSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case deleteAutomatedBackups = "DeleteAutomatedBackups"
            case finalDBSnapshotIdentifier = "FinalDBSnapshotIdentifier"
            case skipFinalSnapshot = "SkipFinalSnapshot"
        }
    }

    public struct DeleteDBInstanceResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct DeleteDBParameterGroupMessage: AWSEncodableShape {
        /// The name of the DB parameter group. Constraints:   Must be the name of an existing DB parameter group   You can't delete a default DB parameter group   Can't be associated with any DB instances
        public let dbParameterGroupName: String?

        public init(dbParameterGroupName: String? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
        }
    }

    public struct DeleteDBProxyEndpointRequest: AWSEncodableShape {
        /// The name of the DB proxy endpoint to delete.
        public let dbProxyEndpointName: String?

        public init(dbProxyEndpointName: String? = nil) {
            self.dbProxyEndpointName = dbProxyEndpointName
        }

        public func validate(name: String) throws {
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, max: 63)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, min: 1)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpointName = "DBProxyEndpointName"
        }
    }

    public struct DeleteDBProxyEndpointResponse: AWSDecodableShape {
        /// The data structure representing the details of the DB proxy endpoint that you delete.
        public let dbProxyEndpoint: DBProxyEndpoint?

        public init(dbProxyEndpoint: DBProxyEndpoint? = nil) {
            self.dbProxyEndpoint = dbProxyEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpoint = "DBProxyEndpoint"
        }
    }

    public struct DeleteDBProxyRequest: AWSEncodableShape {
        /// The name of the DB proxy to delete.
        public let dbProxyName: String?

        public init(dbProxyName: String? = nil) {
            self.dbProxyName = dbProxyName
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyName = "DBProxyName"
        }
    }

    public struct DeleteDBProxyResponse: AWSDecodableShape {
        /// The data structure representing the details of the DB proxy that you delete.
        public let dbProxy: DBProxy?

        public init(dbProxy: DBProxy? = nil) {
            self.dbProxy = dbProxy
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxy = "DBProxy"
        }
    }

    public struct DeleteDBSecurityGroupMessage: AWSEncodableShape {
        /// The name of the DB security group to delete.  You can't delete the default DB security group.  Constraints:   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Must not be "Default"
        public let dbSecurityGroupName: String?

        public init(dbSecurityGroupName: String? = nil) {
            self.dbSecurityGroupName = dbSecurityGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupName = "DBSecurityGroupName"
        }
    }

    public struct DeleteDBShardGroupMessage: AWSEncodableShape {
        /// Teh name of the DB shard group to delete.
        public let dbShardGroupIdentifier: String?

        public init(dbShardGroupIdentifier: String? = nil) {
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, max: 63)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, min: 1)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbShardGroupIdentifier = "DBShardGroupIdentifier"
        }
    }

    public struct DeleteDBSnapshotMessage: AWSEncodableShape {
        /// The DB snapshot identifier. Constraints: Must be the name of an existing DB snapshot in the available state.
        public let dbSnapshotIdentifier: String?

        public init(dbSnapshotIdentifier: String? = nil) {
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
        }
    }

    public struct DeleteDBSnapshotResult: AWSDecodableShape {
        public let dbSnapshot: DBSnapshot?

        public init(dbSnapshot: DBSnapshot? = nil) {
            self.dbSnapshot = dbSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshot = "DBSnapshot"
        }
    }

    public struct DeleteDBSubnetGroupMessage: AWSEncodableShape {
        /// The name of the database subnet group to delete.  You can't delete the default subnet group.  Constraints: Must match the name of an existing DBSubnetGroup. Must not be default. Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?

        public init(dbSubnetGroupName: String? = nil) {
            self.dbSubnetGroupName = dbSubnetGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupName = "DBSubnetGroupName"
        }
    }

    public struct DeleteEventSubscriptionMessage: AWSEncodableShape {
        /// The name of the RDS event notification subscription you want to delete.
        public let subscriptionName: String?

        public init(subscriptionName: String? = nil) {
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DeleteEventSubscriptionResult: AWSDecodableShape {
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct DeleteGlobalClusterMessage: AWSEncodableShape {
        /// The cluster identifier of the global database cluster being deleted.
        public let globalClusterIdentifier: String?

        public init(globalClusterIdentifier: String? = nil) {
            self.globalClusterIdentifier = globalClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case globalClusterIdentifier = "GlobalClusterIdentifier"
        }
    }

    public struct DeleteGlobalClusterResult: AWSDecodableShape {
        public let globalCluster: GlobalCluster?

        public init(globalCluster: GlobalCluster? = nil) {
            self.globalCluster = globalCluster
        }

        private enum CodingKeys: String, CodingKey {
            case globalCluster = "GlobalCluster"
        }
    }

    public struct DeleteIntegrationMessage: AWSEncodableShape {
        /// The unique identifier of the integration.
        public let integrationIdentifier: String?

        public init(integrationIdentifier: String? = nil) {
            self.integrationIdentifier = integrationIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, max: 255)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, min: 1)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, pattern: "^[a-zA-Z0-9_:\\-\\/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case integrationIdentifier = "IntegrationIdentifier"
        }
    }

    public struct DeleteOptionGroupMessage: AWSEncodableShape {
        /// The name of the option group to be deleted.  You can't delete default option groups.
        public let optionGroupName: String?

        public init(optionGroupName: String? = nil) {
            self.optionGroupName = optionGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroupName = "OptionGroupName"
        }
    }

    public struct DeleteTenantDatabaseMessage: AWSEncodableShape {
        /// The user-supplied identifier for the DB instance that contains the tenant database that you want to delete.
        public let dbInstanceIdentifier: String?
        /// The DBSnapshotIdentifier of the new DBSnapshot created when the SkipFinalSnapshot parameter is disabled.  If you enable this parameter and also enable SkipFinalShapshot, the command results in an error.
        public let finalDBSnapshotIdentifier: String?
        /// Specifies whether to skip the creation of a final DB snapshot before removing the tenant database from your DB instance. If you enable this parameter, RDS doesn't create a DB snapshot. If you don't enable this parameter, RDS creates a DB snapshot before it deletes the tenant database. By default, RDS doesn't skip the final snapshot. If you don't enable this parameter, you must specify the FinalDBSnapshotIdentifier parameter.
        public let skipFinalSnapshot: Bool?
        /// The user-supplied name of the tenant database that you want to remove from your DB instance. Amazon RDS deletes the tenant database with this name. This parameter isn’t case-sensitive.
        public let tenantDBName: String?

        public init(dbInstanceIdentifier: String? = nil, finalDBSnapshotIdentifier: String? = nil, skipFinalSnapshot: Bool? = nil, tenantDBName: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
            self.skipFinalSnapshot = skipFinalSnapshot
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case finalDBSnapshotIdentifier = "FinalDBSnapshotIdentifier"
            case skipFinalSnapshot = "SkipFinalSnapshot"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct DeleteTenantDatabaseResult: AWSDecodableShape {
        public let tenantDatabase: TenantDatabase?

        public init(tenantDatabase: TenantDatabase? = nil) {
            self.tenantDatabase = tenantDatabase
        }

        private enum CodingKeys: String, CodingKey {
            case tenantDatabase = "TenantDatabase"
        }
    }

    public struct DeregisterDBProxyTargetsRequest: AWSEncodableShape {
        /// One or more DB cluster identifiers.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var dbClusterIdentifiers: [String]?
        /// One or more DB instance identifiers.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var dbInstanceIdentifiers: [String]?
        /// The identifier of the DBProxy that is associated with the DBProxyTargetGroup.
        public let dbProxyName: String?
        /// The identifier of the DBProxyTargetGroup.
        public let targetGroupName: String?

        public init(dbClusterIdentifiers: [String]? = nil, dbInstanceIdentifiers: [String]? = nil, dbProxyName: String? = nil, targetGroupName: String? = nil) {
            self.dbClusterIdentifiers = dbClusterIdentifiers
            self.dbInstanceIdentifiers = dbInstanceIdentifiers
            self.dbProxyName = dbProxyName
            self.targetGroupName = targetGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifiers = "DBClusterIdentifiers"
            case dbInstanceIdentifiers = "DBInstanceIdentifiers"
            case dbProxyName = "DBProxyName"
            case targetGroupName = "TargetGroupName"
        }
    }

    public struct DeregisterDBProxyTargetsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAccountAttributesMessage: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeBlueGreenDeploymentsRequest: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The blue/green deployment identifier. If you specify this parameter, the response only includes information about the specific blue/green deployment. This parameter isn't case-sensitive. Constraints:   Must match an existing blue/green deployment identifier.
        public let blueGreenDeploymentIdentifier: String?
        /// A filter that specifies one or more blue/green deployments to describe. Valid Values:    blue-green-deployment-identifier - Accepts system-generated identifiers for blue/green deployments. The results list only includes information about the blue/green deployments with the specified identifiers.    blue-green-deployment-name - Accepts user-supplied names for blue/green deployments.  The results list only includes information about the blue/green deployments with the  specified names.    source - Accepts source databases for a blue/green deployment.  The results list only includes information about the blue/green deployments with  the specified source databases.    target - Accepts target databases for a blue/green deployment.  The results list only includes information about the blue/green deployments with  the specified target databases.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeBlueGreenDeployments request. If you specify this parameter, the response only includes records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints:   Must be a minimum of 20.   Can't exceed 100.
        public let maxRecords: Int?

        public init(blueGreenDeploymentIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.blueGreenDeploymentIdentifier = blueGreenDeploymentIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, max: 255)
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, min: 1)
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeploymentIdentifier = "BlueGreenDeploymentIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeBlueGreenDeploymentsResponse: AWSDecodableShape {
        /// A list of blue/green deployments in the current account and Amazon Web Services Region.
        @OptionalCustomCoding<StandardArrayCoder<BlueGreenDeployment>>
        public var blueGreenDeployments: [BlueGreenDeployment]?
        /// A pagination token that can be used in a later DescribeBlueGreenDeployments request.
        public let marker: String?

        public init(blueGreenDeployments: [BlueGreenDeployment]? = nil, marker: String? = nil) {
            self.blueGreenDeployments = blueGreenDeployments
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeployments = "BlueGreenDeployments"
            case marker = "Marker"
        }
    }

    public struct DescribeCertificatesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The user-supplied certificate identifier. If this parameter is specified, information for only the identified certificate is returned. This parameter isn't case-sensitive. Constraints:   Must match an existing CertificateIdentifier.
        public let certificateIdentifier: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeCertificates request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(certificateIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.certificateIdentifier = certificateIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case certificateIdentifier = "CertificateIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBClusterAutomatedBackupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// (Optional) The user-supplied DB cluster identifier. If this parameter is specified, it must match the identifier of an existing DB cluster. It returns information from the specific DB cluster's automated backup. This parameter isn't case-sensitive.
        public let dbClusterIdentifier: String?
        /// The resource ID of the DB cluster that is the source of the automated backup. This parameter isn't case-sensitive.
        public let dbClusterResourceId: String?
        /// A filter that specifies which resources to return based on status. Supported filters are the following:    status     retained - Automated backups for deleted clusters and after backup replication is stopped.      db-cluster-id - Accepts DB cluster identifiers and Amazon Resource Names (ARNs).  The results list includes only information about the DB cluster automated backups identified by these ARNs.    db-cluster-resource-id - Accepts DB resource identifiers and Amazon Resource Names (ARNs).  The results list includes only information about the DB cluster resources identified by these ARNs.   Returns all resources by default. The status for each resource is specified in the response.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The pagination token provided in the previous request. If this parameter is specified the response includes only  records beyond the marker, up to MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords  value, a pagination token called a marker is included in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?

        public init(dbClusterIdentifier: String? = nil, dbClusterResourceId: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterResourceId = dbClusterResourceId
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterResourceId = "DbClusterResourceId"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBClusterBacktracksMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// If specified, this value is the backtrack identifier of the backtrack to be described. Constraints:   Must contain a valid universally unique identifier (UUID). For more information about UUIDs, see  Universally unique  identifier.   Example: 123e4567-e89b-12d3-a456-426655440000
        public let backtrackIdentifier: String?
        /// The DB cluster identifier of the DB cluster to be described. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster1
        public let dbClusterIdentifier: String?
        /// A filter that specifies one or more DB clusters to describe. Supported filters include the following:    db-cluster-backtrack-id - Accepts backtrack identifiers. The results list includes information about only the backtracks identified by these identifiers.    db-cluster-backtrack-status - Accepts any of the following backtrack status values:    applying     completed     failed     pending    The results list includes information about only the backtracks identified by these values.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBClusterBacktracks request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(backtrackIdentifier: String? = nil, dbClusterIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.backtrackIdentifier = backtrackIdentifier
            self.dbClusterIdentifier = dbClusterIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case backtrackIdentifier = "BacktrackIdentifier"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBClusterEndpointsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The identifier of the endpoint to describe. This parameter is stored as a lowercase string.
        public let dbClusterEndpointIdentifier: String?
        /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is stored as a lowercase string.
        public let dbClusterIdentifier: String?
        /// A set of name-value pairs that define which endpoints to include in the output. The filters are specified as name-value pairs, in the format Name=endpoint_type,Values=endpoint_type1,endpoint_type2,.... Name can be one of: db-cluster-endpoint-type, db-cluster-endpoint-custom-type, db-cluster-endpoint-id, db-cluster-endpoint-status. Values for the  db-cluster-endpoint-type filter can be one or more of: reader, writer, custom. Values for the db-cluster-endpoint-custom-type filter can be one or more of: reader, any. Values for the db-cluster-endpoint-status filter can be one or more of: available, creating, deleting, inactive, modifying.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBClusterEndpoints request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbClusterEndpointIdentifier: String? = nil, dbClusterIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbClusterEndpointIdentifier = dbClusterEndpointIdentifier
            self.dbClusterIdentifier = dbClusterIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBClusterParameterGroupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of a specific DB cluster parameter group to return details for. Constraints:   If supplied, must match the name of an existing DBClusterParameterGroup.
        public let dbClusterParameterGroupName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBClusterParameterGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbClusterParameterGroupName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBClusterParametersMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of a specific DB cluster parameter group to return parameter details for. Constraints:   If supplied, must match the name of an existing DBClusterParameterGroup.
        public let dbClusterParameterGroupName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBClusterParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// A specific source to return parameters for. Valid Values:    customer     engine     service
        public let source: String?

        public init(dbClusterParameterGroupName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, source: String? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case source = "Source"
        }
    }

    public struct DescribeDBClusterSnapshotAttributesMessage: AWSEncodableShape {
        /// The identifier for the DB cluster snapshot to describe the attributes for.
        public let dbClusterSnapshotIdentifier: String?

        public init(dbClusterSnapshotIdentifier: String? = nil) {
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        }
    }

    public struct DescribeDBClusterSnapshotAttributesResult: AWSDecodableShape {
        public let dbClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?

        public init(dbClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult? = nil) {
            self.dbClusterSnapshotAttributesResult = dbClusterSnapshotAttributesResult
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
        }
    }

    public struct DescribeDBClusterSnapshotsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The ID of the DB cluster to retrieve the list of DB cluster snapshots for.  This parameter can't be used in conjunction with the DBClusterSnapshotIdentifier parameter. This parameter isn't case-sensitive. Constraints:   If supplied, must match the identifier of an existing DBCluster.
        public let dbClusterIdentifier: String?
        /// A specific DB cluster resource ID to describe.
        public let dbClusterResourceId: String?
        /// A specific DB cluster snapshot identifier to describe.  This parameter can't be used in conjunction with the DBClusterIdentifier parameter.             This value is stored as a lowercase string. Constraints:   If supplied, must match the identifier of an existing DBClusterSnapshot.   If this identifier is for an automated snapshot, the SnapshotType parameter must also be specified.
        public let dbClusterSnapshotIdentifier: String?
        /// A filter that specifies one or more DB cluster snapshots to describe. Supported filters:    db-cluster-id - Accepts DB cluster identifiers and DB  cluster Amazon Resource Names (ARNs).    db-cluster-snapshot-id - Accepts DB cluster snapshot identifiers.    snapshot-type - Accepts types of DB cluster snapshots.    engine - Accepts names of database engines.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// Specifies whether to include manual DB cluster snapshots that are public and can be copied  or restored by any Amazon Web Services account. By default, the public snapshots are not included. You can share a manual DB cluster snapshot  as public by using the ModifyDBClusterSnapshotAttribute API action.
        public let includePublic: Bool?
        /// Specifies whether to include shared manual DB cluster snapshots  from other Amazon Web Services accounts that this Amazon Web Services account has been given  permission to copy or restore. By default, these snapshots are not included. You can give an Amazon Web Services account permission to restore a manual DB cluster snapshot from another Amazon Web Services account by the ModifyDBClusterSnapshotAttribute API action.
        public let includeShared: Bool?
        /// An optional pagination token provided by a previous DescribeDBClusterSnapshots request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The type of DB cluster snapshots to be returned. You can specify one of the following values:    automated - Return all DB cluster snapshots that have been automatically taken by  Amazon RDS for my Amazon Web Services account.    manual - Return all DB cluster snapshots that have been taken by my Amazon Web Services account.    shared - Return all manual DB cluster snapshots that have been shared to my Amazon Web Services account.    public - Return all DB cluster snapshots that have been marked as public.   If you don't specify a SnapshotType value, then both automated and manual DB cluster snapshots are returned. You can include shared DB cluster snapshots with these results by enabling the IncludeShared parameter. You can include public DB cluster snapshots with these results by enabling the  IncludePublic parameter. The IncludeShared and IncludePublic parameters don't apply for SnapshotType values of manual or automated. The IncludePublic parameter doesn't apply when SnapshotType is set to shared. The IncludeShared parameter doesn't apply when SnapshotType is set to public.
        public let snapshotType: String?

        public init(dbClusterIdentifier: String? = nil, dbClusterResourceId: String? = nil, dbClusterSnapshotIdentifier: String? = nil, filters: [Filter]? = nil, includePublic: Bool? = nil, includeShared: Bool? = nil, marker: String? = nil, maxRecords: Int? = nil, snapshotType: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterResourceId = dbClusterResourceId
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.filters = filters
            self.includePublic = includePublic
            self.includeShared = includeShared
            self.marker = marker
            self.maxRecords = maxRecords
            self.snapshotType = snapshotType
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterResourceId = "DbClusterResourceId"
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
            case filters = "Filters"
            case includePublic = "IncludePublic"
            case includeShared = "IncludeShared"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case snapshotType = "SnapshotType"
        }
    }

    public struct DescribeDBClustersMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The user-supplied DB cluster identifier or the Amazon Resource Name (ARN) of the DB cluster. If this parameter is specified,  information for only the specific DB cluster is returned. This parameter isn't case-sensitive. Constraints:   If supplied, must match an existing DB cluster identifier.
        public let dbClusterIdentifier: String?
        /// A filter that specifies one or more DB clusters to describe. Supported Filters:    clone-group-id - Accepts clone group identifiers.  The results list only includes information about the DB clusters associated with these clone groups.    db-cluster-id - Accepts DB cluster identifiers and DB  cluster Amazon Resource Names (ARNs). The results list only includes information about the DB clusters identified by these ARNs.    db-cluster-resource-id - Accepts DB cluster resource identifiers. The results list will only include information about the DB clusters identified by these DB cluster resource identifiers.    domain - Accepts Active Directory directory IDs.  The results list only includes information about the DB clusters associated with these domains.    engine - Accepts engine names.  The results list only includes information about the DB clusters for these engines.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// Specifies whether the output includes information about clusters shared from other Amazon Web Services accounts.
        public let includeShared: Bool?
        /// An optional pagination token provided by a previous DescribeDBClusters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100
        public let maxRecords: Int?

        public init(dbClusterIdentifier: String? = nil, filters: [Filter]? = nil, includeShared: Bool? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.filters = filters
            self.includeShared = includeShared
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case filters = "Filters"
            case includeShared = "IncludeShared"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBEngineVersionsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of a specific DB parameter group family to return details for. Constraints:   If supplied, must match an existing DB parameter group family.
        public let dbParameterGroupFamily: String?
        /// Specifies whether to return only the default version of the specified engine or the engine and major version combination.
        public let defaultOnly: Bool?
        /// The database engine to return version details for. Valid Values:    aurora-mysql     aurora-postgresql     custom-oracle-ee     db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engine: String?
        /// A specific database engine version to return details for. Example: 5.1.49
        public let engineVersion: String?
        /// A filter that specifies one or more DB engine versions to describe. Supported filters:    db-parameter-group-family - Accepts parameter groups family names.  The results list only includes information about the DB engine versions for these parameter group families.    engine - Accepts engine names.  The results list only includes information about the DB engine versions for these engines.    engine-mode - Accepts DB engine modes.  The results list only includes information about the DB engine versions for these engine modes. Valid  DB engine modes are the following:    global     multimaster     parallelquery     provisioned     serverless       engine-version - Accepts engine versions.  The results list only includes information about the DB engine versions for these engine versions.    status - Accepts engine version statuses.  The results list only includes information about the DB engine versions for these statuses. Valid statuses  are the following:    available     deprecated
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// Specifies whether to also list the engine versions that aren't available. The default is to list only available engine versions.
        public let includeAll: Bool?
        /// Specifies whether to list the supported character sets for each engine version. If this parameter is enabled and the requested engine supports the CharacterSetName parameter for CreateDBInstance, the response includes a list of supported character sets for each engine version. For RDS Custom, the default is not to list supported character sets. If you enable this parameter, RDS Custom returns no results.
        public let listSupportedCharacterSets: Bool?
        /// Specifies whether to list the supported time zones for each engine version. If this parameter is enabled and the requested engine supports the TimeZone parameter for CreateDBInstance,  the response includes a list of supported time zones for each engine version. For RDS Custom, the default is not to list supported time zones. If you enable this parameter, RDS Custom returns no results.
        public let listSupportedTimezones: Bool?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbParameterGroupFamily: String? = nil, defaultOnly: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, filters: [Filter]? = nil, includeAll: Bool? = nil, listSupportedCharacterSets: Bool? = nil, listSupportedTimezones: Bool? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.defaultOnly = defaultOnly
            self.engine = engine
            self.engineVersion = engineVersion
            self.filters = filters
            self.includeAll = includeAll
            self.listSupportedCharacterSets = listSupportedCharacterSets
            self.listSupportedTimezones = listSupportedTimezones
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case defaultOnly = "DefaultOnly"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case filters = "Filters"
            case includeAll = "IncludeAll"
            case listSupportedCharacterSets = "ListSupportedCharacterSets"
            case listSupportedTimezones = "ListSupportedTimezones"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBInstanceAutomatedBackupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The Amazon Resource Name (ARN) of the replicated automated backups, for example, arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE. This setting doesn't apply to RDS Custom.
        public let dbInstanceAutomatedBackupsArn: String?
        /// (Optional) The user-supplied instance identifier. If this parameter is specified, it must match the identifier of an existing DB instance. It returns information from the specific DB instance's automated backup. This parameter isn't case-sensitive.
        public let dbInstanceIdentifier: String?
        /// The resource ID of the DB instance that is the source of  the automated backup. This parameter isn't case-sensitive.
        public let dbiResourceId: String?
        /// A filter that specifies which resources to return based on status. Supported filters are the following:    status     active - Automated backups for current instances.    creating - Automated backups that are waiting for the first automated snapshot to be available.    retained - Automated backups for deleted instances and after backup replication is stopped.      db-instance-id - Accepts DB instance identifiers and Amazon Resource Names (ARNs).  The results list includes only information about the DB instance automated backups identified by these ARNs.    dbi-resource-id - Accepts DB resource identifiers and Amazon Resource Names (ARNs).  The results list includes only information about the DB instance resources identified by these ARNs.   Returns all resources by default. The status for each resource is specified in the response.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The pagination token provided in the previous request. If this parameter is specified the response  includes only records beyond the marker, up to MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified  MaxRecords value, a pagination token called a marker is included in the response so that  you can retrieve the remaining results.
        public let maxRecords: Int?

        public init(dbInstanceAutomatedBackupsArn: String? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbInstanceAutomatedBackupsArn = dbInstanceAutomatedBackupsArn
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBInstancesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The user-supplied instance identifier or the Amazon Resource Name (ARN) of the DB instance. If this parameter is specified,  information from only the specific DB instance is returned. This parameter isn't case-sensitive. Constraints:   If supplied, must match the identifier of an existing DB instance.
        public let dbInstanceIdentifier: String?
        /// A filter that specifies one or more DB instances to describe. Supported Filters:    db-cluster-id - Accepts DB cluster identifiers and DB  cluster Amazon Resource Names (ARNs). The results list only includes information about  the DB instances associated with the DB clusters identified by these ARNs.    db-instance-id - Accepts DB instance identifiers and DB  instance Amazon Resource Names (ARNs). The results list only includes information about the DB instances identified by these ARNs.    dbi-resource-id - Accepts DB instance resource identifiers. The results list  only includes information about the DB instances identified by these DB instance resource identifiers.    domain - Accepts Active Directory directory IDs. The results list only includes  information about the DB instances associated with these domains.    engine - Accepts engine names. The results list only includes information  about the DB instances for these engines.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBInstances request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbInstanceIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBLogFilesDetails: AWSDecodableShape {
        /// A POSIX timestamp when the last log entry was written.
        public let lastWritten: Int64?
        /// The name of the log file for the specified DB instance.
        public let logFileName: String?
        /// The size, in bytes, of the log file for the specified DB instance.
        public let size: Int64?

        public init(lastWritten: Int64? = nil, logFileName: String? = nil, size: Int64? = nil) {
            self.lastWritten = lastWritten
            self.logFileName = logFileName
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case lastWritten = "LastWritten"
            case logFileName = "LogFileName"
            case size = "Size"
        }
    }

    public struct DescribeDBLogFilesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The customer-assigned name of the DB instance that contains the log files you want to list. Constraints:   Must match the identifier of an existing DBInstance.
        public let dbInstanceIdentifier: String?
        /// Filters the available log files for files written since the specified date, in POSIX timestamp format with milliseconds.
        public let fileLastWritten: Int64?
        /// Filters the available log files for log file names that contain the specified string.
        public let filenameContains: String?
        /// Filters the available log files for files larger than the specified size.
        public let fileSize: Int64?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The pagination token provided in the previous request. If this parameter is specified the response includes only records beyond the marker, up to MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results.
        public let maxRecords: Int?

        public init(dbInstanceIdentifier: String? = nil, fileLastWritten: Int64? = nil, filenameContains: String? = nil, fileSize: Int64? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.fileLastWritten = fileLastWritten
            self.filenameContains = filenameContains
            self.fileSize = fileSize
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case fileLastWritten = "FileLastWritten"
            case filenameContains = "FilenameContains"
            case fileSize = "FileSize"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBLogFilesResponse: AWSDecodableShape {
        public struct _DescribeDBLogFilesEncoding: ArrayCoderProperties { public static let member = "DescribeDBLogFilesDetails" }

        /// The DB log files returned.
        @OptionalCustomCoding<ArrayCoder<_DescribeDBLogFilesEncoding, DescribeDBLogFilesDetails>>
        public var describeDBLogFiles: [DescribeDBLogFilesDetails]?
        /// A pagination token that can be used in a later DescribeDBLogFiles request.
        public let marker: String?

        public init(describeDBLogFiles: [DescribeDBLogFilesDetails]? = nil, marker: String? = nil) {
            self.describeDBLogFiles = describeDBLogFiles
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case describeDBLogFiles = "DescribeDBLogFiles"
            case marker = "Marker"
        }
    }

    public struct DescribeDBParameterGroupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of a specific DB parameter group to return details for. Constraints:   If supplied, must match the name of an existing DBClusterParameterGroup.
        public let dbParameterGroupName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBParameterGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbParameterGroupName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBParametersMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of a specific DB parameter group to return details for. Constraints:   If supplied, must match the name of an existing DBParameterGroup.
        public let dbParameterGroupName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The parameter types to return. Default: All parameter types returned Valid Values: user | system | engine-default
        public let source: String?

        public init(dbParameterGroupName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, source: String? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case source = "Source"
        }
    }

    public struct DescribeDBProxiesRequest: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of the DB proxy. If you omit this parameter, the output includes information about all DB proxies owned by your Amazon Web Services account ID.
        public let dbProxyName: String?
        /// This parameter is not currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbProxyName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbProxyName = dbProxyName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyName = "DBProxyName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBProxiesResponse: AWSDecodableShape {
        /// A return value representing an arbitrary number of DBProxy data structures.
        @OptionalCustomCoding<StandardArrayCoder<DBProxy>>
        public var dbProxies: [DBProxy]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbProxies: [DBProxy]? = nil, marker: String? = nil) {
            self.dbProxies = dbProxies
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxies = "DBProxies"
            case marker = "Marker"
        }
    }

    public struct DescribeDBProxyEndpointsRequest: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of a DB proxy endpoint to describe. If you omit this parameter, the output includes information about all DB proxy endpoints associated with the specified proxy.
        public let dbProxyEndpointName: String?
        /// The name of the DB proxy whose endpoints you want to describe. If you omit this parameter, the output includes information about all DB proxy endpoints associated with all your DB proxies.
        public let dbProxyName: String?
        /// This parameter is not currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbProxyEndpointName: String? = nil, dbProxyName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbProxyEndpointName = dbProxyEndpointName
            self.dbProxyName = dbProxyName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, max: 63)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, min: 1)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.dbProxyName, name: "dbProxyName", parent: name, max: 63)
            try self.validate(self.dbProxyName, name: "dbProxyName", parent: name, min: 1)
            try self.validate(self.dbProxyName, name: "dbProxyName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpointName = "DBProxyEndpointName"
            case dbProxyName = "DBProxyName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBProxyEndpointsResponse: AWSDecodableShape {
        /// The list of ProxyEndpoint objects returned by the API operation.
        @OptionalCustomCoding<StandardArrayCoder<DBProxyEndpoint>>
        public var dbProxyEndpoints: [DBProxyEndpoint]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(dbProxyEndpoints: [DBProxyEndpoint]? = nil, marker: String? = nil) {
            self.dbProxyEndpoints = dbProxyEndpoints
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpoints = "DBProxyEndpoints"
            case marker = "Marker"
        }
    }

    public struct DescribeDBProxyTargetGroupsRequest: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The identifier of the DBProxy associated with the target group.
        public let dbProxyName: String?
        /// This parameter is not currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The identifier of the DBProxyTargetGroup to describe.
        public let targetGroupName: String?

        public init(dbProxyName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, targetGroupName: String? = nil) {
            self.dbProxyName = dbProxyName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.targetGroupName = targetGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyName = "DBProxyName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case targetGroupName = "TargetGroupName"
        }
    }

    public struct DescribeDBProxyTargetGroupsResponse: AWSDecodableShape {
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// An arbitrary number of DBProxyTargetGroup objects, containing details of the corresponding target groups.
        @OptionalCustomCoding<StandardArrayCoder<DBProxyTargetGroup>>
        public var targetGroups: [DBProxyTargetGroup]?

        public init(marker: String? = nil, targetGroups: [DBProxyTargetGroup]? = nil) {
            self.marker = marker
            self.targetGroups = targetGroups
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case targetGroups = "TargetGroups"
        }
    }

    public struct DescribeDBProxyTargetsRequest: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The identifier of the DBProxyTarget to describe.
        public let dbProxyName: String?
        /// This parameter is not currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The identifier of the DBProxyTargetGroup to describe.
        public let targetGroupName: String?

        public init(dbProxyName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, targetGroupName: String? = nil) {
            self.dbProxyName = dbProxyName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.targetGroupName = targetGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyName = "DBProxyName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case targetGroupName = "TargetGroupName"
        }
    }

    public struct DescribeDBProxyTargetsResponse: AWSDecodableShape {
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// An arbitrary number of DBProxyTarget objects, containing details of the corresponding targets.
        @OptionalCustomCoding<StandardArrayCoder<DBProxyTarget>>
        public var targets: [DBProxyTarget]?

        public init(marker: String? = nil, targets: [DBProxyTarget]? = nil) {
            self.marker = marker
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case targets = "Targets"
        }
    }

    public struct DescribeDBRecommendationsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// A filter that specifies one or more recommendations to describe. Supported Filters:    recommendation-id - Accepts a list of recommendation identifiers. The results list only includes the recommendations whose identifier is one of the specified filter values.    status - Accepts a list of recommendation statuses. Valid values:    active - The recommendations which are ready for you to apply.    pending - The applied or scheduled recommendations which are in progress.    resolved - The recommendations which are completed.    dismissed - The recommendations that you dismissed.   The results list only includes the recommendations whose status is one of the specified filter values.    severity - Accepts a list of recommendation severities. The results list only includes  the recommendations whose severity is one of the specified filter values. Valid values:    high     medium     low     informational       type-id - Accepts a list of recommendation type identifiers. The results list only includes the recommendations whose type is one of the specified filter values.    dbi-resource-id - Accepts a list of database resource identifiers. The results list only includes the recommendations that generated for the specified databases.    cluster-resource-id - Accepts a list of cluster resource identifiers. The results list only includes the recommendations that generated for the specified clusters.    pg-arn - Accepts a list of parameter group ARNs. The results list only includes the recommendations that generated for the specified parameter groups.    cluster-pg-arn - Accepts a list of cluster parameter group ARNs. The results list only includes the recommendations that generated for the specified cluster parameter groups.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// A filter to include only the recommendations that were updated after this specified time.
        public let lastUpdatedAfter: Date?
        /// A filter to include only the recommendations that were updated before this specified time.
        public let lastUpdatedBefore: Date?
        /// The language that you choose to return the list of recommendations. Valid values:    en     en_UK     de     es     fr     id     it     ja     ko     pt_BR     zh_TW     zh_CN
        public let locale: String?
        /// An optional pagination token provided by a previous DescribeDBRecommendations request.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of recommendations to include in the response. If more records exist than the  specified MaxRecords value, a pagination token called a marker is included in the response so  that you can retrieve the remaining results.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, lastUpdatedAfter: Date? = nil, lastUpdatedBefore: Date? = nil, locale: String? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.lastUpdatedAfter = lastUpdatedAfter
            self.lastUpdatedBefore = lastUpdatedBefore
            self.locale = locale
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case lastUpdatedAfter = "LastUpdatedAfter"
            case lastUpdatedBefore = "LastUpdatedBefore"
            case locale = "Locale"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBSecurityGroupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of the DB security group to return details for.
        public let dbSecurityGroupName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBSecurityGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbSecurityGroupName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbSecurityGroupName = dbSecurityGroupName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupName = "DBSecurityGroupName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBShardGroupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The user-supplied DB shard group identifier or the Amazon Resource Name (ARN) of the DB shard group. If this parameter is specified,  information for only the specific DB shard group is returned. This parameter isn't case-sensitive. Constraints:   If supplied, must match an existing DB shard group identifier.
        public let dbShardGroupIdentifier: String?
        /// A filter that specifies one or more DB shard groups to describe.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBShardGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100
        public let maxRecords: Int?

        public init(dbShardGroupIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, max: 63)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, min: 1)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dbShardGroupIdentifier = "DBShardGroupIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDBShardGroupsResponse: AWSDecodableShape {
        public struct _DBShardGroupsEncoding: ArrayCoderProperties { public static let member = "DBShardGroup" }

        /// Contains a list of DB shard groups for the user.
        @OptionalCustomCoding<ArrayCoder<_DBShardGroupsEncoding, DBShardGroup>>
        public var dbShardGroups: [DBShardGroup]?
        /// A pagination token that can be used in a later DescribeDBClusters request.
        public let marker: String?

        public init(dbShardGroups: [DBShardGroup]? = nil, marker: String? = nil) {
            self.dbShardGroups = dbShardGroups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dbShardGroups = "DBShardGroups"
            case marker = "Marker"
        }
    }

    public struct DescribeDBSnapshotAttributesMessage: AWSEncodableShape {
        /// The identifier for the DB snapshot to describe the attributes for.
        public let dbSnapshotIdentifier: String?

        public init(dbSnapshotIdentifier: String? = nil) {
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
        }
    }

    public struct DescribeDBSnapshotAttributesResult: AWSDecodableShape {
        public let dbSnapshotAttributesResult: DBSnapshotAttributesResult?

        public init(dbSnapshotAttributesResult: DBSnapshotAttributesResult? = nil) {
            self.dbSnapshotAttributesResult = dbSnapshotAttributesResult
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotAttributesResult = "DBSnapshotAttributesResult"
        }
    }

    public struct DescribeDBSnapshotTenantDatabasesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The ID of the DB instance used to create the DB snapshots. This parameter isn't case-sensitive. Constraints:   If supplied, must match the identifier of an existing DBInstance.
        public let dbInstanceIdentifier: String?
        /// A specific DB resource identifier to describe.
        public let dbiResourceId: String?
        /// The ID of a DB snapshot that contains the tenant databases to describe. This value is stored as a lowercase string. Constraints:   If you specify this parameter, the value must match the ID of an existing DB snapshot.   If you specify an automatic snapshot, you must also specify SnapshotType.
        public let dbSnapshotIdentifier: String?
        /// A filter that specifies one or more tenant databases to describe. Supported filters:    tenant-db-name - Tenant database names. The results list only includes information about the tenant databases that match these tenant DB names.    tenant-database-resource-id - Tenant database resource identifiers. The results list only includes information about the tenant databases contained within the DB snapshots.    dbi-resource-id - DB instance resource identifiers. The results list only includes information about snapshots containing tenant databases contained within the DB instances identified by these resource identifiers.    db-instance-id - Accepts DB instance identifiers and DB instance Amazon Resource Names (ARNs).    db-snapshot-id - Accepts DB snapshot identifiers.    snapshot-type - Accepts types of DB snapshots.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBSnapshotTenantDatabases request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The type of DB snapshots to be returned. You can specify one of the following values:    automated – All DB snapshots that have been automatically taken by Amazon RDS for my Amazon Web Services account.    manual – All DB snapshots that have been taken by my Amazon Web Services account.    shared – All manual DB snapshots that have been shared to my Amazon Web Services account.    public – All DB snapshots that have been marked as public.    awsbackup – All DB snapshots managed by the Amazon Web Services Backup service.
        public let snapshotType: String?

        public init(dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dbSnapshotIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, snapshotType: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.snapshotType = snapshotType
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case snapshotType = "SnapshotType"
        }
    }

    public struct DescribeDBSnapshotsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The ID of the DB instance to retrieve the list of DB snapshots for.  This parameter isn't case-sensitive. Constraints:   If supplied, must match the identifier of an existing DBInstance.
        public let dbInstanceIdentifier: String?
        /// A specific DB resource ID to describe.
        public let dbiResourceId: String?
        /// A specific DB snapshot identifier to describe. This value is stored as a lowercase string. Constraints:   If supplied, must match the identifier of an existing DBSnapshot.   If this identifier is for an automated snapshot, the SnapshotType parameter must also be specified.
        public let dbSnapshotIdentifier: String?
        /// A filter that specifies one or more DB snapshots to describe. Supported filters:    db-instance-id - Accepts DB instance identifiers and DB  instance Amazon Resource Names (ARNs).    db-snapshot-id - Accepts DB snapshot identifiers.    dbi-resource-id - Accepts identifiers of source DB instances.    snapshot-type - Accepts types of DB snapshots.    engine - Accepts names of database engines.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// Specifies whether to include manual DB cluster snapshots that are public and can be copied  or restored by any Amazon Web Services account. By default, the public snapshots are not included. You can share a manual DB snapshot as public by using the ModifyDBSnapshotAttribute API. This setting doesn't apply to RDS Custom.
        public let includePublic: Bool?
        /// Specifies whether to include shared manual DB cluster snapshots  from other Amazon Web Services accounts that this Amazon Web Services account has been given  permission to copy or restore. By default, these snapshots are not included. You can give an Amazon Web Services account permission to restore a manual DB snapshot from another Amazon Web Services account by using the ModifyDBSnapshotAttribute API action. This setting doesn't apply to RDS Custom.
        public let includeShared: Bool?
        /// An optional pagination token provided by a previous DescribeDBSnapshots request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The type of snapshots to be returned. You can specify one of the following values:    automated - Return all DB snapshots that have been automatically taken by  Amazon RDS for my Amazon Web Services account.    manual - Return all DB snapshots that have been taken by my Amazon Web Services account.    shared - Return all manual DB snapshots that have been shared to my Amazon Web Services account.    public - Return all DB snapshots that have been marked as public.    awsbackup - Return the DB snapshots managed by the Amazon Web Services Backup service. For information about Amazon Web Services Backup, see the   Amazon Web Services Backup Developer Guide.   The awsbackup type does not apply to Aurora.   If you don't specify a SnapshotType value, then both automated and manual snapshots are returned. Shared and public DB snapshots are not included in the returned results by default. You can include shared snapshots with these results by enabling the IncludeShared parameter. You can include public snapshots with these results by enabling the  IncludePublic parameter. The IncludeShared and IncludePublic parameters don't apply for SnapshotType values of manual or automated. The IncludePublic parameter doesn't apply when SnapshotType is set to shared. The IncludeShared parameter doesn't apply when SnapshotType is set to public.
        public let snapshotType: String?

        public init(dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dbSnapshotIdentifier: String? = nil, filters: [Filter]? = nil, includePublic: Bool? = nil, includeShared: Bool? = nil, marker: String? = nil, maxRecords: Int? = nil, snapshotType: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.filters = filters
            self.includePublic = includePublic
            self.includeShared = includeShared
            self.marker = marker
            self.maxRecords = maxRecords
            self.snapshotType = snapshotType
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case filters = "Filters"
            case includePublic = "IncludePublic"
            case includeShared = "IncludeShared"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case snapshotType = "SnapshotType"
        }
    }

    public struct DescribeDBSubnetGroupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of the DB subnet group to return details for.
        public let dbSubnetGroupName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeDBSubnetGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbSubnetGroupName: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbSubnetGroupName = dbSubnetGroupName
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupName = "DBSubnetGroupName"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEngineDefaultClusterParametersMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of the DB cluster parameter group family to return engine parameter information for.
        public let dbParameterGroupFamily: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeEngineDefaultClusterParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbParameterGroupFamily: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEngineDefaultClusterParametersResult: AWSDecodableShape {
        public let engineDefaults: EngineDefaults?

        public init(engineDefaults: EngineDefaults? = nil) {
            self.engineDefaults = engineDefaults
        }

        private enum CodingKeys: String, CodingKey {
            case engineDefaults = "EngineDefaults"
        }
    }

    public struct DescribeEngineDefaultParametersMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of the DB parameter group family. Valid Values:    aurora-mysql5.7     aurora-mysql8.0     aurora-postgresql10     aurora-postgresql11     aurora-postgresql12     aurora-postgresql13     aurora-postgresql14     custom-oracle-ee-19     db2-ae     db2-se     mariadb10.2     mariadb10.3     mariadb10.4     mariadb10.5     mariadb10.6     mysql5.7     mysql8.0     oracle-ee-19     oracle-ee-cdb-19     oracle-ee-cdb-21     oracle-se2-19     oracle-se2-cdb-19     oracle-se2-cdb-21     postgres10     postgres11     postgres12     postgres13     postgres14     sqlserver-ee-11.0     sqlserver-ee-12.0     sqlserver-ee-13.0     sqlserver-ee-14.0     sqlserver-ee-15.0     sqlserver-ex-11.0     sqlserver-ex-12.0     sqlserver-ex-13.0     sqlserver-ex-14.0     sqlserver-ex-15.0     sqlserver-se-11.0     sqlserver-se-12.0     sqlserver-se-13.0     sqlserver-se-14.0     sqlserver-se-15.0     sqlserver-web-11.0     sqlserver-web-12.0     sqlserver-web-13.0     sqlserver-web-14.0     sqlserver-web-15.0
        public let dbParameterGroupFamily: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeEngineDefaultParameters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(dbParameterGroupFamily: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEngineDefaultParametersResult: AWSDecodableShape {
        public let engineDefaults: EngineDefaults?

        public init(engineDefaults: EngineDefaults? = nil) {
            self.engineDefaults = engineDefaults
        }

        private enum CodingKeys: String, CodingKey {
            case engineDefaults = "EngineDefaults"
        }
    }

    public struct DescribeEventCategoriesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The type of source that is generating the events. For RDS Proxy events, specify db-proxy. Valid Values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot | db-proxy
        public let sourceType: String?

        public init(filters: [Filter]? = nil, sourceType: String? = nil) {
            self.filters = filters
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case sourceType = "SourceType"
        }
    }

    public struct DescribeEventSubscriptionsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The name of the RDS event notification subscription you want to describe.
        public let subscriptionName: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, subscriptionName: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DescribeEventsMessage: AWSEncodableShape {
        public struct _EventCategoriesEncoding: ArrayCoderProperties { public static let member = "EventCategory" }
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The number of minutes to retrieve events for. Default: 60
        public let duration: Int?
        /// The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601,  go to the ISO8601 Wikipedia page.  Example: 2009-07-08T18:00Z
        public let endTime: Date?
        /// A list of event categories that trigger notifications for a event notification subscription.
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesEncoding, String>>
        public var eventCategories: [String]?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeEvents request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The identifier of the event source for which events are returned. If not specified, then all sources are included in the response. Constraints:   If SourceIdentifier is supplied, SourceType must also be provided.   If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.   If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.   If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.   If the source type is a DB security group, a DBSecurityGroupName value must be supplied.   If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.   If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.   If the source type is an RDS Proxy, a DBProxyName value must be supplied.   Can't end with a hyphen or contain two consecutive hyphens.
        public let sourceIdentifier: String?
        /// The event source to retrieve events for. If no value is specified, all events are returned.
        public let sourceType: SourceType?
        /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601,  go to the ISO8601 Wikipedia page.  Example: 2009-07-08T18:00Z
        public let startTime: Date?

        public init(duration: Int? = nil, endTime: Date? = nil, eventCategories: [String]? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil, startTime: Date? = nil) {
            self.duration = duration
            self.endTime = endTime
            self.eventCategories = eventCategories
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case endTime = "EndTime"
            case eventCategories = "EventCategories"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
            case startTime = "StartTime"
        }
    }

    public struct DescribeExportTasksMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The identifier of the snapshot or cluster export task to be described.
        public let exportTaskIdentifier: String?
        /// Filters specify one or more snapshot or cluster exports to describe. The filters are specified as name-value pairs that define what to include in the output. Filter names and values are case-sensitive. Supported filters include the following:    export-task-identifier - An identifier for the snapshot or cluster export task.    s3-bucket - The Amazon S3 bucket the data is exported to.    source-arn - The Amazon Resource Name (ARN) of the snapshot or cluster exported to Amazon S3.    status - The status of the export task. Must be lowercase. Valid statuses are the following:    canceled     canceling     complete     failed     in_progress     starting
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeExportTasks request. If you specify this parameter, the response includes only records beyond the marker, up to the value specified by the MaxRecords parameter.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the  specified value, a pagination token called a marker is included in the response.  You can use the marker in a later DescribeExportTasks request  to retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the snapshot or cluster exported to Amazon S3.
        public let sourceArn: String?
        /// The type of source for the export.
        public let sourceType: ExportSourceType?

        public init(exportTaskIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, sourceArn: String? = nil, sourceType: ExportSourceType? = nil) {
            self.exportTaskIdentifier = exportTaskIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, max: 100)
            try self.validate(self.maxRecords, name: "maxRecords", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case exportTaskIdentifier = "ExportTaskIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
        }
    }

    public struct DescribeGlobalClustersMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// A filter that specifies one or more global database clusters to describe. This parameter is case-sensitive. Currently, the only supported filter is region. If used, the request returns information about any global cluster with at least one member (primary or secondary) in the specified Amazon Web Services Regions.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive. Constraints:   If supplied, must match an existing DBClusterIdentifier.
        public let globalClusterIdentifier: String?
        /// An optional pagination token provided by a previous DescribeGlobalClusters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, globalClusterIdentifier: String? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.globalClusterIdentifier = globalClusterIdentifier
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeIntegrationsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// A filter that specifies one or more resources to return.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The unique identifier of the integration.
        public let integrationIdentifier: String?
        /// An optional pagination token provided by a previous DescribeIntegrations request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, integrationIdentifier: String? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.integrationIdentifier = integrationIdentifier
            self.marker = marker
            self.maxRecords = maxRecords
        }

        public func validate(name: String) throws {
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, max: 255)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, min: 1)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, pattern: "^[a-zA-Z0-9_:\\-\\/]+$")
            try self.validate(self.marker, name: "marker", parent: name, max: 340)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case integrationIdentifier = "IntegrationIdentifier"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeIntegrationsResponse: AWSDecodableShape {
        public struct _IntegrationsEncoding: ArrayCoderProperties { public static let member = "Integration" }

        /// A list of integrations.
        @OptionalCustomCoding<ArrayCoder<_IntegrationsEncoding, Integration>>
        public var integrations: [Integration]?
        /// A pagination token that can be used in a later DescribeIntegrations request.
        public let marker: String?

        public init(integrations: [Integration]? = nil, marker: String? = nil) {
            self.integrations = integrations
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case integrations = "Integrations"
            case marker = "Marker"
        }
    }

    public struct DescribeOptionGroupOptionsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The name of the engine to describe options for. Valid Values:    db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engineName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// If specified, filters the results to include only options for the specified major engine version.
        public let majorEngineVersion: String?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(engineName: String? = nil, filters: [Filter]? = nil, majorEngineVersion: String? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.engineName = engineName
            self.filters = filters
            self.majorEngineVersion = majorEngineVersion
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case engineName = "EngineName"
            case filters = "Filters"
            case majorEngineVersion = "MajorEngineVersion"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeOptionGroupsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// A filter to only include option groups associated with this database engine. Valid Values:    db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engineName: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// Filters the list of option groups to only include groups associated with a specific database engine version. If specified, then EngineName must also be specified.
        public let majorEngineVersion: String?
        /// An optional pagination token provided by a previous DescribeOptionGroups request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The name of the option group to describe. Can't be supplied together with EngineName or MajorEngineVersion.
        public let optionGroupName: String?

        public init(engineName: String? = nil, filters: [Filter]? = nil, majorEngineVersion: String? = nil, marker: String? = nil, maxRecords: Int? = nil, optionGroupName: String? = nil) {
            self.engineName = engineName
            self.filters = filters
            self.majorEngineVersion = majorEngineVersion
            self.marker = marker
            self.maxRecords = maxRecords
            self.optionGroupName = optionGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case engineName = "EngineName"
            case filters = "Filters"
            case majorEngineVersion = "MajorEngineVersion"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case optionGroupName = "OptionGroupName"
        }
    }

    public struct DescribeOrderableDBInstanceOptionsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The Availability Zone group associated with a Local Zone. Specify this parameter to retrieve available options for the Local Zones in the group. Omit this parameter to show the available options in the specified Amazon Web Services Region. This setting doesn't apply to RDS Custom DB instances.
        public let availabilityZoneGroup: String?
        /// A filter to include only the available options for the specified DB instance class.
        public let dbInstanceClass: String?
        /// The name of the engine to describe DB instance options for. Valid Values:    aurora-mysql     aurora-postgresql     custom-oracle-ee     db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engine: String?
        /// A filter to include only the available options for the specified engine version.
        public let engineVersion: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// A filter to include only the available options for the specified license model. RDS Custom supports only the BYOL licensing model.
        public let licenseModel: String?
        /// An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 10000.
        public let maxRecords: Int?
        /// Specifies whether to show only VPC or non-VPC offerings. RDS Custom supports  only VPC offerings. RDS Custom supports only VPC offerings. If you describe non-VPC offerings for RDS Custom, the output  shows VPC offerings.
        public let vpc: Bool?

        public init(availabilityZoneGroup: String? = nil, dbInstanceClass: String? = nil, engine: String? = nil, engineVersion: String? = nil, filters: [Filter]? = nil, licenseModel: String? = nil, marker: String? = nil, maxRecords: Int? = nil, vpc: Bool? = nil) {
            self.availabilityZoneGroup = availabilityZoneGroup
            self.dbInstanceClass = dbInstanceClass
            self.engine = engine
            self.engineVersion = engineVersion
            self.filters = filters
            self.licenseModel = licenseModel
            self.marker = marker
            self.maxRecords = maxRecords
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneGroup = "AvailabilityZoneGroup"
            case dbInstanceClass = "DBInstanceClass"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case filters = "Filters"
            case licenseModel = "LicenseModel"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case vpc = "Vpc"
        }
    }

    public struct DescribePendingMaintenanceActionsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// A filter that specifies one or more resources to return pending maintenance actions for. Supported filters:    db-cluster-id - Accepts DB cluster identifiers and DB  cluster Amazon Resource Names (ARNs). The results list only includes pending maintenance  actions for the DB clusters identified by these ARNs.    db-instance-id - Accepts DB instance identifiers and DB  instance ARNs. The results list only includes pending maintenance  actions for the DB instances identified by these ARNs.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribePendingMaintenanceActions request. If this parameter is specified, the response includes only records beyond the marker, up to a number of records specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The ARN of a resource to return pending maintenance actions for.
        public let resourceIdentifier: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, resourceIdentifier: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.resourceIdentifier = resourceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct DescribeReservedDBInstancesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The DB instance class filter value. Specify this parameter to show only those reservations matching the specified DB instances class.
        public let dbInstanceClass: String?
        /// The duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration. Valid Values: 1 | 3 | 31536000 | 94608000
        public let duration: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The lease identifier filter value. Specify this parameter to show only the reservation that matches the specified lease ID.  Amazon Web Services Support might request the lease ID for an issue related to a reserved DB instance.
        public let leaseId: String?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// Specifies whether to show only those reservations that support Multi-AZ.
        public let multiAZ: Bool?
        /// The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type. Valid Values: "Partial Upfront" | "All Upfront" | "No Upfront"
        public let offeringType: String?
        /// The product description filter value. Specify this parameter to show only those reservations matching the specified product description.
        public let productDescription: String?
        /// The reserved DB instance identifier filter value. Specify this parameter to show only the reservation that matches the specified reservation ID.
        public let reservedDBInstanceId: String?
        /// The offering identifier filter value. Specify this parameter to show only purchased reservations matching the specified offering identifier.
        public let reservedDBInstancesOfferingId: String?

        public init(dbInstanceClass: String? = nil, duration: String? = nil, filters: [Filter]? = nil, leaseId: String? = nil, marker: String? = nil, maxRecords: Int? = nil, multiAZ: Bool? = nil, offeringType: String? = nil, productDescription: String? = nil, reservedDBInstanceId: String? = nil, reservedDBInstancesOfferingId: String? = nil) {
            self.dbInstanceClass = dbInstanceClass
            self.duration = duration
            self.filters = filters
            self.leaseId = leaseId
            self.marker = marker
            self.maxRecords = maxRecords
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.reservedDBInstanceId = reservedDBInstanceId
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceClass = "DBInstanceClass"
            case duration = "Duration"
            case filters = "Filters"
            case leaseId = "LeaseId"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case multiAZ = "MultiAZ"
            case offeringType = "OfferingType"
            case productDescription = "ProductDescription"
            case reservedDBInstanceId = "ReservedDBInstanceId"
            case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        }
    }

    public struct DescribeReservedDBInstancesOfferingsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.
        public let dbInstanceClass: String?
        /// Duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration. Valid Values: 1 | 3 | 31536000 | 94608000
        public let duration: String?
        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more than the MaxRecords value is available, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// Specifies whether to show only those reservations that support Multi-AZ.
        public let multiAZ: Bool?
        /// The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type. Valid Values: "Partial Upfront" | "All Upfront" | "No Upfront"
        public let offeringType: String?
        /// Product description filter value. Specify this parameter to show only the available offerings that contain the specified product description.  The results show offerings that partially match the filter value.
        public let productDescription: String?
        /// The offering identifier filter value. Specify this parameter to show only the available offering that matches the specified reservation identifier. Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706
        public let reservedDBInstancesOfferingId: String?

        public init(dbInstanceClass: String? = nil, duration: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, multiAZ: Bool? = nil, offeringType: String? = nil, productDescription: String? = nil, reservedDBInstancesOfferingId: String? = nil) {
            self.dbInstanceClass = dbInstanceClass
            self.duration = duration
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceClass = "DBInstanceClass"
            case duration = "Duration"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case multiAZ = "MultiAZ"
            case offeringType = "OfferingType"
            case productDescription = "ProductDescription"
            case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        }
    }

    public struct DescribeSourceRegionsMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeSourceRegions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results. Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The source Amazon Web Services Region name. For example, us-east-1. Constraints:   Must specify a valid Amazon Web Services Region name.
        public let regionName: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, regionName: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.regionName = regionName
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case regionName = "RegionName"
        }
    }

    public struct DescribeTenantDatabasesMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// The user-supplied DB instance identifier, which must match the identifier of an existing instance owned by the Amazon Web Services account. This parameter isn't case-sensitive.
        public let dbInstanceIdentifier: String?
        /// A filter that specifies one or more database tenants to describe. Supported filters:    tenant-db-name - Tenant database names. The results list only includes information about the tenant databases that match these tenant DB names.    tenant-database-resource-id - Tenant database resource identifiers.    dbi-resource-id - DB instance resource identifiers. The results list only includes information about the tenants contained within the DB instances identified by these resource identifiers.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// An optional pagination token provided by a previous DescribeTenantDatabases request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The user-supplied tenant database name, which must match the name of an existing tenant database on the specified DB instance owned by your Amazon Web Services account. This parameter isn’t case-sensitive.
        public let tenantDBName: String?

        public init(dbInstanceIdentifier: String? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, tenantDBName: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct DescribeValidDBInstanceModificationsMessage: AWSEncodableShape {
        /// The customer identifier or the ARN of your DB instance.
        public let dbInstanceIdentifier: String?

        public init(dbInstanceIdentifier: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
        }
    }

    public struct DescribeValidDBInstanceModificationsResult: AWSDecodableShape {
        public let validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage?

        public init(validDBInstanceModificationsMessage: ValidDBInstanceModificationsMessage? = nil) {
            self.validDBInstanceModificationsMessage = validDBInstanceModificationsMessage
        }

        private enum CodingKeys: String, CodingKey {
            case validDBInstanceModificationsMessage = "ValidDBInstanceModificationsMessage"
        }
    }

    public struct DisableHttpEndpointRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the DB cluster.
        public let resourceArn: String?

        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct DisableHttpEndpointResponse: AWSDecodableShape {
        /// Indicates whether the HTTP endpoint is enabled or disabled for the DB cluster.
        public let httpEndpointEnabled: Bool?
        /// The ARN of the DB cluster.
        public let resourceArn: String?

        public init(httpEndpointEnabled: Bool? = nil, resourceArn: String? = nil) {
            self.httpEndpointEnabled = httpEndpointEnabled
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpointEnabled = "HttpEndpointEnabled"
            case resourceArn = "ResourceArn"
        }
    }

    public struct DocLink: AWSDecodableShape {
        /// The text with the link to documentation for the recommendation.
        public let text: String?
        /// The URL for the documentation for the recommendation.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case url = "Url"
        }
    }

    public struct DomainMembership: AWSDecodableShape {
        /// The ARN for the Secrets Manager secret with the credentials for the user that's a member of the domain.
        public let authSecretArn: String?
        /// The IPv4 DNS IP addresses of the primary and secondary Active Directory domain controllers.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var dnsIps: [String]?
        /// The identifier of the Active Directory Domain.
        public let domain: String?
        /// The fully qualified domain name (FQDN) of the Active Directory Domain.
        public let fqdn: String?
        /// The name of the IAM role used when making API calls to the Directory Service.
        public let iamRoleName: String?
        /// The Active Directory organizational unit for the DB instance or cluster.
        public let ou: String?
        /// The status of the Active Directory Domain membership for the DB instance or cluster. Values include joined, pending-join, failed, and so on.
        public let status: String?

        public init(authSecretArn: String? = nil, dnsIps: [String]? = nil, domain: String? = nil, fqdn: String? = nil, iamRoleName: String? = nil, ou: String? = nil, status: String? = nil) {
            self.authSecretArn = authSecretArn
            self.dnsIps = dnsIps
            self.domain = domain
            self.fqdn = fqdn
            self.iamRoleName = iamRoleName
            self.ou = ou
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case authSecretArn = "AuthSecretArn"
            case dnsIps = "DnsIps"
            case domain = "Domain"
            case fqdn = "FQDN"
            case iamRoleName = "IAMRoleName"
            case ou = "OU"
            case status = "Status"
        }
    }

    public struct DoubleRange: AWSDecodableShape {
        /// The minimum value in the range.
        public let from: Double?
        /// The maximum value in the range.
        public let to: Double?

        public init(from: Double? = nil, to: Double? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct DownloadDBLogFilePortionDetails: AWSDecodableShape {
        /// A Boolean value that, if true, indicates there is more data to be downloaded.
        public let additionalDataPending: Bool?
        /// Entries from the specified log file.
        public let logFileData: String?
        /// A pagination token that can be used in a later DownloadDBLogFilePortion request.
        public let marker: String?

        public init(additionalDataPending: Bool? = nil, logFileData: String? = nil, marker: String? = nil) {
            self.additionalDataPending = additionalDataPending
            self.logFileData = logFileData
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDataPending = "AdditionalDataPending"
            case logFileData = "LogFileData"
            case marker = "Marker"
        }
    }

    public struct DownloadDBLogFilePortionMessage: AWSEncodableShape {
        /// The customer-assigned name of the DB instance that contains the log files you want to list. Constraints:   Must match the identifier of an existing DBInstance.
        public let dbInstanceIdentifier: String?
        /// The name of the log file to be downloaded.
        public let logFileName: String?
        /// The pagination token provided in the previous request or "0". If the Marker parameter is specified the response includes only records beyond the marker until the end of the file or up to NumberOfLines.
        public let marker: String?
        /// The number of lines to download. If the number of lines specified results in a file over 1 MB in size, the file is truncated at 1 MB in size. If the NumberOfLines parameter is specified, then the block of lines returned can be from the beginning  or the end of the log file, depending on the value of the Marker parameter.   If neither Marker or NumberOfLines are specified, the entire log file is returned up to a  maximum of 10000 lines, starting with the most recent log entries first.   If  NumberOfLines is specified and Marker isn't specified, then the most recent lines from the end  of the log file are returned.   If Marker is specified as "0", then the specified  number of lines from the beginning of the log file are returned.   You can  download the log file in blocks of lines by specifying the size of the block using  the NumberOfLines parameter, and by specifying a value of "0" for the Marker parameter in your  first request. Include the Marker value returned in the response as the Marker value for the next  request, continuing until the AdditionalDataPending response element returns false.
        public let numberOfLines: Int?

        public init(dbInstanceIdentifier: String? = nil, logFileName: String? = nil, marker: String? = nil, numberOfLines: Int? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.logFileName = logFileName
            self.marker = marker
            self.numberOfLines = numberOfLines
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case logFileName = "LogFileName"
            case marker = "Marker"
            case numberOfLines = "NumberOfLines"
        }
    }

    public struct EC2SecurityGroup: AWSDecodableShape {
        /// Specifies the id of the EC2 security group.
        public let ec2SecurityGroupId: String?
        /// Specifies the name of the EC2 security group.
        public let ec2SecurityGroupName: String?
        /// Specifies the Amazon Web Services ID of the owner of the EC2 security group specified in the EC2SecurityGroupName field.
        public let ec2SecurityGroupOwnerId: String?
        /// Provides the status of the EC2 security group. Status can be "authorizing", "authorized", "revoking", and "revoked".
        public let status: String?

        public init(ec2SecurityGroupId: String? = nil, ec2SecurityGroupName: String? = nil, ec2SecurityGroupOwnerId: String? = nil, status: String? = nil) {
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case ec2SecurityGroupId = "EC2SecurityGroupId"
            case ec2SecurityGroupName = "EC2SecurityGroupName"
            case ec2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
            case status = "Status"
        }
    }

    public struct EnableHttpEndpointRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the DB cluster.
        public let resourceArn: String?

        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct EnableHttpEndpointResponse: AWSDecodableShape {
        /// Indicates whether the HTTP endpoint is enabled or disabled for the DB cluster.
        public let httpEndpointEnabled: Bool?
        /// The ARN of the DB cluster.
        public let resourceArn: String?

        public init(httpEndpointEnabled: Bool? = nil, resourceArn: String? = nil) {
            self.httpEndpointEnabled = httpEndpointEnabled
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpointEnabled = "HttpEndpointEnabled"
            case resourceArn = "ResourceArn"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// Specifies the DNS address of the DB instance.
        public let address: String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Specifies the port that the database engine is listening on.
        public let port: Int?

        public init(address: String? = nil, hostedZoneId: String? = nil, port: Int? = nil) {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case hostedZoneId = "HostedZoneId"
            case port = "Port"
        }
    }

    public struct EngineDefaults: AWSDecodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// Specifies the name of the DB parameter group family that the engine default parameters apply to.
        public let dbParameterGroupFamily: String?
        /// An optional pagination token provided by a previous EngineDefaults request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords .
        public let marker: String?
        /// Contains a list of engine default parameters.
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?

        public init(dbParameterGroupFamily: String? = nil, marker: String? = nil, parameters: [Parameter]? = nil) {
            self.dbParameterGroupFamily = dbParameterGroupFamily
            self.marker = marker
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupFamily = "DBParameterGroupFamily"
            case marker = "Marker"
            case parameters = "Parameters"
        }
    }

    public struct Event: AWSDecodableShape {
        public struct _EventCategoriesEncoding: ArrayCoderProperties { public static let member = "EventCategory" }

        /// Specifies the date and time of the event.
        public let date: Date?
        /// Specifies the category for the event.
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesEncoding, String>>
        public var eventCategories: [String]?
        /// Provides the text of this event.
        public let message: String?
        /// The Amazon Resource Name (ARN) for the event.
        public let sourceArn: String?
        /// Provides the identifier for the source of the event.
        public let sourceIdentifier: String?
        /// Specifies the source type for this event.
        public let sourceType: SourceType?

        public init(date: Date? = nil, eventCategories: [String]? = nil, message: String? = nil, sourceArn: String? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil) {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceArn = sourceArn
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case eventCategories = "EventCategories"
            case message = "Message"
            case sourceArn = "SourceArn"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
        }
    }

    public struct EventCategoriesMap: AWSDecodableShape {
        public struct _EventCategoriesEncoding: ArrayCoderProperties { public static let member = "EventCategory" }

        /// The event categories for the specified source type
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesEncoding, String>>
        public var eventCategories: [String]?
        /// The source type that the returned categories belong to
        public let sourceType: String?

        public init(eventCategories: [String]? = nil, sourceType: String? = nil) {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategories = "EventCategories"
            case sourceType = "SourceType"
        }
    }

    public struct EventCategoriesMessage: AWSDecodableShape {
        public struct _EventCategoriesMapListEncoding: ArrayCoderProperties { public static let member = "EventCategoriesMap" }

        /// A list of EventCategoriesMap data types.
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesMapListEncoding, EventCategoriesMap>>
        public var eventCategoriesMapList: [EventCategoriesMap]?

        public init(eventCategoriesMapList: [EventCategoriesMap]? = nil) {
            self.eventCategoriesMapList = eventCategoriesMapList
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategoriesMapList = "EventCategoriesMapList"
        }
    }

    public struct EventSubscription: AWSDecodableShape {
        public struct _EventCategoriesListEncoding: ArrayCoderProperties { public static let member = "EventCategory" }
        public struct _SourceIdsListEncoding: ArrayCoderProperties { public static let member = "SourceId" }

        /// The Amazon Web Services customer account associated with the RDS event notification subscription.
        public let customerAwsId: String?
        /// The RDS event notification subscription Id.
        public let custSubscriptionId: String?
        /// Specifies whether the subscription is enabled. True indicates the subscription is enabled.
        public let enabled: Bool?
        /// A list of event categories for the RDS event notification subscription.
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesListEncoding, String>>
        public var eventCategoriesList: [String]?
        /// The Amazon Resource Name (ARN) for the event subscription.
        public let eventSubscriptionArn: String?
        /// The topic ARN of the RDS event notification subscription.
        public let snsTopicArn: String?
        /// A list of source IDs for the RDS event notification subscription.
        @OptionalCustomCoding<ArrayCoder<_SourceIdsListEncoding, String>>
        public var sourceIdsList: [String]?
        /// The source type for the RDS event notification subscription.
        public let sourceType: String?
        /// The status of the RDS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that RDS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public let status: String?
        /// The time the RDS event notification subscription was created.
        public let subscriptionCreationTime: String?

        public init(customerAwsId: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, eventCategoriesList: [String]? = nil, eventSubscriptionArn: String? = nil, snsTopicArn: String? = nil, sourceIdsList: [String]? = nil, sourceType: String? = nil, status: String? = nil, subscriptionCreationTime: String? = nil) {
            self.customerAwsId = customerAwsId
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        private enum CodingKeys: String, CodingKey {
            case customerAwsId = "CustomerAwsId"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case eventCategoriesList = "EventCategoriesList"
            case eventSubscriptionArn = "EventSubscriptionArn"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case status = "Status"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct EventSubscriptionsMessage: AWSDecodableShape {
        public struct _EventSubscriptionsListEncoding: ArrayCoderProperties { public static let member = "EventSubscription" }

        /// A list of EventSubscriptions data types.
        @OptionalCustomCoding<ArrayCoder<_EventSubscriptionsListEncoding, EventSubscription>>
        public var eventSubscriptionsList: [EventSubscription]?
        /// An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(eventSubscriptionsList: [EventSubscription]? = nil, marker: String? = nil) {
            self.eventSubscriptionsList = eventSubscriptionsList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscriptionsList = "EventSubscriptionsList"
            case marker = "Marker"
        }
    }

    public struct EventsMessage: AWSDecodableShape {
        public struct _EventsEncoding: ArrayCoderProperties { public static let member = "Event" }

        /// A list of Event instances.
        @OptionalCustomCoding<ArrayCoder<_EventsEncoding, Event>>
        public var events: [Event]?
        /// An optional pagination token provided by a previous  Events request. If this parameter is specified, the response includes only records beyond the marker,  up to the value specified by MaxRecords.
        public let marker: String?

        public init(events: [Event]? = nil, marker: String? = nil) {
            self.events = events
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case marker = "Marker"
        }
    }

    public struct ExportTask: AWSDecodableShape {
        /// The data exported from the snapshot or cluster. Valid Values:    database - Export all the data from a specified database.    database.table table-name -  Export a table of the snapshot or cluster. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.    database.schema schema-name - Export a database schema of the snapshot or cluster.  This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.    database.schema.table table-name - Export a table of the database schema.  This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var exportOnly: [String]?
        /// A unique identifier for the snapshot or cluster export task. This ID isn't an identifier for the Amazon S3 bucket where the data is exported.
        public let exportTaskIdentifier: String?
        /// The reason the export failed, if it failed.
        public let failureCause: String?
        /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot or cluster.
        public let iamRoleArn: String?
        /// The key identifier of the Amazon Web Services KMS key that is used to encrypt the data when it's exported to Amazon S3.  The KMS key identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the export must have encryption and decryption permissions to use this KMS key.
        public let kmsKeyId: String?
        /// The progress of the snapshot or cluster export task as a percentage.
        public let percentProgress: Int?
        /// The Amazon S3 bucket where the snapshot or cluster is exported to.
        public let s3Bucket: String?
        /// The Amazon S3 bucket prefix that is the file name and path of the exported data.
        public let s3Prefix: String?
        /// The time when the snapshot was created.
        public let snapshotTime: Date?
        /// The Amazon Resource Name (ARN) of the snapshot or cluster exported to Amazon S3.
        public let sourceArn: String?
        /// The type of source for the export.
        public let sourceType: ExportSourceType?
        /// The progress status of the export task. The status can be one of the following:    CANCELED     CANCELING     COMPLETE     FAILED     IN_PROGRESS     STARTING
        public let status: String?
        /// The time when the snapshot or cluster export task ended.
        public let taskEndTime: Date?
        /// The time when the snapshot or cluster export task started.
        public let taskStartTime: Date?
        /// The total amount of data exported, in gigabytes.
        public let totalExtractedDataInGB: Int?
        /// A warning about the snapshot or cluster export task.
        public let warningMessage: String?

        public init(exportOnly: [String]? = nil, exportTaskIdentifier: String? = nil, failureCause: String? = nil, iamRoleArn: String? = nil, kmsKeyId: String? = nil, percentProgress: Int? = nil, s3Bucket: String? = nil, s3Prefix: String? = nil, snapshotTime: Date? = nil, sourceArn: String? = nil, sourceType: ExportSourceType? = nil, status: String? = nil, taskEndTime: Date? = nil, taskStartTime: Date? = nil, totalExtractedDataInGB: Int? = nil, warningMessage: String? = nil) {
            self.exportOnly = exportOnly
            self.exportTaskIdentifier = exportTaskIdentifier
            self.failureCause = failureCause
            self.iamRoleArn = iamRoleArn
            self.kmsKeyId = kmsKeyId
            self.percentProgress = percentProgress
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.snapshotTime = snapshotTime
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.taskEndTime = taskEndTime
            self.taskStartTime = taskStartTime
            self.totalExtractedDataInGB = totalExtractedDataInGB
            self.warningMessage = warningMessage
        }

        private enum CodingKeys: String, CodingKey {
            case exportOnly = "ExportOnly"
            case exportTaskIdentifier = "ExportTaskIdentifier"
            case failureCause = "FailureCause"
            case iamRoleArn = "IamRoleArn"
            case kmsKeyId = "KmsKeyId"
            case percentProgress = "PercentProgress"
            case s3Bucket = "S3Bucket"
            case s3Prefix = "S3Prefix"
            case snapshotTime = "SnapshotTime"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
            case status = "Status"
            case taskEndTime = "TaskEndTime"
            case taskStartTime = "TaskStartTime"
            case totalExtractedDataInGB = "TotalExtractedDataInGB"
            case warningMessage = "WarningMessage"
        }
    }

    public struct ExportTasksMessage: AWSDecodableShape {
        public struct _ExportTasksEncoding: ArrayCoderProperties { public static let member = "ExportTask" }

        /// Information about an export of a snapshot or cluster to Amazon S3.
        @OptionalCustomCoding<ArrayCoder<_ExportTasksEncoding, ExportTask>>
        public var exportTasks: [ExportTask]?
        /// A pagination token that can be used in a later DescribeExportTasks request. A marker is used for pagination to identify the location to begin output for the next response of DescribeExportTasks.
        public let marker: String?

        public init(exportTasks: [ExportTask]? = nil, marker: String? = nil) {
            self.exportTasks = exportTasks
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case exportTasks = "ExportTasks"
            case marker = "Marker"
        }
    }

    public struct FailoverDBClusterMessage: AWSEncodableShape {
        /// The identifier of the DB cluster to force a failover for. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing DB cluster.
        public let dbClusterIdentifier: String?
        /// The name of the DB instance to promote to the primary DB instance. Specify the DB instance identifier for an Aurora Replica or a Multi-AZ readable standby in the DB cluster, for example mydbcluster-replica1. This setting isn't supported for RDS for MySQL Multi-AZ DB clusters.
        public let targetDBInstanceIdentifier: String?

        public init(dbClusterIdentifier: String? = nil, targetDBInstanceIdentifier: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case targetDBInstanceIdentifier = "TargetDBInstanceIdentifier"
        }
    }

    public struct FailoverDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct FailoverGlobalClusterMessage: AWSEncodableShape {
        /// Specifies whether to allow data loss for this global database cluster operation. Allowing data loss triggers a global failover operation. If you don't specify AllowDataLoss, the global database cluster operation defaults to a switchover. Constraints:   Can't be specified together with the Switchover parameter.
        public let allowDataLoss: Bool?
        /// The identifier of the global database cluster (Aurora global database) this operation should apply to.  The identifier is the unique key assigned by the user when the Aurora global database is created. In other words, it's the name of the Aurora global database. Constraints:   Must match the identifier of an existing global database cluster.
        public let globalClusterIdentifier: String?
        /// Specifies whether to switch over this global database cluster. Constraints:   Can't be specified together with the AllowDataLoss parameter.
        public let switchover: Bool?
        /// The identifier of the secondary Aurora DB cluster that you want to promote to the primary for the global database cluster. Use the Amazon Resource Name (ARN) for the identifier so that Aurora can locate the cluster in its Amazon Web Services Region.
        public let targetDbClusterIdentifier: String?

        public init(allowDataLoss: Bool? = nil, globalClusterIdentifier: String? = nil, switchover: Bool? = nil, targetDbClusterIdentifier: String? = nil) {
            self.allowDataLoss = allowDataLoss
            self.globalClusterIdentifier = globalClusterIdentifier
            self.switchover = switchover
            self.targetDbClusterIdentifier = targetDbClusterIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, max: 255)
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, min: 1)
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
            try self.validate(self.targetDbClusterIdentifier, name: "targetDbClusterIdentifier", parent: name, max: 255)
            try self.validate(self.targetDbClusterIdentifier, name: "targetDbClusterIdentifier", parent: name, min: 1)
            try self.validate(self.targetDbClusterIdentifier, name: "targetDbClusterIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowDataLoss = "AllowDataLoss"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case switchover = "Switchover"
            case targetDbClusterIdentifier = "TargetDbClusterIdentifier"
        }
    }

    public struct FailoverGlobalClusterResult: AWSDecodableShape {
        public let globalCluster: GlobalCluster?

        public init(globalCluster: GlobalCluster? = nil) {
            self.globalCluster = globalCluster
        }

        private enum CodingKeys: String, CodingKey {
            case globalCluster = "GlobalCluster"
        }
    }

    public struct FailoverState: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being demoted, and which is associated with this state.
        public let fromDbClusterArn: String?
        /// Indicates whether the operation is a global switchover or a global failover. If data loss is allowed, then the operation is a global failover.  Otherwise, it's a switchover.
        public let isDataLossAllowed: Bool?
        /// The current status of the global cluster. Possible values are as follows:   pending  The service received a request to switch over or fail over the global cluster. The global cluster's primary DB cluster and the specified secondary DB cluster are being verified before the operation starts.   failing-over  Aurora is promoting the chosen secondary Aurora DB cluster to become the new primary DB cluster to fail over the global cluster.   cancelling  The request to switch over or fail over the global cluster was cancelled and the primary Aurora DB cluster and the selected secondary Aurora DB cluster are returning to their previous states.   switching-over  This status covers the range of Aurora internal operations that take place during the switchover process, such as demoting the primary Aurora DB cluster, promoting the secondary Aurora DB cluster, and synchronizing replicas.
        public let status: FailoverStatus?
        /// The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being promoted, and which is associated with this state.
        public let toDbClusterArn: String?

        public init(fromDbClusterArn: String? = nil, isDataLossAllowed: Bool? = nil, status: FailoverStatus? = nil, toDbClusterArn: String? = nil) {
            self.fromDbClusterArn = fromDbClusterArn
            self.isDataLossAllowed = isDataLossAllowed
            self.status = status
            self.toDbClusterArn = toDbClusterArn
        }

        private enum CodingKeys: String, CodingKey {
            case fromDbClusterArn = "FromDbClusterArn"
            case isDataLossAllowed = "IsDataLossAllowed"
            case status = "Status"
            case toDbClusterArn = "ToDbClusterArn"
        }
    }

    public struct Filter: AWSEncodableShape {
        public struct _ValuesEncoding: ArrayCoderProperties { public static let member = "Value" }

        /// The name of the filter. Filter names are case-sensitive.
        public let name: String?
        /// One or more filter values. Filter values are case-sensitive.
        @OptionalCustomCoding<ArrayCoder<_ValuesEncoding, String>>
        public var values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct GlobalCluster: AWSDecodableShape {
        public struct _GlobalClusterMembersEncoding: ArrayCoderProperties { public static let member = "GlobalClusterMember" }

        /// The default database name within the new global database cluster.
        public let databaseName: String?
        /// The deletion protection setting for the new global database cluster.
        public let deletionProtection: Bool?
        /// The Aurora database engine used by the global database cluster.
        public let engine: String?
        /// Indicates the database engine version.
        public let engineVersion: String?
        /// A data object containing all properties for the current state of an in-process or pending switchover or failover process for this global cluster (Aurora global database). This object is empty unless the SwitchoverGlobalCluster or FailoverGlobalCluster operation was called on this global cluster.
        public let failoverState: FailoverState?
        /// The Amazon Resource Name (ARN) for the global database cluster.
        public let globalClusterArn: String?
        /// Contains a user-supplied global database cluster identifier. This identifier is the unique key that identifies a global database cluster.
        public let globalClusterIdentifier: String?
        /// The list of primary and secondary clusters within the global database cluster.
        @OptionalCustomCoding<ArrayCoder<_GlobalClusterMembersEncoding, GlobalClusterMember>>
        public var globalClusterMembers: [GlobalClusterMember]?
        /// The Amazon Web Services Region-unique, immutable identifier for the global database cluster. This identifier is found in Amazon Web Services CloudTrail log entries whenever the Amazon Web Services KMS key for the DB cluster is accessed.
        public let globalClusterResourceId: String?
        /// Specifies the current state of this global database cluster.
        public let status: String?
        /// The storage encryption setting for the global database cluster.
        public let storageEncrypted: Bool?

        public init(databaseName: String? = nil, deletionProtection: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, failoverState: FailoverState? = nil, globalClusterArn: String? = nil, globalClusterIdentifier: String? = nil, globalClusterMembers: [GlobalClusterMember]? = nil, globalClusterResourceId: String? = nil, status: String? = nil, storageEncrypted: Bool? = nil) {
            self.databaseName = databaseName
            self.deletionProtection = deletionProtection
            self.engine = engine
            self.engineVersion = engineVersion
            self.failoverState = failoverState
            self.globalClusterArn = globalClusterArn
            self.globalClusterIdentifier = globalClusterIdentifier
            self.globalClusterMembers = globalClusterMembers
            self.globalClusterResourceId = globalClusterResourceId
            self.status = status
            self.storageEncrypted = storageEncrypted
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case deletionProtection = "DeletionProtection"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case failoverState = "FailoverState"
            case globalClusterArn = "GlobalClusterArn"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case globalClusterMembers = "GlobalClusterMembers"
            case globalClusterResourceId = "GlobalClusterResourceId"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
        }
    }

    public struct GlobalClusterMember: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for each Aurora DB cluster in the global cluster.
        public let dbClusterArn: String?
        /// The status of write forwarding for a secondary cluster in the global cluster.
        public let globalWriteForwardingStatus: WriteForwardingStatus?
        /// Indicates whether the Aurora DB cluster is the primary cluster (that is, has read-write capability) for the global cluster with which it is associated.
        public let isWriter: Bool?
        /// The Amazon Resource Name (ARN) for each read-only secondary cluster associated with the global cluster.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var readers: [String]?
        /// The status of synchronization of each Aurora DB cluster in the global cluster.
        public let synchronizationStatus: GlobalClusterMemberSynchronizationStatus?

        public init(dbClusterArn: String? = nil, globalWriteForwardingStatus: WriteForwardingStatus? = nil, isWriter: Bool? = nil, readers: [String]? = nil, synchronizationStatus: GlobalClusterMemberSynchronizationStatus? = nil) {
            self.dbClusterArn = dbClusterArn
            self.globalWriteForwardingStatus = globalWriteForwardingStatus
            self.isWriter = isWriter
            self.readers = readers
            self.synchronizationStatus = synchronizationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterArn = "DBClusterArn"
            case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
            case isWriter = "IsWriter"
            case readers = "Readers"
            case synchronizationStatus = "SynchronizationStatus"
        }
    }

    public struct GlobalClustersMessage: AWSDecodableShape {
        public struct _GlobalClustersEncoding: ArrayCoderProperties { public static let member = "GlobalClusterMember" }

        /// The list of global clusters returned by this request.
        @OptionalCustomCoding<ArrayCoder<_GlobalClustersEncoding, GlobalCluster>>
        public var globalClusters: [GlobalCluster]?
        /// An optional pagination token provided by a previous DescribeGlobalClusters request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(globalClusters: [GlobalCluster]? = nil, marker: String? = nil) {
            self.globalClusters = globalClusters
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case globalClusters = "GlobalClusters"
            case marker = "Marker"
        }
    }

    public struct IPRange: AWSDecodableShape {
        /// The IP range.
        public let cidrip: String?
        /// The status of the IP range. Status can be "authorizing", "authorized", "revoking", and "revoked".
        public let status: String?

        public init(cidrip: String? = nil, status: String? = nil) {
            self.cidrip = cidrip
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case cidrip = "CIDRIP"
            case status = "Status"
        }
    }

    public struct Integration: AWSDecodableShape {
        public struct _ErrorsEncoding: ArrayCoderProperties { public static let member = "IntegrationError" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The encryption context for the integration. For more information, see Encryption context in the Amazon Web Services Key Management Service Developer Guide.
        @OptionalCustomCoding<StandardDictionaryCoder<String, String>>
        public var additionalEncryptionContext: [String: String]?
        /// The time when the integration was created, in Universal Coordinated Time (UTC).
        public let createTime: Date?
        /// Data filters for the integration. These filters determine which tables from the source database are sent to the target Amazon Redshift data warehouse.
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// Any errors associated with the integration.
        @OptionalCustomCoding<ArrayCoder<_ErrorsEncoding, IntegrationError>>
        public var errors: [IntegrationError]?
        /// The ARN of the integration.
        public let integrationArn: String?
        /// The name of the integration.
        public let integrationName: String?
        /// The Amazon Web Services Key Management System (Amazon Web Services KMS) key identifier for the key used to to encrypt the integration.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the database used as the source for replication.
        public let sourceArn: String?
        /// The current status of the integration.
        public let status: IntegrationStatus?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The ARN of the Redshift data warehouse used as the target for replication.
        public let targetArn: String?

        public init(additionalEncryptionContext: [String: String]? = nil, createTime: Date? = nil, dataFilter: String? = nil, description: String? = nil, errors: [IntegrationError]? = nil, integrationArn: String? = nil, integrationName: String? = nil, kmsKeyId: String? = nil, sourceArn: String? = nil, status: IntegrationStatus? = nil, tags: [Tag]? = nil, targetArn: String? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.createTime = createTime
            self.dataFilter = dataFilter
            self.description = description
            self.errors = errors
            self.integrationArn = integrationArn
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.status = status
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case createTime = "CreateTime"
            case dataFilter = "DataFilter"
            case description = "Description"
            case errors = "Errors"
            case integrationArn = "IntegrationArn"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KMSKeyId"
            case sourceArn = "SourceArn"
            case status = "Status"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct IntegrationError: AWSDecodableShape {
        /// The error code associated with the integration.
        public let errorCode: String?
        /// A message explaining the error.
        public let errorMessage: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct IssueDetails: AWSDecodableShape {
        /// A detailed description of the issue when the recommendation category is performance.
        public let performanceIssueDetails: PerformanceIssueDetails?

        public init(performanceIssueDetails: PerformanceIssueDetails? = nil) {
            self.performanceIssueDetails = performanceIssueDetails
        }

        private enum CodingKeys: String, CodingKey {
            case performanceIssueDetails = "PerformanceIssueDetails"
        }
    }

    public struct LimitlessDatabase: AWSDecodableShape {
        /// The minimum required capacity for Aurora Limitless Database in Aurora capacity units (ACUs).
        public let minRequiredACU: Double?
        /// The status of Aurora Limitless Database.
        public let status: LimitlessDatabaseStatus?

        public init(minRequiredACU: Double? = nil, status: LimitlessDatabaseStatus? = nil) {
            self.minRequiredACU = minRequiredACU
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case minRequiredACU = "MinRequiredACU"
            case status = "Status"
        }
    }

    public struct ListTagsForResourceMessage: AWSEncodableShape {
        public struct _FiltersEncoding: ArrayCoderProperties { public static let member = "Filter" }

        /// This parameter isn't currently supported.
        @OptionalCustomCoding<ArrayCoder<_FiltersEncoding, Filter>>
        public var filters: [Filter]?
        /// The Amazon RDS resource with tags to be listed. This value is an Amazon Resource Name (ARN). For information about  creating an ARN,  see  Constructing an ARN for Amazon RDS in the Amazon RDS User Guide.
        public let resourceName: String?

        public init(filters: [Filter]? = nil, resourceName: String? = nil) {
            self.filters = filters
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case resourceName = "ResourceName"
        }
    }

    public struct MasterUserSecret: AWSDecodableShape {
        /// The Amazon Web Services KMS key identifier that is used to encrypt the secret.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the secret.
        public let secretArn: String?
        /// The status of the secret. The possible status values include the following:    creating - The secret is being created.    active - The secret is available for normal use and rotation.    rotating - The secret is being rotated.    impaired - The secret can be used to access database credentials, but it can't be rotated. A secret might have this status if, for example, permissions are changed so that RDS can no longer access either the secret or the KMS key for the secret. When a secret has this status, you can correct the condition that caused the status. Alternatively, modify the DB instance to turn off automatic management of database credentials, and then modify the DB instance again to turn on automatic management of database credentials.
        public let secretStatus: String?

        public init(kmsKeyId: String? = nil, secretArn: String? = nil, secretStatus: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.secretArn = secretArn
            self.secretStatus = secretStatus
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case secretArn = "SecretArn"
            case secretStatus = "SecretStatus"
        }
    }

    public struct Metric: AWSDecodableShape {
        /// The query to retrieve metric data points.
        public let metricQuery: MetricQuery?
        /// The name of a metric.
        public let name: String?
        /// A list of metric references (thresholds).
        @OptionalCustomCoding<StandardArrayCoder<MetricReference>>
        public var references: [MetricReference]?
        /// The details of different statistics for a metric. The description might contain markdown.
        public let statisticsDetails: String?

        public init(metricQuery: MetricQuery? = nil, name: String? = nil, references: [MetricReference]? = nil, statisticsDetails: String? = nil) {
            self.metricQuery = metricQuery
            self.name = name
            self.references = references
            self.statisticsDetails = statisticsDetails
        }

        private enum CodingKeys: String, CodingKey {
            case metricQuery = "MetricQuery"
            case name = "Name"
            case references = "References"
            case statisticsDetails = "StatisticsDetails"
        }
    }

    public struct MetricQuery: AWSDecodableShape {
        /// The Performance Insights query that you can use to retrieve Performance Insights metric data points.
        public let performanceInsightsMetricQuery: PerformanceInsightsMetricQuery?

        public init(performanceInsightsMetricQuery: PerformanceInsightsMetricQuery? = nil) {
            self.performanceInsightsMetricQuery = performanceInsightsMetricQuery
        }

        private enum CodingKeys: String, CodingKey {
            case performanceInsightsMetricQuery = "PerformanceInsightsMetricQuery"
        }
    }

    public struct MetricReference: AWSDecodableShape {
        /// The name of the metric reference.
        public let name: String?
        /// The details of a performance issue.
        public let referenceDetails: ReferenceDetails?

        public init(name: String? = nil, referenceDetails: ReferenceDetails? = nil) {
            self.name = name
            self.referenceDetails = referenceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case referenceDetails = "ReferenceDetails"
        }
    }

    public struct MinimumEngineVersionPerAllowedValue: AWSDecodableShape {
        /// The allowed value for an option setting.
        public let allowedValue: String?
        /// The minimum DB engine version required for the allowed value.
        public let minimumEngineVersion: String?

        public init(allowedValue: String? = nil, minimumEngineVersion: String? = nil) {
            self.allowedValue = allowedValue
            self.minimumEngineVersion = minimumEngineVersion
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValue = "AllowedValue"
            case minimumEngineVersion = "MinimumEngineVersion"
        }
    }

    public struct ModifyActivityStreamRequest: AWSEncodableShape {
        /// The audit policy state. When a policy is unlocked, it is read/write. When it is locked, it is read-only. You can edit your audit policy only when the activity stream is unlocked or stopped.
        public let auditPolicyState: AuditPolicyState?
        /// The Amazon Resource Name (ARN) of the RDS for Oracle or Microsoft SQL Server DB instance. For example, arn:aws:rds:us-east-1:12345667890:instance:my-orcl-db.
        public let resourceArn: String?

        public init(auditPolicyState: AuditPolicyState? = nil, resourceArn: String? = nil) {
            self.auditPolicyState = auditPolicyState
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case auditPolicyState = "AuditPolicyState"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ModifyActivityStreamResponse: AWSDecodableShape {
        /// Indicates whether engine-native audit fields are included in the database activity stream.
        public let engineNativeAuditFieldsIncluded: Bool?
        /// The name of the Amazon Kinesis data stream to be used for the database activity stream.
        public let kinesisStreamName: String?
        /// The Amazon Web Services KMS key identifier for encryption of messages in the database activity stream.
        public let kmsKeyId: String?
        /// The mode of the database activity stream.
        public let mode: ActivityStreamMode?
        /// The status of the modification to the policy state of the database activity stream.
        public let policyStatus: ActivityStreamPolicyStatus?
        /// The status of the modification to the database activity stream.
        public let status: ActivityStreamStatus?

        public init(engineNativeAuditFieldsIncluded: Bool? = nil, kinesisStreamName: String? = nil, kmsKeyId: String? = nil, mode: ActivityStreamMode? = nil, policyStatus: ActivityStreamPolicyStatus? = nil, status: ActivityStreamStatus? = nil) {
            self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
            self.kinesisStreamName = kinesisStreamName
            self.kmsKeyId = kmsKeyId
            self.mode = mode
            self.policyStatus = policyStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case engineNativeAuditFieldsIncluded = "EngineNativeAuditFieldsIncluded"
            case kinesisStreamName = "KinesisStreamName"
            case kmsKeyId = "KmsKeyId"
            case mode = "Mode"
            case policyStatus = "PolicyStatus"
            case status = "Status"
        }
    }

    public struct ModifyCertificatesMessage: AWSEncodableShape {
        /// The new default certificate identifier to override the current one with. To determine the valid values, use the describe-certificates CLI command or the DescribeCertificates API operation.
        public let certificateIdentifier: String?
        /// Specifies whether to remove the override for the default certificate.  If the override is removed, the default certificate is the system default.
        public let removeCustomerOverride: Bool?

        public init(certificateIdentifier: String? = nil, removeCustomerOverride: Bool? = nil) {
            self.certificateIdentifier = certificateIdentifier
            self.removeCustomerOverride = removeCustomerOverride
        }

        private enum CodingKeys: String, CodingKey {
            case certificateIdentifier = "CertificateIdentifier"
            case removeCustomerOverride = "RemoveCustomerOverride"
        }
    }

    public struct ModifyCertificatesResult: AWSDecodableShape {
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct ModifyCurrentDBClusterCapacityMessage: AWSEncodableShape {
        /// The DB cluster capacity. When you change the capacity of a paused Aurora Serverless v1 DB cluster, it automatically resumes. Constraints:   For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.   For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
        public let capacity: Int?
        /// The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing DB cluster.
        public let dbClusterIdentifier: String?
        /// The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300. Specify a value between 10 and 600 seconds.
        public let secondsBeforeTimeout: Int?
        /// The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.  ForceApplyCapacityChange, the default, sets the capacity to the specified value as soon as possible.  RollbackCapacityChange ignores the capacity change if a scaling point isn't found in the timeout period.
        public let timeoutAction: String?

        public init(capacity: Int? = nil, dbClusterIdentifier: String? = nil, secondsBeforeTimeout: Int? = nil, timeoutAction: String? = nil) {
            self.capacity = capacity
            self.dbClusterIdentifier = dbClusterIdentifier
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.timeoutAction = timeoutAction
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "Capacity"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case secondsBeforeTimeout = "SecondsBeforeTimeout"
            case timeoutAction = "TimeoutAction"
        }
    }

    public struct ModifyCustomDBEngineVersionMessage: AWSEncodableShape {
        /// An optional description of your CEV.
        public let description: String?
        /// The DB engine. The only supported values are custom-oracle-ee and custom-oracle-ee-cdb.
        public let engine: String?
        /// The custom engine version (CEV) that you want to modify. This option is required for  RDS Custom for Oracle, but optional for Amazon RDS. The combination of Engine and  EngineVersion is unique per customer per Amazon Web Services Region.
        public let engineVersion: String?
        /// The availability status to be assigned to the CEV. Valid values are as follows:  available  You can use this CEV to create a new RDS Custom DB instance.  inactive  You can create a new RDS Custom instance by restoring a DB snapshot with this CEV.  You can't patch or create new instances with this CEV.   You can change any status to any status. A typical reason to change status is to prevent the accidental  use of a CEV, or to make a deprecated CEV eligible for use again. For example, you might change the status  of your CEV from available to inactive, and from inactive back to  available. To change the availability status of the CEV, it must not currently be in use by an  RDS Custom instance, snapshot, or automated backup.
        public let status: CustomEngineVersionStatus?

        public init(description: String? = nil, engine: String? = nil, engineVersion: String? = nil, status: CustomEngineVersionStatus? = nil) {
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.engine, name: "engine", parent: name, max: 35)
            try self.validate(self.engine, name: "engine", parent: name, min: 1)
            try self.validate(self.engine, name: "engine", parent: name, pattern: "^[A-Za-z0-9-]{1,35}$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 60)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 1)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^[a-z0-9_.-]{1,60}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case status = "Status"
        }
    }

    public struct ModifyDBClusterEndpointMessage: AWSEncodableShape {
        /// The identifier of the endpoint to modify. This parameter is stored as a lowercase string.
        public let dbClusterEndpointIdentifier: String?
        /// The type of the endpoint. One of: READER, WRITER, ANY.
        public let endpointType: String?
        /// List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var excludedMembers: [String]?
        /// List of DB instance identifiers that are part of the custom endpoint group.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var staticMembers: [String]?

        public init(dbClusterEndpointIdentifier: String? = nil, endpointType: String? = nil, excludedMembers: [String]? = nil, staticMembers: [String]? = nil) {
            self.dbClusterEndpointIdentifier = dbClusterEndpointIdentifier
            self.endpointType = endpointType
            self.excludedMembers = excludedMembers
            self.staticMembers = staticMembers
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
            case endpointType = "EndpointType"
            case excludedMembers = "ExcludedMembers"
            case staticMembers = "StaticMembers"
        }
    }

    public struct ModifyDBClusterMessage: AWSEncodableShape {
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster. Valid for Cluster Type: Multi-AZ DB clusters only
        public let allocatedStorage: Int?
        /// Specifies whether engine mode changes from serverless to provisioned  are allowed. Valid for Cluster Type: Aurora Serverless v1 DB clusters only Constraints:   You must allow engine mode changes when specifying a different value for the EngineMode parameter from the DB cluster's current engine mode.
        public let allowEngineModeChange: Bool?
        /// Specifies whether major version upgrades are allowed. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   You must allow major version upgrades when specifying a value for the EngineVersion parameter that is a different major version than the DB cluster's current version.
        public let allowMajorVersionUpgrade: Bool?
        /// Specifies whether the modifications in this request and any pending modifications are  asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting  for the DB cluster. If this parameter is disabled, changes to the DB cluster are applied during the next  maintenance window. Most modifications can be applied immediately or during the next scheduled maintenance window. Some  modifications, such as turning on deletion protection and changing the master password, are applied  immediately—regardless of when you choose to apply them. By default, this parameter is disabled. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let applyImmediately: Bool?
        /// Specifies whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window.  By default, minor engine upgrades are applied automatically. Valid for Cluster Type: Multi-AZ DB clusters only
        public let autoMinorVersionUpgrade: Bool?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public let awsBackupRecoveryPointArn: String?
        /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Valid for Cluster Type: Aurora MySQL DB clusters only Default: 0  Constraints:   If specified, this value must be set to a number from 0 to 259,200 (72 hours).
        public let backtrackWindow: Int64?
        /// The number of days for which automated backups are retained. Specify a minimum value of 1. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Default: 1  Constraints:   Must be a value from 1 to 35.
        public let backupRetentionPeriod: Int?
        /// The CA certificate identifier to use for the DB cluster's server certificate. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide. Valid for Cluster Type: Multi-AZ DB clusters
        public let caCertificateIdentifier: String?
        /// The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters The following values are valid for each DB engine:   Aurora MySQL - audit | error | general | slowquery    Aurora PostgreSQL - postgresql    RDS for MySQL - error | general | slowquery    RDS for PostgreSQL - postgresql | upgrade    For more information about exporting CloudWatch Logs for Amazon RDS, see  Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. For more information about exporting CloudWatch Logs for Amazon Aurora, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
        public let cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration?
        /// Specifies whether to copy all tags from the DB cluster to snapshots of the DB cluster.  The default is not to copy them. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let copyTagsToSnapshot: Bool?
        /// The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must match the identifier of an existing DB cluster.
        public let dbClusterIdentifier: String?
        /// The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see  DB Instance Class in the Amazon RDS User Guide. Valid for Cluster Type: Multi-AZ DB clusters only
        public let dbClusterInstanceClass: String?
        /// The name of the DB cluster parameter group to use for the DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let dbClusterParameterGroupName: String?
        /// The name of the DB parameter group to apply to all instances of the DB cluster.  When you apply a parameter group using the DBInstanceParameterGroupName parameter, the DB cluster isn't rebooted automatically. Also, parameter changes are applied immediately rather than  during the next maintenance window.  Valid for Cluster Type: Aurora DB clusters only Default: The existing name setting Constraints:   The DB parameter group must be in the same DB parameter group family as this DB cluster.   The DBInstanceParameterGroupName parameter is valid in combination with the AllowMajorVersionUpgrade parameter for a major version upgrade only.
        public let dbInstanceParameterGroupName: String?
        /// Specifies whether the DB cluster has deletion protection enabled.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to move the DB cluster to.   Specify none to remove the cluster from its current domain. The domain must be created prior to this operation. For more information, see Kerberos Authentication in the Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters only
        public let domain: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. Valid for Cluster Type: Aurora DB clusters only
        public let domainIAMRoleName: String?
        /// Specifies whether to enable this DB cluster to forward write operations to the primary cluster of a global cluster (Aurora global database). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database. You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter enabled, a secondary cluster can forward writes to the current primary cluster, and the resulting changes are replicated back to this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is demoted by a global cluster API operation, but it does nothing until then. Valid for Cluster Type: Aurora DB clusters only
        public let enableGlobalWriteForwarding: Bool?
        /// Specifies whether to enable the HTTP endpoint for an Aurora Serverless v1 DB cluster. By default, the HTTP endpoint  isn't enabled. When enabled, the HTTP endpoint provides a connectionless web service API (RDS Data API) for running SQL queries on the Aurora Serverless v1 DB cluster. You can also query your database from inside the RDS console with the RDS query editor. For more information, see Using RDS Data API in the  Amazon Aurora User Guide.  This parameter applies only to Aurora Serverless v1 DB clusters. To enable or disable the HTTP endpoint for an Aurora PostgreSQL  Serverless v2 or provisioned DB cluster, use the EnableHttpEndpoint and DisableHttpEndpoint operations.  Valid for Cluster Type: Aurora DB clusters only
        public let enableHttpEndpoint: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see   IAM Database Authentication in the Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters only
        public let enableIAMDatabaseAuthentication: Bool?
        /// Specifies whether to enable Aurora Limitless Database. You must enable Aurora Limitless Database to create a DB shard group. Valid for: Aurora DB clusters only
        public let enableLimitlessDatabase: Bool?
        /// Specifies whether read replicas can forward write operations to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances. Valid for: Aurora DB clusters only
        public let enableLocalWriteForwarding: Bool?
        /// Specifies whether to turn on Performance Insights for the DB cluster. For more information, see  Using Amazon Performance Insights in the Amazon RDS User Guide. Valid for Cluster Type: Multi-AZ DB clusters only
        public let enablePerformanceInsights: Bool?
        /// The DB engine mode of the DB cluster, either provisioned or serverless.  The DB engine mode can be modified only from serverless to provisioned.  For more information, see  CreateDBCluster. Valid for Cluster Type: Aurora DB clusters only
        public let engineMode: String?
        /// The version number of the database engine to which you want to upgrade. Changing this parameter results in an outage. The change is applied during the next maintenance window unless ApplyImmediately is enabled. If the cluster that you're modifying has one or more read replicas, all replicas must be running an engine version that's the same or later than the version you specify. To list all of the available engine versions for Aurora MySQL, use the following command:  aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for Aurora PostgreSQL, use the following command:  aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for RDS for MySQL, use the following command:  aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for RDS for PostgreSQL, use the following command:  aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"  Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let engineVersion: String?
        /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated  for each DB instance in the Multi-AZ DB cluster. For information about valid IOPS values, see  Amazon RDS Provisioned IOPS storage  in the Amazon RDS User Guide. Valid for Cluster Type: Multi-AZ DB clusters only Constraints:   Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
        public let iops: Int?
        /// Specifies whether to manage the master user password with Amazon Web Services Secrets Manager. If the DB cluster doesn't manage the master user password with Amazon Web Services Secrets Manager, you can turn  on this management. In this case, you can't specify MasterUserPassword. If the DB cluster already manages the master user password with Amazon Web Services Secrets Manager, and you specify that the  master user password is not managed with Amazon Web Services Secrets Manager, then you must specify MasterUserPassword.  In this case, RDS deletes the secret and uses the new password for the master user specified by  MasterUserPassword. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide and Password management with Amazon Web Services Secrets Manager  in the Amazon Aurora User Guide.  Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let manageMasterUserPassword: Bool?
        /// The new password for the master database user. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must contain from 8 to 41 characters.   Can contain any printable ASCII character except "/", """, or "@".   Can't be specified if ManageMasterUserPassword is turned on.
        public let masterUserPassword: String?
        /// The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and  managed in Amazon Web Services Secrets Manager. This setting is valid only if both of the following conditions are met:   The DB cluster doesn't manage the master user password in Amazon Web Services Secrets Manager. If the DB cluster already manages the master user password in Amazon Web Services Secrets Manager, you can't change the KMS key that is used to encrypt the secret.   You are turning on ManageMasterUserPassword to manage the master user password  in Amazon Web Services Secrets Manager. If you are turning on ManageMasterUserPassword and don't specify  MasterUserSecretKmsKeyId, then the aws/secretsmanager  KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't  use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer  managed KMS key.   The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        public let masterUserSecretKmsKeyId: String?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster.  To turn off collecting Enhanced Monitoring metrics, specify 0. If MonitoringRoleArn is specified, also set MonitoringInterval to a value other than 0. Valid for Cluster Type: Multi-AZ DB clusters only Valid Values: 0 | 1 | 5 | 10 | 15 | 30 | 60  Default: 0
        public let monitoringInterval: Int?
        /// The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. An example is arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see To  create an IAM role for Amazon RDS Enhanced Monitoring in the Amazon RDS User Guide.  If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn value. Valid for Cluster Type: Multi-AZ DB clusters only
        public let monitoringRoleArn: String?
        /// The network type of the DB cluster. The network type is determined by the DBSubnetGroup specified for the DB cluster.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon Aurora User Guide.  Valid for Cluster Type: Aurora DB clusters only Valid Values: IPV4 | DUAL
        public let networkType: String?
        /// The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is stored as a lowercase string. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   The first character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster2
        public let newDBClusterIdentifier: String?
        /// The option group to associate the DB cluster with. DB clusters are associated with a default option group that can't be modified.
        public let optionGroupName: String?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS  uses your default KMS key. There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. Valid for Cluster Type: Multi-AZ DB clusters only
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. Valid for Cluster Type: Multi-AZ DB clusters only Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days If you specify a retention period that isn't valid, such as 94,  Amazon RDS issues an error.
        public let performanceInsightsRetentionPeriod: Int?
        /// The port number on which the DB cluster accepts connections. Valid for Cluster Type: Aurora DB clusters only Valid Values: 1150-65535  Default: The same port as the original DB cluster.
        public let port: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region.  To view the time blocks available, see   Backup window in the Amazon Aurora User Guide. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see   Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide. Constraints:   Must be in the format ddd:hh24:mi-ddd:hh24:mi.   Days must be one of Mon | Tue | Wed | Thu | Fri | Sat | Sun.   Must be in Universal Coordinated Time (UTC).   Must be at least 30 minutes.
        public let preferredMaintenanceWindow: String?
        /// Specifies whether to rotate the secret managed by Amazon Web Services Secrets Manager for the  master user password. This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets  Manager for the DB cluster. The secret value contains the updated password. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide and Password management with Amazon Web Services Secrets Manager  in the Amazon Aurora User Guide.  Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Constraints:   You must apply the change immediately when rotating the master user password.
        public let rotateMasterUserPassword: Bool?
        /// The scaling properties of the DB cluster. You can only modify scaling properties for DB clusters in serverless DB engine mode. Valid for Cluster Type: Aurora DB clusters only
        public let scalingConfiguration: ScalingConfiguration?
        public let serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration?
        /// The storage type to associate with the DB cluster. For information on storage types for Aurora DB clusters, see Storage configurations for Amazon Aurora DB clusters. For information on storage types for Multi-AZ DB clusters, see Settings for creating Multi-AZ DB clusters. When specified for a Multi-AZ DB cluster, a value for the Iops parameter is required. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters Valid Values:   Aurora DB clusters - aurora | aurora-iopt1    Multi-AZ DB clusters - io1 | io2 | gp3    Default:   Aurora DB clusters - aurora    Multi-AZ DB clusters - io1
        public let storageType: String?
        /// A list of EC2 VPC security groups to associate with this DB cluster. Valid for Cluster Type: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, allowEngineModeChange: Bool? = nil, allowMajorVersionUpgrade: Bool? = nil, applyImmediately: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil, awsBackupRecoveryPointArn: String? = nil, backtrackWindow: Int64? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration? = nil, copyTagsToSnapshot: Bool? = nil, dbClusterIdentifier: String? = nil, dbClusterInstanceClass: String? = nil, dbClusterParameterGroupName: String? = nil, dbInstanceParameterGroupName: String? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainIAMRoleName: String? = nil, enableGlobalWriteForwarding: Bool? = nil, enableHttpEndpoint: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, enableLimitlessDatabase: Bool? = nil, enableLocalWriteForwarding: Bool? = nil, enablePerformanceInsights: Bool? = nil, engineMode: String? = nil, engineVersion: String? = nil, iops: Int? = nil, manageMasterUserPassword: Bool? = nil, masterUserPassword: String? = nil, masterUserSecretKmsKeyId: String? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, networkType: String? = nil, newDBClusterIdentifier: String? = nil, optionGroupName: String? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, rotateMasterUserPassword: Bool? = nil, scalingConfiguration: ScalingConfiguration? = nil, serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration? = nil, storageType: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.allowEngineModeChange = allowEngineModeChange
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.applyImmediately = applyImmediately
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backtrackWindow = backtrackWindow
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterInstanceClass = dbClusterInstanceClass
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbInstanceParameterGroupName = dbInstanceParameterGroupName
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainIAMRoleName = domainIAMRoleName
            self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
            self.enableHttpEndpoint = enableHttpEndpoint
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.enableLimitlessDatabase = enableLimitlessDatabase
            self.enableLocalWriteForwarding = enableLocalWriteForwarding
            self.enablePerformanceInsights = enablePerformanceInsights
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.iops = iops
            self.manageMasterUserPassword = manageMasterUserPassword
            self.masterUserPassword = masterUserPassword
            self.masterUserSecretKmsKeyId = masterUserSecretKmsKeyId
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.networkType = networkType
            self.newDBClusterIdentifier = newDBClusterIdentifier
            self.optionGroupName = optionGroupName
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.rotateMasterUserPassword = rotateMasterUserPassword
            self.scalingConfiguration = scalingConfiguration
            self.serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration
            self.storageType = storageType
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func validate(name: String) throws {
            try self.validate(self.awsBackupRecoveryPointArn, name: "awsBackupRecoveryPointArn", parent: name, max: 350)
            try self.validate(self.awsBackupRecoveryPointArn, name: "awsBackupRecoveryPointArn", parent: name, min: 43)
            try self.validate(self.awsBackupRecoveryPointArn, name: "awsBackupRecoveryPointArn", parent: name, pattern: "^arn:aws[a-z-]*:backup:[-a-z0-9]+:[0-9]{12}:[-a-z]+:([a-z0-9\\-]+:)?[a-z][a-z0-9\\-]{0,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case allowEngineModeChange = "AllowEngineModeChange"
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case applyImmediately = "ApplyImmediately"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
            case backtrackWindow = "BacktrackWindow"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case cloudwatchLogsExportConfiguration = "CloudwatchLogsExportConfiguration"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterInstanceClass = "DBClusterInstanceClass"
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbInstanceParameterGroupName = "DBInstanceParameterGroupName"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainIAMRoleName = "DomainIAMRoleName"
            case enableGlobalWriteForwarding = "EnableGlobalWriteForwarding"
            case enableHttpEndpoint = "EnableHttpEndpoint"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case enableLimitlessDatabase = "EnableLimitlessDatabase"
            case enableLocalWriteForwarding = "EnableLocalWriteForwarding"
            case enablePerformanceInsights = "EnablePerformanceInsights"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case manageMasterUserPassword = "ManageMasterUserPassword"
            case masterUserPassword = "MasterUserPassword"
            case masterUserSecretKmsKeyId = "MasterUserSecretKmsKeyId"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case networkType = "NetworkType"
            case newDBClusterIdentifier = "NewDBClusterIdentifier"
            case optionGroupName = "OptionGroupName"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case rotateMasterUserPassword = "RotateMasterUserPassword"
            case scalingConfiguration = "ScalingConfiguration"
            case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
            case storageType = "StorageType"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct ModifyDBClusterParameterGroupMessage: AWSEncodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// The name of the DB cluster parameter group to modify.
        public let dbClusterParameterGroupName: String?
        /// A list of parameters in the DB cluster parameter group to modify. Valid Values (for the application method): immediate | pending-reboot   You can use the immediate value with dynamic parameters only. You can use the  pending-reboot value for both dynamic and static parameters. When the application method is immediate, changes to dynamic parameters are applied immediately  to the DB clusters associated with the parameter group. When the application method is pending-reboot,  changes to dynamic and static parameters are applied after a reboot without failover to the DB clusters associated with the  parameter group.
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?

        public init(dbClusterParameterGroupName: String? = nil, parameters: [Parameter]? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case parameters = "Parameters"
        }
    }

    public struct ModifyDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct ModifyDBClusterSnapshotAttributeMessage: AWSEncodableShape {
        public struct _ValuesToAddEncoding: ArrayCoderProperties { public static let member = "AttributeValue" }
        public struct _ValuesToRemoveEncoding: ArrayCoderProperties { public static let member = "AttributeValue" }

        /// The name of the DB cluster snapshot attribute to modify. To manage authorization for other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot,  set this value to restore.  To view the list of attributes available to modify, use the DescribeDBClusterSnapshotAttributes API operation.
        public let attributeName: String?
        /// The identifier for the DB cluster snapshot to modify the attributes for.
        public let dbClusterSnapshotIdentifier: String?
        /// A list of DB cluster snapshot attributes to add to the attribute specified by AttributeName. To authorize other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this list to include one or more Amazon Web Services account IDs, or all to make the manual DB cluster snapshot restorable by  any Amazon Web Services account. Do not add the all value for any manual DB cluster snapshots that contain private information that you don't want available to all Amazon Web Services accounts.
        @OptionalCustomCoding<ArrayCoder<_ValuesToAddEncoding, String>>
        public var valuesToAdd: [String]?
        /// A list of DB cluster snapshot attributes to remove from the attribute specified by AttributeName. To remove authorization for other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this list to include one or more Amazon Web Services account identifiers, or all to remove authorization for any Amazon Web Services account to copy or restore the DB cluster snapshot. If you specify all, an Amazon Web Services account whose account ID is explicitly added to the restore attribute can still copy or restore a manual DB cluster snapshot.
        @OptionalCustomCoding<ArrayCoder<_ValuesToRemoveEncoding, String>>
        public var valuesToRemove: [String]?

        public init(attributeName: String? = nil, dbClusterSnapshotIdentifier: String? = nil, valuesToAdd: [String]? = nil, valuesToRemove: [String]? = nil) {
            self.attributeName = attributeName
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.valuesToAdd = valuesToAdd
            self.valuesToRemove = valuesToRemove
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
            case valuesToAdd = "ValuesToAdd"
            case valuesToRemove = "ValuesToRemove"
        }
    }

    public struct ModifyDBClusterSnapshotAttributeResult: AWSDecodableShape {
        public let dbClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult?

        public init(dbClusterSnapshotAttributesResult: DBClusterSnapshotAttributesResult? = nil) {
            self.dbClusterSnapshotAttributesResult = dbClusterSnapshotAttributesResult
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
        }
    }

    public struct ModifyDBInstanceMessage: AWSEncodableShape {
        public struct _DBSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroupName" }
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The new amount of storage in gibibytes (GiB) to allocate for the DB instance. For RDS for Db2, MariaDB, RDS for MySQL, RDS for Oracle, and RDS for PostgreSQL,  the value supplied must be at least 10% greater than the current value.  Values that are not at least 10% greater than the existing value are rounded up  so that they are 10% greater than the current value. For the valid values for allocated storage for each engine, see CreateDBInstance.
        public let allocatedStorage: Int?
        /// Specifies whether major version upgrades are allowed. Changing this parameter doesn't  result in an outage and the change is asynchronously applied as soon as possible. This setting doesn't apply to RDS Custom DB instances. Constraints:   Major version upgrades must be allowed when specifying a value  for the EngineVersion parameter that's a different major version than the DB instance's current version.
        public let allowMajorVersionUpgrade: Bool?
        /// Specifies whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible,  regardless of the PreferredMaintenanceWindow setting for the DB instance. By default, this parameter is disabled. If this parameter is disabled, changes to the DB instance are applied during the next maintenance window. Some parameter changes can cause an outage and are applied on the next call to RebootDBInstance, or the next failure reboot. Review the table of parameters in  Modifying a DB Instance in the  Amazon RDS User Guide to see the impact of enabling or disabling ApplyImmediately for each modified parameter and to  determine when the changes are applied.
        public let applyImmediately: Bool?
        /// The automation mode of the RDS Custom DB instance.  If full, the DB instance automates monitoring and instance recovery. If  all paused, the instance pauses automation for the duration set by  ResumeFullAutomationModeMinutes.
        public let automationMode: AutomationMode?
        /// Specifies whether minor version upgrades are applied automatically to the DB instance  during the maintenance window. An outage occurs when all the following conditions are met:   The automatic upgrade is enabled for the maintenance window.   A newer minor version is available.   RDS has enabled automatic patching for the engine version.   If any of the preceding conditions isn't met, Amazon RDS applies the change as soon as possible and doesn't cause an outage. For an RDS Custom DB instance, don't enable this setting. Otherwise, the operation returns an error.
        public let autoMinorVersionUpgrade: Bool?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup. This setting doesn't apply to RDS Custom DB instances.
        public let awsBackupRecoveryPointArn: String?
        /// The number of days to retain automated backups. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.  Enabling and disabling backups can result in a brief I/O suspension that lasts from a few seconds to a few minutes, depending on the size and class of your DB instance.  These changes are applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. If you change the parameter from one non-zero value to another non-zero value, the change is asynchronously applied as soon as possible. This setting doesn't apply to Amazon Aurora DB instances. The retention period for automated backups is managed by the DB cluster. For more information, see ModifyDBCluster. Default: Uses existing setting Constraints:   Must be a value from 0 to 35.   Can't be set to 0 if the DB instance is a source to  read replicas.   Can't be set to 0 for an RDS Custom for Oracle DB instance.
        public let backupRetentionPeriod: Int?
        /// The CA certificate identifier to use for the DB instance's server certificate. This setting doesn't apply to RDS Custom DB instances. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide and   Using SSL/TLS to encrypt a connection to a DB cluster in the Amazon Aurora  User Guide.
        public let caCertificateIdentifier: String?
        /// Specifies whether the DB instance is restarted when you rotate your  SSL/TLS certificate. By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate  is not updated until the DB instance is restarted.  Set this parameter only if you are not using SSL/TLS to connect to the DB instance.  If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your  DB engine to rotate your SSL/TLS certificate:   For more information about rotating your SSL/TLS certificate for RDS DB engines, see   Rotating Your SSL/TLS Certificate. in the Amazon RDS User Guide.    For more information about rotating your SSL/TLS certificate for Aurora DB engines, see   Rotating Your SSL/TLS Certificate in the Amazon Aurora User Guide.   This setting doesn't apply to RDS Custom DB instances.
        public let certificateRotationRestart: Bool?
        /// The log types to be enabled for export to CloudWatch Logs for a  specific DB instance. A change to the CloudwatchLogsExportConfiguration parameter is always applied to the DB instance  immediately. Therefore, the ApplyImmediately parameter has no effect. This setting doesn't apply to RDS Custom DB instances.
        public let cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration?
        /// Specifies whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags aren't copied. This setting doesn't apply to Amazon Aurora DB instances. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting. For more information, see ModifyDBCluster.
        public let copyTagsToSnapshot: Bool?
        /// The new compute and memory capacity of the DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB Instance Class in the  Amazon RDS User Guide or  Aurora DB instance classes in the Amazon Aurora User Guide. For RDS Custom, see DB instance class support for RDS Custom for Oracle and  DB instance class support for RDS Custom for SQL Server. If you modify the DB instance class, an outage occurs during the change. The change is applied during the next maintenance window, unless you specify ApplyImmediately in your request.  Default: Uses existing setting Constraints:   If you are modifying the DB instance class and upgrading the engine version at the same time, the currently running engine version must be supported on the  specified DB instance class. Otherwise, the operation returns an error. In this case, first run the operation to upgrade the engine version,  and then run it again to modify the DB instance class.
        public let dbInstanceClass: String?
        /// The identifier of DB instance to modify. This value is stored as a lowercase string. Constraints:   Must match the identifier of an existing DB instance.
        public let dbInstanceIdentifier: String?
        /// The name of the DB parameter group to apply to the DB instance. Changing this setting doesn't result in an outage. The parameter group name itself is changed immediately, but the actual parameter changes are not applied until you reboot the instance without failover. In this case, the DB instance isn't rebooted automatically, and the parameter changes aren't applied during the next maintenance window. However, if you modify  dynamic parameters in the newly associated DB parameter group, these changes are applied  immediately without a reboot. This setting doesn't apply to RDS Custom DB instances. Default: Uses existing setting Constraints:   Must be in the same DB parameter group family as the DB instance.
        public let dbParameterGroupName: String?
        /// The port number on which the database accepts connections. The value of the DBPortNumber parameter must not match any of the port values  specified for options in the option group for the DB instance. If you change the DBPortNumber value, your database restarts regardless of  the value of the ApplyImmediately parameter. This setting doesn't apply to RDS Custom DB instances. Valid Values: 1150-65535  Default:   Amazon Aurora - 3306    RDS for Db2 - 50000    RDS for MariaDB - 3306    RDS for Microsoft SQL Server - 1433    RDS for MySQL - 3306    RDS for Oracle - 1521    RDS for PostgreSQL - 5432    Constraints:   For RDS for Microsoft SQL Server, the value can't be 1234, 1434, 3260, 3343, 3389, 47001, or 49152-49156.
        public let dbPortNumber: Int?
        /// A list of DB security groups to authorize on this DB instance. Changing this setting doesn't  result in an outage and the change is asynchronously applied as soon as possible. This setting doesn't apply to RDS Custom DB instances. Constraints:   If supplied, must match existing DB security groups.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupsEncoding, String>>
        public var dbSecurityGroups: [String]?
        /// The new DB subnet group for the DB instance. You can use this parameter to move your DB instance to a different VPC.   If your DB instance isn't in a VPC, you can also use this parameter to move your DB instance into a VPC. For more information, see  Working with a DB instance in a VPC  in the Amazon RDS User Guide. Changing the subnet group causes an outage during the change.  The change is applied during the next maintenance window, unless you enable ApplyImmediately. This parameter doesn't apply to RDS Custom DB instances. Constraints:   If supplied, must match existing DB subnet group.   Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        public let dedicatedLogVolume: Bool?
        /// Specifies whether the DB instance has deletion protection enabled.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. For more information, see   Deleting a DB Instance.
        public let deletionProtection: Bool?
        /// Specifies whether to remove the DB instance from the Active Directory domain.
        public let disableDomain: Bool?
        /// The Active Directory directory ID to move the DB instance to.   Specify none to remove the instance from its current domain. You must create the domain before this operation. Currently, you can create only Db2, MySQL, Microsoft SQL  Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. For more information, see  Kerberos Authentication in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let domain: String?
        /// The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Example: arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456
        public let domainAuthSecretArn: String?
        /// The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:   Two IP addresses must be provided.  If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: 123.124.125.126,234.235.236.237
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var domainDnsIps: [String]?
        /// The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:   Can't be longer than 64 characters.   Example: mymanagedADtest.mymanagedAD.mydomain
        public let domainFqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to RDS Custom DB instances.
        public let domainIAMRoleName: String?
        /// The Active Directory organizational unit for your DB instance to join. Constraints:   Must be in the distinguished name format.   Can't be longer than 64 characters.   Example: OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain
        public let domainOu: String?
        /// Specifies whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide. For more information about CoIPs, see Customer-owned IP addresses  in the Amazon Web Services Outposts User Guide.
        public let enableCustomerOwnedIp: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. This setting doesn't apply to Amazon Aurora. Mapping Amazon Web Services IAM accounts to database accounts is managed by the DB cluster. For more information about IAM database authentication, see   IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.  This setting doesn't apply to RDS Custom DB instances.
        public let enableIAMDatabaseAuthentication: Bool?
        /// Specifies whether to enable Performance Insights for the DB instance. For more information, see  Using Amazon Performance Insights in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let enablePerformanceInsights: Bool?
        /// The target Oracle DB engine when you convert a non-CDB to a CDB. This intermediate step is necessary to upgrade an Oracle Database 19c non-CDB to an Oracle Database 21c CDB. Note the following requirements:   Make sure that you specify oracle-ee-cdb or oracle-se2-cdb.   Make sure that your DB engine runs Oracle Database 19c with an April 2021 or later RU.   Note the following limitations:   You can't convert a CDB to a non-CDB.   You can't convert a replica database.   You can't convert a non-CDB to a CDB and upgrade the engine version in the same command.   You can't convert the existing custom parameter or option group when it has options or parameters that are permanent or persistent. In this situation, the DB instance reverts to the default option and parameter group. To avoid reverting to the default, specify a new parameter group with --db-parameter-group-name and a new option group with --option-group-name.
        public let engine: String?
        /// The version number of the database engine to upgrade to.  Changing this parameter results in an outage and the change  is applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. For major version upgrades, if a nondefault DB parameter group is currently in use, a new DB parameter group in the DB parameter group family for the new engine version must be specified. The new DB parameter group can be the default for that DB parameter group family. If you specify only a major version, Amazon RDS updates the DB instance to the  default minor version if the current minor version is lower. For information about valid engine versions, see CreateDBInstance,  or call DescribeDBEngineVersions. If the instance that you're modifying is acting as a read replica, the engine version that you specify must be the same or higher than the version that the source DB instance or cluster is running. In RDS Custom for Oracle, this parameter is supported for read replicas only if they are in the  PATCH_DB_FAILURE lifecycle. Constraints:   If you are upgrading the engine version and modifying the DB instance class at the same time, the currently running engine version must be supported on the  specified DB instance class. Otherwise, the operation returns an error. In this case, first run the operation to upgrade the engine version,  and then run it again to modify the DB instance class.
        public let engineVersion: String?
        /// The new Provisioned IOPS (I/O operations per second) value for the RDS instance. Changing this setting doesn't result in an outage and the change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled for this request. If you are migrating from Provisioned IOPS to standard storage, set this value to 0.  The DB instance will require a reboot for the change in storage type to take effect. If you choose to migrate your DB instance from using standard storage to using Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process can take time. The duration of the migration depends on several factors such as database load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS provisioned (if any), and the number of prior scale storage operations. Typical migration times are under 24 hours, but the process can take up to several days in some cases. During the migration, the DB instance is available for use, but might experience performance degradation. While the migration takes place, nightly backups for the instance are suspended. No other Amazon RDS operations can take place for the instance, including modifying the instance, rebooting the instance, deleting the instance, creating a read replica for the instance, and creating a DB snapshot of the instance. Constraints:   For RDS for MariaDB, RDS for MySQL, RDS for Oracle, and RDS for PostgreSQL - The value supplied must be at least 10% greater than the current value.  Values that are not at least 10% greater than the existing value are rounded up so that they are 10% greater than the current value.   Default: Uses existing setting
        public let iops: Int?
        /// The license model for the DB instance. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances. Valid Values:   RDS for Db2 - bring-your-own-license    RDS for MariaDB - general-public-license    RDS for Microsoft SQL Server - license-included    RDS for MySQL - general-public-license    RDS for Oracle - bring-your-own-license | license-included    RDS for PostgreSQL - postgresql-license
        public let licenseModel: String?
        /// Specifies whether to manage the master user password with Amazon Web Services Secrets Manager. If the DB instance doesn't manage the master user password with Amazon Web Services Secrets Manager, you can turn  on this management. In this case, you can't specify MasterUserPassword. If the DB instance already manages the master user password with Amazon Web Services Secrets Manager, and you specify that the  master user password is not managed with Amazon Web Services Secrets Manager, then you must specify MasterUserPassword.  In this case, Amazon RDS deletes the secret and uses the new password for the master user specified by  MasterUserPassword. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide.  Constraints:   Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword  is specified.
        public let manageMasterUserPassword: Bool?
        /// The new password for the master user. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.  Between the time of the request and the completion of the request, the MasterUserPassword element exists in the PendingModifiedValues element of the operation response.  Amazon RDS API operations never return the password,  so this operation provides a way to regain access to a primary instance user if the password is lost.  This includes restoring privileges that might have been accidentally revoked.  This setting doesn't apply to the following DB instances:   Amazon Aurora (The password for the master user is managed by the DB cluster. For more information, see ModifyDBCluster.)   RDS Custom   Default: Uses existing setting Constraints:   Can't be specified if ManageMasterUserPassword is turned on.   Can include any printable ASCII character except "/", """, or "@". For RDS for Oracle, can't include the "&" (ampersand) or  the "'" (single quotes) character.   Length Constraints:   RDS for Db2 - Must contain from 8 to 255 characters.   RDS for MariaDB - Must contain from 8 to 41 characters.   RDS for Microsoft SQL Server - Must contain from 8 to 128 characters.   RDS for MySQL - Must contain from 8 to 41 characters.   RDS for Oracle - Must contain from 8 to 30 characters.   RDS for PostgreSQL - Must contain from 8 to 128 characters.
        public let masterUserPassword: String?
        /// The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and  managed in Amazon Web Services Secrets Manager. This setting is valid only if both of the following conditions are met:   The DB instance doesn't manage the master user password in Amazon Web Services Secrets Manager. If the DB instance already manages the master user password in Amazon Web Services Secrets Manager,  you can't change the KMS key used to encrypt the secret.   You are turning on ManageMasterUserPassword to manage the master user password  in Amazon Web Services Secrets Manager. If you are turning on ManageMasterUserPassword and don't specify  MasterUserSecretKmsKeyId, then the aws/secretsmanager  KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't  use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer  managed KMS key.   The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let masterUserSecretKmsKeyId: String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see   Managing capacity automatically with Amazon RDS storage autoscaling  in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for  the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. If MonitoringRoleArn is specified, set MonitoringInterval to a value other than 0. This setting doesn't apply to RDS Custom DB instances. Valid Values: 0 | 1 | 5 | 10 | 15 | 30 | 60  Default: 0
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role, see To  create an IAM role for Amazon RDS Enhanced Monitoring in the Amazon RDS User Guide.  If MonitoringInterval is set to a value other than 0, supply a MonitoringRoleArn  value. This setting doesn't apply to RDS Custom DB instances.
        public let monitoringRoleArn: String?
        /// Specifies whether the DB instance is a Multi-AZ deployment. Changing this parameter doesn't result  in an outage. The change is applied during the next maintenance window unless the ApplyImmediately  parameter is enabled for this request. This setting doesn't apply to RDS Custom DB instances.
        public let multiAZ: Bool?
        /// Specifies whether the to convert your DB instance from the single-tenant conﬁguration to the multi-tenant conﬁguration. This parameter is supported only for RDS for Oracle CDB instances. During the conversion, RDS creates an initial tenant database and associates the DB name, master user name, character set, and national character set metadata with this database. The tags associated with the instance also propagate to the initial tenant database. You can add more tenant databases to your DB instance by using the CreateTenantDatabase operation.  The conversion to the multi-tenant configuration is permanent and irreversible, so you can't later convert back to the single-tenant configuration. When you specify this parameter, you must also specify ApplyImmediately.
        public let multiTenant: Bool?
        /// The network type of the DB instance. The network type is determined by the DBSubnetGroup specified for the DB instance.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.  Valid Values: IPV4 | DUAL
        public let networkType: String?
        /// The new identifier for the DB instance when renaming a DB instance. When you change the DB instance  identifier, an instance reboot occurs immediately if you enable ApplyImmediately, or will occur  during the next maintenance window if you disable ApplyImmediately. This value is stored as a lowercase string. This setting doesn't apply to RDS Custom DB instances. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   The first character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: mydbinstance
        public let newDBInstanceIdentifier: String?
        /// The option group to associate the DB instance with. Changing this parameter doesn't result in an outage, with one exception. If the parameter change results  in an option group that enables OEM, it can cause a brief period, lasting less than a second, during which  new connections are rejected but existing connections aren't interrupted. The change is applied during the next maintenance window unless the ApplyImmediately parameter  is enabled for this request. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed  from an option group, and that option group can't be removed from a DB instance after  it is associated with a DB instance. This setting doesn't apply to RDS Custom DB instances.
        public let optionGroupName: String?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS  uses your default KMS key. There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region. This setting doesn't apply to RDS Custom DB instances.
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. This setting doesn't apply to RDS Custom DB instances. Valid Values:    7     month * 31, where month is a number of months from 1-23.  Examples: 93 (3 months * 31), 341 (11 months * 31), 589 (19 months * 31)    731    Default: 7 days If you specify a retention period that isn't valid, such as 94,  Amazon RDS returns an error.
        public let performanceInsightsRetentionPeriod: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled, as determined by the BackupRetentionPeriod parameter.  Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region. For more information, see Backup window in the Amazon RDS User Guide. This setting doesn't apply to Amazon Aurora DB instances. The daily time range for creating automated backups is managed by the DB cluster. For more information, see ModifyDBCluster. Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, which might result in an outage. Changing this parameter doesn't result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If there are pending actions that cause a reboot, and the maintenance window is changed to include the current time, then changing this parameter causes a reboot of the DB instance. If you change this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. For more information, see Amazon RDS Maintenance Window in the Amazon RDS User Guide.  Default: Uses existing setting Constraints:   Must be in the format ddd:hh24:mi-ddd:hh24:mi.   The day values must be mon | tue | wed | thu | fri | sat | sun.    Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred backup window.   Must be at least 30 minutes.
        public let preferredMaintenanceWindow: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom DB instances.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// The order of priority in which an Aurora Replica is promoted to the primary instance  after a failure of the existing primary instance. For more information,  see  Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide. This setting doesn't apply to RDS Custom DB instances. Default: 1  Valid Values: 0 - 15
        public let promotionTier: Int?
        /// Specifies whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.  PubliclyAccessible only applies to DB instances in a VPC. The DB instance must be part of a  public subnet and PubliclyAccessible must be enabled for it to be publicly accessible. Changes to the PubliclyAccessible parameter are applied immediately regardless of the value of the ApplyImmediately parameter.
        public let publiclyAccessible: Bool?
        /// A value that sets the open mode of a replica database to either mounted or read-only.  Currently, this parameter is only supported for Oracle DB instances.  Mounted DB replicas are included in Oracle Enterprise Edition. The main use case for  mounted replicas is cross-Region disaster recovery. The primary database doesn't use  Active Data Guard to transmit information to the mounted replica. Because it doesn't  accept user connections, a mounted replica can't serve a read-only workload.  For more information, see Working with Oracle Read Replicas for Amazon RDS  in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom DB instances.
        public let replicaMode: ReplicaMode?
        /// The number of minutes to pause the automation. When the time period ends, RDS Custom resumes  full automation. Default: 60  Constraints:   Must be at least 60.   Must be no more than 1,440.
        public let resumeFullAutomationModeMinutes: Int?
        /// Specifies whether to rotate the secret managed by Amazon Web Services Secrets Manager for the  master user password. This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets  Manager for the DB cluster. The secret value contains the updated password. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide.  Constraints:   You must apply the change immediately when rotating the master user password.
        public let rotateMasterUserPassword: Bool?
        /// The storage throughput value for the DB instance. This setting applies only to the gp3 storage type. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        public let storageThroughput: Int?
        /// The storage type to associate with the DB instance. If you specify io1, io2, or gp3  you must also include a value for the Iops parameter. If you choose to migrate your DB instance from using standard storage to using Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process can take time. The duration of the migration depends on several factors such as database load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS provisioned (if any), and the number of prior scale storage operations. Typical migration times are under 24 hours, but the process can take up to several days in some cases. During the migration, the DB instance is available for use, but might experience performance degradation. While the migration takes place, nightly backups for the instance are suspended. No other Amazon RDS operations can take place for the instance, including modifying the instance, rebooting the instance, deleting the instance, creating a read replica for the instance, and creating a DB snapshot of the instance. Valid Values: gp2 | gp3 | io1 | io2 | standard  Default: io1, if the Iops parameter is specified. Otherwise, gp2.
        public let storageType: String?
        /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom DB instances.
        public let tdeCredentialArn: String?
        /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom DB instances.
        public let tdeCredentialPassword: String?
        /// Specifies whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom DB instances.
        public let useDefaultProcessorFeatures: Bool?
        /// A list of Amazon EC2 VPC security groups to associate with this DB instance. This change is  asynchronously applied as soon as possible. This setting doesn't apply to the following DB instances:   Amazon Aurora (The associated list of EC2 VPC security groups is managed by the DB cluster. For more information, see ModifyDBCluster.)   RDS Custom   Constraints:   If supplied, must match existing VPC security group IDs.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, allowMajorVersionUpgrade: Bool? = nil, applyImmediately: Bool? = nil, automationMode: AutomationMode? = nil, autoMinorVersionUpgrade: Bool? = nil, awsBackupRecoveryPointArn: String? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, certificateRotationRestart: Bool? = nil, cloudwatchLogsExportConfiguration: CloudwatchLogsExportConfiguration? = nil, copyTagsToSnapshot: Bool? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbParameterGroupName: String? = nil, dbPortNumber: Int? = nil, dbSecurityGroups: [String]? = nil, dbSubnetGroupName: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, disableDomain: Bool? = nil, domain: String? = nil, domainAuthSecretArn: String? = nil, domainDnsIps: [String]? = nil, domainFqdn: String? = nil, domainIAMRoleName: String? = nil, domainOu: String? = nil, enableCustomerOwnedIp: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, enablePerformanceInsights: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iops: Int? = nil, licenseModel: String? = nil, manageMasterUserPassword: Bool? = nil, masterUserPassword: String? = nil, masterUserSecretKmsKeyId: String? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAZ: Bool? = nil, multiTenant: Bool? = nil, networkType: String? = nil, newDBInstanceIdentifier: String? = nil, optionGroupName: String? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, processorFeatures: [ProcessorFeature]? = nil, promotionTier: Int? = nil, publiclyAccessible: Bool? = nil, replicaMode: ReplicaMode? = nil, resumeFullAutomationModeMinutes: Int? = nil, rotateMasterUserPassword: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tdeCredentialArn: String? = nil, tdeCredentialPassword: String? = nil, useDefaultProcessorFeatures: Bool? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.applyImmediately = applyImmediately
            self.automationMode = automationMode
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.certificateRotationRestart = certificateRotationRestart
            self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbParameterGroupName = dbParameterGroupName
            self.dbPortNumber = dbPortNumber
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.disableDomain = disableDomain
            self.domain = domain
            self.domainAuthSecretArn = domainAuthSecretArn
            self.domainDnsIps = domainDnsIps
            self.domainFqdn = domainFqdn
            self.domainIAMRoleName = domainIAMRoleName
            self.domainOu = domainOu
            self.enableCustomerOwnedIp = enableCustomerOwnedIp
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.enablePerformanceInsights = enablePerformanceInsights
            self.engine = engine
            self.engineVersion = engineVersion
            self.iops = iops
            self.licenseModel = licenseModel
            self.manageMasterUserPassword = manageMasterUserPassword
            self.masterUserPassword = masterUserPassword
            self.masterUserSecretKmsKeyId = masterUserSecretKmsKeyId
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.multiTenant = multiTenant
            self.networkType = networkType
            self.newDBInstanceIdentifier = newDBInstanceIdentifier
            self.optionGroupName = optionGroupName
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.replicaMode = replicaMode
            self.resumeFullAutomationModeMinutes = resumeFullAutomationModeMinutes
            self.rotateMasterUserPassword = rotateMasterUserPassword
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.tdeCredentialPassword = tdeCredentialPassword
            self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func validate(name: String) throws {
            try self.validate(self.awsBackupRecoveryPointArn, name: "awsBackupRecoveryPointArn", parent: name, max: 350)
            try self.validate(self.awsBackupRecoveryPointArn, name: "awsBackupRecoveryPointArn", parent: name, min: 43)
            try self.validate(self.awsBackupRecoveryPointArn, name: "awsBackupRecoveryPointArn", parent: name, pattern: "^arn:aws[a-z-]*:backup:[-a-z0-9]+:[0-9]{12}:[-a-z]+:([a-z0-9\\-]+:)?[a-z][a-z0-9\\-]{0,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case applyImmediately = "ApplyImmediately"
            case automationMode = "AutomationMode"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case certificateRotationRestart = "CertificateRotationRestart"
            case cloudwatchLogsExportConfiguration = "CloudwatchLogsExportConfiguration"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbParameterGroupName = "DBParameterGroupName"
            case dbPortNumber = "DBPortNumber"
            case dbSecurityGroups = "DBSecurityGroups"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case disableDomain = "DisableDomain"
            case domain = "Domain"
            case domainAuthSecretArn = "DomainAuthSecretArn"
            case domainDnsIps = "DomainDnsIps"
            case domainFqdn = "DomainFqdn"
            case domainIAMRoleName = "DomainIAMRoleName"
            case domainOu = "DomainOu"
            case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case enablePerformanceInsights = "EnablePerformanceInsights"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case licenseModel = "LicenseModel"
            case manageMasterUserPassword = "ManageMasterUserPassword"
            case masterUserPassword = "MasterUserPassword"
            case masterUserSecretKmsKeyId = "MasterUserSecretKmsKeyId"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAZ = "MultiAZ"
            case multiTenant = "MultiTenant"
            case networkType = "NetworkType"
            case newDBInstanceIdentifier = "NewDBInstanceIdentifier"
            case optionGroupName = "OptionGroupName"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case processorFeatures = "ProcessorFeatures"
            case promotionTier = "PromotionTier"
            case publiclyAccessible = "PubliclyAccessible"
            case replicaMode = "ReplicaMode"
            case resumeFullAutomationModeMinutes = "ResumeFullAutomationModeMinutes"
            case rotateMasterUserPassword = "RotateMasterUserPassword"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tdeCredentialArn = "TdeCredentialArn"
            case tdeCredentialPassword = "TdeCredentialPassword"
            case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct ModifyDBInstanceResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct ModifyDBParameterGroupMessage: AWSEncodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// The name of the DB parameter group. Constraints:   If supplied, must match the name of an existing DBParameterGroup.
        public let dbParameterGroupName: String?
        /// An array of parameter names, values, and the application methods for the parameter update. At least one parameter name, value, and  application method must be supplied; later arguments are optional. A maximum of 20 parameters can be modified in a single request. Valid Values (for the application method): immediate | pending-reboot  You can use the immediate value with dynamic parameters only. You can use the pending-reboot value for both dynamic  and static parameters. When the application method is immediate, changes to dynamic parameters are applied immediately to the DB instances associated with  the parameter group. When the application method is pending-reboot, changes to dynamic and static parameters are applied after a reboot without failover  to the DB instances associated with the parameter group.  You can't use pending-reboot with dynamic parameters on RDS for SQL Server DB instances. Use immediate.  For more information on modifying DB parameters, see Working  with DB parameter groups in the Amazon RDS User Guide.
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?

        public init(dbParameterGroupName: String? = nil, parameters: [Parameter]? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
            case parameters = "Parameters"
        }
    }

    public struct ModifyDBProxyEndpointRequest: AWSEncodableShape {
        /// The name of the DB proxy sociated with the DB proxy endpoint that you want to modify.
        public let dbProxyEndpointName: String?
        /// The new identifier for the DBProxyEndpoint. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        public let newDBProxyEndpointName: String?
        /// The VPC security group IDs for the DB proxy endpoint. When the DB proxy endpoint uses a different VPC than the original proxy, you also specify a different set of security group IDs than for the original proxy.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var vpcSecurityGroupIds: [String]?

        public init(dbProxyEndpointName: String? = nil, newDBProxyEndpointName: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.dbProxyEndpointName = dbProxyEndpointName
            self.newDBProxyEndpointName = newDBProxyEndpointName
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func validate(name: String) throws {
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, max: 63)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, min: 1)
            try self.validate(self.dbProxyEndpointName, name: "dbProxyEndpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.newDBProxyEndpointName, name: "newDBProxyEndpointName", parent: name, max: 63)
            try self.validate(self.newDBProxyEndpointName, name: "newDBProxyEndpointName", parent: name, min: 1)
            try self.validate(self.newDBProxyEndpointName, name: "newDBProxyEndpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpointName = "DBProxyEndpointName"
            case newDBProxyEndpointName = "NewDBProxyEndpointName"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct ModifyDBProxyEndpointResponse: AWSDecodableShape {
        /// The DBProxyEndpoint object representing the new settings for the DB proxy endpoint.
        public let dbProxyEndpoint: DBProxyEndpoint?

        public init(dbProxyEndpoint: DBProxyEndpoint? = nil) {
            self.dbProxyEndpoint = dbProxyEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyEndpoint = "DBProxyEndpoint"
        }
    }

    public struct ModifyDBProxyRequest: AWSEncodableShape {
        /// The new authentication settings for the DBProxy.
        @OptionalCustomCoding<StandardArrayCoder<UserAuthConfig>>
        public var auth: [UserAuthConfig]?
        /// The identifier for the DBProxy to modify.
        public let dbProxyName: String?
        /// Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
        public let debugLogging: Bool?
        /// The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
        public let idleClientTimeout: Int?
        /// The new identifier for the DBProxy. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        public let newDBProxyName: String?
        /// Whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy, even if the associated database doesn't use TLS.
        public let requireTLS: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in Amazon Web Services Secrets Manager.
        public let roleArn: String?
        /// The new list of security groups for the DBProxy.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var securityGroups: [String]?

        public init(auth: [UserAuthConfig]? = nil, dbProxyName: String? = nil, debugLogging: Bool? = nil, idleClientTimeout: Int? = nil, newDBProxyName: String? = nil, requireTLS: Bool? = nil, roleArn: String? = nil, securityGroups: [String]? = nil) {
            self.auth = auth
            self.dbProxyName = dbProxyName
            self.debugLogging = debugLogging
            self.idleClientTimeout = idleClientTimeout
            self.newDBProxyName = newDBProxyName
            self.requireTLS = requireTLS
            self.roleArn = roleArn
            self.securityGroups = securityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case auth = "Auth"
            case dbProxyName = "DBProxyName"
            case debugLogging = "DebugLogging"
            case idleClientTimeout = "IdleClientTimeout"
            case newDBProxyName = "NewDBProxyName"
            case requireTLS = "RequireTLS"
            case roleArn = "RoleArn"
            case securityGroups = "SecurityGroups"
        }
    }

    public struct ModifyDBProxyResponse: AWSDecodableShape {
        /// The DBProxy object representing the new settings for the proxy.
        public let dbProxy: DBProxy?

        public init(dbProxy: DBProxy? = nil) {
            self.dbProxy = dbProxy
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxy = "DBProxy"
        }
    }

    public struct ModifyDBProxyTargetGroupRequest: AWSEncodableShape {
        /// The settings that determine the size and behavior of the connection pool for the target group.
        public let connectionPoolConfig: ConnectionPoolConfiguration?
        /// The name of the proxy.
        public let dbProxyName: String?
        /// The new name for the modified DBProxyTarget. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        public let newName: String?
        /// The name of the target group to modify.
        public let targetGroupName: String?

        public init(connectionPoolConfig: ConnectionPoolConfiguration? = nil, dbProxyName: String? = nil, newName: String? = nil, targetGroupName: String? = nil) {
            self.connectionPoolConfig = connectionPoolConfig
            self.dbProxyName = dbProxyName
            self.newName = newName
            self.targetGroupName = targetGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPoolConfig = "ConnectionPoolConfig"
            case dbProxyName = "DBProxyName"
            case newName = "NewName"
            case targetGroupName = "TargetGroupName"
        }
    }

    public struct ModifyDBProxyTargetGroupResponse: AWSDecodableShape {
        /// The settings of the modified DBProxyTarget.
        public let dbProxyTargetGroup: DBProxyTargetGroup?

        public init(dbProxyTargetGroup: DBProxyTargetGroup? = nil) {
            self.dbProxyTargetGroup = dbProxyTargetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyTargetGroup = "DBProxyTargetGroup"
        }
    }

    public struct ModifyDBRecommendationMessage: AWSEncodableShape {
        /// The language of the modified recommendation.
        public let locale: String?
        /// The identifier of the recommendation to update.
        public let recommendationId: String?
        /// The list of recommended action status to update. You can update multiple recommended actions at one time.
        @OptionalCustomCoding<StandardArrayCoder<RecommendedActionUpdate>>
        public var recommendedActionUpdates: [RecommendedActionUpdate]?
        /// The recommendation status to update. Valid values:   active   dismissed
        public let status: String?

        public init(locale: String? = nil, recommendationId: String? = nil, recommendedActionUpdates: [RecommendedActionUpdate]? = nil, status: String? = nil) {
            self.locale = locale
            self.recommendationId = recommendationId
            self.recommendedActionUpdates = recommendedActionUpdates
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "Locale"
            case recommendationId = "RecommendationId"
            case recommendedActionUpdates = "RecommendedActionUpdates"
            case status = "Status"
        }
    }

    public struct ModifyDBShardGroupMessage: AWSEncodableShape {
        /// The name of the DB shard group to modify.
        public let dbShardGroupIdentifier: String?
        /// The maximum capacity of the DB shard group in Aurora capacity units (ACUs).
        public let maxACU: Double?

        public init(dbShardGroupIdentifier: String? = nil, maxACU: Double? = nil) {
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
            self.maxACU = maxACU
        }

        public func validate(name: String) throws {
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, max: 63)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, min: 1)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbShardGroupIdentifier = "DBShardGroupIdentifier"
            case maxACU = "MaxACU"
        }
    }

    public struct ModifyDBSnapshotAttributeMessage: AWSEncodableShape {
        public struct _ValuesToAddEncoding: ArrayCoderProperties { public static let member = "AttributeValue" }
        public struct _ValuesToRemoveEncoding: ArrayCoderProperties { public static let member = "AttributeValue" }

        /// The name of the DB snapshot attribute to modify. To manage authorization for other Amazon Web Services accounts to copy or restore a manual DB snapshot,  set this value to restore.  To view the list of attributes available to modify, use the DescribeDBSnapshotAttributes API operation.
        public let attributeName: String?
        /// The identifier for the DB snapshot to modify the attributes for.
        public let dbSnapshotIdentifier: String?
        /// A list of DB snapshot attributes to add to the attribute specified by AttributeName. To authorize other Amazon Web Services accounts to copy or restore a manual snapshot, set this list to include one or more Amazon Web Services account IDs, or all to make the manual DB snapshot restorable by  any Amazon Web Services account. Do not add the all value for any manual DB snapshots that contain private information that you don't want available to all Amazon Web Services accounts.
        @OptionalCustomCoding<ArrayCoder<_ValuesToAddEncoding, String>>
        public var valuesToAdd: [String]?
        /// A list of DB snapshot attributes to remove from the attribute specified by AttributeName. To remove authorization for other Amazon Web Services accounts to copy or restore a manual snapshot, set this list to include  one or more Amazon Web Services account identifiers, or all to remove authorization for any Amazon Web Services account to copy or restore the DB snapshot. If you specify all, an Amazon Web Services account whose account ID is explicitly added to the restore attribute can still copy or restore the manual DB snapshot.
        @OptionalCustomCoding<ArrayCoder<_ValuesToRemoveEncoding, String>>
        public var valuesToRemove: [String]?

        public init(attributeName: String? = nil, dbSnapshotIdentifier: String? = nil, valuesToAdd: [String]? = nil, valuesToRemove: [String]? = nil) {
            self.attributeName = attributeName
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.valuesToAdd = valuesToAdd
            self.valuesToRemove = valuesToRemove
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case valuesToAdd = "ValuesToAdd"
            case valuesToRemove = "ValuesToRemove"
        }
    }

    public struct ModifyDBSnapshotAttributeResult: AWSDecodableShape {
        public let dbSnapshotAttributesResult: DBSnapshotAttributesResult?

        public init(dbSnapshotAttributesResult: DBSnapshotAttributesResult? = nil) {
            self.dbSnapshotAttributesResult = dbSnapshotAttributesResult
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotAttributesResult = "DBSnapshotAttributesResult"
        }
    }

    public struct ModifyDBSnapshotMessage: AWSEncodableShape {
        /// The identifier of the DB snapshot to modify.
        public let dbSnapshotIdentifier: String?
        /// The engine version to upgrade the DB snapshot to. The following are the database engines and engine versions that are available when you upgrade a DB snapshot.  MySQL  For the list of engine versions that are available for upgrading a DB snapshot, see   Upgrading a MySQL DB snapshot engine version in the Amazon RDS User Guide.   Oracle     19.0.0.0.ru-2022-01.rur-2022-01.r1 (supported for 12.2.0.1 DB snapshots)    19.0.0.0.ru-2022-07.rur-2022-07.r1 (supported for 12.1.0.2 DB snapshots)    12.1.0.2.v8  (supported for 12.1.0.1 DB snapshots)    11.2.0.4.v12 (supported for 11.2.0.2 DB snapshots)    11.2.0.4.v11 (supported for 11.2.0.3 DB snapshots)    PostgreSQL  For the list of engine versions that are available for upgrading a DB snapshot, see   Upgrading a PostgreSQL DB snapshot engine version in the Amazon RDS User Guide.
        public let engineVersion: String?
        /// The option group to identify with the upgraded DB snapshot. You can specify this parameter when you upgrade an Oracle DB snapshot. The same option group considerations apply when upgrading a DB snapshot as when upgrading a DB instance. For more information, see  Option group considerations in the Amazon RDS User Guide.
        public let optionGroupName: String?

        public init(dbSnapshotIdentifier: String? = nil, engineVersion: String? = nil, optionGroupName: String? = nil) {
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.engineVersion = engineVersion
            self.optionGroupName = optionGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case engineVersion = "EngineVersion"
            case optionGroupName = "OptionGroupName"
        }
    }

    public struct ModifyDBSnapshotResult: AWSDecodableShape {
        public let dbSnapshot: DBSnapshot?

        public init(dbSnapshot: DBSnapshot? = nil) {
            self.dbSnapshot = dbSnapshot
        }

        private enum CodingKeys: String, CodingKey {
            case dbSnapshot = "DBSnapshot"
        }
    }

    public struct ModifyDBSubnetGroupMessage: AWSEncodableShape {
        public struct _SubnetIdsEncoding: ArrayCoderProperties { public static let member = "SubnetIdentifier" }

        /// The description for the DB subnet group.
        public let dbSubnetGroupDescription: String?
        /// The name for the DB subnet group. This value is stored as a lowercase string. You can't modify the default subnet group. Constraints: Must match the name of an existing DBSubnetGroup. Must not be default. Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// The EC2 subnet IDs for the DB subnet group.
        @OptionalCustomCoding<ArrayCoder<_SubnetIdsEncoding, String>>
        public var subnetIds: [String]?

        public init(dbSubnetGroupDescription: String? = nil, dbSubnetGroupName: String? = nil, subnetIds: [String]? = nil) {
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupDescription = "DBSubnetGroupDescription"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case subnetIds = "SubnetIds"
        }
    }

    public struct ModifyDBSubnetGroupResult: AWSDecodableShape {
        public let dbSubnetGroup: DBSubnetGroup?

        public init(dbSubnetGroup: DBSubnetGroup? = nil) {
            self.dbSubnetGroup = dbSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroup = "DBSubnetGroup"
        }
    }

    public struct ModifyEventSubscriptionMessage: AWSEncodableShape {
        public struct _EventCategoriesEncoding: ArrayCoderProperties { public static let member = "EventCategory" }

        /// Specifies whether to activate the subscription.
        public let enabled: Bool?
        /// A list of event categories for a source type (SourceType) that you want to subscribe to.  You can see a list of the categories for a given source type  in Events in the Amazon RDS User Guide  or by using the DescribeEventCategories operation.
        @OptionalCustomCoding<ArrayCoder<_EventCategoriesEncoding, String>>
        public var eventCategories: [String]?
        /// The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String?
        /// The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, you would set this parameter to db-instance. For RDS Proxy events, specify db-proxy. If this value isn't specified, all events are returned. Valid Values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot | db-proxy
        public let sourceType: String?
        /// The name of the RDS event notification subscription.
        public let subscriptionName: String?

        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String? = nil, sourceType: String? = nil, subscriptionName: String? = nil) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct ModifyEventSubscriptionResult: AWSDecodableShape {
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct ModifyGlobalClusterMessage: AWSEncodableShape {
        /// Specifies whether to allow major version upgrades. Constraints: Must be enabled if you specify a value for the EngineVersion parameter that's a different major version than the global cluster's current version. If you upgrade the major version of a global database, the cluster and DB instance parameter groups are set to the default parameter groups for the new version. Apply any custom parameter groups after completing the upgrade.
        public let allowMajorVersionUpgrade: Bool?
        /// Specifies whether to enable deletion protection for the global database cluster. The global database cluster can't be deleted when deletion protection is enabled.
        public let deletionProtection: Bool?
        /// The version number of the database engine to which you want to upgrade.   To list all of the available engine versions for aurora-mysql (for MySQL-based Aurora global databases), use the following command:  aws rds describe-db-engine-versions --engine aurora-mysql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'  To list all of the available engine versions for aurora-postgresql (for PostgreSQL-based Aurora global databases), use the following command:  aws rds describe-db-engine-versions --engine aurora-postgresql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'
        public let engineVersion: String?
        /// The cluster identifier for the global cluster to modify. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing global database cluster.
        public let globalClusterIdentifier: String?
        /// The new cluster identifier for the global database cluster. This value is stored as a lowercase string. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   The first character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster2
        public let newGlobalClusterIdentifier: String?

        public init(allowMajorVersionUpgrade: Bool? = nil, deletionProtection: Bool? = nil, engineVersion: String? = nil, globalClusterIdentifier: String? = nil, newGlobalClusterIdentifier: String? = nil) {
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.deletionProtection = deletionProtection
            self.engineVersion = engineVersion
            self.globalClusterIdentifier = globalClusterIdentifier
            self.newGlobalClusterIdentifier = newGlobalClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case deletionProtection = "DeletionProtection"
            case engineVersion = "EngineVersion"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case newGlobalClusterIdentifier = "NewGlobalClusterIdentifier"
        }
    }

    public struct ModifyGlobalClusterResult: AWSDecodableShape {
        public let globalCluster: GlobalCluster?

        public init(globalCluster: GlobalCluster? = nil) {
            self.globalCluster = globalCluster
        }

        private enum CodingKeys: String, CodingKey {
            case globalCluster = "GlobalCluster"
        }
    }

    public struct ModifyIntegrationMessage: AWSEncodableShape {
        /// A new data filter for the integration. For more information, see  Data filtering for Aurora zero-ETL integrations with Amazon Redshift.
        public let dataFilter: String?
        /// A new description for the integration.
        public let description: String?
        /// The unique identifier of the integration to modify.
        public let integrationIdentifier: String?
        /// A new name for the integration.
        public let integrationName: String?

        public init(dataFilter: String? = nil, description: String? = nil, integrationIdentifier: String? = nil, integrationName: String? = nil) {
            self.dataFilter = dataFilter
            self.description = description
            self.integrationIdentifier = integrationIdentifier
            self.integrationName = integrationName
        }

        public func validate(name: String) throws {
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, max: 25600)
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, min: 1)
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, pattern: "^[a-zA-Z0-9_ \"\\\\\\-$,*.:?+\\/]*$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, max: 255)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, min: 1)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, pattern: "^[a-zA-Z0-9_:\\-\\/]+$")
            try self.validate(self.integrationName, name: "integrationName", parent: name, max: 63)
            try self.validate(self.integrationName, name: "integrationName", parent: name, min: 1)
            try self.validate(self.integrationName, name: "integrationName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFilter = "DataFilter"
            case description = "Description"
            case integrationIdentifier = "IntegrationIdentifier"
            case integrationName = "IntegrationName"
        }
    }

    public struct ModifyOptionGroupMessage: AWSEncodableShape {
        public struct _OptionsToIncludeEncoding: ArrayCoderProperties { public static let member = "OptionConfiguration" }

        /// Specifies whether to apply the change immediately or during the next maintenance window for each instance associated with the option group.
        public let applyImmediately: Bool?
        /// The name of the option group to be modified. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance
        public let optionGroupName: String?
        /// Options in this list are added to the option group or, if already present, the specified configuration is used to update the existing configuration.
        @OptionalCustomCoding<ArrayCoder<_OptionsToIncludeEncoding, OptionConfiguration>>
        public var optionsToInclude: [OptionConfiguration]?
        /// Options in this list are removed from the option group.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var optionsToRemove: [String]?

        public init(applyImmediately: Bool? = nil, optionGroupName: String? = nil, optionsToInclude: [OptionConfiguration]? = nil, optionsToRemove: [String]? = nil) {
            self.applyImmediately = applyImmediately
            self.optionGroupName = optionGroupName
            self.optionsToInclude = optionsToInclude
            self.optionsToRemove = optionsToRemove
        }

        private enum CodingKeys: String, CodingKey {
            case applyImmediately = "ApplyImmediately"
            case optionGroupName = "OptionGroupName"
            case optionsToInclude = "OptionsToInclude"
            case optionsToRemove = "OptionsToRemove"
        }
    }

    public struct ModifyOptionGroupResult: AWSDecodableShape {
        public let optionGroup: OptionGroup?

        public init(optionGroup: OptionGroup? = nil) {
            self.optionGroup = optionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroup = "OptionGroup"
        }
    }

    public struct ModifyTenantDatabaseMessage: AWSEncodableShape {
        /// The identifier of the DB instance that contains the tenant database that you are modifying. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing DB instance.
        public let dbInstanceIdentifier: String?
        /// The new password for the master user of the specified tenant database in your DB instance.  Amazon RDS operations never return the password, so this action provides a way to regain access to a tenant database user if the password is lost. This includes restoring privileges that might have been accidentally revoked.  Constraints:   Can include any printable ASCII character except /, " (double quote), @, & (ampersand), and ' (single quote).   Length constraints:   Must contain between 8 and 30 characters.
        public let masterUserPassword: String?
        /// The new name of the tenant database when renaming a tenant database. This parameter isn’t case-sensitive. Constraints:   Can't be the string null or any other reserved word.   Can't be longer than 8 characters.
        public let newTenantDBName: String?
        /// The user-supplied name of the tenant database that you want to modify. This parameter isn’t case-sensitive. Constraints:   Must match the identifier of an existing tenant database.
        public let tenantDBName: String?

        public init(dbInstanceIdentifier: String? = nil, masterUserPassword: String? = nil, newTenantDBName: String? = nil, tenantDBName: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.masterUserPassword = masterUserPassword
            self.newTenantDBName = newTenantDBName
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case masterUserPassword = "MasterUserPassword"
            case newTenantDBName = "NewTenantDBName"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct ModifyTenantDatabaseResult: AWSDecodableShape {
        public let tenantDatabase: TenantDatabase?

        public init(tenantDatabase: TenantDatabase? = nil) {
            self.tenantDatabase = tenantDatabase
        }

        private enum CodingKeys: String, CodingKey {
            case tenantDatabase = "TenantDatabase"
        }
    }

    public struct Option: AWSDecodableShape {
        public struct _DBSecurityGroupMembershipsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroup" }
        public struct _OptionSettingsEncoding: ArrayCoderProperties { public static let member = "OptionSetting" }
        public struct _VpcSecurityGroupMembershipsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupMembership" }

        /// If the option requires access to a port, then this DB security group allows access to the port.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupMembershipsEncoding, DBSecurityGroupMembership>>
        public var dbSecurityGroupMemberships: [DBSecurityGroupMembership]?
        /// The description of the option.
        public let optionDescription: String?
        /// The name of the option.
        public let optionName: String?
        /// The option settings for this option.
        @OptionalCustomCoding<ArrayCoder<_OptionSettingsEncoding, OptionSetting>>
        public var optionSettings: [OptionSetting]?
        /// The version of the option.
        public let optionVersion: String?
        /// Indicates whether this option is permanent.
        public let permanent: Bool?
        /// Indicates whether this option is persistent.
        public let persistent: Bool?
        /// If required, the port configured for this option to use.
        public let port: Int?
        /// If the option requires access to a port, then this VPC security group allows access to the port.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupMembershipsEncoding, VpcSecurityGroupMembership>>
        public var vpcSecurityGroupMemberships: [VpcSecurityGroupMembership]?

        public init(dbSecurityGroupMemberships: [DBSecurityGroupMembership]? = nil, optionDescription: String? = nil, optionName: String? = nil, optionSettings: [OptionSetting]? = nil, optionVersion: String? = nil, permanent: Bool? = nil, persistent: Bool? = nil, port: Int? = nil, vpcSecurityGroupMemberships: [VpcSecurityGroupMembership]? = nil) {
            self.dbSecurityGroupMemberships = dbSecurityGroupMemberships
            self.optionDescription = optionDescription
            self.optionName = optionName
            self.optionSettings = optionSettings
            self.optionVersion = optionVersion
            self.permanent = permanent
            self.persistent = persistent
            self.port = port
            self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupMemberships = "DBSecurityGroupMemberships"
            case optionDescription = "OptionDescription"
            case optionName = "OptionName"
            case optionSettings = "OptionSettings"
            case optionVersion = "OptionVersion"
            case permanent = "Permanent"
            case persistent = "Persistent"
            case port = "Port"
            case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
        }
    }

    public struct OptionConfiguration: AWSEncodableShape {
        public struct _DBSecurityGroupMembershipsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroupName" }
        public struct _OptionSettingsEncoding: ArrayCoderProperties { public static let member = "OptionSetting" }
        public struct _VpcSecurityGroupMembershipsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// A list of DBSecurityGroupMembership name strings used for this option.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupMembershipsEncoding, String>>
        public var dbSecurityGroupMemberships: [String]?
        /// The configuration of options to include in a group.
        public let optionName: String?
        /// The option settings to include in an option group.
        @OptionalCustomCoding<ArrayCoder<_OptionSettingsEncoding, OptionSetting>>
        public var optionSettings: [OptionSetting]?
        /// The version for the option.
        public let optionVersion: String?
        /// The optional port for the option.
        public let port: Int?
        /// A list of VpcSecurityGroupMembership name strings used for this option.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupMembershipsEncoding, String>>
        public var vpcSecurityGroupMemberships: [String]?

        public init(dbSecurityGroupMemberships: [String]? = nil, optionName: String? = nil, optionSettings: [OptionSetting]? = nil, optionVersion: String? = nil, port: Int? = nil, vpcSecurityGroupMemberships: [String]? = nil) {
            self.dbSecurityGroupMemberships = dbSecurityGroupMemberships
            self.optionName = optionName
            self.optionSettings = optionSettings
            self.optionVersion = optionVersion
            self.port = port
            self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupMemberships = "DBSecurityGroupMemberships"
            case optionName = "OptionName"
            case optionSettings = "OptionSettings"
            case optionVersion = "OptionVersion"
            case port = "Port"
            case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
        }
    }

    public struct OptionGroup: AWSDecodableShape {
        public struct _OptionsEncoding: ArrayCoderProperties { public static let member = "Option" }

        /// Indicates whether this option group can be applied to both VPC  and non-VPC instances. The value true indicates the option group  can be applied to both VPC and non-VPC instances.
        public let allowsVpcAndNonVpcInstanceMemberships: Bool?
        /// Indicates when the option group was copied.
        public let copyTimestamp: Date?
        /// Indicates the name of the engine that this option group can be applied to.
        public let engineName: String?
        /// Indicates the major engine version associated with this option group.
        public let majorEngineVersion: String?
        /// Specifies the Amazon Resource Name (ARN) for the option group.
        public let optionGroupArn: String?
        /// Provides a description of the option group.
        public let optionGroupDescription: String?
        /// Specifies the name of the option group.
        public let optionGroupName: String?
        /// Indicates what options are available in the option group.
        @OptionalCustomCoding<ArrayCoder<_OptionsEncoding, Option>>
        public var options: [Option]?
        /// Specifies the Amazon Web Services account ID for the option group from which this option group is copied.
        public let sourceAccountId: String?
        /// Specifies the name of the option group from which this option group is copied.
        public let sourceOptionGroup: String?
        /// If AllowsVpcAndNonVpcInstanceMemberships is false, this field is blank. If AllowsVpcAndNonVpcInstanceMemberships is true and this field is blank,  then this option group can be applied to both VPC and non-VPC instances. If this field contains a value, then this option group can only be  applied to instances that are in the VPC indicated by this field.
        public let vpcId: String?

        public init(allowsVpcAndNonVpcInstanceMemberships: Bool? = nil, copyTimestamp: Date? = nil, engineName: String? = nil, majorEngineVersion: String? = nil, optionGroupArn: String? = nil, optionGroupDescription: String? = nil, optionGroupName: String? = nil, options: [Option]? = nil, sourceAccountId: String? = nil, sourceOptionGroup: String? = nil, vpcId: String? = nil) {
            self.allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMemberships
            self.copyTimestamp = copyTimestamp
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.optionGroupArn = optionGroupArn
            self.optionGroupDescription = optionGroupDescription
            self.optionGroupName = optionGroupName
            self.options = options
            self.sourceAccountId = sourceAccountId
            self.sourceOptionGroup = sourceOptionGroup
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case allowsVpcAndNonVpcInstanceMemberships = "AllowsVpcAndNonVpcInstanceMemberships"
            case copyTimestamp = "CopyTimestamp"
            case engineName = "EngineName"
            case majorEngineVersion = "MajorEngineVersion"
            case optionGroupArn = "OptionGroupArn"
            case optionGroupDescription = "OptionGroupDescription"
            case optionGroupName = "OptionGroupName"
            case options = "Options"
            case sourceAccountId = "SourceAccountId"
            case sourceOptionGroup = "SourceOptionGroup"
            case vpcId = "VpcId"
        }
    }

    public struct OptionGroupMembership: AWSDecodableShape {
        /// The name of the option group that the instance belongs to.
        public let optionGroupName: String?
        /// The status of the DB instance's option group membership. Valid values are:  in-sync,  pending-apply,  pending-removal,  pending-maintenance-apply,  pending-maintenance-removal,  applying,  removing,  and failed.
        public let status: String?

        public init(optionGroupName: String? = nil, status: String? = nil) {
            self.optionGroupName = optionGroupName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroupName = "OptionGroupName"
            case status = "Status"
        }
    }

    public struct OptionGroupOption: AWSDecodableShape {
        public struct _OptionGroupOptionSettingsEncoding: ArrayCoderProperties { public static let member = "OptionGroupOptionSetting" }
        public struct _OptionGroupOptionVersionsEncoding: ArrayCoderProperties { public static let member = "OptionVersion" }
        public struct _OptionsConflictsWithEncoding: ArrayCoderProperties { public static let member = "OptionConflictName" }
        public struct _OptionsDependedOnEncoding: ArrayCoderProperties { public static let member = "OptionName" }

        /// Indicates whether the option can be copied across Amazon Web Services accounts.
        public let copyableCrossAccount: Bool?
        /// If the option requires a port, specifies the default port for the option.
        public let defaultPort: Int?
        /// The description of the option.
        public let description: String?
        /// The name of the engine that this option can be applied to.
        public let engineName: String?
        /// Indicates the major engine version that the option is available for.
        public let majorEngineVersion: String?
        /// The minimum required engine version for the option to be applied.
        public let minimumRequiredMinorEngineVersion: String?
        /// The name of the option.
        public let name: String?
        /// The option settings that are available (and the default value) for each option in an option group.
        @OptionalCustomCoding<ArrayCoder<_OptionGroupOptionSettingsEncoding, OptionGroupOptionSetting>>
        public var optionGroupOptionSettings: [OptionGroupOptionSetting]?
        /// The versions that are available for the option.
        @OptionalCustomCoding<ArrayCoder<_OptionGroupOptionVersionsEncoding, OptionVersion>>
        public var optionGroupOptionVersions: [OptionVersion]?
        /// The options that conflict with this option.
        @OptionalCustomCoding<ArrayCoder<_OptionsConflictsWithEncoding, String>>
        public var optionsConflictsWith: [String]?
        /// The options that are prerequisites for this option.
        @OptionalCustomCoding<ArrayCoder<_OptionsDependedOnEncoding, String>>
        public var optionsDependedOn: [String]?
        /// Permanent options can never be removed from an option group. An option group containing a permanent option can't be removed from a DB instance.
        public let permanent: Bool?
        /// Persistent options can't be removed from an option group while DB instances are associated with the option group. If you disassociate all DB instances from the option group, your can remove the persistent option from the option group.
        public let persistent: Bool?
        /// Indicates whether the option requires a port.
        public let portRequired: Bool?
        /// If true, you must enable the Auto Minor Version Upgrade setting for your DB instance  before you can use this option. You can enable Auto Minor Version Upgrade when you first create your DB instance, or by modifying your DB instance later.
        public let requiresAutoMinorEngineVersionUpgrade: Bool?
        /// If true, you can change the option to an earlier version of the option.   This only applies to options that have different versions available.
        public let supportsOptionVersionDowngrade: Bool?
        /// If true, you can only use this option with a DB instance that is in a VPC.
        public let vpcOnly: Bool?

        public init(copyableCrossAccount: Bool? = nil, defaultPort: Int? = nil, description: String? = nil, engineName: String? = nil, majorEngineVersion: String? = nil, minimumRequiredMinorEngineVersion: String? = nil, name: String? = nil, optionGroupOptionSettings: [OptionGroupOptionSetting]? = nil, optionGroupOptionVersions: [OptionVersion]? = nil, optionsConflictsWith: [String]? = nil, optionsDependedOn: [String]? = nil, permanent: Bool? = nil, persistent: Bool? = nil, portRequired: Bool? = nil, requiresAutoMinorEngineVersionUpgrade: Bool? = nil, supportsOptionVersionDowngrade: Bool? = nil, vpcOnly: Bool? = nil) {
            self.copyableCrossAccount = copyableCrossAccount
            self.defaultPort = defaultPort
            self.description = description
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion
            self.name = name
            self.optionGroupOptionSettings = optionGroupOptionSettings
            self.optionGroupOptionVersions = optionGroupOptionVersions
            self.optionsConflictsWith = optionsConflictsWith
            self.optionsDependedOn = optionsDependedOn
            self.permanent = permanent
            self.persistent = persistent
            self.portRequired = portRequired
            self.requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgrade
            self.supportsOptionVersionDowngrade = supportsOptionVersionDowngrade
            self.vpcOnly = vpcOnly
        }

        private enum CodingKeys: String, CodingKey {
            case copyableCrossAccount = "CopyableCrossAccount"
            case defaultPort = "DefaultPort"
            case description = "Description"
            case engineName = "EngineName"
            case majorEngineVersion = "MajorEngineVersion"
            case minimumRequiredMinorEngineVersion = "MinimumRequiredMinorEngineVersion"
            case name = "Name"
            case optionGroupOptionSettings = "OptionGroupOptionSettings"
            case optionGroupOptionVersions = "OptionGroupOptionVersions"
            case optionsConflictsWith = "OptionsConflictsWith"
            case optionsDependedOn = "OptionsDependedOn"
            case permanent = "Permanent"
            case persistent = "Persistent"
            case portRequired = "PortRequired"
            case requiresAutoMinorEngineVersionUpgrade = "RequiresAutoMinorEngineVersionUpgrade"
            case supportsOptionVersionDowngrade = "SupportsOptionVersionDowngrade"
            case vpcOnly = "VpcOnly"
        }
    }

    public struct OptionGroupOptionSetting: AWSDecodableShape {
        public struct _MinimumEngineVersionPerAllowedValueEncoding: ArrayCoderProperties { public static let member = "MinimumEngineVersionPerAllowedValue" }

        /// Indicates the acceptable values for the option group option.
        public let allowedValues: String?
        /// The DB engine specific parameter type for the option group option.
        public let applyType: String?
        /// The default value for the option group option.
        public let defaultValue: String?
        /// Indicates whether this option group option can be changed from the default value.
        public let isModifiable: Bool?
        /// Indicates whether a value must be specified for this option setting of the option group option.
        public let isRequired: Bool?
        /// The minimum DB engine version required for the corresponding allowed value for this option setting.
        @OptionalCustomCoding<ArrayCoder<_MinimumEngineVersionPerAllowedValueEncoding, MinimumEngineVersionPerAllowedValue>>
        public var minimumEngineVersionPerAllowedValue: [MinimumEngineVersionPerAllowedValue]?
        /// The description of the option group option.
        public let settingDescription: String?
        /// The name of the option group option.
        public let settingName: String?

        public init(allowedValues: String? = nil, applyType: String? = nil, defaultValue: String? = nil, isModifiable: Bool? = nil, isRequired: Bool? = nil, minimumEngineVersionPerAllowedValue: [MinimumEngineVersionPerAllowedValue]? = nil, settingDescription: String? = nil, settingName: String? = nil) {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.defaultValue = defaultValue
            self.isModifiable = isModifiable
            self.isRequired = isRequired
            self.minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue
            self.settingDescription = settingDescription
            self.settingName = settingName
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case applyType = "ApplyType"
            case defaultValue = "DefaultValue"
            case isModifiable = "IsModifiable"
            case isRequired = "IsRequired"
            case minimumEngineVersionPerAllowedValue = "MinimumEngineVersionPerAllowedValue"
            case settingDescription = "SettingDescription"
            case settingName = "SettingName"
        }
    }

    public struct OptionGroupOptionsMessage: AWSDecodableShape {
        public struct _OptionGroupOptionsEncoding: ArrayCoderProperties { public static let member = "OptionGroupOption" }

        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        @OptionalCustomCoding<ArrayCoder<_OptionGroupOptionsEncoding, OptionGroupOption>>
        public var optionGroupOptions: [OptionGroupOption]?

        public init(marker: String? = nil, optionGroupOptions: [OptionGroupOption]? = nil) {
            self.marker = marker
            self.optionGroupOptions = optionGroupOptions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case optionGroupOptions = "OptionGroupOptions"
        }
    }

    public struct OptionGroups: AWSDecodableShape {
        public struct _OptionGroupsListEncoding: ArrayCoderProperties { public static let member = "OptionGroup" }

        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// List of option groups.
        @OptionalCustomCoding<ArrayCoder<_OptionGroupsListEncoding, OptionGroup>>
        public var optionGroupsList: [OptionGroup]?

        public init(marker: String? = nil, optionGroupsList: [OptionGroup]? = nil) {
            self.marker = marker
            self.optionGroupsList = optionGroupsList
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case optionGroupsList = "OptionGroupsList"
        }
    }

    public struct OptionSetting: AWSEncodableShape & AWSDecodableShape {
        /// The allowed values of the option setting.
        public let allowedValues: String?
        /// The DB engine specific parameter type.
        public let applyType: String?
        /// The data type of the option setting.
        public let dataType: String?
        /// The default value of the option setting.
        public let defaultValue: String?
        /// The description of the option setting.
        public let description: String?
        /// Indicates whether the option setting is part of a collection.
        public let isCollection: Bool?
        /// Indicates whether the option setting can be modified from the default.
        public let isModifiable: Bool?
        /// The name of the option that has settings that you can set.
        public let name: String?
        /// The current value of the option setting.
        public let value: String?

        public init(allowedValues: String? = nil, applyType: String? = nil, dataType: String? = nil, defaultValue: String? = nil, description: String? = nil, isCollection: Bool? = nil, isModifiable: Bool? = nil, name: String? = nil, value: String? = nil) {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.isCollection = isCollection
            self.isModifiable = isModifiable
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case applyType = "ApplyType"
            case dataType = "DataType"
            case defaultValue = "DefaultValue"
            case description = "Description"
            case isCollection = "IsCollection"
            case isModifiable = "IsModifiable"
            case name = "Name"
            case value = "Value"
        }
    }

    public struct OptionVersion: AWSDecodableShape {
        /// Indicates whether the version is the default version of the option.
        public let isDefault: Bool?
        /// The version of the option.
        public let version: String?

        public init(isDefault: Bool? = nil, version: String? = nil) {
            self.isDefault = isDefault
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case isDefault = "IsDefault"
            case version = "Version"
        }
    }

    public struct OrderableDBInstanceOption: AWSDecodableShape {
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }
        public struct _AvailableProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "AvailableProcessorFeature" }

        /// The Availability Zone group for a DB instance.
        public let availabilityZoneGroup: String?
        /// A list of Availability Zones for a DB instance.
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, AvailabilityZone>>
        public var availabilityZones: [AvailabilityZone]?
        /// A list of the available processor features for the DB instance class of a DB instance.
        @OptionalCustomCoding<ArrayCoder<_AvailableProcessorFeaturesEncoding, AvailableProcessorFeature>>
        public var availableProcessorFeatures: [AvailableProcessorFeature]?
        /// The DB instance class for a DB instance.
        public let dbInstanceClass: String?
        /// The engine type of a DB instance.
        public let engine: String?
        /// The engine version of a DB instance.
        public let engineVersion: String?
        /// The license model for a DB instance.
        public let licenseModel: String?
        /// Maximum total provisioned IOPS for a DB instance.
        public let maxIopsPerDbInstance: Int?
        /// Maximum provisioned IOPS per GiB for a DB instance.
        public let maxIopsPerGib: Double?
        /// Maximum storage size for a DB instance.
        public let maxStorageSize: Int?
        /// Maximum storage throughput for a DB instance.
        public let maxStorageThroughputPerDbInstance: Int?
        /// Maximum storage throughput to provisioned IOPS ratio for a DB instance.
        public let maxStorageThroughputPerIops: Double?
        /// Minimum total provisioned IOPS for a DB instance.
        public let minIopsPerDbInstance: Int?
        /// Minimum provisioned IOPS per GiB for a DB instance.
        public let minIopsPerGib: Double?
        /// Minimum storage size for a DB instance.
        public let minStorageSize: Int?
        /// Minimum storage throughput for a DB instance.
        public let minStorageThroughputPerDbInstance: Int?
        /// Minimum storage throughput to provisioned IOPS ratio for a DB instance.
        public let minStorageThroughputPerIops: Double?
        /// Indicates whether a DB instance is Multi-AZ capable.
        public let multiAZCapable: Bool?
        /// Indicates whether a DB instance supports RDS on Outposts. For more information about RDS on Outposts, see Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide.
        public let outpostCapable: Bool?
        /// Indicates whether a DB instance can have a read replica.
        public let readReplicaCapable: Bool?
        /// The storage type for a DB instance.
        public let storageType: String?
        /// The list of supported modes for Database Activity Streams. Aurora PostgreSQL returns the value [sync, async]. Aurora MySQL and RDS for Oracle return [async] only. If Database Activity Streams  isn't supported, the return value is an empty list.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedActivityStreamModes: [String]?
        /// A list of the supported DB engine modes.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedEngineModes: [String]?
        /// The network types supported by the DB instance (IPV4 or DUAL). A DB instance can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedNetworkTypes: [String]?
        /// Indicates whether DB instances can be configured as a Multi-AZ DB cluster. For more information on Multi-AZ DB clusters, see   Multi-AZ deployments with two readable standby DB instances in the Amazon RDS User Guide.
        public let supportsClusters: Bool?
        /// Indicates whether a DB instance supports using a dedicated log volume (DLV).
        public let supportsDedicatedLogVolume: Bool?
        /// Indicates whether a DB instance supports Enhanced Monitoring at intervals from 1 to 60 seconds.
        public let supportsEnhancedMonitoring: Bool?
        /// Indicates whether you can use Aurora global databases with a specific combination of other DB engine attributes.
        public let supportsGlobalDatabases: Bool?
        /// Indicates whether a DB instance supports IAM database authentication.
        public let supportsIAMDatabaseAuthentication: Bool?
        /// Indicates whether a DB instance supports provisioned IOPS.
        public let supportsIops: Bool?
        /// Indicates whether a DB instance supports Kerberos Authentication.
        public let supportsKerberosAuthentication: Bool?
        /// Indicates whether a DB instance supports Performance Insights.
        public let supportsPerformanceInsights: Bool?
        /// Indicates whether Amazon RDS can automatically scale storage for DB instances that use the specified DB instance class.
        public let supportsStorageAutoscaling: Bool?
        /// Indicates whether a DB instance supports encrypted storage.
        public let supportsStorageEncryption: Bool?
        /// Indicates whether a DB instance supports storage throughput.
        public let supportsStorageThroughput: Bool?
        /// Indicates whether a DB instance is in a VPC.
        public let vpc: Bool?

        public init(availabilityZoneGroup: String? = nil, availabilityZones: [AvailabilityZone]? = nil, availableProcessorFeatures: [AvailableProcessorFeature]? = nil, dbInstanceClass: String? = nil, engine: String? = nil, engineVersion: String? = nil, licenseModel: String? = nil, maxIopsPerDbInstance: Int? = nil, maxIopsPerGib: Double? = nil, maxStorageSize: Int? = nil, maxStorageThroughputPerDbInstance: Int? = nil, maxStorageThroughputPerIops: Double? = nil, minIopsPerDbInstance: Int? = nil, minIopsPerGib: Double? = nil, minStorageSize: Int? = nil, minStorageThroughputPerDbInstance: Int? = nil, minStorageThroughputPerIops: Double? = nil, multiAZCapable: Bool? = nil, outpostCapable: Bool? = nil, readReplicaCapable: Bool? = nil, storageType: String? = nil, supportedActivityStreamModes: [String]? = nil, supportedEngineModes: [String]? = nil, supportedNetworkTypes: [String]? = nil, supportsClusters: Bool? = nil, supportsDedicatedLogVolume: Bool? = nil, supportsEnhancedMonitoring: Bool? = nil, supportsGlobalDatabases: Bool? = nil, supportsIAMDatabaseAuthentication: Bool? = nil, supportsIops: Bool? = nil, supportsKerberosAuthentication: Bool? = nil, supportsPerformanceInsights: Bool? = nil, supportsStorageAutoscaling: Bool? = nil, supportsStorageEncryption: Bool? = nil, supportsStorageThroughput: Bool? = nil, vpc: Bool? = nil) {
            self.availabilityZoneGroup = availabilityZoneGroup
            self.availabilityZones = availabilityZones
            self.availableProcessorFeatures = availableProcessorFeatures
            self.dbInstanceClass = dbInstanceClass
            self.engine = engine
            self.engineVersion = engineVersion
            self.licenseModel = licenseModel
            self.maxIopsPerDbInstance = maxIopsPerDbInstance
            self.maxIopsPerGib = maxIopsPerGib
            self.maxStorageSize = maxStorageSize
            self.maxStorageThroughputPerDbInstance = maxStorageThroughputPerDbInstance
            self.maxStorageThroughputPerIops = maxStorageThroughputPerIops
            self.minIopsPerDbInstance = minIopsPerDbInstance
            self.minIopsPerGib = minIopsPerGib
            self.minStorageSize = minStorageSize
            self.minStorageThroughputPerDbInstance = minStorageThroughputPerDbInstance
            self.minStorageThroughputPerIops = minStorageThroughputPerIops
            self.multiAZCapable = multiAZCapable
            self.outpostCapable = outpostCapable
            self.readReplicaCapable = readReplicaCapable
            self.storageType = storageType
            self.supportedActivityStreamModes = supportedActivityStreamModes
            self.supportedEngineModes = supportedEngineModes
            self.supportedNetworkTypes = supportedNetworkTypes
            self.supportsClusters = supportsClusters
            self.supportsDedicatedLogVolume = supportsDedicatedLogVolume
            self.supportsEnhancedMonitoring = supportsEnhancedMonitoring
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthentication
            self.supportsIops = supportsIops
            self.supportsKerberosAuthentication = supportsKerberosAuthentication
            self.supportsPerformanceInsights = supportsPerformanceInsights
            self.supportsStorageAutoscaling = supportsStorageAutoscaling
            self.supportsStorageEncryption = supportsStorageEncryption
            self.supportsStorageThroughput = supportsStorageThroughput
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneGroup = "AvailabilityZoneGroup"
            case availabilityZones = "AvailabilityZones"
            case availableProcessorFeatures = "AvailableProcessorFeatures"
            case dbInstanceClass = "DBInstanceClass"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case licenseModel = "LicenseModel"
            case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
            case maxIopsPerGib = "MaxIopsPerGib"
            case maxStorageSize = "MaxStorageSize"
            case maxStorageThroughputPerDbInstance = "MaxStorageThroughputPerDbInstance"
            case maxStorageThroughputPerIops = "MaxStorageThroughputPerIops"
            case minIopsPerDbInstance = "MinIopsPerDbInstance"
            case minIopsPerGib = "MinIopsPerGib"
            case minStorageSize = "MinStorageSize"
            case minStorageThroughputPerDbInstance = "MinStorageThroughputPerDbInstance"
            case minStorageThroughputPerIops = "MinStorageThroughputPerIops"
            case multiAZCapable = "MultiAZCapable"
            case outpostCapable = "OutpostCapable"
            case readReplicaCapable = "ReadReplicaCapable"
            case storageType = "StorageType"
            case supportedActivityStreamModes = "SupportedActivityStreamModes"
            case supportedEngineModes = "SupportedEngineModes"
            case supportedNetworkTypes = "SupportedNetworkTypes"
            case supportsClusters = "SupportsClusters"
            case supportsDedicatedLogVolume = "SupportsDedicatedLogVolume"
            case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
            case supportsGlobalDatabases = "SupportsGlobalDatabases"
            case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
            case supportsIops = "SupportsIops"
            case supportsKerberosAuthentication = "SupportsKerberosAuthentication"
            case supportsPerformanceInsights = "SupportsPerformanceInsights"
            case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
            case supportsStorageEncryption = "SupportsStorageEncryption"
            case supportsStorageThroughput = "SupportsStorageThroughput"
            case vpc = "Vpc"
        }
    }

    public struct OrderableDBInstanceOptionsMessage: AWSDecodableShape {
        public struct _OrderableDBInstanceOptionsEncoding: ArrayCoderProperties { public static let member = "OrderableDBInstanceOption" }

        /// An optional pagination token provided by a previous  OrderableDBInstanceOptions request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// An OrderableDBInstanceOption structure containing information about orderable options for the DB instance.
        @OptionalCustomCoding<ArrayCoder<_OrderableDBInstanceOptionsEncoding, OrderableDBInstanceOption>>
        public var orderableDBInstanceOptions: [OrderableDBInstanceOption]?

        public init(marker: String? = nil, orderableDBInstanceOptions: [OrderableDBInstanceOption]? = nil) {
            self.marker = marker
            self.orderableDBInstanceOptions = orderableDBInstanceOptions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case orderableDBInstanceOptions = "OrderableDBInstanceOptions"
        }
    }

    public struct Outpost: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Outpost.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct Parameter: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the valid range of values for the parameter.
        public let allowedValues: String?
        /// Indicates when to apply parameter updates.
        public let applyMethod: ApplyMethod?
        /// Specifies the engine specific parameters type.
        public let applyType: String?
        /// Specifies the valid data type for the parameter.
        public let dataType: String?
        /// Provides a description of the parameter.
        public let description: String?
        /// Indicates whether (true) or not (false) the parameter can be modified. Some parameters have security or operational implications that prevent them from being changed.
        public let isModifiable: Bool?
        /// The earliest engine version to which the parameter can apply.
        public let minimumEngineVersion: String?
        /// The name of the parameter.
        public let parameterName: String?
        /// The value of the parameter.
        public let parameterValue: String?
        /// The source of the parameter value.
        public let source: String?
        /// The valid DB engine modes.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedEngineModes: [String]?

        public init(allowedValues: String? = nil, applyMethod: ApplyMethod? = nil, applyType: String? = nil, dataType: String? = nil, description: String? = nil, isModifiable: Bool? = nil, minimumEngineVersion: String? = nil, parameterName: String? = nil, parameterValue: String? = nil, source: String? = nil, supportedEngineModes: [String]? = nil) {
            self.allowedValues = allowedValues
            self.applyMethod = applyMethod
            self.applyType = applyType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.minimumEngineVersion = minimumEngineVersion
            self.parameterName = parameterName
            self.parameterValue = parameterValue
            self.source = source
            self.supportedEngineModes = supportedEngineModes
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case applyMethod = "ApplyMethod"
            case applyType = "ApplyType"
            case dataType = "DataType"
            case description = "Description"
            case isModifiable = "IsModifiable"
            case minimumEngineVersion = "MinimumEngineVersion"
            case parameterName = "ParameterName"
            case parameterValue = "ParameterValue"
            case source = "Source"
            case supportedEngineModes = "SupportedEngineModes"
        }
    }

    public struct PendingCloudwatchLogsExports: AWSDecodableShape {
        /// Log types that are in the process of being enabled. After they are enabled, these log types are exported to CloudWatch Logs.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var logTypesToDisable: [String]?
        /// Log types that are in the process of being deactivated. After they are deactivated, these log types aren't exported to CloudWatch Logs.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var logTypesToEnable: [String]?

        public init(logTypesToDisable: [String]? = nil, logTypesToEnable: [String]? = nil) {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }

        private enum CodingKeys: String, CodingKey {
            case logTypesToDisable = "LogTypesToDisable"
            case logTypesToEnable = "LogTypesToEnable"
        }
    }

    public struct PendingMaintenanceAction: AWSDecodableShape {
        /// The type of pending maintenance action that is available for the resource.  Valid actions are system-update, db-upgrade, hardware-maintenance,  and ca-certificate-rotation.
        public let action: String?
        /// The date of the maintenance window when the action is applied. The maintenance action is applied to the resource during its first maintenance window after this date.
        public let autoAppliedAfterDate: Date?
        /// The effective date when the pending maintenance action is applied  to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API, the AutoAppliedAfterDate, and the ForcedApplyDate. This value is blank if an  opt-in request has not been received and nothing has been specified as AutoAppliedAfterDate or ForcedApplyDate.
        public let currentApplyDate: Date?
        /// A description providing more detail about the maintenance action.
        public let description: String?
        /// The date when the maintenance action is automatically applied. On this date, the maintenance action is applied to the resource as soon as possible,  regardless of the maintenance window for the resource. There might be a delay of  one or more days from this date before the maintenance action is applied.
        public let forcedApplyDate: Date?
        /// Indicates the type of opt-in request that has been received for the resource.
        public let optInStatus: String?

        public init(action: String? = nil, autoAppliedAfterDate: Date? = nil, currentApplyDate: Date? = nil, description: String? = nil, forcedApplyDate: Date? = nil, optInStatus: String? = nil) {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case autoAppliedAfterDate = "AutoAppliedAfterDate"
            case currentApplyDate = "CurrentApplyDate"
            case description = "Description"
            case forcedApplyDate = "ForcedApplyDate"
            case optInStatus = "OptInStatus"
        }
    }

    public struct PendingMaintenanceActionsMessage: AWSDecodableShape {
        public struct _PendingMaintenanceActionsEncoding: ArrayCoderProperties { public static let member = "ResourcePendingMaintenanceActions" }

        /// An optional pagination token provided by a previous DescribePendingMaintenanceActions request. If this parameter is specified, the response includes only records beyond the marker, up to a number of records specified by MaxRecords.
        public let marker: String?
        /// A list of the pending maintenance actions for the resource.
        @OptionalCustomCoding<ArrayCoder<_PendingMaintenanceActionsEncoding, ResourcePendingMaintenanceActions>>
        public var pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

        public init(marker: String? = nil, pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil) {
            self.marker = marker
            self.pendingMaintenanceActions = pendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case pendingMaintenanceActions = "PendingMaintenanceActions"
        }
    }

    public struct PendingModifiedValues: AWSDecodableShape {
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }

        /// The allocated storage size for the DB instance specified in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// The automation mode of the RDS Custom DB instance: full or all-paused.  If full, the DB instance automates monitoring and instance recovery. If  all-paused, the instance pauses automation for the duration set by  --resume-full-automation-mode-minutes.
        public let automationMode: AutomationMode?
        /// The number of days for which automated backups are retained.
        public let backupRetentionPeriod: Int?
        /// The identifier of the CA certificate for the DB instance. For more information, see Using SSL/TLS to encrypt a connection to a DB  instance in the Amazon RDS User Guide and   Using SSL/TLS to encrypt a connection to a DB cluster in the Amazon Aurora  User Guide.
        public let caCertificateIdentifier: String?
        /// The name of the compute and memory capacity class for the DB instance.
        public let dbInstanceClass: String?
        /// The  database identifier for the DB instance.
        public let dbInstanceIdentifier: String?
        /// The DB subnet group for the DB instance.
        public let dbSubnetGroupName: String?
        /// Indicates whether the DB instance has a dedicated log volume (DLV) enabled.>
        public let dedicatedLogVolume: Bool?
        /// The database engine of the DB instance.
        public let engine: String?
        /// The database engine version.
        public let engineVersion: String?
        /// Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The Provisioned IOPS value for the DB instance.
        public let iops: Int?
        /// The license model for the DB instance. Valid values: license-included | bring-your-own-license |  general-public-license
        public let licenseModel: String?
        /// The master credentials for the DB instance.
        public let masterUserPassword: String?
        /// Indicates whether the Single-AZ DB instance will change to a Multi-AZ deployment.
        public let multiAZ: Bool?
        /// Indicates whether the DB instance will change to the multi-tenant configuration (TRUE) or the single-tenant configuration (FALSE).
        public let multiTenant: Bool?
        public let pendingCloudwatchLogsExports: PendingCloudwatchLogsExports?
        /// The port for the DB instance.
        public let port: Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// The number of minutes to pause the automation. When the time period ends, RDS Custom resumes full automation.  The minimum value is 60 (default). The maximum value is 1,440.
        public let resumeFullAutomationModeTime: Date?
        /// The storage throughput of the DB instance.
        public let storageThroughput: Int?
        /// The storage type of the DB instance.
        public let storageType: String?

        public init(allocatedStorage: Int? = nil, automationMode: AutomationMode? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbSubnetGroupName: String? = nil, dedicatedLogVolume: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, iops: Int? = nil, licenseModel: String? = nil, masterUserPassword: String? = nil, multiAZ: Bool? = nil, multiTenant: Bool? = nil, pendingCloudwatchLogsExports: PendingCloudwatchLogsExports? = nil, port: Int? = nil, processorFeatures: [ProcessorFeature]? = nil, resumeFullAutomationModeTime: Date? = nil, storageThroughput: Int? = nil, storageType: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.automationMode = automationMode
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dedicatedLogVolume = dedicatedLogVolume
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.multiTenant = multiTenant
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.resumeFullAutomationModeTime = resumeFullAutomationModeTime
            self.storageThroughput = storageThroughput
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case automationMode = "AutomationMode"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case iops = "Iops"
            case licenseModel = "LicenseModel"
            case masterUserPassword = "MasterUserPassword"
            case multiAZ = "MultiAZ"
            case multiTenant = "MultiTenant"
            case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case resumeFullAutomationModeTime = "ResumeFullAutomationModeTime"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
        }
    }

    public struct PerformanceInsightsMetricDimensionGroup: AWSDecodableShape {
        /// A list of specific dimensions from a dimension group. If this list isn't included, then all of the dimensions in the group were requested, or are present in the response.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var dimensions: [String]?
        /// The available dimension groups for Performance Insights metric type.
        public let group: String?
        /// The maximum number of items to fetch for this dimension group.
        public let limit: Int?

        public init(dimensions: [String]? = nil, group: String? = nil, limit: Int? = nil) {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case group = "Group"
            case limit = "Limit"
        }
    }

    public struct PerformanceInsightsMetricQuery: AWSDecodableShape {
        /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights will return all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public let groupBy: PerformanceInsightsMetricDimensionGroup?
        /// The name of a Performance Insights metric to be measured. Valid Values:    db.load.avg - A scaled representation of the number of active sessions for the  database engine.    db.sampledload.avg - The raw number of active sessions for the database engine.   The counter metrics listed in Performance Insights operating system counters in the Amazon Aurora User Guide.   If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg  and db.sampledload.avg are the same value. If the number of active sessions is greater than the  internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        public let metric: String?

        public init(groupBy: PerformanceInsightsMetricDimensionGroup? = nil, metric: String? = nil) {
            self.groupBy = groupBy
            self.metric = metric
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case metric = "Metric"
        }
    }

    public struct PerformanceIssueDetails: AWSDecodableShape {
        /// The analysis of the performance issue. The information might contain markdown.
        public let analysis: String?
        /// The time when the performance issue stopped.
        public let endTime: Date?
        /// The metrics that are relevant to the performance issue.
        @OptionalCustomCoding<StandardArrayCoder<Metric>>
        public var metrics: [Metric]?
        /// The time when the performance issue started.
        public let startTime: Date?

        public init(analysis: String? = nil, endTime: Date? = nil, metrics: [Metric]? = nil, startTime: Date? = nil) {
            self.analysis = analysis
            self.endTime = endTime
            self.metrics = metrics
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case endTime = "EndTime"
            case metrics = "Metrics"
            case startTime = "StartTime"
        }
    }

    public struct ProcessorFeature: AWSEncodableShape & AWSDecodableShape {
        /// The name of the processor feature. Valid names are coreCount and threadsPerCore.
        public let name: String?
        /// The value of a processor feature name.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct PromoteReadReplicaDBClusterMessage: AWSEncodableShape {
        /// The identifier of the DB cluster read replica to promote. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing DB cluster read replica.   Example: my-cluster-replica1
        public let dbClusterIdentifier: String?

        public init(dbClusterIdentifier: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
        }
    }

    public struct PromoteReadReplicaDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct PromoteReadReplicaMessage: AWSEncodableShape {
        /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. Default: 1 Constraints:   Must be a value from 0 to 35.   Can't be set to 0 if the DB instance is a source to read replicas.
        public let backupRetentionPeriod: Int?
        /// The DB instance identifier. This value is stored as a lowercase string. Constraints:   Must match the identifier of an existing read replica DB instance.   Example: mydbinstance
        public let dbInstanceIdentifier: String?
        /// The daily time range during which automated backups are created if automated backups are enabled, using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region.  To see the time blocks available, see   Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.  Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?

        public init(backupRetentionPeriod: Int? = nil, dbInstanceIdentifier: String? = nil, preferredBackupWindow: String? = nil) {
            self.backupRetentionPeriod = backupRetentionPeriod
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.preferredBackupWindow = preferredBackupWindow
        }

        private enum CodingKeys: String, CodingKey {
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case preferredBackupWindow = "PreferredBackupWindow"
        }
    }

    public struct PromoteReadReplicaResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct PurchaseReservedDBInstancesOfferingMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The number of instances to reserve. Default: 1
        public let dbInstanceCount: Int?
        /// Customer-specified identifier to track this reservation. Example: myreservationID
        public let reservedDBInstanceId: String?
        /// The ID of the Reserved DB instance offering to purchase. Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706
        public let reservedDBInstancesOfferingId: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?

        public init(dbInstanceCount: Int? = nil, reservedDBInstanceId: String? = nil, reservedDBInstancesOfferingId: String? = nil, tags: [Tag]? = nil) {
            self.dbInstanceCount = dbInstanceCount
            self.reservedDBInstanceId = reservedDBInstanceId
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceCount = "DBInstanceCount"
            case reservedDBInstanceId = "ReservedDBInstanceId"
            case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
            case tags = "Tags"
        }
    }

    public struct PurchaseReservedDBInstancesOfferingResult: AWSDecodableShape {
        public let reservedDBInstance: ReservedDBInstance?

        public init(reservedDBInstance: ReservedDBInstance? = nil) {
            self.reservedDBInstance = reservedDBInstance
        }

        private enum CodingKeys: String, CodingKey {
            case reservedDBInstance = "ReservedDBInstance"
        }
    }

    public struct Range: AWSDecodableShape {
        /// The minimum value in the range.
        public let from: Int?
        /// The step value for the range. For example, if you have a range of 5,000 to 10,000, with a step value of 1,000, the valid values start at 5,000 and step up by 1,000. Even though 7,500 is within the range, it isn't a valid value for the range. The valid values are 5,000, 6,000, 7,000, 8,000...
        public let step: Int?
        /// The maximum value in the range.
        public let to: Int?

        public init(from: Int? = nil, step: Int? = nil, to: Int? = nil) {
            self.from = from
            self.step = step
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case step = "Step"
            case to = "To"
        }
    }

    public struct RdsCustomClusterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Reserved for future use.
        public let interconnectSubnetId: String?
        /// Reserved for future use.
        public let replicaMode: ReplicaMode?
        /// Reserved for future use.
        public let transitGatewayMulticastDomainId: String?

        public init(interconnectSubnetId: String? = nil, replicaMode: ReplicaMode? = nil, transitGatewayMulticastDomainId: String? = nil) {
            self.interconnectSubnetId = interconnectSubnetId
            self.replicaMode = replicaMode
            self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectSubnetId = "InterconnectSubnetId"
            case replicaMode = "ReplicaMode"
            case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
        }
    }

    public struct RebootDBClusterMessage: AWSEncodableShape {
        /// The DB cluster identifier. This parameter is stored as a lowercase string. Constraints:   Must match the identifier of an existing DBCluster.
        public let dbClusterIdentifier: String?

        public init(dbClusterIdentifier: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
        }
    }

    public struct RebootDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct RebootDBInstanceMessage: AWSEncodableShape {
        /// The DB instance identifier. This parameter is stored as a lowercase string. Constraints:   Must match the identifier of an existing DBInstance.
        public let dbInstanceIdentifier: String?
        /// Specifies whether the reboot is conducted through a Multi-AZ failover. Constraint: You can't enable force failover if the instance isn't configured for Multi-AZ.
        public let forceFailover: Bool?

        public init(dbInstanceIdentifier: String? = nil, forceFailover: Bool? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.forceFailover = forceFailover
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case forceFailover = "ForceFailover"
        }
    }

    public struct RebootDBInstanceResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct RebootDBShardGroupMessage: AWSEncodableShape {
        /// The name of the DB shard group to reboot.
        public let dbShardGroupIdentifier: String?

        public init(dbShardGroupIdentifier: String? = nil) {
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, max: 63)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, min: 1)
            try self.validate(self.dbShardGroupIdentifier, name: "dbShardGroupIdentifier", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbShardGroupIdentifier = "DBShardGroupIdentifier"
        }
    }

    public struct RecommendedAction: AWSDecodableShape {
        /// The unique identifier of the recommended action.
        public let actionId: String?
        /// The methods to apply the recommended action. Valid values:    manual - The action requires you to resolve the recommendation manually.    immediately - The action is applied immediately.    next-maintainance-window - The action is applied during the next scheduled maintainance.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var applyModes: [String]?
        /// The supporting attributes to explain the recommended action.
        @OptionalCustomCoding<StandardArrayCoder<ContextAttribute>>
        public var contextAttributes: [ContextAttribute]?
        /// A detailed description of the action. The description might contain markdown.
        public let description: String?
        /// The details of the issue.
        public let issueDetails: IssueDetails?
        /// An API operation for the action.
        public let operation: String?
        /// The parameters for the API operation.
        @OptionalCustomCoding<StandardArrayCoder<RecommendedActionParameter>>
        public var parameters: [RecommendedActionParameter]?
        /// The status of the action.    ready     applied     scheduled     resolved
        public let status: String?
        /// A short description to summarize the action. The description might contain markdown.
        public let title: String?

        public init(actionId: String? = nil, applyModes: [String]? = nil, contextAttributes: [ContextAttribute]? = nil, description: String? = nil, issueDetails: IssueDetails? = nil, operation: String? = nil, parameters: [RecommendedActionParameter]? = nil, status: String? = nil, title: String? = nil) {
            self.actionId = actionId
            self.applyModes = applyModes
            self.contextAttributes = contextAttributes
            self.description = description
            self.issueDetails = issueDetails
            self.operation = operation
            self.parameters = parameters
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "ActionId"
            case applyModes = "ApplyModes"
            case contextAttributes = "ContextAttributes"
            case description = "Description"
            case issueDetails = "IssueDetails"
            case operation = "Operation"
            case parameters = "Parameters"
            case status = "Status"
            case title = "Title"
        }
    }

    public struct RecommendedActionParameter: AWSDecodableShape {
        /// The key of the parameter to use with the RecommendedAction API operation.
        public let key: String?
        /// The value of the parameter to use with the RecommendedAction API operation.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct RecommendedActionUpdate: AWSEncodableShape {
        /// A unique identifier of the updated recommendation action.
        public let actionId: String?
        /// The status of the updated recommendation action.    applied     scheduled
        public let status: String?

        public init(actionId: String? = nil, status: String? = nil) {
            self.actionId = actionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "ActionId"
            case status = "Status"
        }
    }

    public struct RecurringCharge: AWSDecodableShape {
        /// The amount of the recurring charge.
        public let recurringChargeAmount: Double?
        /// The frequency of the recurring charge.
        public let recurringChargeFrequency: String?

        public init(recurringChargeAmount: Double? = nil, recurringChargeFrequency: String? = nil) {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case recurringChargeAmount = "RecurringChargeAmount"
            case recurringChargeFrequency = "RecurringChargeFrequency"
        }
    }

    public struct ReferenceDetails: AWSDecodableShape {
        /// The metric reference details when the reference is a scalar.
        public let scalarReferenceDetails: ScalarReferenceDetails?

        public init(scalarReferenceDetails: ScalarReferenceDetails? = nil) {
            self.scalarReferenceDetails = scalarReferenceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case scalarReferenceDetails = "ScalarReferenceDetails"
        }
    }

    public struct RegisterDBProxyTargetsRequest: AWSEncodableShape {
        /// One or more DB cluster identifiers.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var dbClusterIdentifiers: [String]?
        /// One or more DB instance identifiers.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var dbInstanceIdentifiers: [String]?
        /// The identifier of the DBProxy that is associated with the DBProxyTargetGroup.
        public let dbProxyName: String?
        /// The identifier of the DBProxyTargetGroup.
        public let targetGroupName: String?

        public init(dbClusterIdentifiers: [String]? = nil, dbInstanceIdentifiers: [String]? = nil, dbProxyName: String? = nil, targetGroupName: String? = nil) {
            self.dbClusterIdentifiers = dbClusterIdentifiers
            self.dbInstanceIdentifiers = dbInstanceIdentifiers
            self.dbProxyName = dbProxyName
            self.targetGroupName = targetGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifiers = "DBClusterIdentifiers"
            case dbInstanceIdentifiers = "DBInstanceIdentifiers"
            case dbProxyName = "DBProxyName"
            case targetGroupName = "TargetGroupName"
        }
    }

    public struct RegisterDBProxyTargetsResponse: AWSDecodableShape {
        /// One or more DBProxyTarget objects that are created when you register targets with a target group.
        @OptionalCustomCoding<StandardArrayCoder<DBProxyTarget>>
        public var dbProxyTargets: [DBProxyTarget]?

        public init(dbProxyTargets: [DBProxyTarget]? = nil) {
            self.dbProxyTargets = dbProxyTargets
        }

        private enum CodingKeys: String, CodingKey {
            case dbProxyTargets = "DBProxyTargets"
        }
    }

    public struct RemoveFromGlobalClusterMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) identifying the cluster that was detached from the Aurora global database cluster.
        public let dbClusterIdentifier: String?
        /// The cluster identifier to detach from the Aurora global database cluster.
        public let globalClusterIdentifier: String?

        public init(dbClusterIdentifier: String? = nil, globalClusterIdentifier: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.globalClusterIdentifier = globalClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DbClusterIdentifier"
            case globalClusterIdentifier = "GlobalClusterIdentifier"
        }
    }

    public struct RemoveFromGlobalClusterResult: AWSDecodableShape {
        public let globalCluster: GlobalCluster?

        public init(globalCluster: GlobalCluster? = nil) {
            self.globalCluster = globalCluster
        }

        private enum CodingKeys: String, CodingKey {
            case globalCluster = "GlobalCluster"
        }
    }

    public struct RemoveRoleFromDBClusterMessage: AWSEncodableShape {
        /// The name of the DB cluster to disassociate the IAM role from.
        public let dbClusterIdentifier: String?
        /// The name of the feature for the DB cluster that the IAM role is to be disassociated from. For information about supported feature names, see DBEngineVersion.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role to disassociate from the Aurora DB cluster, for example arn:aws:iam::123456789012:role/AuroraAccessRole.
        public let roleArn: String?

        public init(dbClusterIdentifier: String? = nil, featureName: String? = nil, roleArn: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.featureName = featureName
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
        }
    }

    public struct RemoveRoleFromDBInstanceMessage: AWSEncodableShape {
        /// The name of the DB instance to disassociate the IAM role from.
        public let dbInstanceIdentifier: String?
        /// The name of the feature for the DB instance that the IAM role is to be disassociated from. For information about supported feature names, see DBEngineVersion.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role to disassociate from the DB instance, for example, arn:aws:iam::123456789012:role/AccessRole.
        public let roleArn: String?

        public init(dbInstanceIdentifier: String? = nil, featureName: String? = nil, roleArn: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.featureName = featureName
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
        }
    }

    public struct RemoveSourceIdentifierFromSubscriptionMessage: AWSEncodableShape {
        /// The source identifier to be removed from the subscription, such as the DB instance identifier  for a DB instance or the name of a security group.
        public let sourceIdentifier: String?
        /// The name of the RDS event notification subscription you want to remove a source identifier from.
        public let subscriptionName: String?

        public init(sourceIdentifier: String? = nil, subscriptionName: String? = nil) {
            self.sourceIdentifier = sourceIdentifier
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case sourceIdentifier = "SourceIdentifier"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct RemoveSourceIdentifierFromSubscriptionResult: AWSDecodableShape {
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct RemoveTagsFromResourceMessage: AWSEncodableShape {
        /// The Amazon RDS resource that the tags are removed from. This value is an Amazon Resource Name (ARN). For information about   creating an ARN,  see  Constructing an ARN for Amazon RDS in the Amazon RDS User Guide.
        public let resourceName: String?
        /// The tag key (name) of the tag to be removed.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var tagKeys: [String]?

        public init(resourceName: String? = nil, tagKeys: [String]? = nil) {
            self.resourceName = resourceName
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "ResourceName"
            case tagKeys = "TagKeys"
        }
    }

    public struct ReservedDBInstance: AWSDecodableShape {
        public struct _RecurringChargesEncoding: ArrayCoderProperties { public static let member = "RecurringCharge" }

        /// The currency code for the reserved DB instance.
        public let currencyCode: String?
        /// The DB instance class for the reserved DB instance.
        public let dbInstanceClass: String?
        /// The number of reserved DB instances.
        public let dbInstanceCount: Int?
        /// The duration of the reservation in seconds.
        public let duration: Int?
        /// The fixed price charged for this reserved DB instance.
        public let fixedPrice: Double?
        /// The unique identifier for the lease associated with the reserved DB instance.  Amazon Web Services Support might request the lease ID for an issue related to a reserved DB instance.
        public let leaseId: String?
        /// Indicates whether the reservation applies to Multi-AZ deployments.
        public let multiAZ: Bool?
        /// The offering type of this reserved DB instance.
        public let offeringType: String?
        /// The description of the reserved DB instance.
        public let productDescription: String?
        /// The recurring price charged to run this reserved DB instance.
        @OptionalCustomCoding<ArrayCoder<_RecurringChargesEncoding, RecurringCharge>>
        public var recurringCharges: [RecurringCharge]?
        /// The Amazon Resource Name (ARN) for the reserved DB instance.
        public let reservedDBInstanceArn: String?
        /// The unique identifier for the reservation.
        public let reservedDBInstanceId: String?
        /// The offering identifier.
        public let reservedDBInstancesOfferingId: String?
        /// The time the reservation started.
        public let startTime: Date?
        /// The state of the reserved DB instance.
        public let state: String?
        /// The hourly price charged for this reserved DB instance.
        public let usagePrice: Double?

        public init(currencyCode: String? = nil, dbInstanceClass: String? = nil, dbInstanceCount: Int? = nil, duration: Int? = nil, fixedPrice: Double? = nil, leaseId: String? = nil, multiAZ: Bool? = nil, offeringType: String? = nil, productDescription: String? = nil, recurringCharges: [RecurringCharge]? = nil, reservedDBInstanceArn: String? = nil, reservedDBInstanceId: String? = nil, reservedDBInstancesOfferingId: String? = nil, startTime: Date? = nil, state: String? = nil, usagePrice: Double? = nil) {
            self.currencyCode = currencyCode
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceCount = dbInstanceCount
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.leaseId = leaseId
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.recurringCharges = recurringCharges
            self.reservedDBInstanceArn = reservedDBInstanceArn
            self.reservedDBInstanceId = reservedDBInstanceId
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceCount = "DBInstanceCount"
            case duration = "Duration"
            case fixedPrice = "FixedPrice"
            case leaseId = "LeaseId"
            case multiAZ = "MultiAZ"
            case offeringType = "OfferingType"
            case productDescription = "ProductDescription"
            case recurringCharges = "RecurringCharges"
            case reservedDBInstanceArn = "ReservedDBInstanceArn"
            case reservedDBInstanceId = "ReservedDBInstanceId"
            case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
            case startTime = "StartTime"
            case state = "State"
            case usagePrice = "UsagePrice"
        }
    }

    public struct ReservedDBInstanceMessage: AWSDecodableShape {
        public struct _ReservedDBInstancesEncoding: ArrayCoderProperties { public static let member = "ReservedDBInstance" }

        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A list of reserved DB instances.
        @OptionalCustomCoding<ArrayCoder<_ReservedDBInstancesEncoding, ReservedDBInstance>>
        public var reservedDBInstances: [ReservedDBInstance]?

        public init(marker: String? = nil, reservedDBInstances: [ReservedDBInstance]? = nil) {
            self.marker = marker
            self.reservedDBInstances = reservedDBInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case reservedDBInstances = "ReservedDBInstances"
        }
    }

    public struct ReservedDBInstancesOffering: AWSDecodableShape {
        public struct _RecurringChargesEncoding: ArrayCoderProperties { public static let member = "RecurringCharge" }

        /// The currency code for the reserved DB instance offering.
        public let currencyCode: String?
        /// The DB instance class for the reserved DB instance.
        public let dbInstanceClass: String?
        /// The duration of the offering in seconds.
        public let duration: Int?
        /// The fixed price charged for this offering.
        public let fixedPrice: Double?
        /// Indicates whether the offering applies to Multi-AZ deployments.
        public let multiAZ: Bool?
        /// The offering type.
        public let offeringType: String?
        /// The database engine used by the offering.
        public let productDescription: String?
        /// The recurring price charged to run this reserved DB instance.
        @OptionalCustomCoding<ArrayCoder<_RecurringChargesEncoding, RecurringCharge>>
        public var recurringCharges: [RecurringCharge]?
        /// The offering identifier.
        public let reservedDBInstancesOfferingId: String?
        /// The hourly price charged for this offering.
        public let usagePrice: Double?

        public init(currencyCode: String? = nil, dbInstanceClass: String? = nil, duration: Int? = nil, fixedPrice: Double? = nil, multiAZ: Bool? = nil, offeringType: String? = nil, productDescription: String? = nil, recurringCharges: [RecurringCharge]? = nil, reservedDBInstancesOfferingId: String? = nil, usagePrice: Double? = nil) {
            self.currencyCode = currencyCode
            self.dbInstanceClass = dbInstanceClass
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.recurringCharges = recurringCharges
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.usagePrice = usagePrice
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case dbInstanceClass = "DBInstanceClass"
            case duration = "Duration"
            case fixedPrice = "FixedPrice"
            case multiAZ = "MultiAZ"
            case offeringType = "OfferingType"
            case productDescription = "ProductDescription"
            case recurringCharges = "RecurringCharges"
            case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
            case usagePrice = "UsagePrice"
        }
    }

    public struct ReservedDBInstancesOfferingMessage: AWSDecodableShape {
        public struct _ReservedDBInstancesOfferingsEncoding: ArrayCoderProperties { public static let member = "ReservedDBInstancesOffering" }

        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A list of reserved DB instance offerings.
        @OptionalCustomCoding<ArrayCoder<_ReservedDBInstancesOfferingsEncoding, ReservedDBInstancesOffering>>
        public var reservedDBInstancesOfferings: [ReservedDBInstancesOffering]?

        public init(marker: String? = nil, reservedDBInstancesOfferings: [ReservedDBInstancesOffering]? = nil) {
            self.marker = marker
            self.reservedDBInstancesOfferings = reservedDBInstancesOfferings
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case reservedDBInstancesOfferings = "ReservedDBInstancesOfferings"
        }
    }

    public struct ResetDBClusterParameterGroupMessage: AWSEncodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// The name of the DB cluster parameter group to reset.
        public let dbClusterParameterGroupName: String?
        /// A list of parameter names in the DB cluster parameter group to reset to the default values. You can't use this parameter if the ResetAllParameters parameter is enabled.
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?
        /// Specifies whether to reset all parameters in the DB cluster parameter group  to their default values. You can't use this parameter if there  is a list of parameter names specified for the Parameters parameter.
        public let resetAllParameters: Bool?

        public init(dbClusterParameterGroupName: String? = nil, parameters: [Parameter]? = nil, resetAllParameters: Bool? = nil) {
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.parameters = parameters
            self.resetAllParameters = resetAllParameters
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case parameters = "Parameters"
            case resetAllParameters = "ResetAllParameters"
        }
    }

    public struct ResetDBParameterGroupMessage: AWSEncodableShape {
        public struct _ParametersEncoding: ArrayCoderProperties { public static let member = "Parameter" }

        /// The name of the DB parameter group. Constraints:   Must match the name of an existing DBParameterGroup.
        public let dbParameterGroupName: String?
        /// To reset the entire DB parameter group, specify the DBParameterGroup name and ResetAllParameters parameters. To reset specific parameters, provide a list of the following: ParameterName and ApplyMethod. A maximum of 20 parameters can be modified in a single request.  MySQL  Valid Values (for Apply method): immediate | pending-reboot  You can use the immediate value with dynamic parameters only. You can use              the pending-reboot value for both dynamic and static parameters, and changes  are applied when DB instance reboots.  MariaDB  Valid Values (for Apply method): immediate | pending-reboot  You can use the immediate value with dynamic parameters only. You can use              the pending-reboot value for both dynamic and static parameters, and changes  are applied when DB instance reboots.  Oracle  Valid Values (for Apply method): pending-reboot
        @OptionalCustomCoding<ArrayCoder<_ParametersEncoding, Parameter>>
        public var parameters: [Parameter]?
        /// Specifies whether to reset all parameters in the DB parameter group to default values.  By default, all parameters in the DB parameter group are reset to default values.
        public let resetAllParameters: Bool?

        public init(dbParameterGroupName: String? = nil, parameters: [Parameter]? = nil, resetAllParameters: Bool? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameters = parameters
            self.resetAllParameters = resetAllParameters
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DBParameterGroupName"
            case parameters = "Parameters"
            case resetAllParameters = "ResetAllParameters"
        }
    }

    public struct ResourcePendingMaintenanceActions: AWSDecodableShape {
        public struct _PendingMaintenanceActionDetailsEncoding: ArrayCoderProperties { public static let member = "PendingMaintenanceAction" }

        /// A list that provides details about the pending maintenance actions for the resource.
        @OptionalCustomCoding<ArrayCoder<_PendingMaintenanceActionDetailsEncoding, PendingMaintenanceAction>>
        public var pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
        /// The ARN of the resource that has pending maintenance actions.
        public let resourceIdentifier: String?

        public init(pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil, resourceIdentifier: String? = nil) {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct RestoreDBClusterFromS3Message: AWSEncodableShape {
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// A list of Availability Zones (AZs) where instances in the restored DB cluster can be created.
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, String>>
        public var availabilityZones: [String]?
        /// The target backtrack window, in seconds. To disable backtracking, set this value to 0.  Currently, Backtrack is only supported for Aurora MySQL DB clusters.  Default: 0 Constraints:   If specified, this value must be set to a number from 0 to 259,200 (72 hours).
        public let backtrackWindow: Int64?
        /// The number of days for which automated backups of the restored DB cluster are retained. You must specify a minimum value of 1. Default: 1 Constraints:   Must be a value from 1 to 35
        public let backupRetentionPeriod: Int?
        /// A value that indicates that the restored DB cluster should be associated with the specified CharacterSet.
        public let characterSetName: String?
        /// Specifies whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.
        public let copyTagsToSnapshot: Bool?
        /// The database name for the restored DB cluster.
        public let databaseName: String?
        /// The name of the DB cluster to create from the source data in the Amazon S3 bucket. This parameter isn't case-sensitive. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-cluster1
        public let dbClusterIdentifier: String?
        /// The name of the DB cluster parameter group to associate with the restored DB cluster. If this argument is omitted, the default parameter group for the engine version is used. Constraints:   If supplied, must match the name of an existing DBClusterParameterGroup.
        public let dbClusterParameterGroupName: String?
        /// A DB subnet group to associate with the restored DB cluster. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Specifies whether to enable deletion protection for the DB cluster.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled.
        public let deletionProtection: Bool?
        /// Specify the Active Directory directory ID to restore the DB cluster in. The domain must be created prior to this operation. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster. For more information, see Kerberos Authentication in the Amazon Aurora User Guide.
        public let domain: String?
        /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
        public let domainIAMRoleName: String?
        /// The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values in the list depend on the DB engine being used.  Aurora MySQL  Possible values are audit, error, general, and slowquery. For more information about exporting CloudWatch Logs for Amazon Aurora, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see   IAM Database Authentication in the Amazon Aurora User Guide.
        public let enableIAMDatabaseAuthentication: Bool?
        /// The name of the database engine to be used for this DB cluster. Valid Values: aurora-mysql (for Aurora MySQL)
        public let engine: String?
        /// The version number of the database engine to use. To list all of the available engine versions for aurora-mysql (Aurora MySQL), use the following command:  aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"   Aurora MySQL  Examples: 5.7.mysql_aurora.2.12.0, 8.0.mysql_aurora.3.04.0
        public let engineVersion: String?
        /// The Amazon Web Services KMS key identifier for an encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If the StorageEncrypted parameter is enabled, and you do not specify a value for the KmsKeyId parameter, then Amazon RDS will use your default KMS key. There is a   default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        /// Specifies whether to manage the master user password with Amazon Web Services Secrets Manager. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide and Password management with Amazon Web Services Secrets Manager  in the Amazon Aurora User Guide.  Constraints:   Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword  is specified.
        public let manageMasterUserPassword: Bool?
        /// The name of the master user for the restored DB cluster. Constraints:   Must be 1 to 16 letters or numbers.   First character must be a letter.   Can't be a reserved word for the chosen database engine.
        public let masterUsername: String?
        /// The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@". Constraints:   Must contain from 8 to 41 characters.   Can't be specified if ManageMasterUserPassword is turned on.
        public let masterUserPassword: String?
        /// The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and  managed in Amazon Web Services Secrets Manager. This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets  Manager for the DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If you don't specify MasterUserSecretKmsKeyId, then the aws/secretsmanager  KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't  use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer  managed KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let masterUserSecretKmsKeyId: String?
        /// The network type of the DB cluster. Valid Values:    IPV4     DUAL    The network type is determined by the DBSubnetGroup specified for the DB cluster.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon Aurora User Guide.
        public let networkType: String?
        /// A value that indicates that the restored DB cluster should be associated with the specified option group. Permanent options can't be removed from an option group. An option group can't be removed from a  DB cluster once it is associated with a DB cluster.
        public let optionGroupName: String?
        /// The port number on which the instances in the restored DB cluster accept connections. Default: 3306
        public let port: Int?
        /// The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region.  To view the time blocks available, see   Backup window in the Amazon Aurora User Guide. Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi  The default is a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. To see the time blocks available, see   Adjusting the Preferred Maintenance Window in the Amazon Aurora User Guide. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window.
        public let preferredMaintenanceWindow: String?
        /// The name of the Amazon S3 bucket that contains the data used to create the Amazon Aurora DB cluster.
        public let s3BucketName: String?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that authorizes Amazon RDS to access the Amazon S3 bucket on your behalf.
        public let s3IngestionRoleArn: String?
        /// The prefix for all of the file names that contain the data used to create the Amazon Aurora DB cluster. If you do not specify a SourceS3Prefix value, then the Amazon Aurora DB cluster is created by using all of the files in the Amazon S3 bucket.
        public let s3Prefix: String?
        public let serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration?
        /// The identifier for the database engine that was backed up to create the files stored in the Amazon S3 bucket. Valid Values: mysql
        public let sourceEngine: String?
        /// The version of the database that the backup files were created from. MySQL versions 5.7 and 8.0 are supported. Example: 5.7.40, 8.0.28
        public let sourceEngineVersion: String?
        /// Specifies whether the restored DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// Specifies the storage type to be associated with the DB cluster. Valid Values: aurora, aurora-iopt1  Default: aurora  Valid for: Aurora DB clusters only
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// A list of EC2 VPC security groups to associate with the restored DB cluster.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(availabilityZones: [String]? = nil, backtrackWindow: Int64? = nil, backupRetentionPeriod: Int? = nil, characterSetName: String? = nil, copyTagsToSnapshot: Bool? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, dbClusterParameterGroupName: String? = nil, dbSubnetGroupName: String? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainIAMRoleName: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableIAMDatabaseAuthentication: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, kmsKeyId: String? = nil, manageMasterUserPassword: Bool? = nil, masterUsername: String? = nil, masterUserPassword: String? = nil, masterUserSecretKmsKeyId: String? = nil, networkType: String? = nil, optionGroupName: String? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, s3BucketName: String? = nil, s3IngestionRoleArn: String? = nil, s3Prefix: String? = nil, serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration? = nil, sourceEngine: String? = nil, sourceEngineVersion: String? = nil, storageEncrypted: Bool? = nil, storageType: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.availabilityZones = availabilityZones
            self.backtrackWindow = backtrackWindow
            self.backupRetentionPeriod = backupRetentionPeriod
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbSubnetGroupName = dbSubnetGroupName
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainIAMRoleName = domainIAMRoleName
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.engine = engine
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.manageMasterUserPassword = manageMasterUserPassword
            self.masterUsername = masterUsername
            self.masterUserPassword = masterUserPassword
            self.masterUserSecretKmsKeyId = masterUserSecretKmsKeyId
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.s3BucketName = s3BucketName
            self.s3IngestionRoleArn = s3IngestionRoleArn
            self.s3Prefix = s3Prefix
            self.serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration
            self.sourceEngine = sourceEngine
            self.sourceEngineVersion = sourceEngineVersion
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case backtrackWindow = "BacktrackWindow"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case characterSetName = "CharacterSetName"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case databaseName = "DatabaseName"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainIAMRoleName = "DomainIAMRoleName"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case kmsKeyId = "KmsKeyId"
            case manageMasterUserPassword = "ManageMasterUserPassword"
            case masterUsername = "MasterUsername"
            case masterUserPassword = "MasterUserPassword"
            case masterUserSecretKmsKeyId = "MasterUserSecretKmsKeyId"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case s3BucketName = "S3BucketName"
            case s3IngestionRoleArn = "S3IngestionRoleArn"
            case s3Prefix = "S3Prefix"
            case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
            case sourceEngine = "SourceEngine"
            case sourceEngineVersion = "SourceEngineVersion"
            case storageEncrypted = "StorageEncrypted"
            case storageType = "StorageType"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct RestoreDBClusterFromS3Result: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct RestoreDBClusterFromSnapshotMessage: AWSEncodableShape {
        public struct _AvailabilityZonesEncoding: ArrayCoderProperties { public static let member = "AvailabilityZone" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// Provides the list of Availability Zones (AZs) where instances in the restored DB cluster can be created. Valid for: Aurora DB clusters only
        @OptionalCustomCoding<ArrayCoder<_AvailabilityZonesEncoding, String>>
        public var availabilityZones: [String]?
        /// The target backtrack window, in seconds. To disable backtracking, set this value to 0.  Currently, Backtrack is only supported for Aurora MySQL DB clusters.  Default: 0 Constraints:   If specified, this value must be set to a number from 0 to 259,200 (72 hours).   Valid for: Aurora DB clusters only
        public let backtrackWindow: Int64?
        /// Specifies whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let copyTagsToSnapshot: Bool?
        /// The database name for the restored DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let databaseName: String?
        /// The name of the DB cluster to create from the DB snapshot or DB cluster snapshot. This parameter isn't case-sensitive. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Example: my-snapshot-id  Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let dbClusterIdentifier: String?
        /// The compute and memory capacity of the each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB Instance Class in the Amazon RDS User Guide.  Valid for: Multi-AZ DB clusters only
        public let dbClusterInstanceClass: String?
        /// The name of the DB cluster parameter group to associate with this DB cluster. If this argument is omitted, the default DB cluster parameter group for the specified engine is used. Constraints:   If supplied, must match the name of an existing default DB cluster parameter group.   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let dbClusterParameterGroupName: String?
        /// The name of the DB subnet group to use for the new DB cluster. Constraints: If supplied, must match the name of an existing DB subnet group. Example: mydbsubnetgroup  Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let dbSubnetGroupName: String?
        /// Specifies whether to enable deletion protection for the DB cluster.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to restore the DB cluster in. The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL  Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see  Kerberos Authentication in the Amazon RDS User Guide. Valid for: Aurora DB clusters only
        public let domain: String?
        /// The name of the IAM role to be used when making API calls to the Directory Service. Valid for: Aurora DB clusters only
        public let domainIAMRoleName: String?
        /// The list of logs that the restored DB cluster is to export to Amazon CloudWatch Logs. The values in the list depend on the DB engine being used.  RDS for MySQL  Possible values are error, general, and slowquery.  RDS for PostgreSQL  Possible values are postgresql and upgrade.  Aurora MySQL  Possible values are audit, error, general, and slowquery.  Aurora PostgreSQL  Possible value is postgresql. For more information about exporting CloudWatch Logs for Amazon RDS, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. For more information about exporting CloudWatch Logs for Amazon Aurora, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see   IAM Database Authentication in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
        public let enableIAMDatabaseAuthentication: Bool?
        /// The database engine to use for the new DB cluster. Default: The same as source Constraint: Must be compatible with the engine of the source Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let engine: String?
        /// The DB engine mode of the DB cluster, either provisioned or serverless. For more information, see  CreateDBCluster. Valid for: Aurora DB clusters only
        public let engineMode: String?
        /// The version of the database engine to use for the new DB cluster. If you don't specify an engine version, the default version for the database engine in the Amazon Web Services Region is used. To list all of the available engine versions for Aurora MySQL, use the following command:  aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for Aurora PostgreSQL, use the following command:  aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for RDS for MySQL, use the following command:  aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"  To list all of the available engine versions for RDS for PostgreSQL, use the following command:  aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"   Aurora MySQL  See Database  engine updates for Amazon Aurora MySQL in the Amazon Aurora User Guide.  Aurora PostgreSQL  See Amazon  Aurora PostgreSQL releases and engine versions in the Amazon Aurora User Guide.  MySQL  See Amazon  RDS for MySQL in the Amazon RDS User Guide.   PostgreSQL  See Amazon  RDS for PostgreSQL versions and extensions in the Amazon RDS User Guide.  Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let engineVersion: String?
        /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for  each DB instance in the Multi-AZ DB cluster. For information about valid IOPS values,  see Amazon RDS Provisioned IOPS storage  in the Amazon RDS User Guide. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB instance. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let iops: Int?
        /// The Amazon Web Services KMS key identifier to use when restoring an encrypted DB cluster from a DB snapshot or DB cluster snapshot. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. When you don't specify a value for the KmsKeyId parameter, then the following occurs:   If the DB snapshot or DB cluster snapshot in SnapshotIdentifier is encrypted, then the restored DB cluster is encrypted using the KMS key that was used to encrypt the DB snapshot or DB cluster snapshot.   If the DB snapshot or DB cluster snapshot in  SnapshotIdentifier isn't encrypted, then the restored DB cluster isn't encrypted.   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let kmsKeyId: String?
        /// The network type of the DB cluster. Valid Values:    IPV4     DUAL    The network type is determined by the DBSubnetGroup specified for the DB cluster.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon Aurora User Guide.  Valid for: Aurora DB clusters only
        public let networkType: String?
        /// The name of the option group to use for the restored DB cluster. DB clusters are associated with a default option group that can't be modified.
        public let optionGroupName: String?
        /// The port number on which the new DB cluster accepts connections. Constraints: This value must be 1150-65535  Default: The same port as the original DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let port: Int?
        /// Specifies whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address  from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC.  Access to the DB cluster is ultimately controlled by the security group it uses.  That public access is not permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:   If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB cluster is private.   If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.   If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:   If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB cluster is private.   If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let publiclyAccessible: Bool?
        /// Reserved for future use.
        public let rdsCustomClusterConfiguration: RdsCustomClusterConfiguration?
        /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster. Valid for: Aurora DB clusters only
        public let scalingConfiguration: ScalingConfiguration?
        public let serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration?
        /// The identifier for the DB snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot. Constraints:   Must match the identifier of an existing Snapshot.   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let snapshotIdentifier: String?
        /// Specifies the storage type to be associated with the DB cluster. When specified for a Multi-AZ DB cluster, a value for the Iops parameter is required. Valid Values: aurora, aurora-iopt1 (Aurora DB clusters); io1 (Multi-AZ DB clusters) Default: aurora (Aurora DB clusters); io1 (Multi-AZ DB clusters) Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let storageType: String?
        /// The tags to be assigned to the restored DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// A list of VPC security groups that the new DB cluster will belong to. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(availabilityZones: [String]? = nil, backtrackWindow: Int64? = nil, copyTagsToSnapshot: Bool? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, dbClusterInstanceClass: String? = nil, dbClusterParameterGroupName: String? = nil, dbSubnetGroupName: String? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainIAMRoleName: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableIAMDatabaseAuthentication: Bool? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, networkType: String? = nil, optionGroupName: String? = nil, port: Int? = nil, publiclyAccessible: Bool? = nil, rdsCustomClusterConfiguration: RdsCustomClusterConfiguration? = nil, scalingConfiguration: ScalingConfiguration? = nil, serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration? = nil, snapshotIdentifier: String? = nil, storageType: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.availabilityZones = availabilityZones
            self.backtrackWindow = backtrackWindow
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterInstanceClass = dbClusterInstanceClass
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbSubnetGroupName = dbSubnetGroupName
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainIAMRoleName = domainIAMRoleName
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.port = port
            self.publiclyAccessible = publiclyAccessible
            self.rdsCustomClusterConfiguration = rdsCustomClusterConfiguration
            self.scalingConfiguration = scalingConfiguration
            self.serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration
            self.snapshotIdentifier = snapshotIdentifier
            self.storageType = storageType
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case backtrackWindow = "BacktrackWindow"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case databaseName = "DatabaseName"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterInstanceClass = "DBClusterInstanceClass"
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainIAMRoleName = "DomainIAMRoleName"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case port = "Port"
            case publiclyAccessible = "PubliclyAccessible"
            case rdsCustomClusterConfiguration = "RdsCustomClusterConfiguration"
            case scalingConfiguration = "ScalingConfiguration"
            case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
            case snapshotIdentifier = "SnapshotIdentifier"
            case storageType = "StorageType"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct RestoreDBClusterFromSnapshotResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct RestoreDBClusterToPointInTimeMessage: AWSEncodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The target backtrack window, in seconds. To disable backtracking, set this value to 0. Default: 0 Constraints:   If specified, this value must be set to a number from 0 to 259,200 (72 hours).   Valid for: Aurora MySQL DB clusters only
        public let backtrackWindow: Int64?
        /// Specifies whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let copyTagsToSnapshot: Bool?
        /// The name of the new DB cluster to be created. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens   First character must be a letter   Can't end with a hyphen or contain two consecutive hyphens   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let dbClusterIdentifier: String?
        /// The compute and memory capacity of the each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see  DB instance class in the  Amazon RDS User Guide. Valid for: Multi-AZ DB clusters only
        public let dbClusterInstanceClass: String?
        /// The name of the custom DB cluster parameter group to associate with this DB cluster. If the DBClusterParameterGroupName parameter is omitted, the default DB cluster parameter group for the specified engine is used. Constraints:   If supplied, must match the name of an existing DB cluster parameter group.   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let dbClusterParameterGroupName: String?
        /// The DB subnet group name to use for the new DB cluster. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mydbsubnetgroup  Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let dbSubnetGroupName: String?
        /// Specifies whether to enable deletion protection for the DB cluster.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to restore the DB cluster in. The domain must be created prior to this operation. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster. For more information, see Kerberos Authentication in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
        public let domain: String?
        /// The name of the IAM role to be used when making API calls to the Directory Service. Valid for: Aurora DB clusters only
        public let domainIAMRoleName: String?
        /// The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values in the list depend on the DB engine being used.  RDS for MySQL  Possible values are error, general, and slowquery.  RDS for PostgreSQL  Possible values are postgresql and upgrade.  Aurora MySQL  Possible values are audit, error, general, and slowquery.  Aurora PostgreSQL  Possible value is postgresql. For more information about exporting CloudWatch Logs for Amazon RDS, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. For more information about exporting CloudWatch Logs for Amazon Aurora, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information, see   IAM Database Authentication in the Amazon Aurora User Guide. Valid for: Aurora DB clusters only
        public let enableIAMDatabaseAuthentication: Bool?
        /// The engine mode of the new cluster. Specify provisioned or serverless, depending on the type of the cluster you are creating. You can create an Aurora Serverless v1 clone from a provisioned cluster, or a provisioned clone from an Aurora Serverless v1 cluster. To create a clone that is an Aurora Serverless v1 cluster, the original cluster must be an Aurora Serverless v1 cluster or an encrypted provisioned cluster. Valid for: Aurora DB clusters only
        public let engineMode: String?
        /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for  each DB instance in the Multi-AZ DB cluster. For information about valid IOPS values,  see Amazon RDS Provisioned IOPS storage  in the Amazon RDS User Guide. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB instance. Valid for: Multi-AZ DB clusters only
        public let iops: Int?
        /// The Amazon Web Services KMS key identifier to use when restoring an encrypted DB cluster from an encrypted DB cluster. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. You can restore to a new DB cluster and encrypt the new DB cluster with a KMS key that is different from the KMS key used to encrypt the source DB cluster. The new DB cluster is encrypted with the KMS key identified by the KmsKeyId parameter. If you don't specify a value for the KmsKeyId parameter, then the following occurs:   If the DB cluster is encrypted, then the restored DB cluster is encrypted using the KMS key that was used to encrypt the source DB cluster.   If the DB cluster isn't encrypted, then the restored DB cluster isn't encrypted.   If DBClusterIdentifier refers to a DB cluster that isn't encrypted, then the restore request is rejected. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let kmsKeyId: String?
        /// The network type of the DB cluster. Valid Values:    IPV4     DUAL    The network type is determined by the DBSubnetGroup specified for the DB cluster.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon Aurora User Guide.  Valid for: Aurora DB clusters only
        public let networkType: String?
        /// The name of the option group for the new DB cluster. DB clusters are associated with a default option group that can't be modified.
        public let optionGroupName: String?
        /// The port number on which the new DB cluster accepts connections. Constraints: A value from 1150-65535. Default: The default port for the engine. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let port: Int?
        /// Specifies whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address  from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC.  Access to the DB cluster is ultimately controlled by the security group it uses.  That public access is not permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether DBSubnetGroupName is specified. If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:   If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB cluster is private.   If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.   If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:   If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB cluster is private.   If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.   Valid for: Multi-AZ DB clusters only
        public let publiclyAccessible: Bool?
        /// Reserved for future use.
        public let rdsCustomClusterConfiguration: RdsCustomClusterConfiguration?
        /// The date and time to restore the DB cluster to. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints:   Must be before the latest restorable time for the DB instance   Must be specified if UseLatestRestorableTime parameter isn't provided   Can't be specified if the UseLatestRestorableTime parameter is enabled   Can't be specified if the RestoreType parameter is copy-on-write    Example: 2015-03-07T23:45:00Z  Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let restoreToTime: Date?
        /// The type of restore to be performed. You can specify one of the following values:    full-copy - The new DB cluster is restored as a full copy of the source DB cluster.    copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.   If you don't specify a RestoreType value, then the new DB cluster is restored as a full copy of the source DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let restoreType: String?
        /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster. Valid for: Aurora DB clusters only
        public let scalingConfiguration: ScalingConfiguration?
        public let serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration?
        /// The identifier of the source DB cluster from which to restore. Constraints:   Must match the identifier of an existing DBCluster.   Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let sourceDBClusterIdentifier: String?
        /// The resource ID of the source DB cluster from which to restore.
        public let sourceDbClusterResourceId: String?
        /// Specifies the storage type to be associated with the DB cluster. When specified for a Multi-AZ DB cluster, a value for the Iops parameter is required. Valid Values: aurora, aurora-iopt1 (Aurora DB clusters); io1 (Multi-AZ DB clusters) Default: aurora (Aurora DB clusters); io1 (Multi-AZ DB clusters) Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// Specifies whether to restore the DB cluster to the latest  restorable backup time. By default, the DB cluster isn't restored to the latest  restorable backup time. Constraints: Can't be specified if RestoreToTime parameter is provided. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        public let useLatestRestorableTime: Bool?
        /// A list of VPC security groups that the new DB cluster belongs to. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(backtrackWindow: Int64? = nil, copyTagsToSnapshot: Bool? = nil, dbClusterIdentifier: String? = nil, dbClusterInstanceClass: String? = nil, dbClusterParameterGroupName: String? = nil, dbSubnetGroupName: String? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainIAMRoleName: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableIAMDatabaseAuthentication: Bool? = nil, engineMode: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, networkType: String? = nil, optionGroupName: String? = nil, port: Int? = nil, publiclyAccessible: Bool? = nil, rdsCustomClusterConfiguration: RdsCustomClusterConfiguration? = nil, restoreToTime: Date? = nil, restoreType: String? = nil, scalingConfiguration: ScalingConfiguration? = nil, serverlessV2ScalingConfiguration: ServerlessV2ScalingConfiguration? = nil, sourceDBClusterIdentifier: String? = nil, sourceDbClusterResourceId: String? = nil, storageType: String? = nil, tags: [Tag]? = nil, useLatestRestorableTime: Bool? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.backtrackWindow = backtrackWindow
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterInstanceClass = dbClusterInstanceClass
            self.dbClusterParameterGroupName = dbClusterParameterGroupName
            self.dbSubnetGroupName = dbSubnetGroupName
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainIAMRoleName = domainIAMRoleName
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.engineMode = engineMode
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.port = port
            self.publiclyAccessible = publiclyAccessible
            self.rdsCustomClusterConfiguration = rdsCustomClusterConfiguration
            self.restoreToTime = restoreToTime
            self.restoreType = restoreType
            self.scalingConfiguration = scalingConfiguration
            self.serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration
            self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
            self.sourceDbClusterResourceId = sourceDbClusterResourceId
            self.storageType = storageType
            self.tags = tags
            self.useLatestRestorableTime = useLatestRestorableTime
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case backtrackWindow = "BacktrackWindow"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbClusterInstanceClass = "DBClusterInstanceClass"
            case dbClusterParameterGroupName = "DBClusterParameterGroupName"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainIAMRoleName = "DomainIAMRoleName"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case engineMode = "EngineMode"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case port = "Port"
            case publiclyAccessible = "PubliclyAccessible"
            case rdsCustomClusterConfiguration = "RdsCustomClusterConfiguration"
            case restoreToTime = "RestoreToTime"
            case restoreType = "RestoreType"
            case scalingConfiguration = "ScalingConfiguration"
            case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
            case sourceDBClusterIdentifier = "SourceDBClusterIdentifier"
            case sourceDbClusterResourceId = "SourceDbClusterResourceId"
            case storageType = "StorageType"
            case tags = "Tags"
            case useLatestRestorableTime = "UseLatestRestorableTime"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct RestoreDBClusterToPointInTimeResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct RestoreDBInstanceFromDBSnapshotMessage: AWSEncodableShape {
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage (in gibibytes) to allocate initially for the DB instance. Follow the allocation rules specified in CreateDBInstance.  Be sure to allocate enough storage for your new DB instance so that the restore operation can succeed. You can also allocate additional storage for future growth.
        public let allocatedStorage: Int?
        /// Specifies whether to automatically apply minor version upgrades to the DB instance  during the maintenance window. If you restore an RDS Custom DB instance, you must disable this parameter.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone (AZ) where the DB instance will be created. Default: A random, system-chosen Availability Zone. Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment. Example: us-east-1a
        public let availabilityZone: String?
        /// Specifies where automated backups and manual snapshots are stored for the restored DB instance. Possible values are outposts (Amazon Web Services Outposts) and region (Amazon Web Services Region). The default is region. For more information, see Working  with Amazon RDS on Amazon Web Services Outposts in the Amazon RDS User Guide.
        public let backupTarget: String?
        /// Specifies whether to copy all tags from the restored DB instance to snapshots of the DB instance. In most cases, tags aren't copied by default. However, when you restore a DB instance from a DB snapshot, RDS checks whether you  specify new tags. If yes, the new tags are added to the restored DB instance. If there are no new tags, RDS looks for the tags from the source DB instance for the DB snapshot, and then adds those tags to the restored DB instance. For more information, see  Copying tags to DB instance snapshots in the Amazon RDS User Guide.
        public let copyTagsToSnapshot: Bool?
        /// The instance profile associated with the underlying Amazon EC2 instance of an  RDS Custom DB instance. The instance profile must meet the following requirements:   The profile must exist in your account.   The profile must have an IAM role that Amazon EC2 has permissions to assume.   The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.   For the list of permissions required for the IAM role, see   Configure IAM and your VPC in the Amazon RDS User Guide. This setting is required for RDS Custom.
        public let customIamInstanceProfile: String?
        /// The identifier for the Multi-AZ DB cluster snapshot to restore from. For more information on Multi-AZ DB clusters, see  Multi-AZ DB cluster deployments in the Amazon RDS User Guide. Constraints:   Must match the identifier of an existing Multi-AZ DB cluster snapshot.   Can't be specified when DBSnapshotIdentifier is specified.   Must be specified when DBSnapshotIdentifier isn't specified.   If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the DBClusterSnapshotIdentifier must be the ARN of the shared snapshot.   Can't be the identifier of an Aurora DB cluster snapshot.
        public let dbClusterSnapshotIdentifier: String?
        /// The compute and memory capacity of the Amazon RDS DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB Instance Class in the Amazon RDS User Guide.  Default: The same DBInstanceClass as the original DB instance.
        public let dbInstanceClass: String?
        /// The name of the DB instance to create from the DB snapshot. This parameter isn't case-sensitive. Constraints:   Must contain from 1 to 63 numbers, letters, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: my-snapshot-id
        public let dbInstanceIdentifier: String?
        /// The name of the database for the restored DB instance. This parameter only applies to RDS for Oracle and RDS for SQL Server DB instances. It doesn't apply to the other engines or to RDS Custom DB instances.
        public let dbName: String?
        /// The name of the DB parameter group to associate with this DB instance. If you don't specify a value for DBParameterGroupName, then RDS uses the default DBParameterGroup  for the specified DB engine. This setting doesn't apply to RDS Custom. Constraints:   If supplied, must match the name of an existing DB parameter group.   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.
        public let dbParameterGroupName: String?
        /// The identifier for the DB snapshot to restore from. Constraints:   Must match the identifier of an existing DB snapshot.   Can't be specified when DBClusterSnapshotIdentifier is specified.   Must be specified when DBClusterSnapshotIdentifier isn't specified.   If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier must be the ARN of the shared DB snapshot.
        public let dbSnapshotIdentifier: String?
        /// The name of the DB subnet group to use for the new instance. Constraints:   If supplied, must match the name of an existing DB subnet group.   Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Specifies whether to enable a dedicated log volume (DLV) for the DB instance.
        public let dedicatedLogVolume: Bool?
        /// Specifies whether to enable deletion protection for the DB instance.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. For more information, see   Deleting a DB Instance.
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to restore the DB instance in. The domain/ must be created prior to this operation. Currently, you can create only Db2, MySQL, Microsoft SQL  Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. For more information, see  Kerberos Authentication in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
        public let domain: String?
        /// The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Constraints:   Can't be longer than 64 characters.   Example: arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456
        public let domainAuthSecretArn: String?
        /// The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:   Two IP addresses must be provided.  If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: 123.124.125.126,234.235.236.237
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var domainDnsIps: [String]?
        /// The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:   Can't be longer than 64 characters.   Example: mymanagedADtest.mymanagedAD.mydomain
        public let domainFqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to RDS Custom DB instances.
        public let domainIAMRoleName: String?
        /// The Active Directory organizational unit for your DB instance to join. Constraints:   Must be in the distinguished name format.   Can't be longer than 64 characters.   Example: OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain
        public let domainOu: String?
        /// The list of logs for the restored DB instance to export to CloudWatch Logs. The values in the list depend on the DB engine. For more information, see  Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. This setting doesn't apply to RDS Custom. For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide. For more information about CoIPs, see Customer-owned IP addresses  in the Amazon Web Services Outposts User Guide.
        public let enableCustomerOwnedIp: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. For more information about IAM database authentication, see   IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.  This setting doesn't apply to RDS Custom.
        public let enableIAMDatabaseAuthentication: Bool?
        /// The database engine to use for the new instance. This setting doesn't apply to RDS Custom. Default: The same as source Constraint: Must be compatible with the engine of the source. For example, you can restore a MariaDB 10.1 DB instance from a MySQL 5.6 snapshot. Valid Values:    db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web
        public let engine: String?
        /// Specifies the amount of provisioned IOPS for the DB instance, expressed in I/O operations per second.  If this parameter isn't specified, the IOPS value is taken from the backup.  If this parameter is set to 0, the new instance is converted to a non-PIOPS instance.  The conversion takes additional time, though your DB instance is available for connections before the conversion starts. The provisioned IOPS value must follow the requirements for your database engine. For more information, see  Amazon RDS Provisioned IOPS storage  in the Amazon RDS User Guide.  Constraints: Must be an integer greater than 1000.
        public let iops: Int?
        /// License model information for the restored DB instance. This setting doesn't apply to RDS Custom. Default: Same as source. Valid Values:  license-included | bring-your-own-license | general-public-license
        public let licenseModel: String?
        /// Specifies whether the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom. Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
        public let multiAZ: Bool?
        /// The network type of the DB instance. Valid Values:    IPV4     DUAL    The network type is determined by the DBSubnetGroup specified for the DB instance.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.
        public let networkType: String?
        /// The name of the option group to be used for the restored DB instance. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option  group, and that option group can't be removed from a DB instance after it is associated with a DB instance. This setting doesn't apply to RDS Custom.
        public let optionGroupName: String?
        /// The port number on which the database accepts connections. Default: The same port as the original DB instance Constraints: Value must be 1150-65535
        public let port: Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// Specifies whether the DB instance is publicly accessible. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address  from within the DB instance's virtual private cloud (VPC).  It resolves to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled  by the security group it uses. That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see CreateDBInstance.
        public let publiclyAccessible: Bool?
        /// Specifies the storage throughput value for the DB instance. This setting doesn't apply to RDS Custom or Amazon Aurora.
        public let storageThroughput: Int?
        /// Specifies the storage type to be associated with the DB instance. Valid Values: gp2 | gp3 | io1 | io2 | standard  If you specify io1, io2, or gp3, you must also include a value for the Iops parameter. Default: io1 if the Iops parameter is specified, otherwise gp2
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom.
        public let tdeCredentialArn: String?
        /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom.
        public let tdeCredentialPassword: String?
        /// Specifies whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
        public let useDefaultProcessorFeatures: Bool?
        /// A list of EC2 VPC security groups to associate with this DB instance. Default: The default EC2 VPC security group for the DB subnet group's VPC.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, backupTarget: String? = nil, copyTagsToSnapshot: Bool? = nil, customIamInstanceProfile: String? = nil, dbClusterSnapshotIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbName: String? = nil, dbParameterGroupName: String? = nil, dbSnapshotIdentifier: String? = nil, dbSubnetGroupName: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainAuthSecretArn: String? = nil, domainDnsIps: [String]? = nil, domainFqdn: String? = nil, domainIAMRoleName: String? = nil, domainOu: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableCustomerOwnedIp: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, engine: String? = nil, iops: Int? = nil, licenseModel: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, optionGroupName: String? = nil, port: Int? = nil, processorFeatures: [ProcessorFeature]? = nil, publiclyAccessible: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tags: [Tag]? = nil, tdeCredentialArn: String? = nil, tdeCredentialPassword: String? = nil, useDefaultProcessorFeatures: Bool? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupTarget = backupTarget
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customIamInstanceProfile = customIamInstanceProfile
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbName = dbName
            self.dbParameterGroupName = dbParameterGroupName
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainAuthSecretArn = domainAuthSecretArn
            self.domainDnsIps = domainDnsIps
            self.domainFqdn = domainFqdn
            self.domainIAMRoleName = domainIAMRoleName
            self.domainOu = domainOu
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableCustomerOwnedIp = enableCustomerOwnedIp
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.engine = engine
            self.iops = iops
            self.licenseModel = licenseModel
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.port = port
            self.processorFeatures = processorFeatures
            self.publiclyAccessible = publiclyAccessible
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tags = tags
            self.tdeCredentialArn = tdeCredentialArn
            self.tdeCredentialPassword = tdeCredentialPassword
            self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case backupTarget = "BackupTarget"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case customIamInstanceProfile = "CustomIamInstanceProfile"
            case dbClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbName = "DBName"
            case dbParameterGroupName = "DBParameterGroupName"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainAuthSecretArn = "DomainAuthSecretArn"
            case domainDnsIps = "DomainDnsIps"
            case domainFqdn = "DomainFqdn"
            case domainIAMRoleName = "DomainIAMRoleName"
            case domainOu = "DomainOu"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case engine = "Engine"
            case iops = "Iops"
            case licenseModel = "LicenseModel"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case publiclyAccessible = "PubliclyAccessible"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tags = "Tags"
            case tdeCredentialArn = "TdeCredentialArn"
            case tdeCredentialPassword = "TdeCredentialPassword"
            case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct RestoreDBInstanceFromDBSnapshotResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct RestoreDBInstanceFromS3Message: AWSEncodableShape {
        public struct _DBSecurityGroupsEncoding: ArrayCoderProperties { public static let member = "DBSecurityGroupName" }
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage (in gibibytes) to allocate initially for the DB instance. Follow the allocation rules specified in CreateDBInstance.  Be sure to allocate enough storage for your new DB instance so that the restore operation can succeed. You can also allocate additional storage for future growth.
        public let allocatedStorage: Int?
        /// Specifies whether to automatically apply minor engine upgrades   to the DB instance during the maintenance window. By default, minor engine upgrades  are not applied automatically.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone that the DB instance is created in.  For information about Amazon Web Services Regions and Availability Zones, see Regions and Availability Zones in the Amazon RDS User Guide.  Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region. Example: us-east-1d  Constraint: The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment.  The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint.
        public let availabilityZone: String?
        /// The number of days for which automated backups are retained.  Setting this parameter to a positive number enables backups. For more information, see CreateDBInstance.
        public let backupRetentionPeriod: Int?
        /// Specifies whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
        public let copyTagsToSnapshot: Bool?
        /// The compute and memory capacity of the DB instance,  for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions,  or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB Instance Class in the Amazon RDS User Guide.  Importing from Amazon S3 isn't supported on the db.t2.micro DB instance class.
        public let dbInstanceClass: String?
        /// The DB instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: mydbinstance
        public let dbInstanceIdentifier: String?
        /// The name of the database to create when the DB instance is created. Follow the naming rules specified in CreateDBInstance.
        public let dbName: String?
        /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup  for the specified DB engine is used.
        public let dbParameterGroupName: String?
        /// A list of DB security groups to associate with this DB instance. Default: The default DB security group for the database engine.
        @OptionalCustomCoding<ArrayCoder<_DBSecurityGroupsEncoding, String>>
        public var dbSecurityGroups: [String]?
        /// A DB subnet group to associate with this DB instance. Constraints: If supplied, must match the name of an existing DBSubnetGroup. Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Specifies whether to enable a dedicated log volume (DLV) for the DB instance.
        public let dedicatedLogVolume: Bool?
        /// Specifies whether to enable deletion protection for the DB instance.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. For more information, see   Deleting a DB Instance.
        public let deletionProtection: Bool?
        /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see  Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. For more information about IAM database authentication, see   IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
        public let enableIAMDatabaseAuthentication: Bool?
        /// Specifies whether to enable Performance Insights for the DB instance. For more information, see  Using Amazon Performance Insights in the Amazon RDS User Guide.
        public let enablePerformanceInsights: Bool?
        /// The name of the database engine to be used for this instance. Valid Values:  mysql
        public let engine: String?
        /// The version number of the database engine to use. Choose the latest minor version of your database engine.  For information about engine versions, see CreateDBInstance, or call DescribeDBEngineVersions.
        public let engineVersion: String?
        /// The amount of Provisioned IOPS (input/output operations per second)  to allocate initially for the DB instance. For information about valid IOPS values,  see Amazon RDS Provisioned IOPS storage  in the Amazon RDS User Guide.
        public let iops: Int?
        /// The Amazon Web Services KMS key identifier for an encrypted DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If the StorageEncrypted parameter is enabled,  and you do not specify a value for the KmsKeyId parameter,  then Amazon RDS will use your default KMS key.  There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        /// The license model for this DB instance. Use general-public-license.
        public let licenseModel: String?
        /// Specifies whether to manage the master user password with Amazon Web Services Secrets Manager. For more information, see Password management with Amazon Web Services Secrets Manager  in the Amazon RDS User Guide.  Constraints:   Can't manage the master user password with Amazon Web Services Secrets Manager if MasterUserPassword  is specified.
        public let manageMasterUserPassword: Bool?
        /// The name for the master user. Constraints:   Must be 1 to 16 letters or numbers.   First character must be a letter.   Can't be a reserved word for the chosen database engine.
        public let masterUsername: String?
        /// The password for the master user. Constraints:   Can't be specified if ManageMasterUserPassword is turned on.   Can include any printable ASCII character except "/", """, or "@". For RDS for Oracle, can't include the "&" (ampersand) or  the "'" (single quotes) character.   Length Constraints:   RDS for Db2 - Must contain from 8 to 128 characters.   RDS for MariaDB - Must contain from 8 to 41 characters.   RDS for Microsoft SQL Server - Must contain from 8 to 128 characters.   RDS for MySQL - Must contain from 8 to 41 characters.   RDS for Oracle - Must contain from 8 to 30 characters.   RDS for PostgreSQL - Must contain from 8 to 128 characters.
        public let masterUserPassword: String?
        /// The Amazon Web Services KMS key identifier to encrypt a secret that is automatically generated and  managed in Amazon Web Services Secrets Manager. This setting is valid only if the master user password is managed by RDS in Amazon Web Services Secrets  Manager for the DB instance. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If you don't specify MasterUserSecretKmsKeyId, then the aws/secretsmanager  KMS key is used to encrypt the secret. If the secret is in a different Amazon Web Services account, then you can't  use the aws/secretsmanager KMS key to encrypt the secret, and you must use a customer  managed KMS key. There is a default KMS key for your Amazon Web Services account. Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let masterUserSecretKmsKeyId: String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see   Managing capacity automatically with Amazon RDS storage autoscaling  in the Amazon RDS User Guide.
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds,  between points when Enhanced Monitoring metrics are collected for the DB instance.  To disable collecting Enhanced Monitoring metrics, specify 0. If MonitoringRoleArn is specified,  then you must also set MonitoringInterval to a value other than 0. Valid Values: 0, 1, 5, 10, 15, 30, 60 Default: 0
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits RDS  to send enhanced monitoring metrics to Amazon CloudWatch Logs.  For example, arn:aws:iam:123456789012:role/emaccess.  For information on creating a monitoring role, see Setting Up and Enabling Enhanced Monitoring  in the Amazon RDS User Guide.  If MonitoringInterval is set to a value other than 0,  then you must supply a MonitoringRoleArn value.
        public let monitoringRoleArn: String?
        /// Specifies whether the DB instance is a Multi-AZ deployment.  If the DB instance is a Multi-AZ deployment, you can't set the AvailabilityZone parameter.
        public let multiAZ: Bool?
        /// The network type of the DB instance. Valid Values:    IPV4     DUAL    The network type is determined by the DBSubnetGroup specified for the DB instance.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.
        public let networkType: String?
        /// The name of the option group to associate with this DB instance.  If this argument is omitted, the default option group for the specified engine is used.
        public let optionGroupName: String?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS  uses your default KMS key. There is a default KMS key for your Amazon Web Services account.  Your Amazon Web Services account has a different default KMS key for each Amazon Web Services Region.
        public let performanceInsightsKMSKeyId: String?
        /// The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:   7    month * 31, where month is a number of months from 1-23   731   For example, the following values are valid:   93 (3 months * 31)   341 (11 months * 31)   589 (19 months * 31)   731   If you specify a retention period such as 94, which isn't a valid value, RDS issues an error.
        public let performanceInsightsRetentionPeriod: Int?
        /// The port number on which the database accepts connections. Type: Integer Valid Values: 1150-65535  Default: 3306
        public let port: Int?
        /// The time range each day  during which automated backups are created  if automated backups are enabled.  For more information, see Backup window in the Amazon RDS User Guide.  Constraints:   Must be in the format hh24:mi-hh24:mi.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred maintenance window.   Must be at least 30 minutes.
        public let preferredBackupWindow: String?
        /// The time range each week during which system maintenance can occur,  in Universal Coordinated Time (UTC).  For more information, see Amazon RDS Maintenance Window in the Amazon RDS User Guide.  Constraints:   Must be in the format ddd:hh24:mi-ddd:hh24:mi.   Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.   Must be in Universal Coordinated Time (UTC).   Must not conflict with the preferred backup window.   Must be at least 30 minutes.
        public let preferredMaintenanceWindow: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// Specifies whether the DB instance is publicly accessible. When the DB instance is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address  from within the DB instance's virtual private cloud (VPC).  It resolves to the public IP address from outside of the DB instance's VPC.  Access to the DB instance is ultimately controlled by the security group it uses.  That public access is not permitted if the security group assigned to the DB instance doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see CreateDBInstance.
        public let publiclyAccessible: Bool?
        /// The name of your Amazon S3 bucket  that contains your database backup file.
        public let s3BucketName: String?
        /// An Amazon Web Services Identity and Access Management (IAM) role to allow Amazon RDS to access your Amazon S3 bucket.
        public let s3IngestionRoleArn: String?
        /// The prefix of your Amazon S3 bucket.
        public let s3Prefix: String?
        /// The name of the engine of your source database. Valid Values:  mysql
        public let sourceEngine: String?
        /// The version of the database that the backup files were created from. MySQL versions 5.6 and 5.7 are supported. Example: 5.6.40
        public let sourceEngineVersion: String?
        /// Specifies whether the new DB instance is encrypted or not.
        public let storageEncrypted: Bool?
        /// Specifies the storage throughput value for the DB instance. This setting doesn't apply to RDS Custom or Amazon Aurora.
        public let storageThroughput: Int?
        /// Specifies the storage type to be associated with the DB instance. Valid Values: gp2 | gp3 | io1 | io2 | standard  If you specify io1, io2, or gp3,  you must also include a value for the Iops parameter. Default: io1  if the Iops parameter is specified;  otherwise gp2
        public let storageType: String?
        /// A list of tags to associate with this DB instance. For more information, see Tagging Amazon RDS Resources in the Amazon RDS User Guide.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// Specifies whether the DB instance class of the DB instance uses its default processor features.
        public let useDefaultProcessorFeatures: Bool?
        /// A list of VPC security groups to associate with this DB instance.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, backupRetentionPeriod: Int? = nil, copyTagsToSnapshot: Bool? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbName: String? = nil, dbParameterGroupName: String? = nil, dbSecurityGroups: [String]? = nil, dbSubnetGroupName: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, enableCloudwatchLogsExports: [String]? = nil, enableIAMDatabaseAuthentication: Bool? = nil, enablePerformanceInsights: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, manageMasterUserPassword: Bool? = nil, masterUsername: String? = nil, masterUserPassword: String? = nil, masterUserSecretKmsKeyId: String? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, optionGroupName: String? = nil, performanceInsightsKMSKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, processorFeatures: [ProcessorFeature]? = nil, publiclyAccessible: Bool? = nil, s3BucketName: String? = nil, s3IngestionRoleArn: String? = nil, s3Prefix: String? = nil, sourceEngine: String? = nil, sourceEngineVersion: String? = nil, storageEncrypted: Bool? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tags: [Tag]? = nil, useDefaultProcessorFeatures: Bool? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbName = dbName
            self.dbParameterGroupName = dbParameterGroupName
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.enablePerformanceInsights = enablePerformanceInsights
            self.engine = engine
            self.engineVersion = engineVersion
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.manageMasterUserPassword = manageMasterUserPassword
            self.masterUsername = masterUsername
            self.masterUserPassword = masterUserPassword
            self.masterUserSecretKmsKeyId = masterUserSecretKmsKeyId
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.publiclyAccessible = publiclyAccessible
            self.s3BucketName = s3BucketName
            self.s3IngestionRoleArn = s3IngestionRoleArn
            self.s3Prefix = s3Prefix
            self.sourceEngine = sourceEngine
            self.sourceEngineVersion = sourceEngineVersion
            self.storageEncrypted = storageEncrypted
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tags = tags
            self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbName = "DBName"
            case dbParameterGroupName = "DBParameterGroupName"
            case dbSecurityGroups = "DBSecurityGroups"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case enablePerformanceInsights = "EnablePerformanceInsights"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case manageMasterUserPassword = "ManageMasterUserPassword"
            case masterUsername = "MasterUsername"
            case masterUserPassword = "MasterUserPassword"
            case masterUserSecretKmsKeyId = "MasterUserSecretKmsKeyId"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case processorFeatures = "ProcessorFeatures"
            case publiclyAccessible = "PubliclyAccessible"
            case s3BucketName = "S3BucketName"
            case s3IngestionRoleArn = "S3IngestionRoleArn"
            case s3Prefix = "S3Prefix"
            case sourceEngine = "SourceEngine"
            case sourceEngineVersion = "SourceEngineVersion"
            case storageEncrypted = "StorageEncrypted"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tags = "Tags"
            case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct RestoreDBInstanceFromS3Result: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct RestoreDBInstanceToPointInTimeMessage: AWSEncodableShape {
        public struct _ProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "ProcessorFeature" }
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }
        public struct _VpcSecurityGroupIdsEncoding: ArrayCoderProperties { public static let member = "VpcSecurityGroupId" }

        /// The amount of storage (in gibibytes) to allocate initially for the DB instance. Follow the allocation rules specified in CreateDBInstance.  Be sure to allocate enough storage for your new DB instance so that the restore operation can succeed. You can also allocate additional storage for future growth.
        public let allocatedStorage: Int?
        /// Specifies whether minor version upgrades are applied automatically to the  DB instance during the maintenance window. This setting doesn't apply to RDS Custom.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone (AZ) where the DB instance will be created. Default: A random, system-chosen Availability Zone. Constraints:   You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.   Example: us-east-1a
        public let availabilityZone: String?
        /// The location for storing automated backups and manual snapshots for the restored DB instance. Valid Values:    outposts (Amazon Web Services Outposts)    region (Amazon Web Services Region)   Default: region  For more information, see Working  with Amazon RDS on Amazon Web Services Outposts in the Amazon RDS User Guide.
        public let backupTarget: String?
        /// Specifies whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.
        public let copyTagsToSnapshot: Bool?
        /// The instance profile associated with the underlying Amazon EC2 instance of an  RDS Custom DB instance. The instance profile must meet the following requirements:   The profile must exist in your account.   The profile must have an IAM role that Amazon EC2 has permissions to assume.   The instance profile name and the associated IAM role name must start with the prefix AWSRDSCustom.   For the list of permissions required for the IAM role, see   Configure IAM and your VPC in the Amazon RDS User Guide. This setting is required for RDS Custom.
        public let customIamInstanceProfile: String?
        /// The compute and memory capacity of the Amazon RDS DB instance, for example db.m4.large. Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see DB Instance Class in the Amazon RDS User Guide. Default: The same DB instance class as the original DB instance.
        public let dbInstanceClass: String?
        /// The database name for the restored DB instance. This parameter doesn't apply to the following DB instances:   RDS Custom   RDS for Db2   RDS for MariaDB   RDS for MySQL
        public let dbName: String?
        /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup  for the specified DB engine is used. This setting doesn't apply to RDS Custom. Constraints:   If supplied, must match the name of an existing DB parameter group.   Must be 1 to 255 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.
        public let dbParameterGroupName: String?
        /// The DB subnet group name to use for the new instance. Constraints:   If supplied, must match the name of an existing DB subnet group.   Example: mydbsubnetgroup
        public let dbSubnetGroupName: String?
        /// Specifies whether to enable a dedicated log volume (DLV) for the DB instance.
        public let dedicatedLogVolume: Bool?
        /// Specifies whether the DB instance has deletion protection enabled.  The database can't be deleted when deletion protection is enabled. By default,  deletion protection isn't enabled. For more information, see   Deleting a DB Instance.
        public let deletionProtection: Bool?
        /// The Active Directory directory ID to restore the DB instance in. Create the domain before running this command. Currently, you can create only the MySQL, Microsoft SQL  Server, Oracle, and PostgreSQL DB instances in an Active Directory Domain. This setting doesn't apply to RDS Custom. For more information, see  Kerberos Authentication in the Amazon RDS User Guide.
        public let domain: String?
        /// The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Constraints:   Can't be longer than 64 characters.   Example: arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456
        public let domainAuthSecretArn: String?
        /// The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:   Two IP addresses must be provided.  If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: 123.124.125.126,234.235.236.237
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var domainDnsIps: [String]?
        /// The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:   Can't be longer than 64 characters.   Example: mymanagedADtest.mymanagedAD.mydomain
        public let domainFqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to RDS Custom DB instances.
        public let domainIAMRoleName: String?
        /// The Active Directory organizational unit for your DB instance to join. Constraints:   Must be in the distinguished name format.   Can't be longer than 64 characters.   Example: OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain
        public let domainOu: String?
        /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see  Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var enableCloudwatchLogsExports: [String]?
        /// Specifies whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. A CoIP provides local or external connectivity to resources in your Outpost subnets through your on-premises network. For some use cases, a CoIP can provide lower latency for connections to the DB instance from outside of its virtual private cloud (VPC) on your local network. This setting doesn't apply to RDS Custom. For more information about RDS on Outposts, see Working with Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide. For more information about CoIPs, see Customer-owned IP addresses  in the Amazon Web Services Outposts User Guide.
        public let enableCustomerOwnedIp: Bool?
        /// Specifies whether to enable mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts. By default, mapping isn't enabled. This setting doesn't apply to RDS Custom. For more information about IAM database authentication, see   IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
        public let enableIAMDatabaseAuthentication: Bool?
        /// The database engine to use for the new instance. This setting doesn't apply to RDS Custom. Valid Values:    db2-ae     db2-se     mariadb     mysql     oracle-ee     oracle-ee-cdb     oracle-se2     oracle-se2-cdb     postgres     sqlserver-ee     sqlserver-se     sqlserver-ex     sqlserver-web    Default: The same as source Constraints:   Must be compatible with the engine of the source.
        public let engine: String?
        /// The amount of Provisioned IOPS (input/output operations per second) to initially allocate for the DB instance. This setting doesn't apply to SQL Server. Constraints:   Must be an integer greater than 1000.
        public let iops: Int?
        /// The license model information for the restored DB instance. This setting doesn't apply to RDS Custom. Valid Values: license-included | bring-your-own-license | general-public-license  Default: Same as the source.
        public let licenseModel: String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see   Managing capacity automatically with Amazon RDS storage autoscaling  in the Amazon RDS User Guide. This setting doesn't apply to RDS Custom.
        public let maxAllocatedStorage: Int?
        /// Secifies whether the DB instance is a Multi-AZ deployment. This setting doesn't apply to RDS Custom. Constraints:   You can't specify the AvailabilityZone parameter if the DB instance is a  Multi-AZ deployment.
        public let multiAZ: Bool?
        /// The network type of the DB instance. The network type is determined by the DBSubnetGroup specified for the DB instance.  A DBSubnetGroup can support only the IPv4 protocol or the IPv4 and the IPv6  protocols (DUAL). For more information, see  Working with a DB instance in a VPC in the  Amazon RDS User Guide.  Valid Values:    IPV4     DUAL
        public let networkType: String?
        /// The name of the option group to use for the restored DB instance. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an  option group, and that option group can't be removed from a DB instance after it is associated with a DB instance This setting doesn't apply to RDS Custom.
        public let optionGroupName: String?
        /// The port number on which the database accepts connections. Default: The same port as the original DB instance. Constraints:   The value must be 1150-65535.
        public let port: Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom.
        @OptionalCustomCoding<ArrayCoder<_ProcessorFeaturesEncoding, ProcessorFeature>>
        public var processorFeatures: [ProcessorFeature]?
        /// Specifies whether the DB instance is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address. For more information, see CreateDBInstance.
        public let publiclyAccessible: Bool?
        /// The date and time to restore from. Constraints:   Must be a time in Universal Coordinated Time (UTC) format.   Must be before the latest restorable time for the DB instance.   Can't be specified if the UseLatestRestorableTime parameter is enabled.   Example: 2009-09-07T23:45:00Z
        public let restoreTime: Date?
        /// The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example,  arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE. This setting doesn't apply to RDS Custom.
        public let sourceDBInstanceAutomatedBackupsArn: String?
        /// The identifier of the source DB instance from which to restore. Constraints:   Must match the identifier of an existing DB instance.
        public let sourceDBInstanceIdentifier: String?
        /// The resource ID of the source DB instance from which to restore.
        public let sourceDbiResourceId: String?
        /// The storage throughput value for the DB instance. This setting doesn't apply to RDS Custom or Amazon Aurora.
        public let storageThroughput: Int?
        /// The storage type to associate with the DB instance. Valid Values: gp2 | gp3 | io1 | io2 | standard  Default: io1, if the Iops parameter is specified. Otherwise, gp2. Constraints:   If you specify io1, io2, or gp3, you must also include a value for the Iops parameter.
        public let storageType: String?
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, Tag>>
        public var tags: [Tag]?
        /// The name of the new DB instance to create. Constraints:   Must contain from 1 to 63 letters, numbers, or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.
        public let targetDBInstanceIdentifier: String?
        /// The ARN from the key store with which to associate the instance for TDE encryption. This setting doesn't apply to RDS Custom.
        public let tdeCredentialArn: String?
        /// The password for the given ARN from the key store in order to access the device. This setting doesn't apply to RDS Custom.
        public let tdeCredentialPassword: String?
        /// Specifies whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
        public let useDefaultProcessorFeatures: Bool?
        /// Specifies whether the DB instance is restored from the latest backup time. By default, the DB instance  isn't restored from the latest backup time. Constraints:   Can't be specified if the RestoreTime parameter is provided.
        public let useLatestRestorableTime: Bool?
        /// A list of EC2 VPC security groups to associate with this DB instance. Default: The default EC2 VPC security group for the DB subnet group's VPC.
        @OptionalCustomCoding<ArrayCoder<_VpcSecurityGroupIdsEncoding, String>>
        public var vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, backupTarget: String? = nil, copyTagsToSnapshot: Bool? = nil, customIamInstanceProfile: String? = nil, dbInstanceClass: String? = nil, dbName: String? = nil, dbParameterGroupName: String? = nil, dbSubnetGroupName: String? = nil, dedicatedLogVolume: Bool? = nil, deletionProtection: Bool? = nil, domain: String? = nil, domainAuthSecretArn: String? = nil, domainDnsIps: [String]? = nil, domainFqdn: String? = nil, domainIAMRoleName: String? = nil, domainOu: String? = nil, enableCloudwatchLogsExports: [String]? = nil, enableCustomerOwnedIp: Bool? = nil, enableIAMDatabaseAuthentication: Bool? = nil, engine: String? = nil, iops: Int? = nil, licenseModel: String? = nil, maxAllocatedStorage: Int? = nil, multiAZ: Bool? = nil, networkType: String? = nil, optionGroupName: String? = nil, port: Int? = nil, processorFeatures: [ProcessorFeature]? = nil, publiclyAccessible: Bool? = nil, restoreTime: Date? = nil, sourceDBInstanceAutomatedBackupsArn: String? = nil, sourceDBInstanceIdentifier: String? = nil, sourceDbiResourceId: String? = nil, storageThroughput: Int? = nil, storageType: String? = nil, tags: [Tag]? = nil, targetDBInstanceIdentifier: String? = nil, tdeCredentialArn: String? = nil, tdeCredentialPassword: String? = nil, useDefaultProcessorFeatures: Bool? = nil, useLatestRestorableTime: Bool? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupTarget = backupTarget
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customIamInstanceProfile = customIamInstanceProfile
            self.dbInstanceClass = dbInstanceClass
            self.dbName = dbName
            self.dbParameterGroupName = dbParameterGroupName
            self.dbSubnetGroupName = dbSubnetGroupName
            self.dedicatedLogVolume = dedicatedLogVolume
            self.deletionProtection = deletionProtection
            self.domain = domain
            self.domainAuthSecretArn = domainAuthSecretArn
            self.domainDnsIps = domainDnsIps
            self.domainFqdn = domainFqdn
            self.domainIAMRoleName = domainIAMRoleName
            self.domainOu = domainOu
            self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
            self.enableCustomerOwnedIp = enableCustomerOwnedIp
            self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
            self.engine = engine
            self.iops = iops
            self.licenseModel = licenseModel
            self.maxAllocatedStorage = maxAllocatedStorage
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.optionGroupName = optionGroupName
            self.port = port
            self.processorFeatures = processorFeatures
            self.publiclyAccessible = publiclyAccessible
            self.restoreTime = restoreTime
            self.sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn
            self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
            self.sourceDbiResourceId = sourceDbiResourceId
            self.storageThroughput = storageThroughput
            self.storageType = storageType
            self.tags = tags
            self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
            self.tdeCredentialArn = tdeCredentialArn
            self.tdeCredentialPassword = tdeCredentialPassword
            self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
            self.useLatestRestorableTime = useLatestRestorableTime
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case backupTarget = "BackupTarget"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case customIamInstanceProfile = "CustomIamInstanceProfile"
            case dbInstanceClass = "DBInstanceClass"
            case dbName = "DBName"
            case dbParameterGroupName = "DBParameterGroupName"
            case dbSubnetGroupName = "DBSubnetGroupName"
            case dedicatedLogVolume = "DedicatedLogVolume"
            case deletionProtection = "DeletionProtection"
            case domain = "Domain"
            case domainAuthSecretArn = "DomainAuthSecretArn"
            case domainDnsIps = "DomainDnsIps"
            case domainFqdn = "DomainFqdn"
            case domainIAMRoleName = "DomainIAMRoleName"
            case domainOu = "DomainOu"
            case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
            case enableCustomerOwnedIp = "EnableCustomerOwnedIp"
            case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
            case engine = "Engine"
            case iops = "Iops"
            case licenseModel = "LicenseModel"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case optionGroupName = "OptionGroupName"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case publiclyAccessible = "PubliclyAccessible"
            case restoreTime = "RestoreTime"
            case sourceDBInstanceAutomatedBackupsArn = "SourceDBInstanceAutomatedBackupsArn"
            case sourceDBInstanceIdentifier = "SourceDBInstanceIdentifier"
            case sourceDbiResourceId = "SourceDbiResourceId"
            case storageThroughput = "StorageThroughput"
            case storageType = "StorageType"
            case tags = "Tags"
            case targetDBInstanceIdentifier = "TargetDBInstanceIdentifier"
            case tdeCredentialArn = "TdeCredentialArn"
            case tdeCredentialPassword = "TdeCredentialPassword"
            case useDefaultProcessorFeatures = "UseDefaultProcessorFeatures"
            case useLatestRestorableTime = "UseLatestRestorableTime"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct RestoreDBInstanceToPointInTimeResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct RestoreWindow: AWSDecodableShape {
        /// The earliest time you can restore an instance to.
        public let earliestTime: Date?
        /// The latest time you can restore an instance to.
        public let latestTime: Date?

        public init(earliestTime: Date? = nil, latestTime: Date? = nil) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

        private enum CodingKeys: String, CodingKey {
            case earliestTime = "EarliestTime"
            case latestTime = "LatestTime"
        }
    }

    public struct RevokeDBSecurityGroupIngressMessage: AWSEncodableShape {
        /// The IP range to revoke access from.  Must be a valid CIDR range. If CIDRIP is specified,  EC2SecurityGroupName, EC2SecurityGroupId and EC2SecurityGroupOwnerId can't be provided.
        public let cidrip: String?
        /// The name of the DB security group to revoke ingress from.
        public let dbSecurityGroupName: String?
        /// The id of the EC2 security group to revoke access from. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
        public let ec2SecurityGroupId: String?
        /// The name of the EC2 security group to revoke access from. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
        public let ec2SecurityGroupName: String?
        /// The Amazon Web Services account number of the owner of the EC2 security group specified in the EC2SecurityGroupName parameter. The Amazon Web Services access key ID isn't an acceptable value. For VPC DB security groups, EC2SecurityGroupId must be provided. Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
        public let ec2SecurityGroupOwnerId: String?

        public init(cidrip: String? = nil, dbSecurityGroupName: String? = nil, ec2SecurityGroupId: String? = nil, ec2SecurityGroupName: String? = nil, ec2SecurityGroupOwnerId: String? = nil) {
            self.cidrip = cidrip
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
        }

        private enum CodingKeys: String, CodingKey {
            case cidrip = "CIDRIP"
            case dbSecurityGroupName = "DBSecurityGroupName"
            case ec2SecurityGroupId = "EC2SecurityGroupId"
            case ec2SecurityGroupName = "EC2SecurityGroupName"
            case ec2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        }
    }

    public struct RevokeDBSecurityGroupIngressResult: AWSDecodableShape {
        public let dbSecurityGroup: DBSecurityGroup?

        public init(dbSecurityGroup: DBSecurityGroup? = nil) {
            self.dbSecurityGroup = dbSecurityGroup
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroup = "DBSecurityGroup"
        }
    }

    public struct ScalarReferenceDetails: AWSDecodableShape {
        /// The value of a scalar reference.
        public let value: Double?

        public init(value: Double? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct ScalingConfiguration: AWSEncodableShape {
        /// Indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).  If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it.
        public let autoPause: Bool?
        /// The maximum capacity for an Aurora DB cluster in serverless DB engine mode. For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256. For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384. The maximum capacity must be greater than or equal to the minimum capacity.
        public let maxCapacity: Int?
        /// The minimum capacity for an Aurora DB cluster in serverless DB engine mode. For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256. For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384. The minimum capacity must be less than or equal to the maximum capacity.
        public let minCapacity: Int?
        /// The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300. Specify a value between 60 and 600 seconds.
        public let secondsBeforeTimeout: Int?
        /// The time, in seconds, before an Aurora DB cluster in serverless mode is paused. Specify a value between 300 and 86,400 seconds.
        public let secondsUntilAutoPause: Int?
        /// The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.  ForceApplyCapacityChange sets the capacity to the specified value as soon as possible.  RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period.  If you specify ForceApplyCapacityChange, connections that prevent Aurora Serverless v1 from finding a scaling point might be dropped.  For more information, see  Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
        public let timeoutAction: String?

        public init(autoPause: Bool? = nil, maxCapacity: Int? = nil, minCapacity: Int? = nil, secondsBeforeTimeout: Int? = nil, secondsUntilAutoPause: Int? = nil, timeoutAction: String? = nil) {
            self.autoPause = autoPause
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.secondsUntilAutoPause = secondsUntilAutoPause
            self.timeoutAction = timeoutAction
        }

        private enum CodingKeys: String, CodingKey {
            case autoPause = "AutoPause"
            case maxCapacity = "MaxCapacity"
            case minCapacity = "MinCapacity"
            case secondsBeforeTimeout = "SecondsBeforeTimeout"
            case secondsUntilAutoPause = "SecondsUntilAutoPause"
            case timeoutAction = "TimeoutAction"
        }
    }

    public struct ScalingConfigurationInfo: AWSDecodableShape {
        /// Indicates whether automatic pause is allowed for the Aurora DB cluster in serverless DB engine mode. When the value is set to false for an Aurora Serverless v1 DB cluster, the DB cluster automatically resumes.
        public let autoPause: Bool?
        /// The maximum capacity for an Aurora DB cluster in serverless DB engine mode.
        public let maxCapacity: Int?
        /// The minimum capacity for an Aurora DB cluster in serverless DB engine mode.
        public let minCapacity: Int?
        /// The number of seconds before scaling times out. What happens when an attempted scaling action times out is determined by the TimeoutAction setting.
        public let secondsBeforeTimeout: Int?
        /// The remaining amount of time, in seconds, before the Aurora DB cluster in serverless mode is paused. A DB cluster can be paused only when it's idle (it has no connections).
        public let secondsUntilAutoPause: Int?
        /// The action that occurs when Aurora times out while attempting to change the capacity of an Aurora Serverless v1 cluster. The value is either ForceApplyCapacityChange or RollbackCapacityChange.  ForceApplyCapacityChange, the default, sets the capacity to the specified value as soon as possible.  RollbackCapacityChange ignores the capacity change if a scaling point isn't found in the timeout period.
        public let timeoutAction: String?

        public init(autoPause: Bool? = nil, maxCapacity: Int? = nil, minCapacity: Int? = nil, secondsBeforeTimeout: Int? = nil, secondsUntilAutoPause: Int? = nil, timeoutAction: String? = nil) {
            self.autoPause = autoPause
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.secondsUntilAutoPause = secondsUntilAutoPause
            self.timeoutAction = timeoutAction
        }

        private enum CodingKeys: String, CodingKey {
            case autoPause = "AutoPause"
            case maxCapacity = "MaxCapacity"
            case minCapacity = "MinCapacity"
            case secondsBeforeTimeout = "SecondsBeforeTimeout"
            case secondsUntilAutoPause = "SecondsUntilAutoPause"
            case timeoutAction = "TimeoutAction"
        }
    }

    public struct ServerlessV2ScalingConfiguration: AWSEncodableShape {
        /// The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
        public let maxCapacity: Double?
        /// The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
        public let minCapacity: Double?

        public init(maxCapacity: Double? = nil, minCapacity: Double? = nil) {
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case maxCapacity = "MaxCapacity"
            case minCapacity = "MinCapacity"
        }
    }

    public struct ServerlessV2ScalingConfigurationInfo: AWSDecodableShape {
        /// The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
        public let maxCapacity: Double?
        /// The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
        public let minCapacity: Double?

        public init(maxCapacity: Double? = nil, minCapacity: Double? = nil) {
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case maxCapacity = "MaxCapacity"
            case minCapacity = "MinCapacity"
        }
    }

    public struct SourceRegion: AWSDecodableShape {
        /// The endpoint for the source Amazon Web Services Region endpoint.
        public let endpoint: String?
        /// The name of the source Amazon Web Services Region.
        public let regionName: String?
        /// The status of the source Amazon Web Services Region.
        public let status: String?
        /// Indicates whether the source Amazon Web Services Region supports replicating automated backups to the current Amazon Web Services Region.
        public let supportsDBInstanceAutomatedBackupsReplication: Bool?

        public init(endpoint: String? = nil, regionName: String? = nil, status: String? = nil, supportsDBInstanceAutomatedBackupsReplication: Bool? = nil) {
            self.endpoint = endpoint
            self.regionName = regionName
            self.status = status
            self.supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplication
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case regionName = "RegionName"
            case status = "Status"
            case supportsDBInstanceAutomatedBackupsReplication = "SupportsDBInstanceAutomatedBackupsReplication"
        }
    }

    public struct SourceRegionMessage: AWSDecodableShape {
        public struct _SourceRegionsEncoding: ArrayCoderProperties { public static let member = "SourceRegion" }

        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A list of SourceRegion instances that contains each source Amazon Web Services Region that the current Amazon Web Services Region can get a read replica or a DB snapshot from.
        @OptionalCustomCoding<ArrayCoder<_SourceRegionsEncoding, SourceRegion>>
        public var sourceRegions: [SourceRegion]?

        public init(marker: String? = nil, sourceRegions: [SourceRegion]? = nil) {
            self.marker = marker
            self.sourceRegions = sourceRegions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case sourceRegions = "SourceRegions"
        }
    }

    public struct StartActivityStreamRequest: AWSEncodableShape {
        /// Specifies whether or not the database activity stream is to start as soon as possible,  regardless of the maintenance window for the database.
        public let applyImmediately: Bool?
        /// Specifies whether the database activity stream includes engine-native audit fields. This option applies to an Oracle or Microsoft SQL Server DB instance. By default, no engine-native audit fields are included.
        public let engineNativeAuditFieldsIncluded: Bool?
        /// The Amazon Web Services KMS key identifier for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// Specifies the mode of the database activity stream. Database events such as a change or access generate an activity stream event. The database session can handle these events either synchronously or asynchronously.
        public let mode: ActivityStreamMode?
        /// The Amazon Resource Name (ARN) of the DB cluster, for example, arn:aws:rds:us-east-1:12345667890:cluster:das-cluster.
        public let resourceArn: String?

        public init(applyImmediately: Bool? = nil, engineNativeAuditFieldsIncluded: Bool? = nil, kmsKeyId: String? = nil, mode: ActivityStreamMode? = nil, resourceArn: String? = nil) {
            self.applyImmediately = applyImmediately
            self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
            self.kmsKeyId = kmsKeyId
            self.mode = mode
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case applyImmediately = "ApplyImmediately"
            case engineNativeAuditFieldsIncluded = "EngineNativeAuditFieldsIncluded"
            case kmsKeyId = "KmsKeyId"
            case mode = "Mode"
            case resourceArn = "ResourceArn"
        }
    }

    public struct StartActivityStreamResponse: AWSDecodableShape {
        /// Indicates whether or not the database activity stream will start as soon as possible,  regardless of the maintenance window for the database.
        public let applyImmediately: Bool?
        /// Indicates whether engine-native audit fields are included in the database activity stream.
        public let engineNativeAuditFieldsIncluded: Bool?
        /// The name of the Amazon Kinesis data stream to be used for the database activity stream.
        public let kinesisStreamName: String?
        /// The Amazon Web Services KMS key identifier for encryption of messages in the database activity stream.
        public let kmsKeyId: String?
        /// The mode of the database activity stream.
        public let mode: ActivityStreamMode?
        /// The status of the database activity stream.
        public let status: ActivityStreamStatus?

        public init(applyImmediately: Bool? = nil, engineNativeAuditFieldsIncluded: Bool? = nil, kinesisStreamName: String? = nil, kmsKeyId: String? = nil, mode: ActivityStreamMode? = nil, status: ActivityStreamStatus? = nil) {
            self.applyImmediately = applyImmediately
            self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
            self.kinesisStreamName = kinesisStreamName
            self.kmsKeyId = kmsKeyId
            self.mode = mode
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case applyImmediately = "ApplyImmediately"
            case engineNativeAuditFieldsIncluded = "EngineNativeAuditFieldsIncluded"
            case kinesisStreamName = "KinesisStreamName"
            case kmsKeyId = "KmsKeyId"
            case mode = "Mode"
            case status = "Status"
        }
    }

    public struct StartDBClusterMessage: AWSEncodableShape {
        /// The DB cluster identifier of the Amazon Aurora DB cluster to be started. This parameter is stored as a lowercase string.
        public let dbClusterIdentifier: String?

        public init(dbClusterIdentifier: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
        }
    }

    public struct StartDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct StartDBInstanceAutomatedBackupsReplicationMessage: AWSEncodableShape {
        /// The retention period for the replicated automated backups.
        public let backupRetentionPeriod: Int?
        /// The Amazon Web Services KMS key identifier for encryption of the replicated automated backups. The KMS key ID is the Amazon Resource Name (ARN) for the KMS encryption key in the destination Amazon Web Services Region, for example,  arn:aws:kms:us-east-1:123456789012:key/AKIAIOSFODNN7EXAMPLE.
        public let kmsKeyId: String?
        /// In an Amazon Web Services GovCloud (US) Region, an URL that contains a Signature Version 4 signed request  for the StartDBInstanceAutomatedBackupsReplication operation to call  in the Amazon Web Services Region of the source DB instance. The presigned URL must be a valid request for the StartDBInstanceAutomatedBackupsReplication API operation that can run in  the Amazon Web Services Region that contains the source DB instance. This setting applies only to Amazon Web Services GovCloud (US) Regions. It's ignored in other Amazon Web Services Regions. To learn how to generate a Signature Version 4 signed request, see   Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and  Signature Version 4 Signing Process.  If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI) instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a presigned URL that is a valid request for the operation that can run in the source Amazon Web Services Region.
        public let preSignedUrl: String?
        /// The Amazon Resource Name (ARN) of the source DB instance for the replicated automated backups, for example,  arn:aws:rds:us-west-2:123456789012:db:mydatabase.
        public let sourceDBInstanceArn: String?

        public init(backupRetentionPeriod: Int? = nil, kmsKeyId: String? = nil, preSignedUrl: String? = nil, sourceDBInstanceArn: String? = nil) {
            self.backupRetentionPeriod = backupRetentionPeriod
            self.kmsKeyId = kmsKeyId
            self.preSignedUrl = preSignedUrl
            self.sourceDBInstanceArn = sourceDBInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case kmsKeyId = "KmsKeyId"
            case preSignedUrl = "PreSignedUrl"
            case sourceDBInstanceArn = "SourceDBInstanceArn"
        }
    }

    public struct StartDBInstanceAutomatedBackupsReplicationResult: AWSDecodableShape {
        public let dbInstanceAutomatedBackup: DBInstanceAutomatedBackup?

        public init(dbInstanceAutomatedBackup: DBInstanceAutomatedBackup? = nil) {
            self.dbInstanceAutomatedBackup = dbInstanceAutomatedBackup
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
        }
    }

    public struct StartDBInstanceMessage: AWSEncodableShape {
        /// The user-supplied instance identifier.
        public let dbInstanceIdentifier: String?

        public init(dbInstanceIdentifier: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
        }
    }

    public struct StartDBInstanceResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct StartExportTaskMessage: AWSEncodableShape {
        /// The data to be exported from the snapshot or cluster.  If this parameter isn't provided, all of the data is exported. Valid Values:    database - Export all the data from a specified database.    database.table table-name -  Export a table of the snapshot or cluster. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.    database.schema schema-name - Export a database schema of the snapshot or cluster.  This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.    database.schema.table table-name - Export a table of the database schema.  This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var exportOnly: [String]?
        /// A unique identifier for the export task. This ID isn't an identifier for the Amazon S3 bucket where the data is to be exported.
        public let exportTaskIdentifier: String?
        /// The name of the IAM role to use for writing to the Amazon S3 bucket  when exporting a snapshot or cluster. In the IAM policy attached to your IAM role, include the following required actions to allow the transfer of files from Amazon RDS or Amazon Aurora to an S3 bucket:   s3:PutObject*   s3:GetObject*   s3:ListBucket   s3:DeleteObject*   s3:GetBucketLocation    In the policy, include the resources to identify the S3 bucket and objects in the bucket. The following list of resources shows the Amazon Resource Name (ARN) format for accessing S3:    arn:aws:s3:::your-s3-bucket      arn:aws:s3:::your-s3-bucket/*
        public let iamRoleArn: String?
        /// The ID of the Amazon Web Services KMS key to use to encrypt the data exported to Amazon S3. The Amazon Web Services KMS  key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.  The caller of this operation must be authorized to run the following operations.  These can be set in the Amazon Web Services KMS key policy:   kms:Encrypt   kms:Decrypt   kms:GenerateDataKey   kms:GenerateDataKeyWithoutPlaintext   kms:ReEncryptFrom   kms:ReEncryptTo   kms:CreateGrant   kms:DescribeKey   kms:RetireGrant
        public let kmsKeyId: String?
        /// The name of the Amazon S3 bucket to export the snapshot or cluster data to.
        public let s3BucketName: String?
        /// The Amazon S3 bucket prefix to use as the file name and path of the exported data.
        public let s3Prefix: String?
        /// The Amazon Resource Name (ARN) of the snapshot or cluster to export to Amazon S3.
        public let sourceArn: String?

        public init(exportOnly: [String]? = nil, exportTaskIdentifier: String? = nil, iamRoleArn: String? = nil, kmsKeyId: String? = nil, s3BucketName: String? = nil, s3Prefix: String? = nil, sourceArn: String? = nil) {
            self.exportOnly = exportOnly
            self.exportTaskIdentifier = exportTaskIdentifier
            self.iamRoleArn = iamRoleArn
            self.kmsKeyId = kmsKeyId
            self.s3BucketName = s3BucketName
            self.s3Prefix = s3Prefix
            self.sourceArn = sourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case exportOnly = "ExportOnly"
            case exportTaskIdentifier = "ExportTaskIdentifier"
            case iamRoleArn = "IamRoleArn"
            case kmsKeyId = "KmsKeyId"
            case s3BucketName = "S3BucketName"
            case s3Prefix = "S3Prefix"
            case sourceArn = "SourceArn"
        }
    }

    public struct StopActivityStreamRequest: AWSEncodableShape {
        /// Specifies whether or not the database activity stream is to stop as soon as possible,  regardless of the maintenance window for the database.
        public let applyImmediately: Bool?
        /// The Amazon Resource Name (ARN) of the DB cluster for the database activity stream. For example, arn:aws:rds:us-east-1:12345667890:cluster:das-cluster.
        public let resourceArn: String?

        public init(applyImmediately: Bool? = nil, resourceArn: String? = nil) {
            self.applyImmediately = applyImmediately
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case applyImmediately = "ApplyImmediately"
            case resourceArn = "ResourceArn"
        }
    }

    public struct StopActivityStreamResponse: AWSDecodableShape {
        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public let kinesisStreamName: String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream. The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        public let kmsKeyId: String?
        /// The status of the database activity stream.
        public let status: ActivityStreamStatus?

        public init(kinesisStreamName: String? = nil, kmsKeyId: String? = nil, status: ActivityStreamStatus? = nil) {
            self.kinesisStreamName = kinesisStreamName
            self.kmsKeyId = kmsKeyId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisStreamName = "KinesisStreamName"
            case kmsKeyId = "KmsKeyId"
            case status = "Status"
        }
    }

    public struct StopDBClusterMessage: AWSEncodableShape {
        /// The DB cluster identifier of the Amazon Aurora DB cluster to be stopped. This parameter is stored as a lowercase string.
        public let dbClusterIdentifier: String?

        public init(dbClusterIdentifier: String? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "DBClusterIdentifier"
        }
    }

    public struct StopDBClusterResult: AWSDecodableShape {
        public let dbCluster: DBCluster?

        public init(dbCluster: DBCluster? = nil) {
            self.dbCluster = dbCluster
        }

        private enum CodingKeys: String, CodingKey {
            case dbCluster = "DBCluster"
        }
    }

    public struct StopDBInstanceAutomatedBackupsReplicationMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the source DB instance for which to stop replicating automate backups, for example, arn:aws:rds:us-west-2:123456789012:db:mydatabase.
        public let sourceDBInstanceArn: String?

        public init(sourceDBInstanceArn: String? = nil) {
            self.sourceDBInstanceArn = sourceDBInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDBInstanceArn = "SourceDBInstanceArn"
        }
    }

    public struct StopDBInstanceAutomatedBackupsReplicationResult: AWSDecodableShape {
        public let dbInstanceAutomatedBackup: DBInstanceAutomatedBackup?

        public init(dbInstanceAutomatedBackup: DBInstanceAutomatedBackup? = nil) {
            self.dbInstanceAutomatedBackup = dbInstanceAutomatedBackup
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
        }
    }

    public struct StopDBInstanceMessage: AWSEncodableShape {
        /// The user-supplied instance identifier.
        public let dbInstanceIdentifier: String?
        /// The user-supplied instance identifier of the DB Snapshot created immediately before the DB instance is stopped.
        public let dbSnapshotIdentifier: String?

        public init(dbInstanceIdentifier: String? = nil, dbSnapshotIdentifier: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbSnapshotIdentifier = "DBSnapshotIdentifier"
        }
    }

    public struct StopDBInstanceResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct Subnet: AWSDecodableShape {
        public let subnetAvailabilityZone: AvailabilityZone?
        /// The identifier of the subnet.
        public let subnetIdentifier: String?
        /// If the subnet is associated with an Outpost, this value specifies the Outpost. For more information about RDS on Outposts, see Amazon RDS on Amazon Web Services Outposts  in the Amazon RDS User Guide.
        public let subnetOutpost: Outpost?
        /// The status of the subnet.
        public let subnetStatus: String?

        public init(subnetAvailabilityZone: AvailabilityZone? = nil, subnetIdentifier: String? = nil, subnetOutpost: Outpost? = nil, subnetStatus: String? = nil) {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetOutpost = subnetOutpost
            self.subnetStatus = subnetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetIdentifier = "SubnetIdentifier"
            case subnetOutpost = "SubnetOutpost"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct SwitchoverBlueGreenDeploymentRequest: AWSEncodableShape {
        /// The unique identifier of the blue/green deployment. Constraints:   Must match an existing blue/green deployment identifier.
        public let blueGreenDeploymentIdentifier: String?
        /// The amount of time, in seconds, for the switchover to complete. Default: 300 If the switchover takes longer than the specified duration, then any changes are rolled back,  and no changes are made to the environments.
        public let switchoverTimeout: Int?

        public init(blueGreenDeploymentIdentifier: String? = nil, switchoverTimeout: Int? = nil) {
            self.blueGreenDeploymentIdentifier = blueGreenDeploymentIdentifier
            self.switchoverTimeout = switchoverTimeout
        }

        public func validate(name: String) throws {
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, max: 255)
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, min: 1)
            try self.validate(self.blueGreenDeploymentIdentifier, name: "blueGreenDeploymentIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
            try self.validate(self.switchoverTimeout, name: "switchoverTimeout", parent: name, min: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeploymentIdentifier = "BlueGreenDeploymentIdentifier"
            case switchoverTimeout = "SwitchoverTimeout"
        }
    }

    public struct SwitchoverBlueGreenDeploymentResponse: AWSDecodableShape {
        public let blueGreenDeployment: BlueGreenDeployment?

        public init(blueGreenDeployment: BlueGreenDeployment? = nil) {
            self.blueGreenDeployment = blueGreenDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case blueGreenDeployment = "BlueGreenDeployment"
        }
    }

    public struct SwitchoverDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a resource in the blue environment.
        public let sourceMember: String?
        /// The switchover status of a resource in a blue/green deployment. Values:    PROVISIONING - The resource is being prepared to switch over.    AVAILABLE - The resource is ready to switch over.    SWITCHOVER_IN_PROGRESS - The resource is being switched over.    SWITCHOVER_COMPLETED - The resource has been switched over.    SWITCHOVER_FAILED - The resource attempted to switch over but failed.    MISSING_SOURCE - The source resource has been deleted.    MISSING_TARGET - The target resource has been deleted.
        public let status: String?
        /// The Amazon Resource Name (ARN) of a resource in the green environment.
        public let targetMember: String?

        public init(sourceMember: String? = nil, status: String? = nil, targetMember: String? = nil) {
            self.sourceMember = sourceMember
            self.status = status
            self.targetMember = targetMember
        }

        private enum CodingKeys: String, CodingKey {
            case sourceMember = "SourceMember"
            case status = "Status"
            case targetMember = "TargetMember"
        }
    }

    public struct SwitchoverGlobalClusterMessage: AWSEncodableShape {
        /// The identifier of the global database cluster to switch over. This parameter isn't case-sensitive. Constraints:   Must match the identifier of an existing global database cluster (Aurora global database).
        public let globalClusterIdentifier: String?
        /// The identifier of the secondary Aurora DB cluster to promote to the new primary for the global database cluster. Use the Amazon Resource Name (ARN) for the identifier so that Aurora can locate the cluster in its Amazon Web Services Region.
        public let targetDbClusterIdentifier: String?

        public init(globalClusterIdentifier: String? = nil, targetDbClusterIdentifier: String? = nil) {
            self.globalClusterIdentifier = globalClusterIdentifier
            self.targetDbClusterIdentifier = targetDbClusterIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, max: 255)
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, min: 1)
            try self.validate(self.globalClusterIdentifier, name: "globalClusterIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
            try self.validate(self.targetDbClusterIdentifier, name: "targetDbClusterIdentifier", parent: name, max: 255)
            try self.validate(self.targetDbClusterIdentifier, name: "targetDbClusterIdentifier", parent: name, min: 1)
            try self.validate(self.targetDbClusterIdentifier, name: "targetDbClusterIdentifier", parent: name, pattern: "^[A-Za-z][0-9A-Za-z-:._]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case globalClusterIdentifier = "GlobalClusterIdentifier"
            case targetDbClusterIdentifier = "TargetDbClusterIdentifier"
        }
    }

    public struct SwitchoverGlobalClusterResult: AWSDecodableShape {
        public let globalCluster: GlobalCluster?

        public init(globalCluster: GlobalCluster? = nil) {
            self.globalCluster = globalCluster
        }

        private enum CodingKeys: String, CodingKey {
            case globalCluster = "GlobalCluster"
        }
    }

    public struct SwitchoverReadReplicaMessage: AWSEncodableShape {
        /// The DB instance identifier of the current standby database. This value is stored as a lowercase string. Constraints:   Must match the identiﬁer of an existing Oracle read replica DB instance.
        public let dbInstanceIdentifier: String?

        public init(dbInstanceIdentifier: String? = nil) {
            self.dbInstanceIdentifier = dbInstanceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstanceIdentifier = "DBInstanceIdentifier"
        }
    }

    public struct SwitchoverReadReplicaResult: AWSDecodableShape {
        public let dbInstance: DBInstance?

        public init(dbInstance: DBInstance? = nil) {
            self.dbInstance = dbInstance
        }

        private enum CodingKeys: String, CodingKey {
            case dbInstance = "DBInstance"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        public let key: String?
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagListMessage: AWSDecodableShape {
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// List of tags returned by the ListTagsForResource operation.
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct TargetHealth: AWSDecodableShape {
        /// A description of the health of the RDS Proxy target.  If the State is AVAILABLE, a description is not included.
        public let description: String?
        /// The reason for the current health State of the RDS Proxy target.
        public let reason: TargetHealthReason?
        /// The current state of the connection health lifecycle for the RDS Proxy target. The following is a typical lifecycle example for the states of an RDS Proxy target:  registering > unavailable > available > unavailable > available
        public let state: TargetState?

        public init(description: String? = nil, reason: TargetHealthReason? = nil, state: TargetState? = nil) {
            self.description = description
            self.reason = reason
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case reason = "Reason"
            case state = "State"
        }
    }

    public struct TenantDatabase: AWSDecodableShape {
        public struct _TagListEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The character set of the tenant database.
        public let characterSetName: String?
        /// The ID of the DB instance that contains the tenant database.
        public let dbInstanceIdentifier: String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance.
        public let dbiResourceId: String?
        /// Specifies whether deletion protection is enabled for the DB instance.
        public let deletionProtection: Bool?
        /// The master username of the tenant database.
        public let masterUsername: String?
        /// The NCHAR character set name of the tenant database.
        public let ncharCharacterSetName: String?
        /// Information about pending changes for a tenant database.
        public let pendingModifiedValues: TenantDatabasePendingModifiedValues?
        /// The status of the tenant database.
        public let status: String?
        @OptionalCustomCoding<ArrayCoder<_TagListEncoding, Tag>>
        public var tagList: [Tag]?
        /// The Amazon Resource Name (ARN) for the tenant database.
        public let tenantDatabaseARN: String?
        /// The creation time of the tenant database.
        public let tenantDatabaseCreateTime: Date?
        /// The Amazon Web Services Region-unique, immutable identifier for the tenant database.
        public let tenantDatabaseResourceId: String?
        /// The database name of the tenant database.
        public let tenantDBName: String?

        public init(characterSetName: String? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, deletionProtection: Bool? = nil, masterUsername: String? = nil, ncharCharacterSetName: String? = nil, pendingModifiedValues: TenantDatabasePendingModifiedValues? = nil, status: String? = nil, tagList: [Tag]? = nil, tenantDatabaseARN: String? = nil, tenantDatabaseCreateTime: Date? = nil, tenantDatabaseResourceId: String? = nil, tenantDBName: String? = nil) {
            self.characterSetName = characterSetName
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.deletionProtection = deletionProtection
            self.masterUsername = masterUsername
            self.ncharCharacterSetName = ncharCharacterSetName
            self.pendingModifiedValues = pendingModifiedValues
            self.status = status
            self.tagList = tagList
            self.tenantDatabaseARN = tenantDatabaseARN
            self.tenantDatabaseCreateTime = tenantDatabaseCreateTime
            self.tenantDatabaseResourceId = tenantDatabaseResourceId
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case characterSetName = "CharacterSetName"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case deletionProtection = "DeletionProtection"
            case masterUsername = "MasterUsername"
            case ncharCharacterSetName = "NcharCharacterSetName"
            case pendingModifiedValues = "PendingModifiedValues"
            case status = "Status"
            case tagList = "TagList"
            case tenantDatabaseARN = "TenantDatabaseARN"
            case tenantDatabaseCreateTime = "TenantDatabaseCreateTime"
            case tenantDatabaseResourceId = "TenantDatabaseResourceId"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct TenantDatabasePendingModifiedValues: AWSDecodableShape {
        /// The master password for the tenant database.
        public let masterUserPassword: String?
        /// The name of the tenant database.
        public let tenantDBName: String?

        public init(masterUserPassword: String? = nil, tenantDBName: String? = nil) {
            self.masterUserPassword = masterUserPassword
            self.tenantDBName = tenantDBName
        }

        private enum CodingKeys: String, CodingKey {
            case masterUserPassword = "MasterUserPassword"
            case tenantDBName = "TenantDBName"
        }
    }

    public struct TenantDatabasesMessage: AWSDecodableShape {
        public struct _TenantDatabasesEncoding: ArrayCoderProperties { public static let member = "TenantDatabase" }

        /// An optional pagination token provided by a previous DescribeTenantDatabases request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// An array of the tenant databases requested by the DescribeTenantDatabases operation.
        @OptionalCustomCoding<ArrayCoder<_TenantDatabasesEncoding, TenantDatabase>>
        public var tenantDatabases: [TenantDatabase]?

        public init(marker: String? = nil, tenantDatabases: [TenantDatabase]? = nil) {
            self.marker = marker
            self.tenantDatabases = tenantDatabases
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case tenantDatabases = "TenantDatabases"
        }
    }

    public struct Timezone: AWSDecodableShape {
        /// The name of the time zone.
        public let timezoneName: String?

        public init(timezoneName: String? = nil) {
            self.timezoneName = timezoneName
        }

        private enum CodingKeys: String, CodingKey {
            case timezoneName = "TimezoneName"
        }
    }

    public struct UpgradeTarget: AWSDecodableShape {
        /// Indicates whether the target version is applied to any source DB instances that have AutoMinorVersionUpgrade set to true.
        public let autoUpgrade: Bool?
        /// The version of the database engine that a DB instance can be upgraded to.
        public let description: String?
        /// The name of the upgrade target database engine.
        public let engine: String?
        /// The version number of the upgrade target database engine.
        public let engineVersion: String?
        /// Indicates whether upgrading to the target version requires upgrading the major version of the database engine.
        public let isMajorVersionUpgrade: Bool?
        /// A list of the supported DB engine modes for the target engine version.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var supportedEngineModes: [String]?
        /// Indicates whether you can use Babelfish for Aurora PostgreSQL with the target engine version.
        public let supportsBabelfish: Bool?
        /// Indicates whether you can use Aurora global databases with the target engine version.
        public let supportsGlobalDatabases: Bool?
        /// Indicates whether the DB engine version supports zero-ETL integrations with Amazon Redshift.
        public let supportsIntegrations: Bool?
        /// Indicates whether the target engine version supports forwarding write operations from reader DB instances  to the writer DB instance in the DB cluster. By default, write operations aren't allowed on reader DB instances. Valid for: Aurora DB clusters only
        public let supportsLocalWriteForwarding: Bool?
        /// Indicates whether you can use Aurora parallel query with the target engine version.
        public let supportsParallelQuery: Bool?

        public init(autoUpgrade: Bool? = nil, description: String? = nil, engine: String? = nil, engineVersion: String? = nil, isMajorVersionUpgrade: Bool? = nil, supportedEngineModes: [String]? = nil, supportsBabelfish: Bool? = nil, supportsGlobalDatabases: Bool? = nil, supportsIntegrations: Bool? = nil, supportsLocalWriteForwarding: Bool? = nil, supportsParallelQuery: Bool? = nil) {
            self.autoUpgrade = autoUpgrade
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.isMajorVersionUpgrade = isMajorVersionUpgrade
            self.supportedEngineModes = supportedEngineModes
            self.supportsBabelfish = supportsBabelfish
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsIntegrations = supportsIntegrations
            self.supportsLocalWriteForwarding = supportsLocalWriteForwarding
            self.supportsParallelQuery = supportsParallelQuery
        }

        private enum CodingKeys: String, CodingKey {
            case autoUpgrade = "AutoUpgrade"
            case description = "Description"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case isMajorVersionUpgrade = "IsMajorVersionUpgrade"
            case supportedEngineModes = "SupportedEngineModes"
            case supportsBabelfish = "SupportsBabelfish"
            case supportsGlobalDatabases = "SupportsGlobalDatabases"
            case supportsIntegrations = "SupportsIntegrations"
            case supportsLocalWriteForwarding = "SupportsLocalWriteForwarding"
            case supportsParallelQuery = "SupportsParallelQuery"
        }
    }

    public struct UserAuthConfig: AWSEncodableShape {
        /// The type of authentication that the proxy uses for connections from the proxy to the underlying database.
        public let authScheme: AuthScheme?
        /// The type of authentication the proxy uses for connections from clients.
        public let clientPasswordAuthType: ClientPasswordAuthType?
        /// A user-specified description about the authentication used by a proxy to log in as a specific database user.
        public let description: String?
        /// A value that indicates whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy.  The ENABLED value is valid only for proxies with RDS for Microsoft SQL Server.
        public let iamAuth: IAMAuthMode?
        /// The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
        public let secretArn: String?
        /// The name of the database user to which the proxy connects.
        public let userName: String?

        public init(authScheme: AuthScheme? = nil, clientPasswordAuthType: ClientPasswordAuthType? = nil, description: String? = nil, iamAuth: IAMAuthMode? = nil, secretArn: String? = nil, userName: String? = nil) {
            self.authScheme = authScheme
            self.clientPasswordAuthType = clientPasswordAuthType
            self.description = description
            self.iamAuth = iamAuth
            self.secretArn = secretArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case authScheme = "AuthScheme"
            case clientPasswordAuthType = "ClientPasswordAuthType"
            case description = "Description"
            case iamAuth = "IAMAuth"
            case secretArn = "SecretArn"
            case userName = "UserName"
        }
    }

    public struct UserAuthConfigInfo: AWSDecodableShape {
        /// The type of authentication that the proxy uses for connections from the proxy to the underlying database.
        public let authScheme: AuthScheme?
        /// The type of authentication the proxy uses for connections from clients.
        public let clientPasswordAuthType: ClientPasswordAuthType?
        /// A user-specified description about the authentication used by a proxy to log in as a specific database user.
        public let description: String?
        /// Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy.  The ENABLED value is valid only for proxies with RDS for Microsoft SQL Server.
        public let iamAuth: IAMAuthMode?
        /// The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
        public let secretArn: String?
        /// The name of the database user to which the proxy connects.
        public let userName: String?

        public init(authScheme: AuthScheme? = nil, clientPasswordAuthType: ClientPasswordAuthType? = nil, description: String? = nil, iamAuth: IAMAuthMode? = nil, secretArn: String? = nil, userName: String? = nil) {
            self.authScheme = authScheme
            self.clientPasswordAuthType = clientPasswordAuthType
            self.description = description
            self.iamAuth = iamAuth
            self.secretArn = secretArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case authScheme = "AuthScheme"
            case clientPasswordAuthType = "ClientPasswordAuthType"
            case description = "Description"
            case iamAuth = "IAMAuth"
            case secretArn = "SecretArn"
            case userName = "UserName"
        }
    }

    public struct ValidDBInstanceModificationsMessage: AWSDecodableShape {
        public struct _StorageEncoding: ArrayCoderProperties { public static let member = "ValidStorageOptions" }
        public struct _ValidProcessorFeaturesEncoding: ArrayCoderProperties { public static let member = "AvailableProcessorFeature" }

        /// Valid storage options for your DB instance.
        @OptionalCustomCoding<ArrayCoder<_StorageEncoding, ValidStorageOptions>>
        public var storage: [ValidStorageOptions]?
        /// Indicates whether a DB instance supports using a dedicated log volume (DLV).
        public let supportsDedicatedLogVolume: Bool?
        /// Valid processor features for your DB instance.
        @OptionalCustomCoding<ArrayCoder<_ValidProcessorFeaturesEncoding, AvailableProcessorFeature>>
        public var validProcessorFeatures: [AvailableProcessorFeature]?

        public init(storage: [ValidStorageOptions]? = nil, supportsDedicatedLogVolume: Bool? = nil, validProcessorFeatures: [AvailableProcessorFeature]? = nil) {
            self.storage = storage
            self.supportsDedicatedLogVolume = supportsDedicatedLogVolume
            self.validProcessorFeatures = validProcessorFeatures
        }

        private enum CodingKeys: String, CodingKey {
            case storage = "Storage"
            case supportsDedicatedLogVolume = "SupportsDedicatedLogVolume"
            case validProcessorFeatures = "ValidProcessorFeatures"
        }
    }

    public struct ValidStorageOptions: AWSDecodableShape {
        public struct _IopsToStorageRatioEncoding: ArrayCoderProperties { public static let member = "DoubleRange" }
        public struct _ProvisionedIopsEncoding: ArrayCoderProperties { public static let member = "Range" }
        public struct _ProvisionedStorageThroughputEncoding: ArrayCoderProperties { public static let member = "Range" }
        public struct _StorageSizeEncoding: ArrayCoderProperties { public static let member = "Range" }
        public struct _StorageThroughputToIopsRatioEncoding: ArrayCoderProperties { public static let member = "DoubleRange" }

        /// The valid range of Provisioned IOPS to gibibytes of storage multiplier. For example, 3-10, which means that provisioned IOPS can be between 3 and 10 times storage.
        @OptionalCustomCoding<ArrayCoder<_IopsToStorageRatioEncoding, DoubleRange>>
        public var iopsToStorageRatio: [DoubleRange]?
        /// The valid range of provisioned IOPS. For example, 1000-256,000.
        @OptionalCustomCoding<ArrayCoder<_ProvisionedIopsEncoding, Range>>
        public var provisionedIops: [Range]?
        /// The valid range of provisioned storage throughput. For example,  500-4,000 mebibytes per second (MiBps).
        @OptionalCustomCoding<ArrayCoder<_ProvisionedStorageThroughputEncoding, Range>>
        public var provisionedStorageThroughput: [Range]?
        /// The valid range of storage in gibibytes (GiB). For example, 100 to 16,384.
        @OptionalCustomCoding<ArrayCoder<_StorageSizeEncoding, Range>>
        public var storageSize: [Range]?
        /// The valid range of storage throughput to provisioned IOPS ratios. For example,  0-0.25.
        @OptionalCustomCoding<ArrayCoder<_StorageThroughputToIopsRatioEncoding, DoubleRange>>
        public var storageThroughputToIopsRatio: [DoubleRange]?
        /// The valid storage types for your DB instance. For example: gp2, gp3, io1, io2.
        public let storageType: String?
        /// Indicates whether or not Amazon RDS can automatically scale storage for DB instances that use the new instance class.
        public let supportsStorageAutoscaling: Bool?

        public init(iopsToStorageRatio: [DoubleRange]? = nil, provisionedIops: [Range]? = nil, provisionedStorageThroughput: [Range]? = nil, storageSize: [Range]? = nil, storageThroughputToIopsRatio: [DoubleRange]? = nil, storageType: String? = nil, supportsStorageAutoscaling: Bool? = nil) {
            self.iopsToStorageRatio = iopsToStorageRatio
            self.provisionedIops = provisionedIops
            self.provisionedStorageThroughput = provisionedStorageThroughput
            self.storageSize = storageSize
            self.storageThroughputToIopsRatio = storageThroughputToIopsRatio
            self.storageType = storageType
            self.supportsStorageAutoscaling = supportsStorageAutoscaling
        }

        private enum CodingKeys: String, CodingKey {
            case iopsToStorageRatio = "IopsToStorageRatio"
            case provisionedIops = "ProvisionedIops"
            case provisionedStorageThroughput = "ProvisionedStorageThroughput"
            case storageSize = "StorageSize"
            case storageThroughputToIopsRatio = "StorageThroughputToIopsRatio"
            case storageType = "StorageType"
            case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
        }
    }

    public struct VpcSecurityGroupMembership: AWSDecodableShape {
        /// The membership status of the VPC security group. Currently, the only valid status is active.
        public let status: String?
        /// The name of the VPC security group.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }
}

// MARK: - Errors

/// Error enum for RDS
public struct RDSErrorType: AWSErrorType {
    enum Code: String {
        case authorizationAlreadyExistsFault = "AuthorizationAlreadyExists"
        case authorizationNotFoundFault = "AuthorizationNotFound"
        case authorizationQuotaExceededFault = "AuthorizationQuotaExceeded"
        case backupPolicyNotFoundFault = "BackupPolicyNotFoundFault"
        case blueGreenDeploymentAlreadyExistsFault = "BlueGreenDeploymentAlreadyExistsFault"
        case blueGreenDeploymentNotFoundFault = "BlueGreenDeploymentNotFoundFault"
        case certificateNotFoundFault = "CertificateNotFound"
        case createCustomDBEngineVersionFault = "CreateCustomDBEngineVersionFault"
        case customAvailabilityZoneNotFoundFault = "CustomAvailabilityZoneNotFound"
        case customDBEngineVersionAlreadyExistsFault = "CustomDBEngineVersionAlreadyExistsFault"
        case customDBEngineVersionNotFoundFault = "CustomDBEngineVersionNotFoundFault"
        case customDBEngineVersionQuotaExceededFault = "CustomDBEngineVersionQuotaExceededFault"
        case dbClusterAlreadyExistsFault = "DBClusterAlreadyExistsFault"
        case dbClusterAutomatedBackupNotFoundFault = "DBClusterAutomatedBackupNotFoundFault"
        case dbClusterAutomatedBackupQuotaExceededFault = "DBClusterAutomatedBackupQuotaExceededFault"
        case dbClusterBacktrackNotFoundFault = "DBClusterBacktrackNotFoundFault"
        case dbClusterEndpointAlreadyExistsFault = "DBClusterEndpointAlreadyExistsFault"
        case dbClusterEndpointNotFoundFault = "DBClusterEndpointNotFoundFault"
        case dbClusterEndpointQuotaExceededFault = "DBClusterEndpointQuotaExceededFault"
        case dbClusterNotFoundFault = "DBClusterNotFoundFault"
        case dbClusterParameterGroupNotFoundFault = "DBClusterParameterGroupNotFound"
        case dbClusterQuotaExceededFault = "DBClusterQuotaExceededFault"
        case dbClusterRoleAlreadyExistsFault = "DBClusterRoleAlreadyExists"
        case dbClusterRoleNotFoundFault = "DBClusterRoleNotFound"
        case dbClusterRoleQuotaExceededFault = "DBClusterRoleQuotaExceeded"
        case dbClusterSnapshotAlreadyExistsFault = "DBClusterSnapshotAlreadyExistsFault"
        case dbClusterSnapshotNotFoundFault = "DBClusterSnapshotNotFoundFault"
        case dbInstanceAlreadyExistsFault = "DBInstanceAlreadyExists"
        case dbInstanceAutomatedBackupNotFoundFault = "DBInstanceAutomatedBackupNotFound"
        case dbInstanceAutomatedBackupQuotaExceededFault = "DBInstanceAutomatedBackupQuotaExceeded"
        case dbInstanceNotFoundFault = "DBInstanceNotFound"
        case dbInstanceRoleAlreadyExistsFault = "DBInstanceRoleAlreadyExists"
        case dbInstanceRoleNotFoundFault = "DBInstanceRoleNotFound"
        case dbInstanceRoleQuotaExceededFault = "DBInstanceRoleQuotaExceeded"
        case dbLogFileNotFoundFault = "DBLogFileNotFoundFault"
        case dbParameterGroupAlreadyExistsFault = "DBParameterGroupAlreadyExists"
        case dbParameterGroupNotFoundFault = "DBParameterGroupNotFound"
        case dbParameterGroupQuotaExceededFault = "DBParameterGroupQuotaExceeded"
        case dbProxyAlreadyExistsFault = "DBProxyAlreadyExistsFault"
        case dbProxyEndpointAlreadyExistsFault = "DBProxyEndpointAlreadyExistsFault"
        case dbProxyEndpointNotFoundFault = "DBProxyEndpointNotFoundFault"
        case dbProxyEndpointQuotaExceededFault = "DBProxyEndpointQuotaExceededFault"
        case dbProxyNotFoundFault = "DBProxyNotFoundFault"
        case dbProxyQuotaExceededFault = "DBProxyQuotaExceededFault"
        case dbProxyTargetAlreadyRegisteredFault = "DBProxyTargetAlreadyRegisteredFault"
        case dbProxyTargetGroupNotFoundFault = "DBProxyTargetGroupNotFoundFault"
        case dbProxyTargetNotFoundFault = "DBProxyTargetNotFoundFault"
        case dbSecurityGroupAlreadyExistsFault = "DBSecurityGroupAlreadyExists"
        case dbSecurityGroupNotFoundFault = "DBSecurityGroupNotFound"
        case dbSecurityGroupNotSupportedFault = "DBSecurityGroupNotSupported"
        case dbSecurityGroupQuotaExceededFault = "QuotaExceeded.DBSecurityGroup"
        case dbShardGroupAlreadyExistsFault = "DBShardGroupAlreadyExists"
        case dbShardGroupNotFoundFault = "DBShardGroupNotFound"
        case dbSnapshotAlreadyExistsFault = "DBSnapshotAlreadyExists"
        case dbSnapshotNotFoundFault = "DBSnapshotNotFound"
        case dbSnapshotTenantDatabaseNotFoundFault = "DBSnapshotTenantDatabaseNotFoundFault"
        case dbSubnetGroupAlreadyExistsFault = "DBSubnetGroupAlreadyExists"
        case dbSubnetGroupDoesNotCoverEnoughAZs = "DBSubnetGroupDoesNotCoverEnoughAZs"
        case dbSubnetGroupNotAllowedFault = "DBSubnetGroupNotAllowedFault"
        case dbSubnetGroupNotFoundFault = "DBSubnetGroupNotFoundFault"
        case dbSubnetGroupQuotaExceededFault = "DBSubnetGroupQuotaExceeded"
        case dbSubnetQuotaExceededFault = "DBSubnetQuotaExceededFault"
        case dbUpgradeDependencyFailureFault = "DBUpgradeDependencyFailure"
        case domainNotFoundFault = "DomainNotFoundFault"
        case ec2ImagePropertiesNotSupportedFault = "Ec2ImagePropertiesNotSupportedFault"
        case eventSubscriptionQuotaExceededFault = "EventSubscriptionQuotaExceeded"
        case exportTaskAlreadyExistsFault = "ExportTaskAlreadyExists"
        case exportTaskNotFoundFault = "ExportTaskNotFound"
        case globalClusterAlreadyExistsFault = "GlobalClusterAlreadyExistsFault"
        case globalClusterNotFoundFault = "GlobalClusterNotFoundFault"
        case globalClusterQuotaExceededFault = "GlobalClusterQuotaExceededFault"
        case iamRoleMissingPermissionsFault = "IamRoleMissingPermissions"
        case iamRoleNotFoundFault = "IamRoleNotFound"
        case instanceQuotaExceededFault = "InstanceQuotaExceeded"
        case insufficientAvailableIPsInSubnetFault = "InsufficientAvailableIPsInSubnetFault"
        case insufficientDBClusterCapacityFault = "InsufficientDBClusterCapacityFault"
        case insufficientDBInstanceCapacityFault = "InsufficientDBInstanceCapacity"
        case insufficientStorageClusterCapacityFault = "InsufficientStorageClusterCapacity"
        case integrationAlreadyExistsFault = "IntegrationAlreadyExistsFault"
        case integrationConflictOperationFault = "IntegrationConflictOperationFault"
        case integrationNotFoundFault = "IntegrationNotFoundFault"
        case integrationQuotaExceededFault = "IntegrationQuotaExceededFault"
        case invalidBlueGreenDeploymentStateFault = "InvalidBlueGreenDeploymentStateFault"
        case invalidCustomDBEngineVersionStateFault = "InvalidCustomDBEngineVersionStateFault"
        case invalidDBClusterAutomatedBackupStateFault = "InvalidDBClusterAutomatedBackupStateFault"
        case invalidDBClusterCapacityFault = "InvalidDBClusterCapacityFault"
        case invalidDBClusterEndpointStateFault = "InvalidDBClusterEndpointStateFault"
        case invalidDBClusterSnapshotStateFault = "InvalidDBClusterSnapshotStateFault"
        case invalidDBClusterStateFault = "InvalidDBClusterStateFault"
        case invalidDBInstanceAutomatedBackupStateFault = "InvalidDBInstanceAutomatedBackupState"
        case invalidDBInstanceStateFault = "InvalidDBInstanceState"
        case invalidDBParameterGroupStateFault = "InvalidDBParameterGroupState"
        case invalidDBProxyEndpointStateFault = "InvalidDBProxyEndpointStateFault"
        case invalidDBProxyStateFault = "InvalidDBProxyStateFault"
        case invalidDBSecurityGroupStateFault = "InvalidDBSecurityGroupState"
        case invalidDBShardGroupStateFault = "InvalidDBShardGroupState"
        case invalidDBSnapshotStateFault = "InvalidDBSnapshotState"
        case invalidDBSubnetGroupFault = "InvalidDBSubnetGroupFault"
        case invalidDBSubnetGroupStateFault = "InvalidDBSubnetGroupStateFault"
        case invalidDBSubnetStateFault = "InvalidDBSubnetStateFault"
        case invalidEventSubscriptionStateFault = "InvalidEventSubscriptionState"
        case invalidExportOnlyFault = "InvalidExportOnly"
        case invalidExportSourceStateFault = "InvalidExportSourceState"
        case invalidExportTaskStateFault = "InvalidExportTaskStateFault"
        case invalidGlobalClusterStateFault = "InvalidGlobalClusterStateFault"
        case invalidIntegrationStateFault = "InvalidIntegrationStateFault"
        case invalidMaxAcuFault = "InvalidMaxAcu"
        case invalidOptionGroupStateFault = "InvalidOptionGroupStateFault"
        case invalidResourceStateFault = "InvalidResourceStateFault"
        case invalidRestoreFault = "InvalidRestoreFault"
        case invalidS3BucketFault = "InvalidS3BucketFault"
        case invalidSubnet = "InvalidSubnet"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case kmsKeyNotAccessibleFault = "KMSKeyNotAccessibleFault"
        case maxDBShardGroupLimitReached = "MaxDBShardGroupLimitReached"
        case networkTypeNotSupported = "NetworkTypeNotSupported"
        case optionGroupAlreadyExistsFault = "OptionGroupAlreadyExistsFault"
        case optionGroupNotFoundFault = "OptionGroupNotFoundFault"
        case optionGroupQuotaExceededFault = "OptionGroupQuotaExceededFault"
        case pointInTimeRestoreNotEnabledFault = "PointInTimeRestoreNotEnabled"
        case provisionedIopsNotAvailableInAZFault = "ProvisionedIopsNotAvailableInAZFault"
        case reservedDBInstanceAlreadyExistsFault = "ReservedDBInstanceAlreadyExists"
        case reservedDBInstanceNotFoundFault = "ReservedDBInstanceNotFound"
        case reservedDBInstanceQuotaExceededFault = "ReservedDBInstanceQuotaExceeded"
        case reservedDBInstancesOfferingNotFoundFault = "ReservedDBInstancesOfferingNotFound"
        case resourceNotFoundFault = "ResourceNotFoundFault"
        case sharedSnapshotQuotaExceededFault = "SharedSnapshotQuotaExceeded"
        case snapshotQuotaExceededFault = "SnapshotQuotaExceeded"
        case snsInvalidTopicFault = "SNSInvalidTopic"
        case snsNoAuthorizationFault = "SNSNoAuthorization"
        case snsTopicArnNotFoundFault = "SNSTopicArnNotFound"
        case sourceClusterNotSupportedFault = "SourceClusterNotSupportedFault"
        case sourceDatabaseNotSupportedFault = "SourceDatabaseNotSupportedFault"
        case sourceNotFoundFault = "SourceNotFound"
        case storageQuotaExceededFault = "StorageQuotaExceeded"
        case storageTypeNotAvailableFault = "StorageTypeNotAvailableFault"
        case storageTypeNotSupportedFault = "StorageTypeNotSupported"
        case subnetAlreadyInUse = "SubnetAlreadyInUse"
        case subscriptionAlreadyExistFault = "SubscriptionAlreadyExist"
        case subscriptionCategoryNotFoundFault = "SubscriptionCategoryNotFound"
        case subscriptionNotFoundFault = "SubscriptionNotFound"
        case tenantDatabaseAlreadyExistsFault = "TenantDatabaseAlreadyExists"
        case tenantDatabaseNotFoundFault = "TenantDatabaseNotFound"
        case tenantDatabaseQuotaExceededFault = "TenantDatabaseQuotaExceeded"
        case unsupportedDBEngineVersionFault = "UnsupportedDBEngineVersion"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RDS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified CIDR IP range or Amazon EC2 security group is already authorized for the specified DB security group.
    public static var authorizationAlreadyExistsFault: Self { .init(.authorizationAlreadyExistsFault) }
    /// The specified CIDR IP range or Amazon EC2 security group might not be authorized for the specified DB security group. Or, RDS might not be authorized to perform necessary actions using IAM on your behalf.
    public static var authorizationNotFoundFault: Self { .init(.authorizationNotFoundFault) }
    /// The DB security group authorization quota has been reached.
    public static var authorizationQuotaExceededFault: Self { .init(.authorizationQuotaExceededFault) }
    public static var backupPolicyNotFoundFault: Self { .init(.backupPolicyNotFoundFault) }
    /// A blue/green deployment with the specified name already exists.
    public static var blueGreenDeploymentAlreadyExistsFault: Self { .init(.blueGreenDeploymentAlreadyExistsFault) }
    ///  BlueGreenDeploymentIdentifier doesn't refer to an existing blue/green deployment.
    public static var blueGreenDeploymentNotFoundFault: Self { .init(.blueGreenDeploymentNotFoundFault) }
    ///  CertificateIdentifier doesn't refer to an existing certificate.
    public static var certificateNotFoundFault: Self { .init(.certificateNotFoundFault) }
    /// An error occurred while trying to create the CEV.
    public static var createCustomDBEngineVersionFault: Self { .init(.createCustomDBEngineVersionFault) }
    ///  CustomAvailabilityZoneId doesn't refer to an existing custom Availability Zone identifier.
    public static var customAvailabilityZoneNotFoundFault: Self { .init(.customAvailabilityZoneNotFoundFault) }
    /// A CEV with the specified name already exists.
    public static var customDBEngineVersionAlreadyExistsFault: Self { .init(.customDBEngineVersionAlreadyExistsFault) }
    /// The specified CEV was not found.
    public static var customDBEngineVersionNotFoundFault: Self { .init(.customDBEngineVersionNotFoundFault) }
    /// You have exceeded your CEV quota.
    public static var customDBEngineVersionQuotaExceededFault: Self { .init(.customDBEngineVersionQuotaExceededFault) }
    /// The user already has a DB cluster with the given identifier.
    public static var dbClusterAlreadyExistsFault: Self { .init(.dbClusterAlreadyExistsFault) }
    /// No automated backup for this DB cluster was found.
    public static var dbClusterAutomatedBackupNotFoundFault: Self { .init(.dbClusterAutomatedBackupNotFoundFault) }
    /// The quota for retained automated backups was exceeded. This prevents you from retaining any additional automated  backups. The retained automated backups quota is the same as your DB cluster quota.
    public static var dbClusterAutomatedBackupQuotaExceededFault: Self { .init(.dbClusterAutomatedBackupQuotaExceededFault) }
    ///  BacktrackIdentifier doesn't refer to an existing backtrack.
    public static var dbClusterBacktrackNotFoundFault: Self { .init(.dbClusterBacktrackNotFoundFault) }
    /// The specified custom endpoint can't be created because it already exists.
    public static var dbClusterEndpointAlreadyExistsFault: Self { .init(.dbClusterEndpointAlreadyExistsFault) }
    /// The specified custom endpoint doesn't exist.
    public static var dbClusterEndpointNotFoundFault: Self { .init(.dbClusterEndpointNotFoundFault) }
    /// The cluster already has the maximum number of custom endpoints.
    public static var dbClusterEndpointQuotaExceededFault: Self { .init(.dbClusterEndpointQuotaExceededFault) }
    ///  DBClusterIdentifier doesn't refer to an existing DB cluster.
    public static var dbClusterNotFoundFault: Self { .init(.dbClusterNotFoundFault) }
    ///  DBClusterParameterGroupName doesn't refer to an existing DB cluster parameter group.
    public static var dbClusterParameterGroupNotFoundFault: Self { .init(.dbClusterParameterGroupNotFoundFault) }
    /// The user attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.
    public static var dbClusterQuotaExceededFault: Self { .init(.dbClusterQuotaExceededFault) }
    /// The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.
    public static var dbClusterRoleAlreadyExistsFault: Self { .init(.dbClusterRoleAlreadyExistsFault) }
    /// The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.
    public static var dbClusterRoleNotFoundFault: Self { .init(.dbClusterRoleNotFoundFault) }
    /// You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.
    public static var dbClusterRoleQuotaExceededFault: Self { .init(.dbClusterRoleQuotaExceededFault) }
    /// The user already has a DB cluster snapshot with the given identifier.
    public static var dbClusterSnapshotAlreadyExistsFault: Self { .init(.dbClusterSnapshotAlreadyExistsFault) }
    ///  DBClusterSnapshotIdentifier doesn't refer to an existing DB cluster snapshot.
    public static var dbClusterSnapshotNotFoundFault: Self { .init(.dbClusterSnapshotNotFoundFault) }
    /// The user already has a DB instance with the given identifier.
    public static var dbInstanceAlreadyExistsFault: Self { .init(.dbInstanceAlreadyExistsFault) }
    /// No automated backup for this DB instance was found.
    public static var dbInstanceAutomatedBackupNotFoundFault: Self { .init(.dbInstanceAutomatedBackupNotFoundFault) }
    /// The quota for retained automated backups was exceeded. This prevents you from retaining any additional automated backups. The retained automated backups  quota is the same as your DB instance quota.
    public static var dbInstanceAutomatedBackupQuotaExceededFault: Self { .init(.dbInstanceAutomatedBackupQuotaExceededFault) }
    ///  DBInstanceIdentifier doesn't refer to an existing DB instance.
    public static var dbInstanceNotFoundFault: Self { .init(.dbInstanceNotFoundFault) }
    /// The specified RoleArn or FeatureName value is already associated with the DB instance.
    public static var dbInstanceRoleAlreadyExistsFault: Self { .init(.dbInstanceRoleAlreadyExistsFault) }
    /// The specified RoleArn value doesn't match the specified feature for the DB instance.
    public static var dbInstanceRoleNotFoundFault: Self { .init(.dbInstanceRoleNotFoundFault) }
    /// You can't associate any more Amazon Web Services Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.
    public static var dbInstanceRoleQuotaExceededFault: Self { .init(.dbInstanceRoleQuotaExceededFault) }
    ///  LogFileName doesn't refer to an existing DB log file.
    public static var dbLogFileNotFoundFault: Self { .init(.dbLogFileNotFoundFault) }
    /// A DB parameter group with the same name exists.
    public static var dbParameterGroupAlreadyExistsFault: Self { .init(.dbParameterGroupAlreadyExistsFault) }
    ///  DBParameterGroupName doesn't refer to an existing DB parameter group.
    public static var dbParameterGroupNotFoundFault: Self { .init(.dbParameterGroupNotFoundFault) }
    /// The request would result in the user exceeding the allowed number of DB parameter groups.
    public static var dbParameterGroupQuotaExceededFault: Self { .init(.dbParameterGroupQuotaExceededFault) }
    /// The specified proxy name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyAlreadyExistsFault: Self { .init(.dbProxyAlreadyExistsFault) }
    /// The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyEndpointAlreadyExistsFault: Self { .init(.dbProxyEndpointAlreadyExistsFault) }
    /// The DB proxy endpoint doesn't exist.
    public static var dbProxyEndpointNotFoundFault: Self { .init(.dbProxyEndpointNotFoundFault) }
    /// The DB proxy already has the maximum number of endpoints.
    public static var dbProxyEndpointQuotaExceededFault: Self { .init(.dbProxyEndpointQuotaExceededFault) }
    /// The specified proxy name doesn't correspond to a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyNotFoundFault: Self { .init(.dbProxyNotFoundFault) }
    /// Your Amazon Web Services account already has the maximum number of proxies in the specified Amazon Web Services Region.
    public static var dbProxyQuotaExceededFault: Self { .init(.dbProxyQuotaExceededFault) }
    /// The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.
    public static var dbProxyTargetAlreadyRegisteredFault: Self { .init(.dbProxyTargetAlreadyRegisteredFault) }
    /// The specified target group isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyTargetGroupNotFoundFault: Self { .init(.dbProxyTargetGroupNotFoundFault) }
    /// The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbProxyTargetNotFoundFault: Self { .init(.dbProxyTargetNotFoundFault) }
    /// A DB security group with the name specified in DBSecurityGroupName already exists.
    public static var dbSecurityGroupAlreadyExistsFault: Self { .init(.dbSecurityGroupAlreadyExistsFault) }
    ///  DBSecurityGroupName doesn't refer to an existing DB security group.
    public static var dbSecurityGroupNotFoundFault: Self { .init(.dbSecurityGroupNotFoundFault) }
    /// A DB security group isn't allowed for this action.
    public static var dbSecurityGroupNotSupportedFault: Self { .init(.dbSecurityGroupNotSupportedFault) }
    /// The request would result in the user exceeding the allowed number of DB security groups.
    public static var dbSecurityGroupQuotaExceededFault: Self { .init(.dbSecurityGroupQuotaExceededFault) }
    /// The specified DB shard group name must be unique in your Amazon Web Services account in the specified Amazon Web Services Region.
    public static var dbShardGroupAlreadyExistsFault: Self { .init(.dbShardGroupAlreadyExistsFault) }
    /// The specified DB shard group name wasn't found.
    public static var dbShardGroupNotFoundFault: Self { .init(.dbShardGroupNotFoundFault) }
    ///  DBSnapshotIdentifier is already used by an existing snapshot.
    public static var dbSnapshotAlreadyExistsFault: Self { .init(.dbSnapshotAlreadyExistsFault) }
    ///  DBSnapshotIdentifier doesn't refer to an existing DB snapshot.
    public static var dbSnapshotNotFoundFault: Self { .init(.dbSnapshotNotFoundFault) }
    /// The specified snapshot tenant database wasn't found.
    public static var dbSnapshotTenantDatabaseNotFoundFault: Self { .init(.dbSnapshotTenantDatabaseNotFoundFault) }
    ///  DBSubnetGroupName is already used by an existing DB subnet group.
    public static var dbSubnetGroupAlreadyExistsFault: Self { .init(.dbSubnetGroupAlreadyExistsFault) }
    /// Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.
    public static var dbSubnetGroupDoesNotCoverEnoughAZs: Self { .init(.dbSubnetGroupDoesNotCoverEnoughAZs) }
    /// The DBSubnetGroup shouldn't be specified while creating read replicas that lie in the same region as the source instance.
    public static var dbSubnetGroupNotAllowedFault: Self { .init(.dbSubnetGroupNotAllowedFault) }
    ///  DBSubnetGroupName doesn't refer to an existing DB subnet group.
    public static var dbSubnetGroupNotFoundFault: Self { .init(.dbSubnetGroupNotFoundFault) }
    /// The request would result in the user exceeding the allowed number of DB subnet groups.
    public static var dbSubnetGroupQuotaExceededFault: Self { .init(.dbSubnetGroupQuotaExceededFault) }
    /// The request would result in the user exceeding the allowed number of subnets in a DB subnet groups.
    public static var dbSubnetQuotaExceededFault: Self { .init(.dbSubnetQuotaExceededFault) }
    /// The DB upgrade failed because a resource the DB depends on can't be modified.
    public static var dbUpgradeDependencyFailureFault: Self { .init(.dbUpgradeDependencyFailureFault) }
    ///  Domain doesn't refer to an existing Active Directory domain.
    public static var domainNotFoundFault: Self { .init(.domainNotFoundFault) }
    /// The AMI configuration prerequisite has not been met.
    public static var ec2ImagePropertiesNotSupportedFault: Self { .init(.ec2ImagePropertiesNotSupportedFault) }
    /// You have reached the maximum number of event subscriptions.
    public static var eventSubscriptionQuotaExceededFault: Self { .init(.eventSubscriptionQuotaExceededFault) }
    /// You can't start an export task that's already running.
    public static var exportTaskAlreadyExistsFault: Self { .init(.exportTaskAlreadyExistsFault) }
    /// The export task doesn't exist.
    public static var exportTaskNotFoundFault: Self { .init(.exportTaskNotFoundFault) }
    /// The GlobalClusterIdentifier already exists. Choose a new global database identifier (unique name) to create a new global database cluster.
    public static var globalClusterAlreadyExistsFault: Self { .init(.globalClusterAlreadyExistsFault) }
    /// The GlobalClusterIdentifier doesn't refer to an existing global database cluster.
    public static var globalClusterNotFoundFault: Self { .init(.globalClusterNotFoundFault) }
    /// The number of global database clusters for this account is already at the maximum allowed.
    public static var globalClusterQuotaExceededFault: Self { .init(.globalClusterQuotaExceededFault) }
    /// The IAM role requires additional permissions to export to an Amazon S3 bucket.
    public static var iamRoleMissingPermissionsFault: Self { .init(.iamRoleMissingPermissionsFault) }
    /// The IAM role is missing for exporting to an Amazon S3 bucket.
    public static var iamRoleNotFoundFault: Self { .init(.iamRoleNotFoundFault) }
    /// The request would result in the user exceeding the allowed number of DB instances.
    public static var instanceQuotaExceededFault: Self { .init(.instanceQuotaExceededFault) }
    /// The requested operation can't be performed because there aren't enough available IP addresses  in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required  from the subnets.
    public static var insufficientAvailableIPsInSubnetFault: Self { .init(.insufficientAvailableIPsInSubnetFault) }
    /// The DB cluster doesn't have enough capacity for the current operation.
    public static var insufficientDBClusterCapacityFault: Self { .init(.insufficientDBClusterCapacityFault) }
    /// The specified DB instance class isn't available in the specified Availability Zone.
    public static var insufficientDBInstanceCapacityFault: Self { .init(.insufficientDBInstanceCapacityFault) }
    /// There is insufficient storage available for the current action. You might be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.
    public static var insufficientStorageClusterCapacityFault: Self { .init(.insufficientStorageClusterCapacityFault) }
    /// The integration you are trying to create already exists.
    public static var integrationAlreadyExistsFault: Self { .init(.integrationAlreadyExistsFault) }
    /// A conflicting conditional operation is currently in progress against this resource. Typically occurs when there are multiple requests being made to the same resource at the same time, and these requests conflict with each other.
    public static var integrationConflictOperationFault: Self { .init(.integrationConflictOperationFault) }
    /// The specified integration could not be found.
    public static var integrationNotFoundFault: Self { .init(.integrationNotFoundFault) }
    /// You can't crate any more zero-ETL integrations because the quota has been reached.
    public static var integrationQuotaExceededFault: Self { .init(.integrationQuotaExceededFault) }
    /// The blue/green deployment can't be switched over or deleted because there is an invalid configuration in  the green environment.
    public static var invalidBlueGreenDeploymentStateFault: Self { .init(.invalidBlueGreenDeploymentStateFault) }
    /// You can't delete the CEV.
    public static var invalidCustomDBEngineVersionStateFault: Self { .init(.invalidCustomDBEngineVersionStateFault) }
    /// The automated backup is in an invalid state.  For example, this automated backup is associated with an active cluster.
    public static var invalidDBClusterAutomatedBackupStateFault: Self { .init(.invalidDBClusterAutomatedBackupStateFault) }
    ///  Capacity isn't a valid Aurora Serverless DB cluster capacity. Valid capacity values are 2, 4, 8, 16,  32, 64, 128, and 256.
    public static var invalidDBClusterCapacityFault: Self { .init(.invalidDBClusterCapacityFault) }
    /// The requested operation can't be performed on the endpoint while the endpoint is in this state.
    public static var invalidDBClusterEndpointStateFault: Self { .init(.invalidDBClusterEndpointStateFault) }
    /// The supplied value isn't a valid DB cluster snapshot state.
    public static var invalidDBClusterSnapshotStateFault: Self { .init(.invalidDBClusterSnapshotStateFault) }
    /// The requested operation can't be performed while the cluster is in this state.
    public static var invalidDBClusterStateFault: Self { .init(.invalidDBClusterStateFault) }
    /// The automated backup is in an invalid state.  For example, this automated backup is associated with an active instance.
    public static var invalidDBInstanceAutomatedBackupStateFault: Self { .init(.invalidDBInstanceAutomatedBackupStateFault) }
    /// The DB instance isn't in a valid state.
    public static var invalidDBInstanceStateFault: Self { .init(.invalidDBInstanceStateFault) }
    /// The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you can't delete it when the parameter group is in this state.
    public static var invalidDBParameterGroupStateFault: Self { .init(.invalidDBParameterGroupStateFault) }
    /// You can't perform this operation while the DB proxy endpoint is in a particular state.
    public static var invalidDBProxyEndpointStateFault: Self { .init(.invalidDBProxyEndpointStateFault) }
    /// The requested operation can't be performed while the proxy is in this state.
    public static var invalidDBProxyStateFault: Self { .init(.invalidDBProxyStateFault) }
    /// The state of the DB security group doesn't allow deletion.
    public static var invalidDBSecurityGroupStateFault: Self { .init(.invalidDBSecurityGroupStateFault) }
    /// The DB shard group must be in the available state.
    public static var invalidDBShardGroupStateFault: Self { .init(.invalidDBShardGroupStateFault) }
    /// The state of the DB snapshot doesn't allow deletion.
    public static var invalidDBSnapshotStateFault: Self { .init(.invalidDBSnapshotStateFault) }
    /// The DBSubnetGroup doesn't belong to the same VPC as that of an existing cross-region read replica of the same source instance.
    public static var invalidDBSubnetGroupFault: Self { .init(.invalidDBSubnetGroupFault) }
    /// The DB subnet group cannot be deleted because it's in use.
    public static var invalidDBSubnetGroupStateFault: Self { .init(.invalidDBSubnetGroupStateFault) }
    /// The DB subnet isn't in the available state.
    public static var invalidDBSubnetStateFault: Self { .init(.invalidDBSubnetStateFault) }
    /// This error can occur if someone else is modifying a subscription. You should retry the action.
    public static var invalidEventSubscriptionStateFault: Self { .init(.invalidEventSubscriptionStateFault) }
    /// The export is invalid for exporting to an Amazon S3 bucket.
    public static var invalidExportOnlyFault: Self { .init(.invalidExportOnlyFault) }
    /// The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.
    public static var invalidExportSourceStateFault: Self { .init(.invalidExportSourceStateFault) }
    /// You can't cancel an export task that has completed.
    public static var invalidExportTaskStateFault: Self { .init(.invalidExportTaskStateFault) }
    /// The global cluster is in an invalid state and can't perform the requested operation.
    public static var invalidGlobalClusterStateFault: Self { .init(.invalidGlobalClusterStateFault) }
    /// The integration is in an invalid state and can't perform the requested operation.
    public static var invalidIntegrationStateFault: Self { .init(.invalidIntegrationStateFault) }
    /// The maximum capacity of the DB shard group must be 48-7168 Aurora capacity units (ACUs).
    public static var invalidMaxAcuFault: Self { .init(.invalidMaxAcuFault) }
    /// The option group isn't in the available state.
    public static var invalidOptionGroupStateFault: Self { .init(.invalidOptionGroupStateFault) }
    /// The operation can't be performed because another operation is in progress.
    public static var invalidResourceStateFault: Self { .init(.invalidResourceStateFault) }
    /// Cannot restore from VPC backup to non-VPC DB instance.
    public static var invalidRestoreFault: Self { .init(.invalidRestoreFault) }
    /// The specified Amazon S3 bucket name can't be found or Amazon RDS isn't authorized to access the specified Amazon S3 bucket. Verify the SourceS3BucketName and S3IngestionRoleArn values and try again.
    public static var invalidS3BucketFault: Self { .init(.invalidS3BucketFault) }
    /// The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    /// The DB subnet group doesn't cover all Availability Zones after it's created because of users' change.
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    /// An error occurred accessing an Amazon Web Services KMS key.
    public static var kmsKeyNotAccessibleFault: Self { .init(.kmsKeyNotAccessibleFault) }
    /// The maximum number of DB shard groups for your Amazon Web Services account in the specified Amazon Web Services Region has been reached.
    public static var maxDBShardGroupLimitReached: Self { .init(.maxDBShardGroupLimitReached) }
    /// The network type is invalid for the DB instance. Valid nework type values are IPV4 and DUAL.
    public static var networkTypeNotSupported: Self { .init(.networkTypeNotSupported) }
    /// The option group you are trying to create already exists.
    public static var optionGroupAlreadyExistsFault: Self { .init(.optionGroupAlreadyExistsFault) }
    /// The specified option group could not be found.
    public static var optionGroupNotFoundFault: Self { .init(.optionGroupNotFoundFault) }
    /// The quota of 20 option groups was exceeded for this Amazon Web Services account.
    public static var optionGroupQuotaExceededFault: Self { .init(.optionGroupQuotaExceededFault) }
    ///  SourceDBInstanceIdentifier refers to a DB instance with BackupRetentionPeriod equal to 0.
    public static var pointInTimeRestoreNotEnabledFault: Self { .init(.pointInTimeRestoreNotEnabledFault) }
    /// Provisioned IOPS not available in the specified Availability Zone.
    public static var provisionedIopsNotAvailableInAZFault: Self { .init(.provisionedIopsNotAvailableInAZFault) }
    /// User already has a reservation with the given identifier.
    public static var reservedDBInstanceAlreadyExistsFault: Self { .init(.reservedDBInstanceAlreadyExistsFault) }
    /// The specified reserved DB Instance not found.
    public static var reservedDBInstanceNotFoundFault: Self { .init(.reservedDBInstanceNotFoundFault) }
    /// Request would exceed the user's DB Instance quota.
    public static var reservedDBInstanceQuotaExceededFault: Self { .init(.reservedDBInstanceQuotaExceededFault) }
    /// Specified offering does not exist.
    public static var reservedDBInstancesOfferingNotFoundFault: Self { .init(.reservedDBInstancesOfferingNotFoundFault) }
    /// The specified resource ID was not found.
    public static var resourceNotFoundFault: Self { .init(.resourceNotFoundFault) }
    /// You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.
    public static var sharedSnapshotQuotaExceededFault: Self { .init(.sharedSnapshotQuotaExceededFault) }
    /// The request would result in the user exceeding the allowed number of DB snapshots.
    public static var snapshotQuotaExceededFault: Self { .init(.snapshotQuotaExceededFault) }
    /// SNS has responded that there is a problem with the SNS topic specified.
    public static var snsInvalidTopicFault: Self { .init(.snsInvalidTopicFault) }
    /// You do not have permission to publish to the SNS topic ARN.
    public static var snsNoAuthorizationFault: Self { .init(.snsNoAuthorizationFault) }
    /// The SNS topic ARN does not exist.
    public static var snsTopicArnNotFoundFault: Self { .init(.snsTopicArnNotFoundFault) }
    /// The source DB cluster isn't supported for a blue/green deployment.
    public static var sourceClusterNotSupportedFault: Self { .init(.sourceClusterNotSupportedFault) }
    /// The source DB instance isn't supported for a blue/green deployment.
    public static var sourceDatabaseNotSupportedFault: Self { .init(.sourceDatabaseNotSupportedFault) }
    /// The requested source could not be found.
    public static var sourceNotFoundFault: Self { .init(.sourceNotFoundFault) }
    /// The request would result in the user exceeding the allowed amount of storage available across all DB instances.
    public static var storageQuotaExceededFault: Self { .init(.storageQuotaExceededFault) }
    /// The aurora-iopt1 storage type isn't available, because you modified the DB cluster  to use this storage type less than one month ago.
    public static var storageTypeNotAvailableFault: Self { .init(.storageTypeNotAvailableFault) }
    /// The specified StorageType can't be associated with the DB instance.
    public static var storageTypeNotSupportedFault: Self { .init(.storageTypeNotSupportedFault) }
    /// The DB subnet is already in use in the Availability Zone.
    public static var subnetAlreadyInUse: Self { .init(.subnetAlreadyInUse) }
    /// The supplied subscription name already exists.
    public static var subscriptionAlreadyExistFault: Self { .init(.subscriptionAlreadyExistFault) }
    /// The supplied category does not exist.
    public static var subscriptionCategoryNotFoundFault: Self { .init(.subscriptionCategoryNotFoundFault) }
    /// The subscription name does not exist.
    public static var subscriptionNotFoundFault: Self { .init(.subscriptionNotFoundFault) }
    /// You attempted to either create a tenant database that already exists or   modify a tenant database to use the name of an existing tenant database.
    public static var tenantDatabaseAlreadyExistsFault: Self { .init(.tenantDatabaseAlreadyExistsFault) }
    /// The specified tenant database wasn't found in the DB instance.
    public static var tenantDatabaseNotFoundFault: Self { .init(.tenantDatabaseNotFoundFault) }
    /// You attempted to create more tenant databases than are permitted in your Amazon Web Services account.
    public static var tenantDatabaseQuotaExceededFault: Self { .init(.tenantDatabaseQuotaExceededFault) }
    /// The specified DB engine version isn't supported for Aurora Limitless Database.
    public static var unsupportedDBEngineVersionFault: Self { .init(.unsupportedDBEngineVersionFault) }
}

extension RDSErrorType: Equatable {
    public static func == (lhs: RDSErrorType, rhs: RDSErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RDSErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
